(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendors-node_modules_symfony_stimulus-bridge_dist_index_js-node_modules_core-js_modules_es_da-09fde6"],{

/***/ "./node_modules/@hotwired/stimulus/dist/stimulus.js":
/*!**********************************************************!*\
  !*** ./node_modules/@hotwired/stimulus/dist/stimulus.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Application": () => (/* binding */ Application),
/* harmony export */   "AttributeObserver": () => (/* binding */ AttributeObserver),
/* harmony export */   "Context": () => (/* binding */ Context),
/* harmony export */   "Controller": () => (/* binding */ Controller),
/* harmony export */   "ElementObserver": () => (/* binding */ ElementObserver),
/* harmony export */   "IndexedMultimap": () => (/* binding */ IndexedMultimap),
/* harmony export */   "Multimap": () => (/* binding */ Multimap),
/* harmony export */   "SelectorObserver": () => (/* binding */ SelectorObserver),
/* harmony export */   "StringMapObserver": () => (/* binding */ StringMapObserver),
/* harmony export */   "TokenListObserver": () => (/* binding */ TokenListObserver),
/* harmony export */   "ValueListObserver": () => (/* binding */ ValueListObserver),
/* harmony export */   "add": () => (/* binding */ add),
/* harmony export */   "defaultSchema": () => (/* binding */ defaultSchema),
/* harmony export */   "del": () => (/* binding */ del),
/* harmony export */   "fetch": () => (/* binding */ fetch),
/* harmony export */   "prune": () => (/* binding */ prune)
/* harmony export */ });
/*
Stimulus 3.2.1
Copyright Â© 2022 Basecamp, LLC
 */
class EventListener {
    constructor(eventTarget, eventName, eventOptions) {
        this.eventTarget = eventTarget;
        this.eventName = eventName;
        this.eventOptions = eventOptions;
        this.unorderedBindings = new Set();
    }
    connect() {
        this.eventTarget.addEventListener(this.eventName, this, this.eventOptions);
    }
    disconnect() {
        this.eventTarget.removeEventListener(this.eventName, this, this.eventOptions);
    }
    bindingConnected(binding) {
        this.unorderedBindings.add(binding);
    }
    bindingDisconnected(binding) {
        this.unorderedBindings.delete(binding);
    }
    handleEvent(event) {
        const extendedEvent = extendEvent(event);
        for (const binding of this.bindings) {
            if (extendedEvent.immediatePropagationStopped) {
                break;
            }
            else {
                binding.handleEvent(extendedEvent);
            }
        }
    }
    hasBindings() {
        return this.unorderedBindings.size > 0;
    }
    get bindings() {
        return Array.from(this.unorderedBindings).sort((left, right) => {
            const leftIndex = left.index, rightIndex = right.index;
            return leftIndex < rightIndex ? -1 : leftIndex > rightIndex ? 1 : 0;
        });
    }
}
function extendEvent(event) {
    if ("immediatePropagationStopped" in event) {
        return event;
    }
    else {
        const { stopImmediatePropagation } = event;
        return Object.assign(event, {
            immediatePropagationStopped: false,
            stopImmediatePropagation() {
                this.immediatePropagationStopped = true;
                stopImmediatePropagation.call(this);
            },
        });
    }
}

class Dispatcher {
    constructor(application) {
        this.application = application;
        this.eventListenerMaps = new Map();
        this.started = false;
    }
    start() {
        if (!this.started) {
            this.started = true;
            this.eventListeners.forEach((eventListener) => eventListener.connect());
        }
    }
    stop() {
        if (this.started) {
            this.started = false;
            this.eventListeners.forEach((eventListener) => eventListener.disconnect());
        }
    }
    get eventListeners() {
        return Array.from(this.eventListenerMaps.values()).reduce((listeners, map) => listeners.concat(Array.from(map.values())), []);
    }
    bindingConnected(binding) {
        this.fetchEventListenerForBinding(binding).bindingConnected(binding);
    }
    bindingDisconnected(binding, clearEventListeners = false) {
        this.fetchEventListenerForBinding(binding).bindingDisconnected(binding);
        if (clearEventListeners)
            this.clearEventListenersForBinding(binding);
    }
    handleError(error, message, detail = {}) {
        this.application.handleError(error, `Error ${message}`, detail);
    }
    clearEventListenersForBinding(binding) {
        const eventListener = this.fetchEventListenerForBinding(binding);
        if (!eventListener.hasBindings()) {
            eventListener.disconnect();
            this.removeMappedEventListenerFor(binding);
        }
    }
    removeMappedEventListenerFor(binding) {
        const { eventTarget, eventName, eventOptions } = binding;
        const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
        const cacheKey = this.cacheKey(eventName, eventOptions);
        eventListenerMap.delete(cacheKey);
        if (eventListenerMap.size == 0)
            this.eventListenerMaps.delete(eventTarget);
    }
    fetchEventListenerForBinding(binding) {
        const { eventTarget, eventName, eventOptions } = binding;
        return this.fetchEventListener(eventTarget, eventName, eventOptions);
    }
    fetchEventListener(eventTarget, eventName, eventOptions) {
        const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
        const cacheKey = this.cacheKey(eventName, eventOptions);
        let eventListener = eventListenerMap.get(cacheKey);
        if (!eventListener) {
            eventListener = this.createEventListener(eventTarget, eventName, eventOptions);
            eventListenerMap.set(cacheKey, eventListener);
        }
        return eventListener;
    }
    createEventListener(eventTarget, eventName, eventOptions) {
        const eventListener = new EventListener(eventTarget, eventName, eventOptions);
        if (this.started) {
            eventListener.connect();
        }
        return eventListener;
    }
    fetchEventListenerMapForEventTarget(eventTarget) {
        let eventListenerMap = this.eventListenerMaps.get(eventTarget);
        if (!eventListenerMap) {
            eventListenerMap = new Map();
            this.eventListenerMaps.set(eventTarget, eventListenerMap);
        }
        return eventListenerMap;
    }
    cacheKey(eventName, eventOptions) {
        const parts = [eventName];
        Object.keys(eventOptions)
            .sort()
            .forEach((key) => {
            parts.push(`${eventOptions[key] ? "" : "!"}${key}`);
        });
        return parts.join(":");
    }
}

const defaultActionDescriptorFilters = {
    stop({ event, value }) {
        if (value)
            event.stopPropagation();
        return true;
    },
    prevent({ event, value }) {
        if (value)
            event.preventDefault();
        return true;
    },
    self({ event, value, element }) {
        if (value) {
            return element === event.target;
        }
        else {
            return true;
        }
    },
};
const descriptorPattern = /^(?:(.+?)(?:\.(.+?))?(?:@(window|document))?->)?(.+?)(?:#([^:]+?))(?::(.+))?$/;
function parseActionDescriptorString(descriptorString) {
    const source = descriptorString.trim();
    const matches = source.match(descriptorPattern) || [];
    let eventName = matches[1];
    let keyFilter = matches[2];
    if (keyFilter && !["keydown", "keyup", "keypress"].includes(eventName)) {
        eventName += `.${keyFilter}`;
        keyFilter = "";
    }
    return {
        eventTarget: parseEventTarget(matches[3]),
        eventName,
        eventOptions: matches[6] ? parseEventOptions(matches[6]) : {},
        identifier: matches[4],
        methodName: matches[5],
        keyFilter,
    };
}
function parseEventTarget(eventTargetName) {
    if (eventTargetName == "window") {
        return window;
    }
    else if (eventTargetName == "document") {
        return document;
    }
}
function parseEventOptions(eventOptions) {
    return eventOptions
        .split(":")
        .reduce((options, token) => Object.assign(options, { [token.replace(/^!/, "")]: !/^!/.test(token) }), {});
}
function stringifyEventTarget(eventTarget) {
    if (eventTarget == window) {
        return "window";
    }
    else if (eventTarget == document) {
        return "document";
    }
}

function camelize(value) {
    return value.replace(/(?:[_-])([a-z0-9])/g, (_, char) => char.toUpperCase());
}
function namespaceCamelize(value) {
    return camelize(value.replace(/--/g, "-").replace(/__/g, "_"));
}
function capitalize(value) {
    return value.charAt(0).toUpperCase() + value.slice(1);
}
function dasherize(value) {
    return value.replace(/([A-Z])/g, (_, char) => `-${char.toLowerCase()}`);
}
function tokenize(value) {
    return value.match(/[^\s]+/g) || [];
}

class Action {
    constructor(element, index, descriptor, schema) {
        this.element = element;
        this.index = index;
        this.eventTarget = descriptor.eventTarget || element;
        this.eventName = descriptor.eventName || getDefaultEventNameForElement(element) || error("missing event name");
        this.eventOptions = descriptor.eventOptions || {};
        this.identifier = descriptor.identifier || error("missing identifier");
        this.methodName = descriptor.methodName || error("missing method name");
        this.keyFilter = descriptor.keyFilter || "";
        this.schema = schema;
    }
    static forToken(token, schema) {
        return new this(token.element, token.index, parseActionDescriptorString(token.content), schema);
    }
    toString() {
        const eventFilter = this.keyFilter ? `.${this.keyFilter}` : "";
        const eventTarget = this.eventTargetName ? `@${this.eventTargetName}` : "";
        return `${this.eventName}${eventFilter}${eventTarget}->${this.identifier}#${this.methodName}`;
    }
    isFilterTarget(event) {
        if (!this.keyFilter) {
            return false;
        }
        const filteres = this.keyFilter.split("+");
        const modifiers = ["meta", "ctrl", "alt", "shift"];
        const [meta, ctrl, alt, shift] = modifiers.map((modifier) => filteres.includes(modifier));
        if (event.metaKey !== meta || event.ctrlKey !== ctrl || event.altKey !== alt || event.shiftKey !== shift) {
            return true;
        }
        const standardFilter = filteres.filter((key) => !modifiers.includes(key))[0];
        if (!standardFilter) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(this.keyMappings, standardFilter)) {
            error(`contains unknown key filter: ${this.keyFilter}`);
        }
        return this.keyMappings[standardFilter].toLowerCase() !== event.key.toLowerCase();
    }
    get params() {
        const params = {};
        const pattern = new RegExp(`^data-${this.identifier}-(.+)-param$`, "i");
        for (const { name, value } of Array.from(this.element.attributes)) {
            const match = name.match(pattern);
            const key = match && match[1];
            if (key) {
                params[camelize(key)] = typecast(value);
            }
        }
        return params;
    }
    get eventTargetName() {
        return stringifyEventTarget(this.eventTarget);
    }
    get keyMappings() {
        return this.schema.keyMappings;
    }
}
const defaultEventNames = {
    a: () => "click",
    button: () => "click",
    form: () => "submit",
    details: () => "toggle",
    input: (e) => (e.getAttribute("type") == "submit" ? "click" : "input"),
    select: () => "change",
    textarea: () => "input",
};
function getDefaultEventNameForElement(element) {
    const tagName = element.tagName.toLowerCase();
    if (tagName in defaultEventNames) {
        return defaultEventNames[tagName](element);
    }
}
function error(message) {
    throw new Error(message);
}
function typecast(value) {
    try {
        return JSON.parse(value);
    }
    catch (o_O) {
        return value;
    }
}

class Binding {
    constructor(context, action) {
        this.context = context;
        this.action = action;
    }
    get index() {
        return this.action.index;
    }
    get eventTarget() {
        return this.action.eventTarget;
    }
    get eventOptions() {
        return this.action.eventOptions;
    }
    get identifier() {
        return this.context.identifier;
    }
    handleEvent(event) {
        if (this.willBeInvokedByEvent(event) && this.applyEventModifiers(event)) {
            this.invokeWithEvent(event);
        }
    }
    get eventName() {
        return this.action.eventName;
    }
    get method() {
        const method = this.controller[this.methodName];
        if (typeof method == "function") {
            return method;
        }
        throw new Error(`Action "${this.action}" references undefined method "${this.methodName}"`);
    }
    applyEventModifiers(event) {
        const { element } = this.action;
        const { actionDescriptorFilters } = this.context.application;
        let passes = true;
        for (const [name, value] of Object.entries(this.eventOptions)) {
            if (name in actionDescriptorFilters) {
                const filter = actionDescriptorFilters[name];
                passes = passes && filter({ name, value, event, element });
            }
            else {
                continue;
            }
        }
        return passes;
    }
    invokeWithEvent(event) {
        const { target, currentTarget } = event;
        try {
            const { params } = this.action;
            const actionEvent = Object.assign(event, { params });
            this.method.call(this.controller, actionEvent);
            this.context.logDebugActivity(this.methodName, { event, target, currentTarget, action: this.methodName });
        }
        catch (error) {
            const { identifier, controller, element, index } = this;
            const detail = { identifier, controller, element, index, event };
            this.context.handleError(error, `invoking action "${this.action}"`, detail);
        }
    }
    willBeInvokedByEvent(event) {
        const eventTarget = event.target;
        if (event instanceof KeyboardEvent && this.action.isFilterTarget(event)) {
            return false;
        }
        if (this.element === eventTarget) {
            return true;
        }
        else if (eventTarget instanceof Element && this.element.contains(eventTarget)) {
            return this.scope.containsElement(eventTarget);
        }
        else {
            return this.scope.containsElement(this.action.element);
        }
    }
    get controller() {
        return this.context.controller;
    }
    get methodName() {
        return this.action.methodName;
    }
    get element() {
        return this.scope.element;
    }
    get scope() {
        return this.context.scope;
    }
}

class ElementObserver {
    constructor(element, delegate) {
        this.mutationObserverInit = { attributes: true, childList: true, subtree: true };
        this.element = element;
        this.started = false;
        this.delegate = delegate;
        this.elements = new Set();
        this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
    }
    start() {
        if (!this.started) {
            this.started = true;
            this.mutationObserver.observe(this.element, this.mutationObserverInit);
            this.refresh();
        }
    }
    pause(callback) {
        if (this.started) {
            this.mutationObserver.disconnect();
            this.started = false;
        }
        callback();
        if (!this.started) {
            this.mutationObserver.observe(this.element, this.mutationObserverInit);
            this.started = true;
        }
    }
    stop() {
        if (this.started) {
            this.mutationObserver.takeRecords();
            this.mutationObserver.disconnect();
            this.started = false;
        }
    }
    refresh() {
        if (this.started) {
            const matches = new Set(this.matchElementsInTree());
            for (const element of Array.from(this.elements)) {
                if (!matches.has(element)) {
                    this.removeElement(element);
                }
            }
            for (const element of Array.from(matches)) {
                this.addElement(element);
            }
        }
    }
    processMutations(mutations) {
        if (this.started) {
            for (const mutation of mutations) {
                this.processMutation(mutation);
            }
        }
    }
    processMutation(mutation) {
        if (mutation.type == "attributes") {
            this.processAttributeChange(mutation.target, mutation.attributeName);
        }
        else if (mutation.type == "childList") {
            this.processRemovedNodes(mutation.removedNodes);
            this.processAddedNodes(mutation.addedNodes);
        }
    }
    processAttributeChange(node, attributeName) {
        const element = node;
        if (this.elements.has(element)) {
            if (this.delegate.elementAttributeChanged && this.matchElement(element)) {
                this.delegate.elementAttributeChanged(element, attributeName);
            }
            else {
                this.removeElement(element);
            }
        }
        else if (this.matchElement(element)) {
            this.addElement(element);
        }
    }
    processRemovedNodes(nodes) {
        for (const node of Array.from(nodes)) {
            const element = this.elementFromNode(node);
            if (element) {
                this.processTree(element, this.removeElement);
            }
        }
    }
    processAddedNodes(nodes) {
        for (const node of Array.from(nodes)) {
            const element = this.elementFromNode(node);
            if (element && this.elementIsActive(element)) {
                this.processTree(element, this.addElement);
            }
        }
    }
    matchElement(element) {
        return this.delegate.matchElement(element);
    }
    matchElementsInTree(tree = this.element) {
        return this.delegate.matchElementsInTree(tree);
    }
    processTree(tree, processor) {
        for (const element of this.matchElementsInTree(tree)) {
            processor.call(this, element);
        }
    }
    elementFromNode(node) {
        if (node.nodeType == Node.ELEMENT_NODE) {
            return node;
        }
    }
    elementIsActive(element) {
        if (element.isConnected != this.element.isConnected) {
            return false;
        }
        else {
            return this.element.contains(element);
        }
    }
    addElement(element) {
        if (!this.elements.has(element)) {
            if (this.elementIsActive(element)) {
                this.elements.add(element);
                if (this.delegate.elementMatched) {
                    this.delegate.elementMatched(element);
                }
            }
        }
    }
    removeElement(element) {
        if (this.elements.has(element)) {
            this.elements.delete(element);
            if (this.delegate.elementUnmatched) {
                this.delegate.elementUnmatched(element);
            }
        }
    }
}

class AttributeObserver {
    constructor(element, attributeName, delegate) {
        this.attributeName = attributeName;
        this.delegate = delegate;
        this.elementObserver = new ElementObserver(element, this);
    }
    get element() {
        return this.elementObserver.element;
    }
    get selector() {
        return `[${this.attributeName}]`;
    }
    start() {
        this.elementObserver.start();
    }
    pause(callback) {
        this.elementObserver.pause(callback);
    }
    stop() {
        this.elementObserver.stop();
    }
    refresh() {
        this.elementObserver.refresh();
    }
    get started() {
        return this.elementObserver.started;
    }
    matchElement(element) {
        return element.hasAttribute(this.attributeName);
    }
    matchElementsInTree(tree) {
        const match = this.matchElement(tree) ? [tree] : [];
        const matches = Array.from(tree.querySelectorAll(this.selector));
        return match.concat(matches);
    }
    elementMatched(element) {
        if (this.delegate.elementMatchedAttribute) {
            this.delegate.elementMatchedAttribute(element, this.attributeName);
        }
    }
    elementUnmatched(element) {
        if (this.delegate.elementUnmatchedAttribute) {
            this.delegate.elementUnmatchedAttribute(element, this.attributeName);
        }
    }
    elementAttributeChanged(element, attributeName) {
        if (this.delegate.elementAttributeValueChanged && this.attributeName == attributeName) {
            this.delegate.elementAttributeValueChanged(element, attributeName);
        }
    }
}

function add(map, key, value) {
    fetch(map, key).add(value);
}
function del(map, key, value) {
    fetch(map, key).delete(value);
    prune(map, key);
}
function fetch(map, key) {
    let values = map.get(key);
    if (!values) {
        values = new Set();
        map.set(key, values);
    }
    return values;
}
function prune(map, key) {
    const values = map.get(key);
    if (values != null && values.size == 0) {
        map.delete(key);
    }
}

class Multimap {
    constructor() {
        this.valuesByKey = new Map();
    }
    get keys() {
        return Array.from(this.valuesByKey.keys());
    }
    get values() {
        const sets = Array.from(this.valuesByKey.values());
        return sets.reduce((values, set) => values.concat(Array.from(set)), []);
    }
    get size() {
        const sets = Array.from(this.valuesByKey.values());
        return sets.reduce((size, set) => size + set.size, 0);
    }
    add(key, value) {
        add(this.valuesByKey, key, value);
    }
    delete(key, value) {
        del(this.valuesByKey, key, value);
    }
    has(key, value) {
        const values = this.valuesByKey.get(key);
        return values != null && values.has(value);
    }
    hasKey(key) {
        return this.valuesByKey.has(key);
    }
    hasValue(value) {
        const sets = Array.from(this.valuesByKey.values());
        return sets.some((set) => set.has(value));
    }
    getValuesForKey(key) {
        const values = this.valuesByKey.get(key);
        return values ? Array.from(values) : [];
    }
    getKeysForValue(value) {
        return Array.from(this.valuesByKey)
            .filter(([_key, values]) => values.has(value))
            .map(([key, _values]) => key);
    }
}

class IndexedMultimap extends Multimap {
    constructor() {
        super();
        this.keysByValue = new Map();
    }
    get values() {
        return Array.from(this.keysByValue.keys());
    }
    add(key, value) {
        super.add(key, value);
        add(this.keysByValue, value, key);
    }
    delete(key, value) {
        super.delete(key, value);
        del(this.keysByValue, value, key);
    }
    hasValue(value) {
        return this.keysByValue.has(value);
    }
    getKeysForValue(value) {
        const set = this.keysByValue.get(value);
        return set ? Array.from(set) : [];
    }
}

class SelectorObserver {
    constructor(element, selector, delegate, details = {}) {
        this.selector = selector;
        this.details = details;
        this.elementObserver = new ElementObserver(element, this);
        this.delegate = delegate;
        this.matchesByElement = new Multimap();
    }
    get started() {
        return this.elementObserver.started;
    }
    start() {
        this.elementObserver.start();
    }
    pause(callback) {
        this.elementObserver.pause(callback);
    }
    stop() {
        this.elementObserver.stop();
    }
    refresh() {
        this.elementObserver.refresh();
    }
    get element() {
        return this.elementObserver.element;
    }
    matchElement(element) {
        const matches = element.matches(this.selector);
        if (this.delegate.selectorMatchElement) {
            return matches && this.delegate.selectorMatchElement(element, this.details);
        }
        return matches;
    }
    matchElementsInTree(tree) {
        const match = this.matchElement(tree) ? [tree] : [];
        const matches = Array.from(tree.querySelectorAll(this.selector)).filter((match) => this.matchElement(match));
        return match.concat(matches);
    }
    elementMatched(element) {
        this.selectorMatched(element);
    }
    elementUnmatched(element) {
        this.selectorUnmatched(element);
    }
    elementAttributeChanged(element, _attributeName) {
        const matches = this.matchElement(element);
        const matchedBefore = this.matchesByElement.has(this.selector, element);
        if (!matches && matchedBefore) {
            this.selectorUnmatched(element);
        }
    }
    selectorMatched(element) {
        if (this.delegate.selectorMatched) {
            this.delegate.selectorMatched(element, this.selector, this.details);
            this.matchesByElement.add(this.selector, element);
        }
    }
    selectorUnmatched(element) {
        this.delegate.selectorUnmatched(element, this.selector, this.details);
        this.matchesByElement.delete(this.selector, element);
    }
}

class StringMapObserver {
    constructor(element, delegate) {
        this.element = element;
        this.delegate = delegate;
        this.started = false;
        this.stringMap = new Map();
        this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
    }
    start() {
        if (!this.started) {
            this.started = true;
            this.mutationObserver.observe(this.element, { attributes: true, attributeOldValue: true });
            this.refresh();
        }
    }
    stop() {
        if (this.started) {
            this.mutationObserver.takeRecords();
            this.mutationObserver.disconnect();
            this.started = false;
        }
    }
    refresh() {
        if (this.started) {
            for (const attributeName of this.knownAttributeNames) {
                this.refreshAttribute(attributeName, null);
            }
        }
    }
    processMutations(mutations) {
        if (this.started) {
            for (const mutation of mutations) {
                this.processMutation(mutation);
            }
        }
    }
    processMutation(mutation) {
        const attributeName = mutation.attributeName;
        if (attributeName) {
            this.refreshAttribute(attributeName, mutation.oldValue);
        }
    }
    refreshAttribute(attributeName, oldValue) {
        const key = this.delegate.getStringMapKeyForAttribute(attributeName);
        if (key != null) {
            if (!this.stringMap.has(attributeName)) {
                this.stringMapKeyAdded(key, attributeName);
            }
            const value = this.element.getAttribute(attributeName);
            if (this.stringMap.get(attributeName) != value) {
                this.stringMapValueChanged(value, key, oldValue);
            }
            if (value == null) {
                const oldValue = this.stringMap.get(attributeName);
                this.stringMap.delete(attributeName);
                if (oldValue)
                    this.stringMapKeyRemoved(key, attributeName, oldValue);
            }
            else {
                this.stringMap.set(attributeName, value);
            }
        }
    }
    stringMapKeyAdded(key, attributeName) {
        if (this.delegate.stringMapKeyAdded) {
            this.delegate.stringMapKeyAdded(key, attributeName);
        }
    }
    stringMapValueChanged(value, key, oldValue) {
        if (this.delegate.stringMapValueChanged) {
            this.delegate.stringMapValueChanged(value, key, oldValue);
        }
    }
    stringMapKeyRemoved(key, attributeName, oldValue) {
        if (this.delegate.stringMapKeyRemoved) {
            this.delegate.stringMapKeyRemoved(key, attributeName, oldValue);
        }
    }
    get knownAttributeNames() {
        return Array.from(new Set(this.currentAttributeNames.concat(this.recordedAttributeNames)));
    }
    get currentAttributeNames() {
        return Array.from(this.element.attributes).map((attribute) => attribute.name);
    }
    get recordedAttributeNames() {
        return Array.from(this.stringMap.keys());
    }
}

class TokenListObserver {
    constructor(element, attributeName, delegate) {
        this.attributeObserver = new AttributeObserver(element, attributeName, this);
        this.delegate = delegate;
        this.tokensByElement = new Multimap();
    }
    get started() {
        return this.attributeObserver.started;
    }
    start() {
        this.attributeObserver.start();
    }
    pause(callback) {
        this.attributeObserver.pause(callback);
    }
    stop() {
        this.attributeObserver.stop();
    }
    refresh() {
        this.attributeObserver.refresh();
    }
    get element() {
        return this.attributeObserver.element;
    }
    get attributeName() {
        return this.attributeObserver.attributeName;
    }
    elementMatchedAttribute(element) {
        this.tokensMatched(this.readTokensForElement(element));
    }
    elementAttributeValueChanged(element) {
        const [unmatchedTokens, matchedTokens] = this.refreshTokensForElement(element);
        this.tokensUnmatched(unmatchedTokens);
        this.tokensMatched(matchedTokens);
    }
    elementUnmatchedAttribute(element) {
        this.tokensUnmatched(this.tokensByElement.getValuesForKey(element));
    }
    tokensMatched(tokens) {
        tokens.forEach((token) => this.tokenMatched(token));
    }
    tokensUnmatched(tokens) {
        tokens.forEach((token) => this.tokenUnmatched(token));
    }
    tokenMatched(token) {
        this.delegate.tokenMatched(token);
        this.tokensByElement.add(token.element, token);
    }
    tokenUnmatched(token) {
        this.delegate.tokenUnmatched(token);
        this.tokensByElement.delete(token.element, token);
    }
    refreshTokensForElement(element) {
        const previousTokens = this.tokensByElement.getValuesForKey(element);
        const currentTokens = this.readTokensForElement(element);
        const firstDifferingIndex = zip(previousTokens, currentTokens).findIndex(([previousToken, currentToken]) => !tokensAreEqual(previousToken, currentToken));
        if (firstDifferingIndex == -1) {
            return [[], []];
        }
        else {
            return [previousTokens.slice(firstDifferingIndex), currentTokens.slice(firstDifferingIndex)];
        }
    }
    readTokensForElement(element) {
        const attributeName = this.attributeName;
        const tokenString = element.getAttribute(attributeName) || "";
        return parseTokenString(tokenString, element, attributeName);
    }
}
function parseTokenString(tokenString, element, attributeName) {
    return tokenString
        .trim()
        .split(/\s+/)
        .filter((content) => content.length)
        .map((content, index) => ({ element, attributeName, content, index }));
}
function zip(left, right) {
    const length = Math.max(left.length, right.length);
    return Array.from({ length }, (_, index) => [left[index], right[index]]);
}
function tokensAreEqual(left, right) {
    return left && right && left.index == right.index && left.content == right.content;
}

class ValueListObserver {
    constructor(element, attributeName, delegate) {
        this.tokenListObserver = new TokenListObserver(element, attributeName, this);
        this.delegate = delegate;
        this.parseResultsByToken = new WeakMap();
        this.valuesByTokenByElement = new WeakMap();
    }
    get started() {
        return this.tokenListObserver.started;
    }
    start() {
        this.tokenListObserver.start();
    }
    stop() {
        this.tokenListObserver.stop();
    }
    refresh() {
        this.tokenListObserver.refresh();
    }
    get element() {
        return this.tokenListObserver.element;
    }
    get attributeName() {
        return this.tokenListObserver.attributeName;
    }
    tokenMatched(token) {
        const { element } = token;
        const { value } = this.fetchParseResultForToken(token);
        if (value) {
            this.fetchValuesByTokenForElement(element).set(token, value);
            this.delegate.elementMatchedValue(element, value);
        }
    }
    tokenUnmatched(token) {
        const { element } = token;
        const { value } = this.fetchParseResultForToken(token);
        if (value) {
            this.fetchValuesByTokenForElement(element).delete(token);
            this.delegate.elementUnmatchedValue(element, value);
        }
    }
    fetchParseResultForToken(token) {
        let parseResult = this.parseResultsByToken.get(token);
        if (!parseResult) {
            parseResult = this.parseToken(token);
            this.parseResultsByToken.set(token, parseResult);
        }
        return parseResult;
    }
    fetchValuesByTokenForElement(element) {
        let valuesByToken = this.valuesByTokenByElement.get(element);
        if (!valuesByToken) {
            valuesByToken = new Map();
            this.valuesByTokenByElement.set(element, valuesByToken);
        }
        return valuesByToken;
    }
    parseToken(token) {
        try {
            const value = this.delegate.parseValueForToken(token);
            return { value };
        }
        catch (error) {
            return { error };
        }
    }
}

class BindingObserver {
    constructor(context, delegate) {
        this.context = context;
        this.delegate = delegate;
        this.bindingsByAction = new Map();
    }
    start() {
        if (!this.valueListObserver) {
            this.valueListObserver = new ValueListObserver(this.element, this.actionAttribute, this);
            this.valueListObserver.start();
        }
    }
    stop() {
        if (this.valueListObserver) {
            this.valueListObserver.stop();
            delete this.valueListObserver;
            this.disconnectAllActions();
        }
    }
    get element() {
        return this.context.element;
    }
    get identifier() {
        return this.context.identifier;
    }
    get actionAttribute() {
        return this.schema.actionAttribute;
    }
    get schema() {
        return this.context.schema;
    }
    get bindings() {
        return Array.from(this.bindingsByAction.values());
    }
    connectAction(action) {
        const binding = new Binding(this.context, action);
        this.bindingsByAction.set(action, binding);
        this.delegate.bindingConnected(binding);
    }
    disconnectAction(action) {
        const binding = this.bindingsByAction.get(action);
        if (binding) {
            this.bindingsByAction.delete(action);
            this.delegate.bindingDisconnected(binding);
        }
    }
    disconnectAllActions() {
        this.bindings.forEach((binding) => this.delegate.bindingDisconnected(binding, true));
        this.bindingsByAction.clear();
    }
    parseValueForToken(token) {
        const action = Action.forToken(token, this.schema);
        if (action.identifier == this.identifier) {
            return action;
        }
    }
    elementMatchedValue(element, action) {
        this.connectAction(action);
    }
    elementUnmatchedValue(element, action) {
        this.disconnectAction(action);
    }
}

class ValueObserver {
    constructor(context, receiver) {
        this.context = context;
        this.receiver = receiver;
        this.stringMapObserver = new StringMapObserver(this.element, this);
        this.valueDescriptorMap = this.controller.valueDescriptorMap;
    }
    start() {
        this.stringMapObserver.start();
        this.invokeChangedCallbacksForDefaultValues();
    }
    stop() {
        this.stringMapObserver.stop();
    }
    get element() {
        return this.context.element;
    }
    get controller() {
        return this.context.controller;
    }
    getStringMapKeyForAttribute(attributeName) {
        if (attributeName in this.valueDescriptorMap) {
            return this.valueDescriptorMap[attributeName].name;
        }
    }
    stringMapKeyAdded(key, attributeName) {
        const descriptor = this.valueDescriptorMap[attributeName];
        if (!this.hasValue(key)) {
            this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), descriptor.writer(descriptor.defaultValue));
        }
    }
    stringMapValueChanged(value, name, oldValue) {
        const descriptor = this.valueDescriptorNameMap[name];
        if (value === null)
            return;
        if (oldValue === null) {
            oldValue = descriptor.writer(descriptor.defaultValue);
        }
        this.invokeChangedCallback(name, value, oldValue);
    }
    stringMapKeyRemoved(key, attributeName, oldValue) {
        const descriptor = this.valueDescriptorNameMap[key];
        if (this.hasValue(key)) {
            this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), oldValue);
        }
        else {
            this.invokeChangedCallback(key, descriptor.writer(descriptor.defaultValue), oldValue);
        }
    }
    invokeChangedCallbacksForDefaultValues() {
        for (const { key, name, defaultValue, writer } of this.valueDescriptors) {
            if (defaultValue != undefined && !this.controller.data.has(key)) {
                this.invokeChangedCallback(name, writer(defaultValue), undefined);
            }
        }
    }
    invokeChangedCallback(name, rawValue, rawOldValue) {
        const changedMethodName = `${name}Changed`;
        const changedMethod = this.receiver[changedMethodName];
        if (typeof changedMethod == "function") {
            const descriptor = this.valueDescriptorNameMap[name];
            try {
                const value = descriptor.reader(rawValue);
                let oldValue = rawOldValue;
                if (rawOldValue) {
                    oldValue = descriptor.reader(rawOldValue);
                }
                changedMethod.call(this.receiver, value, oldValue);
            }
            catch (error) {
                if (error instanceof TypeError) {
                    error.message = `Stimulus Value "${this.context.identifier}.${descriptor.name}" - ${error.message}`;
                }
                throw error;
            }
        }
    }
    get valueDescriptors() {
        const { valueDescriptorMap } = this;
        return Object.keys(valueDescriptorMap).map((key) => valueDescriptorMap[key]);
    }
    get valueDescriptorNameMap() {
        const descriptors = {};
        Object.keys(this.valueDescriptorMap).forEach((key) => {
            const descriptor = this.valueDescriptorMap[key];
            descriptors[descriptor.name] = descriptor;
        });
        return descriptors;
    }
    hasValue(attributeName) {
        const descriptor = this.valueDescriptorNameMap[attributeName];
        const hasMethodName = `has${capitalize(descriptor.name)}`;
        return this.receiver[hasMethodName];
    }
}

class TargetObserver {
    constructor(context, delegate) {
        this.context = context;
        this.delegate = delegate;
        this.targetsByName = new Multimap();
    }
    start() {
        if (!this.tokenListObserver) {
            this.tokenListObserver = new TokenListObserver(this.element, this.attributeName, this);
            this.tokenListObserver.start();
        }
    }
    stop() {
        if (this.tokenListObserver) {
            this.disconnectAllTargets();
            this.tokenListObserver.stop();
            delete this.tokenListObserver;
        }
    }
    tokenMatched({ element, content: name }) {
        if (this.scope.containsElement(element)) {
            this.connectTarget(element, name);
        }
    }
    tokenUnmatched({ element, content: name }) {
        this.disconnectTarget(element, name);
    }
    connectTarget(element, name) {
        var _a;
        if (!this.targetsByName.has(name, element)) {
            this.targetsByName.add(name, element);
            (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetConnected(element, name));
        }
    }
    disconnectTarget(element, name) {
        var _a;
        if (this.targetsByName.has(name, element)) {
            this.targetsByName.delete(name, element);
            (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetDisconnected(element, name));
        }
    }
    disconnectAllTargets() {
        for (const name of this.targetsByName.keys) {
            for (const element of this.targetsByName.getValuesForKey(name)) {
                this.disconnectTarget(element, name);
            }
        }
    }
    get attributeName() {
        return `data-${this.context.identifier}-target`;
    }
    get element() {
        return this.context.element;
    }
    get scope() {
        return this.context.scope;
    }
}

function readInheritableStaticArrayValues(constructor, propertyName) {
    const ancestors = getAncestorsForConstructor(constructor);
    return Array.from(ancestors.reduce((values, constructor) => {
        getOwnStaticArrayValues(constructor, propertyName).forEach((name) => values.add(name));
        return values;
    }, new Set()));
}
function readInheritableStaticObjectPairs(constructor, propertyName) {
    const ancestors = getAncestorsForConstructor(constructor);
    return ancestors.reduce((pairs, constructor) => {
        pairs.push(...getOwnStaticObjectPairs(constructor, propertyName));
        return pairs;
    }, []);
}
function getAncestorsForConstructor(constructor) {
    const ancestors = [];
    while (constructor) {
        ancestors.push(constructor);
        constructor = Object.getPrototypeOf(constructor);
    }
    return ancestors.reverse();
}
function getOwnStaticArrayValues(constructor, propertyName) {
    const definition = constructor[propertyName];
    return Array.isArray(definition) ? definition : [];
}
function getOwnStaticObjectPairs(constructor, propertyName) {
    const definition = constructor[propertyName];
    return definition ? Object.keys(definition).map((key) => [key, definition[key]]) : [];
}

class OutletObserver {
    constructor(context, delegate) {
        this.context = context;
        this.delegate = delegate;
        this.outletsByName = new Multimap();
        this.outletElementsByName = new Multimap();
        this.selectorObserverMap = new Map();
    }
    start() {
        if (this.selectorObserverMap.size === 0) {
            this.outletDefinitions.forEach((outletName) => {
                const selector = this.selector(outletName);
                const details = { outletName };
                if (selector) {
                    this.selectorObserverMap.set(outletName, new SelectorObserver(document.body, selector, this, details));
                }
            });
            this.selectorObserverMap.forEach((observer) => observer.start());
        }
        this.dependentContexts.forEach((context) => context.refresh());
    }
    stop() {
        if (this.selectorObserverMap.size > 0) {
            this.disconnectAllOutlets();
            this.selectorObserverMap.forEach((observer) => observer.stop());
            this.selectorObserverMap.clear();
        }
    }
    refresh() {
        this.selectorObserverMap.forEach((observer) => observer.refresh());
    }
    selectorMatched(element, _selector, { outletName }) {
        const outlet = this.getOutlet(element, outletName);
        if (outlet) {
            this.connectOutlet(outlet, element, outletName);
        }
    }
    selectorUnmatched(element, _selector, { outletName }) {
        const outlet = this.getOutletFromMap(element, outletName);
        if (outlet) {
            this.disconnectOutlet(outlet, element, outletName);
        }
    }
    selectorMatchElement(element, { outletName }) {
        return (this.hasOutlet(element, outletName) &&
            element.matches(`[${this.context.application.schema.controllerAttribute}~=${outletName}]`));
    }
    connectOutlet(outlet, element, outletName) {
        var _a;
        if (!this.outletElementsByName.has(outletName, element)) {
            this.outletsByName.add(outletName, outlet);
            this.outletElementsByName.add(outletName, element);
            (_a = this.selectorObserverMap.get(outletName)) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.outletConnected(outlet, element, outletName));
        }
    }
    disconnectOutlet(outlet, element, outletName) {
        var _a;
        if (this.outletElementsByName.has(outletName, element)) {
            this.outletsByName.delete(outletName, outlet);
            this.outletElementsByName.delete(outletName, element);
            (_a = this.selectorObserverMap
                .get(outletName)) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.outletDisconnected(outlet, element, outletName));
        }
    }
    disconnectAllOutlets() {
        for (const outletName of this.outletElementsByName.keys) {
            for (const element of this.outletElementsByName.getValuesForKey(outletName)) {
                for (const outlet of this.outletsByName.getValuesForKey(outletName)) {
                    this.disconnectOutlet(outlet, element, outletName);
                }
            }
        }
    }
    selector(outletName) {
        return this.scope.outlets.getSelectorForOutletName(outletName);
    }
    get outletDependencies() {
        const dependencies = new Multimap();
        this.router.modules.forEach((module) => {
            const constructor = module.definition.controllerConstructor;
            const outlets = readInheritableStaticArrayValues(constructor, "outlets");
            outlets.forEach((outlet) => dependencies.add(outlet, module.identifier));
        });
        return dependencies;
    }
    get outletDefinitions() {
        return this.outletDependencies.getKeysForValue(this.identifier);
    }
    get dependentControllerIdentifiers() {
        return this.outletDependencies.getValuesForKey(this.identifier);
    }
    get dependentContexts() {
        const identifiers = this.dependentControllerIdentifiers;
        return this.router.contexts.filter((context) => identifiers.includes(context.identifier));
    }
    hasOutlet(element, outletName) {
        return !!this.getOutlet(element, outletName) || !!this.getOutletFromMap(element, outletName);
    }
    getOutlet(element, outletName) {
        return this.application.getControllerForElementAndIdentifier(element, outletName);
    }
    getOutletFromMap(element, outletName) {
        return this.outletsByName.getValuesForKey(outletName).find((outlet) => outlet.element === element);
    }
    get scope() {
        return this.context.scope;
    }
    get identifier() {
        return this.context.identifier;
    }
    get application() {
        return this.context.application;
    }
    get router() {
        return this.application.router;
    }
}

class Context {
    constructor(module, scope) {
        this.logDebugActivity = (functionName, detail = {}) => {
            const { identifier, controller, element } = this;
            detail = Object.assign({ identifier, controller, element }, detail);
            this.application.logDebugActivity(this.identifier, functionName, detail);
        };
        this.module = module;
        this.scope = scope;
        this.controller = new module.controllerConstructor(this);
        this.bindingObserver = new BindingObserver(this, this.dispatcher);
        this.valueObserver = new ValueObserver(this, this.controller);
        this.targetObserver = new TargetObserver(this, this);
        this.outletObserver = new OutletObserver(this, this);
        try {
            this.controller.initialize();
            this.logDebugActivity("initialize");
        }
        catch (error) {
            this.handleError(error, "initializing controller");
        }
    }
    connect() {
        this.bindingObserver.start();
        this.valueObserver.start();
        this.targetObserver.start();
        this.outletObserver.start();
        try {
            this.controller.connect();
            this.logDebugActivity("connect");
        }
        catch (error) {
            this.handleError(error, "connecting controller");
        }
    }
    refresh() {
        this.outletObserver.refresh();
    }
    disconnect() {
        try {
            this.controller.disconnect();
            this.logDebugActivity("disconnect");
        }
        catch (error) {
            this.handleError(error, "disconnecting controller");
        }
        this.outletObserver.stop();
        this.targetObserver.stop();
        this.valueObserver.stop();
        this.bindingObserver.stop();
    }
    get application() {
        return this.module.application;
    }
    get identifier() {
        return this.module.identifier;
    }
    get schema() {
        return this.application.schema;
    }
    get dispatcher() {
        return this.application.dispatcher;
    }
    get element() {
        return this.scope.element;
    }
    get parentElement() {
        return this.element.parentElement;
    }
    handleError(error, message, detail = {}) {
        const { identifier, controller, element } = this;
        detail = Object.assign({ identifier, controller, element }, detail);
        this.application.handleError(error, `Error ${message}`, detail);
    }
    targetConnected(element, name) {
        this.invokeControllerMethod(`${name}TargetConnected`, element);
    }
    targetDisconnected(element, name) {
        this.invokeControllerMethod(`${name}TargetDisconnected`, element);
    }
    outletConnected(outlet, element, name) {
        this.invokeControllerMethod(`${namespaceCamelize(name)}OutletConnected`, outlet, element);
    }
    outletDisconnected(outlet, element, name) {
        this.invokeControllerMethod(`${namespaceCamelize(name)}OutletDisconnected`, outlet, element);
    }
    invokeControllerMethod(methodName, ...args) {
        const controller = this.controller;
        if (typeof controller[methodName] == "function") {
            controller[methodName](...args);
        }
    }
}

function bless(constructor) {
    return shadow(constructor, getBlessedProperties(constructor));
}
function shadow(constructor, properties) {
    const shadowConstructor = extend(constructor);
    const shadowProperties = getShadowProperties(constructor.prototype, properties);
    Object.defineProperties(shadowConstructor.prototype, shadowProperties);
    return shadowConstructor;
}
function getBlessedProperties(constructor) {
    const blessings = readInheritableStaticArrayValues(constructor, "blessings");
    return blessings.reduce((blessedProperties, blessing) => {
        const properties = blessing(constructor);
        for (const key in properties) {
            const descriptor = blessedProperties[key] || {};
            blessedProperties[key] = Object.assign(descriptor, properties[key]);
        }
        return blessedProperties;
    }, {});
}
function getShadowProperties(prototype, properties) {
    return getOwnKeys(properties).reduce((shadowProperties, key) => {
        const descriptor = getShadowedDescriptor(prototype, properties, key);
        if (descriptor) {
            Object.assign(shadowProperties, { [key]: descriptor });
        }
        return shadowProperties;
    }, {});
}
function getShadowedDescriptor(prototype, properties, key) {
    const shadowingDescriptor = Object.getOwnPropertyDescriptor(prototype, key);
    const shadowedByValue = shadowingDescriptor && "value" in shadowingDescriptor;
    if (!shadowedByValue) {
        const descriptor = Object.getOwnPropertyDescriptor(properties, key).value;
        if (shadowingDescriptor) {
            descriptor.get = shadowingDescriptor.get || descriptor.get;
            descriptor.set = shadowingDescriptor.set || descriptor.set;
        }
        return descriptor;
    }
}
const getOwnKeys = (() => {
    if (typeof Object.getOwnPropertySymbols == "function") {
        return (object) => [...Object.getOwnPropertyNames(object), ...Object.getOwnPropertySymbols(object)];
    }
    else {
        return Object.getOwnPropertyNames;
    }
})();
const extend = (() => {
    function extendWithReflect(constructor) {
        function extended() {
            return Reflect.construct(constructor, arguments, new.target);
        }
        extended.prototype = Object.create(constructor.prototype, {
            constructor: { value: extended },
        });
        Reflect.setPrototypeOf(extended, constructor);
        return extended;
    }
    function testReflectExtension() {
        const a = function () {
            this.a.call(this);
        };
        const b = extendWithReflect(a);
        b.prototype.a = function () { };
        return new b();
    }
    try {
        testReflectExtension();
        return extendWithReflect;
    }
    catch (error) {
        return (constructor) => class extended extends constructor {
        };
    }
})();

function blessDefinition(definition) {
    return {
        identifier: definition.identifier,
        controllerConstructor: bless(definition.controllerConstructor),
    };
}

class Module {
    constructor(application, definition) {
        this.application = application;
        this.definition = blessDefinition(definition);
        this.contextsByScope = new WeakMap();
        this.connectedContexts = new Set();
    }
    get identifier() {
        return this.definition.identifier;
    }
    get controllerConstructor() {
        return this.definition.controllerConstructor;
    }
    get contexts() {
        return Array.from(this.connectedContexts);
    }
    connectContextForScope(scope) {
        const context = this.fetchContextForScope(scope);
        this.connectedContexts.add(context);
        context.connect();
    }
    disconnectContextForScope(scope) {
        const context = this.contextsByScope.get(scope);
        if (context) {
            this.connectedContexts.delete(context);
            context.disconnect();
        }
    }
    fetchContextForScope(scope) {
        let context = this.contextsByScope.get(scope);
        if (!context) {
            context = new Context(this, scope);
            this.contextsByScope.set(scope, context);
        }
        return context;
    }
}

class ClassMap {
    constructor(scope) {
        this.scope = scope;
    }
    has(name) {
        return this.data.has(this.getDataKey(name));
    }
    get(name) {
        return this.getAll(name)[0];
    }
    getAll(name) {
        const tokenString = this.data.get(this.getDataKey(name)) || "";
        return tokenize(tokenString);
    }
    getAttributeName(name) {
        return this.data.getAttributeNameForKey(this.getDataKey(name));
    }
    getDataKey(name) {
        return `${name}-class`;
    }
    get data() {
        return this.scope.data;
    }
}

class DataMap {
    constructor(scope) {
        this.scope = scope;
    }
    get element() {
        return this.scope.element;
    }
    get identifier() {
        return this.scope.identifier;
    }
    get(key) {
        const name = this.getAttributeNameForKey(key);
        return this.element.getAttribute(name);
    }
    set(key, value) {
        const name = this.getAttributeNameForKey(key);
        this.element.setAttribute(name, value);
        return this.get(key);
    }
    has(key) {
        const name = this.getAttributeNameForKey(key);
        return this.element.hasAttribute(name);
    }
    delete(key) {
        if (this.has(key)) {
            const name = this.getAttributeNameForKey(key);
            this.element.removeAttribute(name);
            return true;
        }
        else {
            return false;
        }
    }
    getAttributeNameForKey(key) {
        return `data-${this.identifier}-${dasherize(key)}`;
    }
}

class Guide {
    constructor(logger) {
        this.warnedKeysByObject = new WeakMap();
        this.logger = logger;
    }
    warn(object, key, message) {
        let warnedKeys = this.warnedKeysByObject.get(object);
        if (!warnedKeys) {
            warnedKeys = new Set();
            this.warnedKeysByObject.set(object, warnedKeys);
        }
        if (!warnedKeys.has(key)) {
            warnedKeys.add(key);
            this.logger.warn(message, object);
        }
    }
}

function attributeValueContainsToken(attributeName, token) {
    return `[${attributeName}~="${token}"]`;
}

class TargetSet {
    constructor(scope) {
        this.scope = scope;
    }
    get element() {
        return this.scope.element;
    }
    get identifier() {
        return this.scope.identifier;
    }
    get schema() {
        return this.scope.schema;
    }
    has(targetName) {
        return this.find(targetName) != null;
    }
    find(...targetNames) {
        return targetNames.reduce((target, targetName) => target || this.findTarget(targetName) || this.findLegacyTarget(targetName), undefined);
    }
    findAll(...targetNames) {
        return targetNames.reduce((targets, targetName) => [
            ...targets,
            ...this.findAllTargets(targetName),
            ...this.findAllLegacyTargets(targetName),
        ], []);
    }
    findTarget(targetName) {
        const selector = this.getSelectorForTargetName(targetName);
        return this.scope.findElement(selector);
    }
    findAllTargets(targetName) {
        const selector = this.getSelectorForTargetName(targetName);
        return this.scope.findAllElements(selector);
    }
    getSelectorForTargetName(targetName) {
        const attributeName = this.schema.targetAttributeForScope(this.identifier);
        return attributeValueContainsToken(attributeName, targetName);
    }
    findLegacyTarget(targetName) {
        const selector = this.getLegacySelectorForTargetName(targetName);
        return this.deprecate(this.scope.findElement(selector), targetName);
    }
    findAllLegacyTargets(targetName) {
        const selector = this.getLegacySelectorForTargetName(targetName);
        return this.scope.findAllElements(selector).map((element) => this.deprecate(element, targetName));
    }
    getLegacySelectorForTargetName(targetName) {
        const targetDescriptor = `${this.identifier}.${targetName}`;
        return attributeValueContainsToken(this.schema.targetAttribute, targetDescriptor);
    }
    deprecate(element, targetName) {
        if (element) {
            const { identifier } = this;
            const attributeName = this.schema.targetAttribute;
            const revisedAttributeName = this.schema.targetAttributeForScope(identifier);
            this.guide.warn(element, `target:${targetName}`, `Please replace ${attributeName}="${identifier}.${targetName}" with ${revisedAttributeName}="${targetName}". ` +
                `The ${attributeName} attribute is deprecated and will be removed in a future version of Stimulus.`);
        }
        return element;
    }
    get guide() {
        return this.scope.guide;
    }
}

class OutletSet {
    constructor(scope, controllerElement) {
        this.scope = scope;
        this.controllerElement = controllerElement;
    }
    get element() {
        return this.scope.element;
    }
    get identifier() {
        return this.scope.identifier;
    }
    get schema() {
        return this.scope.schema;
    }
    has(outletName) {
        return this.find(outletName) != null;
    }
    find(...outletNames) {
        return outletNames.reduce((outlet, outletName) => outlet || this.findOutlet(outletName), undefined);
    }
    findAll(...outletNames) {
        return outletNames.reduce((outlets, outletName) => [...outlets, ...this.findAllOutlets(outletName)], []);
    }
    getSelectorForOutletName(outletName) {
        const attributeName = this.schema.outletAttributeForScope(this.identifier, outletName);
        return this.controllerElement.getAttribute(attributeName);
    }
    findOutlet(outletName) {
        const selector = this.getSelectorForOutletName(outletName);
        if (selector)
            return this.findElement(selector, outletName);
    }
    findAllOutlets(outletName) {
        const selector = this.getSelectorForOutletName(outletName);
        return selector ? this.findAllElements(selector, outletName) : [];
    }
    findElement(selector, outletName) {
        const elements = this.scope.queryElements(selector);
        return elements.filter((element) => this.matchesElement(element, selector, outletName))[0];
    }
    findAllElements(selector, outletName) {
        const elements = this.scope.queryElements(selector);
        return elements.filter((element) => this.matchesElement(element, selector, outletName));
    }
    matchesElement(element, selector, outletName) {
        const controllerAttribute = element.getAttribute(this.scope.schema.controllerAttribute) || "";
        return element.matches(selector) && controllerAttribute.split(" ").includes(outletName);
    }
}

class Scope {
    constructor(schema, element, identifier, logger) {
        this.targets = new TargetSet(this);
        this.classes = new ClassMap(this);
        this.data = new DataMap(this);
        this.containsElement = (element) => {
            return element.closest(this.controllerSelector) === this.element;
        };
        this.schema = schema;
        this.element = element;
        this.identifier = identifier;
        this.guide = new Guide(logger);
        this.outlets = new OutletSet(this.documentScope, element);
    }
    findElement(selector) {
        return this.element.matches(selector) ? this.element : this.queryElements(selector).find(this.containsElement);
    }
    findAllElements(selector) {
        return [
            ...(this.element.matches(selector) ? [this.element] : []),
            ...this.queryElements(selector).filter(this.containsElement),
        ];
    }
    queryElements(selector) {
        return Array.from(this.element.querySelectorAll(selector));
    }
    get controllerSelector() {
        return attributeValueContainsToken(this.schema.controllerAttribute, this.identifier);
    }
    get isDocumentScope() {
        return this.element === document.documentElement;
    }
    get documentScope() {
        return this.isDocumentScope
            ? this
            : new Scope(this.schema, document.documentElement, this.identifier, this.guide.logger);
    }
}

class ScopeObserver {
    constructor(element, schema, delegate) {
        this.element = element;
        this.schema = schema;
        this.delegate = delegate;
        this.valueListObserver = new ValueListObserver(this.element, this.controllerAttribute, this);
        this.scopesByIdentifierByElement = new WeakMap();
        this.scopeReferenceCounts = new WeakMap();
    }
    start() {
        this.valueListObserver.start();
    }
    stop() {
        this.valueListObserver.stop();
    }
    get controllerAttribute() {
        return this.schema.controllerAttribute;
    }
    parseValueForToken(token) {
        const { element, content: identifier } = token;
        const scopesByIdentifier = this.fetchScopesByIdentifierForElement(element);
        let scope = scopesByIdentifier.get(identifier);
        if (!scope) {
            scope = this.delegate.createScopeForElementAndIdentifier(element, identifier);
            scopesByIdentifier.set(identifier, scope);
        }
        return scope;
    }
    elementMatchedValue(element, value) {
        const referenceCount = (this.scopeReferenceCounts.get(value) || 0) + 1;
        this.scopeReferenceCounts.set(value, referenceCount);
        if (referenceCount == 1) {
            this.delegate.scopeConnected(value);
        }
    }
    elementUnmatchedValue(element, value) {
        const referenceCount = this.scopeReferenceCounts.get(value);
        if (referenceCount) {
            this.scopeReferenceCounts.set(value, referenceCount - 1);
            if (referenceCount == 1) {
                this.delegate.scopeDisconnected(value);
            }
        }
    }
    fetchScopesByIdentifierForElement(element) {
        let scopesByIdentifier = this.scopesByIdentifierByElement.get(element);
        if (!scopesByIdentifier) {
            scopesByIdentifier = new Map();
            this.scopesByIdentifierByElement.set(element, scopesByIdentifier);
        }
        return scopesByIdentifier;
    }
}

class Router {
    constructor(application) {
        this.application = application;
        this.scopeObserver = new ScopeObserver(this.element, this.schema, this);
        this.scopesByIdentifier = new Multimap();
        this.modulesByIdentifier = new Map();
    }
    get element() {
        return this.application.element;
    }
    get schema() {
        return this.application.schema;
    }
    get logger() {
        return this.application.logger;
    }
    get controllerAttribute() {
        return this.schema.controllerAttribute;
    }
    get modules() {
        return Array.from(this.modulesByIdentifier.values());
    }
    get contexts() {
        return this.modules.reduce((contexts, module) => contexts.concat(module.contexts), []);
    }
    start() {
        this.scopeObserver.start();
    }
    stop() {
        this.scopeObserver.stop();
    }
    loadDefinition(definition) {
        this.unloadIdentifier(definition.identifier);
        const module = new Module(this.application, definition);
        this.connectModule(module);
        const afterLoad = definition.controllerConstructor.afterLoad;
        if (afterLoad) {
            afterLoad(definition.identifier, this.application);
        }
    }
    unloadIdentifier(identifier) {
        const module = this.modulesByIdentifier.get(identifier);
        if (module) {
            this.disconnectModule(module);
        }
    }
    getContextForElementAndIdentifier(element, identifier) {
        const module = this.modulesByIdentifier.get(identifier);
        if (module) {
            return module.contexts.find((context) => context.element == element);
        }
    }
    handleError(error, message, detail) {
        this.application.handleError(error, message, detail);
    }
    createScopeForElementAndIdentifier(element, identifier) {
        return new Scope(this.schema, element, identifier, this.logger);
    }
    scopeConnected(scope) {
        this.scopesByIdentifier.add(scope.identifier, scope);
        const module = this.modulesByIdentifier.get(scope.identifier);
        if (module) {
            module.connectContextForScope(scope);
        }
    }
    scopeDisconnected(scope) {
        this.scopesByIdentifier.delete(scope.identifier, scope);
        const module = this.modulesByIdentifier.get(scope.identifier);
        if (module) {
            module.disconnectContextForScope(scope);
        }
    }
    connectModule(module) {
        this.modulesByIdentifier.set(module.identifier, module);
        const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
        scopes.forEach((scope) => module.connectContextForScope(scope));
    }
    disconnectModule(module) {
        this.modulesByIdentifier.delete(module.identifier);
        const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
        scopes.forEach((scope) => module.disconnectContextForScope(scope));
    }
}

const defaultSchema = {
    controllerAttribute: "data-controller",
    actionAttribute: "data-action",
    targetAttribute: "data-target",
    targetAttributeForScope: (identifier) => `data-${identifier}-target`,
    outletAttributeForScope: (identifier, outlet) => `data-${identifier}-${outlet}-outlet`,
    keyMappings: Object.assign(Object.assign({ enter: "Enter", tab: "Tab", esc: "Escape", space: " ", up: "ArrowUp", down: "ArrowDown", left: "ArrowLeft", right: "ArrowRight", home: "Home", end: "End" }, objectFromEntries("abcdefghijklmnopqrstuvwxyz".split("").map((c) => [c, c]))), objectFromEntries("0123456789".split("").map((n) => [n, n]))),
};
function objectFromEntries(array) {
    return array.reduce((memo, [k, v]) => (Object.assign(Object.assign({}, memo), { [k]: v })), {});
}

class Application {
    constructor(element = document.documentElement, schema = defaultSchema) {
        this.logger = console;
        this.debug = false;
        this.logDebugActivity = (identifier, functionName, detail = {}) => {
            if (this.debug) {
                this.logFormattedMessage(identifier, functionName, detail);
            }
        };
        this.element = element;
        this.schema = schema;
        this.dispatcher = new Dispatcher(this);
        this.router = new Router(this);
        this.actionDescriptorFilters = Object.assign({}, defaultActionDescriptorFilters);
    }
    static start(element, schema) {
        const application = new this(element, schema);
        application.start();
        return application;
    }
    async start() {
        await domReady();
        this.logDebugActivity("application", "starting");
        this.dispatcher.start();
        this.router.start();
        this.logDebugActivity("application", "start");
    }
    stop() {
        this.logDebugActivity("application", "stopping");
        this.dispatcher.stop();
        this.router.stop();
        this.logDebugActivity("application", "stop");
    }
    register(identifier, controllerConstructor) {
        this.load({ identifier, controllerConstructor });
    }
    registerActionOption(name, filter) {
        this.actionDescriptorFilters[name] = filter;
    }
    load(head, ...rest) {
        const definitions = Array.isArray(head) ? head : [head, ...rest];
        definitions.forEach((definition) => {
            if (definition.controllerConstructor.shouldLoad) {
                this.router.loadDefinition(definition);
            }
        });
    }
    unload(head, ...rest) {
        const identifiers = Array.isArray(head) ? head : [head, ...rest];
        identifiers.forEach((identifier) => this.router.unloadIdentifier(identifier));
    }
    get controllers() {
        return this.router.contexts.map((context) => context.controller);
    }
    getControllerForElementAndIdentifier(element, identifier) {
        const context = this.router.getContextForElementAndIdentifier(element, identifier);
        return context ? context.controller : null;
    }
    handleError(error, message, detail) {
        var _a;
        this.logger.error(`%s\n\n%o\n\n%o`, message, error, detail);
        (_a = window.onerror) === null || _a === void 0 ? void 0 : _a.call(window, message, "", 0, 0, error);
    }
    logFormattedMessage(identifier, functionName, detail = {}) {
        detail = Object.assign({ application: this }, detail);
        this.logger.groupCollapsed(`${identifier} #${functionName}`);
        this.logger.log("details:", Object.assign({}, detail));
        this.logger.groupEnd();
    }
}
function domReady() {
    return new Promise((resolve) => {
        if (document.readyState == "loading") {
            document.addEventListener("DOMContentLoaded", () => resolve());
        }
        else {
            resolve();
        }
    });
}

function ClassPropertiesBlessing(constructor) {
    const classes = readInheritableStaticArrayValues(constructor, "classes");
    return classes.reduce((properties, classDefinition) => {
        return Object.assign(properties, propertiesForClassDefinition(classDefinition));
    }, {});
}
function propertiesForClassDefinition(key) {
    return {
        [`${key}Class`]: {
            get() {
                const { classes } = this;
                if (classes.has(key)) {
                    return classes.get(key);
                }
                else {
                    const attribute = classes.getAttributeName(key);
                    throw new Error(`Missing attribute "${attribute}"`);
                }
            },
        },
        [`${key}Classes`]: {
            get() {
                return this.classes.getAll(key);
            },
        },
        [`has${capitalize(key)}Class`]: {
            get() {
                return this.classes.has(key);
            },
        },
    };
}

function OutletPropertiesBlessing(constructor) {
    const outlets = readInheritableStaticArrayValues(constructor, "outlets");
    return outlets.reduce((properties, outletDefinition) => {
        return Object.assign(properties, propertiesForOutletDefinition(outletDefinition));
    }, {});
}
function propertiesForOutletDefinition(name) {
    const camelizedName = namespaceCamelize(name);
    return {
        [`${camelizedName}Outlet`]: {
            get() {
                const outlet = this.outlets.find(name);
                if (outlet) {
                    const outletController = this.application.getControllerForElementAndIdentifier(outlet, name);
                    if (outletController) {
                        return outletController;
                    }
                    else {
                        throw new Error(`Missing "data-controller=${name}" attribute on outlet element for "${this.identifier}" controller`);
                    }
                }
                throw new Error(`Missing outlet element "${name}" for "${this.identifier}" controller`);
            },
        },
        [`${camelizedName}Outlets`]: {
            get() {
                const outlets = this.outlets.findAll(name);
                if (outlets.length > 0) {
                    return outlets
                        .map((outlet) => {
                        const controller = this.application.getControllerForElementAndIdentifier(outlet, name);
                        if (controller) {
                            return controller;
                        }
                        else {
                            console.warn(`The provided outlet element is missing the outlet controller "${name}" for "${this.identifier}"`, outlet);
                        }
                    })
                        .filter((controller) => controller);
                }
                return [];
            },
        },
        [`${camelizedName}OutletElement`]: {
            get() {
                const outlet = this.outlets.find(name);
                if (outlet) {
                    return outlet;
                }
                else {
                    throw new Error(`Missing outlet element "${name}" for "${this.identifier}" controller`);
                }
            },
        },
        [`${camelizedName}OutletElements`]: {
            get() {
                return this.outlets.findAll(name);
            },
        },
        [`has${capitalize(camelizedName)}Outlet`]: {
            get() {
                return this.outlets.has(name);
            },
        },
    };
}

function TargetPropertiesBlessing(constructor) {
    const targets = readInheritableStaticArrayValues(constructor, "targets");
    return targets.reduce((properties, targetDefinition) => {
        return Object.assign(properties, propertiesForTargetDefinition(targetDefinition));
    }, {});
}
function propertiesForTargetDefinition(name) {
    return {
        [`${name}Target`]: {
            get() {
                const target = this.targets.find(name);
                if (target) {
                    return target;
                }
                else {
                    throw new Error(`Missing target element "${name}" for "${this.identifier}" controller`);
                }
            },
        },
        [`${name}Targets`]: {
            get() {
                return this.targets.findAll(name);
            },
        },
        [`has${capitalize(name)}Target`]: {
            get() {
                return this.targets.has(name);
            },
        },
    };
}

function ValuePropertiesBlessing(constructor) {
    const valueDefinitionPairs = readInheritableStaticObjectPairs(constructor, "values");
    const propertyDescriptorMap = {
        valueDescriptorMap: {
            get() {
                return valueDefinitionPairs.reduce((result, valueDefinitionPair) => {
                    const valueDescriptor = parseValueDefinitionPair(valueDefinitionPair, this.identifier);
                    const attributeName = this.data.getAttributeNameForKey(valueDescriptor.key);
                    return Object.assign(result, { [attributeName]: valueDescriptor });
                }, {});
            },
        },
    };
    return valueDefinitionPairs.reduce((properties, valueDefinitionPair) => {
        return Object.assign(properties, propertiesForValueDefinitionPair(valueDefinitionPair));
    }, propertyDescriptorMap);
}
function propertiesForValueDefinitionPair(valueDefinitionPair, controller) {
    const definition = parseValueDefinitionPair(valueDefinitionPair, controller);
    const { key, name, reader: read, writer: write } = definition;
    return {
        [name]: {
            get() {
                const value = this.data.get(key);
                if (value !== null) {
                    return read(value);
                }
                else {
                    return definition.defaultValue;
                }
            },
            set(value) {
                if (value === undefined) {
                    this.data.delete(key);
                }
                else {
                    this.data.set(key, write(value));
                }
            },
        },
        [`has${capitalize(name)}`]: {
            get() {
                return this.data.has(key) || definition.hasCustomDefaultValue;
            },
        },
    };
}
function parseValueDefinitionPair([token, typeDefinition], controller) {
    return valueDescriptorForTokenAndTypeDefinition({
        controller,
        token,
        typeDefinition,
    });
}
function parseValueTypeConstant(constant) {
    switch (constant) {
        case Array:
            return "array";
        case Boolean:
            return "boolean";
        case Number:
            return "number";
        case Object:
            return "object";
        case String:
            return "string";
    }
}
function parseValueTypeDefault(defaultValue) {
    switch (typeof defaultValue) {
        case "boolean":
            return "boolean";
        case "number":
            return "number";
        case "string":
            return "string";
    }
    if (Array.isArray(defaultValue))
        return "array";
    if (Object.prototype.toString.call(defaultValue) === "[object Object]")
        return "object";
}
function parseValueTypeObject(payload) {
    const typeFromObject = parseValueTypeConstant(payload.typeObject.type);
    if (!typeFromObject)
        return;
    const defaultValueType = parseValueTypeDefault(payload.typeObject.default);
    if (typeFromObject !== defaultValueType) {
        const propertyPath = payload.controller ? `${payload.controller}.${payload.token}` : payload.token;
        throw new Error(`The specified default value for the Stimulus Value "${propertyPath}" must match the defined type "${typeFromObject}". The provided default value of "${payload.typeObject.default}" is of type "${defaultValueType}".`);
    }
    return typeFromObject;
}
function parseValueTypeDefinition(payload) {
    const typeFromObject = parseValueTypeObject({
        controller: payload.controller,
        token: payload.token,
        typeObject: payload.typeDefinition,
    });
    const typeFromDefaultValue = parseValueTypeDefault(payload.typeDefinition);
    const typeFromConstant = parseValueTypeConstant(payload.typeDefinition);
    const type = typeFromObject || typeFromDefaultValue || typeFromConstant;
    if (type)
        return type;
    const propertyPath = payload.controller ? `${payload.controller}.${payload.typeDefinition}` : payload.token;
    throw new Error(`Unknown value type "${propertyPath}" for "${payload.token}" value`);
}
function defaultValueForDefinition(typeDefinition) {
    const constant = parseValueTypeConstant(typeDefinition);
    if (constant)
        return defaultValuesByType[constant];
    const defaultValue = typeDefinition.default;
    if (defaultValue !== undefined)
        return defaultValue;
    return typeDefinition;
}
function valueDescriptorForTokenAndTypeDefinition(payload) {
    const key = `${dasherize(payload.token)}-value`;
    const type = parseValueTypeDefinition(payload);
    return {
        type,
        key,
        name: camelize(key),
        get defaultValue() {
            return defaultValueForDefinition(payload.typeDefinition);
        },
        get hasCustomDefaultValue() {
            return parseValueTypeDefault(payload.typeDefinition) !== undefined;
        },
        reader: readers[type],
        writer: writers[type] || writers.default,
    };
}
const defaultValuesByType = {
    get array() {
        return [];
    },
    boolean: false,
    number: 0,
    get object() {
        return {};
    },
    string: "",
};
const readers = {
    array(value) {
        const array = JSON.parse(value);
        if (!Array.isArray(array)) {
            throw new TypeError(`expected value of type "array" but instead got value "${value}" of type "${parseValueTypeDefault(array)}"`);
        }
        return array;
    },
    boolean(value) {
        return !(value == "0" || String(value).toLowerCase() == "false");
    },
    number(value) {
        return Number(value);
    },
    object(value) {
        const object = JSON.parse(value);
        if (object === null || typeof object != "object" || Array.isArray(object)) {
            throw new TypeError(`expected value of type "object" but instead got value "${value}" of type "${parseValueTypeDefault(object)}"`);
        }
        return object;
    },
    string(value) {
        return value;
    },
};
const writers = {
    default: writeString,
    array: writeJSON,
    object: writeJSON,
};
function writeJSON(value) {
    return JSON.stringify(value);
}
function writeString(value) {
    return `${value}`;
}

class Controller {
    constructor(context) {
        this.context = context;
    }
    static get shouldLoad() {
        return true;
    }
    static afterLoad(_identifier, _application) {
        return;
    }
    get application() {
        return this.context.application;
    }
    get scope() {
        return this.context.scope;
    }
    get element() {
        return this.scope.element;
    }
    get identifier() {
        return this.scope.identifier;
    }
    get targets() {
        return this.scope.targets;
    }
    get outlets() {
        return this.scope.outlets;
    }
    get classes() {
        return this.scope.classes;
    }
    get data() {
        return this.scope.data;
    }
    initialize() {
    }
    connect() {
    }
    disconnect() {
    }
    dispatch(eventName, { target = this.element, detail = {}, prefix = this.identifier, bubbles = true, cancelable = true } = {}) {
        const type = prefix ? `${prefix}:${eventName}` : eventName;
        const event = new CustomEvent(type, { detail, bubbles, cancelable });
        target.dispatchEvent(event);
        return event;
    }
}
Controller.blessings = [
    ClassPropertiesBlessing,
    TargetPropertiesBlessing,
    ValuePropertiesBlessing,
    OutletPropertiesBlessing,
];
Controller.targets = [];
Controller.outlets = [];
Controller.values = {};




/***/ }),

/***/ "./node_modules/@symfony/stimulus-bridge/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@symfony/stimulus-bridge/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "startStimulusApp": () => (/* binding */ startStimulusApp)
/* harmony export */ });
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");
/* harmony import */ var _webpack_loader_symfony_stimulus_bridge_controllers_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webpack/loader!@symfony/stimulus-bridge/controllers.json */ "./node_modules/@symfony/stimulus-bridge/dist/webpack/loader.js!./assets/controllers.json");



/*
Stimulus Webpack Helpers 1.0.0
Copyright Â© 2021 Basecamp, LLC
 */
function definitionsFromContext(context) {
    return context.keys()
        .map((key) => definitionForModuleWithContextAndKey(context, key))
        .filter((value) => value);
}
function definitionForModuleWithContextAndKey(context, key) {
    const identifier = identifierForContextKey(key);
    if (identifier) {
        return definitionForModuleAndIdentifier(context(key), identifier);
    }
}
function definitionForModuleAndIdentifier(module, identifier) {
    const controllerConstructor = module.default;
    if (typeof controllerConstructor == "function") {
        return { identifier, controllerConstructor };
    }
}
function identifierForContextKey(key) {
    const logicalName = (key.match(/^(?:\.\/)?(.+)(?:[_-]controller\..+?)$/) || [])[1];
    if (logicalName) {
        return logicalName.replace(/_/g, "-").replace(/\//g, "--");
    }
}

function startStimulusApp(context) {
    const application = _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Application.start();
    if (true) {
        application.debug = true;
    }
    if (context) {
        application.load(definitionsFromContext(context));
    }
    for (const controllerName in _webpack_loader_symfony_stimulus_bridge_controllers_json__WEBPACK_IMPORTED_MODULE_1__["default"]) {
        if (!_webpack_loader_symfony_stimulus_bridge_controllers_json__WEBPACK_IMPORTED_MODULE_1__["default"].hasOwnProperty(controllerName)) {
            continue;
        }
        application.register(controllerName, _webpack_loader_symfony_stimulus_bridge_controllers_json__WEBPACK_IMPORTED_MODULE_1__["default"][controllerName]);
    }
    return application;
}




/***/ }),

/***/ "./node_modules/core-js/internals/a-callable.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/a-callable.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var tryToString = __webpack_require__(/*! ../internals/try-to-string */ "./node_modules/core-js/internals/try-to-string.js");

var $TypeError = TypeError;

// `Assert: IsCallable(argument) is true`
module.exports = function (argument) {
  if (isCallable(argument)) return argument;
  throw $TypeError(tryToString(argument) + ' is not a function');
};


/***/ }),

/***/ "./node_modules/core-js/internals/a-constructor.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/a-constructor.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isConstructor = __webpack_require__(/*! ../internals/is-constructor */ "./node_modules/core-js/internals/is-constructor.js");
var tryToString = __webpack_require__(/*! ../internals/try-to-string */ "./node_modules/core-js/internals/try-to-string.js");

var $TypeError = TypeError;

// `Assert: IsConstructor(argument) is true`
module.exports = function (argument) {
  if (isConstructor(argument)) return argument;
  throw $TypeError(tryToString(argument) + ' is not a constructor');
};


/***/ }),

/***/ "./node_modules/core-js/internals/a-possible-prototype.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/a-possible-prototype.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");

var $String = String;
var $TypeError = TypeError;

module.exports = function (argument) {
  if (typeof argument == 'object' || isCallable(argument)) return argument;
  throw $TypeError("Can't set " + $String(argument) + ' as a prototype');
};


/***/ }),

/***/ "./node_modules/core-js/internals/add-to-unscopables.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/internals/add-to-unscopables.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f);

var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype = Array.prototype;

// Array.prototype[@@unscopables]
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype[UNSCOPABLES] == undefined) {
  defineProperty(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: create(null)
  });
}

// add a key to Array.prototype[@@unscopables]
module.exports = function (key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};


/***/ }),

/***/ "./node_modules/core-js/internals/an-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/an-object.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var $String = String;
var $TypeError = TypeError;

// `Assert: Type(argument) is Object`
module.exports = function (argument) {
  if (isObject(argument)) return argument;
  throw $TypeError($String(argument) + ' is not an object');
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-includes.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/array-includes.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = lengthOfArrayLike(O);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-iteration.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/array-iteration.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");
var arraySpeciesCreate = __webpack_require__(/*! ../internals/array-species-create */ "./node_modules/core-js/internals/array-species-create.js");

var push = uncurryThis([].push);

// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation
var createMethod = function (TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var IS_FILTER_REJECT = TYPE == 7;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self = IndexedObject(O);
    var boundFunction = bind(callbackfn, that);
    var length = lengthOfArrayLike(self);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
    var value, result;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
          case 3: return true;              // some
          case 5: return value;             // find
          case 6: return index;             // findIndex
          case 2: push(target, value);      // filter
        } else switch (TYPE) {
          case 4: return false;             // every
          case 7: push(target, value);      // filterReject
        }
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

module.exports = {
  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  forEach: createMethod(0),
  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  map: createMethod(1),
  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  filter: createMethod(2),
  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  some: createMethod(3),
  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  every: createMethod(4),
  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  find: createMethod(5),
  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod(6),
  // `Array.prototype.filterReject` method
  // https://github.com/tc39/proposal-array-filtering
  filterReject: createMethod(7)
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-slice-simple.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/internals/array-slice-simple.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");

var $Array = Array;
var max = Math.max;

module.exports = function (O, start, end) {
  var length = lengthOfArrayLike(O);
  var k = toAbsoluteIndex(start, length);
  var fin = toAbsoluteIndex(end === undefined ? length : end, length);
  var result = $Array(max(fin - k, 0));
  for (var n = 0; k < fin; k++, n++) createProperty(result, n, O[k]);
  result.length = n;
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-slice.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/array-slice.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

module.exports = uncurryThis([].slice);


/***/ }),

/***/ "./node_modules/core-js/internals/array-species-constructor.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/internals/array-species-constructor.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");
var isConstructor = __webpack_require__(/*! ../internals/is-constructor */ "./node_modules/core-js/internals/is-constructor.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var SPECIES = wellKnownSymbol('species');
var $Array = Array;

// a part of `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray) {
  var C;
  if (isArray(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (isConstructor(C) && (C === $Array || isArray(C.prototype))) C = undefined;
    else if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? $Array : C;
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-species-create.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/array-species-create.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arraySpeciesConstructor = __webpack_require__(/*! ../internals/array-species-constructor */ "./node_modules/core-js/internals/array-species-constructor.js");

// `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray, length) {
  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
};


/***/ }),

/***/ "./node_modules/core-js/internals/classof-raw.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/classof-raw.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

var toString = uncurryThis({}.toString);
var stringSlice = uncurryThis(''.slice);

module.exports = function (it) {
  return stringSlice(toString(it), 8, -1);
};


/***/ }),

/***/ "./node_modules/core-js/internals/classof.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/classof.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ "./node_modules/core-js/internals/to-string-tag-support.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var classofRaw = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var $Object = Object;

// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/copy-constructor-properties.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/internals/copy-constructor-properties.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var ownKeys = __webpack_require__(/*! ../internals/own-keys */ "./node_modules/core-js/internals/own-keys.js");
var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");

module.exports = function (target, source, exceptions) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/correct-prototype-getter.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/correct-prototype-getter.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

module.exports = !fails(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
  return Object.getPrototypeOf(new F()) !== F.prototype;
});


/***/ }),

/***/ "./node_modules/core-js/internals/create-iter-result-object.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/internals/create-iter-result-object.js ***!
  \*********************************************************************/
/***/ ((module) => {

// `CreateIterResultObject` abstract operation
// https://tc39.es/ecma262/#sec-createiterresultobject
module.exports = function (value, done) {
  return { value: value, done: done };
};


/***/ }),

/***/ "./node_modules/core-js/internals/create-non-enumerable-property.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/internals/create-non-enumerable-property.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "./node_modules/core-js/internals/create-property-descriptor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/internals/create-property-descriptor.js ***!
  \**********************************************************************/
/***/ ((module) => {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "./node_modules/core-js/internals/create-property.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/create-property.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ "./node_modules/core-js/internals/to-property-key.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");

module.exports = function (object, key, value) {
  var propertyKey = toPropertyKey(key);
  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
  else object[propertyKey] = value;
};


/***/ }),

/***/ "./node_modules/core-js/internals/date-to-primitive.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/date-to-primitive.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var ordinaryToPrimitive = __webpack_require__(/*! ../internals/ordinary-to-primitive */ "./node_modules/core-js/internals/ordinary-to-primitive.js");

var $TypeError = TypeError;

// `Date.prototype[@@toPrimitive](hint)` method implementation
// https://tc39.es/ecma262/#sec-date.prototype-@@toprimitive
module.exports = function (hint) {
  anObject(this);
  if (hint === 'string' || hint === 'default') hint = 'string';
  else if (hint !== 'number') throw $TypeError('Incorrect hint');
  return ordinaryToPrimitive(this, hint);
};


/***/ }),

/***/ "./node_modules/core-js/internals/define-built-in-accessor.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/define-built-in-accessor.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var makeBuiltIn = __webpack_require__(/*! ../internals/make-built-in */ "./node_modules/core-js/internals/make-built-in.js");
var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");

module.exports = function (target, name, descriptor) {
  if (descriptor.get) makeBuiltIn(descriptor.get, name, { getter: true });
  if (descriptor.set) makeBuiltIn(descriptor.set, name, { setter: true });
  return defineProperty.f(target, name, descriptor);
};


/***/ }),

/***/ "./node_modules/core-js/internals/define-built-in.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/define-built-in.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var makeBuiltIn = __webpack_require__(/*! ../internals/make-built-in */ "./node_modules/core-js/internals/make-built-in.js");
var defineGlobalProperty = __webpack_require__(/*! ../internals/define-global-property */ "./node_modules/core-js/internals/define-global-property.js");

module.exports = function (O, key, value, options) {
  if (!options) options = {};
  var simple = options.enumerable;
  var name = options.name !== undefined ? options.name : key;
  if (isCallable(value)) makeBuiltIn(value, name, options);
  if (options.global) {
    if (simple) O[key] = value;
    else defineGlobalProperty(key, value);
  } else {
    try {
      if (!options.unsafe) delete O[key];
      else if (O[key]) simple = true;
    } catch (error) { /* empty */ }
    if (simple) O[key] = value;
    else definePropertyModule.f(O, key, {
      value: value,
      enumerable: false,
      configurable: !options.nonConfigurable,
      writable: !options.nonWritable
    });
  } return O;
};


/***/ }),

/***/ "./node_modules/core-js/internals/define-global-property.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/define-global-property.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;

module.exports = function (key, value) {
  try {
    defineProperty(global, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ "./node_modules/core-js/internals/descriptors.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/descriptors.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
});


/***/ }),

/***/ "./node_modules/core-js/internals/document-all.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/document-all.js ***!
  \********************************************************/
/***/ ((module) => {

var documentAll = typeof document == 'object' && document.all;

// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing
var IS_HTMLDDA = typeof documentAll == 'undefined' && documentAll !== undefined;

module.exports = {
  all: documentAll,
  IS_HTMLDDA: IS_HTMLDDA
};


/***/ }),

/***/ "./node_modules/core-js/internals/document-create-element.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/document-create-element.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ "./node_modules/core-js/internals/dom-iterables.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/dom-iterables.js ***!
  \*********************************************************/
/***/ ((module) => {

// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
module.exports = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};


/***/ }),

/***/ "./node_modules/core-js/internals/dom-token-list-prototype.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/dom-token-list-prototype.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// in old WebKit versions, `element.classList` is not an instance of global `DOMTokenList`
var documentCreateElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");

var classList = documentCreateElement('span').classList;
var DOMTokenListPrototype = classList && classList.constructor && classList.constructor.prototype;

module.exports = DOMTokenListPrototype === Object.prototype ? undefined : DOMTokenListPrototype;


/***/ }),

/***/ "./node_modules/core-js/internals/engine-user-agent.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/engine-user-agent.js ***!
  \*************************************************************/
/***/ ((module) => {

module.exports = typeof navigator != 'undefined' && String(navigator.userAgent) || '';


/***/ }),

/***/ "./node_modules/core-js/internals/engine-v8-version.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/engine-v8-version.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var userAgent = __webpack_require__(/*! ../internals/engine-user-agent */ "./node_modules/core-js/internals/engine-user-agent.js");

var process = global.process;
var Deno = global.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}

// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version && userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}

module.exports = version;


/***/ }),

/***/ "./node_modules/core-js/internals/enum-bug-keys.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/enum-bug-keys.js ***!
  \*********************************************************/
/***/ ((module) => {

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ "./node_modules/core-js/internals/error-stack-clear.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/error-stack-clear.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

var $Error = Error;
var replace = uncurryThis(''.replace);

var TEST = (function (arg) { return String($Error(arg).stack); })('zxcasd');
// eslint-disable-next-line redos/no-vulnerable -- safe
var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);

module.exports = function (stack, dropEntries) {
  if (IS_V8_OR_CHAKRA_STACK && typeof stack == 'string' && !$Error.prepareStackTrace) {
    while (dropEntries--) stack = replace(stack, V8_OR_CHAKRA_STACK_ENTRY, '');
  } return stack;
};


/***/ }),

/***/ "./node_modules/core-js/internals/error-stack-install.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/error-stack-install.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var clearErrorStack = __webpack_require__(/*! ../internals/error-stack-clear */ "./node_modules/core-js/internals/error-stack-clear.js");
var ERROR_STACK_INSTALLABLE = __webpack_require__(/*! ../internals/error-stack-installable */ "./node_modules/core-js/internals/error-stack-installable.js");

// non-standard V8
var captureStackTrace = Error.captureStackTrace;

module.exports = function (error, C, stack, dropEntries) {
  if (ERROR_STACK_INSTALLABLE) {
    if (captureStackTrace) captureStackTrace(error, C);
    else createNonEnumerableProperty(error, 'stack', clearErrorStack(stack, dropEntries));
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/error-stack-installable.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/error-stack-installable.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");

module.exports = !fails(function () {
  var error = Error('a');
  if (!('stack' in error)) return true;
  // eslint-disable-next-line es/no-object-defineproperty -- safe
  Object.defineProperty(error, 'stack', createPropertyDescriptor(1, 7));
  return error.stack !== 7;
});


/***/ }),

/***/ "./node_modules/core-js/internals/error-to-string.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/error-to-string.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var normalizeStringArgument = __webpack_require__(/*! ../internals/normalize-string-argument */ "./node_modules/core-js/internals/normalize-string-argument.js");

var nativeErrorToString = Error.prototype.toString;

var INCORRECT_TO_STRING = fails(function () {
  if (DESCRIPTORS) {
    // Chrome 32- incorrectly call accessor
    // eslint-disable-next-line es/no-object-defineproperty -- safe
    var object = create(Object.defineProperty({}, 'name', { get: function () {
      return this === object;
    } }));
    if (nativeErrorToString.call(object) !== 'true') return true;
  }
  // FF10- does not properly handle non-strings
  return nativeErrorToString.call({ message: 1, name: 2 }) !== '2: 1'
    // IE8 does not properly handle defaults
    || nativeErrorToString.call({}) !== 'Error';
});

module.exports = INCORRECT_TO_STRING ? function toString() {
  var O = anObject(this);
  var name = normalizeStringArgument(O.name, 'Error');
  var message = normalizeStringArgument(O.message);
  return !name ? message : !message ? name : name + ': ' + message;
} : nativeErrorToString;


/***/ }),

/***/ "./node_modules/core-js/internals/export.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/export.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var getOwnPropertyDescriptor = (__webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f);
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");
var defineGlobalProperty = __webpack_require__(/*! ../internals/define-global-property */ "./node_modules/core-js/internals/define-global-property.js");
var copyConstructorProperties = __webpack_require__(/*! ../internals/copy-constructor-properties */ "./node_modules/core-js/internals/copy-constructor-properties.js");
var isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");

/*
  options.target         - name of the target object
  options.global         - target is the global object
  options.stat           - export as static methods of target
  options.proto          - export as prototype methods of target
  options.real           - real prototype method for the `pure` version
  options.forced         - export even if the native feature is available
  options.bind           - bind methods to the target, required for the `pure` version
  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
  options.sham           - add a flag to not completely full polyfills
  options.enumerable     - export as enumerable property
  options.dontCallGetSet - prevent calling a getter on target
  options.name           - the .name of the function if it does not match the key
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || defineGlobalProperty(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.dontCallGetSet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty == typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    defineBuiltIn(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/fails.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/internals/fails.js ***!
  \*************************************************/
/***/ ((module) => {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/function-apply.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/function-apply.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js/internals/function-bind-native.js");

var FunctionPrototype = Function.prototype;
var apply = FunctionPrototype.apply;
var call = FunctionPrototype.call;

// eslint-disable-next-line es/no-reflect -- safe
module.exports = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function () {
  return call.apply(apply, arguments);
});


/***/ }),

/***/ "./node_modules/core-js/internals/function-bind-context.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/function-bind-context.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this-clause */ "./node_modules/core-js/internals/function-uncurry-this-clause.js");
var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");
var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js/internals/function-bind-native.js");

var bind = uncurryThis(uncurryThis.bind);

// optional / simple context binding
module.exports = function (fn, that) {
  aCallable(fn);
  return that === undefined ? fn : NATIVE_BIND ? bind(fn, that) : function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "./node_modules/core-js/internals/function-bind-native.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/function-bind-native.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

module.exports = !fails(function () {
  // eslint-disable-next-line es/no-function-prototype-bind -- safe
  var test = (function () { /* empty */ }).bind();
  // eslint-disable-next-line no-prototype-builtins -- safe
  return typeof test != 'function' || test.hasOwnProperty('prototype');
});


/***/ }),

/***/ "./node_modules/core-js/internals/function-bind.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/function-bind.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var arraySlice = __webpack_require__(/*! ../internals/array-slice */ "./node_modules/core-js/internals/array-slice.js");
var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js/internals/function-bind-native.js");

var $Function = Function;
var concat = uncurryThis([].concat);
var join = uncurryThis([].join);
var factories = {};

var construct = function (C, argsLength, args) {
  if (!hasOwn(factories, argsLength)) {
    for (var list = [], i = 0; i < argsLength; i++) list[i] = 'a[' + i + ']';
    factories[argsLength] = $Function('C,a', 'return new C(' + join(list, ',') + ')');
  } return factories[argsLength](C, args);
};

// `Function.prototype.bind` method implementation
// https://tc39.es/ecma262/#sec-function.prototype.bind
// eslint-disable-next-line es/no-function-prototype-bind -- detection
module.exports = NATIVE_BIND ? $Function.bind : function bind(that /* , ...args */) {
  var F = aCallable(this);
  var Prototype = F.prototype;
  var partArgs = arraySlice(arguments, 1);
  var boundFunction = function bound(/* args... */) {
    var args = concat(partArgs, arraySlice(arguments));
    return this instanceof boundFunction ? construct(F, args.length, args) : F.apply(that, args);
  };
  if (isObject(Prototype)) boundFunction.prototype = Prototype;
  return boundFunction;
};


/***/ }),

/***/ "./node_modules/core-js/internals/function-call.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/function-call.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js/internals/function-bind-native.js");

var call = Function.prototype.call;

module.exports = NATIVE_BIND ? call.bind(call) : function () {
  return call.apply(call, arguments);
};


/***/ }),

/***/ "./node_modules/core-js/internals/function-name.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/function-name.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");

var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;

var EXISTS = hasOwn(FunctionPrototype, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));

module.exports = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};


/***/ }),

/***/ "./node_modules/core-js/internals/function-uncurry-this-accessor.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/internals/function-uncurry-this-accessor.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");

module.exports = function (object, key, method) {
  try {
    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
    return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));
  } catch (error) { /* empty */ }
};


/***/ }),

/***/ "./node_modules/core-js/internals/function-uncurry-this-clause.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js/internals/function-uncurry-this-clause.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var classofRaw = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

module.exports = function (fn) {
  // Nashorn bug:
  //   https://github.com/zloirock/core-js/issues/1128
  //   https://github.com/zloirock/core-js/issues/1130
  if (classofRaw(fn) === 'Function') return uncurryThis(fn);
};


/***/ }),

/***/ "./node_modules/core-js/internals/function-uncurry-this.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/function-uncurry-this.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js/internals/function-bind-native.js");

var FunctionPrototype = Function.prototype;
var call = FunctionPrototype.call;
var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);

module.exports = NATIVE_BIND ? uncurryThisWithBind : function (fn) {
  return function () {
    return call.apply(fn, arguments);
  };
};


/***/ }),

/***/ "./node_modules/core-js/internals/get-built-in.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/get-built-in.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");

var aFunction = function (argument) {
  return isCallable(argument) ? argument : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];
};


/***/ }),

/***/ "./node_modules/core-js/internals/get-json-replacer-function.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/internals/get-json-replacer-function.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");

var push = uncurryThis([].push);

module.exports = function (replacer) {
  if (isCallable(replacer)) return replacer;
  if (!isArray(replacer)) return;
  var rawLength = replacer.length;
  var keys = [];
  for (var i = 0; i < rawLength; i++) {
    var element = replacer[i];
    if (typeof element == 'string') push(keys, element);
    else if (typeof element == 'number' || classof(element) == 'Number' || classof(element) == 'String') push(keys, toString(element));
  }
  var keysLength = keys.length;
  var root = true;
  return function (key, value) {
    if (root) {
      root = false;
      return value;
    }
    if (isArray(this)) return value;
    for (var j = 0; j < keysLength; j++) if (keys[j] === key) return value;
  };
};


/***/ }),

/***/ "./node_modules/core-js/internals/get-method.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/get-method.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");
var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function (V, P) {
  var func = V[P];
  return isNullOrUndefined(func) ? undefined : aCallable(func);
};


/***/ }),

/***/ "./node_modules/core-js/internals/global.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/global.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();


/***/ }),

/***/ "./node_modules/core-js/internals/has-own-property.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/has-own-property.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");

var hasOwnProperty = uncurryThis({}.hasOwnProperty);

// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
// eslint-disable-next-line es/no-object-hasown -- safe
module.exports = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject(it), key);
};


/***/ }),

/***/ "./node_modules/core-js/internals/hidden-keys.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/hidden-keys.js ***!
  \*******************************************************/
/***/ ((module) => {

module.exports = {};


/***/ }),

/***/ "./node_modules/core-js/internals/html.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/html.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");

module.exports = getBuiltIn('document', 'documentElement');


/***/ }),

/***/ "./node_modules/core-js/internals/ie8-dom-define.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/ie8-dom-define.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var createElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");

// Thanks to IE8 for its funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/internals/indexed-object.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/indexed-object.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

var $Object = Object;
var split = uncurryThis(''.split);

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !$Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split(it, '') : $Object(it);
} : $Object;


/***/ }),

/***/ "./node_modules/core-js/internals/inherit-if-required.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/inherit-if-required.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");

// makes subclassing work correct for wrapped built-ins
module.exports = function ($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if (
    // it can work only with native `setPrototypeOf`
    setPrototypeOf &&
    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
    isCallable(NewTarget = dummy.constructor) &&
    NewTarget !== Wrapper &&
    isObject(NewTargetPrototype = NewTarget.prototype) &&
    NewTargetPrototype !== Wrapper.prototype
  ) setPrototypeOf($this, NewTargetPrototype);
  return $this;
};


/***/ }),

/***/ "./node_modules/core-js/internals/inspect-source.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/inspect-source.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var store = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");

var functionToString = uncurryThis(Function.toString);

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable(store.inspectSource)) {
  store.inspectSource = function (it) {
    return functionToString(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ "./node_modules/core-js/internals/install-error-cause.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/install-error-cause.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");

// `InstallErrorCause` abstract operation
// https://tc39.es/proposal-error-cause/#sec-errorobjects-install-error-cause
module.exports = function (O, options) {
  if (isObject(options) && 'cause' in options) {
    createNonEnumerableProperty(O, 'cause', options.cause);
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/internal-state.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/internal-state.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var NATIVE_WEAK_MAP = __webpack_require__(/*! ../internals/weak-map-basic-detection */ "./node_modules/core-js/internals/weak-map-basic-detection.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var shared = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError = global.TypeError;
var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap());
  /* eslint-disable no-self-assign -- prototype methods protection */
  store.get = store.get;
  store.has = store.has;
  store.set = store.set;
  /* eslint-enable no-self-assign -- prototype methods protection */
  set = function (it, metadata) {
    if (store.has(it)) throw TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    store.set(it, metadata);
    return metadata;
  };
  get = function (it) {
    return store.get(it) || {};
  };
  has = function (it) {
    return store.has(it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    if (hasOwn(it, STATE)) throw TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return hasOwn(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return hasOwn(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-array.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/is-array.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es/no-array-isarray -- safe
module.exports = Array.isArray || function isArray(argument) {
  return classof(argument) == 'Array';
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-callable.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/is-callable.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $documentAll = __webpack_require__(/*! ../internals/document-all */ "./node_modules/core-js/internals/document-all.js");

var documentAll = $documentAll.all;

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
module.exports = $documentAll.IS_HTMLDDA ? function (argument) {
  return typeof argument == 'function' || argument === documentAll;
} : function (argument) {
  return typeof argument == 'function';
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-constructor.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/is-constructor.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var inspectSource = __webpack_require__(/*! ../internals/inspect-source */ "./node_modules/core-js/internals/inspect-source.js");

var noop = function () { /* empty */ };
var empty = [];
var construct = getBuiltIn('Reflect', 'construct');
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec = uncurryThis(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.exec(noop);

var isConstructorModern = function isConstructor(argument) {
  if (!isCallable(argument)) return false;
  try {
    construct(noop, empty, argument);
    return true;
  } catch (error) {
    return false;
  }
};

var isConstructorLegacy = function isConstructor(argument) {
  if (!isCallable(argument)) return false;
  switch (classof(argument)) {
    case 'AsyncFunction':
    case 'GeneratorFunction':
    case 'AsyncGeneratorFunction': return false;
  }
  try {
    // we can't check .prototype since constructors produced by .bind haven't it
    // `Function#toString` throws on some built-it function in some legacy engines
    // (for example, `DOMQuad` and similar in FF41-)
    return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
  } catch (error) {
    return true;
  }
};

isConstructorLegacy.sham = true;

// `IsConstructor` abstract operation
// https://tc39.es/ecma262/#sec-isconstructor
module.exports = !construct || fails(function () {
  var called;
  return isConstructorModern(isConstructorModern.call)
    || !isConstructorModern(Object)
    || !isConstructorModern(function () { called = true; })
    || called;
}) ? isConstructorLegacy : isConstructorModern;


/***/ }),

/***/ "./node_modules/core-js/internals/is-forced.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-forced.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : isCallable(detection) ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ "./node_modules/core-js/internals/is-null-or-undefined.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/is-null-or-undefined.js ***!
  \****************************************************************/
/***/ ((module) => {

// we can't use just `it == null` since of `document.all` special case
// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec
module.exports = function (it) {
  return it === null || it === undefined;
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-object.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var $documentAll = __webpack_require__(/*! ../internals/document-all */ "./node_modules/core-js/internals/document-all.js");

var documentAll = $documentAll.all;

module.exports = $documentAll.IS_HTMLDDA ? function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it) || it === documentAll;
} : function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it);
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-pure.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/is-pure.js ***!
  \***************************************************/
/***/ ((module) => {

module.exports = false;


/***/ }),

/***/ "./node_modules/core-js/internals/is-symbol.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-symbol.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ "./node_modules/core-js/internals/object-is-prototype-of.js");
var USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ "./node_modules/core-js/internals/use-symbol-as-uid.js");

var $Object = Object;

module.exports = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn('Symbol');
  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
};


/***/ }),

/***/ "./node_modules/core-js/internals/iterator-create-constructor.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/internals/iterator-create-constructor.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var IteratorPrototype = (__webpack_require__(/*! ../internals/iterators-core */ "./node_modules/core-js/internals/iterators-core.js").IteratorPrototype);
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");

var returnThis = function () { return this; };

module.exports = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
  Iterators[TO_STRING_TAG] = returnThis;
  return IteratorConstructor;
};


/***/ }),

/***/ "./node_modules/core-js/internals/iterator-define.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/iterator-define.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var FunctionName = __webpack_require__(/*! ../internals/function-name */ "./node_modules/core-js/internals/function-name.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var createIteratorConstructor = __webpack_require__(/*! ../internals/iterator-create-constructor */ "./node_modules/core-js/internals/iterator-create-constructor.js");
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");
var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");
var IteratorsCore = __webpack_require__(/*! ../internals/iterators-core */ "./node_modules/core-js/internals/iterators-core.js");

var PROPER_FUNCTION_NAME = FunctionName.PROPER;
var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis = function () { return this; };

module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
    } return function () { return new IteratorConstructor(this); };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR]
    || IterablePrototype['@@iterator']
    || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;

  // fix native
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf) {
          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
          defineBuiltIn(CurrentIteratorPrototype, ITERATOR, returnThis);
        }
      }
      // Set @@toStringTag to native iterators
      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
    }
  }

  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF
  if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
      createNonEnumerableProperty(IterablePrototype, 'name', VALUES);
    } else {
      INCORRECT_VALUES_NAME = true;
      defaultIterator = function values() { return call(nativeIterator, this); };
    }
  }

  // export additional methods
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        defineBuiltIn(IterablePrototype, KEY, methods[KEY]);
      }
    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }

  // define iterator
  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
    defineBuiltIn(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
  }
  Iterators[NAME] = defaultIterator;

  return methods;
};


/***/ }),

/***/ "./node_modules/core-js/internals/iterators-core.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/iterators-core.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");

var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

// `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

/* eslint-disable es/no-array-prototype-keys -- safe */
if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

var NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype) || fails(function () {
  var test = {};
  // FF44- legacy iterators case
  return IteratorPrototype[ITERATOR].call(test) !== test;
});

if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
else if (IS_PURE) IteratorPrototype = create(IteratorPrototype);

// `%IteratorPrototype%[@@iterator]()` method
// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
if (!isCallable(IteratorPrototype[ITERATOR])) {
  defineBuiltIn(IteratorPrototype, ITERATOR, function () {
    return this;
  });
}

module.exports = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};


/***/ }),

/***/ "./node_modules/core-js/internals/iterators.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/iterators.js ***!
  \*****************************************************/
/***/ ((module) => {

module.exports = {};


/***/ }),

/***/ "./node_modules/core-js/internals/length-of-array-like.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/length-of-array-like.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");

// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
module.exports = function (obj) {
  return toLength(obj.length);
};


/***/ }),

/***/ "./node_modules/core-js/internals/make-built-in.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/make-built-in.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var CONFIGURABLE_FUNCTION_NAME = (__webpack_require__(/*! ../internals/function-name */ "./node_modules/core-js/internals/function-name.js").CONFIGURABLE);
var inspectSource = __webpack_require__(/*! ../internals/inspect-source */ "./node_modules/core-js/internals/inspect-source.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");

var enforceInternalState = InternalStateModule.enforce;
var getInternalState = InternalStateModule.get;
var $String = String;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;
var stringSlice = uncurryThis(''.slice);
var replace = uncurryThis(''.replace);
var join = uncurryThis([].join);

var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function () {
  return defineProperty(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;
});

var TEMPLATE = String(String).split('String');

var makeBuiltIn = module.exports = function (value, name, options) {
  if (stringSlice($String(name), 0, 7) === 'Symbol(') {
    name = '[' + replace($String(name), /^Symbol\(([^)]*)\)/, '$1') + ']';
  }
  if (options && options.getter) name = 'get ' + name;
  if (options && options.setter) name = 'set ' + name;
  if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {
    if (DESCRIPTORS) defineProperty(value, 'name', { value: name, configurable: true });
    else value.name = name;
  }
  if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {
    defineProperty(value, 'length', { value: options.arity });
  }
  try {
    if (options && hasOwn(options, 'constructor') && options.constructor) {
      if (DESCRIPTORS) defineProperty(value, 'prototype', { writable: false });
    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable
    } else if (value.prototype) value.prototype = undefined;
  } catch (error) { /* empty */ }
  var state = enforceInternalState(value);
  if (!hasOwn(state, 'source')) {
    state.source = join(TEMPLATE, typeof name == 'string' ? name : '');
  } return value;
};

// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
// eslint-disable-next-line no-extend-native -- required
Function.prototype.toString = makeBuiltIn(function toString() {
  return isCallable(this) && getInternalState(this).source || inspectSource(this);
}, 'toString');


/***/ }),

/***/ "./node_modules/core-js/internals/math-trunc.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/math-trunc.js ***!
  \******************************************************/
/***/ ((module) => {

var ceil = Math.ceil;
var floor = Math.floor;

// `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc
// eslint-disable-next-line es/no-math-trunc -- safe
module.exports = Math.trunc || function trunc(x) {
  var n = +x;
  return (n > 0 ? floor : ceil)(n);
};


/***/ }),

/***/ "./node_modules/core-js/internals/normalize-string-argument.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/internals/normalize-string-argument.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");

module.exports = function (argument, $default) {
  return argument === undefined ? arguments.length < 2 ? '' : $default : toString(argument);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-assign.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/object-assign.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");
var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");
var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");

// eslint-disable-next-line es/no-object-assign -- safe
var $assign = Object.assign;
// eslint-disable-next-line es/no-object-defineproperty -- required for testing
var defineProperty = Object.defineProperty;
var concat = uncurryThis([].concat);

// `Object.assign` method
// https://tc39.es/ecma262/#sec-object.assign
module.exports = !$assign || fails(function () {
  // should have correct order of operations (Edge bug)
  if (DESCRIPTORS && $assign({ b: 1 }, $assign(defineProperty({}, 'a', {
    enumerable: true,
    get: function () {
      defineProperty(this, 'b', {
        value: 3,
        enumerable: false
      });
    }
  }), { b: 2 })).b !== 1) return true;
  // should work with symbols and should have deterministic property order (V8 bug)
  var A = {};
  var B = {};
  // eslint-disable-next-line es/no-symbol -- safe
  var symbol = Symbol();
  var alphabet = 'abcdefghijklmnopqrst';
  A[symbol] = 7;
  alphabet.split('').forEach(function (chr) { B[chr] = chr; });
  return $assign({}, A)[symbol] != 7 || objectKeys($assign({}, B)).join('') != alphabet;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars -- required for `.length`
  var T = toObject(target);
  var argumentsLength = arguments.length;
  var index = 1;
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  var propertyIsEnumerable = propertyIsEnumerableModule.f;
  while (argumentsLength > index) {
    var S = IndexedObject(arguments[index++]);
    var keys = getOwnPropertySymbols ? concat(objectKeys(S), getOwnPropertySymbols(S)) : objectKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || call(propertyIsEnumerable, S, key)) T[key] = S[key];
    }
  } return T;
} : $assign;


/***/ }),

/***/ "./node_modules/core-js/internals/object-create.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/object-create.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* global ActiveXObject -- old IE, WSH */
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var definePropertiesModule = __webpack_require__(/*! ../internals/object-define-properties */ "./node_modules/core-js/internals/object-define-properties.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");
var html = __webpack_require__(/*! ../internals/html */ "./node_modules/core-js/internals/html.js");
var documentCreateElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function () { /* empty */ };

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    activeXDocument = new ActiveXObject('htmlfile');
  } catch (error) { /* ignore */ }
  NullProtoObject = typeof document != 'undefined'
    ? document.domain && activeXDocument
      ? NullProtoObjectViaActiveX(activeXDocument) // old IE
      : NullProtoObjectViaIFrame()
    : NullProtoObjectViaActiveX(activeXDocument); // WSH
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys[IE_PROTO] = true;

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
// eslint-disable-next-line es/no-object-create -- safe
module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-define-properties.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/object-define-properties.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(/*! ../internals/v8-prototype-define-bug */ "./node_modules/core-js/internals/v8-prototype-define-bug.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");

// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es/no-object-defineproperties -- safe
exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var props = toIndexedObject(Properties);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule.f(O, key = keys[index++], props[key]);
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-define-property.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-define-property.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(/*! ../internals/v8-prototype-define-bug */ "./node_modules/core-js/internals/v8-prototype-define-bug.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ "./node_modules/core-js/internals/to-property-key.js");

var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE = 'configurable';
var WRITABLE = 'writable';

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  } return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw $TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-descriptor.js":
/*!******************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-descriptor.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ "./node_modules/core-js/internals/to-property-key.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey(P);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-names-external.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-names-external.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable es/no-object-getownpropertynames -- safe */
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var $getOwnPropertyNames = (__webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js").f);
var arraySlice = __webpack_require__(/*! ../internals/array-slice-simple */ "./node_modules/core-js/internals/array-slice-simple.js");

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return $getOwnPropertyNames(it);
  } catch (error) {
    return arraySlice(windowNames);
  }
};

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && classof(it) == 'Window'
    ? getWindowNames(it)
    : $getOwnPropertyNames(toIndexedObject(it));
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-names.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-names.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js/internals/object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-symbols.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-symbols.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-prototype-of.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-prototype-of.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");
var CORRECT_PROTOTYPE_GETTER = __webpack_require__(/*! ../internals/correct-prototype-getter */ "./node_modules/core-js/internals/correct-prototype-getter.js");

var IE_PROTO = sharedKey('IE_PROTO');
var $Object = Object;
var ObjectPrototype = $Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
// eslint-disable-next-line es/no-object-getprototypeof -- safe
module.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function (O) {
  var object = toObject(O);
  if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
  var constructor = object.constructor;
  if (isCallable(constructor) && object instanceof constructor) {
    return constructor.prototype;
  } return object instanceof $Object ? ObjectPrototype : null;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-is-prototype-of.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-is-prototype-of.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

module.exports = uncurryThis({}.isPrototypeOf);


/***/ }),

/***/ "./node_modules/core-js/internals/object-keys-internal.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/object-keys-internal.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var indexOf = (__webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js/internals/array-includes.js").indexOf);
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");

var push = uncurryThis([].push);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (hasOwn(O, key = names[i++])) {
    ~indexOf(result, key) || push(result, key);
  }
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-keys.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/object-keys.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js/internals/object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es/no-object-keys -- safe
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-property-is-enumerable.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-property-is-enumerable.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;


/***/ }),

/***/ "./node_modules/core-js/internals/object-set-prototype-of.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-set-prototype-of.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable no-proto -- safe */
var uncurryThisAccessor = __webpack_require__(/*! ../internals/function-uncurry-this-accessor */ "./node_modules/core-js/internals/function-uncurry-this-accessor.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var aPossiblePrototype = __webpack_require__(/*! ../internals/a-possible-prototype */ "./node_modules/core-js/internals/a-possible-prototype.js");

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
// eslint-disable-next-line es/no-object-setprototypeof -- safe
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    setter = uncurryThisAccessor(Object.prototype, '__proto__', 'set');
    setter(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);


/***/ }),

/***/ "./node_modules/core-js/internals/object-to-string.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/object-to-string.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ "./node_modules/core-js/internals/to-string-tag-support.js");
var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");

// `Object.prototype.toString` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.tostring
module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
  return '[object ' + classof(this) + ']';
};


/***/ }),

/***/ "./node_modules/core-js/internals/ordinary-to-primitive.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/ordinary-to-primitive.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var $TypeError = TypeError;

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  throw $TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "./node_modules/core-js/internals/own-keys.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/own-keys.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js");
var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

var concat = uncurryThis([].concat);

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ "./node_modules/core-js/internals/path.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/path.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

module.exports = global;


/***/ }),

/***/ "./node_modules/core-js/internals/proxy-accessor.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/proxy-accessor.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f);

module.exports = function (Target, Source, key) {
  key in Target || defineProperty(Target, key, {
    configurable: true,
    get: function () { return Source[key]; },
    set: function (it) { Source[key] = it; }
  });
};


/***/ }),

/***/ "./node_modules/core-js/internals/require-object-coercible.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/require-object-coercible.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");

var $TypeError = TypeError;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (isNullOrUndefined(it)) throw $TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/internals/set-to-string-tag.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/set-to-string-tag.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f);
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

module.exports = function (target, TAG, STATIC) {
  if (target && !STATIC) target = target.prototype;
  if (target && !hasOwn(target, TO_STRING_TAG)) {
    defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG });
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/shared-key.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/shared-key.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ "./node_modules/core-js/internals/shared-store.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/shared-store.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var defineGlobalProperty = __webpack_require__(/*! ../internals/define-global-property */ "./node_modules/core-js/internals/define-global-property.js");

var SHARED = '__core-js_shared__';
var store = global[SHARED] || defineGlobalProperty(SHARED, {});

module.exports = store;


/***/ }),

/***/ "./node_modules/core-js/internals/shared.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/shared.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var store = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.30.1',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: 'Â© 2014-2023 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.30.1/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});


/***/ }),

/***/ "./node_modules/core-js/internals/string-multibyte.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/string-multibyte.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ "./node_modules/core-js/internals/to-integer-or-infinity.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

var charAt = uncurryThis(''.charAt);
var charCodeAt = uncurryThis(''.charCodeAt);
var stringSlice = uncurryThis(''.slice);

var createMethod = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = toString(requireObjectCoercible($this));
    var position = toIntegerOrInfinity(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = charCodeAt(S, position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size
      || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF
        ? CONVERT_TO_STRING
          ? charAt(S, position)
          : first
        : CONVERT_TO_STRING
          ? stringSlice(S, position, position + 2)
          : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

module.exports = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod(true)
};


/***/ }),

/***/ "./node_modules/core-js/internals/string-trim.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/string-trim.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var whitespaces = __webpack_require__(/*! ../internals/whitespaces */ "./node_modules/core-js/internals/whitespaces.js");

var replace = uncurryThis(''.replace);
var ltrim = RegExp('^[' + whitespaces + ']+');
var rtrim = RegExp('(^|[^' + whitespaces + '])[' + whitespaces + ']+$');

// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
var createMethod = function (TYPE) {
  return function ($this) {
    var string = toString(requireObjectCoercible($this));
    if (TYPE & 1) string = replace(string, ltrim, '');
    if (TYPE & 2) string = replace(string, rtrim, '$1');
    return string;
  };
};

module.exports = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
  start: createMethod(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimend
  end: createMethod(2),
  // `String.prototype.trim` method
  // https://tc39.es/ecma262/#sec-string.prototype.trim
  trim: createMethod(3)
};


/***/ }),

/***/ "./node_modules/core-js/internals/symbol-constructor-detection.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js/internals/symbol-constructor-detection.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable es/no-symbol -- required for testing */
var V8_VERSION = __webpack_require__(/*! ../internals/engine-v8-version */ "./node_modules/core-js/internals/engine-v8-version.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  var symbol = Symbol();
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});


/***/ }),

/***/ "./node_modules/core-js/internals/symbol-define-to-primitive.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/internals/symbol-define-to-primitive.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");

module.exports = function () {
  var Symbol = getBuiltIn('Symbol');
  var SymbolPrototype = Symbol && Symbol.prototype;
  var valueOf = SymbolPrototype && SymbolPrototype.valueOf;
  var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

  if (SymbolPrototype && !SymbolPrototype[TO_PRIMITIVE]) {
    // `Symbol.prototype[@@toPrimitive]` method
    // https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
    // eslint-disable-next-line no-unused-vars -- required for .length
    defineBuiltIn(SymbolPrototype, TO_PRIMITIVE, function (hint) {
      return call(valueOf, this);
    }, { arity: 1 });
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/symbol-registry-detection.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/internals/symbol-registry-detection.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ "./node_modules/core-js/internals/symbol-constructor-detection.js");

/* eslint-disable es/no-symbol -- safe */
module.exports = NATIVE_SYMBOL && !!Symbol['for'] && !!Symbol.keyFor;


/***/ }),

/***/ "./node_modules/core-js/internals/this-number-value.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/this-number-value.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

// `thisNumberValue` abstract operation
// https://tc39.es/ecma262/#sec-thisnumbervalue
module.exports = uncurryThis(1.0.valueOf);


/***/ }),

/***/ "./node_modules/core-js/internals/to-absolute-index.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/to-absolute-index.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ "./node_modules/core-js/internals/to-integer-or-infinity.js");

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toIntegerOrInfinity(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-indexed-object.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/to-indexed-object.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-integer-or-infinity.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/to-integer-or-infinity.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var trunc = __webpack_require__(/*! ../internals/math-trunc */ "./node_modules/core-js/internals/math-trunc.js");

// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
module.exports = function (argument) {
  var number = +argument;
  // eslint-disable-next-line no-self-compare -- NaN check
  return number !== number || number === 0 ? 0 : trunc(number);
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-length.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-length.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ "./node_modules/core-js/internals/to-integer-or-infinity.js");

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-object.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

var $Object = Object;

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return $Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-primitive.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/to-primitive.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js/internals/is-symbol.js");
var getMethod = __webpack_require__(/*! ../internals/get-method */ "./node_modules/core-js/internals/get-method.js");
var ordinaryToPrimitive = __webpack_require__(/*! ../internals/ordinary-to-primitive */ "./node_modules/core-js/internals/ordinary-to-primitive.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var $TypeError = TypeError;
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function (input, pref) {
  if (!isObject(input) || isSymbol(input)) return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call(exoticToPrim, input, pref);
    if (!isObject(result) || isSymbol(result)) return result;
    throw $TypeError("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-property-key.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/to-property-key.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");
var isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js/internals/is-symbol.js");

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : key + '';
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-string-tag-support.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/to-string-tag-support.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ "./node_modules/core-js/internals/to-string.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-string.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");

var $String = String;

module.exports = function (argument) {
  if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
  return $String(argument);
};


/***/ }),

/***/ "./node_modules/core-js/internals/try-to-string.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/try-to-string.js ***!
  \*********************************************************/
/***/ ((module) => {

var $String = String;

module.exports = function (argument) {
  try {
    return $String(argument);
  } catch (error) {
    return 'Object';
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/uid.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/internals/uid.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

var id = 0;
var postfix = Math.random();
var toString = uncurryThis(1.0.toString);

module.exports = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
};


/***/ }),

/***/ "./node_modules/core-js/internals/use-symbol-as-uid.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/use-symbol-as-uid.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable es/no-symbol -- required for testing */
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ "./node_modules/core-js/internals/symbol-constructor-detection.js");

module.exports = NATIVE_SYMBOL
  && !Symbol.sham
  && typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ "./node_modules/core-js/internals/v8-prototype-define-bug.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/v8-prototype-define-bug.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
module.exports = DESCRIPTORS && fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
    value: 42,
    writable: false
  }).prototype != 42;
});


/***/ }),

/***/ "./node_modules/core-js/internals/weak-map-basic-detection.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/weak-map-basic-detection.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");

var WeakMap = global.WeakMap;

module.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));


/***/ }),

/***/ "./node_modules/core-js/internals/well-known-symbol-define.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/well-known-symbol-define.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var path = __webpack_require__(/*! ../internals/path */ "./node_modules/core-js/internals/path.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var wrappedWellKnownSymbolModule = __webpack_require__(/*! ../internals/well-known-symbol-wrapped */ "./node_modules/core-js/internals/well-known-symbol-wrapped.js");
var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f);

module.exports = function (NAME) {
  var Symbol = path.Symbol || (path.Symbol = {});
  if (!hasOwn(Symbol, NAME)) defineProperty(Symbol, NAME, {
    value: wrappedWellKnownSymbolModule.f(NAME)
  });
};


/***/ }),

/***/ "./node_modules/core-js/internals/well-known-symbol-wrapped.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/internals/well-known-symbol-wrapped.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

exports.f = wellKnownSymbol;


/***/ }),

/***/ "./node_modules/core-js/internals/well-known-symbol.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/well-known-symbol.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ "./node_modules/core-js/internals/symbol-constructor-detection.js");
var USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ "./node_modules/core-js/internals/use-symbol-as-uid.js");

var Symbol = global.Symbol;
var WellKnownSymbolsStore = shared('wks');
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol['for'] || Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!hasOwn(WellKnownSymbolsStore, name)) {
    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol, name)
      ? Symbol[name]
      : createWellKnownSymbol('Symbol.' + name);
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ "./node_modules/core-js/internals/whitespaces.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/whitespaces.js ***!
  \*******************************************************/
/***/ ((module) => {

// a string of all valid unicode whitespaces
module.exports = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002' +
  '\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),

/***/ "./node_modules/core-js/internals/wrap-error-constructor-with-cause.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/core-js/internals/wrap-error-constructor-with-cause.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ "./node_modules/core-js/internals/object-is-prototype-of.js");
var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");
var copyConstructorProperties = __webpack_require__(/*! ../internals/copy-constructor-properties */ "./node_modules/core-js/internals/copy-constructor-properties.js");
var proxyAccessor = __webpack_require__(/*! ../internals/proxy-accessor */ "./node_modules/core-js/internals/proxy-accessor.js");
var inheritIfRequired = __webpack_require__(/*! ../internals/inherit-if-required */ "./node_modules/core-js/internals/inherit-if-required.js");
var normalizeStringArgument = __webpack_require__(/*! ../internals/normalize-string-argument */ "./node_modules/core-js/internals/normalize-string-argument.js");
var installErrorCause = __webpack_require__(/*! ../internals/install-error-cause */ "./node_modules/core-js/internals/install-error-cause.js");
var installErrorStack = __webpack_require__(/*! ../internals/error-stack-install */ "./node_modules/core-js/internals/error-stack-install.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");

module.exports = function (FULL_NAME, wrapper, FORCED, IS_AGGREGATE_ERROR) {
  var STACK_TRACE_LIMIT = 'stackTraceLimit';
  var OPTIONS_POSITION = IS_AGGREGATE_ERROR ? 2 : 1;
  var path = FULL_NAME.split('.');
  var ERROR_NAME = path[path.length - 1];
  var OriginalError = getBuiltIn.apply(null, path);

  if (!OriginalError) return;

  var OriginalErrorPrototype = OriginalError.prototype;

  // V8 9.3- bug https://bugs.chromium.org/p/v8/issues/detail?id=12006
  if (!IS_PURE && hasOwn(OriginalErrorPrototype, 'cause')) delete OriginalErrorPrototype.cause;

  if (!FORCED) return OriginalError;

  var BaseError = getBuiltIn('Error');

  var WrappedError = wrapper(function (a, b) {
    var message = normalizeStringArgument(IS_AGGREGATE_ERROR ? b : a, undefined);
    var result = IS_AGGREGATE_ERROR ? new OriginalError(a) : new OriginalError();
    if (message !== undefined) createNonEnumerableProperty(result, 'message', message);
    installErrorStack(result, WrappedError, result.stack, 2);
    if (this && isPrototypeOf(OriginalErrorPrototype, this)) inheritIfRequired(result, this, WrappedError);
    if (arguments.length > OPTIONS_POSITION) installErrorCause(result, arguments[OPTIONS_POSITION]);
    return result;
  });

  WrappedError.prototype = OriginalErrorPrototype;

  if (ERROR_NAME !== 'Error') {
    if (setPrototypeOf) setPrototypeOf(WrappedError, BaseError);
    else copyConstructorProperties(WrappedError, BaseError, { name: true });
  } else if (DESCRIPTORS && STACK_TRACE_LIMIT in OriginalError) {
    proxyAccessor(WrappedError, OriginalError, STACK_TRACE_LIMIT);
    proxyAccessor(WrappedError, OriginalError, 'prepareStackTrace');
  }

  copyConstructorProperties(WrappedError, OriginalError);

  if (!IS_PURE) try {
    // Safari 13- bug: WebAssembly errors does not have a proper `.name`
    if (OriginalErrorPrototype.name !== ERROR_NAME) {
      createNonEnumerableProperty(OriginalErrorPrototype, 'name', ERROR_NAME);
    }
    OriginalErrorPrototype.constructor = WrappedError;
  } catch (error) { /* empty */ }

  return WrappedError;
};


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.iterator.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.iterator.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ "./node_modules/core-js/internals/add-to-unscopables.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f);
var defineIterator = __webpack_require__(/*! ../internals/iterator-define */ "./node_modules/core-js/internals/iterator-define.js");
var createIterResultObject = __webpack_require__(/*! ../internals/create-iter-result-object */ "./node_modules/core-js/internals/create-iter-result-object.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");

var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);

// `Array.prototype.entries` method
// https://tc39.es/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.es/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.es/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.es/ecma262/#sec-createarrayiterator
module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
  setInternalState(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated), // target
    index: 0,                          // next index
    kind: kind                         // kind
  });
// `%ArrayIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = undefined;
    return createIterResultObject(undefined, true);
  }
  if (kind == 'keys') return createIterResultObject(index, false);
  if (kind == 'values') return createIterResultObject(target[index], false);
  return createIterResultObject([index, target[index]], false);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
// https://tc39.es/ecma262/#sec-createmappedargumentsobject
var values = Iterators.Arguments = Iterators.Array;

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

// V8 ~ Chrome 45- bug
if (!IS_PURE && DESCRIPTORS && values.name !== 'values') try {
  defineProperty(values, 'name', { value: 'values' });
} catch (error) { /* empty */ }


/***/ }),

/***/ "./node_modules/core-js/modules/es.date.to-primitive.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es.date.to-primitive.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");
var dateToPrimitive = __webpack_require__(/*! ../internals/date-to-primitive */ "./node_modules/core-js/internals/date-to-primitive.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
var DatePrototype = Date.prototype;

// `Date.prototype[@@toPrimitive]` method
// https://tc39.es/ecma262/#sec-date.prototype-@@toprimitive
if (!hasOwn(DatePrototype, TO_PRIMITIVE)) {
  defineBuiltIn(DatePrototype, TO_PRIMITIVE, dateToPrimitive);
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.error.cause.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.error.cause.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable no-unused-vars -- required for functions `.length` */
var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var apply = __webpack_require__(/*! ../internals/function-apply */ "./node_modules/core-js/internals/function-apply.js");
var wrapErrorConstructorWithCause = __webpack_require__(/*! ../internals/wrap-error-constructor-with-cause */ "./node_modules/core-js/internals/wrap-error-constructor-with-cause.js");

var WEB_ASSEMBLY = 'WebAssembly';
var WebAssembly = global[WEB_ASSEMBLY];

var FORCED = Error('e', { cause: 7 }).cause !== 7;

var exportGlobalErrorCauseWrapper = function (ERROR_NAME, wrapper) {
  var O = {};
  O[ERROR_NAME] = wrapErrorConstructorWithCause(ERROR_NAME, wrapper, FORCED);
  $({ global: true, constructor: true, arity: 1, forced: FORCED }, O);
};

var exportWebAssemblyErrorCauseWrapper = function (ERROR_NAME, wrapper) {
  if (WebAssembly && WebAssembly[ERROR_NAME]) {
    var O = {};
    O[ERROR_NAME] = wrapErrorConstructorWithCause(WEB_ASSEMBLY + '.' + ERROR_NAME, wrapper, FORCED);
    $({ target: WEB_ASSEMBLY, stat: true, constructor: true, arity: 1, forced: FORCED }, O);
  }
};

// https://tc39.es/ecma262/#sec-nativeerror
// https://github.com/tc39/proposal-error-cause
exportGlobalErrorCauseWrapper('Error', function (init) {
  return function Error(message) { return apply(init, this, arguments); };
});
exportGlobalErrorCauseWrapper('EvalError', function (init) {
  return function EvalError(message) { return apply(init, this, arguments); };
});
exportGlobalErrorCauseWrapper('RangeError', function (init) {
  return function RangeError(message) { return apply(init, this, arguments); };
});
exportGlobalErrorCauseWrapper('ReferenceError', function (init) {
  return function ReferenceError(message) { return apply(init, this, arguments); };
});
exportGlobalErrorCauseWrapper('SyntaxError', function (init) {
  return function SyntaxError(message) { return apply(init, this, arguments); };
});
exportGlobalErrorCauseWrapper('TypeError', function (init) {
  return function TypeError(message) { return apply(init, this, arguments); };
});
exportGlobalErrorCauseWrapper('URIError', function (init) {
  return function URIError(message) { return apply(init, this, arguments); };
});
exportWebAssemblyErrorCauseWrapper('CompileError', function (init) {
  return function CompileError(message) { return apply(init, this, arguments); };
});
exportWebAssemblyErrorCauseWrapper('LinkError', function (init) {
  return function LinkError(message) { return apply(init, this, arguments); };
});
exportWebAssemblyErrorCauseWrapper('RuntimeError', function (init) {
  return function RuntimeError(message) { return apply(init, this, arguments); };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.error.to-string.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.error.to-string.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");
var errorToString = __webpack_require__(/*! ../internals/error-to-string */ "./node_modules/core-js/internals/error-to-string.js");

var ErrorPrototype = Error.prototype;

// `Error.prototype.toString` method fix
// https://tc39.es/ecma262/#sec-error.prototype.tostring
if (ErrorPrototype.toString !== errorToString) {
  defineBuiltIn(ErrorPrototype, 'toString', errorToString);
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.function.bind.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es.function.bind.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// TODO: Remove from `core-js@4`
var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var bind = __webpack_require__(/*! ../internals/function-bind */ "./node_modules/core-js/internals/function-bind.js");

// `Function.prototype.bind` method
// https://tc39.es/ecma262/#sec-function.prototype.bind
// eslint-disable-next-line es/no-function-prototype-bind -- detection
$({ target: 'Function', proto: true, forced: Function.bind !== bind }, {
  bind: bind
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.json.stringify.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.json.stringify.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var apply = __webpack_require__(/*! ../internals/function-apply */ "./node_modules/core-js/internals/function-apply.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js/internals/is-symbol.js");
var arraySlice = __webpack_require__(/*! ../internals/array-slice */ "./node_modules/core-js/internals/array-slice.js");
var getReplacerFunction = __webpack_require__(/*! ../internals/get-json-replacer-function */ "./node_modules/core-js/internals/get-json-replacer-function.js");
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ "./node_modules/core-js/internals/symbol-constructor-detection.js");

var $String = String;
var $stringify = getBuiltIn('JSON', 'stringify');
var exec = uncurryThis(/./.exec);
var charAt = uncurryThis(''.charAt);
var charCodeAt = uncurryThis(''.charCodeAt);
var replace = uncurryThis(''.replace);
var numberToString = uncurryThis(1.0.toString);

var tester = /[\uD800-\uDFFF]/g;
var low = /^[\uD800-\uDBFF]$/;
var hi = /^[\uDC00-\uDFFF]$/;

var WRONG_SYMBOLS_CONVERSION = !NATIVE_SYMBOL || fails(function () {
  var symbol = getBuiltIn('Symbol')();
  // MS Edge converts symbol values to JSON as {}
  return $stringify([symbol]) != '[null]'
    // WebKit converts symbol values to JSON as null
    || $stringify({ a: symbol }) != '{}'
    // V8 throws on boxed symbols
    || $stringify(Object(symbol)) != '{}';
});

// https://github.com/tc39/proposal-well-formed-stringify
var ILL_FORMED_UNICODE = fails(function () {
  return $stringify('\uDF06\uD834') !== '"\\udf06\\ud834"'
    || $stringify('\uDEAD') !== '"\\udead"';
});

var stringifyWithSymbolsFix = function (it, replacer) {
  var args = arraySlice(arguments);
  var $replacer = getReplacerFunction(replacer);
  if (!isCallable($replacer) && (it === undefined || isSymbol(it))) return; // IE8 returns string on undefined
  args[1] = function (key, value) {
    // some old implementations (like WebKit) could pass numbers as keys
    if (isCallable($replacer)) value = call($replacer, this, $String(key), value);
    if (!isSymbol(value)) return value;
  };
  return apply($stringify, null, args);
};

var fixIllFormed = function (match, offset, string) {
  var prev = charAt(string, offset - 1);
  var next = charAt(string, offset + 1);
  if ((exec(low, match) && !exec(hi, next)) || (exec(hi, match) && !exec(low, prev))) {
    return '\\u' + numberToString(charCodeAt(match, 0), 16);
  } return match;
};

if ($stringify) {
  // `JSON.stringify` method
  // https://tc39.es/ecma262/#sec-json.stringify
  $({ target: 'JSON', stat: true, arity: 3, forced: WRONG_SYMBOLS_CONVERSION || ILL_FORMED_UNICODE }, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    stringify: function stringify(it, replacer, space) {
      var args = arraySlice(arguments);
      var result = apply(WRONG_SYMBOLS_CONVERSION ? stringifyWithSymbolsFix : $stringify, null, args);
      return ILL_FORMED_UNICODE && typeof result == 'string' ? replace(result, tester, fixIllFormed) : result;
    }
  });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.number.constructor.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es.number.constructor.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var path = __webpack_require__(/*! ../internals/path */ "./node_modules/core-js/internals/path.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var inheritIfRequired = __webpack_require__(/*! ../internals/inherit-if-required */ "./node_modules/core-js/internals/inherit-if-required.js");
var isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ "./node_modules/core-js/internals/object-is-prototype-of.js");
var isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js/internals/is-symbol.js");
var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var getOwnPropertyNames = (__webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js").f);
var getOwnPropertyDescriptor = (__webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f);
var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f);
var thisNumberValue = __webpack_require__(/*! ../internals/this-number-value */ "./node_modules/core-js/internals/this-number-value.js");
var trim = (__webpack_require__(/*! ../internals/string-trim */ "./node_modules/core-js/internals/string-trim.js").trim);

var NUMBER = 'Number';
var NativeNumber = global[NUMBER];
var PureNumberNamespace = path[NUMBER];
var NumberPrototype = NativeNumber.prototype;
var TypeError = global.TypeError;
var stringSlice = uncurryThis(''.slice);
var charCodeAt = uncurryThis(''.charCodeAt);

// `ToNumeric` abstract operation
// https://tc39.es/ecma262/#sec-tonumeric
var toNumeric = function (value) {
  var primValue = toPrimitive(value, 'number');
  return typeof primValue == 'bigint' ? primValue : toNumber(primValue);
};

// `ToNumber` abstract operation
// https://tc39.es/ecma262/#sec-tonumber
var toNumber = function (argument) {
  var it = toPrimitive(argument, 'number');
  var first, third, radix, maxCode, digits, length, index, code;
  if (isSymbol(it)) throw TypeError('Cannot convert a Symbol value to a number');
  if (typeof it == 'string' && it.length > 2) {
    it = trim(it);
    first = charCodeAt(it, 0);
    if (first === 43 || first === 45) {
      third = charCodeAt(it, 2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (charCodeAt(it, 1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal of /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal of /^0o[0-7]+$/i
        default: return +it;
      }
      digits = stringSlice(it, 2);
      length = digits.length;
      for (index = 0; index < length; index++) {
        code = charCodeAt(digits, index);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

var FORCED = isForced(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'));

var calledWithNew = function (dummy) {
  // includes check on 1..constructor(foo) case
  return isPrototypeOf(NumberPrototype, dummy) && fails(function () { thisNumberValue(dummy); });
};

// `Number` constructor
// https://tc39.es/ecma262/#sec-number-constructor
var NumberWrapper = function Number(value) {
  var n = arguments.length < 1 ? 0 : NativeNumber(toNumeric(value));
  return calledWithNew(this) ? inheritIfRequired(Object(n), this, NumberWrapper) : n;
};

NumberWrapper.prototype = NumberPrototype;
if (FORCED && !IS_PURE) NumberPrototype.constructor = NumberWrapper;

$({ global: true, constructor: true, wrap: true, forced: FORCED }, {
  Number: NumberWrapper
});

// Use `internal/copy-constructor-properties` helper in `core-js@4`
var copyConstructorProperties = function (target, source) {
  for (var keys = DESCRIPTORS ? getOwnPropertyNames(source) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES2015 (in case, if modules with ES2015 Number statics required before):
    'EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,' +
    // ESNext
    'fromString,range'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (hasOwn(source, key = keys[j]) && !hasOwn(target, key)) {
      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  }
};

if (IS_PURE && PureNumberNamespace) copyConstructorProperties(path[NUMBER], PureNumberNamespace);
if (FORCED || IS_PURE) copyConstructorProperties(path[NUMBER], NativeNumber);


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.assign.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.assign.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var assign = __webpack_require__(/*! ../internals/object-assign */ "./node_modules/core-js/internals/object-assign.js");

// `Object.assign` method
// https://tc39.es/ecma262/#sec-object.assign
// eslint-disable-next-line es/no-object-assign -- required for testing
$({ target: 'Object', stat: true, arity: 2, forced: Object.assign !== assign }, {
  assign: assign
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.create.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.create.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// TODO: Remove from `core-js@4`
var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
$({ target: 'Object', stat: true, sham: !DESCRIPTORS }, {
  create: create
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.define-property.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.define-property.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f);

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
// eslint-disable-next-line es/no-object-defineproperty -- safe
$({ target: 'Object', stat: true, forced: Object.defineProperty !== defineProperty, sham: !DESCRIPTORS }, {
  defineProperty: defineProperty
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.get-own-property-symbols.js":
/*!****************************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.get-own-property-symbols.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ "./node_modules/core-js/internals/symbol-constructor-detection.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");

// V8 ~ Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
var FORCED = !NATIVE_SYMBOL || fails(function () { getOwnPropertySymbolsModule.f(1); });

// `Object.getOwnPropertySymbols` method
// https://tc39.es/ecma262/#sec-object.getownpropertysymbols
$({ target: 'Object', stat: true, forced: FORCED }, {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    var $getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
    return $getOwnPropertySymbols ? $getOwnPropertySymbols(toObject(it)) : [];
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.get-prototype-of.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.get-prototype-of.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var nativeGetPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");
var CORRECT_PROTOTYPE_GETTER = __webpack_require__(/*! ../internals/correct-prototype-getter */ "./node_modules/core-js/internals/correct-prototype-getter.js");

var FAILS_ON_PRIMITIVES = fails(function () { nativeGetPrototypeOf(1); });

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES, sham: !CORRECT_PROTOTYPE_GETTER }, {
  getPrototypeOf: function getPrototypeOf(it) {
    return nativeGetPrototypeOf(toObject(it));
  }
});



/***/ }),

/***/ "./node_modules/core-js/modules/es.object.set-prototype-of.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.set-prototype-of.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
$({ target: 'Object', stat: true }, {
  setPrototypeOf: setPrototypeOf
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.to-string.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.to-string.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ "./node_modules/core-js/internals/to-string-tag-support.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");
var toString = __webpack_require__(/*! ../internals/object-to-string */ "./node_modules/core-js/internals/object-to-string.js");

// `Object.prototype.toString` method
// https://tc39.es/ecma262/#sec-object.prototype.tostring
if (!TO_STRING_TAG_SUPPORT) {
  defineBuiltIn(Object.prototype, 'toString', toString, { unsafe: true });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.reflect.construct.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es.reflect.construct.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var apply = __webpack_require__(/*! ../internals/function-apply */ "./node_modules/core-js/internals/function-apply.js");
var bind = __webpack_require__(/*! ../internals/function-bind */ "./node_modules/core-js/internals/function-bind.js");
var aConstructor = __webpack_require__(/*! ../internals/a-constructor */ "./node_modules/core-js/internals/a-constructor.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

var nativeConstruct = getBuiltIn('Reflect', 'construct');
var ObjectPrototype = Object.prototype;
var push = [].push;

// `Reflect.construct` method
// https://tc39.es/ecma262/#sec-reflect.construct
// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(nativeConstruct(function () { /* empty */ }, [], F) instanceof F);
});

var ARGS_BUG = !fails(function () {
  nativeConstruct(function () { /* empty */ });
});

var FORCED = NEW_TARGET_BUG || ARGS_BUG;

$({ target: 'Reflect', stat: true, forced: FORCED, sham: FORCED }, {
  construct: function construct(Target, args /* , newTarget */) {
    aConstructor(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aConstructor(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      apply(push, $args, args);
      return new (apply(bind, Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : ObjectPrototype);
    var result = apply(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.reflect.to-string-tag.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/es.reflect.to-string-tag.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");

$({ global: true }, { Reflect: {} });

// Reflect[@@toStringTag] property
// https://tc39.es/ecma262/#sec-reflect-@@tostringtag
setToStringTag(global.Reflect, 'Reflect', true);


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.iterator.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.iterator.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var charAt = (__webpack_require__(/*! ../internals/string-multibyte */ "./node_modules/core-js/internals/string-multibyte.js").charAt);
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
var defineIterator = __webpack_require__(/*! ../internals/iterator-define */ "./node_modules/core-js/internals/iterator-define.js");
var createIterResultObject = __webpack_require__(/*! ../internals/create-iter-result-object */ "./node_modules/core-js/internals/create-iter-result-object.js");

var STRING_ITERATOR = 'String Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);

// `String.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-string.prototype-@@iterator
defineIterator(String, 'String', function (iterated) {
  setInternalState(this, {
    type: STRING_ITERATOR,
    string: toString(iterated),
    index: 0
  });
// `%StringIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return createIterResultObject(undefined, true);
  point = charAt(string, index);
  state.index += point.length;
  return createIterResultObject(point, false);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.constructor.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.constructor.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ "./node_modules/core-js/internals/symbol-constructor-detection.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ "./node_modules/core-js/internals/object-is-prototype-of.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ "./node_modules/core-js/internals/to-property-key.js");
var $toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
var nativeObjectCreate = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");
var getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js");
var getOwnPropertyNamesExternal = __webpack_require__(/*! ../internals/object-get-own-property-names-external */ "./node_modules/core-js/internals/object-get-own-property-names-external.js");
var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");
var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var definePropertiesModule = __webpack_require__(/*! ../internals/object-define-properties */ "./node_modules/core-js/internals/object-define-properties.js");
var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");
var defineBuiltInAccessor = __webpack_require__(/*! ../internals/define-built-in-accessor */ "./node_modules/core-js/internals/define-built-in-accessor.js");
var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var wrappedWellKnownSymbolModule = __webpack_require__(/*! ../internals/well-known-symbol-wrapped */ "./node_modules/core-js/internals/well-known-symbol-wrapped.js");
var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js/internals/well-known-symbol-define.js");
var defineSymbolToPrimitive = __webpack_require__(/*! ../internals/symbol-define-to-primitive */ "./node_modules/core-js/internals/symbol-define-to-primitive.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
var $forEach = (__webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js").forEach);

var HIDDEN = sharedKey('hidden');
var SYMBOL = 'Symbol';
var PROTOTYPE = 'prototype';

var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(SYMBOL);

var ObjectPrototype = Object[PROTOTYPE];
var $Symbol = global.Symbol;
var SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];
var TypeError = global.TypeError;
var QObject = global.QObject;
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
var push = uncurryThis([].push);

var AllSymbols = shared('symbols');
var ObjectPrototypeSymbols = shared('op-symbols');
var WellKnownSymbolsStore = shared('wks');

// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDescriptor = DESCRIPTORS && fails(function () {
  return nativeObjectCreate(nativeDefineProperty({}, 'a', {
    get: function () { return nativeDefineProperty(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (O, P, Attributes) {
  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
  nativeDefineProperty(O, P, Attributes);
  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
    nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
  }
} : nativeDefineProperty;

var wrap = function (tag, description) {
  var symbol = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype);
  setInternalState(symbol, {
    type: SYMBOL,
    tag: tag,
    description: description
  });
  if (!DESCRIPTORS) symbol.description = description;
  return symbol;
};

var $defineProperty = function defineProperty(O, P, Attributes) {
  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
  anObject(O);
  var key = toPropertyKey(P);
  anObject(Attributes);
  if (hasOwn(AllSymbols, key)) {
    if (!Attributes.enumerable) {
      if (!hasOwn(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
      O[HIDDEN][key] = true;
    } else {
      if (hasOwn(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
      Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
    } return setSymbolDescriptor(O, key, Attributes);
  } return nativeDefineProperty(O, key, Attributes);
};

var $defineProperties = function defineProperties(O, Properties) {
  anObject(O);
  var properties = toIndexedObject(Properties);
  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
  $forEach(keys, function (key) {
    if (!DESCRIPTORS || call($propertyIsEnumerable, properties, key)) $defineProperty(O, key, properties[key]);
  });
  return O;
};

var $create = function create(O, Properties) {
  return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
};

var $propertyIsEnumerable = function propertyIsEnumerable(V) {
  var P = toPropertyKey(V);
  var enumerable = call(nativePropertyIsEnumerable, this, P);
  if (this === ObjectPrototype && hasOwn(AllSymbols, P) && !hasOwn(ObjectPrototypeSymbols, P)) return false;
  return enumerable || !hasOwn(this, P) || !hasOwn(AllSymbols, P) || hasOwn(this, HIDDEN) && this[HIDDEN][P]
    ? enumerable : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
  var it = toIndexedObject(O);
  var key = toPropertyKey(P);
  if (it === ObjectPrototype && hasOwn(AllSymbols, key) && !hasOwn(ObjectPrototypeSymbols, key)) return;
  var descriptor = nativeGetOwnPropertyDescriptor(it, key);
  if (descriptor && hasOwn(AllSymbols, key) && !(hasOwn(it, HIDDEN) && it[HIDDEN][key])) {
    descriptor.enumerable = true;
  }
  return descriptor;
};

var $getOwnPropertyNames = function getOwnPropertyNames(O) {
  var names = nativeGetOwnPropertyNames(toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (!hasOwn(AllSymbols, key) && !hasOwn(hiddenKeys, key)) push(result, key);
  });
  return result;
};

var $getOwnPropertySymbols = function (O) {
  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (hasOwn(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn(ObjectPrototype, key))) {
      push(result, AllSymbols[key]);
    }
  });
  return result;
};

// `Symbol` constructor
// https://tc39.es/ecma262/#sec-symbol-constructor
if (!NATIVE_SYMBOL) {
  $Symbol = function Symbol() {
    if (isPrototypeOf(SymbolPrototype, this)) throw TypeError('Symbol is not a constructor');
    var description = !arguments.length || arguments[0] === undefined ? undefined : $toString(arguments[0]);
    var tag = uid(description);
    var setter = function (value) {
      if (this === ObjectPrototype) call(setter, ObjectPrototypeSymbols, value);
      if (hasOwn(this, HIDDEN) && hasOwn(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
    };
    if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
    return wrap(tag, description);
  };

  SymbolPrototype = $Symbol[PROTOTYPE];

  defineBuiltIn(SymbolPrototype, 'toString', function toString() {
    return getInternalState(this).tag;
  });

  defineBuiltIn($Symbol, 'withoutSetter', function (description) {
    return wrap(uid(description), description);
  });

  propertyIsEnumerableModule.f = $propertyIsEnumerable;
  definePropertyModule.f = $defineProperty;
  definePropertiesModule.f = $defineProperties;
  getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
  getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
  getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;

  wrappedWellKnownSymbolModule.f = function (name) {
    return wrap(wellKnownSymbol(name), name);
  };

  if (DESCRIPTORS) {
    // https://github.com/tc39/proposal-Symbol-description
    defineBuiltInAccessor(SymbolPrototype, 'description', {
      configurable: true,
      get: function description() {
        return getInternalState(this).description;
      }
    });
    if (!IS_PURE) {
      defineBuiltIn(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });
    }
  }
}

$({ global: true, constructor: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
  Symbol: $Symbol
});

$forEach(objectKeys(WellKnownSymbolsStore), function (name) {
  defineWellKnownSymbol(name);
});

$({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
  useSetter: function () { USE_SETTER = true; },
  useSimple: function () { USE_SETTER = false; }
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
  // `Object.create` method
  // https://tc39.es/ecma262/#sec-object.create
  create: $create,
  // `Object.defineProperty` method
  // https://tc39.es/ecma262/#sec-object.defineproperty
  defineProperty: $defineProperty,
  // `Object.defineProperties` method
  // https://tc39.es/ecma262/#sec-object.defineproperties
  defineProperties: $defineProperties,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL }, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.es/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: $getOwnPropertyNames
});

// `Symbol.prototype[@@toPrimitive]` method
// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
defineSymbolToPrimitive();

// `Symbol.prototype[@@toStringTag]` property
// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
setToStringTag($Symbol, SYMBOL);

hiddenKeys[HIDDEN] = true;


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.description.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.description.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// `Symbol.prototype.description` getter
// https://tc39.es/ecma262/#sec-symbol.prototype.description

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ "./node_modules/core-js/internals/object-is-prototype-of.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var defineBuiltInAccessor = __webpack_require__(/*! ../internals/define-built-in-accessor */ "./node_modules/core-js/internals/define-built-in-accessor.js");
var copyConstructorProperties = __webpack_require__(/*! ../internals/copy-constructor-properties */ "./node_modules/core-js/internals/copy-constructor-properties.js");

var NativeSymbol = global.Symbol;
var SymbolPrototype = NativeSymbol && NativeSymbol.prototype;

if (DESCRIPTORS && isCallable(NativeSymbol) && (!('description' in SymbolPrototype) ||
  // Safari 12 bug
  NativeSymbol().description !== undefined
)) {
  var EmptyStringDescriptionStore = {};
  // wrap Symbol constructor for correct work with undefined description
  var SymbolWrapper = function Symbol() {
    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : toString(arguments[0]);
    var result = isPrototypeOf(SymbolPrototype, this)
      ? new NativeSymbol(description)
      // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
      : description === undefined ? NativeSymbol() : NativeSymbol(description);
    if (description === '') EmptyStringDescriptionStore[result] = true;
    return result;
  };

  copyConstructorProperties(SymbolWrapper, NativeSymbol);
  SymbolWrapper.prototype = SymbolPrototype;
  SymbolPrototype.constructor = SymbolWrapper;

  var NATIVE_SYMBOL = String(NativeSymbol('test')) == 'Symbol(test)';
  var thisSymbolValue = uncurryThis(SymbolPrototype.valueOf);
  var symbolDescriptiveString = uncurryThis(SymbolPrototype.toString);
  var regexp = /^Symbol\((.*)\)[^)]+$/;
  var replace = uncurryThis(''.replace);
  var stringSlice = uncurryThis(''.slice);

  defineBuiltInAccessor(SymbolPrototype, 'description', {
    configurable: true,
    get: function description() {
      var symbol = thisSymbolValue(this);
      if (hasOwn(EmptyStringDescriptionStore, symbol)) return '';
      var string = symbolDescriptiveString(symbol);
      var desc = NATIVE_SYMBOL ? stringSlice(string, 7, -1) : replace(string, regexp, '$1');
      return desc === '' ? undefined : desc;
    }
  });

  $({ global: true, constructor: true, forced: true }, {
    Symbol: SymbolWrapper
  });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.for.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.for.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
var NATIVE_SYMBOL_REGISTRY = __webpack_require__(/*! ../internals/symbol-registry-detection */ "./node_modules/core-js/internals/symbol-registry-detection.js");

var StringToSymbolRegistry = shared('string-to-symbol-registry');
var SymbolToStringRegistry = shared('symbol-to-string-registry');

// `Symbol.for` method
// https://tc39.es/ecma262/#sec-symbol.for
$({ target: 'Symbol', stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
  'for': function (key) {
    var string = toString(key);
    if (hasOwn(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
    var symbol = getBuiltIn('Symbol')(string);
    StringToSymbolRegistry[string] = symbol;
    SymbolToStringRegistry[symbol] = string;
    return symbol;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.iterator.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.iterator.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js/internals/well-known-symbol-define.js");

// `Symbol.iterator` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.iterator
defineWellKnownSymbol('iterator');


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// TODO: Remove this module from `core-js@4` since it's split to modules listed below
__webpack_require__(/*! ../modules/es.symbol.constructor */ "./node_modules/core-js/modules/es.symbol.constructor.js");
__webpack_require__(/*! ../modules/es.symbol.for */ "./node_modules/core-js/modules/es.symbol.for.js");
__webpack_require__(/*! ../modules/es.symbol.key-for */ "./node_modules/core-js/modules/es.symbol.key-for.js");
__webpack_require__(/*! ../modules/es.json.stringify */ "./node_modules/core-js/modules/es.json.stringify.js");
__webpack_require__(/*! ../modules/es.object.get-own-property-symbols */ "./node_modules/core-js/modules/es.object.get-own-property-symbols.js");


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.key-for.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.key-for.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js/internals/is-symbol.js");
var tryToString = __webpack_require__(/*! ../internals/try-to-string */ "./node_modules/core-js/internals/try-to-string.js");
var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
var NATIVE_SYMBOL_REGISTRY = __webpack_require__(/*! ../internals/symbol-registry-detection */ "./node_modules/core-js/internals/symbol-registry-detection.js");

var SymbolToStringRegistry = shared('symbol-to-string-registry');

// `Symbol.keyFor` method
// https://tc39.es/ecma262/#sec-symbol.keyfor
$({ target: 'Symbol', stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(tryToString(sym) + ' is not a symbol');
    if (hasOwn(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.to-primitive.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.to-primitive.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js/internals/well-known-symbol-define.js");
var defineSymbolToPrimitive = __webpack_require__(/*! ../internals/symbol-define-to-primitive */ "./node_modules/core-js/internals/symbol-define-to-primitive.js");

// `Symbol.toPrimitive` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.toprimitive
defineWellKnownSymbol('toPrimitive');

// `Symbol.prototype[@@toPrimitive]` method
// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
defineSymbolToPrimitive();


/***/ }),

/***/ "./node_modules/core-js/modules/web.dom-collections.iterator.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/web.dom-collections.iterator.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var DOMIterables = __webpack_require__(/*! ../internals/dom-iterables */ "./node_modules/core-js/internals/dom-iterables.js");
var DOMTokenListPrototype = __webpack_require__(/*! ../internals/dom-token-list-prototype */ "./node_modules/core-js/internals/dom-token-list-prototype.js");
var ArrayIteratorMethods = __webpack_require__(/*! ../modules/es.array.iterator */ "./node_modules/core-js/modules/es.array.iterator.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var ITERATOR = wellKnownSymbol('iterator');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var ArrayValues = ArrayIteratorMethods.values;

var handlePrototype = function (CollectionPrototype, COLLECTION_NAME) {
  if (CollectionPrototype) {
    // some Chrome versions have non-configurable methods on DOMTokenList
    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
      createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
    } catch (error) {
      CollectionPrototype[ITERATOR] = ArrayValues;
    }
    if (!CollectionPrototype[TO_STRING_TAG]) {
      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
    }
    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
      } catch (error) {
        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
      }
    }
  }
};

for (var COLLECTION_NAME in DOMIterables) {
  handlePrototype(global[COLLECTION_NAME] && global[COLLECTION_NAME].prototype, COLLECTION_NAME);
}

handlePrototype(DOMTokenListPrototype, 'DOMTokenList');


/***/ }),

/***/ "./node_modules/tinymce/tinymce.js":
/*!*****************************************!*\
  !*** ./node_modules/tinymce/tinymce.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * TinyMCE version 6.4.2 (2023-04-26)
 */

(function () {
    'use strict';

    var typeOf$1 = function (x) {
      if (x === null) {
        return 'null';
      }
      if (x === undefined) {
        return 'undefined';
      }
      var t = typeof x;
      if (t === 'object' && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'Array')) {
        return 'array';
      }
      if (t === 'object' && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'String')) {
        return 'string';
      }
      return t;
    };
    var isEquatableType = function (x) {
      return [
        'undefined',
        'boolean',
        'number',
        'string',
        'function',
        'xml',
        'null'
      ].indexOf(x) !== -1;
    };

    var sort$1 = function (xs, compareFn) {
      var clone = Array.prototype.slice.call(xs);
      return clone.sort(compareFn);
    };

    var contramap = function (eqa, f) {
      return eq$2(function (x, y) {
        return eqa.eq(f(x), f(y));
      });
    };
    var eq$2 = function (f) {
      return { eq: f };
    };
    var tripleEq = eq$2(function (x, y) {
      return x === y;
    });
    var eqString = tripleEq;
    var eqArray = function (eqa) {
      return eq$2(function (x, y) {
        if (x.length !== y.length) {
          return false;
        }
        var len = x.length;
        for (var i = 0; i < len; i++) {
          if (!eqa.eq(x[i], y[i])) {
            return false;
          }
        }
        return true;
      });
    };
    var eqSortedArray = function (eqa, compareFn) {
      return contramap(eqArray(eqa), function (xs) {
        return sort$1(xs, compareFn);
      });
    };
    var eqRecord = function (eqa) {
      return eq$2(function (x, y) {
        var kx = Object.keys(x);
        var ky = Object.keys(y);
        if (!eqSortedArray(eqString).eq(kx, ky)) {
          return false;
        }
        var len = kx.length;
        for (var i = 0; i < len; i++) {
          var q = kx[i];
          if (!eqa.eq(x[q], y[q])) {
            return false;
          }
        }
        return true;
      });
    };
    var eqAny = eq$2(function (x, y) {
      if (x === y) {
        return true;
      }
      var tx = typeOf$1(x);
      var ty = typeOf$1(y);
      if (tx !== ty) {
        return false;
      }
      if (isEquatableType(tx)) {
        return x === y;
      } else if (tx === 'array') {
        return eqArray(eqAny).eq(x, y);
      } else if (tx === 'object') {
        return eqRecord(eqAny).eq(x, y);
      }
      return false;
    });

    const getPrototypeOf$2 = Object.getPrototypeOf;
    const hasProto = (v, constructor, predicate) => {
      var _a;
      if (predicate(v, constructor.prototype)) {
        return true;
      } else {
        return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;
      }
    };
    const typeOf = x => {
      const t = typeof x;
      if (x === null) {
        return 'null';
      } else if (t === 'object' && Array.isArray(x)) {
        return 'array';
      } else if (t === 'object' && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) {
        return 'string';
      } else {
        return t;
      }
    };
    const isType$1 = type => value => typeOf(value) === type;
    const isSimpleType = type => value => typeof value === type;
    const eq$1 = t => a => t === a;
    const is$4 = (value, constructor) => isObject(value) && hasProto(value, constructor, (o, proto) => getPrototypeOf$2(o) === proto);
    const isString = isType$1('string');
    const isObject = isType$1('object');
    const isPlainObject = value => is$4(value, Object);
    const isArray$1 = isType$1('array');
    const isNull = eq$1(null);
    const isBoolean = isSimpleType('boolean');
    const isUndefined = eq$1(undefined);
    const isNullable = a => a === null || a === undefined;
    const isNonNullable = a => !isNullable(a);
    const isFunction = isSimpleType('function');
    const isNumber = isSimpleType('number');
    const isArrayOf = (value, pred) => {
      if (isArray$1(value)) {
        for (let i = 0, len = value.length; i < len; ++i) {
          if (!pred(value[i])) {
            return false;
          }
        }
        return true;
      }
      return false;
    };

    const noop = () => {
    };
    const compose = (fa, fb) => {
      return (...args) => {
        return fa(fb.apply(null, args));
      };
    };
    const compose1 = (fbc, fab) => a => fbc(fab(a));
    const constant = value => {
      return () => {
        return value;
      };
    };
    const identity = x => {
      return x;
    };
    const tripleEquals = (a, b) => {
      return a === b;
    };
    function curry(fn, ...initialArgs) {
      return (...restArgs) => {
        const all = initialArgs.concat(restArgs);
        return fn.apply(null, all);
      };
    }
    const not = f => t => !f(t);
    const die = msg => {
      return () => {
        throw new Error(msg);
      };
    };
    const apply$1 = f => {
      return f();
    };
    const call = f => {
      f();
    };
    const never = constant(false);
    const always = constant(true);

    class Optional {
      constructor(tag, value) {
        this.tag = tag;
        this.value = value;
      }
      static some(value) {
        return new Optional(true, value);
      }
      static none() {
        return Optional.singletonNone;
      }
      fold(onNone, onSome) {
        if (this.tag) {
          return onSome(this.value);
        } else {
          return onNone();
        }
      }
      isSome() {
        return this.tag;
      }
      isNone() {
        return !this.tag;
      }
      map(mapper) {
        if (this.tag) {
          return Optional.some(mapper(this.value));
        } else {
          return Optional.none();
        }
      }
      bind(binder) {
        if (this.tag) {
          return binder(this.value);
        } else {
          return Optional.none();
        }
      }
      exists(predicate) {
        return this.tag && predicate(this.value);
      }
      forall(predicate) {
        return !this.tag || predicate(this.value);
      }
      filter(predicate) {
        if (!this.tag || predicate(this.value)) {
          return this;
        } else {
          return Optional.none();
        }
      }
      getOr(replacement) {
        return this.tag ? this.value : replacement;
      }
      or(replacement) {
        return this.tag ? this : replacement;
      }
      getOrThunk(thunk) {
        return this.tag ? this.value : thunk();
      }
      orThunk(thunk) {
        return this.tag ? this : thunk();
      }
      getOrDie(message) {
        if (!this.tag) {
          throw new Error(message !== null && message !== void 0 ? message : 'Called getOrDie on None');
        } else {
          return this.value;
        }
      }
      static from(value) {
        return isNonNullable(value) ? Optional.some(value) : Optional.none();
      }
      getOrNull() {
        return this.tag ? this.value : null;
      }
      getOrUndefined() {
        return this.value;
      }
      each(worker) {
        if (this.tag) {
          worker(this.value);
        }
      }
      toArray() {
        return this.tag ? [this.value] : [];
      }
      toString() {
        return this.tag ? `some(${ this.value })` : 'none()';
      }
    }
    Optional.singletonNone = new Optional(false);

    const nativeSlice = Array.prototype.slice;
    const nativeIndexOf = Array.prototype.indexOf;
    const nativePush = Array.prototype.push;
    const rawIndexOf = (ts, t) => nativeIndexOf.call(ts, t);
    const indexOf$1 = (xs, x) => {
      const r = rawIndexOf(xs, x);
      return r === -1 ? Optional.none() : Optional.some(r);
    };
    const contains$2 = (xs, x) => rawIndexOf(xs, x) > -1;
    const exists = (xs, pred) => {
      for (let i = 0, len = xs.length; i < len; i++) {
        const x = xs[i];
        if (pred(x, i)) {
          return true;
        }
      }
      return false;
    };
    const map$3 = (xs, f) => {
      const len = xs.length;
      const r = new Array(len);
      for (let i = 0; i < len; i++) {
        const x = xs[i];
        r[i] = f(x, i);
      }
      return r;
    };
    const each$e = (xs, f) => {
      for (let i = 0, len = xs.length; i < len; i++) {
        const x = xs[i];
        f(x, i);
      }
    };
    const eachr = (xs, f) => {
      for (let i = xs.length - 1; i >= 0; i--) {
        const x = xs[i];
        f(x, i);
      }
    };
    const partition$2 = (xs, pred) => {
      const pass = [];
      const fail = [];
      for (let i = 0, len = xs.length; i < len; i++) {
        const x = xs[i];
        const arr = pred(x, i) ? pass : fail;
        arr.push(x);
      }
      return {
        pass,
        fail
      };
    };
    const filter$5 = (xs, pred) => {
      const r = [];
      for (let i = 0, len = xs.length; i < len; i++) {
        const x = xs[i];
        if (pred(x, i)) {
          r.push(x);
        }
      }
      return r;
    };
    const foldr = (xs, f, acc) => {
      eachr(xs, (x, i) => {
        acc = f(acc, x, i);
      });
      return acc;
    };
    const foldl = (xs, f, acc) => {
      each$e(xs, (x, i) => {
        acc = f(acc, x, i);
      });
      return acc;
    };
    const findUntil$1 = (xs, pred, until) => {
      for (let i = 0, len = xs.length; i < len; i++) {
        const x = xs[i];
        if (pred(x, i)) {
          return Optional.some(x);
        } else if (until(x, i)) {
          break;
        }
      }
      return Optional.none();
    };
    const find$2 = (xs, pred) => {
      return findUntil$1(xs, pred, never);
    };
    const findIndex$2 = (xs, pred) => {
      for (let i = 0, len = xs.length; i < len; i++) {
        const x = xs[i];
        if (pred(x, i)) {
          return Optional.some(i);
        }
      }
      return Optional.none();
    };
    const flatten = xs => {
      const r = [];
      for (let i = 0, len = xs.length; i < len; ++i) {
        if (!isArray$1(xs[i])) {
          throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);
        }
        nativePush.apply(r, xs[i]);
      }
      return r;
    };
    const bind$3 = (xs, f) => flatten(map$3(xs, f));
    const forall = (xs, pred) => {
      for (let i = 0, len = xs.length; i < len; ++i) {
        const x = xs[i];
        if (pred(x, i) !== true) {
          return false;
        }
      }
      return true;
    };
    const reverse = xs => {
      const r = nativeSlice.call(xs, 0);
      r.reverse();
      return r;
    };
    const difference = (a1, a2) => filter$5(a1, x => !contains$2(a2, x));
    const mapToObject = (xs, f) => {
      const r = {};
      for (let i = 0, len = xs.length; i < len; i++) {
        const x = xs[i];
        r[String(x)] = f(x, i);
      }
      return r;
    };
    const sort = (xs, comparator) => {
      const copy = nativeSlice.call(xs, 0);
      copy.sort(comparator);
      return copy;
    };
    const get$b = (xs, i) => i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();
    const head = xs => get$b(xs, 0);
    const last$3 = xs => get$b(xs, xs.length - 1);
    const from = isFunction(Array.from) ? Array.from : x => nativeSlice.call(x);
    const findMap = (arr, f) => {
      for (let i = 0; i < arr.length; i++) {
        const r = f(arr[i], i);
        if (r.isSome()) {
          return r;
        }
      }
      return Optional.none();
    };
    const unique$1 = (xs, comparator) => {
      const r = [];
      const isDuplicated = isFunction(comparator) ? x => exists(r, i => comparator(i, x)) : x => contains$2(r, x);
      for (let i = 0, len = xs.length; i < len; i++) {
        const x = xs[i];
        if (!isDuplicated(x)) {
          r.push(x);
        }
      }
      return r;
    };

    const keys = Object.keys;
    const hasOwnProperty$2 = Object.hasOwnProperty;
    const each$d = (obj, f) => {
      const props = keys(obj);
      for (let k = 0, len = props.length; k < len; k++) {
        const i = props[k];
        const x = obj[i];
        f(x, i);
      }
    };
    const map$2 = (obj, f) => {
      return tupleMap(obj, (x, i) => ({
        k: i,
        v: f(x, i)
      }));
    };
    const tupleMap = (obj, f) => {
      const r = {};
      each$d(obj, (x, i) => {
        const tuple = f(x, i);
        r[tuple.k] = tuple.v;
      });
      return r;
    };
    const objAcc = r => (x, i) => {
      r[i] = x;
    };
    const internalFilter = (obj, pred, onTrue, onFalse) => {
      each$d(obj, (x, i) => {
        (pred(x, i) ? onTrue : onFalse)(x, i);
      });
    };
    const bifilter = (obj, pred) => {
      const t = {};
      const f = {};
      internalFilter(obj, pred, objAcc(t), objAcc(f));
      return {
        t,
        f
      };
    };
    const filter$4 = (obj, pred) => {
      const t = {};
      internalFilter(obj, pred, objAcc(t), noop);
      return t;
    };
    const mapToArray = (obj, f) => {
      const r = [];
      each$d(obj, (value, name) => {
        r.push(f(value, name));
      });
      return r;
    };
    const values = obj => {
      return mapToArray(obj, identity);
    };
    const get$a = (obj, key) => {
      return has$2(obj, key) ? Optional.from(obj[key]) : Optional.none();
    };
    const has$2 = (obj, key) => hasOwnProperty$2.call(obj, key);
    const hasNonNullableKey = (obj, key) => has$2(obj, key) && obj[key] !== undefined && obj[key] !== null;
    const equal$1 = (a1, a2, eq = eqAny) => eqRecord(eq).eq(a1, a2);

    const stringArray = a => {
      const all = {};
      each$e(a, key => {
        all[key] = {};
      });
      return keys(all);
    };

    const isArrayLike = o => o.length !== undefined;
    const isArray = Array.isArray;
    const toArray$1 = obj => {
      if (!isArray(obj)) {
        const array = [];
        for (let i = 0, l = obj.length; i < l; i++) {
          array[i] = obj[i];
        }
        return array;
      } else {
        return obj;
      }
    };
    const each$c = (o, cb, s) => {
      if (!o) {
        return false;
      }
      s = s || o;
      if (isArrayLike(o)) {
        for (let n = 0, l = o.length; n < l; n++) {
          if (cb.call(s, o[n], n, o) === false) {
            return false;
          }
        }
      } else {
        for (const n in o) {
          if (has$2(o, n)) {
            if (cb.call(s, o[n], n, o) === false) {
              return false;
            }
          }
        }
      }
      return true;
    };
    const map$1 = (array, callback) => {
      const out = [];
      each$c(array, (item, index) => {
        out.push(callback(item, index, array));
      });
      return out;
    };
    const filter$3 = (a, f) => {
      const o = [];
      each$c(a, (v, index) => {
        if (!f || f(v, index, a)) {
          o.push(v);
        }
      });
      return o;
    };
    const indexOf = (a, v) => {
      if (a) {
        for (let i = 0, l = a.length; i < l; i++) {
          if (a[i] === v) {
            return i;
          }
        }
      }
      return -1;
    };
    const reduce = (collection, iteratee, accumulator, thisArg) => {
      let acc = isUndefined(accumulator) ? collection[0] : accumulator;
      for (let i = 0; i < collection.length; i++) {
        acc = iteratee.call(thisArg, acc, collection[i], i);
      }
      return acc;
    };
    const findIndex$1 = (array, predicate, thisArg) => {
      for (let i = 0, l = array.length; i < l; i++) {
        if (predicate.call(thisArg, array[i], i, array)) {
          return i;
        }
      }
      return -1;
    };
    const last$2 = collection => collection[collection.length - 1];

    const cached = f => {
      let called = false;
      let r;
      return (...args) => {
        if (!called) {
          called = true;
          r = f.apply(null, args);
        }
        return r;
      };
    };

    const DeviceType = (os, browser, userAgent, mediaMatch) => {
      const isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;
      const isiPhone = os.isiOS() && !isiPad;
      const isMobile = os.isiOS() || os.isAndroid();
      const isTouch = isMobile || mediaMatch('(pointer:coarse)');
      const isTablet = isiPad || !isiPhone && isMobile && mediaMatch('(min-device-width:768px)');
      const isPhone = isiPhone || isMobile && !isTablet;
      const iOSwebview = browser.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;
      const isDesktop = !isPhone && !isTablet && !iOSwebview;
      return {
        isiPad: constant(isiPad),
        isiPhone: constant(isiPhone),
        isTablet: constant(isTablet),
        isPhone: constant(isPhone),
        isTouch: constant(isTouch),
        isAndroid: os.isAndroid,
        isiOS: os.isiOS,
        isWebView: constant(iOSwebview),
        isDesktop: constant(isDesktop)
      };
    };

    const firstMatch = (regexes, s) => {
      for (let i = 0; i < regexes.length; i++) {
        const x = regexes[i];
        if (x.test(s)) {
          return x;
        }
      }
      return undefined;
    };
    const find$1 = (regexes, agent) => {
      const r = firstMatch(regexes, agent);
      if (!r) {
        return {
          major: 0,
          minor: 0
        };
      }
      const group = i => {
        return Number(agent.replace(r, '$' + i));
      };
      return nu$3(group(1), group(2));
    };
    const detect$5 = (versionRegexes, agent) => {
      const cleanedAgent = String(agent).toLowerCase();
      if (versionRegexes.length === 0) {
        return unknown$2();
      }
      return find$1(versionRegexes, cleanedAgent);
    };
    const unknown$2 = () => {
      return nu$3(0, 0);
    };
    const nu$3 = (major, minor) => {
      return {
        major,
        minor
      };
    };
    const Version = {
      nu: nu$3,
      detect: detect$5,
      unknown: unknown$2
    };

    const detectBrowser$1 = (browsers, userAgentData) => {
      return findMap(userAgentData.brands, uaBrand => {
        const lcBrand = uaBrand.brand.toLowerCase();
        return find$2(browsers, browser => {
          var _a;
          return lcBrand === ((_a = browser.brand) === null || _a === void 0 ? void 0 : _a.toLowerCase());
        }).map(info => ({
          current: info.name,
          version: Version.nu(parseInt(uaBrand.version, 10), 0)
        }));
      });
    };

    const detect$4 = (candidates, userAgent) => {
      const agent = String(userAgent).toLowerCase();
      return find$2(candidates, candidate => {
        return candidate.search(agent);
      });
    };
    const detectBrowser = (browsers, userAgent) => {
      return detect$4(browsers, userAgent).map(browser => {
        const version = Version.detect(browser.versionRegexes, userAgent);
        return {
          current: browser.name,
          version
        };
      });
    };
    const detectOs = (oses, userAgent) => {
      return detect$4(oses, userAgent).map(os => {
        const version = Version.detect(os.versionRegexes, userAgent);
        return {
          current: os.name,
          version
        };
      });
    };

    const removeFromStart = (str, numChars) => {
      return str.substring(numChars);
    };

    const checkRange = (str, substr, start) => substr === '' || str.length >= substr.length && str.substr(start, start + substr.length) === substr;
    const removeLeading = (str, prefix) => {
      return startsWith(str, prefix) ? removeFromStart(str, prefix.length) : str;
    };
    const contains$1 = (str, substr, start = 0, end) => {
      const idx = str.indexOf(substr, start);
      if (idx !== -1) {
        return isUndefined(end) ? true : idx + substr.length <= end;
      } else {
        return false;
      }
    };
    const startsWith = (str, prefix) => {
      return checkRange(str, prefix, 0);
    };
    const endsWith = (str, suffix) => {
      return checkRange(str, suffix, str.length - suffix.length);
    };
    const blank = r => s => s.replace(r, '');
    const trim$3 = blank(/^\s+|\s+$/g);
    const lTrim = blank(/^\s+/g);
    const rTrim = blank(/\s+$/g);
    const isNotEmpty = s => s.length > 0;
    const isEmpty$3 = s => !isNotEmpty(s);
    const repeat = (s, count) => count <= 0 ? '' : new Array(count + 1).join(s);
    const toInt = (value, radix = 10) => {
      const num = parseInt(value, radix);
      return isNaN(num) ? Optional.none() : Optional.some(num);
    };

    const normalVersionRegex = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/;
    const checkContains = target => {
      return uastring => {
        return contains$1(uastring, target);
      };
    };
    const browsers = [
      {
        name: 'Edge',
        versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
        search: uastring => {
          return contains$1(uastring, 'edge/') && contains$1(uastring, 'chrome') && contains$1(uastring, 'safari') && contains$1(uastring, 'applewebkit');
        }
      },
      {
        name: 'Chromium',
        brand: 'Chromium',
        versionRegexes: [
          /.*?chrome\/([0-9]+)\.([0-9]+).*/,
          normalVersionRegex
        ],
        search: uastring => {
          return contains$1(uastring, 'chrome') && !contains$1(uastring, 'chromeframe');
        }
      },
      {
        name: 'IE',
        versionRegexes: [
          /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
          /.*?rv:([0-9]+)\.([0-9]+).*/
        ],
        search: uastring => {
          return contains$1(uastring, 'msie') || contains$1(uastring, 'trident');
        }
      },
      {
        name: 'Opera',
        versionRegexes: [
          normalVersionRegex,
          /.*?opera\/([0-9]+)\.([0-9]+).*/
        ],
        search: checkContains('opera')
      },
      {
        name: 'Firefox',
        versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
        search: checkContains('firefox')
      },
      {
        name: 'Safari',
        versionRegexes: [
          normalVersionRegex,
          /.*?cpu os ([0-9]+)_([0-9]+).*/
        ],
        search: uastring => {
          return (contains$1(uastring, 'safari') || contains$1(uastring, 'mobile/')) && contains$1(uastring, 'applewebkit');
        }
      }
    ];
    const oses = [
      {
        name: 'Windows',
        search: checkContains('win'),
        versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: 'iOS',
        search: uastring => {
          return contains$1(uastring, 'iphone') || contains$1(uastring, 'ipad');
        },
        versionRegexes: [
          /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
          /.*cpu os ([0-9]+)_([0-9]+).*/,
          /.*cpu iphone os ([0-9]+)_([0-9]+).*/
        ]
      },
      {
        name: 'Android',
        search: checkContains('android'),
        versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: 'macOS',
        search: checkContains('mac os x'),
        versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
      },
      {
        name: 'Linux',
        search: checkContains('linux'),
        versionRegexes: []
      },
      {
        name: 'Solaris',
        search: checkContains('sunos'),
        versionRegexes: []
      },
      {
        name: 'FreeBSD',
        search: checkContains('freebsd'),
        versionRegexes: []
      },
      {
        name: 'ChromeOS',
        search: checkContains('cros'),
        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
      }
    ];
    const PlatformInfo = {
      browsers: constant(browsers),
      oses: constant(oses)
    };

    const edge = 'Edge';
    const chromium = 'Chromium';
    const ie = 'IE';
    const opera = 'Opera';
    const firefox = 'Firefox';
    const safari = 'Safari';
    const unknown$1 = () => {
      return nu$2({
        current: undefined,
        version: Version.unknown()
      });
    };
    const nu$2 = info => {
      const current = info.current;
      const version = info.version;
      const isBrowser = name => () => current === name;
      return {
        current,
        version,
        isEdge: isBrowser(edge),
        isChromium: isBrowser(chromium),
        isIE: isBrowser(ie),
        isOpera: isBrowser(opera),
        isFirefox: isBrowser(firefox),
        isSafari: isBrowser(safari)
      };
    };
    const Browser = {
      unknown: unknown$1,
      nu: nu$2,
      edge: constant(edge),
      chromium: constant(chromium),
      ie: constant(ie),
      opera: constant(opera),
      firefox: constant(firefox),
      safari: constant(safari)
    };

    const windows = 'Windows';
    const ios = 'iOS';
    const android = 'Android';
    const linux = 'Linux';
    const macos = 'macOS';
    const solaris = 'Solaris';
    const freebsd = 'FreeBSD';
    const chromeos = 'ChromeOS';
    const unknown = () => {
      return nu$1({
        current: undefined,
        version: Version.unknown()
      });
    };
    const nu$1 = info => {
      const current = info.current;
      const version = info.version;
      const isOS = name => () => current === name;
      return {
        current,
        version,
        isWindows: isOS(windows),
        isiOS: isOS(ios),
        isAndroid: isOS(android),
        isMacOS: isOS(macos),
        isLinux: isOS(linux),
        isSolaris: isOS(solaris),
        isFreeBSD: isOS(freebsd),
        isChromeOS: isOS(chromeos)
      };
    };
    const OperatingSystem = {
      unknown,
      nu: nu$1,
      windows: constant(windows),
      ios: constant(ios),
      android: constant(android),
      linux: constant(linux),
      macos: constant(macos),
      solaris: constant(solaris),
      freebsd: constant(freebsd),
      chromeos: constant(chromeos)
    };

    const detect$3 = (userAgent, userAgentDataOpt, mediaMatch) => {
      const browsers = PlatformInfo.browsers();
      const oses = PlatformInfo.oses();
      const browser = userAgentDataOpt.bind(userAgentData => detectBrowser$1(browsers, userAgentData)).orThunk(() => detectBrowser(browsers, userAgent)).fold(Browser.unknown, Browser.nu);
      const os = detectOs(oses, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);
      const deviceType = DeviceType(os, browser, userAgent, mediaMatch);
      return {
        browser,
        os,
        deviceType
      };
    };
    const PlatformDetection = { detect: detect$3 };

    const mediaMatch = query => window.matchMedia(query).matches;
    let platform$2 = cached(() => PlatformDetection.detect(navigator.userAgent, Optional.from(navigator.userAgentData), mediaMatch));
    const detect$2 = () => platform$2();

    const userAgent = navigator.userAgent;
    const platform$1 = detect$2();
    const browser$1 = platform$1.browser;
    const os = platform$1.os;
    const deviceType = platform$1.deviceType;
    const windowsPhone = userAgent.indexOf('Windows Phone') !== -1;
    const Env = {
      transparentSrc: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',
      documentMode: browser$1.isIE() ? document.documentMode || 7 : 10,
      cacheSuffix: null,
      container: null,
      canHaveCSP: !browser$1.isIE(),
      windowsPhone,
      browser: {
        current: browser$1.current,
        version: browser$1.version,
        isChromium: browser$1.isChromium,
        isEdge: browser$1.isEdge,
        isFirefox: browser$1.isFirefox,
        isIE: browser$1.isIE,
        isOpera: browser$1.isOpera,
        isSafari: browser$1.isSafari
      },
      os: {
        current: os.current,
        version: os.version,
        isAndroid: os.isAndroid,
        isChromeOS: os.isChromeOS,
        isFreeBSD: os.isFreeBSD,
        isiOS: os.isiOS,
        isLinux: os.isLinux,
        isMacOS: os.isMacOS,
        isSolaris: os.isSolaris,
        isWindows: os.isWindows
      },
      deviceType: {
        isDesktop: deviceType.isDesktop,
        isiPad: deviceType.isiPad,
        isiPhone: deviceType.isiPhone,
        isPhone: deviceType.isPhone,
        isTablet: deviceType.isTablet,
        isTouch: deviceType.isTouch,
        isWebView: deviceType.isWebView
      }
    };

    const whiteSpaceRegExp$1 = /^\s*|\s*$/g;
    const trim$2 = str => {
      return isNullable(str) ? '' : ('' + str).replace(whiteSpaceRegExp$1, '');
    };
    const is$3 = (obj, type) => {
      if (!type) {
        return obj !== undefined;
      }
      if (type === 'array' && isArray(obj)) {
        return true;
      }
      return typeof obj === type;
    };
    const makeMap$4 = (items, delim, map = {}) => {
      const resolvedItems = isString(items) ? items.split(delim || ',') : items || [];
      let i = resolvedItems.length;
      while (i--) {
        map[resolvedItems[i]] = {};
      }
      return map;
    };
    const hasOwnProperty$1 = has$2;
    const extend$3 = (obj, ...exts) => {
      for (let i = 0; i < exts.length; i++) {
        const ext = exts[i];
        for (const name in ext) {
          if (has$2(ext, name)) {
            const value = ext[name];
            if (value !== undefined) {
              obj[name] = value;
            }
          }
        }
      }
      return obj;
    };
    const walk$4 = function (o, f, n, s) {
      s = s || this;
      if (o) {
        if (n) {
          o = o[n];
        }
        each$c(o, (o, i) => {
          if (f.call(s, o, i, n) === false) {
            return false;
          } else {
            walk$4(o, f, n, s);
            return true;
          }
        });
      }
    };
    const resolve$3 = (n, o = window) => {
      const path = n.split('.');
      for (let i = 0, l = path.length; i < l; i++) {
        o = o[path[i]];
        if (!o) {
          break;
        }
      }
      return o;
    };
    const explode$3 = (s, d) => {
      if (isArray$1(s)) {
        return s;
      } else if (s === '') {
        return [];
      } else {
        return map$1(s.split(d || ','), trim$2);
      }
    };
    const _addCacheSuffix = url => {
      const cacheSuffix = Env.cacheSuffix;
      if (cacheSuffix) {
        url += (url.indexOf('?') === -1 ? '?' : '&') + cacheSuffix;
      }
      return url;
    };
    const Tools = {
      trim: trim$2,
      isArray: isArray,
      is: is$3,
      toArray: toArray$1,
      makeMap: makeMap$4,
      each: each$c,
      map: map$1,
      grep: filter$3,
      inArray: indexOf,
      hasOwn: hasOwnProperty$1,
      extend: extend$3,
      walk: walk$4,
      resolve: resolve$3,
      explode: explode$3,
      _addCacheSuffix
    };

    const is$2 = (lhs, rhs, comparator = tripleEquals) => lhs.exists(left => comparator(left, rhs));
    const cat = arr => {
      const r = [];
      const push = x => {
        r.push(x);
      };
      for (let i = 0; i < arr.length; i++) {
        arr[i].each(push);
      }
      return r;
    };
    const lift2 = (oa, ob, f) => oa.isSome() && ob.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie())) : Optional.none();
    const lift3 = (oa, ob, oc, f) => oa.isSome() && ob.isSome() && oc.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie(), oc.getOrDie())) : Optional.none();
    const someIf = (b, a) => b ? Optional.some(a) : Optional.none();

    const Global = typeof window !== 'undefined' ? window : Function('return this;')();

    const path = (parts, scope) => {
      let o = scope !== undefined && scope !== null ? scope : Global;
      for (let i = 0; i < parts.length && o !== undefined && o !== null; ++i) {
        o = o[parts[i]];
      }
      return o;
    };
    const resolve$2 = (p, scope) => {
      const parts = p.split('.');
      return path(parts, scope);
    };

    const unsafe = (name, scope) => {
      return resolve$2(name, scope);
    };
    const getOrDie = (name, scope) => {
      const actual = unsafe(name, scope);
      if (actual === undefined || actual === null) {
        throw new Error(name + ' not available on this browser');
      }
      return actual;
    };

    const getPrototypeOf$1 = Object.getPrototypeOf;
    const sandHTMLElement = scope => {
      return getOrDie('HTMLElement', scope);
    };
    const isPrototypeOf = x => {
      const scope = resolve$2('ownerDocument.defaultView', x);
      return isObject(x) && (sandHTMLElement(scope).prototype.isPrototypeOf(x) || /^HTML\w*Element$/.test(getPrototypeOf$1(x).constructor.name));
    };

    const COMMENT = 8;
    const DOCUMENT = 9;
    const DOCUMENT_FRAGMENT = 11;
    const ELEMENT = 1;
    const TEXT = 3;

    const name = element => {
      const r = element.dom.nodeName;
      return r.toLowerCase();
    };
    const type$1 = element => element.dom.nodeType;
    const isType = t => element => type$1(element) === t;
    const isComment$1 = element => type$1(element) === COMMENT || name(element) === '#comment';
    const isHTMLElement = element => isElement$7(element) && isPrototypeOf(element.dom);
    const isElement$7 = isType(ELEMENT);
    const isText$b = isType(TEXT);
    const isDocument$2 = isType(DOCUMENT);
    const isDocumentFragment$1 = isType(DOCUMENT_FRAGMENT);
    const isTag = tag => e => isElement$7(e) && name(e) === tag;

    const rawSet = (dom, key, value) => {
      if (isString(value) || isBoolean(value) || isNumber(value)) {
        dom.setAttribute(key, value + '');
      } else {
        console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);
        throw new Error('Attribute value was not simple');
      }
    };
    const set$3 = (element, key, value) => {
      rawSet(element.dom, key, value);
    };
    const setAll$1 = (element, attrs) => {
      const dom = element.dom;
      each$d(attrs, (v, k) => {
        rawSet(dom, k, v);
      });
    };
    const get$9 = (element, key) => {
      const v = element.dom.getAttribute(key);
      return v === null ? undefined : v;
    };
    const getOpt = (element, key) => Optional.from(get$9(element, key));
    const has$1 = (element, key) => {
      const dom = element.dom;
      return dom && dom.hasAttribute ? dom.hasAttribute(key) : false;
    };
    const remove$b = (element, key) => {
      element.dom.removeAttribute(key);
    };
    const hasNone = element => {
      const attrs = element.dom.attributes;
      return attrs === undefined || attrs === null || attrs.length === 0;
    };
    const clone$4 = element => foldl(element.dom.attributes, (acc, attr) => {
      acc[attr.name] = attr.value;
      return acc;
    }, {});

    const read$4 = (element, attr) => {
      const value = get$9(element, attr);
      return value === undefined || value === '' ? [] : value.split(' ');
    };
    const add$4 = (element, attr, id) => {
      const old = read$4(element, attr);
      const nu = old.concat([id]);
      set$3(element, attr, nu.join(' '));
      return true;
    };
    const remove$a = (element, attr, id) => {
      const nu = filter$5(read$4(element, attr), v => v !== id);
      if (nu.length > 0) {
        set$3(element, attr, nu.join(' '));
      } else {
        remove$b(element, attr);
      }
      return false;
    };

    const supports = element => element.dom.classList !== undefined;
    const get$8 = element => read$4(element, 'class');
    const add$3 = (element, clazz) => add$4(element, 'class', clazz);
    const remove$9 = (element, clazz) => remove$a(element, 'class', clazz);
    const toggle$2 = (element, clazz) => {
      if (contains$2(get$8(element), clazz)) {
        return remove$9(element, clazz);
      } else {
        return add$3(element, clazz);
      }
    };

    const add$2 = (element, clazz) => {
      if (supports(element)) {
        element.dom.classList.add(clazz);
      } else {
        add$3(element, clazz);
      }
    };
    const cleanClass = element => {
      const classList = supports(element) ? element.dom.classList : get$8(element);
      if (classList.length === 0) {
        remove$b(element, 'class');
      }
    };
    const remove$8 = (element, clazz) => {
      if (supports(element)) {
        const classList = element.dom.classList;
        classList.remove(clazz);
      } else {
        remove$9(element, clazz);
      }
      cleanClass(element);
    };
    const toggle$1 = (element, clazz) => {
      const result = supports(element) ? element.dom.classList.toggle(clazz) : toggle$2(element, clazz);
      cleanClass(element);
      return result;
    };
    const has = (element, clazz) => supports(element) && element.dom.classList.contains(clazz);

    const fromHtml$1 = (html, scope) => {
      const doc = scope || document;
      const div = doc.createElement('div');
      div.innerHTML = html;
      if (!div.hasChildNodes() || div.childNodes.length > 1) {
        const message = 'HTML does not have a single root node';
        console.error(message, html);
        throw new Error(message);
      }
      return fromDom$2(div.childNodes[0]);
    };
    const fromTag = (tag, scope) => {
      const doc = scope || document;
      const node = doc.createElement(tag);
      return fromDom$2(node);
    };
    const fromText = (text, scope) => {
      const doc = scope || document;
      const node = doc.createTextNode(text);
      return fromDom$2(node);
    };
    const fromDom$2 = node => {
      if (node === null || node === undefined) {
        throw new Error('Node cannot be null or undefined');
      }
      return { dom: node };
    };
    const fromPoint$2 = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom$2);
    const SugarElement = {
      fromHtml: fromHtml$1,
      fromTag,
      fromText,
      fromDom: fromDom$2,
      fromPoint: fromPoint$2
    };

    const toArray = (target, f) => {
      const r = [];
      const recurse = e => {
        r.push(e);
        return f(e);
      };
      let cur = f(target);
      do {
        cur = cur.bind(recurse);
      } while (cur.isSome());
      return r;
    };

    const is$1 = (element, selector) => {
      const dom = element.dom;
      if (dom.nodeType !== ELEMENT) {
        return false;
      } else {
        const elem = dom;
        if (elem.matches !== undefined) {
          return elem.matches(selector);
        } else if (elem.msMatchesSelector !== undefined) {
          return elem.msMatchesSelector(selector);
        } else if (elem.webkitMatchesSelector !== undefined) {
          return elem.webkitMatchesSelector(selector);
        } else if (elem.mozMatchesSelector !== undefined) {
          return elem.mozMatchesSelector(selector);
        } else {
          throw new Error('Browser lacks native selectors');
        }
      }
    };
    const bypassSelector = dom => dom.nodeType !== ELEMENT && dom.nodeType !== DOCUMENT && dom.nodeType !== DOCUMENT_FRAGMENT || dom.childElementCount === 0;
    const all = (selector, scope) => {
      const base = scope === undefined ? document : scope.dom;
      return bypassSelector(base) ? [] : map$3(base.querySelectorAll(selector), SugarElement.fromDom);
    };
    const one = (selector, scope) => {
      const base = scope === undefined ? document : scope.dom;
      return bypassSelector(base) ? Optional.none() : Optional.from(base.querySelector(selector)).map(SugarElement.fromDom);
    };

    const eq = (e1, e2) => e1.dom === e2.dom;
    const contains = (e1, e2) => {
      const d1 = e1.dom;
      const d2 = e2.dom;
      return d1 === d2 ? false : d1.contains(d2);
    };

    const owner$1 = element => SugarElement.fromDom(element.dom.ownerDocument);
    const documentOrOwner = dos => isDocument$2(dos) ? dos : owner$1(dos);
    const documentElement = element => SugarElement.fromDom(documentOrOwner(element).dom.documentElement);
    const defaultView = element => SugarElement.fromDom(documentOrOwner(element).dom.defaultView);
    const parent = element => Optional.from(element.dom.parentNode).map(SugarElement.fromDom);
    const parentElement = element => Optional.from(element.dom.parentElement).map(SugarElement.fromDom);
    const parents$1 = (element, isRoot) => {
      const stop = isFunction(isRoot) ? isRoot : never;
      let dom = element.dom;
      const ret = [];
      while (dom.parentNode !== null && dom.parentNode !== undefined) {
        const rawParent = dom.parentNode;
        const p = SugarElement.fromDom(rawParent);
        ret.push(p);
        if (stop(p) === true) {
          break;
        } else {
          dom = rawParent;
        }
      }
      return ret;
    };
    const siblings = element => {
      const filterSelf = elements => filter$5(elements, x => !eq(element, x));
      return parent(element).map(children$1).map(filterSelf).getOr([]);
    };
    const prevSibling = element => Optional.from(element.dom.previousSibling).map(SugarElement.fromDom);
    const nextSibling = element => Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);
    const prevSiblings = element => reverse(toArray(element, prevSibling));
    const nextSiblings = element => toArray(element, nextSibling);
    const children$1 = element => map$3(element.dom.childNodes, SugarElement.fromDom);
    const child$1 = (element, index) => {
      const cs = element.dom.childNodes;
      return Optional.from(cs[index]).map(SugarElement.fromDom);
    };
    const firstChild = element => child$1(element, 0);
    const lastChild = element => child$1(element, element.dom.childNodes.length - 1);
    const childNodesCount = element => element.dom.childNodes.length;

    const getHead = doc => {
      const b = doc.dom.head;
      if (b === null || b === undefined) {
        throw new Error('Head is not available yet');
      }
      return SugarElement.fromDom(b);
    };

    const isShadowRoot = dos => isDocumentFragment$1(dos) && isNonNullable(dos.dom.host);
    const supported = isFunction(Element.prototype.attachShadow) && isFunction(Node.prototype.getRootNode);
    const isSupported$1 = constant(supported);
    const getRootNode = supported ? e => SugarElement.fromDom(e.dom.getRootNode()) : documentOrOwner;
    const getStyleContainer = dos => isShadowRoot(dos) ? dos : getHead(documentOrOwner(dos));
    const getContentContainer = dos => isShadowRoot(dos) ? dos : SugarElement.fromDom(documentOrOwner(dos).dom.body);
    const getShadowRoot = e => {
      const r = getRootNode(e);
      return isShadowRoot(r) ? Optional.some(r) : Optional.none();
    };
    const getShadowHost = e => SugarElement.fromDom(e.dom.host);
    const getOriginalEventTarget = event => {
      if (isSupported$1() && isNonNullable(event.target)) {
        const el = SugarElement.fromDom(event.target);
        if (isElement$7(el) && isOpenShadowHost(el)) {
          if (event.composed && event.composedPath) {
            const composedPath = event.composedPath();
            if (composedPath) {
              return head(composedPath);
            }
          }
        }
      }
      return Optional.from(event.target);
    };
    const isOpenShadowHost = element => isNonNullable(element.dom.shadowRoot);

    const inBody = element => {
      const dom = isText$b(element) ? element.dom.parentNode : element.dom;
      if (dom === undefined || dom === null || dom.ownerDocument === null) {
        return false;
      }
      const doc = dom.ownerDocument;
      return getShadowRoot(SugarElement.fromDom(dom)).fold(() => doc.body.contains(dom), compose1(inBody, getShadowHost));
    };

    var ClosestOrAncestor = (is, ancestor, scope, a, isRoot) => {
      if (is(scope, a)) {
        return Optional.some(scope);
      } else if (isFunction(isRoot) && isRoot(scope)) {
        return Optional.none();
      } else {
        return ancestor(scope, a, isRoot);
      }
    };

    const ancestor$4 = (scope, predicate, isRoot) => {
      let element = scope.dom;
      const stop = isFunction(isRoot) ? isRoot : never;
      while (element.parentNode) {
        element = element.parentNode;
        const el = SugarElement.fromDom(element);
        if (predicate(el)) {
          return Optional.some(el);
        } else if (stop(el)) {
          break;
        }
      }
      return Optional.none();
    };
    const closest$4 = (scope, predicate, isRoot) => {
      const is = (s, test) => test(s);
      return ClosestOrAncestor(is, ancestor$4, scope, predicate, isRoot);
    };
    const sibling$1 = (scope, predicate) => {
      const element = scope.dom;
      if (!element.parentNode) {
        return Optional.none();
      }
      return child(SugarElement.fromDom(element.parentNode), x => !eq(scope, x) && predicate(x));
    };
    const child = (scope, predicate) => {
      const pred = node => predicate(SugarElement.fromDom(node));
      const result = find$2(scope.dom.childNodes, pred);
      return result.map(SugarElement.fromDom);
    };
    const descendant$1 = (scope, predicate) => {
      const descend = node => {
        for (let i = 0; i < node.childNodes.length; i++) {
          const child = SugarElement.fromDom(node.childNodes[i]);
          if (predicate(child)) {
            return Optional.some(child);
          }
          const res = descend(node.childNodes[i]);
          if (res.isSome()) {
            return res;
          }
        }
        return Optional.none();
      };
      return descend(scope.dom);
    };

    const ancestor$3 = (scope, selector, isRoot) => ancestor$4(scope, e => is$1(e, selector), isRoot);
    const descendant = (scope, selector) => one(selector, scope);
    const closest$3 = (scope, selector, isRoot) => {
      const is = (element, selector) => is$1(element, selector);
      return ClosestOrAncestor(is, ancestor$3, scope, selector, isRoot);
    };

    const closest$2 = target => closest$3(target, '[contenteditable]');
    const isEditable$3 = (element, assumeEditable = false) => {
      if (inBody(element)) {
        return element.dom.isContentEditable;
      } else {
        return closest$2(element).fold(constant(assumeEditable), editable => getRaw$1(editable) === 'true');
      }
    };
    const getRaw$1 = element => element.dom.contentEditable;

    const isSupported = dom => dom.style !== undefined && isFunction(dom.style.getPropertyValue);

    const internalSet = (dom, property, value) => {
      if (!isString(value)) {
        console.error('Invalid call to CSS.set. Property ', property, ':: Value ', value, ':: Element ', dom);
        throw new Error('CSS value must be a string: ' + value);
      }
      if (isSupported(dom)) {
        dom.style.setProperty(property, value);
      }
    };
    const internalRemove = (dom, property) => {
      if (isSupported(dom)) {
        dom.style.removeProperty(property);
      }
    };
    const set$2 = (element, property, value) => {
      const dom = element.dom;
      internalSet(dom, property, value);
    };
    const setAll = (element, css) => {
      const dom = element.dom;
      each$d(css, (v, k) => {
        internalSet(dom, k, v);
      });
    };
    const get$7 = (element, property) => {
      const dom = element.dom;
      const styles = window.getComputedStyle(dom);
      const r = styles.getPropertyValue(property);
      return r === '' && !inBody(element) ? getUnsafeProperty(dom, property) : r;
    };
    const getUnsafeProperty = (dom, property) => isSupported(dom) ? dom.style.getPropertyValue(property) : '';
    const getRaw = (element, property) => {
      const dom = element.dom;
      const raw = getUnsafeProperty(dom, property);
      return Optional.from(raw).filter(r => r.length > 0);
    };
    const getAllRaw = element => {
      const css = {};
      const dom = element.dom;
      if (isSupported(dom)) {
        for (let i = 0; i < dom.style.length; i++) {
          const ruleName = dom.style.item(i);
          css[ruleName] = dom.style[ruleName];
        }
      }
      return css;
    };
    const remove$7 = (element, property) => {
      const dom = element.dom;
      internalRemove(dom, property);
      if (is$2(getOpt(element, 'style').map(trim$3), '')) {
        remove$b(element, 'style');
      }
    };
    const reflow = e => e.dom.offsetWidth;

    const before$3 = (marker, element) => {
      const parent$1 = parent(marker);
      parent$1.each(v => {
        v.dom.insertBefore(element.dom, marker.dom);
      });
    };
    const after$4 = (marker, element) => {
      const sibling = nextSibling(marker);
      sibling.fold(() => {
        const parent$1 = parent(marker);
        parent$1.each(v => {
          append$1(v, element);
        });
      }, v => {
        before$3(v, element);
      });
    };
    const prepend = (parent, element) => {
      const firstChild$1 = firstChild(parent);
      firstChild$1.fold(() => {
        append$1(parent, element);
      }, v => {
        parent.dom.insertBefore(element.dom, v.dom);
      });
    };
    const append$1 = (parent, element) => {
      parent.dom.appendChild(element.dom);
    };
    const wrap$2 = (element, wrapper) => {
      before$3(element, wrapper);
      append$1(wrapper, element);
    };

    const after$3 = (marker, elements) => {
      each$e(elements, (x, i) => {
        const e = i === 0 ? marker : elements[i - 1];
        after$4(e, x);
      });
    };
    const append = (parent, elements) => {
      each$e(elements, x => {
        append$1(parent, x);
      });
    };

    const empty = element => {
      element.dom.textContent = '';
      each$e(children$1(element), rogue => {
        remove$6(rogue);
      });
    };
    const remove$6 = element => {
      const dom = element.dom;
      if (dom.parentNode !== null) {
        dom.parentNode.removeChild(dom);
      }
    };
    const unwrap = wrapper => {
      const children = children$1(wrapper);
      if (children.length > 0) {
        after$3(wrapper, children);
      }
      remove$6(wrapper);
    };

    const fromHtml = (html, scope) => {
      const doc = scope || document;
      const div = doc.createElement('div');
      div.innerHTML = html;
      return children$1(SugarElement.fromDom(div));
    };
    const fromDom$1 = nodes => map$3(nodes, SugarElement.fromDom);

    const get$6 = element => element.dom.innerHTML;
    const set$1 = (element, content) => {
      const owner = owner$1(element);
      const docDom = owner.dom;
      const fragment = SugarElement.fromDom(docDom.createDocumentFragment());
      const contentElements = fromHtml(content, docDom);
      append(fragment, contentElements);
      empty(element);
      append$1(element, fragment);
    };
    const getOuter = element => {
      const container = SugarElement.fromTag('div');
      const clone = SugarElement.fromDom(element.dom.cloneNode(true));
      append$1(container, clone);
      return get$6(container);
    };

    const mkEvent = (target, x, y, stop, prevent, kill, raw) => ({
      target,
      x,
      y,
      stop,
      prevent,
      kill,
      raw
    });
    const fromRawEvent = rawEvent => {
      const target = SugarElement.fromDom(getOriginalEventTarget(rawEvent).getOr(rawEvent.target));
      const stop = () => rawEvent.stopPropagation();
      const prevent = () => rawEvent.preventDefault();
      const kill = compose(prevent, stop);
      return mkEvent(target, rawEvent.clientX, rawEvent.clientY, stop, prevent, kill, rawEvent);
    };
    const handle$1 = (filter, handler) => rawEvent => {
      if (filter(rawEvent)) {
        handler(fromRawEvent(rawEvent));
      }
    };
    const binder = (element, event, filter, handler, useCapture) => {
      const wrapped = handle$1(filter, handler);
      element.dom.addEventListener(event, wrapped, useCapture);
      return { unbind: curry(unbind, element, event, wrapped, useCapture) };
    };
    const bind$2 = (element, event, filter, handler) => binder(element, event, filter, handler, false);
    const unbind = (element, event, handler, useCapture) => {
      element.dom.removeEventListener(event, handler, useCapture);
    };

    const r = (left, top) => {
      const translate = (x, y) => r(left + x, top + y);
      return {
        left,
        top,
        translate
      };
    };
    const SugarPosition = r;

    const boxPosition = dom => {
      const box = dom.getBoundingClientRect();
      return SugarPosition(box.left, box.top);
    };
    const firstDefinedOrZero = (a, b) => {
      if (a !== undefined) {
        return a;
      } else {
        return b !== undefined ? b : 0;
      }
    };
    const absolute = element => {
      const doc = element.dom.ownerDocument;
      const body = doc.body;
      const win = doc.defaultView;
      const html = doc.documentElement;
      if (body === element.dom) {
        return SugarPosition(body.offsetLeft, body.offsetTop);
      }
      const scrollTop = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageYOffset, html.scrollTop);
      const scrollLeft = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageXOffset, html.scrollLeft);
      const clientTop = firstDefinedOrZero(html.clientTop, body.clientTop);
      const clientLeft = firstDefinedOrZero(html.clientLeft, body.clientLeft);
      return viewport(element).translate(scrollLeft - clientLeft, scrollTop - clientTop);
    };
    const viewport = element => {
      const dom = element.dom;
      const doc = dom.ownerDocument;
      const body = doc.body;
      if (body === dom) {
        return SugarPosition(body.offsetLeft, body.offsetTop);
      }
      if (!inBody(element)) {
        return SugarPosition(0, 0);
      }
      return boxPosition(dom);
    };

    const get$5 = _DOC => {
      const doc = _DOC !== undefined ? _DOC.dom : document;
      const x = doc.body.scrollLeft || doc.documentElement.scrollLeft;
      const y = doc.body.scrollTop || doc.documentElement.scrollTop;
      return SugarPosition(x, y);
    };
    const intoView = (element, alignToTop) => {
      const isSafari = detect$2().browser.isSafari();
      if (isSafari && isFunction(element.dom.scrollIntoViewIfNeeded)) {
        element.dom.scrollIntoViewIfNeeded(false);
      } else {
        element.dom.scrollIntoView(alignToTop);
      }
    };

    const get$4 = _win => {
      const win = _win === undefined ? window : _win;
      if (detect$2().browser.isFirefox()) {
        return Optional.none();
      } else {
        return Optional.from(win.visualViewport);
      }
    };
    const bounds = (x, y, width, height) => ({
      x,
      y,
      width,
      height,
      right: x + width,
      bottom: y + height
    });
    const getBounds = _win => {
      const win = _win === undefined ? window : _win;
      const doc = win.document;
      const scroll = get$5(SugarElement.fromDom(doc));
      return get$4(win).fold(() => {
        const html = win.document.documentElement;
        const width = html.clientWidth;
        const height = html.clientHeight;
        return bounds(scroll.left, scroll.top, width, height);
      }, visualViewport => bounds(Math.max(visualViewport.pageLeft, scroll.left), Math.max(visualViewport.pageTop, scroll.top), visualViewport.width, visualViewport.height));
    };

    const children = (scope, predicate) => filter$5(children$1(scope), predicate);
    const descendants$1 = (scope, predicate) => {
      let result = [];
      each$e(children$1(scope), x => {
        if (predicate(x)) {
          result = result.concat([x]);
        }
        result = result.concat(descendants$1(x, predicate));
      });
      return result;
    };

    const descendants = (scope, selector) => all(selector, scope);

    const ancestor$2 = (scope, selector, isRoot) => ancestor$3(scope, selector, isRoot).isSome();

    class DomTreeWalker {
      constructor(startNode, rootNode) {
        this.node = startNode;
        this.rootNode = rootNode;
        this.current = this.current.bind(this);
        this.next = this.next.bind(this);
        this.prev = this.prev.bind(this);
        this.prev2 = this.prev2.bind(this);
      }
      current() {
        return this.node;
      }
      next(shallow) {
        this.node = this.findSibling(this.node, 'firstChild', 'nextSibling', shallow);
        return this.node;
      }
      prev(shallow) {
        this.node = this.findSibling(this.node, 'lastChild', 'previousSibling', shallow);
        return this.node;
      }
      prev2(shallow) {
        this.node = this.findPreviousNode(this.node, shallow);
        return this.node;
      }
      findSibling(node, startName, siblingName, shallow) {
        if (node) {
          if (!shallow && node[startName]) {
            return node[startName];
          }
          if (node !== this.rootNode) {
            let sibling = node[siblingName];
            if (sibling) {
              return sibling;
            }
            for (let parent = node.parentNode; parent && parent !== this.rootNode; parent = parent.parentNode) {
              sibling = parent[siblingName];
              if (sibling) {
                return sibling;
              }
            }
          }
        }
        return undefined;
      }
      findPreviousNode(node, shallow) {
        if (node) {
          const sibling = node.previousSibling;
          if (this.rootNode && sibling === this.rootNode) {
            return;
          }
          if (sibling) {
            if (!shallow) {
              for (let child = sibling.lastChild; child; child = child.lastChild) {
                if (!child.lastChild) {
                  return child;
                }
              }
            }
            return sibling;
          }
          const parent = node.parentNode;
          if (parent && parent !== this.rootNode) {
            return parent;
          }
        }
        return undefined;
      }
    }

    const isNodeType = type => {
      return node => {
        return !!node && node.nodeType === type;
      };
    };
    const isRestrictedNode = node => !!node && !Object.getPrototypeOf(node);
    const isElement$6 = isNodeType(1);
    const matchNodeName = name => {
      const lowerCasedName = name.toLowerCase();
      return node => isNonNullable(node) && node.nodeName.toLowerCase() === lowerCasedName;
    };
    const matchNodeNames = names => {
      const lowerCasedNames = names.map(s => s.toLowerCase());
      return node => {
        if (node && node.nodeName) {
          const nodeName = node.nodeName.toLowerCase();
          return contains$2(lowerCasedNames, nodeName);
        }
        return false;
      };
    };
    const matchStyleValues = (name, values) => {
      const items = values.toLowerCase().split(' ');
      return node => {
        if (isElement$6(node)) {
          const win = node.ownerDocument.defaultView;
          if (win) {
            for (let i = 0; i < items.length; i++) {
              const computed = win.getComputedStyle(node, null);
              const cssValue = computed ? computed.getPropertyValue(name) : null;
              if (cssValue === items[i]) {
                return true;
              }
            }
          }
        }
        return false;
      };
    };
    const hasAttribute = attrName => {
      return node => {
        return isElement$6(node) && node.hasAttribute(attrName);
      };
    };
    const hasAttributeValue = (attrName, attrValue) => {
      return node => {
        return isElement$6(node) && node.getAttribute(attrName) === attrValue;
      };
    };
    const isBogus$2 = node => isElement$6(node) && node.hasAttribute('data-mce-bogus');
    const isBogusAll$1 = node => isElement$6(node) && node.getAttribute('data-mce-bogus') === 'all';
    const isTable$2 = node => isElement$6(node) && node.tagName === 'TABLE';
    const hasContentEditableState = value => {
      return node => {
        if (isElement$6(node)) {
          if (node.contentEditable === value) {
            return true;
          }
          if (node.getAttribute('data-mce-contenteditable') === value) {
            return true;
          }
        }
        return false;
      };
    };
    const isTextareaOrInput = matchNodeNames([
      'textarea',
      'input'
    ]);
    const isText$a = isNodeType(3);
    const isCData = isNodeType(4);
    const isPi = isNodeType(7);
    const isComment = isNodeType(8);
    const isDocument$1 = isNodeType(9);
    const isDocumentFragment = isNodeType(11);
    const isBr$6 = matchNodeName('br');
    const isImg = matchNodeName('img');
    const isContentEditableTrue$3 = hasContentEditableState('true');
    const isContentEditableFalse$b = hasContentEditableState('false');
    const isTableCell$3 = matchNodeNames([
      'td',
      'th'
    ]);
    const isTableCellOrCaption = matchNodeNames([
      'td',
      'th',
      'caption'
    ]);
    const isMedia$2 = matchNodeNames([
      'video',
      'audio',
      'object',
      'embed'
    ]);
    const isListItem$2 = matchNodeName('li');

    const zeroWidth = '\uFEFF';
    const nbsp = '\xA0';
    const isZwsp$1 = char => char === zeroWidth;
    const removeZwsp = s => s.replace(/\uFEFF/g, '');

    const NodeValue = (is, name) => {
      const get = element => {
        if (!is(element)) {
          throw new Error('Can only get ' + name + ' value of a ' + name + ' node');
        }
        return getOption(element).getOr('');
      };
      const getOption = element => is(element) ? Optional.from(element.dom.nodeValue) : Optional.none();
      const set = (element, value) => {
        if (!is(element)) {
          throw new Error('Can only set raw ' + name + ' value of a ' + name + ' node');
        }
        element.dom.nodeValue = value;
      };
      return {
        get,
        getOption,
        set
      };
    };

    const api$1 = NodeValue(isText$b, 'text');
    const get$3 = element => api$1.get(element);
    const getOption = element => api$1.getOption(element);
    const set = (element, value) => api$1.set(element, value);

    const blocks = [
      'article',
      'aside',
      'details',
      'div',
      'dt',
      'figcaption',
      'footer',
      'form',
      'fieldset',
      'header',
      'hgroup',
      'html',
      'main',
      'nav',
      'section',
      'summary',
      'body',
      'p',
      'dl',
      'multicol',
      'dd',
      'figure',
      'address',
      'center',
      'blockquote',
      'h1',
      'h2',
      'h3',
      'h4',
      'h5',
      'h6',
      'listing',
      'xmp',
      'pre',
      'plaintext',
      'menu',
      'dir',
      'ul',
      'ol',
      'li',
      'hr',
      'table',
      'tbody',
      'thead',
      'tfoot',
      'th',
      'tr',
      'td',
      'caption'
    ];
    const tableCells = [
      'td',
      'th'
    ];
    const tableSections = [
      'thead',
      'tbody',
      'tfoot'
    ];
    const textBlocks = [
      'h1',
      'h2',
      'h3',
      'h4',
      'h5',
      'h6',
      'p',
      'div',
      'address',
      'pre',
      'form',
      'blockquote',
      'center',
      'dir',
      'fieldset',
      'header',
      'footer',
      'article',
      'section',
      'hgroup',
      'aside',
      'nav',
      'figure'
    ];
    const headings = [
      'h1',
      'h2',
      'h3',
      'h4',
      'h5',
      'h6'
    ];
    const listItems$1 = [
      'li',
      'dd',
      'dt'
    ];
    const lists = [
      'ul',
      'ol',
      'dl'
    ];
    const wsElements = [
      'pre',
      'script',
      'textarea',
      'style'
    ];
    const wrapBlockElements = ['pre'].concat(headings);
    const lazyLookup = items => {
      let lookup;
      return node => {
        lookup = lookup ? lookup : mapToObject(items, always);
        return has$2(lookup, name(node));
      };
    };
    const isBlock$2 = lazyLookup(blocks);
    const isTable$1 = node => name(node) === 'table';
    const isInline$1 = node => isElement$7(node) && !isBlock$2(node);
    const isBr$5 = node => isElement$7(node) && name(node) === 'br';
    const isTextBlock$2 = lazyLookup(textBlocks);
    const isList = lazyLookup(lists);
    const isListItem$1 = lazyLookup(listItems$1);
    const isTableSection = lazyLookup(tableSections);
    const isTableCell$2 = lazyLookup(tableCells);
    const isWsPreserveElement = lazyLookup(wsElements);
    const isWrapBlockElement = lazyLookup(wrapBlockElements);
    const isWrapElement = node => isWrapBlockElement(node) || isInline$1(node);

    const getLastChildren$1 = elm => {
      const children = [];
      let rawNode = elm.dom;
      while (rawNode) {
        children.push(SugarElement.fromDom(rawNode));
        rawNode = rawNode.lastChild;
      }
      return children;
    };
    const removeTrailingBr = elm => {
      const allBrs = descendants(elm, 'br');
      const brs = filter$5(getLastChildren$1(elm).slice(-1), isBr$5);
      if (allBrs.length === brs.length) {
        each$e(brs, remove$6);
      }
    };
    const createPaddingBr = () => {
      const br = SugarElement.fromTag('br');
      set$3(br, 'data-mce-bogus', '1');
      return br;
    };
    const fillWithPaddingBr = elm => {
      empty(elm);
      append$1(elm, createPaddingBr());
    };
    const trimBlockTrailingBr = elm => {
      lastChild(elm).each(lastChild => {
        prevSibling(lastChild).each(lastChildPrevSibling => {
          if (isBlock$2(elm) && isBr$5(lastChild) && isBlock$2(lastChildPrevSibling)) {
            remove$6(lastChild);
          }
        });
      });
    };

    const ZWSP$1 = zeroWidth;
    const isZwsp = isZwsp$1;
    const trim$1 = removeZwsp;

    const isElement$5 = isElement$6;
    const isText$9 = isText$a;
    const isCaretContainerBlock$1 = node => {
      if (isText$9(node)) {
        node = node.parentNode;
      }
      return isElement$5(node) && node.hasAttribute('data-mce-caret');
    };
    const isCaretContainerInline = node => isText$9(node) && isZwsp(node.data);
    const isCaretContainer$2 = node => isCaretContainerBlock$1(node) || isCaretContainerInline(node);
    const hasContent = node => node.firstChild !== node.lastChild || !isBr$6(node.firstChild);
    const insertInline$1 = (node, before) => {
      var _a;
      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;
      const textNode = doc.createTextNode(ZWSP$1);
      const parentNode = node.parentNode;
      if (!before) {
        const sibling = node.nextSibling;
        if (isText$9(sibling)) {
          if (isCaretContainer$2(sibling)) {
            return sibling;
          }
          if (startsWithCaretContainer$1(sibling)) {
            sibling.splitText(1);
            return sibling;
          }
        }
        if (node.nextSibling) {
          parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(textNode, node.nextSibling);
        } else {
          parentNode === null || parentNode === void 0 ? void 0 : parentNode.appendChild(textNode);
        }
      } else {
        const sibling = node.previousSibling;
        if (isText$9(sibling)) {
          if (isCaretContainer$2(sibling)) {
            return sibling;
          }
          if (endsWithCaretContainer$1(sibling)) {
            return sibling.splitText(sibling.data.length - 1);
          }
        }
        parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(textNode, node);
      }
      return textNode;
    };
    const isBeforeInline = pos => {
      const container = pos.container();
      if (!isText$a(container)) {
        return false;
      }
      return container.data.charAt(pos.offset()) === ZWSP$1 || pos.isAtStart() && isCaretContainerInline(container.previousSibling);
    };
    const isAfterInline = pos => {
      const container = pos.container();
      if (!isText$a(container)) {
        return false;
      }
      return container.data.charAt(pos.offset() - 1) === ZWSP$1 || pos.isAtEnd() && isCaretContainerInline(container.nextSibling);
    };
    const insertBlock = (blockName, node, before) => {
      var _a;
      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;
      const blockNode = doc.createElement(blockName);
      blockNode.setAttribute('data-mce-caret', before ? 'before' : 'after');
      blockNode.setAttribute('data-mce-bogus', 'all');
      blockNode.appendChild(createPaddingBr().dom);
      const parentNode = node.parentNode;
      if (!before) {
        if (node.nextSibling) {
          parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(blockNode, node.nextSibling);
        } else {
          parentNode === null || parentNode === void 0 ? void 0 : parentNode.appendChild(blockNode);
        }
      } else {
        parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(blockNode, node);
      }
      return blockNode;
    };
    const startsWithCaretContainer$1 = node => isText$9(node) && node.data[0] === ZWSP$1;
    const endsWithCaretContainer$1 = node => isText$9(node) && node.data[node.data.length - 1] === ZWSP$1;
    const trimBogusBr = elm => {
      var _a;
      const brs = elm.getElementsByTagName('br');
      const lastBr = brs[brs.length - 1];
      if (isBogus$2(lastBr)) {
        (_a = lastBr.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(lastBr);
      }
    };
    const showCaretContainerBlock = caretContainer => {
      if (caretContainer && caretContainer.hasAttribute('data-mce-caret')) {
        trimBogusBr(caretContainer);
        caretContainer.removeAttribute('data-mce-caret');
        caretContainer.removeAttribute('data-mce-bogus');
        caretContainer.removeAttribute('style');
        caretContainer.removeAttribute('data-mce-style');
        caretContainer.removeAttribute('_moz_abspos');
        return caretContainer;
      }
      return null;
    };
    const isRangeInCaretContainerBlock = range => isCaretContainerBlock$1(range.startContainer);

    const isContentEditableTrue$2 = isContentEditableTrue$3;
    const isContentEditableFalse$a = isContentEditableFalse$b;
    const isBr$4 = isBr$6;
    const isText$8 = isText$a;
    const isInvalidTextElement = matchNodeNames([
      'script',
      'style',
      'textarea'
    ]);
    const isAtomicInline = matchNodeNames([
      'img',
      'input',
      'textarea',
      'hr',
      'iframe',
      'video',
      'audio',
      'object',
      'embed'
    ]);
    const isTable = matchNodeNames(['table']);
    const isCaretContainer$1 = isCaretContainer$2;
    const isCaretCandidate$3 = node => {
      if (isCaretContainer$1(node)) {
        return false;
      }
      if (isText$8(node)) {
        return !isInvalidTextElement(node.parentNode);
      }
      return isAtomicInline(node) || isBr$4(node) || isTable(node) || isNonUiContentEditableFalse(node);
    };
    const isUnselectable = node => isElement$6(node) && node.getAttribute('unselectable') === 'true';
    const isNonUiContentEditableFalse = node => !isUnselectable(node) && isContentEditableFalse$a(node);
    const isInEditable = (node, root) => {
      for (let tempNode = node.parentNode; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {
        if (isNonUiContentEditableFalse(tempNode)) {
          return false;
        }
        if (isContentEditableTrue$2(tempNode)) {
          return true;
        }
      }
      return true;
    };
    const isAtomicContentEditableFalse = node => {
      if (!isNonUiContentEditableFalse(node)) {
        return false;
      }
      return !foldl(from(node.getElementsByTagName('*')), (result, elm) => {
        return result || isContentEditableTrue$2(elm);
      }, false);
    };
    const isAtomic$1 = node => isAtomicInline(node) || isAtomicContentEditableFalse(node);
    const isEditableCaretCandidate$1 = (node, root) => isCaretCandidate$3(node) && isInEditable(node, root);

    const whiteSpaceRegExp = /^[ \t\r\n]*$/;
    const isWhitespaceText = text => whiteSpaceRegExp.test(text);
    const isCollapsibleWhitespace$1 = c => ' \f\t\x0B'.indexOf(c) !== -1;
    const isNewLineChar = c => c === '\n' || c === '\r';
    const isNewline = (text, idx) => idx < text.length && idx >= 0 ? isNewLineChar(text[idx]) : false;
    const normalize$4 = (text, tabSpaces = 4, isStartOfContent = true, isEndOfContent = true) => {
      const tabSpace = repeat(' ', tabSpaces);
      const normalizedText = text.replace(/\t/g, tabSpace);
      const result = foldl(normalizedText, (acc, c) => {
        if (isCollapsibleWhitespace$1(c) || c === nbsp) {
          if (acc.pcIsSpace || acc.str === '' && isStartOfContent || acc.str.length === normalizedText.length - 1 && isEndOfContent || isNewline(normalizedText, acc.str.length + 1)) {
            return {
              pcIsSpace: false,
              str: acc.str + nbsp
            };
          } else {
            return {
              pcIsSpace: true,
              str: acc.str + ' '
            };
          }
        } else {
          return {
            pcIsSpace: isNewLineChar(c),
            str: acc.str + c
          };
        }
      }, {
        pcIsSpace: false,
        str: ''
      });
      return result.str;
    };

    const hasWhitespacePreserveParent = (node, rootNode) => {
      const rootElement = SugarElement.fromDom(rootNode);
      const startNode = SugarElement.fromDom(node);
      return ancestor$2(startNode, 'pre,code', curry(eq, rootElement));
    };
    const isWhitespace$1 = (node, rootNode) => {
      return isText$a(node) && isWhitespaceText(node.data) && !hasWhitespacePreserveParent(node, rootNode);
    };
    const isNamedAnchor = node => {
      return isElement$6(node) && node.nodeName === 'A' && !node.hasAttribute('href') && (node.hasAttribute('name') || node.hasAttribute('id'));
    };
    const isContent$1 = (node, rootNode) => {
      return isCaretCandidate$3(node) && !isWhitespace$1(node, rootNode) || isNamedAnchor(node) || isBookmark(node);
    };
    const isBookmark = hasAttribute('data-mce-bookmark');
    const isBogus$1 = hasAttribute('data-mce-bogus');
    const isBogusAll = hasAttributeValue('data-mce-bogus', 'all');
    const isEmptyNode = (targetNode, skipBogus) => {
      let brCount = 0;
      if (isContent$1(targetNode, targetNode)) {
        return false;
      } else {
        let node = targetNode.firstChild;
        if (!node) {
          return true;
        }
        const walker = new DomTreeWalker(node, targetNode);
        do {
          if (skipBogus) {
            if (isBogusAll(node)) {
              node = walker.next(true);
              continue;
            }
            if (isBogus$1(node)) {
              node = walker.next();
              continue;
            }
          }
          if (isBr$6(node)) {
            brCount++;
            node = walker.next();
            continue;
          }
          if (isContent$1(node, targetNode)) {
            return false;
          }
          node = walker.next();
        } while (node);
        return brCount <= 1;
      }
    };
    const isEmpty$2 = (elm, skipBogus = true) => isEmptyNode(elm.dom, skipBogus);

    const transparentBlockAttr = 'data-mce-block';
    const elementNames = map => filter$5(keys(map), key => !/[A-Z]/.test(key));
    const makeSelectorFromSchemaMap = map => elementNames(map).join(',');
    const updateTransparent = (blocksSelector, transparent) => {
      if (isNonNullable(transparent.querySelector(blocksSelector))) {
        transparent.setAttribute(transparentBlockAttr, 'true');
        if (transparent.getAttribute('data-mce-selected') === 'inline-boundary') {
          transparent.removeAttribute('data-mce-selected');
        }
        return true;
      } else {
        transparent.removeAttribute(transparentBlockAttr);
        return false;
      }
    };
    const updateBlockStateOnChildren = (schema, scope) => {
      const transparentSelector = makeSelectorFromSchemaMap(schema.getTransparentElements());
      const blocksSelector = makeSelectorFromSchemaMap(schema.getBlockElements());
      return filter$5(scope.querySelectorAll(transparentSelector), transparent => updateTransparent(blocksSelector, transparent));
    };
    const trimEdge = (el, leftSide) => {
      var _a;
      const childPropertyName = leftSide ? 'lastChild' : 'firstChild';
      for (let child = el[childPropertyName]; child; child = child[childPropertyName]) {
        if (isEmpty$2(SugarElement.fromDom(child))) {
          (_a = child.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(child);
          return;
        }
      }
    };
    const split$2 = (parentElm, splitElm) => {
      const range = document.createRange();
      const parentNode = parentElm.parentNode;
      if (parentNode) {
        range.setStartBefore(parentElm);
        range.setEndBefore(splitElm);
        const beforeFragment = range.extractContents();
        trimEdge(beforeFragment, true);
        range.setStartAfter(splitElm);
        range.setEndAfter(parentElm);
        const afterFragment = range.extractContents();
        trimEdge(afterFragment, false);
        if (!isEmpty$2(SugarElement.fromDom(beforeFragment))) {
          parentNode.insertBefore(beforeFragment, parentElm);
        }
        if (!isEmpty$2(SugarElement.fromDom(splitElm))) {
          parentNode.insertBefore(splitElm, parentElm);
        }
        if (!isEmpty$2(SugarElement.fromDom(afterFragment))) {
          parentNode.insertBefore(afterFragment, parentElm);
        }
        parentNode.removeChild(parentElm);
      }
    };
    const splitInvalidChildren = (schema, scope, transparentBlocks) => {
      const blocksElements = schema.getBlockElements();
      const rootNode = SugarElement.fromDom(scope);
      const isBlock = el => name(el) in blocksElements;
      const isRoot = el => eq(el, rootNode);
      each$e(fromDom$1(transparentBlocks), transparentBlock => {
        ancestor$4(transparentBlock, isBlock, isRoot).each(parentBlock => {
          const invalidChildren = children(transparentBlock, el => isBlock(el) && !schema.isValidChild(name(parentBlock), name(el)));
          if (invalidChildren.length > 0) {
            const stateScope = parentElement(parentBlock);
            each$e(invalidChildren, child => {
              ancestor$4(child, isBlock, isRoot).each(parentBlock => {
                split$2(parentBlock.dom, child.dom);
              });
            });
            stateScope.each(scope => updateBlockStateOnChildren(schema, scope.dom));
          }
        });
      });
    };
    const unwrapInvalidChildren = (schema, scope, transparentBlocks) => {
      each$e([
        ...transparentBlocks,
        ...isTransparentBlock(schema, scope) ? [scope] : []
      ], block => each$e(descendants(SugarElement.fromDom(block), block.nodeName.toLowerCase()), elm => {
        if (isTransparentInline(schema, elm.dom)) {
          unwrap(elm);
        }
      }));
    };
    const updateChildren = (schema, scope) => {
      const transparentBlocks = updateBlockStateOnChildren(schema, scope);
      splitInvalidChildren(schema, scope, transparentBlocks);
      unwrapInvalidChildren(schema, scope, transparentBlocks);
    };
    const updateElement = (schema, target) => {
      if (isTransparentElement(schema, target)) {
        const blocksSelector = makeSelectorFromSchemaMap(schema.getBlockElements());
        updateTransparent(blocksSelector, target);
      }
    };
    const updateCaret = (schema, root, caretParent) => {
      const isRoot = el => eq(el, SugarElement.fromDom(root));
      const parents = parents$1(SugarElement.fromDom(caretParent), isRoot);
      get$b(parents, parents.length - 2).filter(isElement$7).fold(() => updateChildren(schema, root), scope => updateChildren(schema, scope.dom));
    };
    const hasBlockAttr = el => el.hasAttribute(transparentBlockAttr);
    const isTransparentElementName = (schema, name) => has$2(schema.getTransparentElements(), name);
    const isTransparentElement = (schema, node) => isElement$6(node) && isTransparentElementName(schema, node.nodeName);
    const isTransparentBlock = (schema, node) => isTransparentElement(schema, node) && hasBlockAttr(node);
    const isTransparentInline = (schema, node) => isTransparentElement(schema, node) && !hasBlockAttr(node);
    const isTransparentAstBlock = (schema, node) => node.type === 1 && isTransparentElementName(schema, node.name) && isString(node.attr(transparentBlockAttr));
    const isTransparentAstInline = (schema, node) => node.type === 1 && isTransparentElementName(schema, node.name) && isUndefined(node.attr(transparentBlockAttr));

    const browser = detect$2().browser;
    const firstElement = nodes => find$2(nodes, isElement$7);
    const getTableCaptionDeltaY = elm => {
      if (browser.isFirefox() && name(elm) === 'table') {
        return firstElement(children$1(elm)).filter(elm => {
          return name(elm) === 'caption';
        }).bind(caption => {
          return firstElement(nextSiblings(caption)).map(body => {
            const bodyTop = body.dom.offsetTop;
            const captionTop = caption.dom.offsetTop;
            const captionHeight = caption.dom.offsetHeight;
            return bodyTop <= captionTop ? -captionHeight : 0;
          });
        }).getOr(0);
      } else {
        return 0;
      }
    };
    const hasChild = (elm, child) => elm.children && contains$2(elm.children, child);
    const getPos = (body, elm, rootElm) => {
      let x = 0, y = 0;
      const doc = body.ownerDocument;
      rootElm = rootElm ? rootElm : body;
      if (elm) {
        if (rootElm === body && elm.getBoundingClientRect && get$7(SugarElement.fromDom(body), 'position') === 'static') {
          const pos = elm.getBoundingClientRect();
          x = pos.left + (doc.documentElement.scrollLeft || body.scrollLeft) - doc.documentElement.clientLeft;
          y = pos.top + (doc.documentElement.scrollTop || body.scrollTop) - doc.documentElement.clientTop;
          return {
            x,
            y
          };
        }
        let offsetParent = elm;
        while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {
          const castOffsetParent = offsetParent;
          x += castOffsetParent.offsetLeft || 0;
          y += castOffsetParent.offsetTop || 0;
          offsetParent = castOffsetParent.offsetParent;
        }
        offsetParent = elm.parentNode;
        while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {
          x -= offsetParent.scrollLeft || 0;
          y -= offsetParent.scrollTop || 0;
          offsetParent = offsetParent.parentNode;
        }
        y += getTableCaptionDeltaY(SugarElement.fromDom(elm));
      }
      return {
        x,
        y
      };
    };

    const StyleSheetLoader = (documentOrShadowRoot, settings = {}) => {
      let idCount = 0;
      const loadedStates = {};
      const edos = SugarElement.fromDom(documentOrShadowRoot);
      const doc = documentOrOwner(edos);
      const _setReferrerPolicy = referrerPolicy => {
        settings.referrerPolicy = referrerPolicy;
      };
      const _setContentCssCors = contentCssCors => {
        settings.contentCssCors = contentCssCors;
      };
      const addStyle = element => {
        append$1(getStyleContainer(edos), element);
      };
      const removeStyle = id => {
        const styleContainer = getStyleContainer(edos);
        descendant(styleContainer, '#' + id).each(remove$6);
      };
      const getOrCreateState = url => get$a(loadedStates, url).getOrThunk(() => ({
        id: 'mce-u' + idCount++,
        passed: [],
        failed: [],
        count: 0
      }));
      const load = url => new Promise((success, failure) => {
        let link;
        const urlWithSuffix = Tools._addCacheSuffix(url);
        const state = getOrCreateState(urlWithSuffix);
        loadedStates[urlWithSuffix] = state;
        state.count++;
        const resolve = (callbacks, status) => {
          each$e(callbacks, call);
          state.status = status;
          state.passed = [];
          state.failed = [];
          if (link) {
            link.onload = null;
            link.onerror = null;
            link = null;
          }
        };
        const passed = () => resolve(state.passed, 2);
        const failed = () => resolve(state.failed, 3);
        if (success) {
          state.passed.push(success);
        }
        if (failure) {
          state.failed.push(failure);
        }
        if (state.status === 1) {
          return;
        }
        if (state.status === 2) {
          passed();
          return;
        }
        if (state.status === 3) {
          failed();
          return;
        }
        state.status = 1;
        const linkElem = SugarElement.fromTag('link', doc.dom);
        setAll$1(linkElem, {
          rel: 'stylesheet',
          type: 'text/css',
          id: state.id
        });
        if (settings.contentCssCors) {
          set$3(linkElem, 'crossOrigin', 'anonymous');
        }
        if (settings.referrerPolicy) {
          set$3(linkElem, 'referrerpolicy', settings.referrerPolicy);
        }
        link = linkElem.dom;
        link.onload = passed;
        link.onerror = failed;
        addStyle(linkElem);
        set$3(linkElem, 'href', urlWithSuffix);
      });
      const loadAll = urls => {
        const loadedUrls = Promise.allSettled(map$3(urls, url => load(url).then(constant(url))));
        return loadedUrls.then(results => {
          const parts = partition$2(results, r => r.status === 'fulfilled');
          if (parts.fail.length > 0) {
            return Promise.reject(map$3(parts.fail, result => result.reason));
          } else {
            return map$3(parts.pass, result => result.value);
          }
        });
      };
      const unload = url => {
        const urlWithSuffix = Tools._addCacheSuffix(url);
        get$a(loadedStates, urlWithSuffix).each(state => {
          const count = --state.count;
          if (count === 0) {
            delete loadedStates[urlWithSuffix];
            removeStyle(state.id);
          }
        });
      };
      const unloadAll = urls => {
        each$e(urls, url => {
          unload(url);
        });
      };
      return {
        load,
        loadAll,
        unload,
        unloadAll,
        _setReferrerPolicy,
        _setContentCssCors
      };
    };

    const create$d = () => {
      const map = new WeakMap();
      const forElement = (referenceElement, settings) => {
        const root = getRootNode(referenceElement);
        const rootDom = root.dom;
        return Optional.from(map.get(rootDom)).getOrThunk(() => {
          const sl = StyleSheetLoader(rootDom, settings);
          map.set(rootDom, sl);
          return sl;
        });
      };
      return { forElement };
    };
    const instance = create$d();

    const isSpan = node => node.nodeName.toLowerCase() === 'span';
    const isInlineContent = (node, root) => isNonNullable(node) && (isContent$1(node, root) || isInline$1(SugarElement.fromDom(node)));
    const surroundedByInlineContent = (node, root) => {
      const prev = new DomTreeWalker(node, root).prev(false);
      const next = new DomTreeWalker(node, root).next(false);
      const prevIsInline = isUndefined(prev) || isInlineContent(prev, root);
      const nextIsInline = isUndefined(next) || isInlineContent(next, root);
      return prevIsInline && nextIsInline;
    };
    const isBookmarkNode$2 = node => isSpan(node) && node.getAttribute('data-mce-type') === 'bookmark';
    const isKeepTextNode = (node, root) => isText$a(node) && node.data.length > 0 && surroundedByInlineContent(node, root);
    const isKeepElement = node => isElement$6(node) ? node.childNodes.length > 0 : false;
    const isDocument = node => isDocumentFragment(node) || isDocument$1(node);
    const trimNode = (dom, node, root) => {
      var _a;
      const rootNode = root || node;
      if (isElement$6(node) && isBookmarkNode$2(node)) {
        return node;
      }
      const children = node.childNodes;
      for (let i = children.length - 1; i >= 0; i--) {
        trimNode(dom, children[i], rootNode);
      }
      if (isElement$6(node)) {
        const currentChildren = node.childNodes;
        if (currentChildren.length === 1 && isBookmarkNode$2(currentChildren[0])) {
          (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(currentChildren[0], node);
        }
      }
      if (!isDocument(node) && !isContent$1(node, rootNode) && !isKeepElement(node) && !isKeepTextNode(node, rootNode)) {
        dom.remove(node);
      }
      return node;
    };

    const makeMap$3 = Tools.makeMap;
    const attrsCharsRegExp = /[&<>\"\u0060\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    const textCharsRegExp = /[<>&\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    const rawCharsRegExp = /[<>&\"\']/g;
    const entityRegExp = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi;
    const asciiMap = {
      128: '\u20AC',
      130: '\u201A',
      131: '\u0192',
      132: '\u201E',
      133: '\u2026',
      134: '\u2020',
      135: '\u2021',
      136: '\u02c6',
      137: '\u2030',
      138: '\u0160',
      139: '\u2039',
      140: '\u0152',
      142: '\u017d',
      145: '\u2018',
      146: '\u2019',
      147: '\u201C',
      148: '\u201D',
      149: '\u2022',
      150: '\u2013',
      151: '\u2014',
      152: '\u02DC',
      153: '\u2122',
      154: '\u0161',
      155: '\u203A',
      156: '\u0153',
      158: '\u017e',
      159: '\u0178'
    };
    const baseEntities = {
      '"': '&quot;',
      '\'': '&#39;',
      '<': '&lt;',
      '>': '&gt;',
      '&': '&amp;',
      '`': '&#96;'
    };
    const reverseEntities = {
      '&lt;': '<',
      '&gt;': '>',
      '&amp;': '&',
      '&quot;': '"',
      '&apos;': `'`
    };
    const nativeDecode = text => {
      const elm = SugarElement.fromTag('div').dom;
      elm.innerHTML = text;
      return elm.textContent || elm.innerText || text;
    };
    const buildEntitiesLookup = (items, radix) => {
      const lookup = {};
      if (items) {
        const itemList = items.split(',');
        radix = radix || 10;
        for (let i = 0; i < itemList.length; i += 2) {
          const chr = String.fromCharCode(parseInt(itemList[i], radix));
          if (!baseEntities[chr]) {
            const entity = '&' + itemList[i + 1] + ';';
            lookup[chr] = entity;
            lookup[entity] = chr;
          }
        }
        return lookup;
      } else {
        return undefined;
      }
    };
    const namedEntities = buildEntitiesLookup('50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,' + '5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,' + '5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,' + '5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,' + '68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,' + '6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,' + '6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,' + '75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,' + '7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,' + '7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,' + 'sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,' + 'st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,' + 't9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,' + 'tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,' + 'u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,' + '81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,' + '8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,' + '8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,' + '8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,' + '8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,' + 'nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,' + 'rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,' + 'Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,' + '80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,' + '811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro', 32);
    const encodeRaw = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {
      return baseEntities[chr] || chr;
    });
    const encodeAllRaw = text => ('' + text).replace(rawCharsRegExp, chr => {
      return baseEntities[chr] || chr;
    });
    const encodeNumeric = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {
      if (chr.length > 1) {
        return '&#' + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ';';
      }
      return baseEntities[chr] || '&#' + chr.charCodeAt(0) + ';';
    });
    const encodeNamed = (text, attr, entities) => {
      const resolveEntities = entities || namedEntities;
      return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {
        return baseEntities[chr] || resolveEntities[chr] || chr;
      });
    };
    const getEncodeFunc = (name, entities) => {
      const entitiesMap = buildEntitiesLookup(entities) || namedEntities;
      const encodeNamedAndNumeric = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {
        if (baseEntities[chr] !== undefined) {
          return baseEntities[chr];
        }
        if (entitiesMap[chr] !== undefined) {
          return entitiesMap[chr];
        }
        if (chr.length > 1) {
          return '&#' + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ';';
        }
        return '&#' + chr.charCodeAt(0) + ';';
      });
      const encodeCustomNamed = (text, attr) => {
        return encodeNamed(text, attr, entitiesMap);
      };
      const nameMap = makeMap$3(name.replace(/\+/g, ','));
      if (nameMap.named && nameMap.numeric) {
        return encodeNamedAndNumeric;
      }
      if (nameMap.named) {
        if (entities) {
          return encodeCustomNamed;
        }
        return encodeNamed;
      }
      if (nameMap.numeric) {
        return encodeNumeric;
      }
      return encodeRaw;
    };
    const decode = text => text.replace(entityRegExp, (all, numeric) => {
      if (numeric) {
        if (numeric.charAt(0).toLowerCase() === 'x') {
          numeric = parseInt(numeric.substr(1), 16);
        } else {
          numeric = parseInt(numeric, 10);
        }
        if (numeric > 65535) {
          numeric -= 65536;
          return String.fromCharCode(55296 + (numeric >> 10), 56320 + (numeric & 1023));
        }
        return asciiMap[numeric] || String.fromCharCode(numeric);
      }
      return reverseEntities[all] || namedEntities[all] || nativeDecode(all);
    });
    const Entities = {
      encodeRaw,
      encodeAllRaw,
      encodeNumeric,
      encodeNamed,
      getEncodeFunc,
      decode
    };

    const lookupCache = {};
    const mapCache = {};
    const dummyObj = {};
    const makeMap$2 = Tools.makeMap, each$b = Tools.each, extend$2 = Tools.extend, explode$2 = Tools.explode, inArray = Tools.inArray;
    const split$1 = (items, delim) => {
      items = Tools.trim(items);
      return items ? items.split(delim || ' ') : [];
    };
    const createMap = (defaultValue, extendWith = {}) => {
      const value = makeMap$2(defaultValue, ' ', makeMap$2(defaultValue.toUpperCase(), ' '));
      return extend$2(value, extendWith);
    };
    const getTextRootBlockElements = schema => createMap('td th li dt dd figcaption caption details summary', schema.getTextBlockElements());
    const compileSchema = type => {
      const schema = {};
      let globalAttributes, blockContent;
      let phrasingContent, flowContent;
      const add = (name, attributes = '', children = '') => {
        const childNames = split$1(children);
        const names = split$1(name);
        let ni = names.length;
        while (ni--) {
          const attributesOrder = split$1([
            globalAttributes,
            attributes
          ].join(' '));
          schema[names[ni]] = {
            attributes: mapToObject(attributesOrder, () => ({})),
            attributesOrder,
            children: mapToObject(childNames, constant(dummyObj))
          };
        }
      };
      const addAttrs = (name, attributes) => {
        const names = split$1(name);
        const attrs = split$1(attributes);
        let ni = names.length;
        while (ni--) {
          const schemaItem = schema[names[ni]];
          for (let i = 0, l = attrs.length; i < l; i++) {
            schemaItem.attributes[attrs[i]] = {};
            schemaItem.attributesOrder.push(attrs[i]);
          }
        }
      };
      if (lookupCache[type]) {
        return lookupCache[type];
      }
      globalAttributes = 'id accesskey class dir lang style tabindex title role';
      blockContent = 'address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul';
      phrasingContent = 'a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd ' + 'label map noscript object q s samp script select small span strong sub sup ' + 'textarea u var #text #comment';
      if (type !== 'html4') {
        const transparentContent = 'a ins del canvas map';
        globalAttributes += ' contenteditable contextmenu draggable dropzone ' + 'hidden spellcheck translate';
        blockContent += ' article aside details dialog figure main header footer hgroup section nav ' + transparentContent;
        phrasingContent += ' audio canvas command datalist mark meter output picture ' + 'progress time wbr video ruby bdi keygen';
      }
      if (type !== 'html5-strict') {
        globalAttributes += ' xml:lang';
        const html4PhrasingContent = 'acronym applet basefont big font strike tt';
        phrasingContent = [
          phrasingContent,
          html4PhrasingContent
        ].join(' ');
        each$b(split$1(html4PhrasingContent), name => {
          add(name, '', phrasingContent);
        });
        const html4BlockContent = 'center dir isindex noframes';
        blockContent = [
          blockContent,
          html4BlockContent
        ].join(' ');
        flowContent = [
          blockContent,
          phrasingContent
        ].join(' ');
        each$b(split$1(html4BlockContent), name => {
          add(name, '', flowContent);
        });
      }
      flowContent = flowContent || [
        blockContent,
        phrasingContent
      ].join(' ');
      add('html', 'manifest', 'head body');
      add('head', '', 'base command link meta noscript script style title');
      add('title hr noscript br');
      add('base', 'href target');
      add('link', 'href rel media hreflang type sizes hreflang');
      add('meta', 'name http-equiv content charset');
      add('style', 'media type scoped');
      add('script', 'src async defer type charset');
      add('body', 'onafterprint onbeforeprint onbeforeunload onblur onerror onfocus ' + 'onhashchange onload onmessage onoffline ononline onpagehide onpageshow ' + 'onpopstate onresize onscroll onstorage onunload', flowContent);
      add('address dt dd div caption', '', flowContent);
      add('h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn', '', phrasingContent);
      add('blockquote', 'cite', flowContent);
      add('ol', 'reversed start type', 'li');
      add('ul', '', 'li');
      add('li', 'value', flowContent);
      add('dl', '', 'dt dd');
      add('a', 'href target rel media hreflang type', flowContent);
      add('q', 'cite', phrasingContent);
      add('ins del', 'cite datetime', flowContent);
      add('img', 'src sizes srcset alt usemap ismap width height');
      add('iframe', 'src name width height', flowContent);
      add('embed', 'src type width height');
      add('object', 'data type typemustmatch name usemap form width height', [
        flowContent,
        'param'
      ].join(' '));
      add('param', 'name value');
      add('map', 'name', [
        flowContent,
        'area'
      ].join(' '));
      add('area', 'alt coords shape href target rel media hreflang type');
      add('table', 'border', 'caption colgroup thead tfoot tbody tr' + (type === 'html4' ? ' col' : ''));
      add('colgroup', 'span', 'col');
      add('col', 'span');
      add('tbody thead tfoot', '', 'tr');
      add('tr', '', 'td th');
      add('td', 'colspan rowspan headers', flowContent);
      add('th', 'colspan rowspan headers scope abbr', flowContent);
      add('form', 'accept-charset action autocomplete enctype method name novalidate target', flowContent);
      add('fieldset', 'disabled form name', [
        flowContent,
        'legend'
      ].join(' '));
      add('label', 'form for', phrasingContent);
      add('input', 'accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate ' + 'formtarget height list max maxlength min multiple name pattern readonly required size src step type value width');
      add('button', 'disabled form formaction formenctype formmethod formnovalidate formtarget name type value', type === 'html4' ? flowContent : phrasingContent);
      add('select', 'disabled form multiple name required size', 'option optgroup');
      add('optgroup', 'disabled label', 'option');
      add('option', 'disabled label selected value');
      add('textarea', 'cols dirname disabled form maxlength name readonly required rows wrap');
      add('menu', 'type label', [
        flowContent,
        'li'
      ].join(' '));
      add('noscript', '', flowContent);
      if (type !== 'html4') {
        add('wbr');
        add('ruby', '', [
          phrasingContent,
          'rt rp'
        ].join(' '));
        add('figcaption', '', flowContent);
        add('mark rt rp summary bdi', '', phrasingContent);
        add('canvas', 'width height', flowContent);
        add('video', 'src crossorigin poster preload autoplay mediagroup loop ' + 'muted controls width height buffered', [
          flowContent,
          'track source'
        ].join(' '));
        add('audio', 'src crossorigin preload autoplay mediagroup loop muted controls ' + 'buffered volume', [
          flowContent,
          'track source'
        ].join(' '));
        add('picture', '', 'img source');
        add('source', 'src srcset type media sizes');
        add('track', 'kind src srclang label default');
        add('datalist', '', [
          phrasingContent,
          'option'
        ].join(' '));
        add('article section nav aside main header footer', '', flowContent);
        add('hgroup', '', 'h1 h2 h3 h4 h5 h6');
        add('figure', '', [
          flowContent,
          'figcaption'
        ].join(' '));
        add('time', 'datetime', phrasingContent);
        add('dialog', 'open', flowContent);
        add('command', 'type label icon disabled checked radiogroup command');
        add('output', 'for form name', phrasingContent);
        add('progress', 'value max', phrasingContent);
        add('meter', 'value min max low high optimum', phrasingContent);
        add('details', 'open', [
          flowContent,
          'summary'
        ].join(' '));
        add('keygen', 'autofocus challenge disabled form keytype name');
      }
      if (type !== 'html5-strict') {
        addAttrs('script', 'language xml:space');
        addAttrs('style', 'xml:space');
        addAttrs('object', 'declare classid code codebase codetype archive standby align border hspace vspace');
        addAttrs('embed', 'align name hspace vspace');
        addAttrs('param', 'valuetype type');
        addAttrs('a', 'charset name rev shape coords');
        addAttrs('br', 'clear');
        addAttrs('applet', 'codebase archive code object alt name width height align hspace vspace');
        addAttrs('img', 'name longdesc align border hspace vspace');
        addAttrs('iframe', 'longdesc frameborder marginwidth marginheight scrolling align');
        addAttrs('font basefont', 'size color face');
        addAttrs('input', 'usemap align');
        addAttrs('select');
        addAttrs('textarea');
        addAttrs('h1 h2 h3 h4 h5 h6 div p legend caption', 'align');
        addAttrs('ul', 'type compact');
        addAttrs('li', 'type');
        addAttrs('ol dl menu dir', 'compact');
        addAttrs('pre', 'width xml:space');
        addAttrs('hr', 'align noshade size width');
        addAttrs('isindex', 'prompt');
        addAttrs('table', 'summary width frame rules cellspacing cellpadding align bgcolor');
        addAttrs('col', 'width align char charoff valign');
        addAttrs('colgroup', 'width align char charoff valign');
        addAttrs('thead', 'align char charoff valign');
        addAttrs('tr', 'align char charoff valign bgcolor');
        addAttrs('th', 'axis align char charoff valign nowrap bgcolor width height');
        addAttrs('form', 'accept');
        addAttrs('td', 'abbr axis scope align char charoff valign nowrap bgcolor width height');
        addAttrs('tfoot', 'align char charoff valign');
        addAttrs('tbody', 'align char charoff valign');
        addAttrs('area', 'nohref');
        addAttrs('body', 'background bgcolor text link vlink alink');
      }
      if (type !== 'html4') {
        addAttrs('input button select textarea', 'autofocus');
        addAttrs('input textarea', 'placeholder');
        addAttrs('a', 'download');
        addAttrs('link script img', 'crossorigin');
        addAttrs('img', 'loading');
        addAttrs('iframe', 'sandbox seamless allow allowfullscreen loading');
      }
      if (type !== 'html4') {
        each$e([
          schema.video,
          schema.audio
        ], item => {
          delete item.children.audio;
          delete item.children.video;
        });
      }
      each$b(split$1('a form meter progress dfn'), name => {
        if (schema[name]) {
          delete schema[name].children[name];
        }
      });
      delete schema.caption.children.table;
      delete schema.script;
      lookupCache[type] = schema;
      return schema;
    };
    const compileElementMap = (value, mode) => {
      if (value) {
        const styles = {};
        if (isString(value)) {
          value = { '*': value };
        }
        each$b(value, (value, key) => {
          styles[key] = styles[key.toUpperCase()] = mode === 'map' ? makeMap$2(value, /[, ]/) : explode$2(value, /[, ]/);
        });
        return styles;
      } else {
        return undefined;
      }
    };
    const Schema = (settings = {}) => {
      var _a;
      const elements = {};
      const children = {};
      let patternElements = [];
      const customElementsMap = {};
      const specialElements = {};
      const createLookupTable = (option, defaultValue, extendWith) => {
        const value = settings[option];
        if (!value) {
          let newValue = mapCache[option];
          if (!newValue) {
            newValue = createMap(defaultValue, extendWith);
            mapCache[option] = newValue;
          }
          return newValue;
        } else {
          return makeMap$2(value, /[, ]/, makeMap$2(value.toUpperCase(), /[, ]/));
        }
      };
      const schemaType = (_a = settings.schema) !== null && _a !== void 0 ? _a : 'html5';
      const schemaItems = compileSchema(schemaType);
      if (settings.verify_html === false) {
        settings.valid_elements = '*[*]';
      }
      const validStyles = compileElementMap(settings.valid_styles);
      const invalidStyles = compileElementMap(settings.invalid_styles, 'map');
      const validClasses = compileElementMap(settings.valid_classes, 'map');
      const whitespaceElementsMap = createLookupTable('whitespace_elements', 'pre script noscript style textarea video audio iframe object code');
      const selfClosingElementsMap = createLookupTable('self_closing_elements', 'colgroup dd dt li option p td tfoot th thead tr');
      const voidElementsMap = createLookupTable('void_elements', 'area base basefont br col frame hr img input isindex link ' + 'meta param embed source wbr track');
      const boolAttrMap = createLookupTable('boolean_attributes', 'checked compact declare defer disabled ismap multiple nohref noresize ' + 'noshade nowrap readonly selected autoplay loop controls allowfullscreen');
      const nonEmptyOrMoveCaretBeforeOnEnter = 'td th iframe video audio object script code';
      const nonEmptyElementsMap = createLookupTable('non_empty_elements', nonEmptyOrMoveCaretBeforeOnEnter + ' pre', voidElementsMap);
      const moveCaretBeforeOnEnterElementsMap = createLookupTable('move_caret_before_on_enter_elements', nonEmptyOrMoveCaretBeforeOnEnter + ' table', voidElementsMap);
      const textBlockElementsMap = createLookupTable('text_block_elements', 'h1 h2 h3 h4 h5 h6 p div address pre form ' + 'blockquote center dir fieldset header footer article section hgroup aside main nav figure');
      const blockElementsMap = createLookupTable('block_elements', 'hr table tbody thead tfoot ' + 'th tr td li ol ul caption dl dt dd noscript menu isindex option ' + 'datalist select optgroup figcaption details summary', textBlockElementsMap);
      const textInlineElementsMap = createLookupTable('text_inline_elements', 'span strong b em i font s strike u var cite ' + 'dfn code mark q sup sub samp');
      const transparentElementsMap = createLookupTable('transparent_elements', 'a ins del canvas map');
      each$b('script noscript iframe noframes noembed title style textarea xmp plaintext'.split(' '), name => {
        specialElements[name] = new RegExp('</' + name + '[^>]*>', 'gi');
      });
      const patternToRegExp = str => new RegExp('^' + str.replace(/([?+*])/g, '.$1') + '$');
      const addValidElements = validElements => {
        const elementRuleRegExp = /^([#+\-])?([^\[!\/]+)(?:\/([^\[!]+))?(?:(!?)\[([^\]]+)])?$/;
        const attrRuleRegExp = /^([!\-])?(\w+[\\:]:\w+|[^=~<]+)?(?:([=~<])(.*))?$/;
        const hasPatternsRegExp = /[*?+]/;
        if (validElements) {
          const validElementsArr = split$1(validElements, ',');
          let globalAttributes;
          let globalAttributesOrder;
          if (elements['@']) {
            globalAttributes = elements['@'].attributes;
            globalAttributesOrder = elements['@'].attributesOrder;
          }
          for (let ei = 0, el = validElementsArr.length; ei < el; ei++) {
            let matches = elementRuleRegExp.exec(validElementsArr[ei]);
            if (matches) {
              const prefix = matches[1];
              const elementName = matches[2];
              const outputName = matches[3];
              const attrData = matches[5];
              const attributes = {};
              const attributesOrder = [];
              const element = {
                attributes,
                attributesOrder
              };
              if (prefix === '#') {
                element.paddEmpty = true;
              }
              if (prefix === '-') {
                element.removeEmpty = true;
              }
              if (matches[4] === '!') {
                element.removeEmptyAttrs = true;
              }
              if (globalAttributes) {
                each$d(globalAttributes, (value, key) => {
                  attributes[key] = value;
                });
                if (globalAttributesOrder) {
                  attributesOrder.push(...globalAttributesOrder);
                }
              }
              if (attrData) {
                const attrDatas = split$1(attrData, '|');
                for (let ai = 0, al = attrDatas.length; ai < al; ai++) {
                  matches = attrRuleRegExp.exec(attrDatas[ai]);
                  if (matches) {
                    const attr = {};
                    const attrType = matches[1];
                    const attrName = matches[2].replace(/[\\:]:/g, ':');
                    const attrPrefix = matches[3];
                    const value = matches[4];
                    if (attrType === '!') {
                      element.attributesRequired = element.attributesRequired || [];
                      element.attributesRequired.push(attrName);
                      attr.required = true;
                    }
                    if (attrType === '-') {
                      delete attributes[attrName];
                      attributesOrder.splice(inArray(attributesOrder, attrName), 1);
                      continue;
                    }
                    if (attrPrefix) {
                      if (attrPrefix === '=') {
                        element.attributesDefault = element.attributesDefault || [];
                        element.attributesDefault.push({
                          name: attrName,
                          value
                        });
                        attr.defaultValue = value;
                      }
                      if (attrPrefix === '~') {
                        element.attributesForced = element.attributesForced || [];
                        element.attributesForced.push({
                          name: attrName,
                          value
                        });
                        attr.forcedValue = value;
                      }
                      if (attrPrefix === '<') {
                        attr.validValues = makeMap$2(value, '?');
                      }
                    }
                    if (hasPatternsRegExp.test(attrName)) {
                      const attrPattern = attr;
                      element.attributePatterns = element.attributePatterns || [];
                      attrPattern.pattern = patternToRegExp(attrName);
                      element.attributePatterns.push(attrPattern);
                    } else {
                      if (!attributes[attrName]) {
                        attributesOrder.push(attrName);
                      }
                      attributes[attrName] = attr;
                    }
                  }
                }
              }
              if (!globalAttributes && elementName === '@') {
                globalAttributes = attributes;
                globalAttributesOrder = attributesOrder;
              }
              if (outputName) {
                element.outputName = elementName;
                elements[outputName] = element;
              }
              if (hasPatternsRegExp.test(elementName)) {
                const patternElement = element;
                patternElement.pattern = patternToRegExp(elementName);
                patternElements.push(patternElement);
              } else {
                elements[elementName] = element;
              }
            }
          }
        }
      };
      const setValidElements = validElements => {
        patternElements = [];
        each$e(keys(elements), name => {
          delete elements[name];
        });
        addValidElements(validElements);
        each$b(schemaItems, (element, name) => {
          children[name] = element.children;
        });
      };
      const addCustomElements = customElements => {
        const customElementRegExp = /^(~)?(.+)$/;
        if (customElements) {
          delete mapCache.text_block_elements;
          delete mapCache.block_elements;
          each$b(split$1(customElements, ','), rule => {
            const matches = customElementRegExp.exec(rule);
            if (matches) {
              const inline = matches[1] === '~';
              const cloneName = inline ? 'span' : 'div';
              const name = matches[2];
              children[name] = children[cloneName];
              customElementsMap[name] = cloneName;
              nonEmptyElementsMap[name.toUpperCase()] = {};
              nonEmptyElementsMap[name] = {};
              if (!inline) {
                blockElementsMap[name.toUpperCase()] = {};
                blockElementsMap[name] = {};
              }
              if (!elements[name]) {
                let customRule = elements[cloneName];
                customRule = extend$2({}, customRule);
                delete customRule.removeEmptyAttrs;
                delete customRule.removeEmpty;
                elements[name] = customRule;
              }
              each$b(children, (element, elmName) => {
                if (element[cloneName]) {
                  children[elmName] = element = extend$2({}, children[elmName]);
                  element[name] = element[cloneName];
                }
              });
            }
          });
        }
      };
      const addValidChildren = validChildren => {
        const childRuleRegExp = /^([+\-]?)([A-Za-z0-9_\-.\u00b7\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u037d\u037f-\u1fff\u200c-\u200d\u203f-\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]+)\[([^\]]+)]$/;
        delete lookupCache[schemaType];
        if (validChildren) {
          each$b(split$1(validChildren, ','), rule => {
            const matches = childRuleRegExp.exec(rule);
            if (matches) {
              const prefix = matches[1];
              let parent;
              if (prefix) {
                parent = children[matches[2]];
              } else {
                parent = children[matches[2]] = { '#comment': {} };
              }
              parent = children[matches[2]];
              each$b(split$1(matches[3], '|'), child => {
                if (prefix === '-') {
                  delete parent[child];
                } else {
                  parent[child] = {};
                }
              });
            }
          });
        }
      };
      const getElementRule = name => {
        const element = elements[name];
        if (element) {
          return element;
        }
        let i = patternElements.length;
        while (i--) {
          const patternElement = patternElements[i];
          if (patternElement.pattern.test(name)) {
            return patternElement;
          }
        }
        return undefined;
      };
      if (!settings.valid_elements) {
        each$b(schemaItems, (element, name) => {
          elements[name] = {
            attributes: element.attributes,
            attributesOrder: element.attributesOrder
          };
          children[name] = element.children;
        });
        each$b(split$1('strong/b em/i'), item => {
          const items = split$1(item, '/');
          elements[items[1]].outputName = items[0];
        });
        each$b(textInlineElementsMap, (_val, name) => {
          if (elements[name]) {
            if (settings.padd_empty_block_inline_children) {
              elements[name].paddInEmptyBlock = true;
            }
            elements[name].removeEmpty = true;
          }
        });
        each$b(split$1('ol ul blockquote a table tbody'), name => {
          if (elements[name]) {
            elements[name].removeEmpty = true;
          }
        });
        each$b(split$1('p h1 h2 h3 h4 h5 h6 th td pre div address caption li'), name => {
          elements[name].paddEmpty = true;
        });
        each$b(split$1('span'), name => {
          elements[name].removeEmptyAttrs = true;
        });
      } else {
        setValidElements(settings.valid_elements);
      }
      addCustomElements(settings.custom_elements);
      addValidChildren(settings.valid_children);
      addValidElements(settings.extended_valid_elements);
      addValidChildren('+ol[ul|ol],+ul[ul|ol]');
      each$b({
        dd: 'dl',
        dt: 'dl',
        li: 'ul ol',
        td: 'tr',
        th: 'tr',
        tr: 'tbody thead tfoot',
        tbody: 'table',
        thead: 'table',
        tfoot: 'table',
        legend: 'fieldset',
        area: 'map',
        param: 'video audio object'
      }, (parents, item) => {
        if (elements[item]) {
          elements[item].parentsRequired = split$1(parents);
        }
      });
      if (settings.invalid_elements) {
        each$b(explode$2(settings.invalid_elements), item => {
          if (elements[item]) {
            delete elements[item];
          }
        });
      }
      if (!getElementRule('span')) {
        addValidElements('span[!data-mce-type|*]');
      }
      const getValidStyles = constant(validStyles);
      const getInvalidStyles = constant(invalidStyles);
      const getValidClasses = constant(validClasses);
      const getBoolAttrs = constant(boolAttrMap);
      const getBlockElements = constant(blockElementsMap);
      const getTextBlockElements = constant(textBlockElementsMap);
      const getTextInlineElements = constant(textInlineElementsMap);
      const getVoidElements = constant(Object.seal(voidElementsMap));
      const getSelfClosingElements = constant(selfClosingElementsMap);
      const getNonEmptyElements = constant(nonEmptyElementsMap);
      const getMoveCaretBeforeOnEnterElements = constant(moveCaretBeforeOnEnterElementsMap);
      const getWhitespaceElements = constant(whitespaceElementsMap);
      const getTransparentElements = constant(transparentElementsMap);
      const getSpecialElements = constant(Object.seal(specialElements));
      const isValidChild = (name, child) => {
        const parent = children[name.toLowerCase()];
        return !!(parent && parent[child.toLowerCase()]);
      };
      const isValid = (name, attr) => {
        const rule = getElementRule(name);
        if (rule) {
          if (attr) {
            if (rule.attributes[attr]) {
              return true;
            }
            const attrPatterns = rule.attributePatterns;
            if (attrPatterns) {
              let i = attrPatterns.length;
              while (i--) {
                if (attrPatterns[i].pattern.test(attr)) {
                  return true;
                }
              }
            }
          } else {
            return true;
          }
        }
        return false;
      };
      const getCustomElements = constant(customElementsMap);
      return {
        type: schemaType,
        children,
        elements,
        getValidStyles,
        getValidClasses,
        getBlockElements,
        getInvalidStyles,
        getVoidElements,
        getTextBlockElements,
        getTextInlineElements,
        getBoolAttrs,
        getElementRule,
        getSelfClosingElements,
        getNonEmptyElements,
        getMoveCaretBeforeOnEnterElements,
        getWhitespaceElements,
        getTransparentElements,
        getSpecialElements,
        isValidChild,
        isValid,
        getCustomElements,
        addValidElements,
        setValidElements,
        addCustomElements,
        addValidChildren
      };
    };

    const Styles = (settings = {}, schema) => {
      const urlOrStrRegExp = /(?:url(?:(?:\(\s*\"([^\"]+)\"\s*\))|(?:\(\s*\'([^\']+)\'\s*\))|(?:\(\s*([^)\s]+)\s*\))))|(?:\'([^\']+)\')|(?:\"([^\"]+)\")/gi;
      const styleRegExp = /\s*([^:]+):\s*([^;]+);?/g;
      const trimRightRegExp = /\s+$/;
      const encodingLookup = {};
      let validStyles;
      let invalidStyles;
      const invisibleChar = zeroWidth;
      if (schema) {
        validStyles = schema.getValidStyles();
        invalidStyles = schema.getInvalidStyles();
      }
      const encodingItems = (`\\" \\' \\; \\: ; : ` + invisibleChar).split(' ');
      for (let i = 0; i < encodingItems.length; i++) {
        encodingLookup[encodingItems[i]] = invisibleChar + i;
        encodingLookup[invisibleChar + i] = encodingItems[i];
      }
      const self = {
        parse: css => {
          const styles = {};
          let isEncoded = false;
          const urlConverter = settings.url_converter;
          const urlConverterScope = settings.url_converter_scope || self;
          const compress = (prefix, suffix, noJoin) => {
            const top = styles[prefix + '-top' + suffix];
            if (!top) {
              return;
            }
            const right = styles[prefix + '-right' + suffix];
            if (!right) {
              return;
            }
            const bottom = styles[prefix + '-bottom' + suffix];
            if (!bottom) {
              return;
            }
            const left = styles[prefix + '-left' + suffix];
            if (!left) {
              return;
            }
            const box = [
              top,
              right,
              bottom,
              left
            ];
            let i = box.length - 1;
            while (i--) {
              if (box[i] !== box[i + 1]) {
                break;
              }
            }
            if (i > -1 && noJoin) {
              return;
            }
            styles[prefix + suffix] = i === -1 ? box[0] : box.join(' ');
            delete styles[prefix + '-top' + suffix];
            delete styles[prefix + '-right' + suffix];
            delete styles[prefix + '-bottom' + suffix];
            delete styles[prefix + '-left' + suffix];
          };
          const canCompress = key => {
            const value = styles[key];
            if (!value) {
              return;
            }
            const values = value.split(' ');
            let i = values.length;
            while (i--) {
              if (values[i] !== values[0]) {
                return false;
              }
            }
            styles[key] = values[0];
            return true;
          };
          const compress2 = (target, a, b, c) => {
            if (!canCompress(a)) {
              return;
            }
            if (!canCompress(b)) {
              return;
            }
            if (!canCompress(c)) {
              return;
            }
            styles[target] = styles[a] + ' ' + styles[b] + ' ' + styles[c];
            delete styles[a];
            delete styles[b];
            delete styles[c];
          };
          const encode = str => {
            isEncoded = true;
            return encodingLookup[str];
          };
          const decode = (str, keepSlashes) => {
            if (isEncoded) {
              str = str.replace(/\uFEFF[0-9]/g, str => {
                return encodingLookup[str];
              });
            }
            if (!keepSlashes) {
              str = str.replace(/\\([\'\";:])/g, '$1');
            }
            return str;
          };
          const decodeSingleHexSequence = escSeq => {
            return String.fromCharCode(parseInt(escSeq.slice(1), 16));
          };
          const decodeHexSequences = value => {
            return value.replace(/\\[0-9a-f]+/gi, decodeSingleHexSequence);
          };
          const processUrl = (match, url, url2, url3, str, str2) => {
            str = str || str2;
            if (str) {
              str = decode(str);
              return `'` + str.replace(/\'/g, `\\'`) + `'`;
            }
            url = decode(url || url2 || url3 || '');
            if (!settings.allow_script_urls) {
              const scriptUrl = url.replace(/[\s\r\n]+/g, '');
              if (/(java|vb)script:/i.test(scriptUrl)) {
                return '';
              }
              if (!settings.allow_svg_data_urls && /^data:image\/svg/i.test(scriptUrl)) {
                return '';
              }
            }
            if (urlConverter) {
              url = urlConverter.call(urlConverterScope, url, 'style');
            }
            return `url('` + url.replace(/\'/g, `\\'`) + `')`;
          };
          if (css) {
            css = css.replace(/[\u0000-\u001F]/g, '');
            css = css.replace(/\\[\"\';:\uFEFF]/g, encode).replace(/\"[^\"]+\"|\'[^\']+\'/g, str => {
              return str.replace(/[;:]/g, encode);
            });
            let matches;
            while (matches = styleRegExp.exec(css)) {
              styleRegExp.lastIndex = matches.index + matches[0].length;
              let name = matches[1].replace(trimRightRegExp, '').toLowerCase();
              let value = matches[2].replace(trimRightRegExp, '');
              if (name && value) {
                name = decodeHexSequences(name);
                value = decodeHexSequences(value);
                if (name.indexOf(invisibleChar) !== -1 || name.indexOf('"') !== -1) {
                  continue;
                }
                if (!settings.allow_script_urls && (name === 'behavior' || /expression\s*\(|\/\*|\*\//.test(value))) {
                  continue;
                }
                if (name === 'font-weight' && value === '700') {
                  value = 'bold';
                } else if (name === 'color' || name === 'background-color') {
                  value = value.toLowerCase();
                }
                value = value.replace(urlOrStrRegExp, processUrl);
                styles[name] = isEncoded ? decode(value, true) : value;
              }
            }
            compress('border', '', true);
            compress('border', '-width');
            compress('border', '-color');
            compress('border', '-style');
            compress('padding', '');
            compress('margin', '');
            compress2('border', 'border-width', 'border-style', 'border-color');
            if (styles.border === 'medium none') {
              delete styles.border;
            }
            if (styles['border-image'] === 'none') {
              delete styles['border-image'];
            }
          }
          return styles;
        },
        serialize: (styles, elementName) => {
          let css = '';
          const serializeStyles = (elemName, validStyleList) => {
            const styleList = validStyleList[elemName];
            if (styleList) {
              for (let i = 0, l = styleList.length; i < l; i++) {
                const name = styleList[i];
                const value = styles[name];
                if (value) {
                  css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';
                }
              }
            }
          };
          const isValid = (name, elemName) => {
            if (!invalidStyles || !elemName) {
              return true;
            }
            let styleMap = invalidStyles['*'];
            if (styleMap && styleMap[name]) {
              return false;
            }
            styleMap = invalidStyles[elemName];
            return !(styleMap && styleMap[name]);
          };
          if (elementName && validStyles) {
            serializeStyles('*', validStyles);
            serializeStyles(elementName, validStyles);
          } else {
            each$d(styles, (value, name) => {
              if (value && isValid(name, elementName)) {
                css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';
              }
            });
          }
          return css;
        }
      };
      return self;
    };

    const deprecated = {
      keyLocation: true,
      layerX: true,
      layerY: true,
      returnValue: true,
      webkitMovementX: true,
      webkitMovementY: true,
      keyIdentifier: true,
      mozPressure: true
    };
    const isNativeEvent = event => event instanceof Event || isFunction(event.initEvent);
    const hasIsDefaultPrevented = event => event.isDefaultPrevented === always || event.isDefaultPrevented === never;
    const needsNormalizing = event => isNullable(event.preventDefault) || isNativeEvent(event);
    const clone$3 = (originalEvent, data) => {
      const event = data !== null && data !== void 0 ? data : {};
      for (const name in originalEvent) {
        if (!has$2(deprecated, name)) {
          event[name] = originalEvent[name];
        }
      }
      if (isNonNullable(originalEvent.composedPath)) {
        event.composedPath = () => originalEvent.composedPath();
      }
      return event;
    };
    const normalize$3 = (type, originalEvent, fallbackTarget, data) => {
      var _a;
      const event = clone$3(originalEvent, data);
      event.type = type;
      if (isNullable(event.target)) {
        event.target = (_a = event.srcElement) !== null && _a !== void 0 ? _a : fallbackTarget;
      }
      if (needsNormalizing(originalEvent)) {
        event.preventDefault = () => {
          event.defaultPrevented = true;
          event.isDefaultPrevented = always;
          if (isFunction(originalEvent.preventDefault)) {
            originalEvent.preventDefault();
          }
        };
        event.stopPropagation = () => {
          event.cancelBubble = true;
          event.isPropagationStopped = always;
          if (isFunction(originalEvent.stopPropagation)) {
            originalEvent.stopPropagation();
          }
        };
        event.stopImmediatePropagation = () => {
          event.isImmediatePropagationStopped = always;
          event.stopPropagation();
        };
        if (!hasIsDefaultPrevented(event)) {
          event.isDefaultPrevented = event.defaultPrevented === true ? always : never;
          event.isPropagationStopped = event.cancelBubble === true ? always : never;
          event.isImmediatePropagationStopped = never;
        }
      }
      return event;
    };

    const eventExpandoPrefix = 'mce-data-';
    const mouseEventRe = /^(?:mouse|contextmenu)|click/;
    const addEvent = (target, name, callback, capture) => {
      target.addEventListener(name, callback, capture || false);
    };
    const removeEvent = (target, name, callback, capture) => {
      target.removeEventListener(name, callback, capture || false);
    };
    const isMouseEvent = event => isNonNullable(event) && mouseEventRe.test(event.type);
    const fix = (originalEvent, data) => {
      const event = normalize$3(originalEvent.type, originalEvent, document, data);
      if (isMouseEvent(originalEvent) && isUndefined(originalEvent.pageX) && !isUndefined(originalEvent.clientX)) {
        const eventDoc = event.target.ownerDocument || document;
        const doc = eventDoc.documentElement;
        const body = eventDoc.body;
        const mouseEvent = event;
        mouseEvent.pageX = originalEvent.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
        mouseEvent.pageY = originalEvent.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
      }
      return event;
    };
    const bindOnReady = (win, callback, eventUtils) => {
      const doc = win.document, event = { type: 'ready' };
      if (eventUtils.domLoaded) {
        callback(event);
        return;
      }
      const isDocReady = () => {
        return doc.readyState === 'complete' || doc.readyState === 'interactive' && doc.body;
      };
      const readyHandler = () => {
        removeEvent(win, 'DOMContentLoaded', readyHandler);
        removeEvent(win, 'load', readyHandler);
        if (!eventUtils.domLoaded) {
          eventUtils.domLoaded = true;
          callback(event);
        }
        win = null;
      };
      if (isDocReady()) {
        readyHandler();
      } else {
        addEvent(win, 'DOMContentLoaded', readyHandler);
      }
      if (!eventUtils.domLoaded) {
        addEvent(win, 'load', readyHandler);
      }
    };
    class EventUtils {
      constructor() {
        this.domLoaded = false;
        this.events = {};
        this.count = 1;
        this.expando = eventExpandoPrefix + (+new Date()).toString(32);
        this.hasFocusIn = 'onfocusin' in document.documentElement;
        this.count = 1;
      }
      bind(target, names, callback, scope) {
        const self = this;
        let callbackList;
        const win = window;
        const defaultNativeHandler = evt => {
          self.executeHandlers(fix(evt || win.event), id);
        };
        if (!target || isText$a(target) || isComment(target)) {
          return callback;
        }
        let id;
        if (!target[self.expando]) {
          id = self.count++;
          target[self.expando] = id;
          self.events[id] = {};
        } else {
          id = target[self.expando];
        }
        scope = scope || target;
        const namesList = names.split(' ');
        let i = namesList.length;
        while (i--) {
          let name = namesList[i];
          let nativeHandler = defaultNativeHandler;
          let capture = false;
          let fakeName = false;
          if (name === 'DOMContentLoaded') {
            name = 'ready';
          }
          if (self.domLoaded && name === 'ready' && target.readyState === 'complete') {
            callback.call(scope, fix({ type: name }));
            continue;
          }
          if (!self.hasFocusIn && (name === 'focusin' || name === 'focusout')) {
            capture = true;
            fakeName = name === 'focusin' ? 'focus' : 'blur';
            nativeHandler = evt => {
              const event = fix(evt || win.event);
              event.type = event.type === 'focus' ? 'focusin' : 'focusout';
              self.executeHandlers(event, id);
            };
          }
          callbackList = self.events[id][name];
          if (!callbackList) {
            self.events[id][name] = callbackList = [{
                func: callback,
                scope
              }];
            callbackList.fakeName = fakeName;
            callbackList.capture = capture;
            callbackList.nativeHandler = nativeHandler;
            if (name === 'ready') {
              bindOnReady(target, nativeHandler, self);
            } else {
              addEvent(target, fakeName || name, nativeHandler, capture);
            }
          } else {
            if (name === 'ready' && self.domLoaded) {
              callback(fix({ type: name }));
            } else {
              callbackList.push({
                func: callback,
                scope
              });
            }
          }
        }
        target = callbackList = null;
        return callback;
      }
      unbind(target, names, callback) {
        if (!target || isText$a(target) || isComment(target)) {
          return this;
        }
        const id = target[this.expando];
        if (id) {
          let eventMap = this.events[id];
          if (names) {
            const namesList = names.split(' ');
            let i = namesList.length;
            while (i--) {
              const name = namesList[i];
              const callbackList = eventMap[name];
              if (callbackList) {
                if (callback) {
                  let ci = callbackList.length;
                  while (ci--) {
                    if (callbackList[ci].func === callback) {
                      const nativeHandler = callbackList.nativeHandler;
                      const fakeName = callbackList.fakeName, capture = callbackList.capture;
                      const newCallbackList = callbackList.slice(0, ci).concat(callbackList.slice(ci + 1));
                      newCallbackList.nativeHandler = nativeHandler;
                      newCallbackList.fakeName = fakeName;
                      newCallbackList.capture = capture;
                      eventMap[name] = newCallbackList;
                    }
                  }
                }
                if (!callback || callbackList.length === 0) {
                  delete eventMap[name];
                  removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);
                }
              }
            }
          } else {
            each$d(eventMap, (callbackList, name) => {
              removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);
            });
            eventMap = {};
          }
          for (const name in eventMap) {
            if (has$2(eventMap, name)) {
              return this;
            }
          }
          delete this.events[id];
          try {
            delete target[this.expando];
          } catch (ex) {
            target[this.expando] = null;
          }
        }
        return this;
      }
      fire(target, name, args) {
        return this.dispatch(target, name, args);
      }
      dispatch(target, name, args) {
        if (!target || isText$a(target) || isComment(target)) {
          return this;
        }
        const event = fix({
          type: name,
          target
        }, args);
        do {
          const id = target[this.expando];
          if (id) {
            this.executeHandlers(event, id);
          }
          target = target.parentNode || target.ownerDocument || target.defaultView || target.parentWindow;
        } while (target && !event.isPropagationStopped());
        return this;
      }
      clean(target) {
        if (!target || isText$a(target) || isComment(target)) {
          return this;
        }
        if (target[this.expando]) {
          this.unbind(target);
        }
        if (!target.getElementsByTagName) {
          target = target.document;
        }
        if (target && target.getElementsByTagName) {
          this.unbind(target);
          const children = target.getElementsByTagName('*');
          let i = children.length;
          while (i--) {
            target = children[i];
            if (target[this.expando]) {
              this.unbind(target);
            }
          }
        }
        return this;
      }
      destroy() {
        this.events = {};
      }
      cancel(e) {
        if (e) {
          e.preventDefault();
          e.stopImmediatePropagation();
        }
        return false;
      }
      executeHandlers(evt, id) {
        const container = this.events[id];
        const callbackList = container && container[evt.type];
        if (callbackList) {
          for (let i = 0, l = callbackList.length; i < l; i++) {
            const callback = callbackList[i];
            if (callback && callback.func.call(callback.scope, evt) === false) {
              evt.preventDefault();
            }
            if (evt.isImmediatePropagationStopped()) {
              return;
            }
          }
        }
      }
    }
    EventUtils.Event = new EventUtils();

    const each$a = Tools.each;
    const grep = Tools.grep;
    const internalStyleName = 'data-mce-style';
    const numericalCssMap = Tools.makeMap('fill-opacity font-weight line-height opacity orphans widows z-index zoom', ' ');
    const legacySetAttribute = (elm, name, value) => {
      if (isNullable(value) || value === '') {
        remove$b(elm, name);
      } else {
        set$3(elm, name, value);
      }
    };
    const camelCaseToHyphens = name => name.replace(/[A-Z]/g, v => '-' + v.toLowerCase());
    const findNodeIndex = (node, normalized) => {
      let idx = 0;
      if (node) {
        for (let lastNodeType = node.nodeType, tempNode = node.previousSibling; tempNode; tempNode = tempNode.previousSibling) {
          const nodeType = tempNode.nodeType;
          if (normalized && isText$a(tempNode)) {
            if (nodeType === lastNodeType || !tempNode.data.length) {
              continue;
            }
          }
          idx++;
          lastNodeType = nodeType;
        }
      }
      return idx;
    };
    const updateInternalStyleAttr = (styles, elm) => {
      const rawValue = get$9(elm, 'style');
      const value = styles.serialize(styles.parse(rawValue), name(elm));
      legacySetAttribute(elm, internalStyleName, value);
    };
    const convertStyleToString = (cssValue, cssName) => {
      if (isNumber(cssValue)) {
        return has$2(numericalCssMap, cssName) ? cssValue + '' : cssValue + 'px';
      } else {
        return cssValue;
      }
    };
    const applyStyle$1 = ($elm, cssName, cssValue) => {
      const normalizedName = camelCaseToHyphens(cssName);
      if (isNullable(cssValue) || cssValue === '') {
        remove$7($elm, normalizedName);
      } else {
        set$2($elm, normalizedName, convertStyleToString(cssValue, normalizedName));
      }
    };
    const setupAttrHooks = (styles, settings, getContext) => {
      const keepValues = settings.keep_values;
      const keepUrlHook = {
        set: (elm, value, name) => {
          const sugarElm = SugarElement.fromDom(elm);
          if (isFunction(settings.url_converter) && isNonNullable(value)) {
            value = settings.url_converter.call(settings.url_converter_scope || getContext(), String(value), name, elm);
          }
          const internalName = 'data-mce-' + name;
          legacySetAttribute(sugarElm, internalName, value);
          legacySetAttribute(sugarElm, name, value);
        },
        get: (elm, name) => {
          const sugarElm = SugarElement.fromDom(elm);
          return get$9(sugarElm, 'data-mce-' + name) || get$9(sugarElm, name);
        }
      };
      const attrHooks = {
        style: {
          set: (elm, value) => {
            const sugarElm = SugarElement.fromDom(elm);
            if (keepValues) {
              legacySetAttribute(sugarElm, internalStyleName, value);
            }
            remove$b(sugarElm, 'style');
            if (isString(value)) {
              setAll(sugarElm, styles.parse(value));
            }
          },
          get: elm => {
            const sugarElm = SugarElement.fromDom(elm);
            const value = get$9(sugarElm, internalStyleName) || get$9(sugarElm, 'style');
            return styles.serialize(styles.parse(value), name(sugarElm));
          }
        }
      };
      if (keepValues) {
        attrHooks.href = attrHooks.src = keepUrlHook;
      }
      return attrHooks;
    };
    const DOMUtils = (doc, settings = {}) => {
      const addedStyles = {};
      const win = window;
      const files = {};
      let counter = 0;
      const stdMode = true;
      const boxModel = true;
      const styleSheetLoader = instance.forElement(SugarElement.fromDom(doc), {
        contentCssCors: settings.contentCssCors,
        referrerPolicy: settings.referrerPolicy
      });
      const boundEvents = [];
      const schema = settings.schema ? settings.schema : Schema({});
      const styles = Styles({
        url_converter: settings.url_converter,
        url_converter_scope: settings.url_converter_scope
      }, settings.schema);
      const events = settings.ownEvents ? new EventUtils() : EventUtils.Event;
      const blockElementsMap = schema.getBlockElements();
      const isBlock = node => {
        if (isString(node)) {
          return has$2(blockElementsMap, node);
        } else {
          return isElement$6(node) && (has$2(blockElementsMap, node.nodeName) || isTransparentBlock(schema, node));
        }
      };
      const get = elm => elm && doc && isString(elm) ? doc.getElementById(elm) : elm;
      const _get = elm => {
        const value = get(elm);
        return isNonNullable(value) ? SugarElement.fromDom(value) : null;
      };
      const getAttrib = (elm, name, defaultVal = '') => {
        let value;
        const $elm = _get(elm);
        if (isNonNullable($elm) && isElement$7($elm)) {
          const hook = attrHooks[name];
          if (hook && hook.get) {
            value = hook.get($elm.dom, name);
          } else {
            value = get$9($elm, name);
          }
        }
        return isNonNullable(value) ? value : defaultVal;
      };
      const getAttribs = elm => {
        const node = get(elm);
        return isNullable(node) ? [] : node.attributes;
      };
      const setAttrib = (elm, name, value) => {
        run(elm, e => {
          if (isElement$6(e)) {
            const $elm = SugarElement.fromDom(e);
            const val = value === '' ? null : value;
            const originalValue = get$9($elm, name);
            const hook = attrHooks[name];
            if (hook && hook.set) {
              hook.set($elm.dom, val, name);
            } else {
              legacySetAttribute($elm, name, val);
            }
            if (originalValue !== val && settings.onSetAttrib) {
              settings.onSetAttrib({
                attrElm: $elm.dom,
                attrName: name,
                attrValue: val
              });
            }
          }
        });
      };
      const clone = (node, deep) => {
        return node.cloneNode(deep);
      };
      const getRoot = () => settings.root_element || doc.body;
      const getViewPort = argWin => {
        const vp = getBounds(argWin);
        return {
          x: vp.x,
          y: vp.y,
          w: vp.width,
          h: vp.height
        };
      };
      const getPos$1 = (elm, rootElm) => getPos(doc.body, get(elm), rootElm);
      const setStyle = (elm, name, value) => {
        run(elm, e => {
          const $elm = SugarElement.fromDom(e);
          applyStyle$1($elm, name, value);
          if (settings.update_styles) {
            updateInternalStyleAttr(styles, $elm);
          }
        });
      };
      const setStyles = (elm, stylesArg) => {
        run(elm, e => {
          const $elm = SugarElement.fromDom(e);
          each$d(stylesArg, (v, n) => {
            applyStyle$1($elm, n, v);
          });
          if (settings.update_styles) {
            updateInternalStyleAttr(styles, $elm);
          }
        });
      };
      const getStyle = (elm, name, computed) => {
        const $elm = get(elm);
        if (isNullable($elm) || !isElement$6($elm)) {
          return undefined;
        }
        if (computed) {
          return get$7(SugarElement.fromDom($elm), camelCaseToHyphens(name));
        } else {
          name = name.replace(/-(\D)/g, (a, b) => b.toUpperCase());
          if (name === 'float') {
            name = 'cssFloat';
          }
          return $elm.style ? $elm.style[name] : undefined;
        }
      };
      const getSize = elm => {
        const $elm = get(elm);
        if (!$elm) {
          return {
            w: 0,
            h: 0
          };
        }
        let w = getStyle($elm, 'width');
        let h = getStyle($elm, 'height');
        if (!w || w.indexOf('px') === -1) {
          w = '0';
        }
        if (!h || h.indexOf('px') === -1) {
          h = '0';
        }
        return {
          w: parseInt(w, 10) || $elm.offsetWidth || $elm.clientWidth,
          h: parseInt(h, 10) || $elm.offsetHeight || $elm.clientHeight
        };
      };
      const getRect = elm => {
        const $elm = get(elm);
        const pos = getPos$1($elm);
        const size = getSize($elm);
        return {
          x: pos.x,
          y: pos.y,
          w: size.w,
          h: size.h
        };
      };
      const is = (elm, selector) => {
        if (!elm) {
          return false;
        }
        const elms = isArray$1(elm) ? elm : [elm];
        return exists(elms, e => {
          return is$1(SugarElement.fromDom(e), selector);
        });
      };
      const getParents = (elm, selector, root, collect) => {
        const result = [];
        let node = get(elm);
        collect = collect === undefined;
        const resolvedRoot = root || (getRoot().nodeName !== 'BODY' ? getRoot().parentNode : null);
        if (isString(selector)) {
          if (selector === '*') {
            selector = isElement$6;
          } else {
            const selectorVal = selector;
            selector = node => is(node, selectorVal);
          }
        }
        while (node) {
          if (node === resolvedRoot || isNullable(node.nodeType) || isDocument$1(node) || isDocumentFragment(node)) {
            break;
          }
          if (!selector || selector(node)) {
            if (collect) {
              result.push(node);
            } else {
              return [node];
            }
          }
          node = node.parentNode;
        }
        return collect ? result : null;
      };
      const getParent = (node, selector, root) => {
        const parents = getParents(node, selector, root, false);
        return parents && parents.length > 0 ? parents[0] : null;
      };
      const _findSib = (node, selector, name) => {
        let func = selector;
        if (node) {
          if (isString(selector)) {
            func = node => {
              return is(node, selector);
            };
          }
          for (let tempNode = node[name]; tempNode; tempNode = tempNode[name]) {
            if (isFunction(func) && func(tempNode)) {
              return tempNode;
            }
          }
        }
        return null;
      };
      const getNext = (node, selector) => _findSib(node, selector, 'nextSibling');
      const getPrev = (node, selector) => _findSib(node, selector, 'previousSibling');
      const isParentNode = node => isFunction(node.querySelectorAll);
      const select = (selector, scope) => {
        var _a, _b;
        const elm = (_b = (_a = get(scope)) !== null && _a !== void 0 ? _a : settings.root_element) !== null && _b !== void 0 ? _b : doc;
        return isParentNode(elm) ? from(elm.querySelectorAll(selector)) : [];
      };
      const run = function (elm, func, scope) {
        const context = scope !== null && scope !== void 0 ? scope : this;
        if (isArray$1(elm)) {
          const result = [];
          each$a(elm, (e, i) => {
            const node = get(e);
            if (node) {
              result.push(func.call(context, node, i));
            }
          });
          return result;
        } else {
          const node = get(elm);
          return !node ? false : func.call(context, node);
        }
      };
      const setAttribs = (elm, attrs) => {
        run(elm, $elm => {
          each$d(attrs, (value, name) => {
            setAttrib($elm, name, value);
          });
        });
      };
      const setHTML = (elm, html) => {
        run(elm, e => {
          const $elm = SugarElement.fromDom(e);
          set$1($elm, html);
        });
      };
      const add = (parentElm, name, attrs, html, create) => run(parentElm, parentElm => {
        const newElm = isString(name) ? doc.createElement(name) : name;
        if (isNonNullable(attrs)) {
          setAttribs(newElm, attrs);
        }
        if (html) {
          if (!isString(html) && html.nodeType) {
            newElm.appendChild(html);
          } else if (isString(html)) {
            setHTML(newElm, html);
          }
        }
        return !create ? parentElm.appendChild(newElm) : newElm;
      });
      const create = (name, attrs, html) => add(doc.createElement(name), name, attrs, html, true);
      const decode = Entities.decode;
      const encode = Entities.encodeAllRaw;
      const createHTML = (name, attrs, html = '') => {
        let outHtml = '<' + name;
        for (const key in attrs) {
          if (hasNonNullableKey(attrs, key)) {
            outHtml += ' ' + key + '="' + encode(attrs[key]) + '"';
          }
        }
        if (isEmpty$3(html) && has$2(schema.getVoidElements(), name)) {
          return outHtml + ' />';
        } else {
          return outHtml + '>' + html + '</' + name + '>';
        }
      };
      const createFragment = html => {
        const container = doc.createElement('div');
        const frag = doc.createDocumentFragment();
        frag.appendChild(container);
        if (html) {
          container.innerHTML = html;
        }
        let node;
        while (node = container.firstChild) {
          frag.appendChild(node);
        }
        frag.removeChild(container);
        return frag;
      };
      const remove = (node, keepChildren) => {
        return run(node, n => {
          const $node = SugarElement.fromDom(n);
          if (keepChildren) {
            each$e(children$1($node), child => {
              if (isText$b(child) && child.dom.length === 0) {
                remove$6(child);
              } else {
                before$3($node, child);
              }
            });
          }
          remove$6($node);
          return $node.dom;
        });
      };
      const removeAllAttribs = e => run(e, e => {
        const attrs = e.attributes;
        for (let i = attrs.length - 1; i >= 0; i--) {
          e.removeAttributeNode(attrs.item(i));
        }
      });
      const parseStyle = cssText => styles.parse(cssText);
      const serializeStyle = (stylesArg, name) => styles.serialize(stylesArg, name);
      const addStyle = cssText => {
        if (self !== DOMUtils.DOM && doc === document) {
          if (addedStyles[cssText]) {
            return;
          }
          addedStyles[cssText] = true;
        }
        let styleElm = doc.getElementById('mceDefaultStyles');
        if (!styleElm) {
          styleElm = doc.createElement('style');
          styleElm.id = 'mceDefaultStyles';
          styleElm.type = 'text/css';
          const head = doc.head;
          if (head.firstChild) {
            head.insertBefore(styleElm, head.firstChild);
          } else {
            head.appendChild(styleElm);
          }
        }
        if (styleElm.styleSheet) {
          styleElm.styleSheet.cssText += cssText;
        } else {
          styleElm.appendChild(doc.createTextNode(cssText));
        }
      };
      const loadCSS = urls => {
        if (!urls) {
          urls = '';
        }
        each$e(urls.split(','), url => {
          files[url] = true;
          styleSheetLoader.load(url).catch(noop);
        });
      };
      const toggleClass = (elm, cls, state) => {
        run(elm, e => {
          if (isElement$6(e)) {
            const $elm = SugarElement.fromDom(e);
            const classes = cls.split(' ');
            each$e(classes, c => {
              if (isNonNullable(state)) {
                const fn = state ? add$2 : remove$8;
                fn($elm, c);
              } else {
                toggle$1($elm, c);
              }
            });
          }
        });
      };
      const addClass = (elm, cls) => {
        toggleClass(elm, cls, true);
      };
      const removeClass = (elm, cls) => {
        toggleClass(elm, cls, false);
      };
      const hasClass = (elm, cls) => {
        const $elm = _get(elm);
        const classes = cls.split(' ');
        return isNonNullable($elm) && forall(classes, c => has($elm, c));
      };
      const show = elm => {
        run(elm, e => remove$7(SugarElement.fromDom(e), 'display'));
      };
      const hide = elm => {
        run(elm, e => set$2(SugarElement.fromDom(e), 'display', 'none'));
      };
      const isHidden = elm => {
        const $elm = _get(elm);
        return isNonNullable($elm) && is$2(getRaw($elm, 'display'), 'none');
      };
      const uniqueId = prefix => (!prefix ? 'mce_' : prefix) + counter++;
      const getOuterHTML = elm => {
        const $elm = _get(elm);
        if (isNonNullable($elm)) {
          return isElement$6($elm.dom) ? $elm.dom.outerHTML : getOuter($elm);
        } else {
          return '';
        }
      };
      const setOuterHTML = (elm, html) => {
        run(elm, $elm => {
          if (isElement$6($elm)) {
            $elm.outerHTML = html;
          }
        });
      };
      const insertAfter = (node, reference) => {
        const referenceNode = get(reference);
        return run(node, node => {
          const parent = referenceNode === null || referenceNode === void 0 ? void 0 : referenceNode.parentNode;
          const nextSibling = referenceNode === null || referenceNode === void 0 ? void 0 : referenceNode.nextSibling;
          if (parent) {
            if (nextSibling) {
              parent.insertBefore(node, nextSibling);
            } else {
              parent.appendChild(node);
            }
          }
          return node;
        });
      };
      const replace = (newElm, oldElm, keepChildren) => run(oldElm, elm => {
        var _a;
        const replacee = isArray$1(oldElm) ? newElm.cloneNode(true) : newElm;
        if (keepChildren) {
          each$a(grep(elm.childNodes), node => {
            replacee.appendChild(node);
          });
        }
        (_a = elm.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(replacee, elm);
        return elm;
      });
      const rename = (elm, name) => {
        if (elm.nodeName !== name.toUpperCase()) {
          const newElm = create(name);
          each$a(getAttribs(elm), attrNode => {
            setAttrib(newElm, attrNode.nodeName, getAttrib(elm, attrNode.nodeName));
          });
          replace(newElm, elm, true);
          return newElm;
        } else {
          return elm;
        }
      };
      const findCommonAncestor = (a, b) => {
        let ps = a;
        while (ps) {
          let pe = b;
          while (pe && ps !== pe) {
            pe = pe.parentNode;
          }
          if (ps === pe) {
            break;
          }
          ps = ps.parentNode;
        }
        if (!ps && a.ownerDocument) {
          return a.ownerDocument.documentElement;
        } else {
          return ps;
        }
      };
      const isNonEmptyElement = node => {
        if (isElement$6(node)) {
          const isNamedAnchor = node.nodeName.toLowerCase() === 'a' && !getAttrib(node, 'href') && getAttrib(node, 'id');
          if (getAttrib(node, 'name') || getAttrib(node, 'data-mce-bookmark') || isNamedAnchor) {
            return true;
          }
        }
        return false;
      };
      const isEmpty = (node, elements) => {
        let brCount = 0;
        if (isNonEmptyElement(node)) {
          return false;
        }
        const firstChild = node.firstChild;
        if (firstChild) {
          const walker = new DomTreeWalker(firstChild, node);
          const whitespaceElements = schema ? schema.getWhitespaceElements() : {};
          const nonEmptyElements = elements || (schema ? schema.getNonEmptyElements() : null);
          let tempNode = firstChild;
          do {
            if (isElement$6(tempNode)) {
              const bogusVal = tempNode.getAttribute('data-mce-bogus');
              if (bogusVal) {
                tempNode = walker.next(bogusVal === 'all');
                continue;
              }
              const name = tempNode.nodeName.toLowerCase();
              if (nonEmptyElements && nonEmptyElements[name]) {
                if (name === 'br') {
                  brCount++;
                  tempNode = walker.next();
                  continue;
                }
                return false;
              }
              if (isNonEmptyElement(tempNode)) {
                return false;
              }
            }
            if (isComment(tempNode)) {
              return false;
            }
            if (isText$a(tempNode) && !isWhitespaceText(tempNode.data)) {
              return false;
            }
            if (isText$a(tempNode) && tempNode.parentNode && whitespaceElements[tempNode.parentNode.nodeName] && isWhitespaceText(tempNode.data)) {
              return false;
            }
            tempNode = walker.next();
          } while (tempNode);
        }
        return brCount <= 1;
      };
      const createRng = () => doc.createRange();
      const split = (parentElm, splitElm, replacementElm) => {
        let range = createRng();
        let beforeFragment;
        let afterFragment;
        if (parentElm && splitElm && parentElm.parentNode && splitElm.parentNode) {
          const parentNode = parentElm.parentNode;
          range.setStart(parentNode, findNodeIndex(parentElm));
          range.setEnd(splitElm.parentNode, findNodeIndex(splitElm));
          beforeFragment = range.extractContents();
          range = createRng();
          range.setStart(splitElm.parentNode, findNodeIndex(splitElm) + 1);
          range.setEnd(parentNode, findNodeIndex(parentElm) + 1);
          afterFragment = range.extractContents();
          parentNode.insertBefore(trimNode(self, beforeFragment), parentElm);
          if (replacementElm) {
            parentNode.insertBefore(replacementElm, parentElm);
          } else {
            parentNode.insertBefore(splitElm, parentElm);
          }
          parentNode.insertBefore(trimNode(self, afterFragment), parentElm);
          remove(parentElm);
          return replacementElm || splitElm;
        } else {
          return undefined;
        }
      };
      const bind = (target, name, func, scope) => {
        if (isArray$1(target)) {
          let i = target.length;
          const rv = [];
          while (i--) {
            rv[i] = bind(target[i], name, func, scope);
          }
          return rv;
        } else {
          if (settings.collect && (target === doc || target === win)) {
            boundEvents.push([
              target,
              name,
              func,
              scope
            ]);
          }
          return events.bind(target, name, func, scope || self);
        }
      };
      const unbind = (target, name, func) => {
        if (isArray$1(target)) {
          let i = target.length;
          const rv = [];
          while (i--) {
            rv[i] = unbind(target[i], name, func);
          }
          return rv;
        } else {
          if (boundEvents.length > 0 && (target === doc || target === win)) {
            let i = boundEvents.length;
            while (i--) {
              const [boundTarget, boundName, boundFunc] = boundEvents[i];
              if (target === boundTarget && (!name || name === boundName) && (!func || func === boundFunc)) {
                events.unbind(boundTarget, boundName, boundFunc);
              }
            }
          }
          return events.unbind(target, name, func);
        }
      };
      const dispatch = (target, name, evt) => events.dispatch(target, name, evt);
      const fire = (target, name, evt) => events.dispatch(target, name, evt);
      const getContentEditable = node => {
        if (node && isElement$6(node)) {
          const contentEditable = node.getAttribute('data-mce-contenteditable');
          if (contentEditable && contentEditable !== 'inherit') {
            return contentEditable;
          }
          return node.contentEditable !== 'inherit' ? node.contentEditable : null;
        } else {
          return null;
        }
      };
      const getContentEditableParent = node => {
        const root = getRoot();
        let state = null;
        for (let tempNode = node; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {
          state = getContentEditable(tempNode);
          if (state !== null) {
            break;
          }
        }
        return state;
      };
      const isEditable = node => {
        if (isNonNullable(node)) {
          const scope = isElement$6(node) ? node : node.parentElement;
          const isRootEditable = getContentEditable(getRoot()) === 'true';
          return isNonNullable(scope) && isEditable$3(SugarElement.fromDom(scope), isRootEditable);
        } else {
          return false;
        }
      };
      const destroy = () => {
        if (boundEvents.length > 0) {
          let i = boundEvents.length;
          while (i--) {
            const [boundTarget, boundName, boundFunc] = boundEvents[i];
            events.unbind(boundTarget, boundName, boundFunc);
          }
        }
        each$d(files, (_, url) => {
          styleSheetLoader.unload(url);
          delete files[url];
        });
      };
      const isChildOf = (node, parent) => {
        return node === parent || parent.contains(node);
      };
      const dumpRng = r => 'startContainer: ' + r.startContainer.nodeName + ', startOffset: ' + r.startOffset + ', endContainer: ' + r.endContainer.nodeName + ', endOffset: ' + r.endOffset;
      const self = {
        doc,
        settings,
        win,
        files,
        stdMode,
        boxModel,
        styleSheetLoader,
        boundEvents,
        styles,
        schema,
        events,
        isBlock: isBlock,
        root: null,
        clone,
        getRoot,
        getViewPort,
        getRect,
        getSize,
        getParent,
        getParents: getParents,
        get,
        getNext,
        getPrev,
        select,
        is,
        add,
        create,
        createHTML,
        createFragment,
        remove,
        setStyle,
        getStyle: getStyle,
        setStyles,
        removeAllAttribs,
        setAttrib,
        setAttribs,
        getAttrib,
        getPos: getPos$1,
        parseStyle,
        serializeStyle,
        addStyle,
        loadCSS,
        addClass,
        removeClass,
        hasClass,
        toggleClass,
        show,
        hide,
        isHidden,
        uniqueId,
        setHTML,
        getOuterHTML,
        setOuterHTML,
        decode,
        encode,
        insertAfter,
        replace,
        rename,
        findCommonAncestor,
        run,
        getAttribs,
        isEmpty,
        createRng,
        nodeIndex: findNodeIndex,
        split,
        bind: bind,
        unbind: unbind,
        fire,
        dispatch,
        getContentEditable,
        getContentEditableParent,
        isEditable,
        destroy,
        isChildOf,
        dumpRng
      };
      const attrHooks = setupAttrHooks(styles, settings, constant(self));
      return self;
    };
    DOMUtils.DOM = DOMUtils(document);
    DOMUtils.nodeIndex = findNodeIndex;

    const DOM$b = DOMUtils.DOM;
    const QUEUED = 0;
    const LOADING = 1;
    const LOADED = 2;
    const FAILED = 3;
    class ScriptLoader {
      constructor(settings = {}) {
        this.states = {};
        this.queue = [];
        this.scriptLoadedCallbacks = {};
        this.queueLoadedCallbacks = [];
        this.loading = false;
        this.settings = settings;
      }
      _setReferrerPolicy(referrerPolicy) {
        this.settings.referrerPolicy = referrerPolicy;
      }
      loadScript(url) {
        return new Promise((resolve, reject) => {
          const dom = DOM$b;
          let elm;
          const cleanup = () => {
            dom.remove(id);
            if (elm) {
              elm.onerror = elm.onload = elm = null;
            }
          };
          const done = () => {
            cleanup();
            resolve();
          };
          const error = () => {
            cleanup();
            reject('Failed to load script: ' + url);
          };
          const id = dom.uniqueId();
          elm = document.createElement('script');
          elm.id = id;
          elm.type = 'text/javascript';
          elm.src = Tools._addCacheSuffix(url);
          if (this.settings.referrerPolicy) {
            dom.setAttrib(elm, 'referrerpolicy', this.settings.referrerPolicy);
          }
          elm.onload = done;
          elm.onerror = error;
          (document.getElementsByTagName('head')[0] || document.body).appendChild(elm);
        });
      }
      isDone(url) {
        return this.states[url] === LOADED;
      }
      markDone(url) {
        this.states[url] = LOADED;
      }
      add(url) {
        const self = this;
        self.queue.push(url);
        const state = self.states[url];
        if (state === undefined) {
          self.states[url] = QUEUED;
        }
        return new Promise((resolve, reject) => {
          if (!self.scriptLoadedCallbacks[url]) {
            self.scriptLoadedCallbacks[url] = [];
          }
          self.scriptLoadedCallbacks[url].push({
            resolve,
            reject
          });
        });
      }
      load(url) {
        return this.add(url);
      }
      remove(url) {
        delete this.states[url];
        delete this.scriptLoadedCallbacks[url];
      }
      loadQueue() {
        const queue = this.queue;
        this.queue = [];
        return this.loadScripts(queue);
      }
      loadScripts(scripts) {
        const self = this;
        const execCallbacks = (name, url) => {
          get$a(self.scriptLoadedCallbacks, url).each(callbacks => {
            each$e(callbacks, callback => callback[name](url));
          });
          delete self.scriptLoadedCallbacks[url];
        };
        const processResults = results => {
          const failures = filter$5(results, result => result.status === 'rejected');
          if (failures.length > 0) {
            return Promise.reject(bind$3(failures, ({reason}) => isArray$1(reason) ? reason : [reason]));
          } else {
            return Promise.resolve();
          }
        };
        const load = urls => Promise.allSettled(map$3(urls, url => {
          if (self.states[url] === LOADED) {
            execCallbacks('resolve', url);
            return Promise.resolve();
          } else if (self.states[url] === FAILED) {
            execCallbacks('reject', url);
            return Promise.reject(url);
          } else {
            self.states[url] = LOADING;
            return self.loadScript(url).then(() => {
              self.states[url] = LOADED;
              execCallbacks('resolve', url);
              const queue = self.queue;
              if (queue.length > 0) {
                self.queue = [];
                return load(queue).then(processResults);
              } else {
                return Promise.resolve();
              }
            }, () => {
              self.states[url] = FAILED;
              execCallbacks('reject', url);
              return Promise.reject(url);
            });
          }
        }));
        const processQueue = urls => {
          self.loading = true;
          return load(urls).then(results => {
            self.loading = false;
            const nextQueuedItem = self.queueLoadedCallbacks.shift();
            Optional.from(nextQueuedItem).each(call);
            return processResults(results);
          });
        };
        const uniqueScripts = stringArray(scripts);
        if (self.loading) {
          return new Promise((resolve, reject) => {
            self.queueLoadedCallbacks.push(() => processQueue(uniqueScripts).then(resolve, reject));
          });
        } else {
          return processQueue(uniqueScripts);
        }
      }
    }
    ScriptLoader.ScriptLoader = new ScriptLoader();

    const Cell = initial => {
      let value = initial;
      const get = () => {
        return value;
      };
      const set = v => {
        value = v;
      };
      return {
        get,
        set
      };
    };

    const isRaw = str => isObject(str) && has$2(str, 'raw');
    const isTokenised = str => isArray$1(str) && str.length > 1;
    const data = {};
    const currentCode = Cell('en');
    const getLanguageData = () => get$a(data, currentCode.get());
    const getData$1 = () => map$2(data, value => ({ ...value }));
    const setCode = newCode => {
      if (newCode) {
        currentCode.set(newCode);
      }
    };
    const getCode = () => currentCode.get();
    const add$1 = (code, items) => {
      let langData = data[code];
      if (!langData) {
        data[code] = langData = {};
      }
      each$d(items, (translation, name) => {
        langData[name.toLowerCase()] = translation;
      });
    };
    const translate = text => {
      const langData = getLanguageData().getOr({});
      const toString = obj => {
        if (isFunction(obj)) {
          return Object.prototype.toString.call(obj);
        }
        return !isEmpty(obj) ? '' + obj : '';
      };
      const isEmpty = text => text === '' || text === null || text === undefined;
      const getLangData = text => {
        const textstr = toString(text);
        return get$a(langData, textstr.toLowerCase()).map(toString).getOr(textstr);
      };
      const removeContext = str => str.replace(/{context:\w+}$/, '');
      if (isEmpty(text)) {
        return '';
      }
      if (isRaw(text)) {
        return toString(text.raw);
      }
      if (isTokenised(text)) {
        const values = text.slice(1);
        const substitued = getLangData(text[0]).replace(/\{([0-9]+)\}/g, ($1, $2) => has$2(values, $2) ? toString(values[$2]) : $1);
        return removeContext(substitued);
      }
      return removeContext(getLangData(text));
    };
    const isRtl$1 = () => getLanguageData().bind(items => get$a(items, '_dir')).exists(dir => dir === 'rtl');
    const hasCode = code => has$2(data, code);
    const I18n = {
      getData: getData$1,
      setCode,
      getCode,
      add: add$1,
      translate,
      isRtl: isRtl$1,
      hasCode
    };

    const AddOnManager = () => {
      const items = [];
      const urls = {};
      const lookup = {};
      const _listeners = [];
      const runListeners = (name, state) => {
        const matchedListeners = filter$5(_listeners, listener => listener.name === name && listener.state === state);
        each$e(matchedListeners, listener => listener.resolve());
      };
      const isLoaded = name => has$2(urls, name);
      const isAdded = name => has$2(lookup, name);
      const get = name => {
        if (lookup[name]) {
          return lookup[name].instance;
        }
        return undefined;
      };
      const loadLanguagePack = (name, languages) => {
        const language = I18n.getCode();
        const wrappedLanguages = ',' + (languages || '') + ',';
        if (!language || languages && wrappedLanguages.indexOf(',' + language + ',') === -1) {
          return;
        }
        ScriptLoader.ScriptLoader.add(urls[name] + '/langs/' + language + '.js');
      };
      const requireLangPack = (name, languages) => {
        if (AddOnManager.languageLoad !== false) {
          if (isLoaded(name)) {
            loadLanguagePack(name, languages);
          } else {
            waitFor(name, 'loaded').then(() => loadLanguagePack(name, languages));
          }
        }
      };
      const add = (id, addOn) => {
        items.push(addOn);
        lookup[id] = { instance: addOn };
        runListeners(id, 'added');
        return addOn;
      };
      const remove = name => {
        delete urls[name];
        delete lookup[name];
      };
      const createUrl = (baseUrl, dep) => {
        if (isString(dep)) {
          return isString(baseUrl) ? {
            prefix: '',
            resource: dep,
            suffix: ''
          } : {
            prefix: baseUrl.prefix,
            resource: dep,
            suffix: baseUrl.suffix
          };
        } else {
          return dep;
        }
      };
      const load = (name, addOnUrl) => {
        if (urls[name]) {
          return Promise.resolve();
        }
        let urlString = isString(addOnUrl) ? addOnUrl : addOnUrl.prefix + addOnUrl.resource + addOnUrl.suffix;
        if (urlString.indexOf('/') !== 0 && urlString.indexOf('://') === -1) {
          urlString = AddOnManager.baseURL + '/' + urlString;
        }
        urls[name] = urlString.substring(0, urlString.lastIndexOf('/'));
        const done = () => {
          runListeners(name, 'loaded');
          return Promise.resolve();
        };
        if (lookup[name]) {
          return done();
        } else {
          return ScriptLoader.ScriptLoader.add(urlString).then(done);
        }
      };
      const waitFor = (name, state = 'added') => {
        if (state === 'added' && isAdded(name)) {
          return Promise.resolve();
        } else if (state === 'loaded' && isLoaded(name)) {
          return Promise.resolve();
        } else {
          return new Promise(resolve => {
            _listeners.push({
              name,
              state,
              resolve
            });
          });
        }
      };
      return {
        items,
        urls,
        lookup,
        get,
        requireLangPack,
        add,
        remove,
        createUrl,
        load,
        waitFor
      };
    };
    AddOnManager.languageLoad = true;
    AddOnManager.baseURL = '';
    AddOnManager.PluginManager = AddOnManager();
    AddOnManager.ThemeManager = AddOnManager();
    AddOnManager.ModelManager = AddOnManager();

    const singleton = doRevoke => {
      const subject = Cell(Optional.none());
      const revoke = () => subject.get().each(doRevoke);
      const clear = () => {
        revoke();
        subject.set(Optional.none());
      };
      const isSet = () => subject.get().isSome();
      const get = () => subject.get();
      const set = s => {
        revoke();
        subject.set(Optional.some(s));
      };
      return {
        clear,
        isSet,
        get,
        set
      };
    };
    const repeatable = delay => {
      const intervalId = Cell(Optional.none());
      const revoke = () => intervalId.get().each(id => clearInterval(id));
      const clear = () => {
        revoke();
        intervalId.set(Optional.none());
      };
      const isSet = () => intervalId.get().isSome();
      const get = () => intervalId.get();
      const set = functionToRepeat => {
        revoke();
        intervalId.set(Optional.some(setInterval(functionToRepeat, delay)));
      };
      return {
        clear,
        isSet,
        get,
        set
      };
    };
    const value$2 = () => {
      const subject = singleton(noop);
      const on = f => subject.get().each(f);
      return {
        ...subject,
        on
      };
    };

    const first$1 = (fn, rate) => {
      let timer = null;
      const cancel = () => {
        if (!isNull(timer)) {
          clearTimeout(timer);
          timer = null;
        }
      };
      const throttle = (...args) => {
        if (isNull(timer)) {
          timer = setTimeout(() => {
            timer = null;
            fn.apply(null, args);
          }, rate);
        }
      };
      return {
        cancel,
        throttle
      };
    };
    const last$1 = (fn, rate) => {
      let timer = null;
      const cancel = () => {
        if (!isNull(timer)) {
          clearTimeout(timer);
          timer = null;
        }
      };
      const throttle = (...args) => {
        cancel();
        timer = setTimeout(() => {
          timer = null;
          fn.apply(null, args);
        }, rate);
      };
      return {
        cancel,
        throttle
      };
    };

    const annotation = constant('mce-annotation');
    const dataAnnotation = constant('data-mce-annotation');
    const dataAnnotationId = constant('data-mce-annotation-uid');
    const dataAnnotationActive = constant('data-mce-annotation-active');
    const dataAnnotationClasses = constant('data-mce-annotation-classes');
    const dataAnnotationAttributes = constant('data-mce-annotation-attrs');

    const isRoot$1 = root => node => eq(node, root);
    const identify = (editor, annotationName) => {
      const rng = editor.selection.getRng();
      const start = SugarElement.fromDom(rng.startContainer);
      const root = SugarElement.fromDom(editor.getBody());
      const selector = annotationName.fold(() => '.' + annotation(), an => `[${ dataAnnotation() }="${ an }"]`);
      const newStart = child$1(start, rng.startOffset).getOr(start);
      const closest = closest$3(newStart, selector, isRoot$1(root));
      return closest.bind(c => getOpt(c, `${ dataAnnotationId() }`).bind(uid => getOpt(c, `${ dataAnnotation() }`).map(name => {
        const elements = findMarkers(editor, uid);
        return {
          uid,
          name,
          elements
        };
      })));
    };
    const isAnnotation = elem => isElement$7(elem) && has(elem, annotation());
    const isBogusElement = (elem, root) => has$1(elem, 'data-mce-bogus') || ancestor$2(elem, '[data-mce-bogus="all"]', isRoot$1(root));
    const findMarkers = (editor, uid) => {
      const body = SugarElement.fromDom(editor.getBody());
      const descendants$1 = descendants(body, `[${ dataAnnotationId() }="${ uid }"]`);
      return filter$5(descendants$1, descendant => !isBogusElement(descendant, body));
    };
    const findAll = (editor, name) => {
      const body = SugarElement.fromDom(editor.getBody());
      const markers = descendants(body, `[${ dataAnnotation() }="${ name }"]`);
      const directory = {};
      each$e(markers, m => {
        if (!isBogusElement(m, body)) {
          const uid = get$9(m, dataAnnotationId());
          const nodesAlready = get$a(directory, uid).getOr([]);
          directory[uid] = nodesAlready.concat([m]);
        }
      });
      return directory;
    };

    const setup$x = (editor, registry) => {
      const changeCallbacks = Cell({});
      const initData = () => ({
        listeners: [],
        previous: value$2()
      });
      const withCallbacks = (name, f) => {
        updateCallbacks(name, data => {
          f(data);
          return data;
        });
      };
      const updateCallbacks = (name, f) => {
        const callbackMap = changeCallbacks.get();
        const data = get$a(callbackMap, name).getOrThunk(initData);
        const outputData = f(data);
        callbackMap[name] = outputData;
        changeCallbacks.set(callbackMap);
      };
      const fireCallbacks = (name, uid, elements) => {
        withCallbacks(name, data => {
          each$e(data.listeners, f => f(true, name, {
            uid,
            nodes: map$3(elements, elem => elem.dom)
          }));
        });
      };
      const fireNoAnnotation = name => {
        withCallbacks(name, data => {
          each$e(data.listeners, f => f(false, name));
        });
      };
      const toggleActiveAttr = (uid, state) => {
        each$e(findMarkers(editor, uid), elem => {
          if (state) {
            set$3(elem, dataAnnotationActive(), 'true');
          } else {
            remove$b(elem, dataAnnotationActive());
          }
        });
      };
      const onNodeChange = last$1(() => {
        const annotations = sort(registry.getNames());
        each$e(annotations, name => {
          updateCallbacks(name, data => {
            const prev = data.previous.get();
            identify(editor, Optional.some(name)).fold(() => {
              prev.each(uid => {
                fireNoAnnotation(name);
                data.previous.clear();
                toggleActiveAttr(uid, false);
              });
            }, ({uid, name, elements}) => {
              if (!is$2(prev, uid)) {
                prev.each(uid => toggleActiveAttr(uid, false));
                fireCallbacks(name, uid, elements);
                data.previous.set(uid);
                toggleActiveAttr(uid, true);
              }
            });
            return {
              previous: data.previous,
              listeners: data.listeners
            };
          });
        });
      }, 30);
      editor.on('remove', () => {
        onNodeChange.cancel();
      });
      editor.on('NodeChange', () => {
        onNodeChange.throttle();
      });
      const addListener = (name, f) => {
        updateCallbacks(name, data => ({
          previous: data.previous,
          listeners: data.listeners.concat([f])
        }));
      };
      return { addListener };
    };

    const setup$w = (editor, registry) => {
      const dataAnnotation$1 = dataAnnotation();
      const identifyParserNode = node => Optional.from(node.attr(dataAnnotation$1)).bind(registry.lookup);
      const removeDirectAnnotation = node => {
        var _a, _b;
        node.attr(dataAnnotationId(), null);
        node.attr(dataAnnotation(), null);
        node.attr(dataAnnotationActive(), null);
        const customAttrNames = Optional.from(node.attr(dataAnnotationAttributes())).map(names => names.split(',')).getOr([]);
        const customClasses = Optional.from(node.attr(dataAnnotationClasses())).map(names => names.split(',')).getOr([]);
        each$e(customAttrNames, name => node.attr(name, null));
        const classList = (_b = (_a = node.attr('class')) === null || _a === void 0 ? void 0 : _a.split(' ')) !== null && _b !== void 0 ? _b : [];
        const newClassList = difference(classList, [annotation()].concat(customClasses));
        node.attr('class', newClassList.length > 0 ? newClassList.join(' ') : null);
        node.attr(dataAnnotationClasses(), null);
        node.attr(dataAnnotationAttributes(), null);
      };
      editor.serializer.addTempAttr(dataAnnotationActive());
      editor.serializer.addAttributeFilter(dataAnnotation$1, nodes => {
        for (const node of nodes) {
          identifyParserNode(node).each(settings => {
            if (settings.persistent === false) {
              if (node.name === 'span') {
                node.unwrap();
              } else {
                removeDirectAnnotation(node);
              }
            }
          });
        }
      });
    };

    const create$c = () => {
      const annotations = {};
      const register = (name, settings) => {
        annotations[name] = {
          name,
          settings
        };
      };
      const lookup = name => get$a(annotations, name).map(a => a.settings);
      const getNames = () => keys(annotations);
      return {
        register,
        lookup,
        getNames
      };
    };

    let unique = 0;
    const generate$1 = prefix => {
      const date = new Date();
      const time = date.getTime();
      const random = Math.floor(Math.random() * 1000000000);
      unique++;
      return prefix + '_' + random + unique + String(time);
    };

    const add = (element, classes) => {
      each$e(classes, x => {
        add$2(element, x);
      });
    };
    const remove$5 = (element, classes) => {
      each$e(classes, x => {
        remove$8(element, x);
      });
    };

    const clone$2 = (original, isDeep) => SugarElement.fromDom(original.dom.cloneNode(isDeep));
    const shallow$1 = original => clone$2(original, false);
    const deep$1 = original => clone$2(original, true);
    const shallowAs = (original, tag) => {
      const nu = SugarElement.fromTag(tag);
      const attributes = clone$4(original);
      setAll$1(nu, attributes);
      return nu;
    };
    const mutate = (original, tag) => {
      const nu = shallowAs(original, tag);
      after$4(original, nu);
      const children = children$1(original);
      append(nu, children);
      remove$6(original);
      return nu;
    };

    const TextWalker = (startNode, rootNode, isBoundary = never) => {
      const walker = new DomTreeWalker(startNode, rootNode);
      const walk = direction => {
        let next;
        do {
          next = walker[direction]();
        } while (next && !isText$a(next) && !isBoundary(next));
        return Optional.from(next).filter(isText$a);
      };
      return {
        current: () => Optional.from(walker.current()).filter(isText$a),
        next: () => walk('next'),
        prev: () => walk('prev'),
        prev2: () => walk('prev2')
      };
    };

    const TextSeeker = (dom, isBoundary) => {
      const isBlockBoundary = isBoundary ? isBoundary : node => dom.isBlock(node) || isBr$6(node) || isContentEditableFalse$b(node);
      const walk = (node, offset, walker, process) => {
        if (isText$a(node)) {
          const newOffset = process(node, offset, node.data);
          if (newOffset !== -1) {
            return Optional.some({
              container: node,
              offset: newOffset
            });
          }
        }
        return walker().bind(next => walk(next.container, next.offset, walker, process));
      };
      const backwards = (node, offset, process, root) => {
        const walker = TextWalker(node, root !== null && root !== void 0 ? root : dom.getRoot(), isBlockBoundary);
        return walk(node, offset, () => walker.prev().map(prev => ({
          container: prev,
          offset: prev.length
        })), process).getOrNull();
      };
      const forwards = (node, offset, process, root) => {
        const walker = TextWalker(node, root !== null && root !== void 0 ? root : dom.getRoot(), isBlockBoundary);
        return walk(node, offset, () => walker.next().map(next => ({
          container: next,
          offset: 0
        })), process).getOrNull();
      };
      return {
        backwards,
        forwards
      };
    };

    const round$2 = Math.round;
    const clone$1 = rect => {
      if (!rect) {
        return {
          left: 0,
          top: 0,
          bottom: 0,
          right: 0,
          width: 0,
          height: 0
        };
      }
      return {
        left: round$2(rect.left),
        top: round$2(rect.top),
        bottom: round$2(rect.bottom),
        right: round$2(rect.right),
        width: round$2(rect.width),
        height: round$2(rect.height)
      };
    };
    const collapse = (rect, toStart) => {
      rect = clone$1(rect);
      if (toStart) {
        rect.right = rect.left;
      } else {
        rect.left = rect.left + rect.width;
        rect.right = rect.left;
      }
      rect.width = 0;
      return rect;
    };
    const isEqual = (rect1, rect2) => rect1.left === rect2.left && rect1.top === rect2.top && rect1.bottom === rect2.bottom && rect1.right === rect2.right;
    const isValidOverflow = (overflowY, rect1, rect2) => overflowY >= 0 && overflowY <= Math.min(rect1.height, rect2.height) / 2;
    const isAbove$1 = (rect1, rect2) => {
      const halfHeight = Math.min(rect2.height / 2, rect1.height / 2);
      if (rect1.bottom - halfHeight < rect2.top) {
        return true;
      }
      if (rect1.top > rect2.bottom) {
        return false;
      }
      return isValidOverflow(rect2.top - rect1.bottom, rect1, rect2);
    };
    const isBelow$1 = (rect1, rect2) => {
      if (rect1.top > rect2.bottom) {
        return true;
      }
      if (rect1.bottom < rect2.top) {
        return false;
      }
      return isValidOverflow(rect2.bottom - rect1.top, rect1, rect2);
    };
    const containsXY = (rect, clientX, clientY) => clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;
    const boundingClientRectFromRects = rects => {
      return foldl(rects, (acc, rect) => {
        return acc.fold(() => Optional.some(rect), prevRect => {
          const left = Math.min(rect.left, prevRect.left);
          const top = Math.min(rect.top, prevRect.top);
          const right = Math.max(rect.right, prevRect.right);
          const bottom = Math.max(rect.bottom, prevRect.bottom);
          return Optional.some({
            top,
            right,
            bottom,
            left,
            width: right - left,
            height: bottom - top
          });
        });
      }, Optional.none());
    };
    const distanceToRectEdgeFromXY = (rect, x, y) => {
      const cx = Math.max(Math.min(x, rect.left + rect.width), rect.left);
      const cy = Math.max(Math.min(y, rect.top + rect.height), rect.top);
      return Math.sqrt((x - cx) * (x - cx) + (y - cy) * (y - cy));
    };
    const overlapY = (r1, r2) => Math.max(0, Math.min(r1.bottom, r2.bottom) - Math.max(r1.top, r2.top));

    const clamp$2 = (value, min, max) => Math.min(Math.max(value, min), max);

    const getSelectedNode = range => {
      const startContainer = range.startContainer, startOffset = range.startOffset;
      if (startContainer === range.endContainer && startContainer.hasChildNodes() && range.endOffset === startOffset + 1) {
        return startContainer.childNodes[startOffset];
      }
      return null;
    };
    const getNode$1 = (container, offset) => {
      if (isElement$6(container) && container.hasChildNodes()) {
        const childNodes = container.childNodes;
        const safeOffset = clamp$2(offset, 0, childNodes.length - 1);
        return childNodes[safeOffset];
      } else {
        return container;
      }
    };
    const getNodeUnsafe = (container, offset) => {
      if (offset < 0 && isElement$6(container) && container.hasChildNodes()) {
        return undefined;
      } else {
        return getNode$1(container, offset);
      }
    };

    const extendingChars = new RegExp('[\u0300-\u036f\u0483-\u0487\u0488-\u0489\u0591-\u05bd\u05bf\u05c1-\u05c2\u05c4-\u05c5\u05c7\u0610-\u061a' + '\u064b-\u065f\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7-\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0' + '\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08e3-\u0902\u093a\u093c' + '\u0941-\u0948\u094d\u0951-\u0957\u0962-\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2-\u09e3' + '\u0a01-\u0a02\u0a3c\u0a41-\u0a42\u0a47-\u0a48\u0a4b-\u0a4d\u0a51\u0a70-\u0a71\u0a75\u0a81-\u0a82\u0abc' + '\u0ac1-\u0ac5\u0ac7-\u0ac8\u0acd\u0ae2-\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57' + '\u0b62-\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c00\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55-\u0c56' + '\u0c62-\u0c63\u0c81\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc-\u0ccd\u0cd5-\u0cd6\u0ce2-\u0ce3\u0d01\u0d3e\u0d41-\u0d44' + '\u0d4d\u0d57\u0d62-\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9' + '\u0ebb-\u0ebc\u0ec8-\u0ecd\u0f18-\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86-\u0f87\u0f8d-\u0f97' + '\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039-\u103a\u103d-\u103e\u1058-\u1059\u105e-\u1060\u1071-\u1074' + '\u1082\u1085-\u1086\u108d\u109d\u135d-\u135f\u1712-\u1714\u1732-\u1734\u1752-\u1753\u1772-\u1773\u17b4-\u17b5' + '\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927-\u1928\u1932\u1939-\u193b\u1a17-\u1a18' + '\u1a1b\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1ab0-\u1abd\u1ABE\u1b00-\u1b03\u1b34' + '\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80-\u1b81\u1ba2-\u1ba5\u1ba8-\u1ba9\u1bab-\u1bad\u1be6\u1be8-\u1be9' + '\u1bed\u1bef-\u1bf1\u1c2c-\u1c33\u1c36-\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1cf4\u1cf8-\u1cf9' + '\u1dc0-\u1df5\u1dfc-\u1dff\u200c-\u200d\u20d0-\u20dc\u20DD-\u20E0\u20e1\u20E2-\u20E4\u20e5-\u20f0\u2cef-\u2cf1' + '\u2d7f\u2de0-\u2dff\u302a-\u302d\u302e-\u302f\u3099-\u309a\ua66f\uA670-\uA672\ua674-\ua67d\ua69e-\ua69f\ua6f0-\ua6f1' + '\ua802\ua806\ua80b\ua825-\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc' + '\ua9e5\uaa29-\uaa2e\uaa31-\uaa32\uaa35-\uaa36\uaa43\uaa4c\uaa7c\uaab0\uaab2-\uaab4\uaab7-\uaab8\uaabe-\uaabf\uaac1' + '\uaaec-\uaaed\uaaf6\uabe5\uabe8\uabed\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\uff9e-\uff9f]');
    const isExtendingChar = ch => isString(ch) && ch.charCodeAt(0) >= 768 && extendingChars.test(ch);

    const or = (...args) => {
      return x => {
        for (let i = 0; i < args.length; i++) {
          if (args[i](x)) {
            return true;
          }
        }
        return false;
      };
    };
    const and = (...args) => {
      return x => {
        for (let i = 0; i < args.length; i++) {
          if (!args[i](x)) {
            return false;
          }
        }
        return true;
      };
    };

    const isElement$4 = isElement$6;
    const isCaretCandidate$2 = isCaretCandidate$3;
    const isBlock$1 = matchStyleValues('display', 'block table');
    const isFloated = matchStyleValues('float', 'left right');
    const isValidElementCaretCandidate = and(isElement$4, isCaretCandidate$2, not(isFloated));
    const isNotPre = not(matchStyleValues('white-space', 'pre pre-line pre-wrap'));
    const isText$7 = isText$a;
    const isBr$3 = isBr$6;
    const nodeIndex$1 = DOMUtils.nodeIndex;
    const resolveIndex$1 = getNodeUnsafe;
    const createRange$1 = doc => doc ? doc.createRange() : DOMUtils.DOM.createRng();
    const isWhiteSpace$1 = chr => isString(chr) && /[\r\n\t ]/.test(chr);
    const isRange = rng => !!rng.setStart && !!rng.setEnd;
    const isHiddenWhiteSpaceRange = range => {
      const container = range.startContainer;
      const offset = range.startOffset;
      if (isWhiteSpace$1(range.toString()) && isNotPre(container.parentNode) && isText$a(container)) {
        const text = container.data;
        if (isWhiteSpace$1(text[offset - 1]) || isWhiteSpace$1(text[offset + 1])) {
          return true;
        }
      }
      return false;
    };
    const getBrClientRect = brNode => {
      const doc = brNode.ownerDocument;
      const rng = createRange$1(doc);
      const nbsp$1 = doc.createTextNode(nbsp);
      const parentNode = brNode.parentNode;
      parentNode.insertBefore(nbsp$1, brNode);
      rng.setStart(nbsp$1, 0);
      rng.setEnd(nbsp$1, 1);
      const clientRect = clone$1(rng.getBoundingClientRect());
      parentNode.removeChild(nbsp$1);
      return clientRect;
    };
    const getBoundingClientRectWebKitText = rng => {
      const sc = rng.startContainer;
      const ec = rng.endContainer;
      const so = rng.startOffset;
      const eo = rng.endOffset;
      if (sc === ec && isText$a(ec) && so === 0 && eo === 1) {
        const newRng = rng.cloneRange();
        newRng.setEndAfter(ec);
        return getBoundingClientRect$1(newRng);
      } else {
        return null;
      }
    };
    const isZeroRect = r => r.left === 0 && r.right === 0 && r.top === 0 && r.bottom === 0;
    const getBoundingClientRect$1 = item => {
      var _a;
      let clientRect;
      const clientRects = item.getClientRects();
      if (clientRects.length > 0) {
        clientRect = clone$1(clientRects[0]);
      } else {
        clientRect = clone$1(item.getBoundingClientRect());
      }
      if (!isRange(item) && isBr$3(item) && isZeroRect(clientRect)) {
        return getBrClientRect(item);
      }
      if (isZeroRect(clientRect) && isRange(item)) {
        return (_a = getBoundingClientRectWebKitText(item)) !== null && _a !== void 0 ? _a : clientRect;
      }
      return clientRect;
    };
    const collapseAndInflateWidth = (clientRect, toStart) => {
      const newClientRect = collapse(clientRect, toStart);
      newClientRect.width = 1;
      newClientRect.right = newClientRect.left + 1;
      return newClientRect;
    };
    const getCaretPositionClientRects = caretPosition => {
      const clientRects = [];
      const addUniqueAndValidRect = clientRect => {
        if (clientRect.height === 0) {
          return;
        }
        if (clientRects.length > 0) {
          if (isEqual(clientRect, clientRects[clientRects.length - 1])) {
            return;
          }
        }
        clientRects.push(clientRect);
      };
      const addCharacterOffset = (container, offset) => {
        const range = createRange$1(container.ownerDocument);
        if (offset < container.data.length) {
          if (isExtendingChar(container.data[offset])) {
            return;
          }
          if (isExtendingChar(container.data[offset - 1])) {
            range.setStart(container, offset);
            range.setEnd(container, offset + 1);
            if (!isHiddenWhiteSpaceRange(range)) {
              addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), false));
              return;
            }
          }
        }
        if (offset > 0) {
          range.setStart(container, offset - 1);
          range.setEnd(container, offset);
          if (!isHiddenWhiteSpaceRange(range)) {
            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), false));
          }
        }
        if (offset < container.data.length) {
          range.setStart(container, offset);
          range.setEnd(container, offset + 1);
          if (!isHiddenWhiteSpaceRange(range)) {
            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), true));
          }
        }
      };
      const container = caretPosition.container();
      const offset = caretPosition.offset();
      if (isText$7(container)) {
        addCharacterOffset(container, offset);
        return clientRects;
      }
      if (isElement$4(container)) {
        if (caretPosition.isAtEnd()) {
          const node = resolveIndex$1(container, offset);
          if (isText$7(node)) {
            addCharacterOffset(node, node.data.length);
          }
          if (isValidElementCaretCandidate(node) && !isBr$3(node)) {
            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), false));
          }
        } else {
          const node = resolveIndex$1(container, offset);
          if (isText$7(node)) {
            addCharacterOffset(node, 0);
          }
          if (isValidElementCaretCandidate(node) && caretPosition.isAtEnd()) {
            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), false));
            return clientRects;
          }
          const beforeNode = resolveIndex$1(caretPosition.container(), caretPosition.offset() - 1);
          if (isValidElementCaretCandidate(beforeNode) && !isBr$3(beforeNode)) {
            if (isBlock$1(beforeNode) || isBlock$1(node) || !isValidElementCaretCandidate(node)) {
              addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(beforeNode), false));
            }
          }
          if (isValidElementCaretCandidate(node)) {
            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), true));
          }
        }
      }
      return clientRects;
    };
    const CaretPosition = (container, offset, clientRects) => {
      const isAtStart = () => {
        if (isText$7(container)) {
          return offset === 0;
        }
        return offset === 0;
      };
      const isAtEnd = () => {
        if (isText$7(container)) {
          return offset >= container.data.length;
        }
        return offset >= container.childNodes.length;
      };
      const toRange = () => {
        const range = createRange$1(container.ownerDocument);
        range.setStart(container, offset);
        range.setEnd(container, offset);
        return range;
      };
      const getClientRects = () => {
        if (!clientRects) {
          clientRects = getCaretPositionClientRects(CaretPosition(container, offset));
        }
        return clientRects;
      };
      const isVisible = () => getClientRects().length > 0;
      const isEqual = caretPosition => caretPosition && container === caretPosition.container() && offset === caretPosition.offset();
      const getNode = before => resolveIndex$1(container, before ? offset - 1 : offset);
      return {
        container: constant(container),
        offset: constant(offset),
        toRange,
        getClientRects,
        isVisible,
        isAtStart,
        isAtEnd,
        isEqual,
        getNode
      };
    };
    CaretPosition.fromRangeStart = range => CaretPosition(range.startContainer, range.startOffset);
    CaretPosition.fromRangeEnd = range => CaretPosition(range.endContainer, range.endOffset);
    CaretPosition.after = node => CaretPosition(node.parentNode, nodeIndex$1(node) + 1);
    CaretPosition.before = node => CaretPosition(node.parentNode, nodeIndex$1(node));
    CaretPosition.isAbove = (pos1, pos2) => lift2(head(pos2.getClientRects()), last$3(pos1.getClientRects()), isAbove$1).getOr(false);
    CaretPosition.isBelow = (pos1, pos2) => lift2(last$3(pos2.getClientRects()), head(pos1.getClientRects()), isBelow$1).getOr(false);
    CaretPosition.isAtStart = pos => pos ? pos.isAtStart() : false;
    CaretPosition.isAtEnd = pos => pos ? pos.isAtEnd() : false;
    CaretPosition.isTextPosition = pos => pos ? isText$a(pos.container()) : false;
    CaretPosition.isElementPosition = pos => !CaretPosition.isTextPosition(pos);

    const trimEmptyTextNode$1 = (dom, node) => {
      if (isText$a(node) && node.data.length === 0) {
        dom.remove(node);
      }
    };
    const insertNode = (dom, rng, node) => {
      rng.insertNode(node);
      trimEmptyTextNode$1(dom, node.previousSibling);
      trimEmptyTextNode$1(dom, node.nextSibling);
    };
    const insertFragment = (dom, rng, frag) => {
      const firstChild = Optional.from(frag.firstChild);
      const lastChild = Optional.from(frag.lastChild);
      rng.insertNode(frag);
      firstChild.each(child => trimEmptyTextNode$1(dom, child.previousSibling));
      lastChild.each(child => trimEmptyTextNode$1(dom, child.nextSibling));
    };
    const rangeInsertNode = (dom, rng, node) => {
      if (isDocumentFragment(node)) {
        insertFragment(dom, rng, node);
      } else {
        insertNode(dom, rng, node);
      }
    };

    const isText$6 = isText$a;
    const isBogus = isBogus$2;
    const nodeIndex = DOMUtils.nodeIndex;
    const normalizedParent = node => {
      const parentNode = node.parentNode;
      if (isBogus(parentNode)) {
        return normalizedParent(parentNode);
      }
      return parentNode;
    };
    const getChildNodes = node => {
      if (!node) {
        return [];
      }
      return reduce(node.childNodes, (result, node) => {
        if (isBogus(node) && node.nodeName !== 'BR') {
          result = result.concat(getChildNodes(node));
        } else {
          result.push(node);
        }
        return result;
      }, []);
    };
    const normalizedTextOffset = (node, offset) => {
      let tempNode = node;
      while (tempNode = tempNode.previousSibling) {
        if (!isText$6(tempNode)) {
          break;
        }
        offset += tempNode.data.length;
      }
      return offset;
    };
    const equal = a => b => a === b;
    const normalizedNodeIndex = node => {
      let nodes, index;
      nodes = getChildNodes(normalizedParent(node));
      index = findIndex$1(nodes, equal(node), node);
      nodes = nodes.slice(0, index + 1);
      const numTextFragments = reduce(nodes, (result, node, i) => {
        if (isText$6(node) && isText$6(nodes[i - 1])) {
          result++;
        }
        return result;
      }, 0);
      nodes = filter$3(nodes, matchNodeNames([node.nodeName]));
      index = findIndex$1(nodes, equal(node), node);
      return index - numTextFragments;
    };
    const createPathItem = node => {
      const name = isText$6(node) ? 'text()' : node.nodeName.toLowerCase();
      return name + '[' + normalizedNodeIndex(node) + ']';
    };
    const parentsUntil$1 = (root, node, predicate) => {
      const parents = [];
      for (let tempNode = node.parentNode; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {
        if (predicate && predicate(tempNode)) {
          break;
        }
        parents.push(tempNode);
      }
      return parents;
    };
    const create$b = (root, caretPosition) => {
      let path = [];
      let container = caretPosition.container();
      let offset = caretPosition.offset();
      let outputOffset;
      if (isText$6(container)) {
        outputOffset = normalizedTextOffset(container, offset);
      } else {
        const childNodes = container.childNodes;
        if (offset >= childNodes.length) {
          outputOffset = 'after';
          offset = childNodes.length - 1;
        } else {
          outputOffset = 'before';
        }
        container = childNodes[offset];
      }
      path.push(createPathItem(container));
      let parents = parentsUntil$1(root, container);
      parents = filter$3(parents, not(isBogus$2));
      path = path.concat(map$1(parents, node => {
        return createPathItem(node);
      }));
      return path.reverse().join('/') + ',' + outputOffset;
    };
    const resolvePathItem = (node, name, index) => {
      let nodes = getChildNodes(node);
      nodes = filter$3(nodes, (node, index) => {
        return !isText$6(node) || !isText$6(nodes[index - 1]);
      });
      nodes = filter$3(nodes, matchNodeNames([name]));
      return nodes[index];
    };
    const findTextPosition = (container, offset) => {
      let node = container;
      let targetOffset = 0;
      while (isText$6(node)) {
        const dataLen = node.data.length;
        if (offset >= targetOffset && offset <= targetOffset + dataLen) {
          container = node;
          offset = offset - targetOffset;
          break;
        }
        if (!isText$6(node.nextSibling)) {
          container = node;
          offset = dataLen;
          break;
        }
        targetOffset += dataLen;
        node = node.nextSibling;
      }
      if (isText$6(container) && offset > container.data.length) {
        offset = container.data.length;
      }
      return CaretPosition(container, offset);
    };
    const resolve$1 = (root, path) => {
      if (!path) {
        return null;
      }
      const parts = path.split(',');
      const paths = parts[0].split('/');
      const offset = parts.length > 1 ? parts[1] : 'before';
      const container = reduce(paths, (result, value) => {
        const match = /([\w\-\(\)]+)\[([0-9]+)\]/.exec(value);
        if (!match) {
          return null;
        }
        if (match[1] === 'text()') {
          match[1] = '#text';
        }
        return resolvePathItem(result, match[1], parseInt(match[2], 10));
      }, root);
      if (!container) {
        return null;
      }
      if (!isText$6(container) && container.parentNode) {
        let nodeOffset;
        if (offset === 'after') {
          nodeOffset = nodeIndex(container) + 1;
        } else {
          nodeOffset = nodeIndex(container);
        }
        return CaretPosition(container.parentNode, nodeOffset);
      }
      return findTextPosition(container, parseInt(offset, 10));
    };

    const isContentEditableFalse$9 = isContentEditableFalse$b;
    const getNormalizedTextOffset$1 = (trim, container, offset) => {
      let trimmedOffset = trim(container.data.slice(0, offset)).length;
      for (let node = container.previousSibling; node && isText$a(node); node = node.previousSibling) {
        trimmedOffset += trim(node.data).length;
      }
      return trimmedOffset;
    };
    const getPoint = (dom, trim, normalized, rng, start) => {
      const container = start ? rng.startContainer : rng.endContainer;
      let offset = start ? rng.startOffset : rng.endOffset;
      const point = [];
      const root = dom.getRoot();
      if (isText$a(container)) {
        point.push(normalized ? getNormalizedTextOffset$1(trim, container, offset) : offset);
      } else {
        let after = 0;
        const childNodes = container.childNodes;
        if (offset >= childNodes.length && childNodes.length) {
          after = 1;
          offset = Math.max(0, childNodes.length - 1);
        }
        point.push(dom.nodeIndex(childNodes[offset], normalized) + after);
      }
      for (let node = container; node && node !== root; node = node.parentNode) {
        point.push(dom.nodeIndex(node, normalized));
      }
      return point;
    };
    const getLocation = (trim, selection, normalized, rng) => {
      const dom = selection.dom;
      const start = getPoint(dom, trim, normalized, rng, true);
      const forward = selection.isForward();
      const fakeCaret = isRangeInCaretContainerBlock(rng) ? { isFakeCaret: true } : {};
      if (!selection.isCollapsed()) {
        const end = getPoint(dom, trim, normalized, rng, false);
        return {
          start,
          end,
          forward,
          ...fakeCaret
        };
      } else {
        return {
          start,
          forward,
          ...fakeCaret
        };
      }
    };
    const findIndex = (dom, name, element) => {
      let count = 0;
      Tools.each(dom.select(name), node => {
        if (node.getAttribute('data-mce-bogus') === 'all') {
          return;
        } else if (node === element) {
          return false;
        } else {
          count++;
          return;
        }
      });
      return count;
    };
    const moveEndPoint$1 = (rng, start) => {
      let container = start ? rng.startContainer : rng.endContainer;
      let offset = start ? rng.startOffset : rng.endOffset;
      if (isElement$6(container) && container.nodeName === 'TR') {
        const childNodes = container.childNodes;
        container = childNodes[Math.min(start ? offset : offset - 1, childNodes.length - 1)];
        if (container) {
          offset = start ? 0 : container.childNodes.length;
          if (start) {
            rng.setStart(container, offset);
          } else {
            rng.setEnd(container, offset);
          }
        }
      }
    };
    const normalizeTableCellSelection = rng => {
      moveEndPoint$1(rng, true);
      moveEndPoint$1(rng, false);
      return rng;
    };
    const findSibling = (node, offset) => {
      if (isElement$6(node)) {
        node = getNode$1(node, offset);
        if (isContentEditableFalse$9(node)) {
          return node;
        }
      }
      if (isCaretContainer$2(node)) {
        if (isText$a(node) && isCaretContainerBlock$1(node)) {
          node = node.parentNode;
        }
        let sibling = node.previousSibling;
        if (isContentEditableFalse$9(sibling)) {
          return sibling;
        }
        sibling = node.nextSibling;
        if (isContentEditableFalse$9(sibling)) {
          return sibling;
        }
      }
      return undefined;
    };
    const findAdjacentContentEditableFalseElm = rng => {
      return findSibling(rng.startContainer, rng.startOffset) || findSibling(rng.endContainer, rng.endOffset);
    };
    const getOffsetBookmark = (trim, normalized, selection) => {
      const element = selection.getNode();
      const rng = selection.getRng();
      if (element.nodeName === 'IMG' || isContentEditableFalse$9(element)) {
        const name = element.nodeName;
        return {
          name,
          index: findIndex(selection.dom, name, element)
        };
      }
      const sibling = findAdjacentContentEditableFalseElm(rng);
      if (sibling) {
        const name = sibling.tagName;
        return {
          name,
          index: findIndex(selection.dom, name, sibling)
        };
      }
      return getLocation(trim, selection, normalized, rng);
    };
    const getCaretBookmark = selection => {
      const rng = selection.getRng();
      return {
        start: create$b(selection.dom.getRoot(), CaretPosition.fromRangeStart(rng)),
        end: create$b(selection.dom.getRoot(), CaretPosition.fromRangeEnd(rng)),
        forward: selection.isForward()
      };
    };
    const getRangeBookmark = selection => {
      return {
        rng: selection.getRng(),
        forward: selection.isForward()
      };
    };
    const createBookmarkSpan = (dom, id, filled) => {
      const args = {
        'data-mce-type': 'bookmark',
        id,
        'style': 'overflow:hidden;line-height:0px'
      };
      return filled ? dom.create('span', args, '&#xFEFF;') : dom.create('span', args);
    };
    const getPersistentBookmark = (selection, filled) => {
      const dom = selection.dom;
      let rng = selection.getRng();
      const id = dom.uniqueId();
      const collapsed = selection.isCollapsed();
      const element = selection.getNode();
      const name = element.nodeName;
      const forward = selection.isForward();
      if (name === 'IMG') {
        return {
          name,
          index: findIndex(dom, name, element)
        };
      }
      const rng2 = normalizeTableCellSelection(rng.cloneRange());
      if (!collapsed) {
        rng2.collapse(false);
        const endBookmarkNode = createBookmarkSpan(dom, id + '_end', filled);
        rangeInsertNode(dom, rng2, endBookmarkNode);
      }
      rng = normalizeTableCellSelection(rng);
      rng.collapse(true);
      const startBookmarkNode = createBookmarkSpan(dom, id + '_start', filled);
      rangeInsertNode(dom, rng, startBookmarkNode);
      selection.moveToBookmark({
        id,
        keep: true,
        forward
      });
      return {
        id,
        forward
      };
    };
    const getBookmark$2 = (selection, type, normalized = false) => {
      if (type === 2) {
        return getOffsetBookmark(trim$1, normalized, selection);
      } else if (type === 3) {
        return getCaretBookmark(selection);
      } else if (type) {
        return getRangeBookmark(selection);
      } else {
        return getPersistentBookmark(selection, false);
      }
    };
    const getUndoBookmark = curry(getOffsetBookmark, identity, true);

    const value$1 = value => {
      const applyHelper = fn => fn(value);
      const constHelper = constant(value);
      const outputHelper = () => output;
      const output = {
        tag: true,
        inner: value,
        fold: (_onError, onValue) => onValue(value),
        isValue: always,
        isError: never,
        map: mapper => Result.value(mapper(value)),
        mapError: outputHelper,
        bind: applyHelper,
        exists: applyHelper,
        forall: applyHelper,
        getOr: constHelper,
        or: outputHelper,
        getOrThunk: constHelper,
        orThunk: outputHelper,
        getOrDie: constHelper,
        each: fn => {
          fn(value);
        },
        toOptional: () => Optional.some(value)
      };
      return output;
    };
    const error = error => {
      const outputHelper = () => output;
      const output = {
        tag: false,
        inner: error,
        fold: (onError, _onValue) => onError(error),
        isValue: never,
        isError: always,
        map: outputHelper,
        mapError: mapper => Result.error(mapper(error)),
        bind: outputHelper,
        exists: never,
        forall: always,
        getOr: identity,
        or: identity,
        getOrThunk: apply$1,
        orThunk: apply$1,
        getOrDie: die(String(error)),
        each: noop,
        toOptional: Optional.none
      };
      return output;
    };
    const fromOption = (optional, err) => optional.fold(() => error(err), value$1);
    const Result = {
      value: value$1,
      error,
      fromOption
    };

    const generate = cases => {
      if (!isArray$1(cases)) {
        throw new Error('cases must be an array');
      }
      if (cases.length === 0) {
        throw new Error('there must be at least one case');
      }
      const constructors = [];
      const adt = {};
      each$e(cases, (acase, count) => {
        const keys$1 = keys(acase);
        if (keys$1.length !== 1) {
          throw new Error('one and only one name per case');
        }
        const key = keys$1[0];
        const value = acase[key];
        if (adt[key] !== undefined) {
          throw new Error('duplicate key detected:' + key);
        } else if (key === 'cata') {
          throw new Error('cannot have a case named cata (sorry)');
        } else if (!isArray$1(value)) {
          throw new Error('case arguments must be an array');
        }
        constructors.push(key);
        adt[key] = (...args) => {
          const argLength = args.length;
          if (argLength !== value.length) {
            throw new Error('Wrong number of arguments to case ' + key + '. Expected ' + value.length + ' (' + value + '), got ' + argLength);
          }
          const match = branches => {
            const branchKeys = keys(branches);
            if (constructors.length !== branchKeys.length) {
              throw new Error('Wrong number of arguments to match. Expected: ' + constructors.join(',') + '\nActual: ' + branchKeys.join(','));
            }
            const allReqd = forall(constructors, reqKey => {
              return contains$2(branchKeys, reqKey);
            });
            if (!allReqd) {
              throw new Error('Not all branches were specified when using match. Specified: ' + branchKeys.join(', ') + '\nRequired: ' + constructors.join(', '));
            }
            return branches[key].apply(null, args);
          };
          return {
            fold: (...foldArgs) => {
              if (foldArgs.length !== cases.length) {
                throw new Error('Wrong number of arguments to fold. Expected ' + cases.length + ', got ' + foldArgs.length);
              }
              const target = foldArgs[count];
              return target.apply(null, args);
            },
            match,
            log: label => {
              console.log(label, {
                constructors,
                constructor: key,
                params: args
              });
            }
          };
        };
      });
      return adt;
    };
    const Adt = { generate };

    Adt.generate([
      {
        bothErrors: [
          'error1',
          'error2'
        ]
      },
      {
        firstError: [
          'error1',
          'value2'
        ]
      },
      {
        secondError: [
          'value1',
          'error2'
        ]
      },
      {
        bothValues: [
          'value1',
          'value2'
        ]
      }
    ]);
    const partition$1 = results => {
      const errors = [];
      const values = [];
      each$e(results, result => {
        result.fold(err => {
          errors.push(err);
        }, value => {
          values.push(value);
        });
      });
      return {
        errors,
        values
      };
    };

    const isInlinePattern = pattern => pattern.type === 'inline-command' || pattern.type === 'inline-format';
    const isBlockPattern = pattern => pattern.type === 'block-command' || pattern.type === 'block-format';
    const normalizePattern = pattern => {
      const err = message => Result.error({
        message,
        pattern
      });
      const formatOrCmd = (name, onFormat, onCommand) => {
        if (pattern.format !== undefined) {
          let formats;
          if (isArray$1(pattern.format)) {
            if (!forall(pattern.format, isString)) {
              return err(name + ' pattern has non-string items in the `format` array');
            }
            formats = pattern.format;
          } else if (isString(pattern.format)) {
            formats = [pattern.format];
          } else {
            return err(name + ' pattern has non-string `format` parameter');
          }
          return Result.value(onFormat(formats));
        } else if (pattern.cmd !== undefined) {
          if (!isString(pattern.cmd)) {
            return err(name + ' pattern has non-string `cmd` parameter');
          }
          return Result.value(onCommand(pattern.cmd, pattern.value));
        } else {
          return err(name + ' pattern is missing both `format` and `cmd` parameters');
        }
      };
      if (!isObject(pattern)) {
        return err('Raw pattern is not an object');
      }
      if (!isString(pattern.start)) {
        return err('Raw pattern is missing `start` parameter');
      }
      if (pattern.end !== undefined) {
        if (!isString(pattern.end)) {
          return err('Inline pattern has non-string `end` parameter');
        }
        if (pattern.start.length === 0 && pattern.end.length === 0) {
          return err('Inline pattern has empty `start` and `end` parameters');
        }
        let start = pattern.start;
        let end = pattern.end;
        if (end.length === 0) {
          end = start;
          start = '';
        }
        return formatOrCmd('Inline', format => ({
          type: 'inline-format',
          start,
          end,
          format
        }), (cmd, value) => ({
          type: 'inline-command',
          start,
          end,
          cmd,
          value
        }));
      } else if (pattern.replacement !== undefined) {
        if (!isString(pattern.replacement)) {
          return err('Replacement pattern has non-string `replacement` parameter');
        }
        if (pattern.start.length === 0) {
          return err('Replacement pattern has empty `start` parameter');
        }
        return Result.value({
          type: 'inline-command',
          start: '',
          end: pattern.start,
          cmd: 'mceInsertContent',
          value: pattern.replacement
        });
      } else {
        if (pattern.start.length === 0) {
          return err('Block pattern has empty `start` parameter');
        }
        return formatOrCmd('Block', formats => ({
          type: 'block-format',
          start: pattern.start,
          format: formats[0]
        }), (command, commandValue) => ({
          type: 'block-command',
          start: pattern.start,
          cmd: command,
          value: commandValue
        }));
      }
    };
    const getBlockPatterns = patterns => filter$5(patterns, isBlockPattern);
    const getInlinePatterns = patterns => filter$5(patterns, isInlinePattern);
    const createPatternSet = (patterns, dynamicPatternsLookup) => ({
      inlinePatterns: getInlinePatterns(patterns),
      blockPatterns: getBlockPatterns(patterns),
      dynamicPatternsLookup
    });
    const fromRawPatterns = patterns => {
      const normalized = partition$1(map$3(patterns, normalizePattern));
      each$e(normalized.errors, err => console.error(err.message, err.pattern));
      return normalized.values;
    };
    const fromRawPatternsLookup = lookupFn => {
      return ctx => {
        const rawPatterns = lookupFn(ctx);
        return fromRawPatterns(rawPatterns);
      };
    };

    const deviceDetection$1 = detect$2().deviceType;
    const isTouch = deviceDetection$1.isTouch();
    const DOM$a = DOMUtils.DOM;
    const getHash = value => {
      const items = value.indexOf('=') > 0 ? value.split(/[;,](?![^=;,]*(?:[;,]|$))/) : value.split(',');
      return foldl(items, (output, item) => {
        const arr = item.split('=');
        const key = arr[0];
        const val = arr.length > 1 ? arr[1] : key;
        output[trim$3(key)] = trim$3(val);
        return output;
      }, {});
    };
    const isRegExp = x => is$4(x, RegExp);
    const option = name => editor => editor.options.get(name);
    const stringOrObjectProcessor = value => isString(value) || isObject(value);
    const bodyOptionProcessor = (editor, defaultValue = '') => value => {
      const valid = isString(value);
      if (valid) {
        if (value.indexOf('=') !== -1) {
          const bodyObj = getHash(value);
          return {
            value: get$a(bodyObj, editor.id).getOr(defaultValue),
            valid
          };
        } else {
          return {
            value,
            valid
          };
        }
      } else {
        return {
          valid: false,
          message: 'Must be a string.'
        };
      }
    };
    const register$7 = editor => {
      const registerOption = editor.options.register;
      registerOption('id', {
        processor: 'string',
        default: editor.id
      });
      registerOption('selector', { processor: 'string' });
      registerOption('target', { processor: 'object' });
      registerOption('suffix', { processor: 'string' });
      registerOption('cache_suffix', { processor: 'string' });
      registerOption('base_url', { processor: 'string' });
      registerOption('referrer_policy', {
        processor: 'string',
        default: ''
      });
      registerOption('language_load', {
        processor: 'boolean',
        default: true
      });
      registerOption('inline', {
        processor: 'boolean',
        default: false
      });
      registerOption('iframe_attrs', {
        processor: 'object',
        default: {}
      });
      registerOption('doctype', {
        processor: 'string',
        default: '<!DOCTYPE html>'
      });
      registerOption('document_base_url', {
        processor: 'string',
        default: editor.documentBaseUrl
      });
      registerOption('body_id', {
        processor: bodyOptionProcessor(editor, 'tinymce'),
        default: 'tinymce'
      });
      registerOption('body_class', {
        processor: bodyOptionProcessor(editor),
        default: ''
      });
      registerOption('content_security_policy', {
        processor: 'string',
        default: ''
      });
      registerOption('br_in_pre', {
        processor: 'boolean',
        default: true
      });
      registerOption('forced_root_block', {
        processor: value => {
          const valid = isString(value) && isNotEmpty(value);
          if (valid) {
            return {
              value,
              valid
            };
          } else {
            return {
              valid: false,
              message: 'Must be a non-empty string.'
            };
          }
        },
        default: 'p'
      });
      registerOption('forced_root_block_attrs', {
        processor: 'object',
        default: {}
      });
      registerOption('newline_behavior', {
        processor: value => {
          const valid = contains$2([
            'block',
            'linebreak',
            'invert',
            'default'
          ], value);
          return valid ? {
            value,
            valid
          } : {
            valid: false,
            message: 'Must be one of: block, linebreak, invert or default.'
          };
        },
        default: 'default'
      });
      registerOption('br_newline_selector', {
        processor: 'string',
        default: '.mce-toc h2,figcaption,caption'
      });
      registerOption('no_newline_selector', {
        processor: 'string',
        default: ''
      });
      registerOption('keep_styles', {
        processor: 'boolean',
        default: true
      });
      registerOption('end_container_on_empty_block', {
        processor: value => {
          if (isBoolean(value)) {
            return {
              valid: true,
              value
            };
          } else if (isString(value)) {
            return {
              valid: true,
              value
            };
          } else {
            return {
              valid: false,
              message: 'Must be boolean or a string'
            };
          }
        },
        default: 'blockquote'
      });
      registerOption('font_size_style_values', {
        processor: 'string',
        default: 'xx-small,x-small,small,medium,large,x-large,xx-large'
      });
      registerOption('font_size_legacy_values', {
        processor: 'string',
        default: 'xx-small,small,medium,large,x-large,xx-large,300%'
      });
      registerOption('font_size_classes', {
        processor: 'string',
        default: ''
      });
      registerOption('automatic_uploads', {
        processor: 'boolean',
        default: true
      });
      registerOption('images_reuse_filename', {
        processor: 'boolean',
        default: false
      });
      registerOption('images_replace_blob_uris', {
        processor: 'boolean',
        default: true
      });
      registerOption('icons', {
        processor: 'string',
        default: ''
      });
      registerOption('icons_url', {
        processor: 'string',
        default: ''
      });
      registerOption('images_upload_url', {
        processor: 'string',
        default: ''
      });
      registerOption('images_upload_base_path', {
        processor: 'string',
        default: ''
      });
      registerOption('images_upload_credentials', {
        processor: 'boolean',
        default: false
      });
      registerOption('images_upload_handler', { processor: 'function' });
      registerOption('language', {
        processor: 'string',
        default: 'en'
      });
      registerOption('language_url', {
        processor: 'string',
        default: ''
      });
      registerOption('entity_encoding', {
        processor: 'string',
        default: 'named'
      });
      registerOption('indent', {
        processor: 'boolean',
        default: true
      });
      registerOption('indent_before', {
        processor: 'string',
        default: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,' + 'tfoot,tbody,tr,section,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist'
      });
      registerOption('indent_after', {
        processor: 'string',
        default: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,' + 'tfoot,tbody,tr,section,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist'
      });
      registerOption('indent_use_margin', {
        processor: 'boolean',
        default: false
      });
      registerOption('indentation', {
        processor: 'string',
        default: '40px'
      });
      registerOption('content_css', {
        processor: value => {
          const valid = value === false || isString(value) || isArrayOf(value, isString);
          if (valid) {
            if (isString(value)) {
              return {
                value: map$3(value.split(','), trim$3),
                valid
              };
            } else if (isArray$1(value)) {
              return {
                value,
                valid
              };
            } else if (value === false) {
              return {
                value: [],
                valid
              };
            } else {
              return {
                value,
                valid
              };
            }
          } else {
            return {
              valid: false,
              message: 'Must be false, a string or an array of strings.'
            };
          }
        },
        default: isInline(editor) ? [] : ['default']
      });
      registerOption('content_style', { processor: 'string' });
      registerOption('content_css_cors', {
        processor: 'boolean',
        default: false
      });
      registerOption('font_css', {
        processor: value => {
          const valid = isString(value) || isArrayOf(value, isString);
          if (valid) {
            const newValue = isArray$1(value) ? value : map$3(value.split(','), trim$3);
            return {
              value: newValue,
              valid
            };
          } else {
            return {
              valid: false,
              message: 'Must be a string or an array of strings.'
            };
          }
        },
        default: []
      });
      registerOption('inline_boundaries', {
        processor: 'boolean',
        default: true
      });
      registerOption('inline_boundaries_selector', {
        processor: 'string',
        default: 'a[href],code,span.mce-annotation'
      });
      registerOption('object_resizing', {
        processor: value => {
          const valid = isBoolean(value) || isString(value);
          if (valid) {
            if (value === false || deviceDetection$1.isiPhone() || deviceDetection$1.isiPad()) {
              return {
                value: '',
                valid
              };
            } else {
              return {
                value: value === true ? 'table,img,figure.image,div,video,iframe' : value,
                valid
              };
            }
          } else {
            return {
              valid: false,
              message: 'Must be boolean or a string'
            };
          }
        },
        default: !isTouch
      });
      registerOption('resize_img_proportional', {
        processor: 'boolean',
        default: true
      });
      registerOption('event_root', { processor: 'object' });
      registerOption('service_message', { processor: 'string' });
      registerOption('theme', {
        processor: value => value === false || isString(value) || isFunction(value),
        default: 'silver'
      });
      registerOption('theme_url', { processor: 'string' });
      registerOption('formats', { processor: 'object' });
      registerOption('format_empty_lines', {
        processor: 'boolean',
        default: false
      });
      registerOption('format_noneditable_selector', {
        processor: 'string',
        default: ''
      });
      registerOption('preview_styles', {
        processor: value => {
          const valid = value === false || isString(value);
          if (valid) {
            return {
              value: value === false ? '' : value,
              valid
            };
          } else {
            return {
              valid: false,
              message: 'Must be false or a string'
            };
          }
        },
        default: 'font-family font-size font-weight font-style text-decoration text-transform color background-color border border-radius outline text-shadow'
      });
      registerOption('custom_ui_selector', {
        processor: 'string',
        default: ''
      });
      registerOption('hidden_input', {
        processor: 'boolean',
        default: true
      });
      registerOption('submit_patch', {
        processor: 'boolean',
        default: true
      });
      registerOption('encoding', { processor: 'string' });
      registerOption('add_form_submit_trigger', {
        processor: 'boolean',
        default: true
      });
      registerOption('add_unload_trigger', {
        processor: 'boolean',
        default: true
      });
      registerOption('custom_undo_redo_levels', {
        processor: 'number',
        default: 0
      });
      registerOption('disable_nodechange', {
        processor: 'boolean',
        default: false
      });
      registerOption('readonly', {
        processor: 'boolean',
        default: false
      });
      registerOption('plugins', {
        processor: 'string[]',
        default: []
      });
      registerOption('external_plugins', { processor: 'object' });
      registerOption('forced_plugins', { processor: 'string[]' });
      registerOption('model', {
        processor: 'string',
        default: editor.hasPlugin('rtc') ? 'plugin' : 'dom'
      });
      registerOption('model_url', { processor: 'string' });
      registerOption('block_unsupported_drop', {
        processor: 'boolean',
        default: true
      });
      registerOption('visual', {
        processor: 'boolean',
        default: true
      });
      registerOption('visual_table_class', {
        processor: 'string',
        default: 'mce-item-table'
      });
      registerOption('visual_anchor_class', {
        processor: 'string',
        default: 'mce-item-anchor'
      });
      registerOption('iframe_aria_text', {
        processor: 'string',
        default: 'Rich Text Area. Press ALT-0 for help.'
      });
      registerOption('setup', { processor: 'function' });
      registerOption('init_instance_callback', { processor: 'function' });
      registerOption('url_converter', {
        processor: 'function',
        default: editor.convertURL
      });
      registerOption('url_converter_scope', {
        processor: 'object',
        default: editor
      });
      registerOption('urlconverter_callback', { processor: 'function' });
      registerOption('allow_conditional_comments', {
        processor: 'boolean',
        default: false
      });
      registerOption('allow_html_data_urls', {
        processor: 'boolean',
        default: false
      });
      registerOption('allow_svg_data_urls', { processor: 'boolean' });
      registerOption('allow_html_in_named_anchor', {
        processor: 'boolean',
        default: false
      });
      registerOption('allow_script_urls', {
        processor: 'boolean',
        default: false
      });
      registerOption('allow_unsafe_link_target', {
        processor: 'boolean',
        default: false
      });
      registerOption('convert_fonts_to_spans', {
        processor: 'boolean',
        default: true,
        deprecated: true
      });
      registerOption('fix_list_elements', {
        processor: 'boolean',
        default: false
      });
      registerOption('preserve_cdata', {
        processor: 'boolean',
        default: false
      });
      registerOption('remove_trailing_brs', { processor: 'boolean' });
      registerOption('inline_styles', {
        processor: 'boolean',
        default: true,
        deprecated: true
      });
      registerOption('element_format', {
        processor: 'string',
        default: 'html'
      });
      registerOption('entities', { processor: 'string' });
      registerOption('schema', {
        processor: 'string',
        default: 'html5'
      });
      registerOption('convert_urls', {
        processor: 'boolean',
        default: true
      });
      registerOption('relative_urls', {
        processor: 'boolean',
        default: true
      });
      registerOption('remove_script_host', {
        processor: 'boolean',
        default: true
      });
      registerOption('custom_elements', { processor: 'string' });
      registerOption('extended_valid_elements', { processor: 'string' });
      registerOption('invalid_elements', { processor: 'string' });
      registerOption('invalid_styles', { processor: stringOrObjectProcessor });
      registerOption('valid_children', { processor: 'string' });
      registerOption('valid_classes', { processor: stringOrObjectProcessor });
      registerOption('valid_elements', { processor: 'string' });
      registerOption('valid_styles', { processor: stringOrObjectProcessor });
      registerOption('verify_html', {
        processor: 'boolean',
        default: true
      });
      registerOption('auto_focus', { processor: value => isString(value) || value === true });
      registerOption('browser_spellcheck', {
        processor: 'boolean',
        default: false
      });
      registerOption('protect', { processor: 'array' });
      registerOption('images_file_types', {
        processor: 'string',
        default: 'jpeg,jpg,jpe,jfi,jif,jfif,png,gif,bmp,webp'
      });
      registerOption('deprecation_warnings', {
        processor: 'boolean',
        default: true
      });
      registerOption('a11y_advanced_options', {
        processor: 'boolean',
        default: false
      });
      registerOption('api_key', { processor: 'string' });
      registerOption('paste_block_drop', {
        processor: 'boolean',
        default: false
      });
      registerOption('paste_data_images', {
        processor: 'boolean',
        default: true
      });
      registerOption('paste_preprocess', { processor: 'function' });
      registerOption('paste_postprocess', { processor: 'function' });
      registerOption('paste_webkit_styles', {
        processor: 'string',
        default: 'none'
      });
      registerOption('paste_remove_styles_if_webkit', {
        processor: 'boolean',
        default: true
      });
      registerOption('paste_merge_formats', {
        processor: 'boolean',
        default: true
      });
      registerOption('smart_paste', {
        processor: 'boolean',
        default: true
      });
      registerOption('paste_as_text', {
        processor: 'boolean',
        default: false
      });
      registerOption('paste_tab_spaces', {
        processor: 'number',
        default: 4
      });
      registerOption('text_patterns', {
        processor: value => {
          if (isArrayOf(value, isObject) || value === false) {
            const patterns = value === false ? [] : value;
            return {
              value: fromRawPatterns(patterns),
              valid: true
            };
          } else {
            return {
              valid: false,
              message: 'Must be an array of objects or false.'
            };
          }
        },
        default: [
          {
            start: '*',
            end: '*',
            format: 'italic'
          },
          {
            start: '**',
            end: '**',
            format: 'bold'
          },
          {
            start: '#',
            format: 'h1'
          },
          {
            start: '##',
            format: 'h2'
          },
          {
            start: '###',
            format: 'h3'
          },
          {
            start: '####',
            format: 'h4'
          },
          {
            start: '#####',
            format: 'h5'
          },
          {
            start: '######',
            format: 'h6'
          },
          {
            start: '1. ',
            cmd: 'InsertOrderedList'
          },
          {
            start: '* ',
            cmd: 'InsertUnorderedList'
          },
          {
            start: '- ',
            cmd: 'InsertUnorderedList'
          }
        ]
      });
      registerOption('text_patterns_lookup', {
        processor: value => {
          if (isFunction(value)) {
            return {
              value: fromRawPatternsLookup(value),
              valid: true
            };
          } else {
            return {
              valid: false,
              message: 'Must be a single function'
            };
          }
        },
        default: _ctx => []
      });
      registerOption('noneditable_class', {
        processor: 'string',
        default: 'mceNonEditable'
      });
      registerOption('editable_class', {
        processor: 'string',
        default: 'mceEditable'
      });
      registerOption('noneditable_regexp', {
        processor: value => {
          if (isArrayOf(value, isRegExp)) {
            return {
              value,
              valid: true
            };
          } else if (isRegExp(value)) {
            return {
              value: [value],
              valid: true
            };
          } else {
            return {
              valid: false,
              message: 'Must be a RegExp or an array of RegExp.'
            };
          }
        },
        default: []
      });
      registerOption('table_tab_navigation', {
        processor: 'boolean',
        default: true
      });
      registerOption('highlight_on_focus', {
        processor: 'boolean',
        default: false
      });
      registerOption('xss_sanitization', {
        processor: 'boolean',
        default: true
      });
      editor.on('ScriptsLoaded', () => {
        registerOption('directionality', {
          processor: 'string',
          default: I18n.isRtl() ? 'rtl' : undefined
        });
        registerOption('placeholder', {
          processor: 'string',
          default: DOM$a.getAttrib(editor.getElement(), 'placeholder')
        });
      });
    };
    const getIframeAttrs = option('iframe_attrs');
    const getDocType = option('doctype');
    const getDocumentBaseUrl = option('document_base_url');
    const getBodyId = option('body_id');
    const getBodyClass = option('body_class');
    const getContentSecurityPolicy = option('content_security_policy');
    const shouldPutBrInPre$1 = option('br_in_pre');
    const getForcedRootBlock = option('forced_root_block');
    const getForcedRootBlockAttrs = option('forced_root_block_attrs');
    const getNewlineBehavior = option('newline_behavior');
    const getBrNewLineSelector = option('br_newline_selector');
    const getNoNewLineSelector = option('no_newline_selector');
    const shouldKeepStyles = option('keep_styles');
    const shouldEndContainerOnEmptyBlock = option('end_container_on_empty_block');
    const isAutomaticUploadsEnabled = option('automatic_uploads');
    const shouldReuseFileName = option('images_reuse_filename');
    const shouldReplaceBlobUris = option('images_replace_blob_uris');
    const getIconPackName = option('icons');
    const getIconsUrl = option('icons_url');
    const getImageUploadUrl = option('images_upload_url');
    const getImageUploadBasePath = option('images_upload_base_path');
    const getImagesUploadCredentials = option('images_upload_credentials');
    const getImagesUploadHandler = option('images_upload_handler');
    const shouldUseContentCssCors = option('content_css_cors');
    const getReferrerPolicy = option('referrer_policy');
    const getLanguageCode = option('language');
    const getLanguageUrl = option('language_url');
    const shouldIndentUseMargin = option('indent_use_margin');
    const getIndentation = option('indentation');
    const getContentCss = option('content_css');
    const getContentStyle = option('content_style');
    const getFontCss = option('font_css');
    const getDirectionality = option('directionality');
    const getInlineBoundarySelector = option('inline_boundaries_selector');
    const getObjectResizing = option('object_resizing');
    const getResizeImgProportional = option('resize_img_proportional');
    const getPlaceholder = option('placeholder');
    const getEventRoot = option('event_root');
    const getServiceMessage = option('service_message');
    const getTheme = option('theme');
    const getThemeUrl = option('theme_url');
    const getModel = option('model');
    const getModelUrl = option('model_url');
    const isInlineBoundariesEnabled = option('inline_boundaries');
    const getFormats = option('formats');
    const getPreviewStyles = option('preview_styles');
    const canFormatEmptyLines = option('format_empty_lines');
    const getFormatNoneditableSelector = option('format_noneditable_selector');
    const getCustomUiSelector = option('custom_ui_selector');
    const isInline = option('inline');
    const hasHiddenInput = option('hidden_input');
    const shouldPatchSubmit = option('submit_patch');
    const shouldAddFormSubmitTrigger = option('add_form_submit_trigger');
    const shouldAddUnloadTrigger = option('add_unload_trigger');
    const getCustomUndoRedoLevels = option('custom_undo_redo_levels');
    const shouldDisableNodeChange = option('disable_nodechange');
    const isReadOnly$1 = option('readonly');
    const hasContentCssCors = option('content_css_cors');
    const getPlugins = option('plugins');
    const getExternalPlugins$1 = option('external_plugins');
    const shouldBlockUnsupportedDrop = option('block_unsupported_drop');
    const isVisualAidsEnabled = option('visual');
    const getVisualAidsTableClass = option('visual_table_class');
    const getVisualAidsAnchorClass = option('visual_anchor_class');
    const getIframeAriaText = option('iframe_aria_text');
    const getSetupCallback = option('setup');
    const getInitInstanceCallback = option('init_instance_callback');
    const getUrlConverterCallback = option('urlconverter_callback');
    const getAutoFocus = option('auto_focus');
    const shouldBrowserSpellcheck = option('browser_spellcheck');
    const getProtect = option('protect');
    const shouldPasteBlockDrop = option('paste_block_drop');
    const shouldPasteDataImages = option('paste_data_images');
    const getPastePreProcess = option('paste_preprocess');
    const getPastePostProcess = option('paste_postprocess');
    const getPasteWebkitStyles = option('paste_webkit_styles');
    const shouldPasteRemoveWebKitStyles = option('paste_remove_styles_if_webkit');
    const shouldPasteMergeFormats = option('paste_merge_formats');
    const isSmartPasteEnabled = option('smart_paste');
    const isPasteAsTextEnabled = option('paste_as_text');
    const getPasteTabSpaces = option('paste_tab_spaces');
    const shouldAllowHtmlDataUrls = option('allow_html_data_urls');
    const getTextPatterns = option('text_patterns');
    const getTextPatternsLookup = option('text_patterns_lookup');
    const getNonEditableClass = option('noneditable_class');
    const getEditableClass = option('editable_class');
    const getNonEditableRegExps = option('noneditable_regexp');
    const shouldPreserveCData = option('preserve_cdata');
    const shouldHighlightOnFocus = option('highlight_on_focus');
    const shouldSanitizeXss = option('xss_sanitization');
    const hasTextPatternsLookup = editor => editor.options.isSet('text_patterns_lookup');
    const getFontStyleValues = editor => Tools.explode(editor.options.get('font_size_style_values'));
    const getFontSizeClasses = editor => Tools.explode(editor.options.get('font_size_classes'));
    const isEncodingXml = editor => editor.options.get('encoding') === 'xml';
    const getAllowedImageFileTypes = editor => Tools.explode(editor.options.get('images_file_types'));
    const hasTableTabNavigation = option('table_tab_navigation');

    const isElement$3 = isElement$6;
    const isText$5 = isText$a;
    const removeNode$1 = node => {
      const parentNode = node.parentNode;
      if (parentNode) {
        parentNode.removeChild(node);
      }
    };
    const trimCount = text => {
      const trimmedText = trim$1(text);
      return {
        count: text.length - trimmedText.length,
        text: trimmedText
      };
    };
    const deleteZwspChars = caretContainer => {
      let idx;
      while ((idx = caretContainer.data.lastIndexOf(ZWSP$1)) !== -1) {
        caretContainer.deleteData(idx, 1);
      }
    };
    const removeUnchanged = (caretContainer, pos) => {
      remove$4(caretContainer);
      return pos;
    };
    const removeTextAndReposition = (caretContainer, pos) => {
      const before = trimCount(caretContainer.data.substr(0, pos.offset()));
      const after = trimCount(caretContainer.data.substr(pos.offset()));
      const text = before.text + after.text;
      if (text.length > 0) {
        deleteZwspChars(caretContainer);
        return CaretPosition(caretContainer, pos.offset() - before.count);
      } else {
        return pos;
      }
    };
    const removeElementAndReposition = (caretContainer, pos) => {
      const parentNode = pos.container();
      const newPosition = indexOf$1(from(parentNode.childNodes), caretContainer).map(index => {
        return index < pos.offset() ? CaretPosition(parentNode, pos.offset() - 1) : pos;
      }).getOr(pos);
      remove$4(caretContainer);
      return newPosition;
    };
    const removeTextCaretContainer = (caretContainer, pos) => isText$5(caretContainer) && pos.container() === caretContainer ? removeTextAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);
    const removeElementCaretContainer = (caretContainer, pos) => pos.container() === caretContainer.parentNode ? removeElementAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);
    const removeAndReposition = (container, pos) => CaretPosition.isTextPosition(pos) ? removeTextCaretContainer(container, pos) : removeElementCaretContainer(container, pos);
    const remove$4 = caretContainerNode => {
      if (isElement$3(caretContainerNode) && isCaretContainer$2(caretContainerNode)) {
        if (hasContent(caretContainerNode)) {
          caretContainerNode.removeAttribute('data-mce-caret');
        } else {
          removeNode$1(caretContainerNode);
        }
      }
      if (isText$5(caretContainerNode)) {
        deleteZwspChars(caretContainerNode);
        if (caretContainerNode.data.length === 0) {
          removeNode$1(caretContainerNode);
        }
      }
    };

    const isContentEditableFalse$8 = isContentEditableFalse$b;
    const isMedia$1 = isMedia$2;
    const isTableCell$1 = isTableCell$3;
    const inlineFakeCaretSelector = '*[contentEditable=false],video,audio,embed,object';
    const getAbsoluteClientRect = (root, element, before) => {
      const clientRect = collapse(element.getBoundingClientRect(), before);
      let scrollX;
      let scrollY;
      if (root.tagName === 'BODY') {
        const docElm = root.ownerDocument.documentElement;
        scrollX = root.scrollLeft || docElm.scrollLeft;
        scrollY = root.scrollTop || docElm.scrollTop;
      } else {
        const rootRect = root.getBoundingClientRect();
        scrollX = root.scrollLeft - rootRect.left;
        scrollY = root.scrollTop - rootRect.top;
      }
      clientRect.left += scrollX;
      clientRect.right += scrollX;
      clientRect.top += scrollY;
      clientRect.bottom += scrollY;
      clientRect.width = 1;
      let margin = element.offsetWidth - element.clientWidth;
      if (margin > 0) {
        if (before) {
          margin *= -1;
        }
        clientRect.left += margin;
        clientRect.right += margin;
      }
      return clientRect;
    };
    const trimInlineCaretContainers = root => {
      var _a, _b;
      const fakeCaretTargetNodes = descendants(SugarElement.fromDom(root), inlineFakeCaretSelector);
      for (let i = 0; i < fakeCaretTargetNodes.length; i++) {
        const node = fakeCaretTargetNodes[i].dom;
        let sibling = node.previousSibling;
        if (endsWithCaretContainer$1(sibling)) {
          const data = sibling.data;
          if (data.length === 1) {
            (_a = sibling.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(sibling);
          } else {
            sibling.deleteData(data.length - 1, 1);
          }
        }
        sibling = node.nextSibling;
        if (startsWithCaretContainer$1(sibling)) {
          const data = sibling.data;
          if (data.length === 1) {
            (_b = sibling.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(sibling);
          } else {
            sibling.deleteData(0, 1);
          }
        }
      }
    };
    const FakeCaret = (editor, root, isBlock, hasFocus) => {
      const lastVisualCaret = value$2();
      let cursorInterval;
      let caretContainerNode;
      const caretBlock = getForcedRootBlock(editor);
      const dom = editor.dom;
      const show = (before, element) => {
        let rng;
        hide();
        if (isTableCell$1(element)) {
          return null;
        }
        if (isBlock(element)) {
          const caretContainer = insertBlock(caretBlock, element, before);
          const clientRect = getAbsoluteClientRect(root, element, before);
          dom.setStyle(caretContainer, 'top', clientRect.top);
          caretContainerNode = caretContainer;
          const caret = dom.create('div', {
            'class': 'mce-visual-caret',
            'data-mce-bogus': 'all'
          });
          dom.setStyles(caret, { ...clientRect });
          dom.add(root, caret);
          lastVisualCaret.set({
            caret,
            element,
            before
          });
          if (before) {
            dom.addClass(caret, 'mce-visual-caret-before');
          }
          startBlink();
          rng = element.ownerDocument.createRange();
          rng.setStart(caretContainer, 0);
          rng.setEnd(caretContainer, 0);
        } else {
          caretContainerNode = insertInline$1(element, before);
          rng = element.ownerDocument.createRange();
          if (isInlineFakeCaretTarget(caretContainerNode.nextSibling)) {
            rng.setStart(caretContainerNode, 0);
            rng.setEnd(caretContainerNode, 0);
          } else {
            rng.setStart(caretContainerNode, 1);
            rng.setEnd(caretContainerNode, 1);
          }
          return rng;
        }
        return rng;
      };
      const hide = () => {
        trimInlineCaretContainers(root);
        if (caretContainerNode) {
          remove$4(caretContainerNode);
          caretContainerNode = null;
        }
        lastVisualCaret.on(caretState => {
          dom.remove(caretState.caret);
          lastVisualCaret.clear();
        });
        if (cursorInterval) {
          clearInterval(cursorInterval);
          cursorInterval = undefined;
        }
      };
      const startBlink = () => {
        cursorInterval = setInterval(() => {
          lastVisualCaret.on(caretState => {
            if (hasFocus()) {
              dom.toggleClass(caretState.caret, 'mce-visual-caret-hidden');
            } else {
              dom.addClass(caretState.caret, 'mce-visual-caret-hidden');
            }
          });
        }, 500);
      };
      const reposition = () => {
        lastVisualCaret.on(caretState => {
          const clientRect = getAbsoluteClientRect(root, caretState.element, caretState.before);
          dom.setStyles(caretState.caret, { ...clientRect });
        });
      };
      const destroy = () => clearInterval(cursorInterval);
      const getCss = () => '.mce-visual-caret {' + 'position: absolute;' + 'background-color: black;' + 'background-color: currentcolor;' + '}' + '.mce-visual-caret-hidden {' + 'display: none;' + '}' + '*[data-mce-caret] {' + 'position: absolute;' + 'left: -1000px;' + 'right: auto;' + 'top: 0;' + 'margin: 0;' + 'padding: 0;' + '}';
      return {
        show,
        hide,
        getCss,
        reposition,
        destroy
      };
    };
    const isFakeCaretTableBrowser = () => Env.browser.isFirefox();
    const isInlineFakeCaretTarget = node => isContentEditableFalse$8(node) || isMedia$1(node);
    const isFakeCaretTarget = node => {
      const isTarget = isInlineFakeCaretTarget(node) || isTable$2(node) && isFakeCaretTableBrowser();
      return isTarget && parentElement(SugarElement.fromDom(node)).exists(isEditable$3);
    };

    const isContentEditableTrue$1 = isContentEditableTrue$3;
    const isContentEditableFalse$7 = isContentEditableFalse$b;
    const isMedia = isMedia$2;
    const isBlockLike = matchStyleValues('display', 'block table table-cell table-caption list-item');
    const isCaretContainer = isCaretContainer$2;
    const isCaretContainerBlock = isCaretContainerBlock$1;
    const isElement$2 = isElement$6;
    const isText$4 = isText$a;
    const isCaretCandidate$1 = isCaretCandidate$3;
    const isForwards = direction => direction > 0;
    const isBackwards = direction => direction < 0;
    const skipCaretContainers = (walk, shallow) => {
      let node;
      while (node = walk(shallow)) {
        if (!isCaretContainerBlock(node)) {
          return node;
        }
      }
      return null;
    };
    const findNode = (node, direction, predicateFn, rootNode, shallow) => {
      const walker = new DomTreeWalker(node, rootNode);
      const isCefOrCaretContainer = isContentEditableFalse$7(node) || isCaretContainerBlock(node);
      let tempNode;
      if (isBackwards(direction)) {
        if (isCefOrCaretContainer) {
          tempNode = skipCaretContainers(walker.prev.bind(walker), true);
          if (predicateFn(tempNode)) {
            return tempNode;
          }
        }
        while (tempNode = skipCaretContainers(walker.prev.bind(walker), shallow)) {
          if (predicateFn(tempNode)) {
            return tempNode;
          }
        }
      }
      if (isForwards(direction)) {
        if (isCefOrCaretContainer) {
          tempNode = skipCaretContainers(walker.next.bind(walker), true);
          if (predicateFn(tempNode)) {
            return tempNode;
          }
        }
        while (tempNode = skipCaretContainers(walker.next.bind(walker), shallow)) {
          if (predicateFn(tempNode)) {
            return tempNode;
          }
        }
      }
      return null;
    };
    const getEditingHost = (node, rootNode) => {
      const isCETrue = node => isContentEditableTrue$1(node.dom);
      const isRoot = node => node.dom === rootNode;
      return ancestor$4(SugarElement.fromDom(node), isCETrue, isRoot).map(elm => elm.dom).getOr(rootNode);
    };
    const getParentBlock$3 = (node, rootNode) => {
      while (node && node !== rootNode) {
        if (isBlockLike(node)) {
          return node;
        }
        node = node.parentNode;
      }
      return null;
    };
    const isInSameBlock = (caretPosition1, caretPosition2, rootNode) => getParentBlock$3(caretPosition1.container(), rootNode) === getParentBlock$3(caretPosition2.container(), rootNode);
    const getChildNodeAtRelativeOffset = (relativeOffset, caretPosition) => {
      if (!caretPosition) {
        return Optional.none();
      }
      const container = caretPosition.container();
      const offset = caretPosition.offset();
      if (!isElement$2(container)) {
        return Optional.none();
      }
      return Optional.from(container.childNodes[offset + relativeOffset]);
    };
    const beforeAfter = (before, node) => {
      var _a;
      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;
      const range = doc.createRange();
      if (before) {
        range.setStartBefore(node);
        range.setEndBefore(node);
      } else {
        range.setStartAfter(node);
        range.setEndAfter(node);
      }
      return range;
    };
    const isNodesInSameBlock = (root, node1, node2) => getParentBlock$3(node1, root) === getParentBlock$3(node2, root);
    const lean = (left, root, node) => {
      const siblingName = left ? 'previousSibling' : 'nextSibling';
      let tempNode = node;
      while (tempNode && tempNode !== root) {
        let sibling = tempNode[siblingName];
        if (sibling && isCaretContainer(sibling)) {
          sibling = sibling[siblingName];
        }
        if (isContentEditableFalse$7(sibling) || isMedia(sibling)) {
          if (isNodesInSameBlock(root, sibling, tempNode)) {
            return sibling;
          }
          break;
        }
        if (isCaretCandidate$1(sibling)) {
          break;
        }
        tempNode = tempNode.parentNode;
      }
      return null;
    };
    const before$2 = curry(beforeAfter, true);
    const after$2 = curry(beforeAfter, false);
    const normalizeRange = (direction, root, range) => {
      let node;
      const leanLeft = curry(lean, true, root);
      const leanRight = curry(lean, false, root);
      const container = range.startContainer;
      const offset = range.startOffset;
      if (isCaretContainerBlock$1(container)) {
        const block = isText$4(container) ? container.parentNode : container;
        const location = block.getAttribute('data-mce-caret');
        if (location === 'before') {
          node = block.nextSibling;
          if (isFakeCaretTarget(node)) {
            return before$2(node);
          }
        }
        if (location === 'after') {
          node = block.previousSibling;
          if (isFakeCaretTarget(node)) {
            return after$2(node);
          }
        }
      }
      if (!range.collapsed) {
        return range;
      }
      if (isText$a(container)) {
        if (isCaretContainer(container)) {
          if (direction === 1) {
            node = leanRight(container);
            if (node) {
              return before$2(node);
            }
            node = leanLeft(container);
            if (node) {
              return after$2(node);
            }
          }
          if (direction === -1) {
            node = leanLeft(container);
            if (node) {
              return after$2(node);
            }
            node = leanRight(container);
            if (node) {
              return before$2(node);
            }
          }
          return range;
        }
        if (endsWithCaretContainer$1(container) && offset >= container.data.length - 1) {
          if (direction === 1) {
            node = leanRight(container);
            if (node) {
              return before$2(node);
            }
          }
          return range;
        }
        if (startsWithCaretContainer$1(container) && offset <= 1) {
          if (direction === -1) {
            node = leanLeft(container);
            if (node) {
              return after$2(node);
            }
          }
          return range;
        }
        if (offset === container.data.length) {
          node = leanRight(container);
          if (node) {
            return before$2(node);
          }
          return range;
        }
        if (offset === 0) {
          node = leanLeft(container);
          if (node) {
            return after$2(node);
          }
          return range;
        }
      }
      return range;
    };
    const getRelativeCefElm = (forward, caretPosition) => getChildNodeAtRelativeOffset(forward ? 0 : -1, caretPosition).filter(isContentEditableFalse$7);
    const getNormalizedRangeEndPoint = (direction, root, range) => {
      const normalizedRange = normalizeRange(direction, root, range);
      return direction === -1 ? CaretPosition.fromRangeStart(normalizedRange) : CaretPosition.fromRangeEnd(normalizedRange);
    };
    const getElementFromPosition = pos => Optional.from(pos.getNode()).map(SugarElement.fromDom);
    const getElementFromPrevPosition = pos => Optional.from(pos.getNode(true)).map(SugarElement.fromDom);
    const getVisualCaretPosition = (walkFn, caretPosition) => {
      let pos = caretPosition;
      while (pos = walkFn(pos)) {
        if (pos.isVisible()) {
          return pos;
        }
      }
      return pos;
    };
    const isMoveInsideSameBlock = (from, to) => {
      const inSameBlock = isInSameBlock(from, to);
      if (!inSameBlock && isBr$6(from.getNode())) {
        return true;
      }
      return inSameBlock;
    };

    var HDirection;
    (function (HDirection) {
      HDirection[HDirection['Backwards'] = -1] = 'Backwards';
      HDirection[HDirection['Forwards'] = 1] = 'Forwards';
    }(HDirection || (HDirection = {})));
    const isContentEditableFalse$6 = isContentEditableFalse$b;
    const isText$3 = isText$a;
    const isElement$1 = isElement$6;
    const isBr$2 = isBr$6;
    const isCaretCandidate = isCaretCandidate$3;
    const isAtomic = isAtomic$1;
    const isEditableCaretCandidate = isEditableCaretCandidate$1;
    const getParents$3 = (node, root) => {
      const parents = [];
      let tempNode = node;
      while (tempNode && tempNode !== root) {
        parents.push(tempNode);
        tempNode = tempNode.parentNode;
      }
      return parents;
    };
    const nodeAtIndex = (container, offset) => {
      if (container.hasChildNodes() && offset < container.childNodes.length) {
        return container.childNodes[offset];
      }
      return null;
    };
    const getCaretCandidatePosition = (direction, node) => {
      if (isForwards(direction)) {
        if (isCaretCandidate(node.previousSibling) && !isText$3(node.previousSibling)) {
          return CaretPosition.before(node);
        }
        if (isText$3(node)) {
          return CaretPosition(node, 0);
        }
      }
      if (isBackwards(direction)) {
        if (isCaretCandidate(node.nextSibling) && !isText$3(node.nextSibling)) {
          return CaretPosition.after(node);
        }
        if (isText$3(node)) {
          return CaretPosition(node, node.data.length);
        }
      }
      if (isBackwards(direction)) {
        if (isBr$2(node)) {
          return CaretPosition.before(node);
        }
        return CaretPosition.after(node);
      }
      return CaretPosition.before(node);
    };
    const moveForwardFromBr = (root, nextNode) => {
      const nextSibling = nextNode.nextSibling;
      if (nextSibling && isCaretCandidate(nextSibling)) {
        if (isText$3(nextSibling)) {
          return CaretPosition(nextSibling, 0);
        } else {
          return CaretPosition.before(nextSibling);
        }
      } else {
        return findCaretPosition$1(HDirection.Forwards, CaretPosition.after(nextNode), root);
      }
    };
    const findCaretPosition$1 = (direction, startPos, root) => {
      let node;
      let nextNode;
      let innerNode;
      let caretPosition;
      if (!isElement$1(root) || !startPos) {
        return null;
      }
      if (startPos.isEqual(CaretPosition.after(root)) && root.lastChild) {
        caretPosition = CaretPosition.after(root.lastChild);
        if (isBackwards(direction) && isCaretCandidate(root.lastChild) && isElement$1(root.lastChild)) {
          return isBr$2(root.lastChild) ? CaretPosition.before(root.lastChild) : caretPosition;
        }
      } else {
        caretPosition = startPos;
      }
      const container = caretPosition.container();
      let offset = caretPosition.offset();
      if (isText$3(container)) {
        if (isBackwards(direction) && offset > 0) {
          return CaretPosition(container, --offset);
        }
        if (isForwards(direction) && offset < container.length) {
          return CaretPosition(container, ++offset);
        }
        node = container;
      } else {
        if (isBackwards(direction) && offset > 0) {
          nextNode = nodeAtIndex(container, offset - 1);
          if (isCaretCandidate(nextNode)) {
            if (!isAtomic(nextNode)) {
              innerNode = findNode(nextNode, direction, isEditableCaretCandidate, nextNode);
              if (innerNode) {
                if (isText$3(innerNode)) {
                  return CaretPosition(innerNode, innerNode.data.length);
                }
                return CaretPosition.after(innerNode);
              }
            }
            if (isText$3(nextNode)) {
              return CaretPosition(nextNode, nextNode.data.length);
            }
            return CaretPosition.before(nextNode);
          }
        }
        if (isForwards(direction) && offset < container.childNodes.length) {
          nextNode = nodeAtIndex(container, offset);
          if (isCaretCandidate(nextNode)) {
            if (isBr$2(nextNode)) {
              return moveForwardFromBr(root, nextNode);
            }
            if (!isAtomic(nextNode)) {
              innerNode = findNode(nextNode, direction, isEditableCaretCandidate, nextNode);
              if (innerNode) {
                if (isText$3(innerNode)) {
                  return CaretPosition(innerNode, 0);
                }
                return CaretPosition.before(innerNode);
              }
            }
            if (isText$3(nextNode)) {
              return CaretPosition(nextNode, 0);
            }
            return CaretPosition.after(nextNode);
          }
        }
        node = nextNode ? nextNode : caretPosition.getNode();
      }
      if (node && (isForwards(direction) && caretPosition.isAtEnd() || isBackwards(direction) && caretPosition.isAtStart())) {
        node = findNode(node, direction, always, root, true);
        if (isEditableCaretCandidate(node, root)) {
          return getCaretCandidatePosition(direction, node);
        }
      }
      nextNode = node ? findNode(node, direction, isEditableCaretCandidate, root) : node;
      const rootContentEditableFalseElm = last$2(filter$5(getParents$3(container, root), isContentEditableFalse$6));
      if (rootContentEditableFalseElm && (!nextNode || !rootContentEditableFalseElm.contains(nextNode))) {
        if (isForwards(direction)) {
          caretPosition = CaretPosition.after(rootContentEditableFalseElm);
        } else {
          caretPosition = CaretPosition.before(rootContentEditableFalseElm);
        }
        return caretPosition;
      }
      if (nextNode) {
        return getCaretCandidatePosition(direction, nextNode);
      }
      return null;
    };
    const CaretWalker = root => ({
      next: caretPosition => {
        return findCaretPosition$1(HDirection.Forwards, caretPosition, root);
      },
      prev: caretPosition => {
        return findCaretPosition$1(HDirection.Backwards, caretPosition, root);
      }
    });

    const walkToPositionIn = (forward, root, start) => {
      const position = forward ? CaretPosition.before(start) : CaretPosition.after(start);
      return fromPosition(forward, root, position);
    };
    const afterElement = node => isBr$6(node) ? CaretPosition.before(node) : CaretPosition.after(node);
    const isBeforeOrStart = position => {
      if (CaretPosition.isTextPosition(position)) {
        return position.offset() === 0;
      } else {
        return isCaretCandidate$3(position.getNode());
      }
    };
    const isAfterOrEnd = position => {
      if (CaretPosition.isTextPosition(position)) {
        const container = position.container();
        return position.offset() === container.data.length;
      } else {
        return isCaretCandidate$3(position.getNode(true));
      }
    };
    const isBeforeAfterSameElement = (from, to) => !CaretPosition.isTextPosition(from) && !CaretPosition.isTextPosition(to) && from.getNode() === to.getNode(true);
    const isAtBr = position => !CaretPosition.isTextPosition(position) && isBr$6(position.getNode());
    const shouldSkipPosition = (forward, from, to) => {
      if (forward) {
        return !isBeforeAfterSameElement(from, to) && !isAtBr(from) && isAfterOrEnd(from) && isBeforeOrStart(to);
      } else {
        return !isBeforeAfterSameElement(to, from) && isBeforeOrStart(from) && isAfterOrEnd(to);
      }
    };
    const fromPosition = (forward, root, pos) => {
      const walker = CaretWalker(root);
      return Optional.from(forward ? walker.next(pos) : walker.prev(pos));
    };
    const navigate = (forward, root, from) => fromPosition(forward, root, from).bind(to => {
      if (isInSameBlock(from, to, root) && shouldSkipPosition(forward, from, to)) {
        return fromPosition(forward, root, to);
      } else {
        return Optional.some(to);
      }
    });
    const navigateIgnore = (forward, root, from, ignoreFilter) => navigate(forward, root, from).bind(pos => ignoreFilter(pos) ? navigateIgnore(forward, root, pos, ignoreFilter) : Optional.some(pos));
    const positionIn = (forward, element) => {
      const startNode = forward ? element.firstChild : element.lastChild;
      if (isText$a(startNode)) {
        return Optional.some(CaretPosition(startNode, forward ? 0 : startNode.data.length));
      } else if (startNode) {
        if (isCaretCandidate$3(startNode)) {
          return Optional.some(forward ? CaretPosition.before(startNode) : afterElement(startNode));
        } else {
          return walkToPositionIn(forward, element, startNode);
        }
      } else {
        return Optional.none();
      }
    };
    const nextPosition = curry(fromPosition, true);
    const prevPosition = curry(fromPosition, false);
    const firstPositionIn = curry(positionIn, true);
    const lastPositionIn = curry(positionIn, false);

    const CARET_ID = '_mce_caret';
    const isCaretNode = node => isElement$6(node) && node.id === CARET_ID;
    const getParentCaretContainer = (body, node) => {
      let currentNode = node;
      while (currentNode && currentNode !== body) {
        if (isCaretNode(currentNode)) {
          return currentNode;
        }
        currentNode = currentNode.parentNode;
      }
      return null;
    };

    const isStringPathBookmark = bookmark => isString(bookmark.start);
    const isRangeBookmark = bookmark => has$2(bookmark, 'rng');
    const isIdBookmark = bookmark => has$2(bookmark, 'id');
    const isIndexBookmark = bookmark => has$2(bookmark, 'name');
    const isPathBookmark = bookmark => Tools.isArray(bookmark.start);

    const isForwardBookmark = bookmark => !isIndexBookmark(bookmark) && isBoolean(bookmark.forward) ? bookmark.forward : true;
    const addBogus = (dom, node) => {
      if (isElement$6(node) && dom.isBlock(node) && !node.innerHTML) {
        node.innerHTML = '<br data-mce-bogus="1" />';
      }
      return node;
    };
    const resolveCaretPositionBookmark = (dom, bookmark) => {
      const startPos = Optional.from(resolve$1(dom.getRoot(), bookmark.start));
      const endPos = Optional.from(resolve$1(dom.getRoot(), bookmark.end));
      return lift2(startPos, endPos, (start, end) => {
        const range = dom.createRng();
        range.setStart(start.container(), start.offset());
        range.setEnd(end.container(), end.offset());
        return {
          range,
          forward: isForwardBookmark(bookmark)
        };
      });
    };
    const insertZwsp = (node, rng) => {
      var _a;
      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;
      const textNode = doc.createTextNode(ZWSP$1);
      node.appendChild(textNode);
      rng.setStart(textNode, 0);
      rng.setEnd(textNode, 0);
    };
    const isEmpty$1 = node => !node.hasChildNodes();
    const tryFindRangePosition = (node, rng) => lastPositionIn(node).fold(never, pos => {
      rng.setStart(pos.container(), pos.offset());
      rng.setEnd(pos.container(), pos.offset());
      return true;
    });
    const padEmptyCaretContainer = (root, node, rng) => {
      if (isEmpty$1(node) && getParentCaretContainer(root, node)) {
        insertZwsp(node, rng);
        return true;
      } else {
        return false;
      }
    };
    const setEndPoint = (dom, start, bookmark, rng) => {
      const point = bookmark[start ? 'start' : 'end'];
      const root = dom.getRoot();
      if (point) {
        let node = root;
        let offset = point[0];
        for (let i = point.length - 1; node && i >= 1; i--) {
          const children = node.childNodes;
          if (padEmptyCaretContainer(root, node, rng)) {
            return true;
          }
          if (point[i] > children.length - 1) {
            if (padEmptyCaretContainer(root, node, rng)) {
              return true;
            }
            return tryFindRangePosition(node, rng);
          }
          node = children[point[i]];
        }
        if (isText$a(node)) {
          offset = Math.min(point[0], node.data.length);
        }
        if (isElement$6(node)) {
          offset = Math.min(point[0], node.childNodes.length);
        }
        if (start) {
          rng.setStart(node, offset);
        } else {
          rng.setEnd(node, offset);
        }
      }
      return true;
    };
    const isValidTextNode = node => isText$a(node) && node.data.length > 0;
    const restoreEndPoint = (dom, suffix, bookmark) => {
      const marker = dom.get(bookmark.id + '_' + suffix);
      const markerParent = marker === null || marker === void 0 ? void 0 : marker.parentNode;
      const keep = bookmark.keep;
      if (marker && markerParent) {
        let container;
        let offset;
        if (suffix === 'start') {
          if (!keep) {
            container = markerParent;
            offset = dom.nodeIndex(marker);
          } else {
            if (marker.hasChildNodes()) {
              container = marker.firstChild;
              offset = 1;
            } else if (isValidTextNode(marker.nextSibling)) {
              container = marker.nextSibling;
              offset = 0;
            } else if (isValidTextNode(marker.previousSibling)) {
              container = marker.previousSibling;
              offset = marker.previousSibling.data.length;
            } else {
              container = markerParent;
              offset = dom.nodeIndex(marker) + 1;
            }
          }
        } else {
          if (!keep) {
            container = markerParent;
            offset = dom.nodeIndex(marker);
          } else {
            if (marker.hasChildNodes()) {
              container = marker.firstChild;
              offset = 1;
            } else if (isValidTextNode(marker.previousSibling)) {
              container = marker.previousSibling;
              offset = marker.previousSibling.data.length;
            } else {
              container = markerParent;
              offset = dom.nodeIndex(marker);
            }
          }
        }
        if (!keep) {
          const prev = marker.previousSibling;
          const next = marker.nextSibling;
          Tools.each(Tools.grep(marker.childNodes), node => {
            if (isText$a(node)) {
              node.data = node.data.replace(/\uFEFF/g, '');
            }
          });
          let otherMarker;
          while (otherMarker = dom.get(bookmark.id + '_' + suffix)) {
            dom.remove(otherMarker, true);
          }
          if (isText$a(next) && isText$a(prev) && !Env.browser.isOpera()) {
            const idx = prev.data.length;
            prev.appendData(next.data);
            dom.remove(next);
            container = prev;
            offset = idx;
          }
        }
        return Optional.some(CaretPosition(container, offset));
      } else {
        return Optional.none();
      }
    };
    const resolvePaths = (dom, bookmark) => {
      const range = dom.createRng();
      if (setEndPoint(dom, true, bookmark, range) && setEndPoint(dom, false, bookmark, range)) {
        return Optional.some({
          range,
          forward: isForwardBookmark(bookmark)
        });
      } else {
        return Optional.none();
      }
    };
    const resolveId = (dom, bookmark) => {
      const startPos = restoreEndPoint(dom, 'start', bookmark);
      const endPos = restoreEndPoint(dom, 'end', bookmark);
      return lift2(startPos, endPos.or(startPos), (spos, epos) => {
        const range = dom.createRng();
        range.setStart(addBogus(dom, spos.container()), spos.offset());
        range.setEnd(addBogus(dom, epos.container()), epos.offset());
        return {
          range,
          forward: isForwardBookmark(bookmark)
        };
      });
    };
    const resolveIndex = (dom, bookmark) => Optional.from(dom.select(bookmark.name)[bookmark.index]).map(elm => {
      const range = dom.createRng();
      range.selectNode(elm);
      return {
        range,
        forward: true
      };
    });
    const resolve = (selection, bookmark) => {
      const dom = selection.dom;
      if (bookmark) {
        if (isPathBookmark(bookmark)) {
          return resolvePaths(dom, bookmark);
        } else if (isStringPathBookmark(bookmark)) {
          return resolveCaretPositionBookmark(dom, bookmark);
        } else if (isIdBookmark(bookmark)) {
          return resolveId(dom, bookmark);
        } else if (isIndexBookmark(bookmark)) {
          return resolveIndex(dom, bookmark);
        } else if (isRangeBookmark(bookmark)) {
          return Optional.some({
            range: bookmark.rng,
            forward: isForwardBookmark(bookmark)
          });
        }
      }
      return Optional.none();
    };

    const getBookmark$1 = (selection, type, normalized) => {
      return getBookmark$2(selection, type, normalized);
    };
    const moveToBookmark = (selection, bookmark) => {
      resolve(selection, bookmark).each(({range, forward}) => {
        selection.setRng(range, forward);
      });
    };
    const isBookmarkNode$1 = node => {
      return isElement$6(node) && node.tagName === 'SPAN' && node.getAttribute('data-mce-type') === 'bookmark';
    };

    const is = expected => actual => expected === actual;
    const isNbsp = is(nbsp);
    const isWhiteSpace = chr => chr !== '' && ' \f\n\r\t\x0B'.indexOf(chr) !== -1;
    const isContent = chr => !isWhiteSpace(chr) && !isNbsp(chr) && !isZwsp$1(chr);

    const hexColour = value => ({ value: normalizeHex(value) });
    const normalizeHex = hex => removeLeading(hex, '#').toUpperCase();
    const toHex = component => {
      const hex = component.toString(16);
      return (hex.length === 1 ? '0' + hex : hex).toUpperCase();
    };
    const fromRgba = rgbaColour => {
      const value = toHex(rgbaColour.red) + toHex(rgbaColour.green) + toHex(rgbaColour.blue);
      return hexColour(value);
    };

    const rgbRegex = /^\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)\s*$/i;
    const rgbaRegex = /^\s*rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?(?:\.\d+)?)\s*\)\s*$/i;
    const rgbaColour = (red, green, blue, alpha) => ({
      red,
      green,
      blue,
      alpha
    });
    const fromStringValues = (red, green, blue, alpha) => {
      const r = parseInt(red, 10);
      const g = parseInt(green, 10);
      const b = parseInt(blue, 10);
      const a = parseFloat(alpha);
      return rgbaColour(r, g, b, a);
    };
    const fromString = rgbaString => {
      if (rgbaString === 'transparent') {
        return Optional.some(rgbaColour(0, 0, 0, 0));
      }
      const rgbMatch = rgbRegex.exec(rgbaString);
      if (rgbMatch !== null) {
        return Optional.some(fromStringValues(rgbMatch[1], rgbMatch[2], rgbMatch[3], '1'));
      }
      const rgbaMatch = rgbaRegex.exec(rgbaString);
      if (rgbaMatch !== null) {
        return Optional.some(fromStringValues(rgbaMatch[1], rgbaMatch[2], rgbaMatch[3], rgbaMatch[4]));
      }
      return Optional.none();
    };

    const rgbaToHexString = color => fromString(color).map(fromRgba).map(h => '#' + h.value).getOr(color);

    const getRanges$1 = selection => {
      const ranges = [];
      if (selection) {
        for (let i = 0; i < selection.rangeCount; i++) {
          ranges.push(selection.getRangeAt(i));
        }
      }
      return ranges;
    };
    const getSelectedNodes = ranges => {
      return bind$3(ranges, range => {
        const node = getSelectedNode(range);
        return node ? [SugarElement.fromDom(node)] : [];
      });
    };
    const hasMultipleRanges = selection => {
      return getRanges$1(selection).length > 1;
    };

    const getCellsFromRanges = ranges => filter$5(getSelectedNodes(ranges), isTableCell$2);
    const getCellsFromElement = elm => descendants(elm, 'td[data-mce-selected],th[data-mce-selected]');
    const getCellsFromElementOrRanges = (ranges, element) => {
      const selectedCells = getCellsFromElement(element);
      return selectedCells.length > 0 ? selectedCells : getCellsFromRanges(ranges);
    };
    const getCellsFromEditor = editor => getCellsFromElementOrRanges(getRanges$1(editor.selection.getSel()), SugarElement.fromDom(editor.getBody()));
    const getClosestTable = (cell, isRoot) => ancestor$3(cell, 'table', isRoot);

    const getStartNode = rng => {
      const sc = rng.startContainer, so = rng.startOffset;
      if (isText$a(sc)) {
        return so === 0 ? Optional.some(SugarElement.fromDom(sc)) : Optional.none();
      } else {
        return Optional.from(sc.childNodes[so]).map(SugarElement.fromDom);
      }
    };
    const getEndNode = rng => {
      const ec = rng.endContainer, eo = rng.endOffset;
      if (isText$a(ec)) {
        return eo === ec.data.length ? Optional.some(SugarElement.fromDom(ec)) : Optional.none();
      } else {
        return Optional.from(ec.childNodes[eo - 1]).map(SugarElement.fromDom);
      }
    };
    const getFirstChildren = node => {
      return firstChild(node).fold(constant([node]), child => {
        return [node].concat(getFirstChildren(child));
      });
    };
    const getLastChildren = node => {
      return lastChild(node).fold(constant([node]), child => {
        if (name(child) === 'br') {
          return prevSibling(child).map(sibling => {
            return [node].concat(getLastChildren(sibling));
          }).getOr([]);
        } else {
          return [node].concat(getLastChildren(child));
        }
      });
    };
    const hasAllContentsSelected = (elm, rng) => {
      return lift2(getStartNode(rng), getEndNode(rng), (startNode, endNode) => {
        const start = find$2(getFirstChildren(elm), curry(eq, startNode));
        const end = find$2(getLastChildren(elm), curry(eq, endNode));
        return start.isSome() && end.isSome();
      }).getOr(false);
    };
    const moveEndPoint = (dom, rng, node, start) => {
      const root = node;
      const walker = new DomTreeWalker(node, root);
      const moveCaretBeforeOnEnterElementsMap = filter$4(dom.schema.getMoveCaretBeforeOnEnterElements(), (_, name) => !contains$2([
        'td',
        'th',
        'table'
      ], name.toLowerCase()));
      let currentNode = node;
      do {
        if (isText$a(currentNode) && Tools.trim(currentNode.data).length !== 0) {
          if (start) {
            rng.setStart(currentNode, 0);
          } else {
            rng.setEnd(currentNode, currentNode.data.length);
          }
          return;
        }
        if (moveCaretBeforeOnEnterElementsMap[currentNode.nodeName]) {
          if (start) {
            rng.setStartBefore(currentNode);
          } else {
            if (currentNode.nodeName === 'BR') {
              rng.setEndBefore(currentNode);
            } else {
              rng.setEndAfter(currentNode);
            }
          }
          return;
        }
      } while (currentNode = start ? walker.next() : walker.prev());
      if (root.nodeName === 'BODY') {
        if (start) {
          rng.setStart(root, 0);
        } else {
          rng.setEnd(root, root.childNodes.length);
        }
      }
    };
    const hasAnyRanges = editor => {
      const sel = editor.selection.getSel();
      return isNonNullable(sel) && sel.rangeCount > 0;
    };
    const runOnRanges = (editor, executor) => {
      const fakeSelectionNodes = getCellsFromEditor(editor);
      if (fakeSelectionNodes.length > 0) {
        each$e(fakeSelectionNodes, elem => {
          const node = elem.dom;
          const fakeNodeRng = editor.dom.createRng();
          fakeNodeRng.setStartBefore(node);
          fakeNodeRng.setEndAfter(node);
          executor(fakeNodeRng, true);
        });
      } else {
        executor(editor.selection.getRng(), false);
      }
    };
    const preserve = (selection, fillBookmark, executor) => {
      const bookmark = getPersistentBookmark(selection, fillBookmark);
      executor(bookmark);
      selection.moveToBookmark(bookmark);
    };

    const isNode = node => isNumber(node === null || node === void 0 ? void 0 : node.nodeType);
    const isElementNode$1 = node => isElement$6(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus$2(node);
    const isElementDirectlySelected = (dom, node) => {
      if (isElementNode$1(node) && !/^(TD|TH)$/.test(node.nodeName)) {
        const selectedAttr = dom.getAttrib(node, 'data-mce-selected');
        const value = parseInt(selectedAttr, 10);
        return !isNaN(value) && value > 0;
      } else {
        return false;
      }
    };
    const isEditable$2 = elm => elm.isContentEditable === true;
    const preserveSelection = (editor, action, shouldMoveStart) => {
      const {selection, dom} = editor;
      const selectedNodeBeforeAction = selection.getNode();
      const isSelectedBeforeNodeNoneditable = isContentEditableFalse$b(selectedNodeBeforeAction);
      preserve(selection, true, () => {
        action();
      });
      const isBeforeNodeStillNoneditable = isSelectedBeforeNodeNoneditable && isContentEditableFalse$b(selectedNodeBeforeAction);
      if (isBeforeNodeStillNoneditable && dom.isChildOf(selectedNodeBeforeAction, editor.getBody())) {
        editor.selection.select(selectedNodeBeforeAction);
      } else if (shouldMoveStart(selection.getStart())) {
        moveStartToNearestText(dom, selection);
      }
    };
    const moveStartToNearestText = (dom, selection) => {
      var _a, _b;
      const rng = selection.getRng();
      const {startContainer, startOffset} = rng;
      const selectedNode = selection.getNode();
      if (isElementDirectlySelected(dom, selectedNode)) {
        return;
      }
      if (isElement$6(startContainer)) {
        const nodes = startContainer.childNodes;
        const root = dom.getRoot();
        let walker;
        if (startOffset < nodes.length) {
          const startNode = nodes[startOffset];
          walker = new DomTreeWalker(startNode, (_a = dom.getParent(startNode, dom.isBlock)) !== null && _a !== void 0 ? _a : root);
        } else {
          const startNode = nodes[nodes.length - 1];
          walker = new DomTreeWalker(startNode, (_b = dom.getParent(startNode, dom.isBlock)) !== null && _b !== void 0 ? _b : root);
          walker.next(true);
        }
        for (let node = walker.current(); node; node = walker.next()) {
          if (dom.getContentEditable(node) === 'false') {
            return;
          } else if (isText$a(node) && !isWhiteSpaceNode$1(node)) {
            rng.setStart(node, 0);
            selection.setRng(rng);
            return;
          }
        }
      }
    };
    const getNonWhiteSpaceSibling = (node, next, inc) => {
      if (node) {
        const nextName = next ? 'nextSibling' : 'previousSibling';
        for (node = inc ? node : node[nextName]; node; node = node[nextName]) {
          if (isElement$6(node) || !isWhiteSpaceNode$1(node)) {
            return node;
          }
        }
      }
      return undefined;
    };
    const isTextBlock$1 = (schema, node) => !!schema.getTextBlockElements()[node.nodeName.toLowerCase()] || isTransparentBlock(schema, node);
    const isValid = (ed, parent, child) => {
      return ed.schema.isValidChild(parent, child);
    };
    const isWhiteSpaceNode$1 = (node, allowSpaces = false) => {
      if (isNonNullable(node) && isText$a(node)) {
        const data = allowSpaces ? node.data.replace(/ /g, '\xA0') : node.data;
        return isWhitespaceText(data);
      } else {
        return false;
      }
    };
    const isEmptyTextNode$1 = node => {
      return isNonNullable(node) && isText$a(node) && node.length === 0;
    };
    const isWrapNoneditableTarget = (editor, node) => {
      const baseDataSelector = '[data-mce-cef-wrappable]';
      const formatNoneditableSelector = getFormatNoneditableSelector(editor);
      const selector = isEmpty$3(formatNoneditableSelector) ? baseDataSelector : `${ baseDataSelector },${ formatNoneditableSelector }`;
      return is$1(SugarElement.fromDom(node), selector);
    };
    const isWrappableNoneditable = (editor, node) => {
      const dom = editor.dom;
      return isElementNode$1(node) && dom.getContentEditable(node) === 'false' && isWrapNoneditableTarget(editor, node) && dom.select('[contenteditable="true"]', node).length === 0;
    };
    const replaceVars = (value, vars) => {
      if (isFunction(value)) {
        return value(vars);
      } else if (isNonNullable(vars)) {
        value = value.replace(/%(\w+)/g, (str, name) => {
          return vars[name] || str;
        });
      }
      return value;
    };
    const isEq$5 = (str1, str2) => {
      str1 = str1 || '';
      str2 = str2 || '';
      str1 = '' + (str1.nodeName || str1);
      str2 = '' + (str2.nodeName || str2);
      return str1.toLowerCase() === str2.toLowerCase();
    };
    const normalizeStyleValue = (value, name) => {
      if (isNullable(value)) {
        return null;
      } else {
        let strValue = String(value);
        if (name === 'color' || name === 'backgroundColor') {
          strValue = rgbaToHexString(strValue);
        }
        if (name === 'fontWeight' && value === 700) {
          strValue = 'bold';
        }
        if (name === 'fontFamily') {
          strValue = strValue.replace(/[\'\"]/g, '').replace(/,\s+/g, ',');
        }
        return strValue;
      }
    };
    const getStyle = (dom, node, name) => {
      const style = dom.getStyle(node, name);
      return normalizeStyleValue(style, name);
    };
    const getTextDecoration = (dom, node) => {
      let decoration;
      dom.getParent(node, n => {
        if (isElement$6(n)) {
          decoration = dom.getStyle(n, 'text-decoration');
          return !!decoration && decoration !== 'none';
        } else {
          return false;
        }
      });
      return decoration;
    };
    const getParents$2 = (dom, node, selector) => {
      return dom.getParents(node, selector, dom.getRoot());
    };
    const isFormatPredicate = (editor, formatName, predicate) => {
      const formats = editor.formatter.get(formatName);
      return isNonNullable(formats) && exists(formats, predicate);
    };
    const isVariableFormatName = (editor, formatName) => {
      const hasVariableValues = format => {
        const isVariableValue = val => isFunction(val) || val.length > 1 && val.charAt(0) === '%';
        return exists([
          'styles',
          'attributes'
        ], key => get$a(format, key).exists(field => {
          const fieldValues = isArray$1(field) ? field : values(field);
          return exists(fieldValues, isVariableValue);
        }));
      };
      return isFormatPredicate(editor, formatName, hasVariableValues);
    };
    const areSimilarFormats = (editor, formatName, otherFormatName) => {
      const validKeys = [
        'inline',
        'block',
        'selector',
        'attributes',
        'styles',
        'classes'
      ];
      const filterObj = format => filter$4(format, (_, key) => exists(validKeys, validKey => validKey === key));
      return isFormatPredicate(editor, formatName, fmt1 => {
        const filteredFmt1 = filterObj(fmt1);
        return isFormatPredicate(editor, otherFormatName, fmt2 => {
          const filteredFmt2 = filterObj(fmt2);
          return equal$1(filteredFmt1, filteredFmt2);
        });
      });
    };
    const isBlockFormat = format => hasNonNullableKey(format, 'block');
    const isWrappingBlockFormat = format => isBlockFormat(format) && format.wrapper === true;
    const isNonWrappingBlockFormat = format => isBlockFormat(format) && format.wrapper !== true;
    const isSelectorFormat = format => hasNonNullableKey(format, 'selector');
    const isInlineFormat = format => hasNonNullableKey(format, 'inline');
    const isMixedFormat = format => isSelectorFormat(format) && isInlineFormat(format) && is$2(get$a(format, 'mixed'), true);
    const shouldExpandToSelector = format => isSelectorFormat(format) && format.expand !== false && !isInlineFormat(format);

    const isBookmarkNode = isBookmarkNode$1;
    const getParents$1 = getParents$2;
    const isWhiteSpaceNode = isWhiteSpaceNode$1;
    const isTextBlock = isTextBlock$1;
    const isBogusBr = node => {
      return isBr$6(node) && node.getAttribute('data-mce-bogus') && !node.nextSibling;
    };
    const findParentContentEditable = (dom, node) => {
      let parent = node;
      while (parent) {
        if (isElement$6(parent) && dom.getContentEditable(parent)) {
          return dom.getContentEditable(parent) === 'false' ? parent : node;
        }
        parent = parent.parentNode;
      }
      return node;
    };
    const walkText = (start, node, offset, predicate) => {
      const str = node.data;
      if (start) {
        for (let i = offset; i > 0; i--) {
          if (predicate(str.charAt(i - 1))) {
            return i;
          }
        }
      } else {
        for (let i = offset; i < str.length; i++) {
          if (predicate(str.charAt(i))) {
            return i;
          }
        }
      }
      return -1;
    };
    const findSpace = (start, node, offset) => walkText(start, node, offset, c => isNbsp(c) || isWhiteSpace(c));
    const findContent = (start, node, offset) => walkText(start, node, offset, isContent);
    const findWordEndPoint = (dom, body, container, offset, start, includeTrailingSpaces) => {
      let lastTextNode;
      const rootNode = dom.getParent(container, dom.isBlock) || body;
      const walk = (container, offset, pred) => {
        const textSeeker = TextSeeker(dom);
        const walker = start ? textSeeker.backwards : textSeeker.forwards;
        return Optional.from(walker(container, offset, (text, textOffset) => {
          if (isBookmarkNode(text.parentNode)) {
            return -1;
          } else {
            lastTextNode = text;
            return pred(start, text, textOffset);
          }
        }, rootNode));
      };
      const spaceResult = walk(container, offset, findSpace);
      return spaceResult.bind(result => includeTrailingSpaces ? walk(result.container, result.offset + (start ? -1 : 0), findContent) : Optional.some(result)).orThunk(() => lastTextNode ? Optional.some({
        container: lastTextNode,
        offset: start ? 0 : lastTextNode.length
      }) : Optional.none());
    };
    const findSelectorEndPoint = (dom, formatList, rng, container, siblingName) => {
      const sibling = container[siblingName];
      if (isText$a(container) && isEmpty$3(container.data) && sibling) {
        container = sibling;
      }
      const parents = getParents$1(dom, container);
      for (let i = 0; i < parents.length; i++) {
        for (let y = 0; y < formatList.length; y++) {
          const curFormat = formatList[y];
          if (isNonNullable(curFormat.collapsed) && curFormat.collapsed !== rng.collapsed) {
            continue;
          }
          if (isSelectorFormat(curFormat) && dom.is(parents[i], curFormat.selector)) {
            return parents[i];
          }
        }
      }
      return container;
    };
    const findBlockEndPoint = (dom, formatList, container, siblingName) => {
      var _a;
      let node = container;
      const root = dom.getRoot();
      const format = formatList[0];
      if (isBlockFormat(format)) {
        node = format.wrapper ? null : dom.getParent(container, format.block, root);
      }
      if (!node) {
        const scopeRoot = (_a = dom.getParent(container, 'LI,TD,TH')) !== null && _a !== void 0 ? _a : root;
        node = dom.getParent(isText$a(container) ? container.parentNode : container, node => node !== root && isTextBlock(dom.schema, node), scopeRoot);
      }
      if (node && isBlockFormat(format) && format.wrapper) {
        node = getParents$1(dom, node, 'ul,ol').reverse()[0] || node;
      }
      if (!node) {
        node = container;
        while (node && node[siblingName] && !dom.isBlock(node[siblingName])) {
          node = node[siblingName];
          if (isEq$5(node, 'br')) {
            break;
          }
        }
      }
      return node || container;
    };
    const isAtBlockBoundary$1 = (dom, root, container, siblingName) => {
      const parent = container.parentNode;
      if (isNonNullable(container[siblingName])) {
        return false;
      } else if (parent === root || isNullable(parent) || dom.isBlock(parent)) {
        return true;
      } else {
        return isAtBlockBoundary$1(dom, root, parent, siblingName);
      }
    };
    const findParentContainer = (dom, formatList, container, offset, start) => {
      let parent = container;
      const siblingName = start ? 'previousSibling' : 'nextSibling';
      const root = dom.getRoot();
      if (isText$a(container) && !isWhiteSpaceNode(container)) {
        if (start ? offset > 0 : offset < container.data.length) {
          return container;
        }
      }
      while (parent) {
        if (!formatList[0].block_expand && dom.isBlock(parent)) {
          return parent;
        }
        for (let sibling = parent[siblingName]; sibling; sibling = sibling[siblingName]) {
          const allowSpaces = isText$a(sibling) && !isAtBlockBoundary$1(dom, root, sibling, siblingName);
          if (!isBookmarkNode(sibling) && !isBogusBr(sibling) && !isWhiteSpaceNode(sibling, allowSpaces)) {
            return parent;
          }
        }
        if (parent === root || parent.parentNode === root) {
          container = parent;
          break;
        }
        parent = parent.parentNode;
      }
      return container;
    };
    const isSelfOrParentBookmark = container => isBookmarkNode(container.parentNode) || isBookmarkNode(container);
    const expandRng = (dom, rng, formatList, includeTrailingSpace = false) => {
      let {startContainer, startOffset, endContainer, endOffset} = rng;
      const format = formatList[0];
      if (isElement$6(startContainer) && startContainer.hasChildNodes()) {
        startContainer = getNode$1(startContainer, startOffset);
        if (isText$a(startContainer)) {
          startOffset = 0;
        }
      }
      if (isElement$6(endContainer) && endContainer.hasChildNodes()) {
        endContainer = getNode$1(endContainer, rng.collapsed ? endOffset : endOffset - 1);
        if (isText$a(endContainer)) {
          endOffset = endContainer.data.length;
        }
      }
      startContainer = findParentContentEditable(dom, startContainer);
      endContainer = findParentContentEditable(dom, endContainer);
      if (isSelfOrParentBookmark(startContainer)) {
        startContainer = isBookmarkNode(startContainer) ? startContainer : startContainer.parentNode;
        if (rng.collapsed) {
          startContainer = startContainer.previousSibling || startContainer;
        } else {
          startContainer = startContainer.nextSibling || startContainer;
        }
        if (isText$a(startContainer)) {
          startOffset = rng.collapsed ? startContainer.length : 0;
        }
      }
      if (isSelfOrParentBookmark(endContainer)) {
        endContainer = isBookmarkNode(endContainer) ? endContainer : endContainer.parentNode;
        if (rng.collapsed) {
          endContainer = endContainer.nextSibling || endContainer;
        } else {
          endContainer = endContainer.previousSibling || endContainer;
        }
        if (isText$a(endContainer)) {
          endOffset = rng.collapsed ? 0 : endContainer.length;
        }
      }
      if (rng.collapsed) {
        const startPoint = findWordEndPoint(dom, dom.getRoot(), startContainer, startOffset, true, includeTrailingSpace);
        startPoint.each(({container, offset}) => {
          startContainer = container;
          startOffset = offset;
        });
        const endPoint = findWordEndPoint(dom, dom.getRoot(), endContainer, endOffset, false, includeTrailingSpace);
        endPoint.each(({container, offset}) => {
          endContainer = container;
          endOffset = offset;
        });
      }
      if (isInlineFormat(format) || format.block_expand) {
        if (!isInlineFormat(format) || (!isText$a(startContainer) || startOffset === 0)) {
          startContainer = findParentContainer(dom, formatList, startContainer, startOffset, true);
        }
        if (!isInlineFormat(format) || (!isText$a(endContainer) || endOffset === endContainer.data.length)) {
          endContainer = findParentContainer(dom, formatList, endContainer, endOffset, false);
        }
      }
      if (shouldExpandToSelector(format)) {
        startContainer = findSelectorEndPoint(dom, formatList, rng, startContainer, 'previousSibling');
        endContainer = findSelectorEndPoint(dom, formatList, rng, endContainer, 'nextSibling');
      }
      if (isBlockFormat(format) || isSelectorFormat(format)) {
        startContainer = findBlockEndPoint(dom, formatList, startContainer, 'previousSibling');
        endContainer = findBlockEndPoint(dom, formatList, endContainer, 'nextSibling');
        if (isBlockFormat(format)) {
          if (!dom.isBlock(startContainer)) {
            startContainer = findParentContainer(dom, formatList, startContainer, startOffset, true);
          }
          if (!dom.isBlock(endContainer)) {
            endContainer = findParentContainer(dom, formatList, endContainer, endOffset, false);
          }
        }
      }
      if (isElement$6(startContainer) && startContainer.parentNode) {
        startOffset = dom.nodeIndex(startContainer);
        startContainer = startContainer.parentNode;
      }
      if (isElement$6(endContainer) && endContainer.parentNode) {
        endOffset = dom.nodeIndex(endContainer) + 1;
        endContainer = endContainer.parentNode;
      }
      return {
        startContainer,
        startOffset,
        endContainer,
        endOffset
      };
    };

    const walk$3 = (dom, rng, callback) => {
      var _a;
      const startOffset = rng.startOffset;
      const startContainer = getNode$1(rng.startContainer, startOffset);
      const endOffset = rng.endOffset;
      const endContainer = getNode$1(rng.endContainer, endOffset - 1);
      const exclude = nodes => {
        const firstNode = nodes[0];
        if (isText$a(firstNode) && firstNode === startContainer && startOffset >= firstNode.data.length) {
          nodes.splice(0, 1);
        }
        const lastNode = nodes[nodes.length - 1];
        if (endOffset === 0 && nodes.length > 0 && lastNode === endContainer && isText$a(lastNode)) {
          nodes.splice(nodes.length - 1, 1);
        }
        return nodes;
      };
      const collectSiblings = (node, name, endNode) => {
        const siblings = [];
        for (; node && node !== endNode; node = node[name]) {
          siblings.push(node);
        }
        return siblings;
      };
      const findEndPoint = (node, root) => dom.getParent(node, node => node.parentNode === root, root);
      const walkBoundary = (startNode, endNode, next) => {
        const siblingName = next ? 'nextSibling' : 'previousSibling';
        for (let node = startNode, parent = node.parentNode; node && node !== endNode; node = parent) {
          parent = node.parentNode;
          const siblings = collectSiblings(node === startNode ? node : node[siblingName], siblingName);
          if (siblings.length) {
            if (!next) {
              siblings.reverse();
            }
            callback(exclude(siblings));
          }
        }
      };
      if (startContainer === endContainer) {
        return callback(exclude([startContainer]));
      }
      const ancestor = (_a = dom.findCommonAncestor(startContainer, endContainer)) !== null && _a !== void 0 ? _a : dom.getRoot();
      if (dom.isChildOf(startContainer, endContainer)) {
        return walkBoundary(startContainer, ancestor, true);
      }
      if (dom.isChildOf(endContainer, startContainer)) {
        return walkBoundary(endContainer, ancestor);
      }
      const startPoint = findEndPoint(startContainer, ancestor) || startContainer;
      const endPoint = findEndPoint(endContainer, ancestor) || endContainer;
      walkBoundary(startContainer, startPoint, true);
      const siblings = collectSiblings(startPoint === startContainer ? startPoint : startPoint.nextSibling, 'nextSibling', endPoint === endContainer ? endPoint.nextSibling : endPoint);
      if (siblings.length) {
        callback(exclude(siblings));
      }
      walkBoundary(endContainer, endPoint);
    };

    const validBlocks = [
      'pre[class*=language-][contenteditable="false"]',
      'figure.image',
      'div[data-ephox-embed-iri]',
      'div.tiny-pageembed',
      'div.mce-toc',
      'div[data-mce-toc]'
    ];
    const isZeroWidth = elem => isText$b(elem) && get$3(elem) === ZWSP$1;
    const context = (editor, elem, wrapName, nodeName) => parent(elem).fold(() => 'skipping', parent => {
      if (nodeName === 'br' || isZeroWidth(elem)) {
        return 'valid';
      } else if (isAnnotation(elem)) {
        return 'existing';
      } else if (isCaretNode(elem.dom)) {
        return 'caret';
      } else if (exists(validBlocks, selector => is$1(elem, selector))) {
        return 'valid-block';
      } else if (!isValid(editor, wrapName, nodeName) || !isValid(editor, name(parent), wrapName)) {
        return 'invalid-child';
      } else {
        return 'valid';
      }
    });

    const applyWordGrab = (editor, rng) => {
      const r = expandRng(editor.dom, rng, [{ inline: 'span' }]);
      rng.setStart(r.startContainer, r.startOffset);
      rng.setEnd(r.endContainer, r.endOffset);
      editor.selection.setRng(rng);
    };
    const applyAnnotation = (elem, masterUId, data, annotationName, decorate, directAnnotation) => {
      const {uid = masterUId, ...otherData} = data;
      add$2(elem, annotation());
      set$3(elem, `${ dataAnnotationId() }`, uid);
      set$3(elem, `${ dataAnnotation() }`, annotationName);
      const {attributes = {}, classes = []} = decorate(uid, otherData);
      setAll$1(elem, attributes);
      add(elem, classes);
      if (directAnnotation) {
        if (classes.length > 0) {
          set$3(elem, `${ dataAnnotationClasses() }`, classes.join(','));
        }
        const attributeNames = keys(attributes);
        if (attributeNames.length > 0) {
          set$3(elem, `${ dataAnnotationAttributes() }`, attributeNames.join(','));
        }
      }
    };
    const removeDirectAnnotation = elem => {
      remove$8(elem, annotation());
      remove$b(elem, `${ dataAnnotationId() }`);
      remove$b(elem, `${ dataAnnotation() }`);
      remove$b(elem, `${ dataAnnotationActive() }`);
      const customAttrNames = getOpt(elem, `${ dataAnnotationAttributes() }`).map(names => names.split(',')).getOr([]);
      const customClasses = getOpt(elem, `${ dataAnnotationClasses() }`).map(names => names.split(',')).getOr([]);
      each$e(customAttrNames, name => remove$b(elem, name));
      remove$5(elem, customClasses);
      remove$b(elem, `${ dataAnnotationClasses() }`);
      remove$b(elem, `${ dataAnnotationAttributes() }`);
    };
    const makeAnnotation = (eDoc, uid, data, annotationName, decorate) => {
      const master = SugarElement.fromTag('span', eDoc);
      applyAnnotation(master, uid, data, annotationName, decorate, false);
      return master;
    };
    const annotate = (editor, rng, uid, annotationName, decorate, data) => {
      const newWrappers = [];
      const master = makeAnnotation(editor.getDoc(), uid, data, annotationName, decorate);
      const wrapper = value$2();
      const finishWrapper = () => {
        wrapper.clear();
      };
      const getOrOpenWrapper = () => wrapper.get().getOrThunk(() => {
        const nu = shallow$1(master);
        newWrappers.push(nu);
        wrapper.set(nu);
        return nu;
      });
      const processElements = elems => {
        each$e(elems, processElement);
      };
      const processElement = elem => {
        const ctx = context(editor, elem, 'span', name(elem));
        switch (ctx) {
        case 'invalid-child': {
            finishWrapper();
            const children = children$1(elem);
            processElements(children);
            finishWrapper();
            break;
          }
        case 'valid-block': {
            finishWrapper();
            applyAnnotation(elem, uid, data, annotationName, decorate, true);
            break;
          }
        case 'valid': {
            const w = getOrOpenWrapper();
            wrap$2(elem, w);
            break;
          }
        }
      };
      const processNodes = nodes => {
        const elems = map$3(nodes, SugarElement.fromDom);
        processElements(elems);
      };
      walk$3(editor.dom, rng, nodes => {
        finishWrapper();
        processNodes(nodes);
      });
      return newWrappers;
    };
    const annotateWithBookmark = (editor, name, settings, data) => {
      editor.undoManager.transact(() => {
        const selection = editor.selection;
        const initialRng = selection.getRng();
        const hasFakeSelection = getCellsFromEditor(editor).length > 0;
        const masterUid = generate$1('mce-annotation');
        if (initialRng.collapsed && !hasFakeSelection) {
          applyWordGrab(editor, initialRng);
        }
        if (selection.getRng().collapsed && !hasFakeSelection) {
          const wrapper = makeAnnotation(editor.getDoc(), masterUid, data, name, settings.decorate);
          set$1(wrapper, nbsp);
          selection.getRng().insertNode(wrapper.dom);
          selection.select(wrapper.dom);
        } else {
          preserve(selection, false, () => {
            runOnRanges(editor, selectionRng => {
              annotate(editor, selectionRng, masterUid, name, settings.decorate, data);
            });
          });
        }
      });
    };

    const Annotator = editor => {
      const registry = create$c();
      setup$w(editor, registry);
      const changes = setup$x(editor, registry);
      const isSpan = isTag('span');
      const removeAnnotations = elements => {
        each$e(elements, element => {
          if (isSpan(element)) {
            unwrap(element);
          } else {
            removeDirectAnnotation(element);
          }
        });
      };
      return {
        register: (name, settings) => {
          registry.register(name, settings);
        },
        annotate: (name, data) => {
          registry.lookup(name).each(settings => {
            annotateWithBookmark(editor, name, settings, data);
          });
        },
        annotationChanged: (name, callback) => {
          changes.addListener(name, callback);
        },
        remove: name => {
          identify(editor, Optional.some(name)).each(({elements}) => {
            const bookmark = editor.selection.getBookmark();
            removeAnnotations(elements);
            editor.selection.moveToBookmark(bookmark);
          });
        },
        removeAll: name => {
          const bookmark = editor.selection.getBookmark();
          each$d(findAll(editor, name), (elements, _) => {
            removeAnnotations(elements);
          });
          editor.selection.moveToBookmark(bookmark);
        },
        getAll: name => {
          const directory = findAll(editor, name);
          return map$2(directory, elems => map$3(elems, elem => elem.dom));
        }
      };
    };

    const BookmarkManager = selection => {
      return {
        getBookmark: curry(getBookmark$1, selection),
        moveToBookmark: curry(moveToBookmark, selection)
      };
    };
    BookmarkManager.isBookmarkNode = isBookmarkNode$1;

    const isXYWithinRange = (clientX, clientY, range) => {
      if (range.collapsed) {
        return false;
      } else {
        return exists(range.getClientRects(), rect => containsXY(rect, clientX, clientY));
      }
    };

    const firePreProcess = (editor, args) => editor.dispatch('PreProcess', args);
    const firePostProcess = (editor, args) => editor.dispatch('PostProcess', args);
    const fireRemove = editor => {
      editor.dispatch('remove');
    };
    const fireDetach = editor => {
      editor.dispatch('detach');
    };
    const fireSwitchMode = (editor, mode) => {
      editor.dispatch('SwitchMode', { mode });
    };
    const fireObjectResizeStart = (editor, target, width, height, origin) => {
      editor.dispatch('ObjectResizeStart', {
        target,
        width,
        height,
        origin
      });
    };
    const fireObjectResized = (editor, target, width, height, origin) => {
      editor.dispatch('ObjectResized', {
        target,
        width,
        height,
        origin
      });
    };
    const firePreInit = editor => {
      editor.dispatch('PreInit');
    };
    const firePostRender = editor => {
      editor.dispatch('PostRender');
    };
    const fireInit = editor => {
      editor.dispatch('Init');
    };
    const firePlaceholderToggle = (editor, state) => {
      editor.dispatch('PlaceholderToggle', { state });
    };
    const fireError = (editor, errorType, error) => {
      editor.dispatch(errorType, error);
    };
    const fireFormatApply = (editor, format, node, vars) => {
      editor.dispatch('FormatApply', {
        format,
        node,
        vars
      });
    };
    const fireFormatRemove = (editor, format, node, vars) => {
      editor.dispatch('FormatRemove', {
        format,
        node,
        vars
      });
    };
    const fireBeforeSetContent = (editor, args) => editor.dispatch('BeforeSetContent', args);
    const fireSetContent = (editor, args) => editor.dispatch('SetContent', args);
    const fireBeforeGetContent = (editor, args) => editor.dispatch('BeforeGetContent', args);
    const fireGetContent = (editor, args) => editor.dispatch('GetContent', args);
    const fireAutocompleterStart = (editor, args) => {
      editor.dispatch('AutocompleterStart', args);
    };
    const fireAutocompleterUpdate = (editor, args) => {
      editor.dispatch('AutocompleterUpdate', args);
    };
    const fireAutocompleterEnd = editor => {
      editor.dispatch('AutocompleterEnd');
    };
    const firePastePreProcess = (editor, html, internal) => editor.dispatch('PastePreProcess', {
      content: html,
      internal
    });
    const firePastePostProcess = (editor, node, internal) => editor.dispatch('PastePostProcess', {
      node,
      internal
    });
    const firePastePlainTextToggle = (editor, state) => editor.dispatch('PastePlainTextToggle', { state });

    const VK = {
      BACKSPACE: 8,
      DELETE: 46,
      DOWN: 40,
      ENTER: 13,
      ESC: 27,
      LEFT: 37,
      RIGHT: 39,
      SPACEBAR: 32,
      TAB: 9,
      UP: 38,
      PAGE_UP: 33,
      PAGE_DOWN: 34,
      END: 35,
      HOME: 36,
      modifierPressed: e => {
        return e.shiftKey || e.ctrlKey || e.altKey || VK.metaKeyPressed(e);
      },
      metaKeyPressed: e => {
        return Env.os.isMacOS() || Env.os.isiOS() ? e.metaKey : e.ctrlKey && !e.altKey;
      }
    };

    const elementSelectionAttr = 'data-mce-selected';
    const controlElmSelector = 'table,img,figure.image,hr,video,span.mce-preview-object';
    const abs = Math.abs;
    const round$1 = Math.round;
    const resizeHandles = {
      nw: [
        0,
        0,
        -1,
        -1
      ],
      ne: [
        1,
        0,
        1,
        -1
      ],
      se: [
        1,
        1,
        1,
        1
      ],
      sw: [
        0,
        1,
        -1,
        1
      ]
    };
    const isTouchEvent = evt => evt.type === 'longpress' || evt.type.indexOf('touch') === 0;
    const ControlSelection = (selection, editor) => {
      const dom = editor.dom;
      const editableDoc = editor.getDoc();
      const rootDocument = document;
      const rootElement = editor.getBody();
      let selectedElm, selectedElmGhost, resizeHelper, selectedHandle, resizeBackdrop;
      let startX, startY, selectedElmX, selectedElmY, startW, startH, ratio, resizeStarted;
      let width;
      let height;
      let startScrollWidth;
      let startScrollHeight;
      const isImage = elm => isNonNullable(elm) && (isImg(elm) || dom.is(elm, 'figure.image'));
      const isMedia = elm => isMedia$2(elm) || dom.hasClass(elm, 'mce-preview-object');
      const isEventOnImageOutsideRange = (evt, range) => {
        if (isTouchEvent(evt)) {
          const touch = evt.touches[0];
          return isImage(evt.target) && !isXYWithinRange(touch.clientX, touch.clientY, range);
        } else {
          return isImage(evt.target) && !isXYWithinRange(evt.clientX, evt.clientY, range);
        }
      };
      const contextMenuSelectImage = evt => {
        const target = evt.target;
        if (isEventOnImageOutsideRange(evt, editor.selection.getRng()) && !evt.isDefaultPrevented()) {
          editor.selection.select(target);
        }
      };
      const getResizeTargets = elm => {
        if (dom.hasClass(elm, 'mce-preview-object') && isNonNullable(elm.firstElementChild)) {
          return [
            elm,
            elm.firstElementChild
          ];
        } else if (dom.is(elm, 'figure.image')) {
          return [elm.querySelector('img')];
        } else {
          return [elm];
        }
      };
      const isResizable = elm => {
        const selector = getObjectResizing(editor);
        if (!selector) {
          return false;
        }
        if (elm.getAttribute('data-mce-resize') === 'false') {
          return false;
        }
        if (elm === editor.getBody()) {
          return false;
        }
        if (dom.hasClass(elm, 'mce-preview-object') && isNonNullable(elm.firstElementChild)) {
          return is$1(SugarElement.fromDom(elm.firstElementChild), selector);
        } else {
          return is$1(SugarElement.fromDom(elm), selector);
        }
      };
      const createGhostElement = elm => {
        if (isMedia(elm)) {
          return dom.create('img', { src: Env.transparentSrc });
        } else {
          return elm.cloneNode(true);
        }
      };
      const setSizeProp = (element, name, value) => {
        if (isNonNullable(value)) {
          const targets = getResizeTargets(element);
          each$e(targets, target => {
            if (target.style[name] || !editor.schema.isValid(target.nodeName.toLowerCase(), name)) {
              dom.setStyle(target, name, value);
            } else {
              dom.setAttrib(target, name, '' + value);
            }
          });
        }
      };
      const setGhostElmSize = (ghostElm, width, height) => {
        setSizeProp(ghostElm, 'width', width);
        setSizeProp(ghostElm, 'height', height);
      };
      const resizeGhostElement = e => {
        let deltaX, deltaY, proportional;
        let resizeHelperX, resizeHelperY;
        deltaX = e.screenX - startX;
        deltaY = e.screenY - startY;
        width = deltaX * selectedHandle[2] + startW;
        height = deltaY * selectedHandle[3] + startH;
        width = width < 5 ? 5 : width;
        height = height < 5 ? 5 : height;
        if ((isImage(selectedElm) || isMedia(selectedElm)) && getResizeImgProportional(editor) !== false) {
          proportional = !VK.modifierPressed(e);
        } else {
          proportional = VK.modifierPressed(e);
        }
        if (proportional) {
          if (abs(deltaX) > abs(deltaY)) {
            height = round$1(width * ratio);
            width = round$1(height / ratio);
          } else {
            width = round$1(height / ratio);
            height = round$1(width * ratio);
          }
        }
        setGhostElmSize(selectedElmGhost, width, height);
        resizeHelperX = selectedHandle.startPos.x + deltaX;
        resizeHelperY = selectedHandle.startPos.y + deltaY;
        resizeHelperX = resizeHelperX > 0 ? resizeHelperX : 0;
        resizeHelperY = resizeHelperY > 0 ? resizeHelperY : 0;
        dom.setStyles(resizeHelper, {
          left: resizeHelperX,
          top: resizeHelperY,
          display: 'block'
        });
        resizeHelper.innerHTML = width + ' &times; ' + height;
        if (selectedHandle[2] < 0 && selectedElmGhost.clientWidth <= width) {
          dom.setStyle(selectedElmGhost, 'left', selectedElmX + (startW - width));
        }
        if (selectedHandle[3] < 0 && selectedElmGhost.clientHeight <= height) {
          dom.setStyle(selectedElmGhost, 'top', selectedElmY + (startH - height));
        }
        deltaX = rootElement.scrollWidth - startScrollWidth;
        deltaY = rootElement.scrollHeight - startScrollHeight;
        if (deltaX + deltaY !== 0) {
          dom.setStyles(resizeHelper, {
            left: resizeHelperX - deltaX,
            top: resizeHelperY - deltaY
          });
        }
        if (!resizeStarted) {
          fireObjectResizeStart(editor, selectedElm, startW, startH, 'corner-' + selectedHandle.name);
          resizeStarted = true;
        }
      };
      const endGhostResize = () => {
        const wasResizeStarted = resizeStarted;
        resizeStarted = false;
        if (wasResizeStarted) {
          setSizeProp(selectedElm, 'width', width);
          setSizeProp(selectedElm, 'height', height);
        }
        dom.unbind(editableDoc, 'mousemove', resizeGhostElement);
        dom.unbind(editableDoc, 'mouseup', endGhostResize);
        if (rootDocument !== editableDoc) {
          dom.unbind(rootDocument, 'mousemove', resizeGhostElement);
          dom.unbind(rootDocument, 'mouseup', endGhostResize);
        }
        dom.remove(selectedElmGhost);
        dom.remove(resizeHelper);
        dom.remove(resizeBackdrop);
        showResizeRect(selectedElm);
        if (wasResizeStarted) {
          fireObjectResized(editor, selectedElm, width, height, 'corner-' + selectedHandle.name);
          dom.setAttrib(selectedElm, 'style', dom.getAttrib(selectedElm, 'style'));
        }
        editor.nodeChanged();
      };
      const showResizeRect = targetElm => {
        unbindResizeHandleEvents();
        const position = dom.getPos(targetElm, rootElement);
        const selectedElmX = position.x;
        const selectedElmY = position.y;
        const rect = targetElm.getBoundingClientRect();
        const targetWidth = rect.width || rect.right - rect.left;
        const targetHeight = rect.height || rect.bottom - rect.top;
        if (selectedElm !== targetElm) {
          hideResizeRect();
          selectedElm = targetElm;
          width = height = 0;
        }
        const e = editor.dispatch('ObjectSelected', { target: targetElm });
        if (isResizable(targetElm) && !e.isDefaultPrevented()) {
          each$d(resizeHandles, (handle, name) => {
            const startDrag = e => {
              const target = getResizeTargets(selectedElm)[0];
              startX = e.screenX;
              startY = e.screenY;
              startW = target.clientWidth;
              startH = target.clientHeight;
              ratio = startH / startW;
              selectedHandle = handle;
              selectedHandle.name = name;
              selectedHandle.startPos = {
                x: targetWidth * handle[0] + selectedElmX,
                y: targetHeight * handle[1] + selectedElmY
              };
              startScrollWidth = rootElement.scrollWidth;
              startScrollHeight = rootElement.scrollHeight;
              resizeBackdrop = dom.add(rootElement, 'div', {
                'class': 'mce-resize-backdrop',
                'data-mce-bogus': 'all'
              });
              dom.setStyles(resizeBackdrop, {
                position: 'fixed',
                left: '0',
                top: '0',
                width: '100%',
                height: '100%'
              });
              selectedElmGhost = createGhostElement(selectedElm);
              dom.addClass(selectedElmGhost, 'mce-clonedresizable');
              dom.setAttrib(selectedElmGhost, 'data-mce-bogus', 'all');
              selectedElmGhost.contentEditable = 'false';
              dom.setStyles(selectedElmGhost, {
                left: selectedElmX,
                top: selectedElmY,
                margin: 0
              });
              setGhostElmSize(selectedElmGhost, targetWidth, targetHeight);
              selectedElmGhost.removeAttribute(elementSelectionAttr);
              rootElement.appendChild(selectedElmGhost);
              dom.bind(editableDoc, 'mousemove', resizeGhostElement);
              dom.bind(editableDoc, 'mouseup', endGhostResize);
              if (rootDocument !== editableDoc) {
                dom.bind(rootDocument, 'mousemove', resizeGhostElement);
                dom.bind(rootDocument, 'mouseup', endGhostResize);
              }
              resizeHelper = dom.add(rootElement, 'div', {
                'class': 'mce-resize-helper',
                'data-mce-bogus': 'all'
              }, startW + ' &times; ' + startH);
            };
            let handleElm = dom.get('mceResizeHandle' + name);
            if (handleElm) {
              dom.remove(handleElm);
            }
            handleElm = dom.add(rootElement, 'div', {
              'id': 'mceResizeHandle' + name,
              'data-mce-bogus': 'all',
              'class': 'mce-resizehandle',
              'unselectable': true,
              'style': 'cursor:' + name + '-resize; margin:0; padding:0'
            });
            dom.bind(handleElm, 'mousedown', e => {
              e.stopImmediatePropagation();
              e.preventDefault();
              startDrag(e);
            });
            handle.elm = handleElm;
            dom.setStyles(handleElm, {
              left: targetWidth * handle[0] + selectedElmX - handleElm.offsetWidth / 2,
              top: targetHeight * handle[1] + selectedElmY - handleElm.offsetHeight / 2
            });
          });
        } else {
          hideResizeRect(false);
        }
      };
      const throttledShowResizeRect = first$1(showResizeRect, 0);
      const hideResizeRect = (removeSelected = true) => {
        throttledShowResizeRect.cancel();
        unbindResizeHandleEvents();
        if (selectedElm && removeSelected) {
          selectedElm.removeAttribute(elementSelectionAttr);
        }
        each$d(resizeHandles, (value, name) => {
          const handleElm = dom.get('mceResizeHandle' + name);
          if (handleElm) {
            dom.unbind(handleElm);
            dom.remove(handleElm);
          }
        });
      };
      const isChildOrEqual = (node, parent) => dom.isChildOf(node, parent);
      const updateResizeRect = e => {
        if (resizeStarted || editor.removed || editor.composing) {
          return;
        }
        const targetElm = e.type === 'mousedown' ? e.target : selection.getNode();
        const controlElm = closest$3(SugarElement.fromDom(targetElm), controlElmSelector).map(e => e.dom).filter(e => dom.isEditable(e.parentElement)).getOrUndefined();
        const selectedValue = isNonNullable(controlElm) ? dom.getAttrib(controlElm, elementSelectionAttr, '1') : '1';
        each$e(dom.select(`img[${ elementSelectionAttr }],hr[${ elementSelectionAttr }]`), img => {
          img.removeAttribute(elementSelectionAttr);
        });
        if (isNonNullable(controlElm) && isChildOrEqual(controlElm, rootElement)) {
          disableGeckoResize();
          const startElm = selection.getStart(true);
          if (isChildOrEqual(startElm, controlElm) && isChildOrEqual(selection.getEnd(true), controlElm)) {
            dom.setAttrib(controlElm, elementSelectionAttr, selectedValue);
            throttledShowResizeRect.throttle(controlElm);
            return;
          }
        }
        hideResizeRect();
      };
      const unbindResizeHandleEvents = () => {
        each$d(resizeHandles, handle => {
          if (handle.elm) {
            dom.unbind(handle.elm);
            delete handle.elm;
          }
        });
      };
      const disableGeckoResize = () => {
        try {
          editor.getDoc().execCommand('enableObjectResizing', false, 'false');
        } catch (ex) {
        }
      };
      editor.on('init', () => {
        disableGeckoResize();
        editor.on('NodeChange ResizeEditor ResizeWindow ResizeContent drop', updateResizeRect);
        editor.on('keyup compositionend', e => {
          if (selectedElm && selectedElm.nodeName === 'TABLE') {
            updateResizeRect(e);
          }
        });
        editor.on('hide blur', hideResizeRect);
        editor.on('contextmenu longpress', contextMenuSelectImage, true);
      });
      editor.on('remove', unbindResizeHandleEvents);
      const destroy = () => {
        throttledShowResizeRect.cancel();
        selectedElm = selectedElmGhost = resizeBackdrop = null;
      };
      return {
        isResizable,
        showResizeRect,
        hideResizeRect,
        updateResizeRect,
        destroy
      };
    };

    const setStart = (rng, situ) => {
      situ.fold(e => {
        rng.setStartBefore(e.dom);
      }, (e, o) => {
        rng.setStart(e.dom, o);
      }, e => {
        rng.setStartAfter(e.dom);
      });
    };
    const setFinish = (rng, situ) => {
      situ.fold(e => {
        rng.setEndBefore(e.dom);
      }, (e, o) => {
        rng.setEnd(e.dom, o);
      }, e => {
        rng.setEndAfter(e.dom);
      });
    };
    const relativeToNative = (win, startSitu, finishSitu) => {
      const range = win.document.createRange();
      setStart(range, startSitu);
      setFinish(range, finishSitu);
      return range;
    };
    const exactToNative = (win, start, soffset, finish, foffset) => {
      const rng = win.document.createRange();
      rng.setStart(start.dom, soffset);
      rng.setEnd(finish.dom, foffset);
      return rng;
    };

    const adt$3 = Adt.generate([
      {
        ltr: [
          'start',
          'soffset',
          'finish',
          'foffset'
        ]
      },
      {
        rtl: [
          'start',
          'soffset',
          'finish',
          'foffset'
        ]
      }
    ]);
    const fromRange = (win, type, range) => type(SugarElement.fromDom(range.startContainer), range.startOffset, SugarElement.fromDom(range.endContainer), range.endOffset);
    const getRanges = (win, selection) => selection.match({
      domRange: rng => {
        return {
          ltr: constant(rng),
          rtl: Optional.none
        };
      },
      relative: (startSitu, finishSitu) => {
        return {
          ltr: cached(() => relativeToNative(win, startSitu, finishSitu)),
          rtl: cached(() => Optional.some(relativeToNative(win, finishSitu, startSitu)))
        };
      },
      exact: (start, soffset, finish, foffset) => {
        return {
          ltr: cached(() => exactToNative(win, start, soffset, finish, foffset)),
          rtl: cached(() => Optional.some(exactToNative(win, finish, foffset, start, soffset)))
        };
      }
    });
    const doDiagnose = (win, ranges) => {
      const rng = ranges.ltr();
      if (rng.collapsed) {
        const reversed = ranges.rtl().filter(rev => rev.collapsed === false);
        return reversed.map(rev => adt$3.rtl(SugarElement.fromDom(rev.endContainer), rev.endOffset, SugarElement.fromDom(rev.startContainer), rev.startOffset)).getOrThunk(() => fromRange(win, adt$3.ltr, rng));
      } else {
        return fromRange(win, adt$3.ltr, rng);
      }
    };
    const diagnose = (win, selection) => {
      const ranges = getRanges(win, selection);
      return doDiagnose(win, ranges);
    };
    adt$3.ltr;
    adt$3.rtl;

    const create$a = (start, soffset, finish, foffset) => ({
      start,
      soffset,
      finish,
      foffset
    });
    const SimRange = { create: create$a };

    const caretPositionFromPoint = (doc, x, y) => {
      var _a, _b;
      return Optional.from((_b = (_a = doc.dom).caretPositionFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x, y)).bind(pos => {
        if (pos.offsetNode === null) {
          return Optional.none();
        }
        const r = doc.dom.createRange();
        r.setStart(pos.offsetNode, pos.offset);
        r.collapse();
        return Optional.some(r);
      });
    };
    const caretRangeFromPoint = (doc, x, y) => {
      var _a, _b;
      return Optional.from((_b = (_a = doc.dom).caretRangeFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x, y));
    };
    const availableSearch = (() => {
      if (document.caretPositionFromPoint) {
        return caretPositionFromPoint;
      } else if (document.caretRangeFromPoint) {
        return caretRangeFromPoint;
      } else {
        return Optional.none;
      }
    })();
    const fromPoint$1 = (win, x, y) => {
      const doc = SugarElement.fromDom(win.document);
      return availableSearch(doc, x, y).map(rng => SimRange.create(SugarElement.fromDom(rng.startContainer), rng.startOffset, SugarElement.fromDom(rng.endContainer), rng.endOffset));
    };

    const adt$2 = Adt.generate([
      { before: ['element'] },
      {
        on: [
          'element',
          'offset'
        ]
      },
      { after: ['element'] }
    ]);
    const cata = (subject, onBefore, onOn, onAfter) => subject.fold(onBefore, onOn, onAfter);
    const getStart$2 = situ => situ.fold(identity, identity, identity);
    const before$1 = adt$2.before;
    const on = adt$2.on;
    const after$1 = adt$2.after;
    const Situ = {
      before: before$1,
      on,
      after: after$1,
      cata,
      getStart: getStart$2
    };

    const adt$1 = Adt.generate([
      { domRange: ['rng'] },
      {
        relative: [
          'startSitu',
          'finishSitu'
        ]
      },
      {
        exact: [
          'start',
          'soffset',
          'finish',
          'foffset'
        ]
      }
    ]);
    const exactFromRange = simRange => adt$1.exact(simRange.start, simRange.soffset, simRange.finish, simRange.foffset);
    const getStart$1 = selection => selection.match({
      domRange: rng => SugarElement.fromDom(rng.startContainer),
      relative: (startSitu, _finishSitu) => Situ.getStart(startSitu),
      exact: (start, _soffset, _finish, _foffset) => start
    });
    const domRange = adt$1.domRange;
    const relative = adt$1.relative;
    const exact = adt$1.exact;
    const getWin = selection => {
      const start = getStart$1(selection);
      return defaultView(start);
    };
    const range = SimRange.create;
    const SimSelection = {
      domRange,
      relative,
      exact,
      exactFromRange,
      getWin,
      range
    };

    const beforeSpecial = (element, offset) => {
      const name$1 = name(element);
      if ('input' === name$1) {
        return Situ.after(element);
      } else if (!contains$2([
          'br',
          'img'
        ], name$1)) {
        return Situ.on(element, offset);
      } else {
        return offset === 0 ? Situ.before(element) : Situ.after(element);
      }
    };
    const preprocessRelative = (startSitu, finishSitu) => {
      const start = startSitu.fold(Situ.before, beforeSpecial, Situ.after);
      const finish = finishSitu.fold(Situ.before, beforeSpecial, Situ.after);
      return SimSelection.relative(start, finish);
    };
    const preprocessExact = (start, soffset, finish, foffset) => {
      const startSitu = beforeSpecial(start, soffset);
      const finishSitu = beforeSpecial(finish, foffset);
      return SimSelection.relative(startSitu, finishSitu);
    };
    const preprocess = selection => selection.match({
      domRange: rng => {
        const start = SugarElement.fromDom(rng.startContainer);
        const finish = SugarElement.fromDom(rng.endContainer);
        return preprocessExact(start, rng.startOffset, finish, rng.endOffset);
      },
      relative: preprocessRelative,
      exact: preprocessExact
    });

    const fromElements = (elements, scope) => {
      const doc = scope || document;
      const fragment = doc.createDocumentFragment();
      each$e(elements, element => {
        fragment.appendChild(element.dom);
      });
      return SugarElement.fromDom(fragment);
    };

    const toNative = selection => {
      const win = SimSelection.getWin(selection).dom;
      const getDomRange = (start, soffset, finish, foffset) => exactToNative(win, start, soffset, finish, foffset);
      const filtered = preprocess(selection);
      return diagnose(win, filtered).match({
        ltr: getDomRange,
        rtl: getDomRange
      });
    };
    const getAtPoint = (win, x, y) => fromPoint$1(win, x, y);

    const fromPoint = (clientX, clientY, doc) => {
      const win = defaultView(SugarElement.fromDom(doc));
      return getAtPoint(win.dom, clientX, clientY).map(simRange => {
        const rng = doc.createRange();
        rng.setStart(simRange.start.dom, simRange.soffset);
        rng.setEnd(simRange.finish.dom, simRange.foffset);
        return rng;
      }).getOrUndefined();
    };

    const isEq$4 = (rng1, rng2) => {
      return isNonNullable(rng1) && isNonNullable(rng2) && (rng1.startContainer === rng2.startContainer && rng1.startOffset === rng2.startOffset) && (rng1.endContainer === rng2.endContainer && rng1.endOffset === rng2.endOffset);
    };

    const findParent = (node, rootNode, predicate) => {
      let currentNode = node;
      while (currentNode && currentNode !== rootNode) {
        if (predicate(currentNode)) {
          return currentNode;
        }
        currentNode = currentNode.parentNode;
      }
      return null;
    };
    const hasParent$1 = (node, rootNode, predicate) => findParent(node, rootNode, predicate) !== null;
    const hasParentWithName = (node, rootNode, name) => hasParent$1(node, rootNode, node => node.nodeName === name);
    const isCeFalseCaretContainer = (node, rootNode) => isCaretContainer$2(node) && !hasParent$1(node, rootNode, isCaretNode);
    const hasBrBeforeAfter = (dom, node, left) => {
      const parentNode = node.parentNode;
      if (parentNode) {
        const walker = new DomTreeWalker(node, dom.getParent(parentNode, dom.isBlock) || dom.getRoot());
        let currentNode;
        while (currentNode = walker[left ? 'prev' : 'next']()) {
          if (isBr$6(currentNode)) {
            return true;
          }
        }
      }
      return false;
    };
    const isPrevNode = (node, name) => {
      var _a;
      return ((_a = node.previousSibling) === null || _a === void 0 ? void 0 : _a.nodeName) === name;
    };
    const hasContentEditableFalseParent = (root, node) => {
      let currentNode = node;
      while (currentNode && currentNode !== root) {
        if (isContentEditableFalse$b(currentNode)) {
          return true;
        }
        currentNode = currentNode.parentNode;
      }
      return false;
    };
    const findTextNodeRelative = (dom, isAfterNode, collapsed, left, startNode) => {
      const body = dom.getRoot();
      const nonEmptyElementsMap = dom.schema.getNonEmptyElements();
      const parentNode = startNode.parentNode;
      let lastInlineElement;
      let node;
      if (!parentNode) {
        return Optional.none();
      }
      const parentBlockContainer = dom.getParent(parentNode, dom.isBlock) || body;
      if (left && isBr$6(startNode) && isAfterNode && dom.isEmpty(parentBlockContainer)) {
        return Optional.some(CaretPosition(parentNode, dom.nodeIndex(startNode)));
      }
      const walker = new DomTreeWalker(startNode, parentBlockContainer);
      while (node = walker[left ? 'prev' : 'next']()) {
        if (dom.getContentEditableParent(node) === 'false' || isCeFalseCaretContainer(node, body)) {
          return Optional.none();
        }
        if (isText$a(node) && node.data.length > 0) {
          if (!hasParentWithName(node, body, 'A')) {
            return Optional.some(CaretPosition(node, left ? node.data.length : 0));
          }
          return Optional.none();
        }
        if (dom.isBlock(node) || nonEmptyElementsMap[node.nodeName.toLowerCase()]) {
          return Optional.none();
        }
        lastInlineElement = node;
      }
      if (isComment(lastInlineElement)) {
        return Optional.none();
      }
      if (collapsed && lastInlineElement) {
        return Optional.some(CaretPosition(lastInlineElement, 0));
      }
      return Optional.none();
    };
    const normalizeEndPoint = (dom, collapsed, start, rng) => {
      const body = dom.getRoot();
      let node;
      let normalized = false;
      let container = start ? rng.startContainer : rng.endContainer;
      let offset = start ? rng.startOffset : rng.endOffset;
      const isAfterNode = isElement$6(container) && offset === container.childNodes.length;
      const nonEmptyElementsMap = dom.schema.getNonEmptyElements();
      let directionLeft = start;
      if (isCaretContainer$2(container)) {
        return Optional.none();
      }
      if (isElement$6(container) && offset > container.childNodes.length - 1) {
        directionLeft = false;
      }
      if (isDocument$1(container)) {
        container = body;
        offset = 0;
      }
      if (container === body) {
        if (directionLeft) {
          node = container.childNodes[offset > 0 ? offset - 1 : 0];
          if (node) {
            if (isCaretContainer$2(node)) {
              return Optional.none();
            }
            if (nonEmptyElementsMap[node.nodeName] || isTable$2(node)) {
              return Optional.none();
            }
          }
        }
        if (container.hasChildNodes()) {
          offset = Math.min(!directionLeft && offset > 0 ? offset - 1 : offset, container.childNodes.length - 1);
          container = container.childNodes[offset];
          offset = isText$a(container) && isAfterNode ? container.data.length : 0;
          if (!collapsed && container === body.lastChild && isTable$2(container)) {
            return Optional.none();
          }
          if (hasContentEditableFalseParent(body, container) || isCaretContainer$2(container)) {
            return Optional.none();
          }
          if (container.hasChildNodes() && !isTable$2(container)) {
            node = container;
            const walker = new DomTreeWalker(container, body);
            do {
              if (isContentEditableFalse$b(node) || isCaretContainer$2(node)) {
                normalized = false;
                break;
              }
              if (isText$a(node) && node.data.length > 0) {
                offset = directionLeft ? 0 : node.data.length;
                container = node;
                normalized = true;
                break;
              }
              if (nonEmptyElementsMap[node.nodeName.toLowerCase()] && !isTableCellOrCaption(node)) {
                offset = dom.nodeIndex(node);
                container = node.parentNode;
                if (!directionLeft) {
                  offset++;
                }
                normalized = true;
                break;
              }
            } while (node = directionLeft ? walker.next() : walker.prev());
          }
        }
      }
      if (collapsed) {
        if (isText$a(container) && offset === 0) {
          findTextNodeRelative(dom, isAfterNode, collapsed, true, container).each(pos => {
            container = pos.container();
            offset = pos.offset();
            normalized = true;
          });
        }
        if (isElement$6(container)) {
          node = container.childNodes[offset];
          if (!node) {
            node = container.childNodes[offset - 1];
          }
          if (node && isBr$6(node) && !isPrevNode(node, 'A') && !hasBrBeforeAfter(dom, node, false) && !hasBrBeforeAfter(dom, node, true)) {
            findTextNodeRelative(dom, isAfterNode, collapsed, true, node).each(pos => {
              container = pos.container();
              offset = pos.offset();
              normalized = true;
            });
          }
        }
      }
      if (directionLeft && !collapsed && isText$a(container) && offset === container.data.length) {
        findTextNodeRelative(dom, isAfterNode, collapsed, false, container).each(pos => {
          container = pos.container();
          offset = pos.offset();
          normalized = true;
        });
      }
      return normalized && container ? Optional.some(CaretPosition(container, offset)) : Optional.none();
    };
    const normalize$2 = (dom, rng) => {
      const collapsed = rng.collapsed, normRng = rng.cloneRange();
      const startPos = CaretPosition.fromRangeStart(rng);
      normalizeEndPoint(dom, collapsed, true, normRng).each(pos => {
        if (!collapsed || !CaretPosition.isAbove(startPos, pos)) {
          normRng.setStart(pos.container(), pos.offset());
        }
      });
      if (!collapsed) {
        normalizeEndPoint(dom, collapsed, false, normRng).each(pos => {
          normRng.setEnd(pos.container(), pos.offset());
        });
      }
      if (collapsed) {
        normRng.collapse(true);
      }
      return isEq$4(rng, normRng) ? Optional.none() : Optional.some(normRng);
    };

    const splitText = (node, offset) => {
      return node.splitText(offset);
    };
    const split = rng => {
      let startContainer = rng.startContainer, startOffset = rng.startOffset, endContainer = rng.endContainer, endOffset = rng.endOffset;
      if (startContainer === endContainer && isText$a(startContainer)) {
        if (startOffset > 0 && startOffset < startContainer.data.length) {
          endContainer = splitText(startContainer, startOffset);
          startContainer = endContainer.previousSibling;
          if (endOffset > startOffset) {
            endOffset = endOffset - startOffset;
            const newContainer = splitText(endContainer, endOffset).previousSibling;
            startContainer = endContainer = newContainer;
            endOffset = newContainer.data.length;
            startOffset = 0;
          } else {
            endOffset = 0;
          }
        }
      } else {
        if (isText$a(startContainer) && startOffset > 0 && startOffset < startContainer.data.length) {
          startContainer = splitText(startContainer, startOffset);
          startOffset = 0;
        }
        if (isText$a(endContainer) && endOffset > 0 && endOffset < endContainer.data.length) {
          const newContainer = splitText(endContainer, endOffset).previousSibling;
          endContainer = newContainer;
          endOffset = newContainer.data.length;
        }
      }
      return {
        startContainer,
        startOffset,
        endContainer,
        endOffset
      };
    };

    const RangeUtils = dom => {
      const walk = (rng, callback) => {
        return walk$3(dom, rng, callback);
      };
      const split$1 = split;
      const normalize = rng => {
        return normalize$2(dom, rng).fold(never, normalizedRng => {
          rng.setStart(normalizedRng.startContainer, normalizedRng.startOffset);
          rng.setEnd(normalizedRng.endContainer, normalizedRng.endOffset);
          return true;
        });
      };
      const expand = (rng, options = { type: 'word' }) => {
        if (options.type === 'word') {
          const rangeLike = expandRng(dom, rng, [{ inline: 'span' }]);
          const newRange = dom.createRng();
          newRange.setStart(rangeLike.startContainer, rangeLike.startOffset);
          newRange.setEnd(rangeLike.endContainer, rangeLike.endOffset);
          return newRange;
        }
        return rng;
      };
      return {
        walk,
        split: split$1,
        expand,
        normalize
      };
    };
    RangeUtils.compareRanges = isEq$4;
    RangeUtils.getCaretRangeFromPoint = fromPoint;
    RangeUtils.getSelectedNode = getSelectedNode;
    RangeUtils.getNode = getNode$1;

    const Dimension = (name, getOffset) => {
      const set = (element, h) => {
        if (!isNumber(h) && !h.match(/^[0-9]+$/)) {
          throw new Error(name + '.set accepts only positive integer values. Value was ' + h);
        }
        const dom = element.dom;
        if (isSupported(dom)) {
          dom.style[name] = h + 'px';
        }
      };
      const get = element => {
        const r = getOffset(element);
        if (r <= 0 || r === null) {
          const css = get$7(element, name);
          return parseFloat(css) || 0;
        }
        return r;
      };
      const getOuter = get;
      const aggregate = (element, properties) => foldl(properties, (acc, property) => {
        const val = get$7(element, property);
        const value = val === undefined ? 0 : parseInt(val, 10);
        return isNaN(value) ? acc : acc + value;
      }, 0);
      const max = (element, value, properties) => {
        const cumulativeInclusions = aggregate(element, properties);
        const absoluteMax = value > cumulativeInclusions ? value - cumulativeInclusions : 0;
        return absoluteMax;
      };
      return {
        set,
        get,
        getOuter,
        aggregate,
        max
      };
    };

    const api = Dimension('height', element => {
      const dom = element.dom;
      return inBody(element) ? dom.getBoundingClientRect().height : dom.offsetHeight;
    });
    const get$2 = element => api.get(element);

    const getDocument = () => SugarElement.fromDom(document);

    const walkUp = (navigation, doc) => {
      const frame = navigation.view(doc);
      return frame.fold(constant([]), f => {
        const parent = navigation.owner(f);
        const rest = walkUp(navigation, parent);
        return [f].concat(rest);
      });
    };
    const pathTo = (element, navigation) => {
      const d = navigation.owner(element);
      return walkUp(navigation, d);
    };

    const view = doc => {
      var _a;
      const element = doc.dom === document ? Optional.none() : Optional.from((_a = doc.dom.defaultView) === null || _a === void 0 ? void 0 : _a.frameElement);
      return element.map(SugarElement.fromDom);
    };
    const owner = element => documentOrOwner(element);

    var Navigation = /*#__PURE__*/Object.freeze({
        __proto__: null,
        view: view,
        owner: owner
    });

    const find = element => {
      const doc = getDocument();
      const scroll = get$5(doc);
      const frames = pathTo(element, Navigation);
      const offset = viewport(element);
      const r = foldr(frames, (b, a) => {
        const loc = viewport(a);
        return {
          left: b.left + loc.left,
          top: b.top + loc.top
        };
      }, {
        left: 0,
        top: 0
      });
      return SugarPosition(r.left + offset.left + scroll.left, r.top + offset.top + scroll.top);
    };

    const excludeFromDescend = element => name(element) === 'textarea';
    const fireScrollIntoViewEvent = (editor, data) => {
      const scrollEvent = editor.dispatch('ScrollIntoView', data);
      return scrollEvent.isDefaultPrevented();
    };
    const fireAfterScrollIntoViewEvent = (editor, data) => {
      editor.dispatch('AfterScrollIntoView', data);
    };
    const descend = (element, offset) => {
      const children = children$1(element);
      if (children.length === 0 || excludeFromDescend(element)) {
        return {
          element,
          offset
        };
      } else if (offset < children.length && !excludeFromDescend(children[offset])) {
        return {
          element: children[offset],
          offset: 0
        };
      } else {
        const last = children[children.length - 1];
        if (excludeFromDescend(last)) {
          return {
            element,
            offset
          };
        } else {
          if (name(last) === 'img') {
            return {
              element: last,
              offset: 1
            };
          } else if (isText$b(last)) {
            return {
              element: last,
              offset: get$3(last).length
            };
          } else {
            return {
              element: last,
              offset: children$1(last).length
            };
          }
        }
      }
    };
    const markerInfo = (element, cleanupFun) => {
      const pos = absolute(element);
      const height = get$2(element);
      return {
        element,
        bottom: pos.top + height,
        height,
        pos,
        cleanup: cleanupFun
      };
    };
    const createMarker$1 = (element, offset) => {
      const startPoint = descend(element, offset);
      const span = SugarElement.fromHtml('<span data-mce-bogus="all" style="display: inline-block;">' + ZWSP$1 + '</span>');
      before$3(startPoint.element, span);
      return markerInfo(span, () => remove$6(span));
    };
    const elementMarker = element => markerInfo(SugarElement.fromDom(element), noop);
    const withMarker = (editor, f, rng, alignToTop) => {
      preserveWith(editor, (_s, _e) => applyWithMarker(editor, f, rng, alignToTop), rng);
    };
    const withScrollEvents = (editor, doc, f, marker, alignToTop) => {
      const data = {
        elm: marker.element.dom,
        alignToTop
      };
      if (fireScrollIntoViewEvent(editor, data)) {
        return;
      }
      const scrollTop = get$5(doc).top;
      f(doc, scrollTop, marker, alignToTop);
      fireAfterScrollIntoViewEvent(editor, data);
    };
    const applyWithMarker = (editor, f, rng, alignToTop) => {
      const body = SugarElement.fromDom(editor.getBody());
      const doc = SugarElement.fromDom(editor.getDoc());
      reflow(body);
      const marker = createMarker$1(SugarElement.fromDom(rng.startContainer), rng.startOffset);
      withScrollEvents(editor, doc, f, marker, alignToTop);
      marker.cleanup();
    };
    const withElement = (editor, element, f, alignToTop) => {
      const doc = SugarElement.fromDom(editor.getDoc());
      withScrollEvents(editor, doc, f, elementMarker(element), alignToTop);
    };
    const preserveWith = (editor, f, rng) => {
      const startElement = rng.startContainer;
      const startOffset = rng.startOffset;
      const endElement = rng.endContainer;
      const endOffset = rng.endOffset;
      f(SugarElement.fromDom(startElement), SugarElement.fromDom(endElement));
      const newRng = editor.dom.createRng();
      newRng.setStart(startElement, startOffset);
      newRng.setEnd(endElement, endOffset);
      editor.selection.setRng(rng);
    };
    const scrollToMarker = (marker, alignToTop) => marker.element.dom.scrollIntoView({ block: alignToTop ? 'start' : 'end' });
    const intoWindowIfNeeded = (scrollTop, viewHeight, marker, alignToTop) => {
      const viewportBottom = viewHeight + scrollTop;
      const markerTop = marker.pos.top;
      const markerBottom = marker.bottom;
      const largerThanViewport = markerBottom - markerTop >= viewHeight;
      if (markerTop < scrollTop) {
        scrollToMarker(marker, alignToTop !== false);
      } else if (markerTop > viewportBottom) {
        const align = largerThanViewport ? alignToTop !== false : alignToTop === true;
        scrollToMarker(marker, align);
      } else if (markerBottom > viewportBottom && !largerThanViewport) {
        scrollToMarker(marker, alignToTop === true);
      }
    };
    const intoWindow = (doc, scrollTop, marker, alignToTop) => {
      const viewHeight = defaultView(doc).dom.innerHeight;
      intoWindowIfNeeded(scrollTop, viewHeight, marker, alignToTop);
    };
    const intoFrame = (doc, scrollTop, marker, alignToTop) => {
      const frameViewHeight = defaultView(doc).dom.innerHeight;
      intoWindowIfNeeded(scrollTop, frameViewHeight, marker, alignToTop);
      const op = find(marker.element);
      const viewportBounds = getBounds(window);
      if (op.top < viewportBounds.y) {
        intoView(marker.element, alignToTop !== false);
      } else if (op.top > viewportBounds.bottom) {
        intoView(marker.element, alignToTop === true);
      }
    };
    const rangeIntoWindow = (editor, rng, alignToTop) => withMarker(editor, intoWindow, rng, alignToTop);
    const elementIntoWindow = (editor, element, alignToTop) => withElement(editor, element, intoWindow, alignToTop);
    const rangeIntoFrame = (editor, rng, alignToTop) => withMarker(editor, intoFrame, rng, alignToTop);
    const elementIntoFrame = (editor, element, alignToTop) => withElement(editor, element, intoFrame, alignToTop);
    const scrollElementIntoView = (editor, element, alignToTop) => {
      const scroller = editor.inline ? elementIntoWindow : elementIntoFrame;
      scroller(editor, element, alignToTop);
    };
    const scrollRangeIntoView = (editor, rng, alignToTop) => {
      const scroller = editor.inline ? rangeIntoWindow : rangeIntoFrame;
      scroller(editor, rng, alignToTop);
    };

    const focus$1 = element => element.dom.focus();
    const hasFocus$1 = element => {
      const root = getRootNode(element).dom;
      return element.dom === root.activeElement;
    };
    const active$1 = (root = getDocument()) => Optional.from(root.dom.activeElement).map(SugarElement.fromDom);
    const search = element => active$1(getRootNode(element)).filter(e => element.dom.contains(e.dom));

    const clamp$1 = (offset, element) => {
      const max = isText$b(element) ? get$3(element).length : children$1(element).length + 1;
      if (offset > max) {
        return max;
      } else if (offset < 0) {
        return 0;
      }
      return offset;
    };
    const normalizeRng = rng => SimSelection.range(rng.start, clamp$1(rng.soffset, rng.start), rng.finish, clamp$1(rng.foffset, rng.finish));
    const isOrContains = (root, elm) => !isRestrictedNode(elm.dom) && (contains(root, elm) || eq(root, elm));
    const isRngInRoot = root => rng => isOrContains(root, rng.start) && isOrContains(root, rng.finish);
    const shouldStore = editor => editor.inline || Env.browser.isFirefox();
    const nativeRangeToSelectionRange = r => SimSelection.range(SugarElement.fromDom(r.startContainer), r.startOffset, SugarElement.fromDom(r.endContainer), r.endOffset);
    const readRange = win => {
      const selection = win.getSelection();
      const rng = !selection || selection.rangeCount === 0 ? Optional.none() : Optional.from(selection.getRangeAt(0));
      return rng.map(nativeRangeToSelectionRange);
    };
    const getBookmark = root => {
      const win = defaultView(root);
      return readRange(win.dom).filter(isRngInRoot(root));
    };
    const validate = (root, bookmark) => Optional.from(bookmark).filter(isRngInRoot(root)).map(normalizeRng);
    const bookmarkToNativeRng = bookmark => {
      const rng = document.createRange();
      try {
        rng.setStart(bookmark.start.dom, bookmark.soffset);
        rng.setEnd(bookmark.finish.dom, bookmark.foffset);
        return Optional.some(rng);
      } catch (_) {
        return Optional.none();
      }
    };
    const store = editor => {
      const newBookmark = shouldStore(editor) ? getBookmark(SugarElement.fromDom(editor.getBody())) : Optional.none();
      editor.bookmark = newBookmark.isSome() ? newBookmark : editor.bookmark;
    };
    const getRng = editor => {
      const bookmark = editor.bookmark ? editor.bookmark : Optional.none();
      return bookmark.bind(x => validate(SugarElement.fromDom(editor.getBody()), x)).bind(bookmarkToNativeRng);
    };
    const restore = editor => {
      getRng(editor).each(rng => editor.selection.setRng(rng));
    };

    const isEditorUIElement$1 = elm => {
      const className = elm.className.toString();
      return className.indexOf('tox-') !== -1 || className.indexOf('mce-') !== -1;
    };
    const FocusManager = { isEditorUIElement: isEditorUIElement$1 };

    const wrappedSetTimeout = (callback, time) => {
      if (!isNumber(time)) {
        time = 0;
      }
      return setTimeout(callback, time);
    };
    const wrappedSetInterval = (callback, time) => {
      if (!isNumber(time)) {
        time = 0;
      }
      return setInterval(callback, time);
    };
    const Delay = {
      setEditorTimeout: (editor, callback, time) => {
        return wrappedSetTimeout(() => {
          if (!editor.removed) {
            callback();
          }
        }, time);
      },
      setEditorInterval: (editor, callback, time) => {
        const timer = wrappedSetInterval(() => {
          if (!editor.removed) {
            callback();
          } else {
            clearInterval(timer);
          }
        }, time);
        return timer;
      }
    };

    const isManualNodeChange = e => {
      return e.type === 'nodechange' && e.selectionChange;
    };
    const registerPageMouseUp = (editor, throttledStore) => {
      const mouseUpPage = () => {
        throttledStore.throttle();
      };
      DOMUtils.DOM.bind(document, 'mouseup', mouseUpPage);
      editor.on('remove', () => {
        DOMUtils.DOM.unbind(document, 'mouseup', mouseUpPage);
      });
    };
    const registerMouseUp = (editor, throttledStore) => {
      editor.on('mouseup touchend', _e => {
        throttledStore.throttle();
      });
    };
    const registerEditorEvents = (editor, throttledStore) => {
      registerMouseUp(editor, throttledStore);
      editor.on('keyup NodeChange AfterSetSelectionRange', e => {
        if (!isManualNodeChange(e)) {
          store(editor);
        }
      });
    };
    const register$6 = editor => {
      const throttledStore = first$1(() => {
        store(editor);
      }, 0);
      editor.on('init', () => {
        if (editor.inline) {
          registerPageMouseUp(editor, throttledStore);
        }
        registerEditorEvents(editor, throttledStore);
      });
      editor.on('remove', () => {
        throttledStore.cancel();
      });
    };

    let documentFocusInHandler;
    const DOM$9 = DOMUtils.DOM;
    const isEditorUIElement = elm => {
      return isElement$6(elm) && FocusManager.isEditorUIElement(elm);
    };
    const isEditorContentAreaElement = elm => {
      const classList = elm.classList;
      if (classList !== undefined) {
        return classList.contains('tox-edit-area') || classList.contains('tox-edit-area__iframe') || classList.contains('mce-content-body');
      } else {
        return false;
      }
    };
    const isUIElement = (editor, elm) => {
      const customSelector = getCustomUiSelector(editor);
      const parent = DOM$9.getParent(elm, elm => {
        return isEditorUIElement(elm) || (customSelector ? editor.dom.is(elm, customSelector) : false);
      });
      return parent !== null;
    };
    const getActiveElement = editor => {
      try {
        const root = getRootNode(SugarElement.fromDom(editor.getElement()));
        return active$1(root).fold(() => document.body, x => x.dom);
      } catch (ex) {
        return document.body;
      }
    };
    const registerEvents$1 = (editorManager, e) => {
      const editor = e.editor;
      register$6(editor);
      const toggleContentAreaOnFocus = (editor, fn) => {
        if (shouldHighlightOnFocus(editor) && editor.inline !== true) {
          const contentArea = SugarElement.fromDom(editor.getContainer());
          fn(contentArea, 'tox-edit-focus');
        }
      };
      editor.on('focusin', () => {
        const focusedEditor = editorManager.focusedEditor;
        if (isEditorContentAreaElement(getActiveElement(editor))) {
          toggleContentAreaOnFocus(editor, add$2);
        }
        if (focusedEditor !== editor) {
          if (focusedEditor) {
            focusedEditor.dispatch('blur', { focusedEditor: editor });
          }
          editorManager.setActive(editor);
          editorManager.focusedEditor = editor;
          editor.dispatch('focus', { blurredEditor: focusedEditor });
          editor.focus(true);
        }
      });
      editor.on('focusout', () => {
        Delay.setEditorTimeout(editor, () => {
          const focusedEditor = editorManager.focusedEditor;
          if (!isEditorContentAreaElement(getActiveElement(editor)) || focusedEditor !== editor) {
            toggleContentAreaOnFocus(editor, remove$8);
          }
          if (!isUIElement(editor, getActiveElement(editor)) && focusedEditor === editor) {
            editor.dispatch('blur', { focusedEditor: null });
            editorManager.focusedEditor = null;
          }
        });
      });
      if (!documentFocusInHandler) {
        documentFocusInHandler = e => {
          const activeEditor = editorManager.activeEditor;
          if (activeEditor) {
            getOriginalEventTarget(e).each(target => {
              const elem = target;
              if (elem.ownerDocument === document) {
                if (elem !== document.body && !isUIElement(activeEditor, elem) && editorManager.focusedEditor === activeEditor) {
                  activeEditor.dispatch('blur', { focusedEditor: null });
                  editorManager.focusedEditor = null;
                }
              }
            });
          }
        };
        DOM$9.bind(document, 'focusin', documentFocusInHandler);
      }
    };
    const unregisterDocumentEvents = (editorManager, e) => {
      if (editorManager.focusedEditor === e.editor) {
        editorManager.focusedEditor = null;
      }
      if (!editorManager.activeEditor && documentFocusInHandler) {
        DOM$9.unbind(document, 'focusin', documentFocusInHandler);
        documentFocusInHandler = null;
      }
    };
    const setup$v = editorManager => {
      editorManager.on('AddEditor', curry(registerEvents$1, editorManager));
      editorManager.on('RemoveEditor', curry(unregisterDocumentEvents, editorManager));
    };

    const getContentEditableHost = (editor, node) => editor.dom.getParent(node, node => editor.dom.getContentEditable(node) === 'true');
    const getCollapsedNode = rng => rng.collapsed ? Optional.from(getNode$1(rng.startContainer, rng.startOffset)).map(SugarElement.fromDom) : Optional.none();
    const getFocusInElement = (root, rng) => getCollapsedNode(rng).bind(node => {
      if (isTableSection(node)) {
        return Optional.some(node);
      } else if (!contains(root, node)) {
        return Optional.some(root);
      } else {
        return Optional.none();
      }
    });
    const normalizeSelection = (editor, rng) => {
      getFocusInElement(SugarElement.fromDom(editor.getBody()), rng).bind(elm => {
        return firstPositionIn(elm.dom);
      }).fold(() => {
        editor.selection.normalize();
      }, caretPos => editor.selection.setRng(caretPos.toRange()));
    };
    const focusBody = body => {
      if (body.setActive) {
        try {
          body.setActive();
        } catch (ex) {
          body.focus();
        }
      } else {
        body.focus();
      }
    };
    const hasElementFocus = elm => hasFocus$1(elm) || search(elm).isSome();
    const hasIframeFocus = editor => isNonNullable(editor.iframeElement) && hasFocus$1(SugarElement.fromDom(editor.iframeElement));
    const hasInlineFocus = editor => {
      const rawBody = editor.getBody();
      return rawBody && hasElementFocus(SugarElement.fromDom(rawBody));
    };
    const hasUiFocus = editor => {
      const dos = getRootNode(SugarElement.fromDom(editor.getElement()));
      return active$1(dos).filter(elem => !isEditorContentAreaElement(elem.dom) && isUIElement(editor, elem.dom)).isSome();
    };
    const hasFocus = editor => editor.inline ? hasInlineFocus(editor) : hasIframeFocus(editor);
    const hasEditorOrUiFocus = editor => hasFocus(editor) || hasUiFocus(editor);
    const focusEditor = editor => {
      const selection = editor.selection;
      const body = editor.getBody();
      let rng = selection.getRng();
      editor.quirks.refreshContentEditable();
      if (isNonNullable(editor.bookmark) && !hasFocus(editor)) {
        getRng(editor).each(bookmarkRng => {
          editor.selection.setRng(bookmarkRng);
          rng = bookmarkRng;
        });
      }
      const contentEditableHost = getContentEditableHost(editor, selection.getNode());
      if (contentEditableHost && editor.dom.isChildOf(contentEditableHost, body)) {
        focusBody(contentEditableHost);
        normalizeSelection(editor, rng);
        activateEditor(editor);
        return;
      }
      if (!editor.inline) {
        if (!Env.browser.isOpera()) {
          focusBody(body);
        }
        editor.getWin().focus();
      }
      if (Env.browser.isFirefox() || editor.inline) {
        focusBody(body);
        normalizeSelection(editor, rng);
      }
      activateEditor(editor);
    };
    const activateEditor = editor => editor.editorManager.setActive(editor);
    const focus = (editor, skipFocus) => {
      if (editor.removed) {
        return;
      }
      if (skipFocus) {
        activateEditor(editor);
      } else {
        focusEditor(editor);
      }
    };

    const getEndpointElement = (root, rng, start, real, resolve) => {
      const container = start ? rng.startContainer : rng.endContainer;
      const offset = start ? rng.startOffset : rng.endOffset;
      return Optional.from(container).map(SugarElement.fromDom).map(elm => !real || !rng.collapsed ? child$1(elm, resolve(elm, offset)).getOr(elm) : elm).bind(elm => isElement$7(elm) ? Optional.some(elm) : parent(elm).filter(isElement$7)).map(elm => elm.dom).getOr(root);
    };
    const getStart = (root, rng, real = false) => getEndpointElement(root, rng, true, real, (elm, offset) => Math.min(childNodesCount(elm), offset));
    const getEnd$1 = (root, rng, real = false) => getEndpointElement(root, rng, false, real, (elm, offset) => offset > 0 ? offset - 1 : offset);
    const skipEmptyTextNodes = (node, forwards) => {
      const orig = node;
      while (node && isText$a(node) && node.length === 0) {
        node = forwards ? node.nextSibling : node.previousSibling;
      }
      return node || orig;
    };
    const getNode = (root, rng) => {
      if (!rng) {
        return root;
      }
      let startContainer = rng.startContainer;
      let endContainer = rng.endContainer;
      const startOffset = rng.startOffset;
      const endOffset = rng.endOffset;
      let node = rng.commonAncestorContainer;
      if (!rng.collapsed) {
        if (startContainer === endContainer) {
          if (endOffset - startOffset < 2) {
            if (startContainer.hasChildNodes()) {
              node = startContainer.childNodes[startOffset];
            }
          }
        }
        if (isText$a(startContainer) && isText$a(endContainer)) {
          if (startContainer.length === startOffset) {
            startContainer = skipEmptyTextNodes(startContainer.nextSibling, true);
          } else {
            startContainer = startContainer.parentNode;
          }
          if (endOffset === 0) {
            endContainer = skipEmptyTextNodes(endContainer.previousSibling, false);
          } else {
            endContainer = endContainer.parentNode;
          }
          if (startContainer && startContainer === endContainer) {
            node = startContainer;
          }
        }
      }
      const elm = isText$a(node) ? node.parentNode : node;
      return isElement$6(elm) ? elm : root;
    };
    const getSelectedBlocks = (dom, rng, startElm, endElm) => {
      const selectedBlocks = [];
      const root = dom.getRoot();
      const start = dom.getParent(startElm || getStart(root, rng, rng.collapsed), dom.isBlock);
      const end = dom.getParent(endElm || getEnd$1(root, rng, rng.collapsed), dom.isBlock);
      if (start && start !== root) {
        selectedBlocks.push(start);
      }
      if (start && end && start !== end) {
        let node;
        const walker = new DomTreeWalker(start, root);
        while ((node = walker.next()) && node !== end) {
          if (dom.isBlock(node)) {
            selectedBlocks.push(node);
          }
        }
      }
      if (end && start !== end && end !== root) {
        selectedBlocks.push(end);
      }
      return selectedBlocks;
    };
    const select = (dom, node, content) => Optional.from(node).bind(node => Optional.from(node.parentNode).map(parent => {
      const idx = dom.nodeIndex(node);
      const rng = dom.createRng();
      rng.setStart(parent, idx);
      rng.setEnd(parent, idx + 1);
      if (content) {
        moveEndPoint(dom, rng, node, true);
        moveEndPoint(dom, rng, node, false);
      }
      return rng;
    }));

    const processRanges = (editor, ranges) => map$3(ranges, range => {
      const evt = editor.dispatch('GetSelectionRange', { range });
      return evt.range !== range ? evt.range : range;
    });

    const getEnd = element => name(element) === 'img' ? 1 : getOption(element).fold(() => children$1(element).length, v => v.length);
    const isTextNodeWithCursorPosition = el => getOption(el).filter(text => text.trim().length !== 0 || text.indexOf(nbsp) > -1).isSome();
    const isContentEditableFalse$5 = elem => isHTMLElement(elem) && get$9(elem, 'contenteditable') === 'false';
    const elementsWithCursorPosition = [
      'img',
      'br'
    ];
    const isCursorPosition = elem => {
      const hasCursorPosition = isTextNodeWithCursorPosition(elem);
      return hasCursorPosition || contains$2(elementsWithCursorPosition, name(elem)) || isContentEditableFalse$5(elem);
    };

    const first = element => descendant$1(element, isCursorPosition);
    const last = element => descendantRtl(element, isCursorPosition);
    const descendantRtl = (scope, predicate) => {
      const descend = element => {
        const children = children$1(element);
        for (let i = children.length - 1; i >= 0; i--) {
          const child = children[i];
          if (predicate(child)) {
            return Optional.some(child);
          }
          const res = descend(child);
          if (res.isSome()) {
            return res;
          }
        }
        return Optional.none();
      };
      return descend(scope);
    };

    const autocompleteSelector = '[data-mce-autocompleter]';
    const create$9 = (editor, range) => {
      if (findIn(SugarElement.fromDom(editor.getBody())).isNone()) {
        const wrapper = SugarElement.fromHtml('<span data-mce-autocompleter="1" data-mce-bogus="1"></span>', editor.getDoc());
        append$1(wrapper, SugarElement.fromDom(range.extractContents()));
        range.insertNode(wrapper.dom);
        parent(wrapper).each(elm => elm.dom.normalize());
        last(wrapper).map(last => {
          editor.selection.setCursorLocation(last.dom, getEnd(last));
        });
      }
    };
    const detect$1 = elm => closest$3(elm, autocompleteSelector);
    const findIn = elm => descendant(elm, autocompleteSelector);
    const remove$3 = (editor, elm) => findIn(elm).each(wrapper => {
      const bookmark = editor.selection.getBookmark();
      unwrap(wrapper);
      editor.selection.moveToBookmark(bookmark);
    });

    const typeLookup = {
      '#text': 3,
      '#comment': 8,
      '#cdata': 4,
      '#pi': 7,
      '#doctype': 10,
      '#document-fragment': 11
    };
    const walk$2 = (node, root, prev) => {
      const startName = prev ? 'lastChild' : 'firstChild';
      const siblingName = prev ? 'prev' : 'next';
      if (node[startName]) {
        return node[startName];
      }
      if (node !== root) {
        let sibling = node[siblingName];
        if (sibling) {
          return sibling;
        }
        for (let parent = node.parent; parent && parent !== root; parent = parent.parent) {
          sibling = parent[siblingName];
          if (sibling) {
            return sibling;
          }
        }
      }
      return undefined;
    };
    const isEmptyTextNode = node => {
      var _a;
      const text = (_a = node.value) !== null && _a !== void 0 ? _a : '';
      if (!isWhitespaceText(text)) {
        return false;
      }
      const parentNode = node.parent;
      if (parentNode && (parentNode.name !== 'span' || parentNode.attr('style')) && /^[ ]+$/.test(text)) {
        return false;
      }
      return true;
    };
    const isNonEmptyElement = node => {
      const isNamedAnchor = node.name === 'a' && !node.attr('href') && node.attr('id');
      return node.attr('name') || node.attr('id') && !node.firstChild || node.attr('data-mce-bookmark') || isNamedAnchor;
    };
    class AstNode {
      constructor(name, type) {
        this.name = name;
        this.type = type;
        if (type === 1) {
          this.attributes = [];
          this.attributes.map = {};
        }
      }
      static create(name, attrs) {
        const node = new AstNode(name, typeLookup[name] || 1);
        if (attrs) {
          each$d(attrs, (value, attrName) => {
            node.attr(attrName, value);
          });
        }
        return node;
      }
      replace(node) {
        const self = this;
        if (node.parent) {
          node.remove();
        }
        self.insert(node, self);
        self.remove();
        return self;
      }
      attr(name, value) {
        const self = this;
        if (!isString(name)) {
          if (isNonNullable(name)) {
            each$d(name, (value, key) => {
              self.attr(key, value);
            });
          }
          return self;
        }
        const attrs = self.attributes;
        if (attrs) {
          if (value !== undefined) {
            if (value === null) {
              if (name in attrs.map) {
                delete attrs.map[name];
                let i = attrs.length;
                while (i--) {
                  if (attrs[i].name === name) {
                    attrs.splice(i, 1);
                    return self;
                  }
                }
              }
              return self;
            }
            if (name in attrs.map) {
              let i = attrs.length;
              while (i--) {
                if (attrs[i].name === name) {
                  attrs[i].value = value;
                  break;
                }
              }
            } else {
              attrs.push({
                name,
                value
              });
            }
            attrs.map[name] = value;
            return self;
          }
          return attrs.map[name];
        }
        return undefined;
      }
      clone() {
        const self = this;
        const clone = new AstNode(self.name, self.type);
        const selfAttrs = self.attributes;
        if (selfAttrs) {
          const cloneAttrs = [];
          cloneAttrs.map = {};
          for (let i = 0, l = selfAttrs.length; i < l; i++) {
            const selfAttr = selfAttrs[i];
            if (selfAttr.name !== 'id') {
              cloneAttrs[cloneAttrs.length] = {
                name: selfAttr.name,
                value: selfAttr.value
              };
              cloneAttrs.map[selfAttr.name] = selfAttr.value;
            }
          }
          clone.attributes = cloneAttrs;
        }
        clone.value = self.value;
        return clone;
      }
      wrap(wrapper) {
        const self = this;
        if (self.parent) {
          self.parent.insert(wrapper, self);
          wrapper.append(self);
        }
        return self;
      }
      unwrap() {
        const self = this;
        for (let node = self.firstChild; node;) {
          const next = node.next;
          self.insert(node, self, true);
          node = next;
        }
        self.remove();
      }
      remove() {
        const self = this, parent = self.parent, next = self.next, prev = self.prev;
        if (parent) {
          if (parent.firstChild === self) {
            parent.firstChild = next;
            if (next) {
              next.prev = null;
            }
          } else if (prev) {
            prev.next = next;
          }
          if (parent.lastChild === self) {
            parent.lastChild = prev;
            if (prev) {
              prev.next = null;
            }
          } else if (next) {
            next.prev = prev;
          }
          self.parent = self.next = self.prev = null;
        }
        return self;
      }
      append(node) {
        const self = this;
        if (node.parent) {
          node.remove();
        }
        const last = self.lastChild;
        if (last) {
          last.next = node;
          node.prev = last;
          self.lastChild = node;
        } else {
          self.lastChild = self.firstChild = node;
        }
        node.parent = self;
        return node;
      }
      insert(node, refNode, before) {
        if (node.parent) {
          node.remove();
        }
        const parent = refNode.parent || this;
        if (before) {
          if (refNode === parent.firstChild) {
            parent.firstChild = node;
          } else if (refNode.prev) {
            refNode.prev.next = node;
          }
          node.prev = refNode.prev;
          node.next = refNode;
          refNode.prev = node;
        } else {
          if (refNode === parent.lastChild) {
            parent.lastChild = node;
          } else if (refNode.next) {
            refNode.next.prev = node;
          }
          node.next = refNode.next;
          node.prev = refNode;
          refNode.next = node;
        }
        node.parent = parent;
        return node;
      }
      getAll(name) {
        const self = this;
        const collection = [];
        for (let node = self.firstChild; node; node = walk$2(node, self)) {
          if (node.name === name) {
            collection.push(node);
          }
        }
        return collection;
      }
      children() {
        const self = this;
        const collection = [];
        for (let node = self.firstChild; node; node = node.next) {
          collection.push(node);
        }
        return collection;
      }
      empty() {
        const self = this;
        if (self.firstChild) {
          const nodes = [];
          for (let node = self.firstChild; node; node = walk$2(node, self)) {
            nodes.push(node);
          }
          let i = nodes.length;
          while (i--) {
            const node = nodes[i];
            node.parent = node.firstChild = node.lastChild = node.next = node.prev = null;
          }
        }
        self.firstChild = self.lastChild = null;
        return self;
      }
      isEmpty(elements, whitespace = {}, predicate) {
        var _a;
        const self = this;
        let node = self.firstChild;
        if (isNonEmptyElement(self)) {
          return false;
        }
        if (node) {
          do {
            if (node.type === 1) {
              if (node.attr('data-mce-bogus')) {
                continue;
              }
              if (elements[node.name]) {
                return false;
              }
              if (isNonEmptyElement(node)) {
                return false;
              }
            }
            if (node.type === 8) {
              return false;
            }
            if (node.type === 3 && !isEmptyTextNode(node)) {
              return false;
            }
            if (node.type === 3 && node.parent && whitespace[node.parent.name] && isWhitespaceText((_a = node.value) !== null && _a !== void 0 ? _a : '')) {
              return false;
            }
            if (predicate && predicate(node)) {
              return false;
            }
          } while (node = walk$2(node, self));
        }
        return true;
      }
      walk(prev) {
        return walk$2(this, null, prev);
      }
    }

    const isConditionalComment = (html, startIndex) => /^\s*\[if [\w\W]+\]>.*<!\[endif\](--!?)?>/.test(html.substr(startIndex));
    const findCommentEndIndex = (html, isBogus, startIndex = 0) => {
      const lcHtml = html.toLowerCase();
      if (lcHtml.indexOf('[if ', startIndex) !== -1 && isConditionalComment(lcHtml, startIndex)) {
        const endIfIndex = lcHtml.indexOf('[endif]', startIndex);
        return lcHtml.indexOf('>', endIfIndex);
      } else {
        if (isBogus) {
          const endIndex = lcHtml.indexOf('>', startIndex);
          return endIndex !== -1 ? endIndex : lcHtml.length;
        } else {
          const endCommentRegexp = /--!?>/g;
          endCommentRegexp.lastIndex = startIndex;
          const match = endCommentRegexp.exec(html);
          return match ? match.index + match[0].length : lcHtml.length;
        }
      }
    };
    const findMatchingEndTagIndex = (schema, html, startIndex) => {
      const startTagRegExp = /<([!?\/])?([A-Za-z0-9\-_:.]+)/g;
      const endTagRegExp = /(?:\s(?:[^'">]+(?:"[^"]*"|'[^']*'))*[^"'>]*(?:"[^">]*|'[^'>]*)?|\s*|\/)>/g;
      const voidElements = schema.getVoidElements();
      let count = 1, index = startIndex;
      while (count !== 0) {
        startTagRegExp.lastIndex = index;
        while (true) {
          const startMatch = startTagRegExp.exec(html);
          if (startMatch === null) {
            return index;
          } else if (startMatch[1] === '!') {
            if (startsWith(startMatch[2], '--')) {
              index = findCommentEndIndex(html, false, startMatch.index + '!--'.length);
            } else {
              index = findCommentEndIndex(html, true, startMatch.index + 1);
            }
            break;
          } else {
            endTagRegExp.lastIndex = startTagRegExp.lastIndex;
            const endMatch = endTagRegExp.exec(html);
            if (isNull(endMatch) || endMatch.index !== startTagRegExp.lastIndex) {
              continue;
            }
            if (startMatch[1] === '/') {
              count -= 1;
            } else if (!has$2(voidElements, startMatch[2])) {
              count += 1;
            }
            index = startTagRegExp.lastIndex + endMatch[0].length;
            break;
          }
        }
      }
      return index;
    };
    const trimHtml$1 = (tempAttrs, html) => {
      const trimContentRegExp = new RegExp(['\\s?(' + tempAttrs.join('|') + ')="[^"]+"'].join('|'), 'gi');
      return html.replace(trimContentRegExp, '');
    };
    const trimInternal = (serializer, html) => {
      const bogusAllRegExp = /<(\w+) [^>]*data-mce-bogus="all"[^>]*>/g;
      const schema = serializer.schema;
      let content = trimHtml$1(serializer.getTempAttrs(), html);
      const voidElements = schema.getVoidElements();
      let matches;
      while (matches = bogusAllRegExp.exec(content)) {
        const index = bogusAllRegExp.lastIndex;
        const matchLength = matches[0].length;
        let endTagIndex;
        if (voidElements[matches[1]]) {
          endTagIndex = index;
        } else {
          endTagIndex = findMatchingEndTagIndex(schema, content, index);
        }
        content = content.substring(0, index - matchLength) + content.substring(endTagIndex);
        bogusAllRegExp.lastIndex = index - matchLength;
      }
      return trim$1(content);
    };
    const trimExternal = trimInternal;

    const cleanupBogusElements = parent => {
      const bogusElements = descendants(parent, '[data-mce-bogus]');
      each$e(bogusElements, elem => {
        const bogusValue = get$9(elem, 'data-mce-bogus');
        if (bogusValue === 'all') {
          remove$6(elem);
        } else if (isBr$5(elem)) {
          before$3(elem, SugarElement.fromText(zeroWidth));
          remove$6(elem);
        } else {
          unwrap(elem);
        }
      });
    };
    const cleanupInputNames = parent => {
      const inputs = descendants(parent, 'input');
      each$e(inputs, input => {
        remove$b(input, 'name');
      });
    };

    const trimEmptyContents = (editor, html) => {
      const blockName = getForcedRootBlock(editor);
      const emptyRegExp = new RegExp(`^(<${ blockName }[^>]*>(&nbsp;|&#160;|\\s|\u00a0|<br \\/>|)<\\/${ blockName }>[\r\n]*|<br \\/>[\r\n]*)$`);
      return html.replace(emptyRegExp, '');
    };
    const getPlainTextContent = (editor, body) => {
      const doc = editor.getDoc();
      const dos = getRootNode(SugarElement.fromDom(editor.getBody()));
      const offscreenDiv = SugarElement.fromTag('div', doc);
      set$3(offscreenDiv, 'data-mce-bogus', 'all');
      setAll(offscreenDiv, {
        position: 'fixed',
        left: '-9999999px',
        top: '0'
      });
      set$1(offscreenDiv, body.innerHTML);
      cleanupBogusElements(offscreenDiv);
      cleanupInputNames(offscreenDiv);
      const root = getContentContainer(dos);
      append$1(root, offscreenDiv);
      const content = trim$1(offscreenDiv.dom.innerText);
      remove$6(offscreenDiv);
      return content;
    };
    const getContentFromBody = (editor, args, body) => {
      let content;
      if (args.format === 'raw') {
        content = Tools.trim(trimExternal(editor.serializer, body.innerHTML));
      } else if (args.format === 'text') {
        content = getPlainTextContent(editor, body);
      } else if (args.format === 'tree') {
        content = editor.serializer.serialize(body, args);
      } else {
        content = trimEmptyContents(editor, editor.serializer.serialize(body, args));
      }
      const shouldTrim = args.format !== 'text' && !isWsPreserveElement(SugarElement.fromDom(body));
      return shouldTrim && isString(content) ? Tools.trim(content) : content;
    };
    const getContentInternal = (editor, args) => Optional.from(editor.getBody()).fold(constant(args.format === 'tree' ? new AstNode('body', 11) : ''), body => getContentFromBody(editor, args, body));

    const makeMap$1 = Tools.makeMap;
    const Writer = settings => {
      const html = [];
      settings = settings || {};
      const indent = settings.indent;
      const indentBefore = makeMap$1(settings.indent_before || '');
      const indentAfter = makeMap$1(settings.indent_after || '');
      const encode = Entities.getEncodeFunc(settings.entity_encoding || 'raw', settings.entities);
      const htmlOutput = settings.element_format !== 'xhtml';
      return {
        start: (name, attrs, empty) => {
          if (indent && indentBefore[name] && html.length > 0) {
            const value = html[html.length - 1];
            if (value.length > 0 && value !== '\n') {
              html.push('\n');
            }
          }
          html.push('<', name);
          if (attrs) {
            for (let i = 0, l = attrs.length; i < l; i++) {
              const attr = attrs[i];
              html.push(' ', attr.name, '="', encode(attr.value, true), '"');
            }
          }
          if (!empty || htmlOutput) {
            html[html.length] = '>';
          } else {
            html[html.length] = ' />';
          }
          if (empty && indent && indentAfter[name] && html.length > 0) {
            const value = html[html.length - 1];
            if (value.length > 0 && value !== '\n') {
              html.push('\n');
            }
          }
        },
        end: name => {
          let value;
          html.push('</', name, '>');
          if (indent && indentAfter[name] && html.length > 0) {
            value = html[html.length - 1];
            if (value.length > 0 && value !== '\n') {
              html.push('\n');
            }
          }
        },
        text: (text, raw) => {
          if (text.length > 0) {
            html[html.length] = raw ? text : encode(text);
          }
        },
        cdata: text => {
          html.push('<![CDATA[', text, ']]>');
        },
        comment: text => {
          html.push('<!--', text, '-->');
        },
        pi: (name, text) => {
          if (text) {
            html.push('<?', name, ' ', encode(text), '?>');
          } else {
            html.push('<?', name, '?>');
          }
          if (indent) {
            html.push('\n');
          }
        },
        doctype: text => {
          html.push('<!DOCTYPE', text, '>', indent ? '\n' : '');
        },
        reset: () => {
          html.length = 0;
        },
        getContent: () => {
          return html.join('').replace(/\n$/, '');
        }
      };
    };

    const HtmlSerializer = (settings = {}, schema = Schema()) => {
      const writer = Writer(settings);
      settings.validate = 'validate' in settings ? settings.validate : true;
      const serialize = node => {
        const validate = settings.validate;
        const handlers = {
          3: node => {
            var _a;
            writer.text((_a = node.value) !== null && _a !== void 0 ? _a : '', node.raw);
          },
          8: node => {
            var _a;
            writer.comment((_a = node.value) !== null && _a !== void 0 ? _a : '');
          },
          7: node => {
            writer.pi(node.name, node.value);
          },
          10: node => {
            var _a;
            writer.doctype((_a = node.value) !== null && _a !== void 0 ? _a : '');
          },
          4: node => {
            var _a;
            writer.cdata((_a = node.value) !== null && _a !== void 0 ? _a : '');
          },
          11: node => {
            let tempNode = node;
            if (tempNode = tempNode.firstChild) {
              do {
                walk(tempNode);
              } while (tempNode = tempNode.next);
            }
          }
        };
        writer.reset();
        const walk = node => {
          var _a;
          const handler = handlers[node.type];
          if (!handler) {
            const name = node.name;
            const isEmpty = name in schema.getVoidElements();
            let attrs = node.attributes;
            if (validate && attrs && attrs.length > 1) {
              const sortedAttrs = [];
              sortedAttrs.map = {};
              const elementRule = schema.getElementRule(node.name);
              if (elementRule) {
                for (let i = 0, l = elementRule.attributesOrder.length; i < l; i++) {
                  const attrName = elementRule.attributesOrder[i];
                  if (attrName in attrs.map) {
                    const attrValue = attrs.map[attrName];
                    sortedAttrs.map[attrName] = attrValue;
                    sortedAttrs.push({
                      name: attrName,
                      value: attrValue
                    });
                  }
                }
                for (let i = 0, l = attrs.length; i < l; i++) {
                  const attrName = attrs[i].name;
                  if (!(attrName in sortedAttrs.map)) {
                    const attrValue = attrs.map[attrName];
                    sortedAttrs.map[attrName] = attrValue;
                    sortedAttrs.push({
                      name: attrName,
                      value: attrValue
                    });
                  }
                }
                attrs = sortedAttrs;
              }
            }
            writer.start(name, attrs, isEmpty);
            if (!isEmpty) {
              let child = node.firstChild;
              if (child) {
                if ((name === 'pre' || name === 'textarea') && child.type === 3 && ((_a = child.value) === null || _a === void 0 ? void 0 : _a[0]) === '\n') {
                  writer.text('\n', true);
                }
                do {
                  walk(child);
                } while (child = child.next);
              }
              writer.end(name);
            }
          } else {
            handler(node);
          }
        };
        if (node.type === 1 && !settings.inner) {
          walk(node);
        } else if (node.type === 3) {
          handlers[3](node);
        } else {
          handlers[11](node);
        }
        return writer.getContent();
      };
      return { serialize };
    };

    const nonInheritableStyles = new Set();
    (() => {
      const nonInheritableStylesArr = [
        'margin',
        'margin-left',
        'margin-right',
        'margin-top',
        'margin-bottom',
        'padding',
        'padding-left',
        'padding-right',
        'padding-top',
        'padding-bottom',
        'border',
        'border-width',
        'border-style',
        'border-color',
        'background',
        'background-attachment',
        'background-clip',
        'background-color',
        'background-image',
        'background-origin',
        'background-position',
        'background-repeat',
        'background-size',
        'float',
        'position',
        'left',
        'right',
        'top',
        'bottom',
        'z-index',
        'display',
        'transform',
        'width',
        'max-width',
        'min-width',
        'height',
        'max-height',
        'min-height',
        'overflow',
        'overflow-x',
        'overflow-y',
        'text-overflow',
        'vertical-align',
        'transition',
        'transition-delay',
        'transition-duration',
        'transition-property',
        'transition-timing-function'
      ];
      each$e(nonInheritableStylesArr, style => {
        nonInheritableStyles.add(style);
      });
    })();
    const shorthandStyleProps = [
      'font',
      'text-decoration',
      'text-emphasis'
    ];
    const getStyleProps = (dom, node) => keys(dom.parseStyle(dom.getAttrib(node, 'style')));
    const isNonInheritableStyle = style => nonInheritableStyles.has(style);
    const hasInheritableStyles = (dom, node) => forall(getStyleProps(dom, node), style => !isNonInheritableStyle(style));
    const getLonghandStyleProps = styles => filter$5(styles, style => exists(shorthandStyleProps, prop => startsWith(style, prop)));
    const hasStyleConflict = (dom, node, parentNode) => {
      const nodeStyleProps = getStyleProps(dom, node);
      const parentNodeStyleProps = getStyleProps(dom, parentNode);
      const valueMismatch = prop => {
        var _a, _b;
        const nodeValue = (_a = dom.getStyle(node, prop)) !== null && _a !== void 0 ? _a : '';
        const parentValue = (_b = dom.getStyle(parentNode, prop)) !== null && _b !== void 0 ? _b : '';
        return isNotEmpty(nodeValue) && isNotEmpty(parentValue) && nodeValue !== parentValue;
      };
      return exists(nodeStyleProps, nodeStyleProp => {
        const propExists = props => exists(props, prop => prop === nodeStyleProp);
        if (!propExists(parentNodeStyleProps) && propExists(shorthandStyleProps)) {
          const longhandProps = getLonghandStyleProps(parentNodeStyleProps);
          return exists(longhandProps, valueMismatch);
        } else {
          return valueMismatch(nodeStyleProp);
        }
      });
    };

    const isChar = (forward, predicate, pos) => Optional.from(pos.container()).filter(isText$a).exists(text => {
      const delta = forward ? 0 : -1;
      return predicate(text.data.charAt(pos.offset() + delta));
    });
    const isBeforeSpace = curry(isChar, true, isWhiteSpace);
    const isAfterSpace = curry(isChar, false, isWhiteSpace);
    const isEmptyText = pos => {
      const container = pos.container();
      return isText$a(container) && (container.data.length === 0 || isZwsp(container.data) && BookmarkManager.isBookmarkNode(container.parentNode));
    };
    const matchesElementPosition = (before, predicate) => pos => getChildNodeAtRelativeOffset(before ? 0 : -1, pos).filter(predicate).isSome();
    const isImageBlock = node => isImg(node) && get$7(SugarElement.fromDom(node), 'display') === 'block';
    const isCefNode = node => isContentEditableFalse$b(node) && !isBogusAll$1(node);
    const isBeforeImageBlock = matchesElementPosition(true, isImageBlock);
    const isAfterImageBlock = matchesElementPosition(false, isImageBlock);
    const isBeforeMedia = matchesElementPosition(true, isMedia$2);
    const isAfterMedia = matchesElementPosition(false, isMedia$2);
    const isBeforeTable = matchesElementPosition(true, isTable$2);
    const isAfterTable = matchesElementPosition(false, isTable$2);
    const isBeforeContentEditableFalse = matchesElementPosition(true, isCefNode);
    const isAfterContentEditableFalse = matchesElementPosition(false, isCefNode);

    const dropLast = xs => xs.slice(0, -1);
    const parentsUntil = (start, root, predicate) => {
      if (contains(root, start)) {
        return dropLast(parents$1(start, elm => {
          return predicate(elm) || eq(elm, root);
        }));
      } else {
        return [];
      }
    };
    const parents = (start, root) => parentsUntil(start, root, never);
    const parentsAndSelf = (start, root) => [start].concat(parents(start, root));

    const navigateIgnoreEmptyTextNodes = (forward, root, from) => navigateIgnore(forward, root, from, isEmptyText);
    const getClosestBlock$1 = (root, pos) => find$2(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock$2);
    const isAtBeforeAfterBlockBoundary = (forward, root, pos) => navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall(newPos => getClosestBlock$1(root, pos).fold(() => !isInSameBlock(newPos, pos, root.dom), fromBlock => !isInSameBlock(newPos, pos, root.dom) && contains(fromBlock, SugarElement.fromDom(newPos.container()))));
    const isAtBlockBoundary = (forward, root, pos) => getClosestBlock$1(root, pos).fold(() => navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall(newPos => !isInSameBlock(newPos, pos, root.dom)), parent => navigateIgnoreEmptyTextNodes(forward, parent.dom, pos).isNone());
    const isAtStartOfBlock = curry(isAtBlockBoundary, false);
    const isAtEndOfBlock = curry(isAtBlockBoundary, true);
    const isBeforeBlock = curry(isAtBeforeAfterBlockBoundary, false);
    const isAfterBlock = curry(isAtBeforeAfterBlockBoundary, true);

    const isBr$1 = pos => getElementFromPosition(pos).exists(isBr$5);
    const findBr = (forward, root, pos) => {
      const parentBlocks = filter$5(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock$2);
      const scope = head(parentBlocks).getOr(root);
      return fromPosition(forward, scope.dom, pos).filter(isBr$1);
    };
    const isBeforeBr$1 = (root, pos) => getElementFromPosition(pos).exists(isBr$5) || findBr(true, root, pos).isSome();
    const isAfterBr = (root, pos) => getElementFromPrevPosition(pos).exists(isBr$5) || findBr(false, root, pos).isSome();
    const findPreviousBr = curry(findBr, false);
    const findNextBr = curry(findBr, true);

    const isInMiddleOfText = pos => CaretPosition.isTextPosition(pos) && !pos.isAtStart() && !pos.isAtEnd();
    const getClosestBlock = (root, pos) => {
      const parentBlocks = filter$5(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock$2);
      return head(parentBlocks).getOr(root);
    };
    const hasSpaceBefore = (root, pos) => {
      if (isInMiddleOfText(pos)) {
        return isAfterSpace(pos);
      } else {
        return isAfterSpace(pos) || prevPosition(getClosestBlock(root, pos).dom, pos).exists(isAfterSpace);
      }
    };
    const hasSpaceAfter = (root, pos) => {
      if (isInMiddleOfText(pos)) {
        return isBeforeSpace(pos);
      } else {
        return isBeforeSpace(pos) || nextPosition(getClosestBlock(root, pos).dom, pos).exists(isBeforeSpace);
      }
    };
    const isPreValue = value => contains$2([
      'pre',
      'pre-wrap'
    ], value);
    const isInPre = pos => getElementFromPosition(pos).bind(elm => closest$4(elm, isElement$7)).exists(elm => isPreValue(get$7(elm, 'white-space')));
    const isAtBeginningOfBody = (root, pos) => prevPosition(root.dom, pos).isNone();
    const isAtEndOfBody = (root, pos) => nextPosition(root.dom, pos).isNone();
    const isAtLineBoundary = (root, pos) => isAtBeginningOfBody(root, pos) || isAtEndOfBody(root, pos) || isAtStartOfBlock(root, pos) || isAtEndOfBlock(root, pos) || isAfterBr(root, pos) || isBeforeBr$1(root, pos);
    const isCefBlock = node => isNonNullable(node) && isContentEditableFalse$b(node) && isBlockLike(node);
    const isSiblingCefBlock = (root, direction) => container => {
      return isCefBlock(new DomTreeWalker(container, root)[direction]());
    };
    const isBeforeCefBlock = (root, pos) => {
      const nextPos = nextPosition(root.dom, pos).getOr(pos);
      const isNextCefBlock = isSiblingCefBlock(root.dom, 'next');
      return pos.isAtEnd() && (isNextCefBlock(pos.container()) || isNextCefBlock(nextPos.container()));
    };
    const isAfterCefBlock = (root, pos) => {
      const prevPos = prevPosition(root.dom, pos).getOr(pos);
      const isPrevCefBlock = isSiblingCefBlock(root.dom, 'prev');
      return pos.isAtStart() && (isPrevCefBlock(pos.container()) || isPrevCefBlock(prevPos.container()));
    };
    const needsToHaveNbsp = (root, pos) => {
      if (isInPre(pos)) {
        return false;
      } else {
        return isAtLineBoundary(root, pos) || hasSpaceBefore(root, pos) || hasSpaceAfter(root, pos);
      }
    };
    const needsToBeNbspLeft = (root, pos) => {
      if (isInPre(pos)) {
        return false;
      } else {
        return isAtStartOfBlock(root, pos) || isBeforeBlock(root, pos) || isAfterBr(root, pos) || hasSpaceBefore(root, pos) || isAfterCefBlock(root, pos);
      }
    };
    const leanRight = pos => {
      const container = pos.container();
      const offset = pos.offset();
      if (isText$a(container) && offset < container.data.length) {
        return CaretPosition(container, offset + 1);
      } else {
        return pos;
      }
    };
    const needsToBeNbspRight = (root, pos) => {
      if (isInPre(pos)) {
        return false;
      } else {
        return isAtEndOfBlock(root, pos) || isAfterBlock(root, pos) || isBeforeBr$1(root, pos) || hasSpaceAfter(root, pos) || isBeforeCefBlock(root, pos);
      }
    };
    const needsToBeNbsp = (root, pos) => needsToBeNbspLeft(root, pos) || needsToBeNbspRight(root, leanRight(pos));
    const isNbspAt = (text, offset) => isNbsp(text.charAt(offset));
    const isWhiteSpaceAt = (text, offset) => isWhiteSpace(text.charAt(offset));
    const hasNbsp = pos => {
      const container = pos.container();
      return isText$a(container) && contains$1(container.data, nbsp);
    };
    const normalizeNbspMiddle = text => {
      const chars = text.split('');
      return map$3(chars, (chr, i) => {
        if (isNbsp(chr) && i > 0 && i < chars.length - 1 && isContent(chars[i - 1]) && isContent(chars[i + 1])) {
          return ' ';
        } else {
          return chr;
        }
      }).join('');
    };
    const normalizeNbspAtStart = (root, node, makeNbsp) => {
      const text = node.data;
      const firstPos = CaretPosition(node, 0);
      if (!makeNbsp && isNbspAt(text, 0) && !needsToBeNbsp(root, firstPos)) {
        node.data = ' ' + text.slice(1);
        return true;
      } else if (makeNbsp && isWhiteSpaceAt(text, 0) && needsToBeNbspLeft(root, firstPos)) {
        node.data = nbsp + text.slice(1);
        return true;
      } else {
        return false;
      }
    };
    const normalizeNbspInMiddleOfTextNode = node => {
      const text = node.data;
      const newText = normalizeNbspMiddle(text);
      if (newText !== text) {
        node.data = newText;
        return true;
      } else {
        return false;
      }
    };
    const normalizeNbspAtEnd = (root, node, makeNbsp) => {
      const text = node.data;
      const lastPos = CaretPosition(node, text.length - 1);
      if (!makeNbsp && isNbspAt(text, text.length - 1) && !needsToBeNbsp(root, lastPos)) {
        node.data = text.slice(0, -1) + ' ';
        return true;
      } else if (makeNbsp && isWhiteSpaceAt(text, text.length - 1) && needsToBeNbspRight(root, lastPos)) {
        node.data = text.slice(0, -1) + nbsp;
        return true;
      } else {
        return false;
      }
    };
    const normalizeNbsps = (root, pos) => {
      const container = pos.container();
      if (!isText$a(container)) {
        return Optional.none();
      }
      if (hasNbsp(pos)) {
        const normalized = normalizeNbspAtStart(root, container, false) || normalizeNbspInMiddleOfTextNode(container) || normalizeNbspAtEnd(root, container, false);
        return someIf(normalized, pos);
      } else if (needsToBeNbsp(root, pos)) {
        const normalized = normalizeNbspAtStart(root, container, true) || normalizeNbspAtEnd(root, container, true);
        return someIf(normalized, pos);
      } else {
        return Optional.none();
      }
    };
    const normalizeNbspsInEditor = editor => {
      const root = SugarElement.fromDom(editor.getBody());
      if (editor.selection.isCollapsed()) {
        normalizeNbsps(root, CaretPosition.fromRangeStart(editor.selection.getRng())).each(pos => {
          editor.selection.setRng(pos.toRange());
        });
      }
    };

    const normalize$1 = (node, offset, count) => {
      if (count === 0) {
        return;
      }
      const elm = SugarElement.fromDom(node);
      const root = ancestor$4(elm, isBlock$2).getOr(elm);
      const whitespace = node.data.slice(offset, offset + count);
      const isEndOfContent = offset + count >= node.data.length && needsToBeNbspRight(root, CaretPosition(node, node.data.length));
      const isStartOfContent = offset === 0 && needsToBeNbspLeft(root, CaretPosition(node, 0));
      node.replaceData(offset, count, normalize$4(whitespace, 4, isStartOfContent, isEndOfContent));
    };
    const normalizeWhitespaceAfter = (node, offset) => {
      const content = node.data.slice(offset);
      const whitespaceCount = content.length - lTrim(content).length;
      normalize$1(node, offset, whitespaceCount);
    };
    const normalizeWhitespaceBefore = (node, offset) => {
      const content = node.data.slice(0, offset);
      const whitespaceCount = content.length - rTrim(content).length;
      normalize$1(node, offset - whitespaceCount, whitespaceCount);
    };
    const mergeTextNodes = (prevNode, nextNode, normalizeWhitespace, mergeToPrev = true) => {
      const whitespaceOffset = rTrim(prevNode.data).length;
      const newNode = mergeToPrev ? prevNode : nextNode;
      const removeNode = mergeToPrev ? nextNode : prevNode;
      if (mergeToPrev) {
        newNode.appendData(removeNode.data);
      } else {
        newNode.insertData(0, removeNode.data);
      }
      remove$6(SugarElement.fromDom(removeNode));
      if (normalizeWhitespace) {
        normalizeWhitespaceAfter(newNode, whitespaceOffset);
      }
      return newNode;
    };

    const needsReposition = (pos, elm) => {
      const container = pos.container();
      const offset = pos.offset();
      return !CaretPosition.isTextPosition(pos) && container === elm.parentNode && offset > CaretPosition.before(elm).offset();
    };
    const reposition = (elm, pos) => needsReposition(pos, elm) ? CaretPosition(pos.container(), pos.offset() - 1) : pos;
    const beforeOrStartOf = node => isText$a(node) ? CaretPosition(node, 0) : CaretPosition.before(node);
    const afterOrEndOf = node => isText$a(node) ? CaretPosition(node, node.data.length) : CaretPosition.after(node);
    const getPreviousSiblingCaretPosition = elm => {
      if (isCaretCandidate$3(elm.previousSibling)) {
        return Optional.some(afterOrEndOf(elm.previousSibling));
      } else {
        return elm.previousSibling ? lastPositionIn(elm.previousSibling) : Optional.none();
      }
    };
    const getNextSiblingCaretPosition = elm => {
      if (isCaretCandidate$3(elm.nextSibling)) {
        return Optional.some(beforeOrStartOf(elm.nextSibling));
      } else {
        return elm.nextSibling ? firstPositionIn(elm.nextSibling) : Optional.none();
      }
    };
    const findCaretPositionBackwardsFromElm = (rootElement, elm) => {
      return Optional.from(elm.previousSibling ? elm.previousSibling : elm.parentNode).bind(node => prevPosition(rootElement, CaretPosition.before(node))).orThunk(() => nextPosition(rootElement, CaretPosition.after(elm)));
    };
    const findCaretPositionForwardsFromElm = (rootElement, elm) => nextPosition(rootElement, CaretPosition.after(elm)).orThunk(() => prevPosition(rootElement, CaretPosition.before(elm)));
    const findCaretPositionBackwards = (rootElement, elm) => getPreviousSiblingCaretPosition(elm).orThunk(() => getNextSiblingCaretPosition(elm)).orThunk(() => findCaretPositionBackwardsFromElm(rootElement, elm));
    const findCaretPositionForward = (rootElement, elm) => getNextSiblingCaretPosition(elm).orThunk(() => getPreviousSiblingCaretPosition(elm)).orThunk(() => findCaretPositionForwardsFromElm(rootElement, elm));
    const findCaretPosition = (forward, rootElement, elm) => forward ? findCaretPositionForward(rootElement, elm) : findCaretPositionBackwards(rootElement, elm);
    const findCaretPosOutsideElmAfterDelete = (forward, rootElement, elm) => findCaretPosition(forward, rootElement, elm).map(curry(reposition, elm));
    const setSelection$1 = (editor, forward, pos) => {
      pos.fold(() => {
        editor.focus();
      }, pos => {
        editor.selection.setRng(pos.toRange(), forward);
      });
    };
    const eqRawNode = rawNode => elm => elm.dom === rawNode;
    const isBlock = (editor, elm) => elm && has$2(editor.schema.getBlockElements(), name(elm));
    const paddEmptyBlock = elm => {
      if (isEmpty$2(elm)) {
        const br = SugarElement.fromHtml('<br data-mce-bogus="1">');
        empty(elm);
        append$1(elm, br);
        return Optional.some(CaretPosition.before(br.dom));
      } else {
        return Optional.none();
      }
    };
    const deleteNormalized = (elm, afterDeletePosOpt, normalizeWhitespace) => {
      const prevTextOpt = prevSibling(elm).filter(isText$b);
      const nextTextOpt = nextSibling(elm).filter(isText$b);
      remove$6(elm);
      return lift3(prevTextOpt, nextTextOpt, afterDeletePosOpt, (prev, next, pos) => {
        const prevNode = prev.dom, nextNode = next.dom;
        const offset = prevNode.data.length;
        mergeTextNodes(prevNode, nextNode, normalizeWhitespace);
        return pos.container() === nextNode ? CaretPosition(prevNode, offset) : pos;
      }).orThunk(() => {
        if (normalizeWhitespace) {
          prevTextOpt.each(elm => normalizeWhitespaceBefore(elm.dom, elm.dom.length));
          nextTextOpt.each(elm => normalizeWhitespaceAfter(elm.dom, 0));
        }
        return afterDeletePosOpt;
      });
    };
    const isInlineElement = (editor, element) => has$2(editor.schema.getTextInlineElements(), name(element));
    const deleteElement$2 = (editor, forward, elm, moveCaret = true) => {
      const afterDeletePos = findCaretPosOutsideElmAfterDelete(forward, editor.getBody(), elm.dom);
      const parentBlock = ancestor$4(elm, curry(isBlock, editor), eqRawNode(editor.getBody()));
      const normalizedAfterDeletePos = deleteNormalized(elm, afterDeletePos, isInlineElement(editor, elm));
      if (editor.dom.isEmpty(editor.getBody())) {
        editor.setContent('');
        editor.selection.setCursorLocation();
      } else {
        parentBlock.bind(paddEmptyBlock).fold(() => {
          if (moveCaret) {
            setSelection$1(editor, forward, normalizedAfterDeletePos);
          }
        }, paddPos => {
          if (moveCaret) {
            setSelection$1(editor, forward, Optional.some(paddPos));
          }
        });
      }
    };

    const strongRtl = /[\u0591-\u07FF\uFB1D-\uFDFF\uFE70-\uFEFC]/;
    const hasStrongRtl = text => strongRtl.test(text);

    const isInlineTarget = (editor, elm) => is$1(SugarElement.fromDom(elm), getInlineBoundarySelector(editor)) && !isTransparentBlock(editor.schema, elm) && editor.dom.isEditable(elm);
    const isRtl = element => {
      var _a;
      return DOMUtils.DOM.getStyle(element, 'direction', true) === 'rtl' || hasStrongRtl((_a = element.textContent) !== null && _a !== void 0 ? _a : '');
    };
    const findInlineParents = (isInlineTarget, rootNode, pos) => filter$5(DOMUtils.DOM.getParents(pos.container(), '*', rootNode), isInlineTarget);
    const findRootInline = (isInlineTarget, rootNode, pos) => {
      const parents = findInlineParents(isInlineTarget, rootNode, pos);
      return Optional.from(parents[parents.length - 1]);
    };
    const hasSameParentBlock = (rootNode, node1, node2) => {
      const block1 = getParentBlock$3(node1, rootNode);
      const block2 = getParentBlock$3(node2, rootNode);
      return isNonNullable(block1) && block1 === block2;
    };
    const isAtZwsp = pos => isBeforeInline(pos) || isAfterInline(pos);
    const normalizePosition = (forward, pos) => {
      const container = pos.container(), offset = pos.offset();
      if (forward) {
        if (isCaretContainerInline(container)) {
          if (isText$a(container.nextSibling)) {
            return CaretPosition(container.nextSibling, 0);
          } else {
            return CaretPosition.after(container);
          }
        } else {
          return isBeforeInline(pos) ? CaretPosition(container, offset + 1) : pos;
        }
      } else {
        if (isCaretContainerInline(container)) {
          if (isText$a(container.previousSibling)) {
            return CaretPosition(container.previousSibling, container.previousSibling.data.length);
          } else {
            return CaretPosition.before(container);
          }
        } else {
          return isAfterInline(pos) ? CaretPosition(container, offset - 1) : pos;
        }
      }
    };
    const normalizeForwards = curry(normalizePosition, true);
    const normalizeBackwards = curry(normalizePosition, false);

    const execCommandIgnoreInputEvents = (editor, command) => {
      const inputBlocker = e => e.stopImmediatePropagation();
      editor.on('beforeinput input', inputBlocker, true);
      editor.getDoc().execCommand(command);
      editor.off('beforeinput input', inputBlocker);
    };
    const execEditorDeleteCommand = editor => {
      editor.execCommand('delete');
    };
    const execNativeDeleteCommand = editor => execCommandIgnoreInputEvents(editor, 'Delete');
    const execNativeForwardDeleteCommand = editor => execCommandIgnoreInputEvents(editor, 'ForwardDelete');
    const isBeforeRoot = rootNode => elm => is$2(parent(elm), rootNode, eq);
    const isTextBlockOrListItem = element => isTextBlock$2(element) || isListItem$1(element);
    const getParentBlock$2 = (rootNode, elm) => {
      if (contains(rootNode, elm)) {
        return closest$4(elm, isTextBlockOrListItem, isBeforeRoot(rootNode));
      } else {
        return Optional.none();
      }
    };
    const paddEmptyBody = (editor, moveSelection = true) => {
      if (editor.dom.isEmpty(editor.getBody())) {
        editor.setContent('', { no_selection: !moveSelection });
      }
    };
    const willDeleteLastPositionInElement = (forward, fromPos, elm) => lift2(firstPositionIn(elm), lastPositionIn(elm), (firstPos, lastPos) => {
      const normalizedFirstPos = normalizePosition(true, firstPos);
      const normalizedLastPos = normalizePosition(false, lastPos);
      const normalizedFromPos = normalizePosition(false, fromPos);
      if (forward) {
        return nextPosition(elm, normalizedFromPos).exists(nextPos => nextPos.isEqual(normalizedLastPos) && fromPos.isEqual(normalizedFirstPos));
      } else {
        return prevPosition(elm, normalizedFromPos).exists(prevPos => prevPos.isEqual(normalizedFirstPos) && fromPos.isEqual(normalizedLastPos));
      }
    }).getOr(true);
    const freefallRtl = root => {
      const child = isComment$1(root) ? prevSibling(root) : lastChild(root);
      return child.bind(freefallRtl).orThunk(() => Optional.some(root));
    };
    const deleteRangeContents = (editor, rng, root, moveSelection = true) => {
      var _a;
      rng.deleteContents();
      const lastNode = freefallRtl(root).getOr(root);
      const lastBlock = SugarElement.fromDom((_a = editor.dom.getParent(lastNode.dom, editor.dom.isBlock)) !== null && _a !== void 0 ? _a : root.dom);
      if (lastBlock.dom === editor.getBody()) {
        paddEmptyBody(editor, moveSelection);
      } else if (isEmpty$2(lastBlock)) {
        fillWithPaddingBr(lastBlock);
        if (moveSelection) {
          editor.selection.setCursorLocation(lastBlock.dom, 0);
        }
      }
      if (!eq(root, lastBlock)) {
        const additionalCleanupNodes = is$2(parent(lastBlock), root) ? [] : siblings(lastBlock);
        each$e(additionalCleanupNodes.concat(children$1(root)), node => {
          if (!eq(node, lastBlock) && !contains(node, lastBlock) && isEmpty$2(node)) {
            remove$6(node);
          }
        });
      }
    };

    const isRootFromElement = root => cur => eq(root, cur);
    const getTableCells = table => descendants(table, 'td,th');
    const getTableDetailsFromRange = (rng, isRoot) => {
      const getTable = node => getClosestTable(SugarElement.fromDom(node), isRoot);
      const startTable = getTable(rng.startContainer);
      const endTable = getTable(rng.endContainer);
      const isStartInTable = startTable.isSome();
      const isEndInTable = endTable.isSome();
      const isSameTable = lift2(startTable, endTable, eq).getOr(false);
      const isMultiTable = !isSameTable && isStartInTable && isEndInTable;
      return {
        startTable,
        endTable,
        isStartInTable,
        isEndInTable,
        isSameTable,
        isMultiTable
      };
    };

    const tableCellRng = (start, end) => ({
      start,
      end
    });
    const tableSelection = (rng, table, cells) => ({
      rng,
      table,
      cells
    });
    const deleteAction = Adt.generate([
      {
        singleCellTable: [
          'rng',
          'cell'
        ]
      },
      { fullTable: ['table'] },
      {
        partialTable: [
          'cells',
          'outsideDetails'
        ]
      },
      {
        multiTable: [
          'startTableCells',
          'endTableCells',
          'betweenRng'
        ]
      }
    ]);
    const getClosestCell$1 = (container, isRoot) => closest$3(SugarElement.fromDom(container), 'td,th', isRoot);
    const isExpandedCellRng = cellRng => !eq(cellRng.start, cellRng.end);
    const getTableFromCellRng = (cellRng, isRoot) => getClosestTable(cellRng.start, isRoot).bind(startParentTable => getClosestTable(cellRng.end, isRoot).bind(endParentTable => someIf(eq(startParentTable, endParentTable), startParentTable)));
    const isSingleCellTable = (cellRng, isRoot) => !isExpandedCellRng(cellRng) && getTableFromCellRng(cellRng, isRoot).exists(table => {
      const rows = table.dom.rows;
      return rows.length === 1 && rows[0].cells.length === 1;
    });
    const getCellRng = (rng, isRoot) => {
      const startCell = getClosestCell$1(rng.startContainer, isRoot);
      const endCell = getClosestCell$1(rng.endContainer, isRoot);
      return lift2(startCell, endCell, tableCellRng);
    };
    const getCellRangeFromStartTable = isRoot => startCell => getClosestTable(startCell, isRoot).bind(table => last$3(getTableCells(table)).map(endCell => tableCellRng(startCell, endCell)));
    const getCellRangeFromEndTable = isRoot => endCell => getClosestTable(endCell, isRoot).bind(table => head(getTableCells(table)).map(startCell => tableCellRng(startCell, endCell)));
    const getTableSelectionFromCellRng = isRoot => cellRng => getTableFromCellRng(cellRng, isRoot).map(table => tableSelection(cellRng, table, getTableCells(table)));
    const getTableSelections = (cellRng, selectionDetails, rng, isRoot) => {
      if (rng.collapsed || !cellRng.forall(isExpandedCellRng)) {
        return Optional.none();
      } else if (selectionDetails.isSameTable) {
        const sameTableSelection = cellRng.bind(getTableSelectionFromCellRng(isRoot));
        return Optional.some({
          start: sameTableSelection,
          end: sameTableSelection
        });
      } else {
        const startCell = getClosestCell$1(rng.startContainer, isRoot);
        const endCell = getClosestCell$1(rng.endContainer, isRoot);
        const startTableSelection = startCell.bind(getCellRangeFromStartTable(isRoot)).bind(getTableSelectionFromCellRng(isRoot));
        const endTableSelection = endCell.bind(getCellRangeFromEndTable(isRoot)).bind(getTableSelectionFromCellRng(isRoot));
        return Optional.some({
          start: startTableSelection,
          end: endTableSelection
        });
      }
    };
    const getCellIndex = (cells, cell) => findIndex$2(cells, x => eq(x, cell));
    const getSelectedCells = tableSelection => lift2(getCellIndex(tableSelection.cells, tableSelection.rng.start), getCellIndex(tableSelection.cells, tableSelection.rng.end), (startIndex, endIndex) => tableSelection.cells.slice(startIndex, endIndex + 1));
    const isSingleCellTableContentSelected = (optCellRng, rng, isRoot) => optCellRng.exists(cellRng => isSingleCellTable(cellRng, isRoot) && hasAllContentsSelected(cellRng.start, rng));
    const unselectCells = (rng, selectionDetails) => {
      const {startTable, endTable} = selectionDetails;
      const otherContentRng = rng.cloneRange();
      startTable.each(table => otherContentRng.setStartAfter(table.dom));
      endTable.each(table => otherContentRng.setEndBefore(table.dom));
      return otherContentRng;
    };
    const handleSingleTable = (cellRng, selectionDetails, rng, isRoot) => getTableSelections(cellRng, selectionDetails, rng, isRoot).bind(({start, end}) => start.or(end)).bind(tableSelection => {
      const {isSameTable} = selectionDetails;
      const selectedCells = getSelectedCells(tableSelection).getOr([]);
      if (isSameTable && tableSelection.cells.length === selectedCells.length) {
        return Optional.some(deleteAction.fullTable(tableSelection.table));
      } else if (selectedCells.length > 0) {
        if (isSameTable) {
          return Optional.some(deleteAction.partialTable(selectedCells, Optional.none()));
        } else {
          const otherContentRng = unselectCells(rng, selectionDetails);
          return Optional.some(deleteAction.partialTable(selectedCells, Optional.some({
            ...selectionDetails,
            rng: otherContentRng
          })));
        }
      } else {
        return Optional.none();
      }
    });
    const handleMultiTable = (cellRng, selectionDetails, rng, isRoot) => getTableSelections(cellRng, selectionDetails, rng, isRoot).bind(({start, end}) => {
      const startTableSelectedCells = start.bind(getSelectedCells).getOr([]);
      const endTableSelectedCells = end.bind(getSelectedCells).getOr([]);
      if (startTableSelectedCells.length > 0 && endTableSelectedCells.length > 0) {
        const otherContentRng = unselectCells(rng, selectionDetails);
        return Optional.some(deleteAction.multiTable(startTableSelectedCells, endTableSelectedCells, otherContentRng));
      } else {
        return Optional.none();
      }
    });
    const getActionFromRange = (root, rng) => {
      const isRoot = isRootFromElement(root);
      const optCellRng = getCellRng(rng, isRoot);
      const selectionDetails = getTableDetailsFromRange(rng, isRoot);
      if (isSingleCellTableContentSelected(optCellRng, rng, isRoot)) {
        return optCellRng.map(cellRng => deleteAction.singleCellTable(rng, cellRng.start));
      } else if (selectionDetails.isMultiTable) {
        return handleMultiTable(optCellRng, selectionDetails, rng, isRoot);
      } else {
        return handleSingleTable(optCellRng, selectionDetails, rng, isRoot);
      }
    };

    const cleanCells = cells => each$e(cells, cell => {
      remove$b(cell, 'contenteditable');
      fillWithPaddingBr(cell);
    });
    const getOutsideBlock = (editor, container) => Optional.from(editor.dom.getParent(container, editor.dom.isBlock)).map(SugarElement.fromDom);
    const handleEmptyBlock = (editor, startInTable, emptyBlock) => {
      emptyBlock.each(block => {
        if (startInTable) {
          remove$6(block);
        } else {
          fillWithPaddingBr(block);
          editor.selection.setCursorLocation(block.dom, 0);
        }
      });
    };
    const deleteContentInsideCell = (editor, cell, rng, isFirstCellInSelection) => {
      const insideTableRng = rng.cloneRange();
      if (isFirstCellInSelection) {
        insideTableRng.setStart(rng.startContainer, rng.startOffset);
        insideTableRng.setEndAfter(cell.dom.lastChild);
      } else {
        insideTableRng.setStartBefore(cell.dom.firstChild);
        insideTableRng.setEnd(rng.endContainer, rng.endOffset);
      }
      deleteCellContents(editor, insideTableRng, cell, false).each(action => action());
    };
    const collapseAndRestoreCellSelection = editor => {
      const selectedCells = getCellsFromEditor(editor);
      const selectedNode = SugarElement.fromDom(editor.selection.getNode());
      if (isTableCell$3(selectedNode.dom) && isEmpty$2(selectedNode)) {
        editor.selection.setCursorLocation(selectedNode.dom, 0);
      } else {
        editor.selection.collapse(true);
      }
      if (selectedCells.length > 1 && exists(selectedCells, cell => eq(cell, selectedNode))) {
        set$3(selectedNode, 'data-mce-selected', '1');
      }
    };
    const emptySingleTableCells = (editor, cells, outsideDetails) => Optional.some(() => {
      const editorRng = editor.selection.getRng();
      const cellsToClean = outsideDetails.bind(({rng, isStartInTable}) => {
        const outsideBlock = getOutsideBlock(editor, isStartInTable ? rng.endContainer : rng.startContainer);
        rng.deleteContents();
        handleEmptyBlock(editor, isStartInTable, outsideBlock.filter(isEmpty$2));
        const endPointCell = isStartInTable ? cells[0] : cells[cells.length - 1];
        deleteContentInsideCell(editor, endPointCell, editorRng, isStartInTable);
        if (!isEmpty$2(endPointCell)) {
          return Optional.some(isStartInTable ? cells.slice(1) : cells.slice(0, -1));
        } else {
          return Optional.none();
        }
      }).getOr(cells);
      cleanCells(cellsToClean);
      collapseAndRestoreCellSelection(editor);
    });
    const emptyMultiTableCells = (editor, startTableCells, endTableCells, betweenRng) => Optional.some(() => {
      const rng = editor.selection.getRng();
      const startCell = startTableCells[0];
      const endCell = endTableCells[endTableCells.length - 1];
      deleteContentInsideCell(editor, startCell, rng, true);
      deleteContentInsideCell(editor, endCell, rng, false);
      const startTableCellsToClean = isEmpty$2(startCell) ? startTableCells : startTableCells.slice(1);
      const endTableCellsToClean = isEmpty$2(endCell) ? endTableCells : endTableCells.slice(0, -1);
      cleanCells(startTableCellsToClean.concat(endTableCellsToClean));
      betweenRng.deleteContents();
      collapseAndRestoreCellSelection(editor);
    });
    const deleteCellContents = (editor, rng, cell, moveSelection = true) => Optional.some(() => {
      deleteRangeContents(editor, rng, cell, moveSelection);
    });
    const deleteTableElement = (editor, table) => Optional.some(() => deleteElement$2(editor, false, table));
    const deleteCellRange = (editor, rootElm, rng) => getActionFromRange(rootElm, rng).bind(action => action.fold(curry(deleteCellContents, editor), curry(deleteTableElement, editor), curry(emptySingleTableCells, editor), curry(emptyMultiTableCells, editor)));
    const deleteCaptionRange = (editor, caption) => emptyElement(editor, caption);
    const deleteTableRange = (editor, rootElm, rng, startElm) => getParentCaption(rootElm, startElm).fold(() => deleteCellRange(editor, rootElm, rng), caption => deleteCaptionRange(editor, caption));
    const deleteRange$3 = (editor, startElm, selectedCells) => {
      const rootNode = SugarElement.fromDom(editor.getBody());
      const rng = editor.selection.getRng();
      return selectedCells.length !== 0 ? emptySingleTableCells(editor, selectedCells, Optional.none()) : deleteTableRange(editor, rootNode, rng, startElm);
    };
    const getParentCell = (rootElm, elm) => find$2(parentsAndSelf(elm, rootElm), isTableCell$2);
    const getParentCaption = (rootElm, elm) => find$2(parentsAndSelf(elm, rootElm), isTag('caption'));
    const deleteBetweenCells = (editor, rootElm, forward, fromCell, from) => navigate(forward, editor.getBody(), from).bind(to => getParentCell(rootElm, SugarElement.fromDom(to.getNode())).bind(toCell => eq(toCell, fromCell) ? Optional.none() : Optional.some(noop)));
    const emptyElement = (editor, elm) => Optional.some(() => {
      fillWithPaddingBr(elm);
      editor.selection.setCursorLocation(elm.dom, 0);
    });
    const isDeleteOfLastCharPos = (fromCaption, forward, from, to) => firstPositionIn(fromCaption.dom).bind(first => lastPositionIn(fromCaption.dom).map(last => forward ? from.isEqual(first) && to.isEqual(last) : from.isEqual(last) && to.isEqual(first))).getOr(true);
    const emptyCaretCaption = (editor, elm) => emptyElement(editor, elm);
    const validateCaretCaption = (rootElm, fromCaption, to) => getParentCaption(rootElm, SugarElement.fromDom(to.getNode())).fold(() => Optional.some(noop), toCaption => someIf(!eq(toCaption, fromCaption), noop));
    const deleteCaretInsideCaption = (editor, rootElm, forward, fromCaption, from) => navigate(forward, editor.getBody(), from).fold(() => Optional.some(noop), to => isDeleteOfLastCharPos(fromCaption, forward, from, to) ? emptyCaretCaption(editor, fromCaption) : validateCaretCaption(rootElm, fromCaption, to));
    const deleteCaretCells = (editor, forward, rootElm, startElm) => {
      const from = CaretPosition.fromRangeStart(editor.selection.getRng());
      return getParentCell(rootElm, startElm).bind(fromCell => isEmpty$2(fromCell) ? emptyElement(editor, fromCell) : deleteBetweenCells(editor, rootElm, forward, fromCell, from));
    };
    const deleteCaretCaption = (editor, forward, rootElm, fromCaption) => {
      const from = CaretPosition.fromRangeStart(editor.selection.getRng());
      return isEmpty$2(fromCaption) ? emptyElement(editor, fromCaption) : deleteCaretInsideCaption(editor, rootElm, forward, fromCaption, from);
    };
    const isNearTable = (forward, pos) => forward ? isBeforeTable(pos) : isAfterTable(pos);
    const isBeforeOrAfterTable = (editor, forward) => {
      const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());
      return isNearTable(forward, fromPos) || fromPosition(forward, editor.getBody(), fromPos).exists(pos => isNearTable(forward, pos));
    };
    const deleteCaret$3 = (editor, forward, startElm) => {
      const rootElm = SugarElement.fromDom(editor.getBody());
      return getParentCaption(rootElm, startElm).fold(() => deleteCaretCells(editor, forward, rootElm, startElm).orThunk(() => someIf(isBeforeOrAfterTable(editor, forward), noop)), fromCaption => deleteCaretCaption(editor, forward, rootElm, fromCaption));
    };
    const backspaceDelete$9 = (editor, forward) => {
      const startElm = SugarElement.fromDom(editor.selection.getStart(true));
      const cells = getCellsFromEditor(editor);
      return editor.selection.isCollapsed() && cells.length === 0 ? deleteCaret$3(editor, forward, startElm) : deleteRange$3(editor, startElm, cells);
    };

    const getContentEditableRoot$1 = (root, node) => {
      let tempNode = node;
      while (tempNode && tempNode !== root) {
        if (isContentEditableTrue$3(tempNode) || isContentEditableFalse$b(tempNode)) {
          return tempNode;
        }
        tempNode = tempNode.parentNode;
      }
      return null;
    };

    const internalAttributesPrefixes = [
      'data-ephox-',
      'data-mce-',
      'data-alloy-',
      'data-snooker-',
      '_'
    ];
    const each$9 = Tools.each;
    const ElementUtils = editor => {
      const dom = editor.dom;
      const internalAttributes = new Set(editor.serializer.getTempAttrs());
      const compare = (node1, node2) => {
        if (node1.nodeName !== node2.nodeName || node1.nodeType !== node2.nodeType) {
          return false;
        }
        const getAttribs = node => {
          const attribs = {};
          each$9(dom.getAttribs(node), attr => {
            const name = attr.nodeName.toLowerCase();
            if (name !== 'style' && !isAttributeInternal(name)) {
              attribs[name] = dom.getAttrib(node, name);
            }
          });
          return attribs;
        };
        const compareObjects = (obj1, obj2) => {
          for (const name in obj1) {
            if (has$2(obj1, name)) {
              const value = obj2[name];
              if (isUndefined(value)) {
                return false;
              }
              if (obj1[name] !== value) {
                return false;
              }
              delete obj2[name];
            }
          }
          for (const name in obj2) {
            if (has$2(obj2, name)) {
              return false;
            }
          }
          return true;
        };
        if (isElement$6(node1) && isElement$6(node2)) {
          if (!compareObjects(getAttribs(node1), getAttribs(node2))) {
            return false;
          }
          if (!compareObjects(dom.parseStyle(dom.getAttrib(node1, 'style')), dom.parseStyle(dom.getAttrib(node2, 'style')))) {
            return false;
          }
        }
        return !isBookmarkNode$1(node1) && !isBookmarkNode$1(node2);
      };
      const isAttributeInternal = attributeName => exists(internalAttributesPrefixes, value => startsWith(attributeName, value)) || internalAttributes.has(attributeName);
      return {
        compare,
        isAttributeInternal
      };
    };

    const traverse = (root, fn) => {
      let node = root;
      while (node = node.walk()) {
        fn(node);
      }
    };
    const matchNode$1 = (nodeFilters, attributeFilters, node, matches) => {
      const name = node.name;
      for (let ni = 0, nl = nodeFilters.length; ni < nl; ni++) {
        const filter = nodeFilters[ni];
        if (filter.name === name) {
          const match = matches.nodes[name];
          if (match) {
            match.nodes.push(node);
          } else {
            matches.nodes[name] = {
              filter,
              nodes: [node]
            };
          }
        }
      }
      if (node.attributes) {
        for (let ai = 0, al = attributeFilters.length; ai < al; ai++) {
          const filter = attributeFilters[ai];
          const attrName = filter.name;
          if (attrName in node.attributes.map) {
            const match = matches.attributes[attrName];
            if (match) {
              match.nodes.push(node);
            } else {
              matches.attributes[attrName] = {
                filter,
                nodes: [node]
              };
            }
          }
        }
      }
    };
    const findMatchingNodes = (nodeFilters, attributeFilters, node) => {
      const matches = {
        nodes: {},
        attributes: {}
      };
      if (node.firstChild) {
        traverse(node, childNode => {
          matchNode$1(nodeFilters, attributeFilters, childNode, matches);
        });
      }
      return matches;
    };
    const runFilters = (matches, args) => {
      const run = (matchRecord, filteringAttributes) => {
        each$d(matchRecord, match => {
          const nodes = from(match.nodes);
          each$e(match.filter.callbacks, callback => {
            for (let i = nodes.length - 1; i >= 0; i--) {
              const node = nodes[i];
              const valueMatches = filteringAttributes ? node.attr(match.filter.name) !== undefined : node.name === match.filter.name;
              if (!valueMatches || isNullable(node.parent)) {
                nodes.splice(i, 1);
              }
            }
            if (nodes.length > 0) {
              callback(nodes, match.filter.name, args);
            }
          });
        });
      };
      run(matches.nodes, false);
      run(matches.attributes, true);
    };
    const filter$2 = (nodeFilters, attributeFilters, node, args = {}) => {
      const matches = findMatchingNodes(nodeFilters, attributeFilters, node);
      runFilters(matches, args);
    };

    const paddEmptyNode = (args, isBlock, node) => {
      if (args.insert && isBlock(node)) {
        const astNode = new AstNode('br', 1);
        astNode.attr('data-mce-bogus', '1');
        node.empty().append(astNode);
      } else {
        node.empty().append(new AstNode('#text', 3)).value = nbsp;
      }
    };
    const isPaddedWithNbsp = node => {
      var _a;
      return hasOnlyChild(node, '#text') && ((_a = node === null || node === void 0 ? void 0 : node.firstChild) === null || _a === void 0 ? void 0 : _a.value) === nbsp;
    };
    const hasOnlyChild = (node, name) => {
      const firstChild = node === null || node === void 0 ? void 0 : node.firstChild;
      return isNonNullable(firstChild) && firstChild === node.lastChild && firstChild.name === name;
    };
    const isPadded = (schema, node) => {
      const rule = schema.getElementRule(node.name);
      return (rule === null || rule === void 0 ? void 0 : rule.paddEmpty) === true;
    };
    const isEmpty = (schema, nonEmptyElements, whitespaceElements, node) => node.isEmpty(nonEmptyElements, whitespaceElements, node => isPadded(schema, node));
    const isLineBreakNode = (node, isBlock) => isNonNullable(node) && (isBlock(node) || node.name === 'br');
    const findClosestEditingHost = scope => {
      let editableNode;
      for (let node = scope; node; node = node.parent) {
        const contentEditable = node.attr('contenteditable');
        if (contentEditable === 'false') {
          break;
        } else if (contentEditable === 'true') {
          editableNode = node;
        }
      }
      return Optional.from(editableNode);
    };

    const removeOrUnwrapInvalidNode = (node, schema, originalNodeParent = node.parent) => {
      if (schema.getSpecialElements()[node.name]) {
        node.empty().remove();
      } else {
        const children = node.children();
        for (const childNode of children) {
          if (originalNodeParent && !schema.isValidChild(originalNodeParent.name, childNode.name)) {
            removeOrUnwrapInvalidNode(childNode, schema, originalNodeParent);
          }
        }
        node.unwrap();
      }
    };
    const cleanInvalidNodes = (nodes, schema, rootNode, onCreate = noop) => {
      const textBlockElements = schema.getTextBlockElements();
      const nonEmptyElements = schema.getNonEmptyElements();
      const whitespaceElements = schema.getWhitespaceElements();
      const nonSplittableElements = Tools.makeMap('tr,td,th,tbody,thead,tfoot,table');
      const fixed = new Set();
      const isSplittableElement = node => node !== rootNode && !nonSplittableElements[node.name];
      for (let ni = 0; ni < nodes.length; ni++) {
        const node = nodes[ni];
        let parent;
        let newParent;
        let tempNode;
        if (!node.parent || fixed.has(node)) {
          continue;
        }
        if (textBlockElements[node.name] && node.parent.name === 'li') {
          let sibling = node.next;
          while (sibling) {
            if (textBlockElements[sibling.name]) {
              sibling.name = 'li';
              fixed.add(sibling);
              node.parent.insert(sibling, node.parent);
            } else {
              break;
            }
            sibling = sibling.next;
          }
          node.unwrap();
          continue;
        }
        const parents = [node];
        for (parent = node.parent; parent && !schema.isValidChild(parent.name, node.name) && isSplittableElement(parent); parent = parent.parent) {
          parents.push(parent);
        }
        if (parent && parents.length > 1) {
          if (schema.isValidChild(parent.name, node.name)) {
            parents.reverse();
            newParent = parents[0].clone();
            onCreate(newParent);
            let currentNode = newParent;
            for (let i = 0; i < parents.length - 1; i++) {
              if (schema.isValidChild(currentNode.name, parents[i].name) && i > 0) {
                tempNode = parents[i].clone();
                onCreate(tempNode);
                currentNode.append(tempNode);
              } else {
                tempNode = currentNode;
              }
              for (let childNode = parents[i].firstChild; childNode && childNode !== parents[i + 1];) {
                const nextNode = childNode.next;
                tempNode.append(childNode);
                childNode = nextNode;
              }
              currentNode = tempNode;
            }
            if (!isEmpty(schema, nonEmptyElements, whitespaceElements, newParent)) {
              parent.insert(newParent, parents[0], true);
              parent.insert(node, newParent);
            } else {
              parent.insert(node, parents[0], true);
            }
            parent = parents[0];
            if (isEmpty(schema, nonEmptyElements, whitespaceElements, parent) || hasOnlyChild(parent, 'br')) {
              parent.empty().remove();
            }
          } else {
            removeOrUnwrapInvalidNode(node, schema);
          }
        } else if (node.parent) {
          if (node.name === 'li') {
            let sibling = node.prev;
            if (sibling && (sibling.name === 'ul' || sibling.name === 'ol')) {
              sibling.append(node);
              continue;
            }
            sibling = node.next;
            if (sibling && (sibling.name === 'ul' || sibling.name === 'ol') && sibling.firstChild) {
              sibling.insert(node, sibling.firstChild, true);
              continue;
            }
            const wrapper = new AstNode('ul', 1);
            onCreate(wrapper);
            node.wrap(wrapper);
            continue;
          }
          if (schema.isValidChild(node.parent.name, 'div') && schema.isValidChild('div', node.name)) {
            const wrapper = new AstNode('div', 1);
            onCreate(wrapper);
            node.wrap(wrapper);
          } else {
            removeOrUnwrapInvalidNode(node, schema);
          }
        }
      }
    };
    const hasClosest = (node, parentName) => {
      let tempNode = node;
      while (tempNode) {
        if (tempNode.name === parentName) {
          return true;
        }
        tempNode = tempNode.parent;
      }
      return false;
    };
    const isInvalid = (schema, node, parent = node.parent) => {
      if (parent && schema.children[node.name] && !schema.isValidChild(parent.name, node.name)) {
        return true;
      } else if (parent && node.name === 'a' && hasClosest(parent, 'a')) {
        return true;
      } else {
        return false;
      }
    };

    const createRange = (sc, so, ec, eo) => {
      const rng = document.createRange();
      rng.setStart(sc, so);
      rng.setEnd(ec, eo);
      return rng;
    };
    const normalizeBlockSelectionRange = rng => {
      const startPos = CaretPosition.fromRangeStart(rng);
      const endPos = CaretPosition.fromRangeEnd(rng);
      const rootNode = rng.commonAncestorContainer;
      return fromPosition(false, rootNode, endPos).map(newEndPos => {
        if (!isInSameBlock(startPos, endPos, rootNode) && isInSameBlock(startPos, newEndPos, rootNode)) {
          return createRange(startPos.container(), startPos.offset(), newEndPos.container(), newEndPos.offset());
        } else {
          return rng;
        }
      }).getOr(rng);
    };
    const normalize = rng => rng.collapsed ? rng : normalizeBlockSelectionRange(rng);

    const hasOnlyOneChild = node => {
      return isNonNullable(node.firstChild) && node.firstChild === node.lastChild;
    };
    const isPaddingNode = node => {
      return node.name === 'br' || node.value === nbsp;
    };
    const isPaddedEmptyBlock = (schema, node) => {
      const blockElements = schema.getBlockElements();
      return blockElements[node.name] && hasOnlyOneChild(node) && isPaddingNode(node.firstChild);
    };
    const isEmptyFragmentElement = (schema, node) => {
      const nonEmptyElements = schema.getNonEmptyElements();
      return isNonNullable(node) && (node.isEmpty(nonEmptyElements) || isPaddedEmptyBlock(schema, node));
    };
    const isListFragment = (schema, fragment) => {
      let firstChild = fragment.firstChild;
      let lastChild = fragment.lastChild;
      if (firstChild && firstChild.name === 'meta') {
        firstChild = firstChild.next;
      }
      if (lastChild && lastChild.attr('id') === 'mce_marker') {
        lastChild = lastChild.prev;
      }
      if (isEmptyFragmentElement(schema, lastChild)) {
        lastChild = lastChild === null || lastChild === void 0 ? void 0 : lastChild.prev;
      }
      if (!firstChild || firstChild !== lastChild) {
        return false;
      }
      return firstChild.name === 'ul' || firstChild.name === 'ol';
    };
    const cleanupDomFragment = domFragment => {
      var _a, _b;
      const firstChild = domFragment.firstChild;
      const lastChild = domFragment.lastChild;
      if (firstChild && firstChild.nodeName === 'META') {
        (_a = firstChild.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(firstChild);
      }
      if (lastChild && lastChild.id === 'mce_marker') {
        (_b = lastChild.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(lastChild);
      }
      return domFragment;
    };
    const toDomFragment = (dom, serializer, fragment) => {
      const html = serializer.serialize(fragment);
      const domFragment = dom.createFragment(html);
      return cleanupDomFragment(domFragment);
    };
    const listItems = elm => {
      var _a;
      return filter$5((_a = elm === null || elm === void 0 ? void 0 : elm.childNodes) !== null && _a !== void 0 ? _a : [], child => {
        return child.nodeName === 'LI';
      });
    };
    const isPadding = node => {
      return node.data === nbsp || isBr$6(node);
    };
    const isListItemPadded = node => {
      return isNonNullable(node === null || node === void 0 ? void 0 : node.firstChild) && node.firstChild === node.lastChild && isPadding(node.firstChild);
    };
    const isEmptyOrPadded = elm => {
      return !elm.firstChild || isListItemPadded(elm);
    };
    const trimListItems = elms => {
      return elms.length > 0 && isEmptyOrPadded(elms[elms.length - 1]) ? elms.slice(0, -1) : elms;
    };
    const getParentLi = (dom, node) => {
      const parentBlock = dom.getParent(node, dom.isBlock);
      return parentBlock && parentBlock.nodeName === 'LI' ? parentBlock : null;
    };
    const isParentBlockLi = (dom, node) => {
      return !!getParentLi(dom, node);
    };
    const getSplit = (parentNode, rng) => {
      const beforeRng = rng.cloneRange();
      const afterRng = rng.cloneRange();
      beforeRng.setStartBefore(parentNode);
      afterRng.setEndAfter(parentNode);
      return [
        beforeRng.cloneContents(),
        afterRng.cloneContents()
      ];
    };
    const findFirstIn = (node, rootNode) => {
      const caretPos = CaretPosition.before(node);
      const caretWalker = CaretWalker(rootNode);
      const newCaretPos = caretWalker.next(caretPos);
      return newCaretPos ? newCaretPos.toRange() : null;
    };
    const findLastOf = (node, rootNode) => {
      const caretPos = CaretPosition.after(node);
      const caretWalker = CaretWalker(rootNode);
      const newCaretPos = caretWalker.prev(caretPos);
      return newCaretPos ? newCaretPos.toRange() : null;
    };
    const insertMiddle = (target, elms, rootNode, rng) => {
      const parts = getSplit(target, rng);
      const parentElm = target.parentNode;
      if (parentElm) {
        parentElm.insertBefore(parts[0], target);
        Tools.each(elms, li => {
          parentElm.insertBefore(li, target);
        });
        parentElm.insertBefore(parts[1], target);
        parentElm.removeChild(target);
      }
      return findLastOf(elms[elms.length - 1], rootNode);
    };
    const insertBefore$1 = (target, elms, rootNode) => {
      const parentElm = target.parentNode;
      if (parentElm) {
        Tools.each(elms, elm => {
          parentElm.insertBefore(elm, target);
        });
      }
      return findFirstIn(target, rootNode);
    };
    const insertAfter$1 = (target, elms, rootNode, dom) => {
      dom.insertAfter(elms.reverse(), target);
      return findLastOf(elms[0], rootNode);
    };
    const insertAtCaret$1 = (serializer, dom, rng, fragment) => {
      const domFragment = toDomFragment(dom, serializer, fragment);
      const liTarget = getParentLi(dom, rng.startContainer);
      const liElms = trimListItems(listItems(domFragment.firstChild));
      const BEGINNING = 1, END = 2;
      const rootNode = dom.getRoot();
      const isAt = location => {
        const caretPos = CaretPosition.fromRangeStart(rng);
        const caretWalker = CaretWalker(dom.getRoot());
        const newPos = location === BEGINNING ? caretWalker.prev(caretPos) : caretWalker.next(caretPos);
        const newPosNode = newPos === null || newPos === void 0 ? void 0 : newPos.getNode();
        return newPosNode ? getParentLi(dom, newPosNode) !== liTarget : true;
      };
      if (!liTarget) {
        return null;
      } else if (isAt(BEGINNING)) {
        return insertBefore$1(liTarget, liElms, rootNode);
      } else if (isAt(END)) {
        return insertAfter$1(liTarget, liElms, rootNode, dom);
      } else {
        return insertMiddle(liTarget, liElms, rootNode, rng);
      }
    };

    const mergeableWrappedElements = ['pre'];
    const shouldPasteContentOnly = (dom, fragment, parentNode, root) => {
      var _a;
      const firstNode = fragment.firstChild;
      const lastNode = fragment.lastChild;
      const last = lastNode.attr('data-mce-type') === 'bookmark' ? lastNode.prev : lastNode;
      const isPastingSingleElement = firstNode === last;
      const isWrappedElement = contains$2(mergeableWrappedElements, firstNode.name);
      if (isPastingSingleElement && isWrappedElement) {
        const isContentEditable = firstNode.attr('contenteditable') !== 'false';
        const isPastingInTheSameBlockTag = ((_a = dom.getParent(parentNode, dom.isBlock)) === null || _a === void 0 ? void 0 : _a.nodeName.toLowerCase()) === firstNode.name;
        const isPastingInContentEditable = Optional.from(getContentEditableRoot$1(root, parentNode)).forall(isContentEditableTrue$3);
        return isContentEditable && isPastingInTheSameBlockTag && isPastingInContentEditable;
      } else {
        return false;
      }
    };
    const isTableCell = isTableCell$3;
    const isTableCellContentSelected = (dom, rng, cell) => {
      if (isNonNullable(cell)) {
        const endCell = dom.getParent(rng.endContainer, isTableCell);
        return cell === endCell && hasAllContentsSelected(SugarElement.fromDom(cell), rng);
      } else {
        return false;
      }
    };
    const validInsertion = (editor, value, parentNode) => {
      var _a;
      if (parentNode.getAttribute('data-mce-bogus') === 'all') {
        (_a = parentNode.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(editor.dom.createFragment(value), parentNode);
      } else {
        const node = parentNode.firstChild;
        const node2 = parentNode.lastChild;
        if (!node || node === node2 && node.nodeName === 'BR') {
          editor.dom.setHTML(parentNode, value);
        } else {
          editor.selection.setContent(value, { no_events: true });
        }
      }
    };
    const trimBrsFromTableCell = (dom, elm) => {
      Optional.from(dom.getParent(elm, 'td,th')).map(SugarElement.fromDom).each(trimBlockTrailingBr);
    };
    const reduceInlineTextElements = (editor, merge) => {
      const textInlineElements = editor.schema.getTextInlineElements();
      const dom = editor.dom;
      if (merge) {
        const root = editor.getBody();
        const elementUtils = ElementUtils(editor);
        Tools.each(dom.select('*[data-mce-fragment]'), node => {
          const isInline = isNonNullable(textInlineElements[node.nodeName.toLowerCase()]);
          if (isInline && hasInheritableStyles(dom, node)) {
            for (let parentNode = node.parentElement; isNonNullable(parentNode) && parentNode !== root; parentNode = parentNode.parentElement) {
              const styleConflict = hasStyleConflict(dom, node, parentNode);
              if (styleConflict) {
                break;
              }
              if (elementUtils.compare(parentNode, node)) {
                dom.remove(node, true);
                break;
              }
            }
          }
        });
      }
    };
    const markFragmentElements = fragment => {
      let node = fragment;
      while (node = node.walk()) {
        if (node.type === 1) {
          node.attr('data-mce-fragment', '1');
        }
      }
    };
    const unmarkFragmentElements = elm => {
      Tools.each(elm.getElementsByTagName('*'), elm => {
        elm.removeAttribute('data-mce-fragment');
      });
    };
    const isPartOfFragment = node => {
      return !!node.getAttribute('data-mce-fragment');
    };
    const canHaveChildren = (editor, node) => {
      return isNonNullable(node) && !editor.schema.getVoidElements()[node.nodeName];
    };
    const moveSelectionToMarker = (editor, marker) => {
      var _a, _b, _c;
      let nextRng;
      const dom = editor.dom;
      const selection = editor.selection;
      if (!marker) {
        return;
      }
      selection.scrollIntoView(marker);
      const parentEditableElm = getContentEditableRoot$1(editor.getBody(), marker);
      if (parentEditableElm && dom.getContentEditable(parentEditableElm) === 'false') {
        dom.remove(marker);
        selection.select(parentEditableElm);
        return;
      }
      let rng = dom.createRng();
      const node = marker.previousSibling;
      if (isText$a(node)) {
        rng.setStart(node, (_b = (_a = node.nodeValue) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0);
        const node2 = marker.nextSibling;
        if (isText$a(node2)) {
          node.appendData(node2.data);
          (_c = node2.parentNode) === null || _c === void 0 ? void 0 : _c.removeChild(node2);
        }
      } else {
        rng.setStartBefore(marker);
        rng.setEndBefore(marker);
      }
      const findNextCaretRng = rng => {
        let caretPos = CaretPosition.fromRangeStart(rng);
        const caretWalker = CaretWalker(editor.getBody());
        caretPos = caretWalker.next(caretPos);
        return caretPos === null || caretPos === void 0 ? void 0 : caretPos.toRange();
      };
      const parentBlock = dom.getParent(marker, dom.isBlock);
      dom.remove(marker);
      if (parentBlock && dom.isEmpty(parentBlock)) {
        empty(SugarElement.fromDom(parentBlock));
        rng.setStart(parentBlock, 0);
        rng.setEnd(parentBlock, 0);
        if (!isTableCell(parentBlock) && !isPartOfFragment(parentBlock) && (nextRng = findNextCaretRng(rng))) {
          rng = nextRng;
          dom.remove(parentBlock);
        } else {
          dom.add(parentBlock, dom.create('br', { 'data-mce-bogus': '1' }));
        }
      }
      selection.setRng(rng);
    };
    const deleteSelectedContent = editor => {
      const dom = editor.dom;
      const rng = normalize(editor.selection.getRng());
      editor.selection.setRng(rng);
      const startCell = dom.getParent(rng.startContainer, isTableCell);
      if (isTableCellContentSelected(dom, rng, startCell)) {
        deleteCellContents(editor, rng, SugarElement.fromDom(startCell));
      } else if (rng.startContainer === rng.endContainer && rng.endOffset - rng.startOffset === 1 && isText$a(rng.startContainer.childNodes[rng.startOffset])) {
        rng.deleteContents();
      } else {
        editor.getDoc().execCommand('Delete', false);
      }
    };
    const findMarkerNode = scope => {
      for (let markerNode = scope; markerNode; markerNode = markerNode.walk()) {
        if (markerNode.attr('id') === 'mce_marker') {
          return Optional.some(markerNode);
        }
      }
      return Optional.none();
    };
    const insertHtmlAtCaret = (editor, value, details) => {
      var _a, _b;
      const selection = editor.selection;
      const dom = editor.dom;
      const parser = editor.parser;
      const merge = details.merge;
      const serializer = HtmlSerializer({ validate: true }, editor.schema);
      const bookmarkHtml = '<span id="mce_marker" data-mce-type="bookmark">&#xFEFF;</span>';
      if (value.indexOf('{$caret}') === -1) {
        value += '{$caret}';
      }
      value = value.replace(/\{\$caret\}/, bookmarkHtml);
      let rng = selection.getRng();
      const caretElement = rng.startContainer;
      const body = editor.getBody();
      if (caretElement === body && selection.isCollapsed()) {
        if (dom.isBlock(body.firstChild) && canHaveChildren(editor, body.firstChild) && dom.isEmpty(body.firstChild)) {
          rng = dom.createRng();
          rng.setStart(body.firstChild, 0);
          rng.setEnd(body.firstChild, 0);
          selection.setRng(rng);
        }
      }
      if (!selection.isCollapsed()) {
        deleteSelectedContent(editor);
      }
      const parentNode = selection.getNode();
      const parserArgs = {
        context: parentNode.nodeName.toLowerCase(),
        data: details.data,
        insert: true
      };
      const fragment = parser.parse(value, parserArgs);
      if (details.paste === true && isListFragment(editor.schema, fragment) && isParentBlockLi(dom, parentNode)) {
        rng = insertAtCaret$1(serializer, dom, selection.getRng(), fragment);
        if (rng) {
          selection.setRng(rng);
        }
        return value;
      }
      if (details.paste === true && shouldPasteContentOnly(dom, fragment, parentNode, editor.getBody())) {
        (_a = fragment.firstChild) === null || _a === void 0 ? void 0 : _a.unwrap();
      }
      markFragmentElements(fragment);
      let node = fragment.lastChild;
      if (node && node.attr('id') === 'mce_marker') {
        const marker = node;
        for (node = node.prev; node; node = node.walk(true)) {
          if (node.type === 3 || !dom.isBlock(node.name)) {
            if (node.parent && editor.schema.isValidChild(node.parent.name, 'span')) {
              node.parent.insert(marker, node, node.name === 'br');
            }
            break;
          }
        }
      }
      editor._selectionOverrides.showBlockCaretContainer(parentNode);
      if (!parserArgs.invalid) {
        value = serializer.serialize(fragment);
        validInsertion(editor, value, parentNode);
      } else {
        editor.selection.setContent(bookmarkHtml);
        let parentNode = selection.getNode();
        let tempNode;
        const rootNode = editor.getBody();
        if (isDocument$1(parentNode)) {
          parentNode = tempNode = rootNode;
        } else {
          tempNode = parentNode;
        }
        while (tempNode && tempNode !== rootNode) {
          parentNode = tempNode;
          tempNode = tempNode.parentNode;
        }
        value = parentNode === rootNode ? rootNode.innerHTML : dom.getOuterHTML(parentNode);
        const root = parser.parse(value);
        const markerNode = findMarkerNode(root);
        const editingHost = markerNode.bind(findClosestEditingHost).getOr(root);
        markerNode.each(marker => marker.replace(fragment));
        const toExtract = fragment.children();
        const parent = (_b = fragment.parent) !== null && _b !== void 0 ? _b : root;
        fragment.unwrap();
        const invalidChildren = filter$5(toExtract, node => isInvalid(editor.schema, node, parent));
        cleanInvalidNodes(invalidChildren, editor.schema, editingHost);
        filter$2(parser.getNodeFilters(), parser.getAttributeFilters(), root);
        value = serializer.serialize(root);
        if (parentNode === rootNode) {
          dom.setHTML(rootNode, value);
        } else {
          dom.setOuterHTML(parentNode, value);
        }
      }
      reduceInlineTextElements(editor, merge);
      moveSelectionToMarker(editor, dom.get('mce_marker'));
      unmarkFragmentElements(editor.getBody());
      trimBrsFromTableCell(dom, selection.getStart());
      updateCaret(editor.schema, editor.getBody(), selection.getStart());
      return value;
    };

    const isTreeNode = content => content instanceof AstNode;

    const moveSelection = editor => {
      if (hasFocus(editor)) {
        firstPositionIn(editor.getBody()).each(pos => {
          const node = pos.getNode();
          const caretPos = isTable$2(node) ? firstPositionIn(node).getOr(pos) : pos;
          editor.selection.setRng(caretPos.toRange());
        });
      }
    };
    const setEditorHtml = (editor, html, noSelection) => {
      editor.dom.setHTML(editor.getBody(), html);
      if (noSelection !== true) {
        moveSelection(editor);
      }
    };
    const setContentString = (editor, body, content, args) => {
      if (content.length === 0 || /^\s+$/.test(content)) {
        const padd = '<br data-mce-bogus="1">';
        if (body.nodeName === 'TABLE') {
          content = '<tr><td>' + padd + '</td></tr>';
        } else if (/^(UL|OL)$/.test(body.nodeName)) {
          content = '<li>' + padd + '</li>';
        }
        const forcedRootBlockName = getForcedRootBlock(editor);
        if (editor.schema.isValidChild(body.nodeName.toLowerCase(), forcedRootBlockName.toLowerCase())) {
          content = padd;
          content = editor.dom.createHTML(forcedRootBlockName, getForcedRootBlockAttrs(editor), content);
        } else if (!content) {
          content = padd;
        }
        setEditorHtml(editor, content, args.no_selection);
        return {
          content,
          html: content
        };
      } else {
        if (args.format !== 'raw') {
          content = HtmlSerializer({ validate: false }, editor.schema).serialize(editor.parser.parse(content, {
            isRootContent: true,
            insert: true
          }));
        }
        const trimmedHtml = isWsPreserveElement(SugarElement.fromDom(body)) ? content : Tools.trim(content);
        setEditorHtml(editor, trimmedHtml, args.no_selection);
        return {
          content: trimmedHtml,
          html: trimmedHtml
        };
      }
    };
    const setContentTree = (editor, body, content, args) => {
      filter$2(editor.parser.getNodeFilters(), editor.parser.getAttributeFilters(), content);
      const html = HtmlSerializer({ validate: false }, editor.schema).serialize(content);
      const trimmedHtml = isWsPreserveElement(SugarElement.fromDom(body)) ? html : Tools.trim(html);
      setEditorHtml(editor, trimmedHtml, args.no_selection);
      return {
        content,
        html: trimmedHtml
      };
    };
    const setContentInternal = (editor, content, args) => {
      return Optional.from(editor.getBody()).map(body => {
        if (isTreeNode(content)) {
          return setContentTree(editor, body, content, args);
        } else {
          return setContentString(editor, body, content, args);
        }
      }).getOr({
        content,
        html: isTreeNode(args.content) ? '' : args.content
      });
    };

    const ancestor$1 = (scope, predicate, isRoot) => ancestor$4(scope, predicate, isRoot).isSome();
    const sibling = (scope, predicate) => sibling$1(scope, predicate).isSome();

    const ensureIsRoot = isRoot => isFunction(isRoot) ? isRoot : never;
    const ancestor = (scope, transform, isRoot) => {
      let element = scope.dom;
      const stop = ensureIsRoot(isRoot);
      while (element.parentNode) {
        element = element.parentNode;
        const el = SugarElement.fromDom(element);
        const transformed = transform(el);
        if (transformed.isSome()) {
          return transformed;
        } else if (stop(el)) {
          break;
        }
      }
      return Optional.none();
    };
    const closest$1 = (scope, transform, isRoot) => {
      const current = transform(scope);
      const stop = ensureIsRoot(isRoot);
      return current.orThunk(() => stop(scope) ? Optional.none() : ancestor(scope, transform, stop));
    };

    const isEq$3 = isEq$5;
    const matchesUnInheritedFormatSelector = (ed, node, name) => {
      const formatList = ed.formatter.get(name);
      if (formatList) {
        for (let i = 0; i < formatList.length; i++) {
          const format = formatList[i];
          if (isSelectorFormat(format) && format.inherit === false && ed.dom.is(node, format.selector)) {
            return true;
          }
        }
      }
      return false;
    };
    const matchParents = (editor, node, name, vars, similar) => {
      const root = editor.dom.getRoot();
      if (node === root) {
        return false;
      }
      const matchedNode = editor.dom.getParent(node, elm => {
        if (matchesUnInheritedFormatSelector(editor, elm, name)) {
          return true;
        }
        return elm.parentNode === root || !!matchNode(editor, elm, name, vars, true);
      });
      return !!matchNode(editor, matchedNode, name, vars, similar);
    };
    const matchName = (dom, node, format) => {
      if (isInlineFormat(format) && isEq$3(node, format.inline)) {
        return true;
      }
      if (isBlockFormat(format) && isEq$3(node, format.block)) {
        return true;
      }
      if (isSelectorFormat(format)) {
        return isElement$6(node) && dom.is(node, format.selector);
      }
      return false;
    };
    const matchItems = (dom, node, format, itemName, similar, vars) => {
      const items = format[itemName];
      const matchAttributes = itemName === 'attributes';
      if (isFunction(format.onmatch)) {
        return format.onmatch(node, format, itemName);
      }
      if (items) {
        if (!isArrayLike(items)) {
          for (const key in items) {
            if (has$2(items, key)) {
              const value = matchAttributes ? dom.getAttrib(node, key) : getStyle(dom, node, key);
              const expectedValue = replaceVars(items[key], vars);
              const isEmptyValue = isNullable(value) || isEmpty$3(value);
              if (isEmptyValue && isNullable(expectedValue)) {
                continue;
              }
              if (similar && isEmptyValue && !format.exact) {
                return false;
              }
              if ((!similar || format.exact) && !isEq$3(value, normalizeStyleValue(expectedValue, key))) {
                return false;
              }
            }
          }
        } else {
          for (let i = 0; i < items.length; i++) {
            if (matchAttributes ? dom.getAttrib(node, items[i]) : getStyle(dom, node, items[i])) {
              return true;
            }
          }
        }
      }
      return true;
    };
    const matchNode = (ed, node, name, vars, similar) => {
      const formatList = ed.formatter.get(name);
      const dom = ed.dom;
      if (formatList && isElement$6(node)) {
        for (let i = 0; i < formatList.length; i++) {
          const format = formatList[i];
          if (matchName(ed.dom, node, format) && matchItems(dom, node, format, 'attributes', similar, vars) && matchItems(dom, node, format, 'styles', similar, vars)) {
            const classes = format.classes;
            if (classes) {
              for (let x = 0; x < classes.length; x++) {
                if (!ed.dom.hasClass(node, replaceVars(classes[x], vars))) {
                  return;
                }
              }
            }
            return format;
          }
        }
      }
      return undefined;
    };
    const match$2 = (editor, name, vars, node, similar) => {
      if (node) {
        return matchParents(editor, node, name, vars, similar);
      }
      node = editor.selection.getNode();
      if (matchParents(editor, node, name, vars, similar)) {
        return true;
      }
      const startNode = editor.selection.getStart();
      if (startNode !== node) {
        if (matchParents(editor, startNode, name, vars, similar)) {
          return true;
        }
      }
      return false;
    };
    const matchAll = (editor, names, vars) => {
      const matchedFormatNames = [];
      const checkedMap = {};
      const startElement = editor.selection.getStart();
      editor.dom.getParent(startElement, node => {
        for (let i = 0; i < names.length; i++) {
          const name = names[i];
          if (!checkedMap[name] && matchNode(editor, node, name, vars)) {
            checkedMap[name] = true;
            matchedFormatNames.push(name);
          }
        }
      }, editor.dom.getRoot());
      return matchedFormatNames;
    };
    const closest = (editor, names) => {
      const isRoot = elm => eq(elm, SugarElement.fromDom(editor.getBody()));
      const match = (elm, name) => matchNode(editor, elm.dom, name) ? Optional.some(name) : Optional.none();
      return Optional.from(editor.selection.getStart(true)).bind(rawElm => closest$1(SugarElement.fromDom(rawElm), elm => findMap(names, name => match(elm, name)), isRoot)).getOrNull();
    };
    const canApply = (editor, name) => {
      const formatList = editor.formatter.get(name);
      const dom = editor.dom;
      if (formatList) {
        const startNode = editor.selection.getStart();
        const parents = getParents$2(dom, startNode);
        for (let x = formatList.length - 1; x >= 0; x--) {
          const format = formatList[x];
          if (!isSelectorFormat(format)) {
            return true;
          }
          for (let i = parents.length - 1; i >= 0; i--) {
            if (dom.is(parents[i], format.selector)) {
              return true;
            }
          }
        }
      }
      return false;
    };
    const matchAllOnNode = (editor, node, formatNames) => foldl(formatNames, (acc, name) => {
      const matchSimilar = isVariableFormatName(editor, name);
      if (editor.formatter.matchNode(node, name, {}, matchSimilar)) {
        return acc.concat([name]);
      } else {
        return acc;
      }
    }, []);

    const ZWSP = ZWSP$1;
    const importNode = (ownerDocument, node) => {
      return ownerDocument.importNode(node, true);
    };
    const getEmptyCaretContainers = node => {
      const nodes = [];
      let tempNode = node;
      while (tempNode) {
        if (isText$a(tempNode) && tempNode.data !== ZWSP || tempNode.childNodes.length > 1) {
          return [];
        }
        if (isElement$6(tempNode)) {
          nodes.push(tempNode);
        }
        tempNode = tempNode.firstChild;
      }
      return nodes;
    };
    const isCaretContainerEmpty = node => {
      return getEmptyCaretContainers(node).length > 0;
    };
    const findFirstTextNode = node => {
      if (node) {
        const walker = new DomTreeWalker(node, node);
        for (let tempNode = walker.current(); tempNode; tempNode = walker.next()) {
          if (isText$a(tempNode)) {
            return tempNode;
          }
        }
      }
      return null;
    };
    const createCaretContainer = fill => {
      const caretContainer = SugarElement.fromTag('span');
      setAll$1(caretContainer, {
        'id': CARET_ID,
        'data-mce-bogus': '1',
        'data-mce-type': 'format-caret'
      });
      if (fill) {
        append$1(caretContainer, SugarElement.fromText(ZWSP));
      }
      return caretContainer;
    };
    const trimZwspFromCaretContainer = caretContainerNode => {
      const textNode = findFirstTextNode(caretContainerNode);
      if (textNode && textNode.data.charAt(0) === ZWSP) {
        textNode.deleteData(0, 1);
      }
      return textNode;
    };
    const removeCaretContainerNode = (editor, node, moveCaret = true) => {
      const dom = editor.dom, selection = editor.selection;
      if (isCaretContainerEmpty(node)) {
        deleteElement$2(editor, false, SugarElement.fromDom(node), moveCaret);
      } else {
        const rng = selection.getRng();
        const block = dom.getParent(node, dom.isBlock);
        const startContainer = rng.startContainer;
        const startOffset = rng.startOffset;
        const endContainer = rng.endContainer;
        const endOffset = rng.endOffset;
        const textNode = trimZwspFromCaretContainer(node);
        dom.remove(node, true);
        if (startContainer === textNode && startOffset > 0) {
          rng.setStart(textNode, startOffset - 1);
        }
        if (endContainer === textNode && endOffset > 0) {
          rng.setEnd(textNode, endOffset - 1);
        }
        if (block && dom.isEmpty(block)) {
          fillWithPaddingBr(SugarElement.fromDom(block));
        }
        selection.setRng(rng);
      }
    };
    const removeCaretContainer = (editor, node, moveCaret = true) => {
      const dom = editor.dom, selection = editor.selection;
      if (!node) {
        node = getParentCaretContainer(editor.getBody(), selection.getStart());
        if (!node) {
          while (node = dom.get(CARET_ID)) {
            removeCaretContainerNode(editor, node, false);
          }
        }
      } else {
        removeCaretContainerNode(editor, node, moveCaret);
      }
    };
    const insertCaretContainerNode = (editor, caretContainer, formatNode) => {
      var _a, _b;
      const dom = editor.dom;
      const block = dom.getParent(formatNode, curry(isTextBlock$1, editor.schema));
      if (block && dom.isEmpty(block)) {
        (_a = formatNode.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(caretContainer, formatNode);
      } else {
        removeTrailingBr(SugarElement.fromDom(formatNode));
        if (dom.isEmpty(formatNode)) {
          (_b = formatNode.parentNode) === null || _b === void 0 ? void 0 : _b.replaceChild(caretContainer, formatNode);
        } else {
          dom.insertAfter(caretContainer, formatNode);
        }
      }
    };
    const appendNode = (parentNode, node) => {
      parentNode.appendChild(node);
      return node;
    };
    const insertFormatNodesIntoCaretContainer = (formatNodes, caretContainer) => {
      var _a;
      const innerMostFormatNode = foldr(formatNodes, (parentNode, formatNode) => {
        return appendNode(parentNode, formatNode.cloneNode(false));
      }, caretContainer);
      const doc = (_a = innerMostFormatNode.ownerDocument) !== null && _a !== void 0 ? _a : document;
      return appendNode(innerMostFormatNode, doc.createTextNode(ZWSP));
    };
    const cleanFormatNode = (editor, caretContainer, formatNode, name, vars, similar) => {
      const formatter = editor.formatter;
      const dom = editor.dom;
      const validFormats = filter$5(keys(formatter.get()), formatName => formatName !== name && !contains$1(formatName, 'removeformat'));
      const matchedFormats = matchAllOnNode(editor, formatNode, validFormats);
      const uniqueFormats = filter$5(matchedFormats, fmtName => !areSimilarFormats(editor, fmtName, name));
      if (uniqueFormats.length > 0) {
        const clonedFormatNode = formatNode.cloneNode(false);
        dom.add(caretContainer, clonedFormatNode);
        formatter.remove(name, vars, clonedFormatNode, similar);
        dom.remove(clonedFormatNode);
        return Optional.some(clonedFormatNode);
      } else {
        return Optional.none();
      }
    };
    const applyCaretFormat = (editor, name, vars) => {
      let caretContainer;
      const selection = editor.selection;
      const formatList = editor.formatter.get(name);
      if (!formatList) {
        return;
      }
      const selectionRng = selection.getRng();
      let offset = selectionRng.startOffset;
      const container = selectionRng.startContainer;
      const text = container.nodeValue;
      caretContainer = getParentCaretContainer(editor.getBody(), selection.getStart());
      const wordcharRegex = /[^\s\u00a0\u00ad\u200b\ufeff]/;
      if (text && offset > 0 && offset < text.length && wordcharRegex.test(text.charAt(offset)) && wordcharRegex.test(text.charAt(offset - 1))) {
        const bookmark = selection.getBookmark();
        selectionRng.collapse(true);
        let rng = expandRng(editor.dom, selectionRng, formatList);
        rng = split(rng);
        editor.formatter.apply(name, vars, rng);
        selection.moveToBookmark(bookmark);
      } else {
        let textNode = caretContainer ? findFirstTextNode(caretContainer) : null;
        if (!caretContainer || (textNode === null || textNode === void 0 ? void 0 : textNode.data) !== ZWSP) {
          caretContainer = importNode(editor.getDoc(), createCaretContainer(true).dom);
          textNode = caretContainer.firstChild;
          selectionRng.insertNode(caretContainer);
          offset = 1;
          editor.formatter.apply(name, vars, caretContainer);
        } else {
          editor.formatter.apply(name, vars, caretContainer);
        }
        selection.setCursorLocation(textNode, offset);
      }
    };
    const removeCaretFormat = (editor, name, vars, similar) => {
      const dom = editor.dom;
      const selection = editor.selection;
      let hasContentAfter = false;
      const formatList = editor.formatter.get(name);
      if (!formatList) {
        return;
      }
      const rng = selection.getRng();
      const container = rng.startContainer;
      const offset = rng.startOffset;
      let node = container;
      if (isText$a(container)) {
        if (offset !== container.data.length) {
          hasContentAfter = true;
        }
        node = node.parentNode;
      }
      const parents = [];
      let formatNode;
      while (node) {
        if (matchNode(editor, node, name, vars, similar)) {
          formatNode = node;
          break;
        }
        if (node.nextSibling) {
          hasContentAfter = true;
        }
        parents.push(node);
        node = node.parentNode;
      }
      if (!formatNode) {
        return;
      }
      if (hasContentAfter) {
        const bookmark = selection.getBookmark();
        rng.collapse(true);
        let expandedRng = expandRng(dom, rng, formatList, true);
        expandedRng = split(expandedRng);
        editor.formatter.remove(name, vars, expandedRng, similar);
        selection.moveToBookmark(bookmark);
      } else {
        const caretContainer = getParentCaretContainer(editor.getBody(), formatNode);
        const newCaretContainer = createCaretContainer(false).dom;
        insertCaretContainerNode(editor, newCaretContainer, caretContainer !== null && caretContainer !== void 0 ? caretContainer : formatNode);
        const cleanedFormatNode = cleanFormatNode(editor, newCaretContainer, formatNode, name, vars, similar);
        const caretTextNode = insertFormatNodesIntoCaretContainer(parents.concat(cleanedFormatNode.toArray()), newCaretContainer);
        if (caretContainer) {
          removeCaretContainerNode(editor, caretContainer, false);
        }
        selection.setCursorLocation(caretTextNode, 1);
        if (dom.isEmpty(formatNode)) {
          dom.remove(formatNode);
        }
      }
    };
    const disableCaretContainer = (editor, keyCode) => {
      const selection = editor.selection, body = editor.getBody();
      removeCaretContainer(editor, null, false);
      if ((keyCode === 8 || keyCode === 46) && selection.isCollapsed() && selection.getStart().innerHTML === ZWSP) {
        removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()));
      }
      if (keyCode === 37 || keyCode === 39) {
        removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()));
      }
    };
    const setup$u = editor => {
      editor.on('mouseup keydown', e => {
        disableCaretContainer(editor, e.keyCode);
      });
    };
    const createCaretFormat = formatNodes => {
      const caretContainer = createCaretContainer(false);
      const innerMost = insertFormatNodesIntoCaretContainer(formatNodes, caretContainer.dom);
      return {
        caretContainer,
        caretPosition: CaretPosition(innerMost, 0)
      };
    };
    const replaceWithCaretFormat = (targetNode, formatNodes) => {
      const {caretContainer, caretPosition} = createCaretFormat(formatNodes);
      before$3(SugarElement.fromDom(targetNode), caretContainer);
      remove$6(SugarElement.fromDom(targetNode));
      return caretPosition;
    };
    const createCaretFormatAtStart$1 = (editor, formatNodes) => {
      const {caretContainer, caretPosition} = createCaretFormat(formatNodes);
      editor.selection.getRng().insertNode(caretContainer.dom);
      return caretPosition;
    };
    const isFormatElement = (editor, element) => {
      const inlineElements = editor.schema.getTextInlineElements();
      return has$2(inlineElements, name(element)) && !isCaretNode(element.dom) && !isBogus$2(element.dom);
    };
    const isEmptyCaretFormatElement = element => {
      return isCaretNode(element.dom) && isCaretContainerEmpty(element.dom);
    };

    const postProcessHooks = {};
    const isPre = matchNodeNames(['pre']);
    const addPostProcessHook = (name, hook) => {
      const hooks = postProcessHooks[name];
      if (!hooks) {
        postProcessHooks[name] = [];
      }
      postProcessHooks[name].push(hook);
    };
    const postProcess$1 = (name, editor) => {
      if (has$2(postProcessHooks, name)) {
        each$e(postProcessHooks[name], hook => {
          hook(editor);
        });
      }
    };
    addPostProcessHook('pre', editor => {
      const rng = editor.selection.getRng();
      const hasPreSibling = blocks => pre => {
        const prev = pre.previousSibling;
        return isPre(prev) && contains$2(blocks, prev);
      };
      const joinPre = (pre1, pre2) => {
        const sPre2 = SugarElement.fromDom(pre2);
        const doc = documentOrOwner(sPre2).dom;
        remove$6(sPre2);
        append(SugarElement.fromDom(pre1), [
          SugarElement.fromTag('br', doc),
          SugarElement.fromTag('br', doc),
          ...children$1(sPre2)
        ]);
      };
      if (!rng.collapsed) {
        const blocks = editor.selection.getSelectedBlocks();
        const preBlocks = filter$5(filter$5(blocks, isPre), hasPreSibling(blocks));
        each$e(preBlocks, pre => {
          joinPre(pre.previousSibling, pre);
        });
      }
    });

    const listItemStyles = [
      'fontWeight',
      'fontStyle',
      'color',
      'fontSize',
      'fontFamily'
    ];
    const hasListStyles = fmt => isObject(fmt.styles) && exists(keys(fmt.styles), name => contains$2(listItemStyles, name));
    const findExpandedListItemFormat = formats => find$2(formats, fmt => isInlineFormat(fmt) && fmt.inline === 'span' && hasListStyles(fmt));
    const getExpandedListItemFormat = (formatter, format) => {
      const formatList = formatter.get(format);
      return isArray$1(formatList) ? findExpandedListItemFormat(formatList) : Optional.none();
    };
    const isRngStartAtStartOfElement = (rng, elm) => prevPosition(elm, CaretPosition.fromRangeStart(rng)).isNone();
    const isRngEndAtEndOfElement = (rng, elm) => {
      return nextPosition(elm, CaretPosition.fromRangeEnd(rng)).exists(pos => !isBr$6(pos.getNode()) || nextPosition(elm, pos).isSome()) === false;
    };
    const isEditableListItem = dom => elm => isListItem$2(elm) && dom.isEditable(elm);
    const getFullySelectedBlocks = selection => {
      const blocks = selection.getSelectedBlocks();
      const rng = selection.getRng();
      if (selection.isCollapsed()) {
        return [];
      }
      if (blocks.length === 1) {
        return isRngStartAtStartOfElement(rng, blocks[0]) && isRngEndAtEndOfElement(rng, blocks[0]) ? blocks : [];
      } else {
        const first = head(blocks).filter(elm => isRngStartAtStartOfElement(rng, elm)).toArray();
        const last = last$3(blocks).filter(elm => isRngEndAtEndOfElement(rng, elm)).toArray();
        const middle = blocks.slice(1, -1);
        return first.concat(middle).concat(last);
      }
    };
    const getFullySelectedListItems = selection => filter$5(getFullySelectedBlocks(selection), isEditableListItem(selection.dom));
    const getPartiallySelectedListItems = selection => filter$5(selection.getSelectedBlocks(), isEditableListItem(selection.dom));

    const each$8 = Tools.each;
    const isElementNode = node => isElement$6(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus$2(node);
    const findElementSibling = (node, siblingName) => {
      for (let sibling = node; sibling; sibling = sibling[siblingName]) {
        if (isText$a(sibling) && isNotEmpty(sibling.data)) {
          return node;
        }
        if (isElement$6(sibling) && !isBookmarkNode$1(sibling)) {
          return sibling;
        }
      }
      return node;
    };
    const mergeSiblingsNodes = (editor, prev, next) => {
      const elementUtils = ElementUtils(editor);
      const isPrevEditable = isElement$6(prev) && isEditable$2(prev);
      const isNextEditable = isElement$6(next) && isEditable$2(next);
      if (isPrevEditable && isNextEditable) {
        const prevSibling = findElementSibling(prev, 'previousSibling');
        const nextSibling = findElementSibling(next, 'nextSibling');
        if (elementUtils.compare(prevSibling, nextSibling)) {
          for (let sibling = prevSibling.nextSibling; sibling && sibling !== nextSibling;) {
            const tmpSibling = sibling;
            sibling = sibling.nextSibling;
            prevSibling.appendChild(tmpSibling);
          }
          editor.dom.remove(nextSibling);
          Tools.each(Tools.grep(nextSibling.childNodes), node => {
            prevSibling.appendChild(node);
          });
          return prevSibling;
        }
      }
      return next;
    };
    const mergeSiblings = (editor, format, vars, node) => {
      var _a;
      if (node && format.merge_siblings !== false) {
        const newNode = (_a = mergeSiblingsNodes(editor, getNonWhiteSpaceSibling(node), node)) !== null && _a !== void 0 ? _a : node;
        mergeSiblingsNodes(editor, newNode, getNonWhiteSpaceSibling(newNode, true));
      }
    };
    const clearChildStyles = (dom, format, node) => {
      if (format.clear_child_styles) {
        const selector = format.links ? '*:not(a)' : '*';
        each$8(dom.select(selector, node), childNode => {
          if (isElementNode(childNode) && isEditable$2(childNode)) {
            each$8(format.styles, (_value, name) => {
              dom.setStyle(childNode, name, '');
            });
          }
        });
      }
    };
    const processChildElements = (node, filter, process) => {
      each$8(node.childNodes, node => {
        if (isElementNode(node)) {
          if (filter(node)) {
            process(node);
          }
          if (node.hasChildNodes()) {
            processChildElements(node, filter, process);
          }
        }
      });
    };
    const unwrapEmptySpan = (dom, node) => {
      if (node.nodeName === 'SPAN' && dom.getAttribs(node).length === 0) {
        dom.remove(node, true);
      }
    };
    const hasStyle = (dom, name) => node => !!(node && getStyle(dom, node, name));
    const applyStyle = (dom, name, value) => node => {
      dom.setStyle(node, name, value);
      if (node.getAttribute('style') === '') {
        node.removeAttribute('style');
      }
      unwrapEmptySpan(dom, node);
    };

    const removeResult = Adt.generate([
      { keep: [] },
      { rename: ['name'] },
      { removed: [] }
    ]);
    const MCE_ATTR_RE = /^(src|href|style)$/;
    const each$7 = Tools.each;
    const isEq$2 = isEq$5;
    const isTableCellOrRow = node => /^(TR|TH|TD)$/.test(node.nodeName);
    const isChildOfInlineParent = (dom, node, parent) => dom.isChildOf(node, parent) && node !== parent && !dom.isBlock(parent);
    const getContainer = (ed, rng, start) => {
      let container = rng[start ? 'startContainer' : 'endContainer'];
      let offset = rng[start ? 'startOffset' : 'endOffset'];
      if (isElement$6(container)) {
        const lastIdx = container.childNodes.length - 1;
        if (!start && offset) {
          offset--;
        }
        container = container.childNodes[offset > lastIdx ? lastIdx : offset];
      }
      if (isText$a(container) && start && offset >= container.data.length) {
        container = new DomTreeWalker(container, ed.getBody()).next() || container;
      }
      if (isText$a(container) && !start && offset === 0) {
        container = new DomTreeWalker(container, ed.getBody()).prev() || container;
      }
      return container;
    };
    const normalizeTableSelection = (node, start) => {
      const prop = start ? 'firstChild' : 'lastChild';
      const childNode = node[prop];
      if (isTableCellOrRow(node) && childNode) {
        if (node.nodeName === 'TR') {
          return childNode[prop] || childNode;
        } else {
          return childNode;
        }
      }
      return node;
    };
    const wrap$1 = (dom, node, name, attrs) => {
      var _a;
      const wrapper = dom.create(name, attrs);
      (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(wrapper, node);
      wrapper.appendChild(node);
      return wrapper;
    };
    const wrapWithSiblings = (dom, node, next, name, attrs) => {
      const start = SugarElement.fromDom(node);
      const wrapper = SugarElement.fromDom(dom.create(name, attrs));
      const siblings = next ? nextSiblings(start) : prevSiblings(start);
      append(wrapper, siblings);
      if (next) {
        before$3(start, wrapper);
        prepend(wrapper, start);
      } else {
        after$4(start, wrapper);
        append$1(wrapper, start);
      }
      return wrapper.dom;
    };
    const isColorFormatAndAnchor = (node, format) => format.links && node.nodeName === 'A';
    const removeNode = (ed, node, format) => {
      const parentNode = node.parentNode;
      let rootBlockElm;
      const dom = ed.dom;
      const forcedRootBlock = getForcedRootBlock(ed);
      if (isBlockFormat(format)) {
        if (parentNode === dom.getRoot()) {
          if (!format.list_block || !isEq$2(node, format.list_block)) {
            each$e(from(node.childNodes), node => {
              if (isValid(ed, forcedRootBlock, node.nodeName.toLowerCase())) {
                if (!rootBlockElm) {
                  rootBlockElm = wrap$1(dom, node, forcedRootBlock);
                  dom.setAttribs(rootBlockElm, getForcedRootBlockAttrs(ed));
                } else {
                  rootBlockElm.appendChild(node);
                }
              } else {
                rootBlockElm = null;
              }
            });
          }
        }
      }
      if (isMixedFormat(format) && !isEq$2(format.inline, node)) {
        return;
      }
      dom.remove(node, true);
    };
    const processFormatAttrOrStyle = (name, value, vars) => {
      if (isNumber(name)) {
        return {
          name: value,
          value: null
        };
      } else {
        return {
          name,
          value: replaceVars(value, vars)
        };
      }
    };
    const removeEmptyStyleAttributeIfNeeded = (dom, elm) => {
      if (dom.getAttrib(elm, 'style') === '') {
        elm.removeAttribute('style');
        elm.removeAttribute('data-mce-style');
      }
    };
    const removeStyles = (dom, elm, format, vars, compareNode) => {
      let stylesModified = false;
      each$7(format.styles, (value, name) => {
        const {
          name: styleName,
          value: styleValue
        } = processFormatAttrOrStyle(name, value, vars);
        const normalizedStyleValue = normalizeStyleValue(styleValue, styleName);
        if (format.remove_similar || isNull(styleValue) || !isElement$6(compareNode) || isEq$2(getStyle(dom, compareNode, styleName), normalizedStyleValue)) {
          dom.setStyle(elm, styleName, '');
        }
        stylesModified = true;
      });
      if (stylesModified) {
        removeEmptyStyleAttributeIfNeeded(dom, elm);
      }
    };
    const removeListStyleFormats = (editor, name, vars) => {
      if (name === 'removeformat') {
        each$e(getPartiallySelectedListItems(editor.selection), li => {
          each$e(listItemStyles, name => editor.dom.setStyle(li, name, ''));
          removeEmptyStyleAttributeIfNeeded(editor.dom, li);
        });
      } else {
        getExpandedListItemFormat(editor.formatter, name).each(liFmt => {
          each$e(getPartiallySelectedListItems(editor.selection), li => removeStyles(editor.dom, li, liFmt, vars, null));
        });
      }
    };
    const removeFormatInternal = (ed, format, vars, node, compareNode) => {
      const dom = ed.dom;
      const elementUtils = ElementUtils(ed);
      const schema = ed.schema;
      if (isInlineFormat(format) && isTransparentElementName(schema, format.inline) && isTransparentBlock(schema, node) && node.parentElement === ed.getBody()) {
        removeNode(ed, node, format);
        return removeResult.removed();
      }
      if (!format.ceFalseOverride && node && dom.getContentEditableParent(node) === 'false') {
        return removeResult.keep();
      }
      if (node && !matchName(dom, node, format) && !isColorFormatAndAnchor(node, format)) {
        return removeResult.keep();
      }
      const elm = node;
      const preserveAttributes = format.preserve_attributes;
      if (isInlineFormat(format) && format.remove === 'all' && isArray$1(preserveAttributes)) {
        const attrsToPreserve = filter$5(dom.getAttribs(elm), attr => contains$2(preserveAttributes, attr.name.toLowerCase()));
        dom.removeAllAttribs(elm);
        each$e(attrsToPreserve, attr => dom.setAttrib(elm, attr.name, attr.value));
        if (attrsToPreserve.length > 0) {
          return removeResult.rename('span');
        }
      }
      if (format.remove !== 'all') {
        removeStyles(dom, elm, format, vars, compareNode);
        each$7(format.attributes, (value, name) => {
          const {
            name: attrName,
            value: attrValue
          } = processFormatAttrOrStyle(name, value, vars);
          if (format.remove_similar || isNull(attrValue) || !isElement$6(compareNode) || isEq$2(dom.getAttrib(compareNode, attrName), attrValue)) {
            if (attrName === 'class') {
              const currentValue = dom.getAttrib(elm, attrName);
              if (currentValue) {
                let valueOut = '';
                each$e(currentValue.split(/\s+/), cls => {
                  if (/mce\-\w+/.test(cls)) {
                    valueOut += (valueOut ? ' ' : '') + cls;
                  }
                });
                if (valueOut) {
                  dom.setAttrib(elm, attrName, valueOut);
                  return;
                }
              }
            }
            if (MCE_ATTR_RE.test(attrName)) {
              elm.removeAttribute('data-mce-' + attrName);
            }
            if (attrName === 'style' && matchNodeNames(['li'])(elm) && dom.getStyle(elm, 'list-style-type') === 'none') {
              elm.removeAttribute(attrName);
              dom.setStyle(elm, 'list-style-type', 'none');
              return;
            }
            if (attrName === 'class') {
              elm.removeAttribute('className');
            }
            elm.removeAttribute(attrName);
          }
        });
        each$7(format.classes, value => {
          value = replaceVars(value, vars);
          if (!isElement$6(compareNode) || dom.hasClass(compareNode, value)) {
            dom.removeClass(elm, value);
          }
        });
        const attrs = dom.getAttribs(elm);
        for (let i = 0; i < attrs.length; i++) {
          const attrName = attrs[i].nodeName;
          if (!elementUtils.isAttributeInternal(attrName)) {
            return removeResult.keep();
          }
        }
      }
      if (format.remove !== 'none') {
        removeNode(ed, elm, format);
        return removeResult.removed();
      }
      return removeResult.keep();
    };
    const removeFormat$1 = (ed, format, vars, node, compareNode) => removeFormatInternal(ed, format, vars, node, compareNode).fold(never, newName => {
      ed.dom.rename(node, newName);
      return true;
    }, always);
    const findFormatRoot = (editor, container, name, vars, similar) => {
      let formatRoot;
      if (container.parentNode) {
        each$e(getParents$2(editor.dom, container.parentNode).reverse(), parent => {
          if (!formatRoot && isElement$6(parent) && parent.id !== '_start' && parent.id !== '_end') {
            const format = matchNode(editor, parent, name, vars, similar);
            if (format && format.split !== false) {
              formatRoot = parent;
            }
          }
        });
      }
      return formatRoot;
    };
    const removeFormatFromClone = (editor, format, vars, clone) => removeFormatInternal(editor, format, vars, clone, clone).fold(constant(clone), newName => {
      const fragment = editor.dom.createFragment();
      fragment.appendChild(clone);
      return editor.dom.rename(clone, newName);
    }, constant(null));
    const wrapAndSplit = (editor, formatList, formatRoot, container, target, split, format, vars) => {
      var _a, _b;
      let lastClone;
      let firstClone;
      const dom = editor.dom;
      if (formatRoot) {
        const formatRootParent = formatRoot.parentNode;
        for (let parent = container.parentNode; parent && parent !== formatRootParent; parent = parent.parentNode) {
          let clone = dom.clone(parent, false);
          for (let i = 0; i < formatList.length; i++) {
            clone = removeFormatFromClone(editor, formatList[i], vars, clone);
            if (clone === null) {
              break;
            }
          }
          if (clone) {
            if (lastClone) {
              clone.appendChild(lastClone);
            }
            if (!firstClone) {
              firstClone = clone;
            }
            lastClone = clone;
          }
        }
        if (split && (!format.mixed || !dom.isBlock(formatRoot))) {
          container = (_a = dom.split(formatRoot, container)) !== null && _a !== void 0 ? _a : container;
        }
        if (lastClone && firstClone) {
          (_b = target.parentNode) === null || _b === void 0 ? void 0 : _b.insertBefore(lastClone, target);
          firstClone.appendChild(target);
          if (isInlineFormat(format)) {
            mergeSiblings(editor, format, vars, lastClone);
          }
        }
      }
      return container;
    };
    const remove$2 = (ed, name, vars, node, similar) => {
      const formatList = ed.formatter.get(name);
      const format = formatList[0];
      const dom = ed.dom;
      const selection = ed.selection;
      const splitToFormatRoot = container => {
        const formatRoot = findFormatRoot(ed, container, name, vars, similar);
        return wrapAndSplit(ed, formatList, formatRoot, container, container, true, format, vars);
      };
      const isRemoveBookmarkNode = node => isBookmarkNode$1(node) && isElement$6(node) && (node.id === '_start' || node.id === '_end');
      const removeNodeFormat = node => exists(formatList, fmt => removeFormat$1(ed, fmt, vars, node, node));
      const process = node => {
        const children = from(node.childNodes);
        const removed = removeNodeFormat(node);
        const currentNodeMatches = removed || exists(formatList, f => matchName(dom, node, f));
        const parentNode = node.parentNode;
        if (!currentNodeMatches && isNonNullable(parentNode) && shouldExpandToSelector(format)) {
          removeNodeFormat(parentNode);
        }
        if (format.deep) {
          if (children.length) {
            for (let i = 0; i < children.length; i++) {
              process(children[i]);
            }
          }
        }
        const textDecorations = [
          'underline',
          'line-through',
          'overline'
        ];
        each$e(textDecorations, decoration => {
          if (isElement$6(node) && ed.dom.getStyle(node, 'text-decoration') === decoration && node.parentNode && getTextDecoration(dom, node.parentNode) === decoration) {
            removeFormat$1(ed, {
              deep: false,
              exact: true,
              inline: 'span',
              styles: { textDecoration: decoration }
            }, undefined, node);
          }
        });
      };
      const unwrap = start => {
        const node = dom.get(start ? '_start' : '_end');
        if (node) {
          let out = node[start ? 'firstChild' : 'lastChild'];
          if (isRemoveBookmarkNode(out)) {
            out = out[start ? 'firstChild' : 'lastChild'];
          }
          if (isText$a(out) && out.data.length === 0) {
            out = start ? node.previousSibling || node.nextSibling : node.nextSibling || node.previousSibling;
          }
          dom.remove(node, true);
          return out;
        } else {
          return null;
        }
      };
      const removeRngStyle = rng => {
        let startContainer;
        let endContainer;
        let expandedRng = expandRng(dom, rng, formatList, rng.collapsed);
        if (format.split) {
          expandedRng = split(expandedRng);
          startContainer = getContainer(ed, expandedRng, true);
          endContainer = getContainer(ed, expandedRng);
          if (startContainer !== endContainer) {
            startContainer = normalizeTableSelection(startContainer, true);
            endContainer = normalizeTableSelection(endContainer, false);
            if (isChildOfInlineParent(dom, startContainer, endContainer)) {
              const marker = Optional.from(startContainer.firstChild).getOr(startContainer);
              splitToFormatRoot(wrapWithSiblings(dom, marker, true, 'span', {
                'id': '_start',
                'data-mce-type': 'bookmark'
              }));
              unwrap(true);
              return;
            }
            if (isChildOfInlineParent(dom, endContainer, startContainer)) {
              const marker = Optional.from(endContainer.lastChild).getOr(endContainer);
              splitToFormatRoot(wrapWithSiblings(dom, marker, false, 'span', {
                'id': '_end',
                'data-mce-type': 'bookmark'
              }));
              unwrap(false);
              return;
            }
            startContainer = wrap$1(dom, startContainer, 'span', {
              'id': '_start',
              'data-mce-type': 'bookmark'
            });
            endContainer = wrap$1(dom, endContainer, 'span', {
              'id': '_end',
              'data-mce-type': 'bookmark'
            });
            const newRng = dom.createRng();
            newRng.setStartAfter(startContainer);
            newRng.setEndBefore(endContainer);
            walk$3(dom, newRng, nodes => {
              each$e(nodes, n => {
                if (!isBookmarkNode$1(n) && !isBookmarkNode$1(n.parentNode)) {
                  splitToFormatRoot(n);
                }
              });
            });
            splitToFormatRoot(startContainer);
            splitToFormatRoot(endContainer);
            startContainer = unwrap(true);
            endContainer = unwrap();
          } else {
            startContainer = endContainer = splitToFormatRoot(startContainer);
          }
          expandedRng.startContainer = startContainer.parentNode ? startContainer.parentNode : startContainer;
          expandedRng.startOffset = dom.nodeIndex(startContainer);
          expandedRng.endContainer = endContainer.parentNode ? endContainer.parentNode : endContainer;
          expandedRng.endOffset = dom.nodeIndex(endContainer) + 1;
        }
        walk$3(dom, expandedRng, nodes => {
          each$e(nodes, process);
        });
      };
      if (node) {
        if (isNode(node)) {
          const rng = dom.createRng();
          rng.setStartBefore(node);
          rng.setEndAfter(node);
          removeRngStyle(rng);
        } else {
          removeRngStyle(node);
        }
        fireFormatRemove(ed, name, node, vars);
        return;
      }
      if (!selection.isCollapsed() || !isInlineFormat(format) || getCellsFromEditor(ed).length) {
        preserveSelection(ed, () => runOnRanges(ed, removeRngStyle), startNode => isInlineFormat(format) && match$2(ed, name, vars, startNode));
        ed.nodeChanged();
      } else {
        removeCaretFormat(ed, name, vars, similar);
      }
      removeListStyleFormats(ed, name, vars);
      fireFormatRemove(ed, name, node, vars);
    };

    const each$6 = Tools.each;
    const mergeTextDecorationsAndColor = (dom, format, vars, node) => {
      const processTextDecorationsAndColor = n => {
        if (isElement$6(n) && isElement$6(n.parentNode) && isEditable$2(n)) {
          const parentTextDecoration = getTextDecoration(dom, n.parentNode);
          if (dom.getStyle(n, 'color') && parentTextDecoration) {
            dom.setStyle(n, 'text-decoration', parentTextDecoration);
          } else if (dom.getStyle(n, 'text-decoration') === parentTextDecoration) {
            dom.setStyle(n, 'text-decoration', null);
          }
        }
      };
      if (format.styles && (format.styles.color || format.styles.textDecoration)) {
        Tools.walk(node, processTextDecorationsAndColor, 'childNodes');
        processTextDecorationsAndColor(node);
      }
    };
    const mergeBackgroundColorAndFontSize = (dom, format, vars, node) => {
      if (format.styles && format.styles.backgroundColor) {
        const hasFontSize = hasStyle(dom, 'fontSize');
        processChildElements(node, elm => hasFontSize(elm) && isEditable$2(elm), applyStyle(dom, 'backgroundColor', replaceVars(format.styles.backgroundColor, vars)));
      }
    };
    const mergeSubSup = (dom, format, vars, node) => {
      if (isInlineFormat(format) && (format.inline === 'sub' || format.inline === 'sup')) {
        const hasFontSize = hasStyle(dom, 'fontSize');
        processChildElements(node, elm => hasFontSize(elm) && isEditable$2(elm), applyStyle(dom, 'fontSize', ''));
        const inverseTagDescendants = filter$5(dom.select(format.inline === 'sup' ? 'sub' : 'sup', node), isEditable$2);
        dom.remove(inverseTagDescendants, true);
      }
    };
    const mergeWithChildren = (editor, formatList, vars, node) => {
      each$6(formatList, format => {
        if (isInlineFormat(format)) {
          each$6(editor.dom.select(format.inline, node), child => {
            if (isElementNode(child)) {
              removeFormat$1(editor, format, vars, child, format.exact ? child : null);
            }
          });
        }
        clearChildStyles(editor.dom, format, node);
      });
    };
    const mergeWithParents = (editor, format, name, vars, node) => {
      const parentNode = node.parentNode;
      if (matchNode(editor, parentNode, name, vars)) {
        if (removeFormat$1(editor, format, vars, node)) {
          return;
        }
      }
      if (format.merge_with_parents && parentNode) {
        editor.dom.getParent(parentNode, parent => {
          if (matchNode(editor, parent, name, vars)) {
            removeFormat$1(editor, format, vars, node);
            return true;
          } else {
            return false;
          }
        });
      }
    };

    const each$5 = Tools.each;
    const canFormatBR = (editor, format, node, parentName) => {
      if (canFormatEmptyLines(editor) && isInlineFormat(format) && node.parentNode) {
        const validBRParentElements = getTextRootBlockElements(editor.schema);
        const hasCaretNodeSibling = sibling(SugarElement.fromDom(node), sibling => isCaretNode(sibling.dom));
        return hasNonNullableKey(validBRParentElements, parentName) && isEmpty$2(SugarElement.fromDom(node.parentNode), false) && !hasCaretNodeSibling;
      } else {
        return false;
      }
    };
    const applyStyles = (dom, elm, format, vars) => {
      each$5(format.styles, (value, name) => {
        dom.setStyle(elm, name, replaceVars(value, vars));
      });
      if (format.styles) {
        const styleVal = dom.getAttrib(elm, 'style');
        if (styleVal) {
          dom.setAttrib(elm, 'data-mce-style', styleVal);
        }
      }
    };
    const applyFormat$1 = (ed, name, vars, node) => {
      const formatList = ed.formatter.get(name);
      const format = formatList[0];
      const isCollapsed = !node && ed.selection.isCollapsed();
      const dom = ed.dom;
      const selection = ed.selection;
      const setElementFormat = (elm, fmt = format) => {
        if (isFunction(fmt.onformat)) {
          fmt.onformat(elm, fmt, vars, node);
        }
        applyStyles(dom, elm, fmt, vars);
        each$5(fmt.attributes, (value, name) => {
          dom.setAttrib(elm, name, replaceVars(value, vars));
        });
        each$5(fmt.classes, value => {
          const newValue = replaceVars(value, vars);
          if (!dom.hasClass(elm, newValue)) {
            dom.addClass(elm, newValue);
          }
        });
      };
      const applyNodeStyle = (formatList, node) => {
        let found = false;
        each$5(formatList, format => {
          if (!isSelectorFormat(format)) {
            return false;
          }
          if (dom.getContentEditable(node) === 'false' && !format.ceFalseOverride) {
            return true;
          }
          if (isNonNullable(format.collapsed) && format.collapsed !== isCollapsed) {
            return true;
          }
          if (dom.is(node, format.selector) && !isCaretNode(node)) {
            setElementFormat(node, format);
            found = true;
            return false;
          }
          return true;
        });
        return found;
      };
      const createWrapElement = wrapName => {
        if (isString(wrapName)) {
          const wrapElm = dom.create(wrapName);
          setElementFormat(wrapElm);
          return wrapElm;
        } else {
          return null;
        }
      };
      const applyRngStyle = (dom, rng, nodeSpecific) => {
        const newWrappers = [];
        let contentEditable = true;
        const wrapName = format.inline || format.block;
        const wrapElm = createWrapElement(wrapName);
        const isMatchingWrappingBlock = node => isWrappingBlockFormat(format) && matchNode(ed, node, name, vars);
        const canRenameBlock = (node, parentName, isEditableDescendant) => {
          const isValidBlockFormatForNode = isNonWrappingBlockFormat(format) && isTextBlock$1(ed.schema, node) && isValid(ed, parentName, wrapName);
          return isEditableDescendant && isValidBlockFormatForNode;
        };
        const canWrapNode = (node, parentName, isEditableDescendant, isWrappableNoneditableElm) => {
          const nodeName = node.nodeName.toLowerCase();
          const isValidWrapNode = isValid(ed, wrapName, nodeName) && isValid(ed, parentName, wrapName);
          const isZwsp$1 = !nodeSpecific && isText$a(node) && isZwsp(node.data);
          const isCaret = isCaretNode(node);
          const isCorrectFormatForNode = !isInlineFormat(format) || !dom.isBlock(node);
          return (isEditableDescendant || isWrappableNoneditableElm) && isValidWrapNode && !isZwsp$1 && !isCaret && isCorrectFormatForNode;
        };
        walk$3(dom, rng, nodes => {
          let currentWrapElm;
          const process = node => {
            let hasContentEditableState = false;
            let lastContentEditable = contentEditable;
            let isWrappableNoneditableElm = false;
            const parentNode = node.parentNode;
            const parentName = parentNode.nodeName.toLowerCase();
            const contentEditableValue = dom.getContentEditable(node);
            if (isNonNullable(contentEditableValue)) {
              lastContentEditable = contentEditable;
              contentEditable = contentEditableValue === 'true';
              hasContentEditableState = true;
              isWrappableNoneditableElm = isWrappableNoneditable(ed, node);
            }
            const isEditableDescendant = contentEditable && !hasContentEditableState;
            if (isBr$6(node) && !canFormatBR(ed, format, node, parentName)) {
              currentWrapElm = null;
              if (isBlockFormat(format)) {
                dom.remove(node);
              }
              return;
            }
            if (isMatchingWrappingBlock(node)) {
              currentWrapElm = null;
              return;
            }
            if (canRenameBlock(node, parentName, isEditableDescendant)) {
              const elm = dom.rename(node, wrapName);
              setElementFormat(elm);
              newWrappers.push(elm);
              currentWrapElm = null;
              return;
            }
            if (isSelectorFormat(format)) {
              let found = applyNodeStyle(formatList, node);
              if (!found && isNonNullable(parentNode) && shouldExpandToSelector(format)) {
                found = applyNodeStyle(formatList, parentNode);
              }
              if (!isInlineFormat(format) || found) {
                currentWrapElm = null;
                return;
              }
            }
            if (isNonNullable(wrapElm) && canWrapNode(node, parentName, isEditableDescendant, isWrappableNoneditableElm)) {
              if (!currentWrapElm) {
                currentWrapElm = dom.clone(wrapElm, false);
                parentNode.insertBefore(currentWrapElm, node);
                newWrappers.push(currentWrapElm);
              }
              if (isWrappableNoneditableElm && hasContentEditableState) {
                contentEditable = lastContentEditable;
              }
              currentWrapElm.appendChild(node);
            } else {
              currentWrapElm = null;
              each$e(from(node.childNodes), process);
              if (hasContentEditableState) {
                contentEditable = lastContentEditable;
              }
              currentWrapElm = null;
            }
          };
          each$e(nodes, process);
        });
        if (format.links === true) {
          each$e(newWrappers, node => {
            const process = node => {
              if (node.nodeName === 'A') {
                setElementFormat(node, format);
              }
              each$e(from(node.childNodes), process);
            };
            process(node);
          });
        }
        each$e(newWrappers, node => {
          const getChildCount = node => {
            let count = 0;
            each$e(node.childNodes, node => {
              if (!isEmptyTextNode$1(node) && !isBookmarkNode$1(node)) {
                count++;
              }
            });
            return count;
          };
          const mergeStyles = node => {
            const childElement = find$2(node.childNodes, isElementNode$1).filter(child => dom.getContentEditable(child) !== 'false' && matchName(dom, child, format));
            return childElement.map(child => {
              const clone = dom.clone(child, false);
              setElementFormat(clone);
              dom.replace(clone, node, true);
              dom.remove(child, true);
              return clone;
            }).getOr(node);
          };
          const childCount = getChildCount(node);
          if ((newWrappers.length > 1 || !dom.isBlock(node)) && childCount === 0) {
            dom.remove(node, true);
            return;
          }
          if (isInlineFormat(format) || isBlockFormat(format) && format.wrapper) {
            if (!format.exact && childCount === 1) {
              node = mergeStyles(node);
            }
            mergeWithChildren(ed, formatList, vars, node);
            mergeWithParents(ed, format, name, vars, node);
            mergeBackgroundColorAndFontSize(dom, format, vars, node);
            mergeTextDecorationsAndColor(dom, format, vars, node);
            mergeSubSup(dom, format, vars, node);
            mergeSiblings(ed, format, vars, node);
          }
        });
      };
      const targetNode = isNode(node) ? node : selection.getNode();
      if (dom.getContentEditable(targetNode) === 'false' && !isWrappableNoneditable(ed, targetNode)) {
        node = targetNode;
        applyNodeStyle(formatList, node);
        fireFormatApply(ed, name, node, vars);
        return;
      }
      if (format) {
        if (node) {
          if (isNode(node)) {
            if (!applyNodeStyle(formatList, node)) {
              const rng = dom.createRng();
              rng.setStartBefore(node);
              rng.setEndAfter(node);
              applyRngStyle(dom, expandRng(dom, rng, formatList), true);
            }
          } else {
            applyRngStyle(dom, node, true);
          }
        } else {
          if (!isCollapsed || !isInlineFormat(format) || getCellsFromEditor(ed).length) {
            selection.setRng(normalize(selection.getRng()));
            preserveSelection(ed, () => {
              runOnRanges(ed, (selectionRng, fake) => {
                const expandedRng = fake ? selectionRng : expandRng(dom, selectionRng, formatList);
                applyRngStyle(dom, expandedRng, false);
              });
            }, always);
            ed.nodeChanged();
          } else {
            applyCaretFormat(ed, name, vars);
          }
          getExpandedListItemFormat(ed.formatter, name).each(liFmt => {
            each$e(getFullySelectedListItems(ed.selection), li => applyStyles(dom, li, liFmt, vars));
          });
        }
        postProcess$1(name, ed);
      }
      fireFormatApply(ed, name, node, vars);
    };

    const hasVars = value => has$2(value, 'vars');
    const setup$t = (registeredFormatListeners, editor) => {
      registeredFormatListeners.set({});
      editor.on('NodeChange', e => {
        updateAndFireChangeCallbacks(editor, e.element, registeredFormatListeners.get());
      });
      editor.on('FormatApply FormatRemove', e => {
        const element = Optional.from(e.node).map(nodeOrRange => isNode(nodeOrRange) ? nodeOrRange : nodeOrRange.startContainer).bind(node => isElement$6(node) ? Optional.some(node) : Optional.from(node.parentElement)).getOrThunk(() => fallbackElement(editor));
        updateAndFireChangeCallbacks(editor, element, registeredFormatListeners.get());
      });
    };
    const fallbackElement = editor => editor.selection.getStart();
    const matchingNode = (editor, parents, format, similar, vars) => {
      const isMatchingNode = node => {
        const matchingFormat = editor.formatter.matchNode(node, format, vars !== null && vars !== void 0 ? vars : {}, similar);
        return !isUndefined(matchingFormat);
      };
      const isUnableToMatch = node => {
        if (matchesUnInheritedFormatSelector(editor, node, format)) {
          return true;
        } else {
          if (!similar) {
            return isNonNullable(editor.formatter.matchNode(node, format, vars, true));
          } else {
            return false;
          }
        }
      };
      return findUntil$1(parents, isMatchingNode, isUnableToMatch);
    };
    const getParents = (editor, elm) => {
      const element = elm !== null && elm !== void 0 ? elm : fallbackElement(editor);
      return filter$5(getParents$2(editor.dom, element), node => isElement$6(node) && !isBogus$2(node));
    };
    const updateAndFireChangeCallbacks = (editor, elm, registeredCallbacks) => {
      const parents = getParents(editor, elm);
      each$d(registeredCallbacks, (data, format) => {
        const runIfChanged = spec => {
          const match = matchingNode(editor, parents, format, spec.similar, hasVars(spec) ? spec.vars : undefined);
          const isSet = match.isSome();
          if (spec.state.get() !== isSet) {
            spec.state.set(isSet);
            const node = match.getOr(elm);
            if (hasVars(spec)) {
              spec.callback(isSet, {
                node,
                format,
                parents
              });
            } else {
              each$e(spec.callbacks, callback => callback(isSet, {
                node,
                format,
                parents
              }));
            }
          }
        };
        each$e([
          data.withSimilar,
          data.withoutSimilar
        ], runIfChanged);
        each$e(data.withVars, runIfChanged);
      });
    };
    const addListeners = (editor, registeredFormatListeners, formats, callback, similar, vars) => {
      const formatChangeItems = registeredFormatListeners.get();
      each$e(formats.split(','), format => {
        const group = get$a(formatChangeItems, format).getOrThunk(() => {
          const base = {
            withSimilar: {
              state: Cell(false),
              similar: true,
              callbacks: []
            },
            withoutSimilar: {
              state: Cell(false),
              similar: false,
              callbacks: []
            },
            withVars: []
          };
          formatChangeItems[format] = base;
          return base;
        });
        const getCurrent = () => {
          const parents = getParents(editor);
          return matchingNode(editor, parents, format, similar, vars).isSome();
        };
        if (isUndefined(vars)) {
          const toAppendTo = similar ? group.withSimilar : group.withoutSimilar;
          toAppendTo.callbacks.push(callback);
          if (toAppendTo.callbacks.length === 1) {
            toAppendTo.state.set(getCurrent());
          }
        } else {
          group.withVars.push({
            state: Cell(getCurrent()),
            similar,
            vars,
            callback
          });
        }
      });
      registeredFormatListeners.set(formatChangeItems);
    };
    const removeListeners = (registeredFormatListeners, formats, callback) => {
      const formatChangeItems = registeredFormatListeners.get();
      each$e(formats.split(','), format => get$a(formatChangeItems, format).each(group => {
        formatChangeItems[format] = {
          withSimilar: {
            ...group.withSimilar,
            callbacks: filter$5(group.withSimilar.callbacks, cb => cb !== callback)
          },
          withoutSimilar: {
            ...group.withoutSimilar,
            callbacks: filter$5(group.withoutSimilar.callbacks, cb => cb !== callback)
          },
          withVars: filter$5(group.withVars, item => item.callback !== callback)
        };
      }));
      registeredFormatListeners.set(formatChangeItems);
    };
    const formatChangedInternal = (editor, registeredFormatListeners, formats, callback, similar, vars) => {
      addListeners(editor, registeredFormatListeners, formats, callback, similar, vars);
      return { unbind: () => removeListeners(registeredFormatListeners, formats, callback) };
    };

    const toggle = (editor, name, vars, node) => {
      const fmt = editor.formatter.get(name);
      if (fmt) {
        if (match$2(editor, name, vars, node) && (!('toggle' in fmt[0]) || fmt[0].toggle)) {
          remove$2(editor, name, vars, node);
        } else {
          applyFormat$1(editor, name, vars, node);
        }
      }
    };

    const explode$1 = Tools.explode;
    const create$8 = () => {
      const filters = {};
      const addFilter = (name, callback) => {
        each$e(explode$1(name), name => {
          if (!has$2(filters, name)) {
            filters[name] = {
              name,
              callbacks: []
            };
          }
          filters[name].callbacks.push(callback);
        });
      };
      const getFilters = () => values(filters);
      const removeFilter = (name, callback) => {
        each$e(explode$1(name), name => {
          if (has$2(filters, name)) {
            if (isNonNullable(callback)) {
              const filter = filters[name];
              const newCallbacks = filter$5(filter.callbacks, c => c !== callback);
              if (newCallbacks.length > 0) {
                filter.callbacks = newCallbacks;
              } else {
                delete filters[name];
              }
            } else {
              delete filters[name];
            }
          }
        });
      };
      return {
        addFilter,
        getFilters,
        removeFilter
      };
    };

    const removeAttrs = (node, names) => {
      each$e(names, name => {
        node.attr(name, null);
      });
    };
    const addFontToSpansFilter = (domParser, styles, fontSizes) => {
      domParser.addNodeFilter('font', nodes => {
        each$e(nodes, node => {
          const props = styles.parse(node.attr('style'));
          const color = node.attr('color');
          const face = node.attr('face');
          const size = node.attr('size');
          if (color) {
            props.color = color;
          }
          if (face) {
            props['font-family'] = face;
          }
          if (size) {
            toInt(size).each(num => {
              props['font-size'] = fontSizes[num - 1];
            });
          }
          node.name = 'span';
          node.attr('style', styles.serialize(props));
          removeAttrs(node, [
            'color',
            'face',
            'size'
          ]);
        });
      });
    };
    const addStrikeFilter = (domParser, schema, styles) => {
      domParser.addNodeFilter('strike', nodes => {
        const convertToSTag = schema.type !== 'html4';
        each$e(nodes, node => {
          if (convertToSTag) {
            node.name = 's';
          } else {
            const props = styles.parse(node.attr('style'));
            props['text-decoration'] = 'line-through';
            node.name = 'span';
            node.attr('style', styles.serialize(props));
          }
        });
      });
    };
    const addFilters = (domParser, settings, schema) => {
      var _a;
      const styles = Styles();
      if (settings.convert_fonts_to_spans) {
        addFontToSpansFilter(domParser, styles, Tools.explode((_a = settings.font_size_legacy_values) !== null && _a !== void 0 ? _a : ''));
      }
      addStrikeFilter(domParser, schema, styles);
    };
    const register$5 = (domParser, settings, schema) => {
      if (settings.inline_styles) {
        addFilters(domParser, settings, schema);
      }
    };

    const blobUriToBlob = url => fetch(url).then(res => res.ok ? res.blob() : Promise.reject()).catch(() => Promise.reject({
      message: `Cannot convert ${ url } to Blob. Resource might not exist or is inaccessible.`,
      uriType: 'blob'
    }));
    const extractBase64Data = data => {
      const matches = /([a-z0-9+\/=\s]+)/i.exec(data);
      return matches ? matches[1] : '';
    };
    const parseDataUri = uri => {
      const [type, ...rest] = uri.split(',');
      const data = rest.join(',');
      const matches = /data:([^/]+\/[^;]+)(;.+)?/.exec(type);
      if (matches) {
        const base64Encoded = matches[2] === ';base64';
        const extractedData = base64Encoded ? extractBase64Data(data) : decodeURIComponent(data);
        return Optional.some({
          type: matches[1],
          data: extractedData,
          base64Encoded
        });
      } else {
        return Optional.none();
      }
    };
    const buildBlob = (type, data, base64Encoded = true) => {
      let str = data;
      if (base64Encoded) {
        try {
          str = atob(data);
        } catch (e) {
          return Optional.none();
        }
      }
      const arr = new Uint8Array(str.length);
      for (let i = 0; i < arr.length; i++) {
        arr[i] = str.charCodeAt(i);
      }
      return Optional.some(new Blob([arr], { type }));
    };
    const dataUriToBlob = uri => {
      return new Promise((resolve, reject) => {
        parseDataUri(uri).bind(({type, data, base64Encoded}) => buildBlob(type, data, base64Encoded)).fold(() => reject('Invalid data URI'), resolve);
      });
    };
    const uriToBlob = url => {
      if (startsWith(url, 'blob:')) {
        return blobUriToBlob(url);
      } else if (startsWith(url, 'data:')) {
        return dataUriToBlob(url);
      } else {
        return Promise.reject('Unknown URI format');
      }
    };
    const blobToDataUri = blob => {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => {
          resolve(reader.result);
        };
        reader.onerror = () => {
          var _a;
          reject((_a = reader.error) === null || _a === void 0 ? void 0 : _a.message);
        };
        reader.readAsDataURL(blob);
      });
    };

    let count$1 = 0;
    const uniqueId$1 = prefix => {
      return (prefix || 'blobid') + count$1++;
    };
    const processDataUri = (dataUri, base64Only, generateBlobInfo) => {
      return parseDataUri(dataUri).bind(({data, type, base64Encoded}) => {
        if (base64Only && !base64Encoded) {
          return Optional.none();
        } else {
          const base64 = base64Encoded ? data : btoa(data);
          return generateBlobInfo(base64, type);
        }
      });
    };
    const createBlobInfo$1 = (blobCache, blob, base64) => {
      const blobInfo = blobCache.create(uniqueId$1(), blob, base64);
      blobCache.add(blobInfo);
      return blobInfo;
    };
    const dataUriToBlobInfo = (blobCache, dataUri, base64Only = false) => {
      return processDataUri(dataUri, base64Only, (base64, type) => Optional.from(blobCache.getByData(base64, type)).orThunk(() => buildBlob(type, base64).map(blob => createBlobInfo$1(blobCache, blob, base64))));
    };
    const imageToBlobInfo = (blobCache, imageSrc) => {
      const invalidDataUri = () => Promise.reject('Invalid data URI');
      if (startsWith(imageSrc, 'blob:')) {
        const blobInfo = blobCache.getByUri(imageSrc);
        if (isNonNullable(blobInfo)) {
          return Promise.resolve(blobInfo);
        } else {
          return uriToBlob(imageSrc).then(blob => {
            return blobToDataUri(blob).then(dataUri => {
              return processDataUri(dataUri, false, base64 => {
                return Optional.some(createBlobInfo$1(blobCache, blob, base64));
              }).getOrThunk(invalidDataUri);
            });
          });
        }
      } else if (startsWith(imageSrc, 'data:')) {
        return dataUriToBlobInfo(blobCache, imageSrc).fold(invalidDataUri, blobInfo => Promise.resolve(blobInfo));
      } else {
        return Promise.reject('Unknown image data format');
      }
    };

    const isBogusImage = img => isNonNullable(img.attr('data-mce-bogus'));
    const isInternalImageSource = img => img.attr('src') === Env.transparentSrc || isNonNullable(img.attr('data-mce-placeholder'));
    const registerBase64ImageFilter = (parser, settings) => {
      const {blob_cache: blobCache} = settings;
      if (blobCache) {
        const processImage = img => {
          const inputSrc = img.attr('src');
          if (isInternalImageSource(img) || isBogusImage(img) || isNullable(inputSrc)) {
            return;
          }
          dataUriToBlobInfo(blobCache, inputSrc, true).each(blobInfo => {
            img.attr('src', blobInfo.blobUri());
          });
        };
        parser.addAttributeFilter('src', nodes => each$e(nodes, processImage));
      }
    };
    const register$4 = (parser, settings) => {
      const schema = parser.schema;
      if (settings.remove_trailing_brs) {
        parser.addNodeFilter('br', (nodes, _, args) => {
          const blockElements = Tools.extend({}, schema.getBlockElements());
          const nonEmptyElements = schema.getNonEmptyElements();
          const whitespaceElements = schema.getWhitespaceElements();
          blockElements.body = 1;
          const isBlock = node => node.name in blockElements && isTransparentAstInline(schema, node);
          for (let i = 0, l = nodes.length; i < l; i++) {
            let node = nodes[i];
            let parent = node.parent;
            if (parent && blockElements[parent.name] && node === parent.lastChild) {
              let prev = node.prev;
              while (prev) {
                const prevName = prev.name;
                if (prevName !== 'span' || prev.attr('data-mce-type') !== 'bookmark') {
                  if (prevName === 'br') {
                    node = null;
                  }
                  break;
                }
                prev = prev.prev;
              }
              if (node) {
                node.remove();
                if (isEmpty(schema, nonEmptyElements, whitespaceElements, parent)) {
                  const elementRule = schema.getElementRule(parent.name);
                  if (elementRule) {
                    if (elementRule.removeEmpty) {
                      parent.remove();
                    } else if (elementRule.paddEmpty) {
                      paddEmptyNode(args, isBlock, parent);
                    }
                  }
                }
              }
            } else {
              let lastParent = node;
              while (parent && parent.firstChild === lastParent && parent.lastChild === lastParent) {
                lastParent = parent;
                if (blockElements[parent.name]) {
                  break;
                }
                parent = parent.parent;
              }
              if (lastParent === parent) {
                const textNode = new AstNode('#text', 3);
                textNode.value = nbsp;
                node.replace(textNode);
              }
            }
          }
        });
      }
      parser.addAttributeFilter('href', nodes => {
        let i = nodes.length;
        const appendRel = rel => {
          const parts = rel.split(' ').filter(p => p.length > 0);
          return parts.concat(['noopener']).sort().join(' ');
        };
        const addNoOpener = rel => {
          const newRel = rel ? Tools.trim(rel) : '';
          if (!/\b(noopener)\b/g.test(newRel)) {
            return appendRel(newRel);
          } else {
            return newRel;
          }
        };
        if (!settings.allow_unsafe_link_target) {
          while (i--) {
            const node = nodes[i];
            if (node.name === 'a' && node.attr('target') === '_blank') {
              node.attr('rel', addNoOpener(node.attr('rel')));
            }
          }
        }
      });
      if (!settings.allow_html_in_named_anchor) {
        parser.addAttributeFilter('id,name', nodes => {
          let i = nodes.length, sibling, prevSibling, parent, node;
          while (i--) {
            node = nodes[i];
            if (node.name === 'a' && node.firstChild && !node.attr('href')) {
              parent = node.parent;
              sibling = node.lastChild;
              while (sibling && parent) {
                prevSibling = sibling.prev;
                parent.insert(sibling, node);
                sibling = prevSibling;
              }
            }
          }
        });
      }
      if (settings.fix_list_elements) {
        parser.addNodeFilter('ul,ol', nodes => {
          let i = nodes.length, node, parentNode;
          while (i--) {
            node = nodes[i];
            parentNode = node.parent;
            if (parentNode && (parentNode.name === 'ul' || parentNode.name === 'ol')) {
              if (node.prev && node.prev.name === 'li') {
                node.prev.append(node);
              } else {
                const li = new AstNode('li', 1);
                li.attr('style', 'list-style-type: none');
                node.wrap(li);
              }
            }
          }
        });
      }
      const validClasses = schema.getValidClasses();
      if (settings.validate && validClasses) {
        parser.addAttributeFilter('class', nodes => {
          var _a;
          let i = nodes.length;
          while (i--) {
            const node = nodes[i];
            const clazz = (_a = node.attr('class')) !== null && _a !== void 0 ? _a : '';
            const classList = Tools.explode(clazz, ' ');
            let classValue = '';
            for (let ci = 0; ci < classList.length; ci++) {
              const className = classList[ci];
              let valid = false;
              let validClassesMap = validClasses['*'];
              if (validClassesMap && validClassesMap[className]) {
                valid = true;
              }
              validClassesMap = validClasses[node.name];
              if (!valid && validClassesMap && validClassesMap[className]) {
                valid = true;
              }
              if (valid) {
                if (classValue) {
                  classValue += ' ';
                }
                classValue += className;
              }
            }
            if (!classValue.length) {
              classValue = null;
            }
            node.attr('class', classValue);
          }
        });
      }
      registerBase64ImageFilter(parser, settings);
    };

    function _typeof(obj) {
      '@babel/helpers - typeof';
      return _typeof = 'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator ? function (obj) {
        return typeof obj;
      } : function (obj) {
        return obj && 'function' == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
      }, _typeof(obj);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === 'undefined' || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === 'function')
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct(Parent, args, Class) {
          var a = [null];
          a.push.apply(a, args);
          var Constructor = Function.bind.apply(Parent, a);
          var instance = new Constructor();
          if (Class)
            _setPrototypeOf(instance, Class.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== 'undefined' && iter[Symbol.iterator] != null || iter['@@iterator'] != null)
        return Array.from(iter);
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === 'string')
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === 'Object' && o.constructor)
        n = o.constructor.name;
      if (n === 'Map' || n === 'Set')
        return Array.from(o);
      if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _nonIterableSpread() {
      throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.');
    }
    var hasOwnProperty = Object.hasOwnProperty, setPrototypeOf = Object.setPrototypeOf, isFrozen = Object.isFrozen, getPrototypeOf = Object.getPrototypeOf, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var freeze = Object.freeze, seal = Object.seal, create$7 = Object.create;
    var _ref = typeof Reflect !== 'undefined' && Reflect, apply = _ref.apply, construct = _ref.construct;
    if (!apply) {
      apply = function apply(fun, thisValue, args) {
        return fun.apply(thisValue, args);
      };
    }
    if (!freeze) {
      freeze = function freeze(x) {
        return x;
      };
    }
    if (!seal) {
      seal = function seal(x) {
        return x;
      };
    }
    if (!construct) {
      construct = function construct(Func, args) {
        return _construct(Func, _toConsumableArray(args));
      };
    }
    var arrayForEach = unapply(Array.prototype.forEach);
    var arrayPop = unapply(Array.prototype.pop);
    var arrayPush = unapply(Array.prototype.push);
    var stringToLowerCase = unapply(String.prototype.toLowerCase);
    var stringMatch = unapply(String.prototype.match);
    var stringReplace = unapply(String.prototype.replace);
    var stringIndexOf = unapply(String.prototype.indexOf);
    var stringTrim = unapply(String.prototype.trim);
    var regExpTest = unapply(RegExp.prototype.test);
    var typeErrorCreate = unconstruct(TypeError);
    function unapply(func) {
      return function (thisArg) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        return apply(func, thisArg, args);
      };
    }
    function unconstruct(func) {
      return function () {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        return construct(func, args);
      };
    }
    function addToSet(set, array) {
      if (setPrototypeOf) {
        setPrototypeOf(set, null);
      }
      var l = array.length;
      while (l--) {
        var element = array[l];
        if (typeof element === 'string') {
          var lcElement = stringToLowerCase(element);
          if (lcElement !== element) {
            if (!isFrozen(array)) {
              array[l] = lcElement;
            }
            element = lcElement;
          }
        }
        set[element] = true;
      }
      return set;
    }
    function clone(object) {
      var newObject = create$7(null);
      var property;
      for (property in object) {
        if (apply(hasOwnProperty, object, [property])) {
          newObject[property] = object[property];
        }
      }
      return newObject;
    }
    function lookupGetter(object, prop) {
      while (object !== null) {
        var desc = getOwnPropertyDescriptor(object, prop);
        if (desc) {
          if (desc.get) {
            return unapply(desc.get);
          }
          if (typeof desc.value === 'function') {
            return unapply(desc.value);
          }
        }
        object = getPrototypeOf(object);
      }
      function fallbackValue(element) {
        console.warn('fallback value for', element);
        return null;
      }
      return fallbackValue;
    }
    var html$1 = freeze([
      'a',
      'abbr',
      'acronym',
      'address',
      'area',
      'article',
      'aside',
      'audio',
      'b',
      'bdi',
      'bdo',
      'big',
      'blink',
      'blockquote',
      'body',
      'br',
      'button',
      'canvas',
      'caption',
      'center',
      'cite',
      'code',
      'col',
      'colgroup',
      'content',
      'data',
      'datalist',
      'dd',
      'decorator',
      'del',
      'details',
      'dfn',
      'dialog',
      'dir',
      'div',
      'dl',
      'dt',
      'element',
      'em',
      'fieldset',
      'figcaption',
      'figure',
      'font',
      'footer',
      'form',
      'h1',
      'h2',
      'h3',
      'h4',
      'h5',
      'h6',
      'head',
      'header',
      'hgroup',
      'hr',
      'html',
      'i',
      'img',
      'input',
      'ins',
      'kbd',
      'label',
      'legend',
      'li',
      'main',
      'map',
      'mark',
      'marquee',
      'menu',
      'menuitem',
      'meter',
      'nav',
      'nobr',
      'ol',
      'optgroup',
      'option',
      'output',
      'p',
      'picture',
      'pre',
      'progress',
      'q',
      'rp',
      'rt',
      'ruby',
      's',
      'samp',
      'section',
      'select',
      'shadow',
      'small',
      'source',
      'spacer',
      'span',
      'strike',
      'strong',
      'style',
      'sub',
      'summary',
      'sup',
      'table',
      'tbody',
      'td',
      'template',
      'textarea',
      'tfoot',
      'th',
      'thead',
      'time',
      'tr',
      'track',
      'tt',
      'u',
      'ul',
      'var',
      'video',
      'wbr'
    ]);
    var svg$1 = freeze([
      'svg',
      'a',
      'altglyph',
      'altglyphdef',
      'altglyphitem',
      'animatecolor',
      'animatemotion',
      'animatetransform',
      'circle',
      'clippath',
      'defs',
      'desc',
      'ellipse',
      'filter',
      'font',
      'g',
      'glyph',
      'glyphref',
      'hkern',
      'image',
      'line',
      'lineargradient',
      'marker',
      'mask',
      'metadata',
      'mpath',
      'path',
      'pattern',
      'polygon',
      'polyline',
      'radialgradient',
      'rect',
      'stop',
      'style',
      'switch',
      'symbol',
      'text',
      'textpath',
      'title',
      'tref',
      'tspan',
      'view',
      'vkern'
    ]);
    var svgFilters = freeze([
      'feBlend',
      'feColorMatrix',
      'feComponentTransfer',
      'feComposite',
      'feConvolveMatrix',
      'feDiffuseLighting',
      'feDisplacementMap',
      'feDistantLight',
      'feFlood',
      'feFuncA',
      'feFuncB',
      'feFuncG',
      'feFuncR',
      'feGaussianBlur',
      'feImage',
      'feMerge',
      'feMergeNode',
      'feMorphology',
      'feOffset',
      'fePointLight',
      'feSpecularLighting',
      'feSpotLight',
      'feTile',
      'feTurbulence'
    ]);
    var svgDisallowed = freeze([
      'animate',
      'color-profile',
      'cursor',
      'discard',
      'fedropshadow',
      'font-face',
      'font-face-format',
      'font-face-name',
      'font-face-src',
      'font-face-uri',
      'foreignobject',
      'hatch',
      'hatchpath',
      'mesh',
      'meshgradient',
      'meshpatch',
      'meshrow',
      'missing-glyph',
      'script',
      'set',
      'solidcolor',
      'unknown',
      'use'
    ]);
    var mathMl$1 = freeze([
      'math',
      'menclose',
      'merror',
      'mfenced',
      'mfrac',
      'mglyph',
      'mi',
      'mlabeledtr',
      'mmultiscripts',
      'mn',
      'mo',
      'mover',
      'mpadded',
      'mphantom',
      'mroot',
      'mrow',
      'ms',
      'mspace',
      'msqrt',
      'mstyle',
      'msub',
      'msup',
      'msubsup',
      'mtable',
      'mtd',
      'mtext',
      'mtr',
      'munder',
      'munderover'
    ]);
    var mathMlDisallowed = freeze([
      'maction',
      'maligngroup',
      'malignmark',
      'mlongdiv',
      'mscarries',
      'mscarry',
      'msgroup',
      'mstack',
      'msline',
      'msrow',
      'semantics',
      'annotation',
      'annotation-xml',
      'mprescripts',
      'none'
    ]);
    var text = freeze(['#text']);
    var html = freeze([
      'accept',
      'action',
      'align',
      'alt',
      'autocapitalize',
      'autocomplete',
      'autopictureinpicture',
      'autoplay',
      'background',
      'bgcolor',
      'border',
      'capture',
      'cellpadding',
      'cellspacing',
      'checked',
      'cite',
      'class',
      'clear',
      'color',
      'cols',
      'colspan',
      'controls',
      'controlslist',
      'coords',
      'crossorigin',
      'datetime',
      'decoding',
      'default',
      'dir',
      'disabled',
      'disablepictureinpicture',
      'disableremoteplayback',
      'download',
      'draggable',
      'enctype',
      'enterkeyhint',
      'face',
      'for',
      'headers',
      'height',
      'hidden',
      'high',
      'href',
      'hreflang',
      'id',
      'inputmode',
      'integrity',
      'ismap',
      'kind',
      'label',
      'lang',
      'list',
      'loading',
      'loop',
      'low',
      'max',
      'maxlength',
      'media',
      'method',
      'min',
      'minlength',
      'multiple',
      'muted',
      'name',
      'nonce',
      'noshade',
      'novalidate',
      'nowrap',
      'open',
      'optimum',
      'pattern',
      'placeholder',
      'playsinline',
      'poster',
      'preload',
      'pubdate',
      'radiogroup',
      'readonly',
      'rel',
      'required',
      'rev',
      'reversed',
      'role',
      'rows',
      'rowspan',
      'spellcheck',
      'scope',
      'selected',
      'shape',
      'size',
      'sizes',
      'span',
      'srclang',
      'start',
      'src',
      'srcset',
      'step',
      'style',
      'summary',
      'tabindex',
      'title',
      'translate',
      'type',
      'usemap',
      'valign',
      'value',
      'width',
      'xmlns',
      'slot'
    ]);
    var svg = freeze([
      'accent-height',
      'accumulate',
      'additive',
      'alignment-baseline',
      'ascent',
      'attributename',
      'attributetype',
      'azimuth',
      'basefrequency',
      'baseline-shift',
      'begin',
      'bias',
      'by',
      'class',
      'clip',
      'clippathunits',
      'clip-path',
      'clip-rule',
      'color',
      'color-interpolation',
      'color-interpolation-filters',
      'color-profile',
      'color-rendering',
      'cx',
      'cy',
      'd',
      'dx',
      'dy',
      'diffuseconstant',
      'direction',
      'display',
      'divisor',
      'dur',
      'edgemode',
      'elevation',
      'end',
      'fill',
      'fill-opacity',
      'fill-rule',
      'filter',
      'filterunits',
      'flood-color',
      'flood-opacity',
      'font-family',
      'font-size',
      'font-size-adjust',
      'font-stretch',
      'font-style',
      'font-variant',
      'font-weight',
      'fx',
      'fy',
      'g1',
      'g2',
      'glyph-name',
      'glyphref',
      'gradientunits',
      'gradienttransform',
      'height',
      'href',
      'id',
      'image-rendering',
      'in',
      'in2',
      'k',
      'k1',
      'k2',
      'k3',
      'k4',
      'kerning',
      'keypoints',
      'keysplines',
      'keytimes',
      'lang',
      'lengthadjust',
      'letter-spacing',
      'kernelmatrix',
      'kernelunitlength',
      'lighting-color',
      'local',
      'marker-end',
      'marker-mid',
      'marker-start',
      'markerheight',
      'markerunits',
      'markerwidth',
      'maskcontentunits',
      'maskunits',
      'max',
      'mask',
      'media',
      'method',
      'mode',
      'min',
      'name',
      'numoctaves',
      'offset',
      'operator',
      'opacity',
      'order',
      'orient',
      'orientation',
      'origin',
      'overflow',
      'paint-order',
      'path',
      'pathlength',
      'patterncontentunits',
      'patterntransform',
      'patternunits',
      'points',
      'preservealpha',
      'preserveaspectratio',
      'primitiveunits',
      'r',
      'rx',
      'ry',
      'radius',
      'refx',
      'refy',
      'repeatcount',
      'repeatdur',
      'restart',
      'result',
      'rotate',
      'scale',
      'seed',
      'shape-rendering',
      'specularconstant',
      'specularexponent',
      'spreadmethod',
      'startoffset',
      'stddeviation',
      'stitchtiles',
      'stop-color',
      'stop-opacity',
      'stroke-dasharray',
      'stroke-dashoffset',
      'stroke-linecap',
      'stroke-linejoin',
      'stroke-miterlimit',
      'stroke-opacity',
      'stroke',
      'stroke-width',
      'style',
      'surfacescale',
      'systemlanguage',
      'tabindex',
      'targetx',
      'targety',
      'transform',
      'transform-origin',
      'text-anchor',
      'text-decoration',
      'text-rendering',
      'textlength',
      'type',
      'u1',
      'u2',
      'unicode',
      'values',
      'viewbox',
      'visibility',
      'version',
      'vert-adv-y',
      'vert-origin-x',
      'vert-origin-y',
      'width',
      'word-spacing',
      'wrap',
      'writing-mode',
      'xchannelselector',
      'ychannelselector',
      'x',
      'x1',
      'x2',
      'xmlns',
      'y',
      'y1',
      'y2',
      'z',
      'zoomandpan'
    ]);
    var mathMl = freeze([
      'accent',
      'accentunder',
      'align',
      'bevelled',
      'close',
      'columnsalign',
      'columnlines',
      'columnspan',
      'denomalign',
      'depth',
      'dir',
      'display',
      'displaystyle',
      'encoding',
      'fence',
      'frame',
      'height',
      'href',
      'id',
      'largeop',
      'length',
      'linethickness',
      'lspace',
      'lquote',
      'mathbackground',
      'mathcolor',
      'mathsize',
      'mathvariant',
      'maxsize',
      'minsize',
      'movablelimits',
      'notation',
      'numalign',
      'open',
      'rowalign',
      'rowlines',
      'rowspacing',
      'rowspan',
      'rspace',
      'rquote',
      'scriptlevel',
      'scriptminsize',
      'scriptsizemultiplier',
      'selection',
      'separator',
      'separators',
      'stretchy',
      'subscriptshift',
      'supscriptshift',
      'symmetric',
      'voffset',
      'width',
      'xmlns'
    ]);
    var xml = freeze([
      'xlink:href',
      'xml:id',
      'xlink:title',
      'xml:space',
      'xmlns:xlink'
    ]);
    var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
    var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
    var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/);
    var ARIA_ATTR = seal(/^aria-[\-\w]+$/);
    var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i);
    var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
    var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g);
    var DOCTYPE_NAME = seal(/^html$/i);
    var getGlobal = function getGlobal() {
      return typeof window === 'undefined' ? null : window;
    };
    var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {
      if (_typeof(trustedTypes) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
        return null;
      }
      var suffix = null;
      var ATTR_NAME = 'data-tt-policy-suffix';
      if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {
        suffix = document.currentScript.getAttribute(ATTR_NAME);
      }
      var policyName = 'dompurify' + (suffix ? '#' + suffix : '');
      try {
        return trustedTypes.createPolicy(policyName, {
          createHTML: function createHTML(html) {
            return html;
          }
        });
      } catch (_) {
        console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
        return null;
      }
    };
    function createDOMPurify() {
      var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();
      var DOMPurify = function DOMPurify(root) {
        return createDOMPurify(root);
      };
      DOMPurify.version = '2.3.8';
      DOMPurify.removed = [];
      if (!window || !window.document || window.document.nodeType !== 9) {
        DOMPurify.isSupported = false;
        return DOMPurify;
      }
      var originalDocument = window.document;
      var document = window.document;
      var DocumentFragment = window.DocumentFragment, HTMLTemplateElement = window.HTMLTemplateElement, Node = window.Node, Element = window.Element, NodeFilter = window.NodeFilter, _window$NamedNodeMap = window.NamedNodeMap, NamedNodeMap = _window$NamedNodeMap === void 0 ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap, HTMLFormElement = window.HTMLFormElement, DOMParser = window.DOMParser, trustedTypes = window.trustedTypes;
      var ElementPrototype = Element.prototype;
      var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');
      var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');
      var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');
      var getParentNode = lookupGetter(ElementPrototype, 'parentNode');
      if (typeof HTMLTemplateElement === 'function') {
        var template = document.createElement('template');
        if (template.content && template.content.ownerDocument) {
          document = template.content.ownerDocument;
        }
      }
      var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
      var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML('') : '';
      var _document = document, implementation = _document.implementation, createNodeIterator = _document.createNodeIterator, createDocumentFragment = _document.createDocumentFragment, getElementsByTagName = _document.getElementsByTagName;
      var importNode = originalDocument.importNode;
      var documentMode = {};
      try {
        documentMode = clone(document).documentMode ? document.documentMode : {};
      } catch (_) {
      }
      var hooks = {};
      DOMPurify.isSupported = typeof getParentNode === 'function' && implementation && typeof implementation.createHTMLDocument !== 'undefined' && documentMode !== 9;
      var MUSTACHE_EXPR$1 = MUSTACHE_EXPR, ERB_EXPR$1 = ERB_EXPR, DATA_ATTR$1 = DATA_ATTR, ARIA_ATTR$1 = ARIA_ATTR, IS_SCRIPT_OR_DATA$1 = IS_SCRIPT_OR_DATA, ATTR_WHITESPACE$1 = ATTR_WHITESPACE;
      var IS_ALLOWED_URI$1 = IS_ALLOWED_URI;
      var ALLOWED_TAGS = null;
      var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html$1), _toConsumableArray(svg$1), _toConsumableArray(svgFilters), _toConsumableArray(mathMl$1), _toConsumableArray(text)));
      var ALLOWED_ATTR = null;
      var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html), _toConsumableArray(svg), _toConsumableArray(mathMl), _toConsumableArray(xml)));
      var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
        tagNameCheck: {
          writable: true,
          configurable: false,
          enumerable: true,
          value: null
        },
        attributeNameCheck: {
          writable: true,
          configurable: false,
          enumerable: true,
          value: null
        },
        allowCustomizedBuiltInElements: {
          writable: true,
          configurable: false,
          enumerable: true,
          value: false
        }
      }));
      var FORBID_TAGS = null;
      var FORBID_ATTR = null;
      var ALLOW_ARIA_ATTR = true;
      var ALLOW_DATA_ATTR = true;
      var ALLOW_UNKNOWN_PROTOCOLS = false;
      var SAFE_FOR_TEMPLATES = false;
      var WHOLE_DOCUMENT = false;
      var SET_CONFIG = false;
      var FORCE_BODY = false;
      var RETURN_DOM = false;
      var RETURN_DOM_FRAGMENT = false;
      var RETURN_TRUSTED_TYPE = false;
      var SANITIZE_DOM = true;
      var KEEP_CONTENT = true;
      var IN_PLACE = false;
      var USE_PROFILES = {};
      var FORBID_CONTENTS = null;
      var DEFAULT_FORBID_CONTENTS = addToSet({}, [
        'annotation-xml',
        'audio',
        'colgroup',
        'desc',
        'foreignobject',
        'head',
        'iframe',
        'math',
        'mi',
        'mn',
        'mo',
        'ms',
        'mtext',
        'noembed',
        'noframes',
        'noscript',
        'plaintext',
        'script',
        'style',
        'svg',
        'template',
        'thead',
        'title',
        'video',
        'xmp'
      ]);
      var DATA_URI_TAGS = null;
      var DEFAULT_DATA_URI_TAGS = addToSet({}, [
        'audio',
        'video',
        'img',
        'source',
        'image',
        'track'
      ]);
      var URI_SAFE_ATTRIBUTES = null;
      var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, [
        'alt',
        'class',
        'for',
        'id',
        'label',
        'name',
        'pattern',
        'placeholder',
        'role',
        'summary',
        'title',
        'value',
        'style',
        'xmlns'
      ]);
      var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
      var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
      var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
      var NAMESPACE = HTML_NAMESPACE;
      var IS_EMPTY_INPUT = false;
      var PARSER_MEDIA_TYPE;
      var SUPPORTED_PARSER_MEDIA_TYPES = [
        'application/xhtml+xml',
        'text/html'
      ];
      var DEFAULT_PARSER_MEDIA_TYPE = 'text/html';
      var transformCaseFunc;
      var CONFIG = null;
      var formElement = document.createElement('form');
      var isRegexOrFunction = function isRegexOrFunction(testValue) {
        return testValue instanceof RegExp || testValue instanceof Function;
      };
      var _parseConfig = function _parseConfig(cfg) {
        if (CONFIG && CONFIG === cfg) {
          return;
        }
        if (!cfg || _typeof(cfg) !== 'object') {
          cfg = {};
        }
        cfg = clone(cfg);
        ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
        ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
        URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;
        DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;
        FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS) : DEFAULT_FORBID_CONTENTS;
        FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};
        FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};
        USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;
        ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
        ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
        ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
        SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
        WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
        RETURN_DOM = cfg.RETURN_DOM || false;
        RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
        RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
        FORCE_BODY = cfg.FORCE_BODY || false;
        SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
        KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
        IN_PLACE = cfg.IN_PLACE || false;
        IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$1;
        NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
          CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
        }
        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
          CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
        }
        if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {
          CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
        }
        PARSER_MEDIA_TYPE = SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;
        transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? function (x) {
          return x;
        } : stringToLowerCase;
        if (SAFE_FOR_TEMPLATES) {
          ALLOW_DATA_ATTR = false;
        }
        if (RETURN_DOM_FRAGMENT) {
          RETURN_DOM = true;
        }
        if (USE_PROFILES) {
          ALLOWED_TAGS = addToSet({}, _toConsumableArray(text));
          ALLOWED_ATTR = [];
          if (USE_PROFILES.html === true) {
            addToSet(ALLOWED_TAGS, html$1);
            addToSet(ALLOWED_ATTR, html);
          }
          if (USE_PROFILES.svg === true) {
            addToSet(ALLOWED_TAGS, svg$1);
            addToSet(ALLOWED_ATTR, svg);
            addToSet(ALLOWED_ATTR, xml);
          }
          if (USE_PROFILES.svgFilters === true) {
            addToSet(ALLOWED_TAGS, svgFilters);
            addToSet(ALLOWED_ATTR, svg);
            addToSet(ALLOWED_ATTR, xml);
          }
          if (USE_PROFILES.mathMl === true) {
            addToSet(ALLOWED_TAGS, mathMl$1);
            addToSet(ALLOWED_ATTR, mathMl);
            addToSet(ALLOWED_ATTR, xml);
          }
        }
        if (cfg.ADD_TAGS) {
          if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
            ALLOWED_TAGS = clone(ALLOWED_TAGS);
          }
          addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);
        }
        if (cfg.ADD_ATTR) {
          if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
            ALLOWED_ATTR = clone(ALLOWED_ATTR);
          }
          addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);
        }
        if (cfg.ADD_URI_SAFE_ATTR) {
          addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);
        }
        if (cfg.FORBID_CONTENTS) {
          if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
            FORBID_CONTENTS = clone(FORBID_CONTENTS);
          }
          addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS);
        }
        if (KEEP_CONTENT) {
          ALLOWED_TAGS['#text'] = true;
        }
        if (WHOLE_DOCUMENT) {
          addToSet(ALLOWED_TAGS, [
            'html',
            'head',
            'body'
          ]);
        }
        if (ALLOWED_TAGS.table) {
          addToSet(ALLOWED_TAGS, ['tbody']);
          delete FORBID_TAGS.tbody;
        }
        if (freeze) {
          freeze(cfg);
        }
        CONFIG = cfg;
      };
      var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, [
        'mi',
        'mo',
        'mn',
        'ms',
        'mtext'
      ]);
      var HTML_INTEGRATION_POINTS = addToSet({}, [
        'foreignobject',
        'desc',
        'title',
        'annotation-xml'
      ]);
      var COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, [
        'title',
        'style',
        'font',
        'a',
        'script'
      ]);
      var ALL_SVG_TAGS = addToSet({}, svg$1);
      addToSet(ALL_SVG_TAGS, svgFilters);
      addToSet(ALL_SVG_TAGS, svgDisallowed);
      var ALL_MATHML_TAGS = addToSet({}, mathMl$1);
      addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
      var _checkValidNamespace = function _checkValidNamespace(element) {
        var parent = getParentNode(element);
        if (!parent || !parent.tagName) {
          parent = {
            namespaceURI: HTML_NAMESPACE,
            tagName: 'template'
          };
        }
        var tagName = stringToLowerCase(element.tagName);
        var parentTagName = stringToLowerCase(parent.tagName);
        if (element.namespaceURI === SVG_NAMESPACE) {
          if (parent.namespaceURI === HTML_NAMESPACE) {
            return tagName === 'svg';
          }
          if (parent.namespaceURI === MATHML_NAMESPACE) {
            return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
          }
          return Boolean(ALL_SVG_TAGS[tagName]);
        }
        if (element.namespaceURI === MATHML_NAMESPACE) {
          if (parent.namespaceURI === HTML_NAMESPACE) {
            return tagName === 'math';
          }
          if (parent.namespaceURI === SVG_NAMESPACE) {
            return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];
          }
          return Boolean(ALL_MATHML_TAGS[tagName]);
        }
        if (element.namespaceURI === HTML_NAMESPACE) {
          if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
            return false;
          }
          if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
            return false;
          }
          return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
        }
        return false;
      };
      var _forceRemove = function _forceRemove(node) {
        arrayPush(DOMPurify.removed, { element: node });
        try {
          node.parentNode.removeChild(node);
        } catch (_) {
          try {
            node.outerHTML = emptyHTML;
          } catch (_) {
            node.remove();
          }
        }
      };
      var _removeAttribute = function _removeAttribute(name, node) {
        try {
          arrayPush(DOMPurify.removed, {
            attribute: node.getAttributeNode(name),
            from: node
          });
        } catch (_) {
          arrayPush(DOMPurify.removed, {
            attribute: null,
            from: node
          });
        }
        node.removeAttribute(name);
        if (name === 'is' && !ALLOWED_ATTR[name]) {
          if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
            try {
              _forceRemove(node);
            } catch (_) {
            }
          } else {
            try {
              node.setAttribute(name, '');
            } catch (_) {
            }
          }
        }
      };
      var _initDocument = function _initDocument(dirty) {
        var doc;
        var leadingWhitespace;
        if (FORCE_BODY) {
          dirty = '<remove></remove>' + dirty;
        } else {
          var matches = stringMatch(dirty, /^[\r\n\t ]+/);
          leadingWhitespace = matches && matches[0];
        }
        if (PARSER_MEDIA_TYPE === 'application/xhtml+xml') {
          dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + '</body></html>';
        }
        var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
        if (NAMESPACE === HTML_NAMESPACE) {
          try {
            doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
          } catch (_) {
          }
        }
        if (!doc || !doc.documentElement) {
          doc = implementation.createDocument(NAMESPACE, 'template', null);
          try {
            doc.documentElement.innerHTML = IS_EMPTY_INPUT ? '' : dirtyPayload;
          } catch (_) {
          }
        }
        var body = doc.body || doc.documentElement;
        if (dirty && leadingWhitespace) {
          body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
        }
        if (NAMESPACE === HTML_NAMESPACE) {
          return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
        }
        return WHOLE_DOCUMENT ? doc.documentElement : body;
      };
      var _createIterator = function _createIterator(root) {
        return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);
      };
      var _isClobbered = function _isClobbered(elm) {
        return elm instanceof HTMLFormElement && (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function');
      };
      var _isNode = function _isNode(object) {
        return _typeof(Node) === 'object' ? object instanceof Node : object && _typeof(object) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';
      };
      var _executeHook = function _executeHook(entryPoint, currentNode, data) {
        if (!hooks[entryPoint]) {
          return;
        }
        arrayForEach(hooks[entryPoint], function (hook) {
          hook.call(DOMPurify, currentNode, data, CONFIG);
        });
      };
      var _sanitizeElements = function _sanitizeElements(currentNode) {
        var content;
        _executeHook('beforeSanitizeElements', currentNode, null);
        if (_isClobbered(currentNode)) {
          _forceRemove(currentNode);
          return true;
        }
        if (regExpTest(/[\u0080-\uFFFF]/, currentNode.nodeName)) {
          _forceRemove(currentNode);
          return true;
        }
        var tagName = transformCaseFunc(currentNode.nodeName);
        _executeHook('uponSanitizeElement', currentNode, {
          tagName: tagName,
          allowedTags: ALLOWED_TAGS
        });
        if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
          _forceRemove(currentNode);
          return true;
        }
        if (tagName === 'select' && regExpTest(/<template/i, currentNode.innerHTML)) {
          _forceRemove(currentNode);
          return true;
        }
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName))
              return false;
            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))
              return false;
          }
          if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
            var parentNode = getParentNode(currentNode) || currentNode.parentNode;
            var childNodes = getChildNodes(currentNode) || currentNode.childNodes;
            if (childNodes && parentNode) {
              var childCount = childNodes.length;
              for (var i = childCount - 1; i >= 0; --i) {
                parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
              }
            }
          }
          _forceRemove(currentNode);
          return true;
        }
        if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
          _forceRemove(currentNode);
          return true;
        }
        if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
          _forceRemove(currentNode);
          return true;
        }
        if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
          content = currentNode.textContent;
          content = stringReplace(content, MUSTACHE_EXPR$1, ' ');
          content = stringReplace(content, ERB_EXPR$1, ' ');
          if (currentNode.textContent !== content) {
            arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });
            currentNode.textContent = content;
          }
        }
        _executeHook('afterSanitizeElements', currentNode, null);
        return false;
      };
      var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
        if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
          return false;
        }
        if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$1, lcName));
        else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$1, lcName));
        else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
          if (_basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value)));
          else {
            return false;
          }
        } else if (URI_SAFE_ATTRIBUTES[lcName]);
        else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE$1, '')));
        else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]);
        else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$1, stringReplace(value, ATTR_WHITESPACE$1, '')));
        else if (!value);
        else {
          return false;
        }
        return true;
      };
      var _basicCustomElementTest = function _basicCustomElementTest(tagName) {
        return tagName.indexOf('-') > 0;
      };
      var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
        var attr;
        var value;
        var lcName;
        var l;
        _executeHook('beforeSanitizeAttributes', currentNode, null);
        var attributes = currentNode.attributes;
        if (!attributes) {
          return;
        }
        var hookEvent = {
          attrName: '',
          attrValue: '',
          keepAttr: true,
          allowedAttributes: ALLOWED_ATTR
        };
        l = attributes.length;
        while (l--) {
          attr = attributes[l];
          var _attr = attr, name = _attr.name, namespaceURI = _attr.namespaceURI;
          value = name === 'value' ? attr.value : stringTrim(attr.value);
          lcName = transformCaseFunc(name);
          var initValue = value;
          hookEvent.attrName = lcName;
          hookEvent.attrValue = value;
          hookEvent.keepAttr = true;
          hookEvent.forceKeepAttr = undefined;
          _executeHook('uponSanitizeAttribute', currentNode, hookEvent);
          value = hookEvent.attrValue;
          if (hookEvent.forceKeepAttr) {
            continue;
          }
          if (!hookEvent.keepAttr) {
            _removeAttribute(name, currentNode);
            continue;
          }
          if (regExpTest(/\/>/i, value)) {
            _removeAttribute(name, currentNode);
            continue;
          }
          if (SAFE_FOR_TEMPLATES) {
            value = stringReplace(value, MUSTACHE_EXPR$1, ' ');
            value = stringReplace(value, ERB_EXPR$1, ' ');
          }
          var lcTag = transformCaseFunc(currentNode.nodeName);
          if (!_isValidAttribute(lcTag, lcName, value)) {
            _removeAttribute(name, currentNode);
            continue;
          }
          if (value !== initValue) {
            try {
              if (namespaceURI) {
                currentNode.setAttributeNS(namespaceURI, name, value);
              } else {
                currentNode.setAttribute(name, value);
              }
            } catch (_) {
              _removeAttribute(name, currentNode);
            }
          }
        }
        _executeHook('afterSanitizeAttributes', currentNode, null);
      };
      var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
        var shadowNode;
        var shadowIterator = _createIterator(fragment);
        _executeHook('beforeSanitizeShadowDOM', fragment, null);
        while (shadowNode = shadowIterator.nextNode()) {
          _executeHook('uponSanitizeShadowNode', shadowNode, null);
          if (_sanitizeElements(shadowNode)) {
            continue;
          }
          if (shadowNode.content instanceof DocumentFragment) {
            _sanitizeShadowDOM(shadowNode.content);
          }
          _sanitizeAttributes(shadowNode);
        }
        _executeHook('afterSanitizeShadowDOM', fragment, null);
      };
      DOMPurify.sanitize = function (dirty, cfg) {
        var body;
        var importedNode;
        var currentNode;
        var oldNode;
        var returnNode;
        IS_EMPTY_INPUT = !dirty;
        if (IS_EMPTY_INPUT) {
          dirty = '<!-->';
        }
        if (typeof dirty !== 'string' && !_isNode(dirty)) {
          if (typeof dirty.toString !== 'function') {
            throw typeErrorCreate('toString is not a function');
          } else {
            dirty = dirty.toString();
            if (typeof dirty !== 'string') {
              throw typeErrorCreate('dirty is not a string, aborting');
            }
          }
        }
        if (!DOMPurify.isSupported) {
          if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {
            if (typeof dirty === 'string') {
              return window.toStaticHTML(dirty);
            }
            if (_isNode(dirty)) {
              return window.toStaticHTML(dirty.outerHTML);
            }
          }
          return dirty;
        }
        if (!SET_CONFIG) {
          _parseConfig(cfg);
        }
        DOMPurify.removed = [];
        if (typeof dirty === 'string') {
          IN_PLACE = false;
        }
        if (IN_PLACE) {
          if (dirty.nodeName) {
            var tagName = transformCaseFunc(dirty.nodeName);
            if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
              throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');
            }
          }
        } else if (dirty instanceof Node) {
          body = _initDocument('<!---->');
          importedNode = body.ownerDocument.importNode(dirty, true);
          if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {
            body = importedNode;
          } else if (importedNode.nodeName === 'HTML') {
            body = importedNode;
          } else {
            body.appendChild(importedNode);
          }
        } else {
          if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && dirty.indexOf('<') === -1) {
            return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
          }
          body = _initDocument(dirty);
          if (!body) {
            return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';
          }
        }
        if (body && FORCE_BODY) {
          _forceRemove(body.firstChild);
        }
        var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
        while (currentNode = nodeIterator.nextNode()) {
          if (currentNode.nodeType === 3 && currentNode === oldNode) {
            continue;
          }
          if (_sanitizeElements(currentNode)) {
            continue;
          }
          if (currentNode.content instanceof DocumentFragment) {
            _sanitizeShadowDOM(currentNode.content);
          }
          _sanitizeAttributes(currentNode);
          oldNode = currentNode;
        }
        oldNode = null;
        if (IN_PLACE) {
          return dirty;
        }
        if (RETURN_DOM) {
          if (RETURN_DOM_FRAGMENT) {
            returnNode = createDocumentFragment.call(body.ownerDocument);
            while (body.firstChild) {
              returnNode.appendChild(body.firstChild);
            }
          } else {
            returnNode = body;
          }
          if (ALLOWED_ATTR.shadowroot) {
            returnNode = importNode.call(originalDocument, returnNode, true);
          }
          return returnNode;
        }
        var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
        if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
          serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\n' + serializedHTML;
        }
        if (SAFE_FOR_TEMPLATES) {
          serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$1, ' ');
          serializedHTML = stringReplace(serializedHTML, ERB_EXPR$1, ' ');
        }
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
      };
      DOMPurify.setConfig = function (cfg) {
        _parseConfig(cfg);
        SET_CONFIG = true;
      };
      DOMPurify.clearConfig = function () {
        CONFIG = null;
        SET_CONFIG = false;
      };
      DOMPurify.isValidAttribute = function (tag, attr, value) {
        if (!CONFIG) {
          _parseConfig({});
        }
        var lcTag = transformCaseFunc(tag);
        var lcName = transformCaseFunc(attr);
        return _isValidAttribute(lcTag, lcName, value);
      };
      DOMPurify.addHook = function (entryPoint, hookFunction) {
        if (typeof hookFunction !== 'function') {
          return;
        }
        hooks[entryPoint] = hooks[entryPoint] || [];
        arrayPush(hooks[entryPoint], hookFunction);
      };
      DOMPurify.removeHook = function (entryPoint) {
        if (hooks[entryPoint]) {
          return arrayPop(hooks[entryPoint]);
        }
      };
      DOMPurify.removeHooks = function (entryPoint) {
        if (hooks[entryPoint]) {
          hooks[entryPoint] = [];
        }
      };
      DOMPurify.removeAllHooks = function () {
        hooks = {};
      };
      return DOMPurify;
    }
    var purify = createDOMPurify();

    const each$4 = Tools.each, trim = Tools.trim;
    const queryParts = [
      'source',
      'protocol',
      'authority',
      'userInfo',
      'user',
      'password',
      'host',
      'port',
      'relative',
      'path',
      'directory',
      'file',
      'query',
      'anchor'
    ];
    const DEFAULT_PORTS = {
      ftp: 21,
      http: 80,
      https: 443,
      mailto: 25
    };
    const safeSvgDataUrlElements = [
      'img',
      'video'
    ];
    const blockSvgDataUris = (allowSvgDataUrls, tagName) => {
      if (isNonNullable(allowSvgDataUrls)) {
        return !allowSvgDataUrls;
      } else {
        return isNonNullable(tagName) ? !contains$2(safeSvgDataUrlElements, tagName) : true;
      }
    };
    const decodeUri = encodedUri => {
      try {
        return decodeURIComponent(encodedUri);
      } catch (ex) {
        return unescape(encodedUri);
      }
    };
    const isInvalidUri = (settings, uri, tagName) => {
      const decodedUri = decodeUri(uri).replace(/\s/g, '');
      if (settings.allow_script_urls) {
        return false;
      } else if (/((java|vb)script|mhtml):/i.test(decodedUri)) {
        return true;
      } else if (settings.allow_html_data_urls) {
        return false;
      } else if (/^data:image\//i.test(decodedUri)) {
        return blockSvgDataUris(settings.allow_svg_data_urls, tagName) && /^data:image\/svg\+xml/i.test(decodedUri);
      } else {
        return /^data:/i.test(decodedUri);
      }
    };
    class URI {
      constructor(url, settings = {}) {
        this.path = '';
        this.directory = '';
        url = trim(url);
        this.settings = settings;
        const baseUri = settings.base_uri;
        const self = this;
        if (/^([\w\-]+):([^\/]{2})/i.test(url) || /^\s*#/.test(url)) {
          self.source = url;
          return;
        }
        const isProtocolRelative = url.indexOf('//') === 0;
        if (url.indexOf('/') === 0 && !isProtocolRelative) {
          url = (baseUri ? baseUri.protocol || 'http' : 'http') + '://mce_host' + url;
        }
        if (!/^[\w\-]*:?\/\//.test(url)) {
          const baseUrl = baseUri ? baseUri.path : new URI(document.location.href).directory;
          if ((baseUri === null || baseUri === void 0 ? void 0 : baseUri.protocol) === '') {
            url = '//mce_host' + self.toAbsPath(baseUrl, url);
          } else {
            const match = /([^#?]*)([#?]?.*)/.exec(url);
            if (match) {
              url = (baseUri && baseUri.protocol || 'http') + '://mce_host' + self.toAbsPath(baseUrl, match[1]) + match[2];
            }
          }
        }
        url = url.replace(/@@/g, '(mce_at)');
        const urlMatch = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@\/]*):?([^:@\/]*))?@)?(\[[a-zA-Z0-9:.%]+\]|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/.exec(url);
        if (urlMatch) {
          each$4(queryParts, (v, i) => {
            let part = urlMatch[i];
            if (part) {
              part = part.replace(/\(mce_at\)/g, '@@');
            }
            self[v] = part;
          });
        }
        if (baseUri) {
          if (!self.protocol) {
            self.protocol = baseUri.protocol;
          }
          if (!self.userInfo) {
            self.userInfo = baseUri.userInfo;
          }
          if (!self.port && self.host === 'mce_host') {
            self.port = baseUri.port;
          }
          if (!self.host || self.host === 'mce_host') {
            self.host = baseUri.host;
          }
          self.source = '';
        }
        if (isProtocolRelative) {
          self.protocol = '';
        }
      }
      static parseDataUri(uri) {
        let type;
        const uriComponents = decodeURIComponent(uri).split(',');
        const matches = /data:([^;]+)/.exec(uriComponents[0]);
        if (matches) {
          type = matches[1];
        }
        return {
          type,
          data: uriComponents[1]
        };
      }
      static isDomSafe(uri, context, options = {}) {
        if (options.allow_script_urls) {
          return true;
        } else {
          const decodedUri = Entities.decode(uri).replace(/[\s\u0000-\u001F]+/g, '');
          return !isInvalidUri(options, decodedUri, context);
        }
      }
      static getDocumentBaseUrl(loc) {
        var _a;
        let baseUrl;
        if (loc.protocol.indexOf('http') !== 0 && loc.protocol !== 'file:') {
          baseUrl = (_a = loc.href) !== null && _a !== void 0 ? _a : '';
        } else {
          baseUrl = loc.protocol + '//' + loc.host + loc.pathname;
        }
        if (/^[^:]+:\/\/\/?[^\/]+\//.test(baseUrl)) {
          baseUrl = baseUrl.replace(/[\?#].*$/, '').replace(/[\/\\][^\/]+$/, '');
          if (!/[\/\\]$/.test(baseUrl)) {
            baseUrl += '/';
          }
        }
        return baseUrl;
      }
      setPath(path) {
        const pathMatch = /^(.*?)\/?(\w+)?$/.exec(path);
        if (pathMatch) {
          this.path = pathMatch[0];
          this.directory = pathMatch[1];
          this.file = pathMatch[2];
        }
        this.source = '';
        this.getURI();
      }
      toRelative(uri) {
        if (uri === './') {
          return uri;
        }
        const relativeUri = new URI(uri, { base_uri: this });
        if (relativeUri.host !== 'mce_host' && this.host !== relativeUri.host && relativeUri.host || this.port !== relativeUri.port || this.protocol !== relativeUri.protocol && relativeUri.protocol !== '') {
          return relativeUri.getURI();
        }
        const tu = this.getURI(), uu = relativeUri.getURI();
        if (tu === uu || tu.charAt(tu.length - 1) === '/' && tu.substr(0, tu.length - 1) === uu) {
          return tu;
        }
        let output = this.toRelPath(this.path, relativeUri.path);
        if (relativeUri.query) {
          output += '?' + relativeUri.query;
        }
        if (relativeUri.anchor) {
          output += '#' + relativeUri.anchor;
        }
        return output;
      }
      toAbsolute(uri, noHost) {
        const absoluteUri = new URI(uri, { base_uri: this });
        return absoluteUri.getURI(noHost && this.isSameOrigin(absoluteUri));
      }
      isSameOrigin(uri) {
        if (this.host == uri.host && this.protocol == uri.protocol) {
          if (this.port == uri.port) {
            return true;
          }
          const defaultPort = this.protocol ? DEFAULT_PORTS[this.protocol] : null;
          if (defaultPort && (this.port || defaultPort) == (uri.port || defaultPort)) {
            return true;
          }
        }
        return false;
      }
      toRelPath(base, path) {
        let breakPoint = 0, out = '', i, l;
        const normalizedBase = base.substring(0, base.lastIndexOf('/')).split('/');
        const items = path.split('/');
        if (normalizedBase.length >= items.length) {
          for (i = 0, l = normalizedBase.length; i < l; i++) {
            if (i >= items.length || normalizedBase[i] !== items[i]) {
              breakPoint = i + 1;
              break;
            }
          }
        }
        if (normalizedBase.length < items.length) {
          for (i = 0, l = items.length; i < l; i++) {
            if (i >= normalizedBase.length || normalizedBase[i] !== items[i]) {
              breakPoint = i + 1;
              break;
            }
          }
        }
        if (breakPoint === 1) {
          return path;
        }
        for (i = 0, l = normalizedBase.length - (breakPoint - 1); i < l; i++) {
          out += '../';
        }
        for (i = breakPoint - 1, l = items.length; i < l; i++) {
          if (i !== breakPoint - 1) {
            out += '/' + items[i];
          } else {
            out += items[i];
          }
        }
        return out;
      }
      toAbsPath(base, path) {
        let nb = 0;
        const tr = /\/$/.test(path) ? '/' : '';
        const normalizedBase = base.split('/');
        const normalizedPath = path.split('/');
        const baseParts = [];
        each$4(normalizedBase, k => {
          if (k) {
            baseParts.push(k);
          }
        });
        const pathParts = [];
        for (let i = normalizedPath.length - 1; i >= 0; i--) {
          if (normalizedPath[i].length === 0 || normalizedPath[i] === '.') {
            continue;
          }
          if (normalizedPath[i] === '..') {
            nb++;
            continue;
          }
          if (nb > 0) {
            nb--;
            continue;
          }
          pathParts.push(normalizedPath[i]);
        }
        const i = baseParts.length - nb;
        let outPath;
        if (i <= 0) {
          outPath = reverse(pathParts).join('/');
        } else {
          outPath = baseParts.slice(0, i).join('/') + '/' + reverse(pathParts).join('/');
        }
        if (outPath.indexOf('/') !== 0) {
          outPath = '/' + outPath;
        }
        if (tr && outPath.lastIndexOf('/') !== outPath.length - 1) {
          outPath += tr;
        }
        return outPath;
      }
      getURI(noProtoHost = false) {
        let s;
        if (!this.source || noProtoHost) {
          s = '';
          if (!noProtoHost) {
            if (this.protocol) {
              s += this.protocol + '://';
            } else {
              s += '//';
            }
            if (this.userInfo) {
              s += this.userInfo + '@';
            }
            if (this.host) {
              s += this.host;
            }
            if (this.port) {
              s += ':' + this.port;
            }
          }
          if (this.path) {
            s += this.path;
          }
          if (this.query) {
            s += '?' + this.query;
          }
          if (this.anchor) {
            s += '#' + this.anchor;
          }
          this.source = s;
        }
        return this.source;
      }
    }

    const filteredUrlAttrs = Tools.makeMap('src,href,data,background,action,formaction,poster,xlink:href');
    const internalElementAttr = 'data-mce-type';
    let uid = 0;
    const processNode = (node, settings, schema, evt) => {
      var _a, _b, _c, _d;
      const validate = settings.validate;
      const specialElements = schema.getSpecialElements();
      if (node.nodeType === COMMENT && !settings.allow_conditional_comments && /^\[if/i.test((_a = node.nodeValue) !== null && _a !== void 0 ? _a : '')) {
        node.nodeValue = ' ' + node.nodeValue;
      }
      const lcTagName = (_b = evt === null || evt === void 0 ? void 0 : evt.tagName) !== null && _b !== void 0 ? _b : node.nodeName.toLowerCase();
      if (node.nodeType !== ELEMENT || lcTagName === 'body') {
        return;
      }
      const element = SugarElement.fromDom(node);
      const isInternalElement = has$1(element, internalElementAttr);
      const bogus = get$9(element, 'data-mce-bogus');
      if (!isInternalElement && isString(bogus)) {
        if (bogus === 'all') {
          remove$6(element);
        } else {
          unwrap(element);
        }
        return;
      }
      const rule = schema.getElementRule(lcTagName);
      if (validate && !rule) {
        if (has$2(specialElements, lcTagName)) {
          remove$6(element);
        } else {
          unwrap(element);
        }
        return;
      } else {
        if (isNonNullable(evt)) {
          evt.allowedTags[lcTagName] = true;
        }
      }
      if (validate && rule && !isInternalElement) {
        each$e((_c = rule.attributesForced) !== null && _c !== void 0 ? _c : [], attr => {
          set$3(element, attr.name, attr.value === '{$uid}' ? `mce_${ uid++ }` : attr.value);
        });
        each$e((_d = rule.attributesDefault) !== null && _d !== void 0 ? _d : [], attr => {
          if (!has$1(element, attr.name)) {
            set$3(element, attr.name, attr.value === '{$uid}' ? `mce_${ uid++ }` : attr.value);
          }
        });
        if (rule.attributesRequired && !exists(rule.attributesRequired, attr => has$1(element, attr))) {
          unwrap(element);
          return;
        }
        if (rule.removeEmptyAttrs && hasNone(element)) {
          unwrap(element);
          return;
        }
        if (rule.outputName && rule.outputName !== lcTagName) {
          mutate(element, rule.outputName);
        }
      }
    };
    const shouldKeepAttribute = (settings, schema, tagName, attrName, attrValue) => !(attrName in filteredUrlAttrs && isInvalidUri(settings, attrValue, tagName)) && (!settings.validate || schema.isValid(tagName, attrName) || startsWith(attrName, 'data-') || startsWith(attrName, 'aria-'));
    const isRequiredAttributeOfInternalElement = (ele, attrName) => ele.hasAttribute(internalElementAttr) && (attrName === 'id' || attrName === 'class' || attrName === 'style');
    const isBooleanAttribute = (attrName, schema) => attrName in schema.getBoolAttrs();
    const filterAttributes = (ele, settings, schema) => {
      const {attributes} = ele;
      for (let i = attributes.length - 1; i >= 0; i--) {
        const attr = attributes[i];
        const attrName = attr.name;
        const attrValue = attr.value;
        if (!shouldKeepAttribute(settings, schema, ele.tagName.toLowerCase(), attrName, attrValue) && !isRequiredAttributeOfInternalElement(ele, attrName)) {
          ele.removeAttribute(attrName);
        } else if (isBooleanAttribute(attrName, schema)) {
          ele.setAttribute(attrName, attrName);
        }
      }
    };
    const setupPurify = (settings, schema) => {
      const purify$1 = purify();
      purify$1.addHook('uponSanitizeElement', (ele, evt) => {
        processNode(ele, settings, schema, evt);
      });
      purify$1.addHook('uponSanitizeAttribute', (ele, evt) => {
        const tagName = ele.tagName.toLowerCase();
        const {attrName, attrValue} = evt;
        evt.keepAttr = shouldKeepAttribute(settings, schema, tagName, attrName, attrValue);
        if (evt.keepAttr) {
          evt.allowedAttributes[attrName] = true;
          if (isBooleanAttribute(attrName, schema)) {
            evt.attrValue = attrName;
          }
          if (settings.allow_svg_data_urls && startsWith(attrValue, 'data:image/svg+xml')) {
            evt.forceKeepAttr = true;
          }
        } else if (isRequiredAttributeOfInternalElement(ele, attrName)) {
          evt.forceKeepAttr = true;
        }
      });
      return purify$1;
    };
    const getPurifyConfig = (settings, mimeType) => {
      const basePurifyConfig = {
        IN_PLACE: true,
        ALLOW_UNKNOWN_PROTOCOLS: true,
        ALLOWED_TAGS: [
          '#comment',
          '#cdata-section',
          'body'
        ],
        ALLOWED_ATTR: []
      };
      const config = { ...basePurifyConfig };
      config.PARSER_MEDIA_TYPE = mimeType;
      if (settings.allow_script_urls) {
        config.ALLOWED_URI_REGEXP = /.*/;
      } else if (settings.allow_html_data_urls) {
        config.ALLOWED_URI_REGEXP = /^(?!(\w+script|mhtml):)/i;
      }
      return config;
    };
    const getSanitizer = (settings, schema) => {
      if (settings.sanitize) {
        const purify = setupPurify(settings, schema);
        return (body, mimeType) => {
          purify.sanitize(body, getPurifyConfig(settings, mimeType));
          purify.removed = [];
        };
      } else {
        return (body, _) => {
          const nodeIterator = document.createNodeIterator(body, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT);
          let node;
          while (node = nodeIterator.nextNode()) {
            processNode(node, settings, schema);
            if (isElement$6(node)) {
              filterAttributes(node, settings, schema);
            }
          }
        };
      }
    };

    const makeMap = Tools.makeMap, extend$1 = Tools.extend;
    const transferChildren = (parent, nativeParent, specialElements) => {
      const parentName = parent.name;
      const isSpecial = parentName in specialElements && parentName !== 'title' && parentName !== 'textarea';
      const childNodes = nativeParent.childNodes;
      for (let ni = 0, nl = childNodes.length; ni < nl; ni++) {
        const nativeChild = childNodes[ni];
        const child = new AstNode(nativeChild.nodeName.toLowerCase(), nativeChild.nodeType);
        if (isElement$6(nativeChild)) {
          const attributes = nativeChild.attributes;
          for (let ai = 0, al = attributes.length; ai < al; ai++) {
            const attr = attributes[ai];
            child.attr(attr.name, attr.value);
          }
        } else if (isText$a(nativeChild)) {
          child.value = nativeChild.data;
          if (isSpecial) {
            child.raw = true;
          }
        } else if (isComment(nativeChild) || isCData(nativeChild) || isPi(nativeChild)) {
          child.value = nativeChild.data;
        }
        transferChildren(child, nativeChild, specialElements);
        parent.append(child);
      }
    };
    const walkTree = (root, preprocessors, postprocessors) => {
      const traverseOrder = [];
      for (let node = root, lastNode = node; node; lastNode = node, node = node.walk()) {
        const tempNode = node;
        each$e(preprocessors, preprocess => preprocess(tempNode));
        if (isNullable(tempNode.parent) && tempNode !== root) {
          node = lastNode;
        } else {
          traverseOrder.push(tempNode);
        }
      }
      for (let i = traverseOrder.length - 1; i >= 0; i--) {
        const node = traverseOrder[i];
        each$e(postprocessors, postprocess => postprocess(node));
      }
    };
    const whitespaceCleaner = (root, schema, settings, args) => {
      const validate = settings.validate;
      const nonEmptyElements = schema.getNonEmptyElements();
      const whitespaceElements = schema.getWhitespaceElements();
      const blockElements = extend$1(makeMap('script,style,head,html,body,title,meta,param'), schema.getBlockElements());
      const textRootBlockElements = getTextRootBlockElements(schema);
      const allWhiteSpaceRegExp = /[ \t\r\n]+/g;
      const startWhiteSpaceRegExp = /^[ \t\r\n]+/;
      const endWhiteSpaceRegExp = /[ \t\r\n]+$/;
      const hasWhitespaceParent = node => {
        let tempNode = node.parent;
        while (isNonNullable(tempNode)) {
          if (tempNode.name in whitespaceElements) {
            return true;
          } else {
            tempNode = tempNode.parent;
          }
        }
        return false;
      };
      const isTextRootBlockEmpty = node => {
        let tempNode = node;
        while (isNonNullable(tempNode)) {
          if (tempNode.name in textRootBlockElements) {
            return isEmpty(schema, nonEmptyElements, whitespaceElements, tempNode);
          } else {
            tempNode = tempNode.parent;
          }
        }
        return false;
      };
      const isBlock = node => node.name in blockElements && !isTransparentAstInline(schema, node);
      const isAtEdgeOfBlock = (node, start) => {
        const neighbour = start ? node.prev : node.next;
        if (isNonNullable(neighbour) || isNullable(node.parent)) {
          return false;
        }
        return isBlock(node.parent) && (node.parent !== root || args.isRootContent === true);
      };
      const preprocess = node => {
        var _a;
        if (node.type === 3) {
          if (!hasWhitespaceParent(node)) {
            let text = (_a = node.value) !== null && _a !== void 0 ? _a : '';
            text = text.replace(allWhiteSpaceRegExp, ' ');
            if (isLineBreakNode(node.prev, isBlock) || isAtEdgeOfBlock(node, true)) {
              text = text.replace(startWhiteSpaceRegExp, '');
            }
            if (text.length === 0) {
              node.remove();
            } else {
              node.value = text;
            }
          }
        }
      };
      const postprocess = node => {
        var _a;
        if (node.type === 1) {
          const elementRule = schema.getElementRule(node.name);
          if (validate && elementRule) {
            const isNodeEmpty = isEmpty(schema, nonEmptyElements, whitespaceElements, node);
            if (elementRule.paddInEmptyBlock && isNodeEmpty && isTextRootBlockEmpty(node)) {
              paddEmptyNode(args, isBlock, node);
            } else if (elementRule.removeEmpty && isNodeEmpty) {
              if (isBlock(node)) {
                node.remove();
              } else {
                node.unwrap();
              }
            } else if (elementRule.paddEmpty && (isNodeEmpty || isPaddedWithNbsp(node))) {
              paddEmptyNode(args, isBlock, node);
            }
          }
        } else if (node.type === 3) {
          if (!hasWhitespaceParent(node)) {
            let text = (_a = node.value) !== null && _a !== void 0 ? _a : '';
            if (node.next && isBlock(node.next) || isAtEdgeOfBlock(node, false)) {
              text = text.replace(endWhiteSpaceRegExp, '');
            }
            if (text.length === 0) {
              node.remove();
            } else {
              node.value = text;
            }
          }
        }
      };
      return [
        preprocess,
        postprocess
      ];
    };
    const getRootBlockName = (settings, args) => {
      var _a;
      const name = (_a = args.forced_root_block) !== null && _a !== void 0 ? _a : settings.forced_root_block;
      if (name === false) {
        return '';
      } else if (name === true) {
        return 'p';
      } else {
        return name;
      }
    };
    const DomParser = (settings = {}, schema = Schema()) => {
      const nodeFilterRegistry = create$8();
      const attributeFilterRegistry = create$8();
      const defaultedSettings = {
        validate: true,
        root_name: 'body',
        sanitize: true,
        ...settings
      };
      const parser = new DOMParser();
      const sanitize = getSanitizer(defaultedSettings, schema);
      const parseAndSanitizeWithContext = (html, rootName, format = 'html') => {
        const mimeType = format === 'xhtml' ? 'application/xhtml+xml' : 'text/html';
        const isSpecialRoot = has$2(schema.getSpecialElements(), rootName.toLowerCase());
        const content = isSpecialRoot ? `<${ rootName }>${ html }</${ rootName }>` : html;
        const wrappedHtml = format === 'xhtml' ? `<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>${ content }</body></html>` : `<body>${ content }</body>`;
        const body = parser.parseFromString(wrappedHtml, mimeType).body;
        sanitize(body, mimeType);
        return isSpecialRoot ? body.firstChild : body;
      };
      const addNodeFilter = nodeFilterRegistry.addFilter;
      const getNodeFilters = nodeFilterRegistry.getFilters;
      const removeNodeFilter = nodeFilterRegistry.removeFilter;
      const addAttributeFilter = attributeFilterRegistry.addFilter;
      const getAttributeFilters = attributeFilterRegistry.getFilters;
      const removeAttributeFilter = attributeFilterRegistry.removeFilter;
      const findInvalidChildren = (node, invalidChildren) => {
        if (isInvalid(schema, node)) {
          invalidChildren.push(node);
        }
      };
      const isWrappableNode = (blockElements, node) => {
        const isInternalElement = isString(node.attr(internalElementAttr));
        const isInlineElement = node.type === 1 && (!has$2(blockElements, node.name) && !isTransparentAstBlock(schema, node));
        return node.type === 3 || isInlineElement && !isInternalElement;
      };
      const addRootBlocks = (rootNode, rootBlockName) => {
        const blockElements = extend$1(makeMap('script,style,head,html,body,title,meta,param'), schema.getBlockElements());
        const startWhiteSpaceRegExp = /^[ \t\r\n]+/;
        const endWhiteSpaceRegExp = /[ \t\r\n]+$/;
        let node = rootNode.firstChild, rootBlockNode = null;
        const trim = rootBlock => {
          var _a, _b;
          if (rootBlock) {
            node = rootBlock.firstChild;
            if (node && node.type === 3) {
              node.value = (_a = node.value) === null || _a === void 0 ? void 0 : _a.replace(startWhiteSpaceRegExp, '');
            }
            node = rootBlock.lastChild;
            if (node && node.type === 3) {
              node.value = (_b = node.value) === null || _b === void 0 ? void 0 : _b.replace(endWhiteSpaceRegExp, '');
            }
          }
        };
        if (!schema.isValidChild(rootNode.name, rootBlockName.toLowerCase())) {
          return;
        }
        while (node) {
          const next = node.next;
          if (isWrappableNode(blockElements, node)) {
            if (!rootBlockNode) {
              rootBlockNode = new AstNode(rootBlockName, 1);
              rootBlockNode.attr(defaultedSettings.forced_root_block_attrs);
              rootNode.insert(rootBlockNode, node);
              rootBlockNode.append(node);
            } else {
              rootBlockNode.append(node);
            }
          } else {
            trim(rootBlockNode);
            rootBlockNode = null;
          }
          node = next;
        }
        trim(rootBlockNode);
      };
      const parse = (html, args = {}) => {
        var _a;
        const validate = defaultedSettings.validate;
        const rootName = (_a = args.context) !== null && _a !== void 0 ? _a : defaultedSettings.root_name;
        const element = parseAndSanitizeWithContext(html, rootName, args.format);
        updateChildren(schema, element);
        const rootNode = new AstNode(rootName, 11);
        transferChildren(rootNode, element, schema.getSpecialElements());
        element.innerHTML = '';
        const [whitespacePre, whitespacePost] = whitespaceCleaner(rootNode, schema, defaultedSettings, args);
        const invalidChildren = [];
        const invalidFinder = validate ? node => findInvalidChildren(node, invalidChildren) : noop;
        const matches = {
          nodes: {},
          attributes: {}
        };
        const matchFinder = node => matchNode$1(getNodeFilters(), getAttributeFilters(), node, matches);
        walkTree(rootNode, [
          whitespacePre,
          matchFinder
        ], [
          whitespacePost,
          invalidFinder
        ]);
        invalidChildren.reverse();
        if (validate && invalidChildren.length > 0) {
          if (args.context) {
            const {
              pass: topLevelChildren,
              fail: otherChildren
            } = partition$2(invalidChildren, child => child.parent === rootNode);
            cleanInvalidNodes(otherChildren, schema, rootNode, matchFinder);
            args.invalid = topLevelChildren.length > 0;
          } else {
            cleanInvalidNodes(invalidChildren, schema, rootNode, matchFinder);
          }
        }
        const rootBlockName = getRootBlockName(defaultedSettings, args);
        if (rootBlockName && (rootNode.name === 'body' || args.isRootContent)) {
          addRootBlocks(rootNode, rootBlockName);
        }
        if (!args.invalid) {
          runFilters(matches, args);
        }
        return rootNode;
      };
      const exports = {
        schema,
        addAttributeFilter,
        getAttributeFilters,
        removeAttributeFilter,
        addNodeFilter,
        getNodeFilters,
        removeNodeFilter,
        parse
      };
      register$4(exports, defaultedSettings);
      register$5(exports, defaultedSettings, schema);
      return exports;
    };

    const serializeContent = content => isTreeNode(content) ? HtmlSerializer({ validate: false }).serialize(content) : content;
    const withSerializedContent = (content, fireEvent, sanitize) => {
      const serializedContent = serializeContent(content);
      const eventArgs = fireEvent(serializedContent);
      if (eventArgs.isDefaultPrevented()) {
        return eventArgs;
      } else if (isTreeNode(content)) {
        if (eventArgs.content !== serializedContent) {
          const rootNode = DomParser({
            validate: false,
            forced_root_block: false,
            sanitize
          }).parse(eventArgs.content, { context: content.name });
          return {
            ...eventArgs,
            content: rootNode
          };
        } else {
          return {
            ...eventArgs,
            content
          };
        }
      } else {
        return eventArgs;
      }
    };
    const preProcessGetContent = (editor, args) => {
      if (args.no_events) {
        return Result.value(args);
      } else {
        const eventArgs = fireBeforeGetContent(editor, args);
        if (eventArgs.isDefaultPrevented()) {
          return Result.error(fireGetContent(editor, {
            content: '',
            ...eventArgs
          }).content);
        } else {
          return Result.value(eventArgs);
        }
      }
    };
    const postProcessGetContent = (editor, content, args) => {
      if (args.no_events) {
        return content;
      } else {
        const processedEventArgs = withSerializedContent(content, content => fireGetContent(editor, {
          ...args,
          content
        }), shouldSanitizeXss(editor));
        return processedEventArgs.content;
      }
    };
    const preProcessSetContent = (editor, args) => {
      if (args.no_events) {
        return Result.value(args);
      } else {
        const processedEventArgs = withSerializedContent(args.content, content => fireBeforeSetContent(editor, {
          ...args,
          content
        }), shouldSanitizeXss(editor));
        if (processedEventArgs.isDefaultPrevented()) {
          fireSetContent(editor, processedEventArgs);
          return Result.error(undefined);
        } else {
          return Result.value(processedEventArgs);
        }
      }
    };
    const postProcessSetContent = (editor, content, args) => {
      if (!args.no_events) {
        fireSetContent(editor, {
          ...args,
          content
        });
      }
    };

    const tableModel = (element, width, rows) => ({
      element,
      width,
      rows
    });
    const tableRow = (element, cells) => ({
      element,
      cells
    });
    const cellPosition = (x, y) => ({
      x,
      y
    });
    const getSpan = (td, key) => {
      return getOpt(td, key).bind(toInt).getOr(1);
    };
    const fillout = (table, x, y, tr, td) => {
      const rowspan = getSpan(td, 'rowspan');
      const colspan = getSpan(td, 'colspan');
      const rows = table.rows;
      for (let y2 = y; y2 < y + rowspan; y2++) {
        if (!rows[y2]) {
          rows[y2] = tableRow(deep$1(tr), []);
        }
        for (let x2 = x; x2 < x + colspan; x2++) {
          const cells = rows[y2].cells;
          cells[x2] = y2 === y && x2 === x ? td : shallow$1(td);
        }
      }
    };
    const cellExists = (table, x, y) => {
      const rows = table.rows;
      const cells = rows[y] ? rows[y].cells : [];
      return !!cells[x];
    };
    const skipCellsX = (table, x, y) => {
      while (cellExists(table, x, y)) {
        x++;
      }
      return x;
    };
    const getWidth = rows => {
      return foldl(rows, (acc, row) => {
        return row.cells.length > acc ? row.cells.length : acc;
      }, 0);
    };
    const findElementPos = (table, element) => {
      const rows = table.rows;
      for (let y = 0; y < rows.length; y++) {
        const cells = rows[y].cells;
        for (let x = 0; x < cells.length; x++) {
          if (eq(cells[x], element)) {
            return Optional.some(cellPosition(x, y));
          }
        }
      }
      return Optional.none();
    };
    const extractRows = (table, sx, sy, ex, ey) => {
      const newRows = [];
      const rows = table.rows;
      for (let y = sy; y <= ey; y++) {
        const cells = rows[y].cells;
        const slice = sx < ex ? cells.slice(sx, ex + 1) : cells.slice(ex, sx + 1);
        newRows.push(tableRow(rows[y].element, slice));
      }
      return newRows;
    };
    const subTable = (table, startPos, endPos) => {
      const sx = startPos.x, sy = startPos.y;
      const ex = endPos.x, ey = endPos.y;
      const newRows = sy < ey ? extractRows(table, sx, sy, ex, ey) : extractRows(table, sx, ey, ex, sy);
      return tableModel(table.element, getWidth(newRows), newRows);
    };
    const createDomTable = (table, rows) => {
      const tableElement = shallow$1(table.element);
      const tableBody = SugarElement.fromTag('tbody');
      append(tableBody, rows);
      append$1(tableElement, tableBody);
      return tableElement;
    };
    const modelRowsToDomRows = table => {
      return map$3(table.rows, row => {
        const cells = map$3(row.cells, cell => {
          const td = deep$1(cell);
          remove$b(td, 'colspan');
          remove$b(td, 'rowspan');
          return td;
        });
        const tr = shallow$1(row.element);
        append(tr, cells);
        return tr;
      });
    };
    const fromDom = tableElm => {
      const table = tableModel(shallow$1(tableElm), 0, []);
      each$e(descendants(tableElm, 'tr'), (tr, y) => {
        each$e(descendants(tr, 'td,th'), (td, x) => {
          fillout(table, skipCellsX(table, x, y), y, tr, td);
        });
      });
      return tableModel(table.element, getWidth(table.rows), table.rows);
    };
    const toDom = table => {
      return createDomTable(table, modelRowsToDomRows(table));
    };
    const subsection = (table, startElement, endElement) => {
      return findElementPos(table, startElement).bind(startPos => {
        return findElementPos(table, endElement).map(endPos => {
          return subTable(table, startPos, endPos);
        });
      });
    };

    const findParentListContainer = parents => find$2(parents, elm => name(elm) === 'ul' || name(elm) === 'ol');
    const getFullySelectedListWrappers = (parents, rng) => find$2(parents, elm => name(elm) === 'li' && hasAllContentsSelected(elm, rng)).fold(constant([]), _li => findParentListContainer(parents).map(listCont => {
      const listElm = SugarElement.fromTag(name(listCont));
      const listStyles = filter$4(getAllRaw(listCont), (_style, name) => startsWith(name, 'list-style'));
      setAll(listElm, listStyles);
      return [
        SugarElement.fromTag('li'),
        listElm
      ];
    }).getOr([]));
    const wrap = (innerElm, elms) => {
      const wrapped = foldl(elms, (acc, elm) => {
        append$1(elm, acc);
        return elm;
      }, innerElm);
      return elms.length > 0 ? fromElements([wrapped]) : wrapped;
    };
    const directListWrappers = commonAnchorContainer => {
      if (isListItem$1(commonAnchorContainer)) {
        return parent(commonAnchorContainer).filter(isList).fold(constant([]), listElm => [
          commonAnchorContainer,
          listElm
        ]);
      } else {
        return isList(commonAnchorContainer) ? [commonAnchorContainer] : [];
      }
    };
    const getWrapElements = (rootNode, rng) => {
      const commonAnchorContainer = SugarElement.fromDom(rng.commonAncestorContainer);
      const parents = parentsAndSelf(commonAnchorContainer, rootNode);
      const wrapElements = filter$5(parents, isWrapElement);
      const listWrappers = getFullySelectedListWrappers(parents, rng);
      const allWrappers = wrapElements.concat(listWrappers.length ? listWrappers : directListWrappers(commonAnchorContainer));
      return map$3(allWrappers, shallow$1);
    };
    const emptyFragment = () => fromElements([]);
    const getFragmentFromRange = (rootNode, rng) => wrap(SugarElement.fromDom(rng.cloneContents()), getWrapElements(rootNode, rng));
    const getParentTable = (rootElm, cell) => ancestor$3(cell, 'table', curry(eq, rootElm));
    const getTableFragment = (rootNode, selectedTableCells) => getParentTable(rootNode, selectedTableCells[0]).bind(tableElm => {
      const firstCell = selectedTableCells[0];
      const lastCell = selectedTableCells[selectedTableCells.length - 1];
      const fullTableModel = fromDom(tableElm);
      return subsection(fullTableModel, firstCell, lastCell).map(sectionedTableModel => fromElements([toDom(sectionedTableModel)]));
    }).getOrThunk(emptyFragment);
    const getSelectionFragment = (rootNode, ranges) => ranges.length > 0 && ranges[0].collapsed ? emptyFragment() : getFragmentFromRange(rootNode, ranges[0]);
    const read$3 = (rootNode, ranges) => {
      const selectedCells = getCellsFromElementOrRanges(ranges, rootNode);
      return selectedCells.length > 0 ? getTableFragment(rootNode, selectedCells) : getSelectionFragment(rootNode, ranges);
    };

    const isCollapsibleWhitespace = (text, index) => index >= 0 && index < text.length && isWhiteSpace(text.charAt(index));
    const getInnerText = bin => {
      return trim$1(bin.innerText);
    };
    const getContextNodeName = parentBlockOpt => parentBlockOpt.map(block => block.nodeName).getOr('div').toLowerCase();
    const getTextContent = editor => Optional.from(editor.selection.getRng()).map(rng => {
      var _a;
      const parentBlockOpt = Optional.from(editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock));
      const body = editor.getBody();
      const contextNodeName = getContextNodeName(parentBlockOpt);
      const rangeContentClone = SugarElement.fromDom(rng.cloneContents());
      cleanupBogusElements(rangeContentClone);
      cleanupInputNames(rangeContentClone);
      const bin = editor.dom.add(body, contextNodeName, {
        'data-mce-bogus': 'all',
        'style': 'overflow: hidden; opacity: 0;'
      }, rangeContentClone.dom);
      const text = getInnerText(bin);
      const nonRenderedText = trim$1((_a = bin.textContent) !== null && _a !== void 0 ? _a : '');
      editor.dom.remove(bin);
      if (isCollapsibleWhitespace(nonRenderedText, 0) || isCollapsibleWhitespace(nonRenderedText, nonRenderedText.length - 1)) {
        const parentBlock = parentBlockOpt.getOr(body);
        const parentBlockText = getInnerText(parentBlock);
        const textIndex = parentBlockText.indexOf(text);
        if (textIndex === -1) {
          return text;
        } else {
          const hasProceedingSpace = isCollapsibleWhitespace(parentBlockText, textIndex - 1);
          const hasTrailingSpace = isCollapsibleWhitespace(parentBlockText, textIndex + text.length);
          return (hasProceedingSpace ? ' ' : '') + text + (hasTrailingSpace ? ' ' : '');
        }
      } else {
        return text;
      }
    }).getOr('');
    const getSerializedContent = (editor, args) => {
      const rng = editor.selection.getRng(), tmpElm = editor.dom.create('body');
      const sel = editor.selection.getSel();
      const ranges = processRanges(editor, getRanges$1(sel));
      const fragment = args.contextual ? read$3(SugarElement.fromDom(editor.getBody()), ranges).dom : rng.cloneContents();
      if (fragment) {
        tmpElm.appendChild(fragment);
      }
      return editor.selection.serializer.serialize(tmpElm, args);
    };
    const extractSelectedContent = (editor, args) => {
      if (args.format === 'text') {
        return getTextContent(editor);
      } else {
        const content = getSerializedContent(editor, args);
        if (args.format === 'tree') {
          return content;
        } else {
          return editor.selection.isCollapsed() ? '' : content;
        }
      }
    };
    const setupArgs$3 = (args, format) => ({
      ...args,
      format,
      get: true,
      selection: true,
      getInner: true
    });
    const getSelectedContentInternal = (editor, format, args = {}) => {
      const defaultedArgs = setupArgs$3(args, format);
      return preProcessGetContent(editor, defaultedArgs).fold(identity, updatedArgs => {
        const content = extractSelectedContent(editor, updatedArgs);
        return postProcessGetContent(editor, content, updatedArgs);
      });
    };

    const KEEP = 0, INSERT = 1, DELETE = 2;
    const diff = (left, right) => {
      const size = left.length + right.length + 2;
      const vDown = new Array(size);
      const vUp = new Array(size);
      const snake = (start, end, diag) => {
        return {
          start,
          end,
          diag
        };
      };
      const buildScript = (start1, end1, start2, end2, script) => {
        const middle = getMiddleSnake(start1, end1, start2, end2);
        if (middle === null || middle.start === end1 && middle.diag === end1 - end2 || middle.end === start1 && middle.diag === start1 - start2) {
          let i = start1;
          let j = start2;
          while (i < end1 || j < end2) {
            if (i < end1 && j < end2 && left[i] === right[j]) {
              script.push([
                KEEP,
                left[i]
              ]);
              ++i;
              ++j;
            } else {
              if (end1 - start1 > end2 - start2) {
                script.push([
                  DELETE,
                  left[i]
                ]);
                ++i;
              } else {
                script.push([
                  INSERT,
                  right[j]
                ]);
                ++j;
              }
            }
          }
        } else {
          buildScript(start1, middle.start, start2, middle.start - middle.diag, script);
          for (let i2 = middle.start; i2 < middle.end; ++i2) {
            script.push([
              KEEP,
              left[i2]
            ]);
          }
          buildScript(middle.end, end1, middle.end - middle.diag, end2, script);
        }
      };
      const buildSnake = (start, diag, end1, end2) => {
        let end = start;
        while (end - diag < end2 && end < end1 && left[end] === right[end - diag]) {
          ++end;
        }
        return snake(start, end, diag);
      };
      const getMiddleSnake = (start1, end1, start2, end2) => {
        const m = end1 - start1;
        const n = end2 - start2;
        if (m === 0 || n === 0) {
          return null;
        }
        const delta = m - n;
        const sum = n + m;
        const offset = (sum % 2 === 0 ? sum : sum + 1) / 2;
        vDown[1 + offset] = start1;
        vUp[1 + offset] = end1 + 1;
        let d, k, i, x, y;
        for (d = 0; d <= offset; ++d) {
          for (k = -d; k <= d; k += 2) {
            i = k + offset;
            if (k === -d || k !== d && vDown[i - 1] < vDown[i + 1]) {
              vDown[i] = vDown[i + 1];
            } else {
              vDown[i] = vDown[i - 1] + 1;
            }
            x = vDown[i];
            y = x - start1 + start2 - k;
            while (x < end1 && y < end2 && left[x] === right[y]) {
              vDown[i] = ++x;
              ++y;
            }
            if (delta % 2 !== 0 && delta - d <= k && k <= delta + d) {
              if (vUp[i - delta] <= vDown[i]) {
                return buildSnake(vUp[i - delta], k + start1 - start2, end1, end2);
              }
            }
          }
          for (k = delta - d; k <= delta + d; k += 2) {
            i = k + offset - delta;
            if (k === delta - d || k !== delta + d && vUp[i + 1] <= vUp[i - 1]) {
              vUp[i] = vUp[i + 1] - 1;
            } else {
              vUp[i] = vUp[i - 1];
            }
            x = vUp[i] - 1;
            y = x - start1 + start2 - k;
            while (x >= start1 && y >= start2 && left[x] === right[y]) {
              vUp[i] = x--;
              y--;
            }
            if (delta % 2 === 0 && -d <= k && k <= d) {
              if (vUp[i] <= vDown[i + delta]) {
                return buildSnake(vUp[i], k + start1 - start2, end1, end2);
              }
            }
          }
        }
        return null;
      };
      const script = [];
      buildScript(0, left.length, 0, right.length, script);
      return script;
    };

    const getOuterHtml = elm => {
      if (isElement$6(elm)) {
        return elm.outerHTML;
      } else if (isText$a(elm)) {
        return Entities.encodeRaw(elm.data, false);
      } else if (isComment(elm)) {
        return '<!--' + elm.data + '-->';
      }
      return '';
    };
    const createFragment = html => {
      let node;
      const container = document.createElement('div');
      const frag = document.createDocumentFragment();
      if (html) {
        container.innerHTML = html;
      }
      while (node = container.firstChild) {
        frag.appendChild(node);
      }
      return frag;
    };
    const insertAt = (elm, html, index) => {
      const fragment = createFragment(html);
      if (elm.hasChildNodes() && index < elm.childNodes.length) {
        const target = elm.childNodes[index];
        elm.insertBefore(fragment, target);
      } else {
        elm.appendChild(fragment);
      }
    };
    const removeAt = (elm, index) => {
      if (elm.hasChildNodes() && index < elm.childNodes.length) {
        const target = elm.childNodes[index];
        elm.removeChild(target);
      }
    };
    const applyDiff = (diff, elm) => {
      let index = 0;
      each$e(diff, action => {
        if (action[0] === KEEP) {
          index++;
        } else if (action[0] === INSERT) {
          insertAt(elm, action[1], index);
          index++;
        } else if (action[0] === DELETE) {
          removeAt(elm, index);
        }
      });
    };
    const read$2 = elm => {
      return filter$5(map$3(from(elm.childNodes), getOuterHtml), item => {
        return item.length > 0;
      });
    };
    const write = (fragments, elm) => {
      const currentFragments = map$3(from(elm.childNodes), getOuterHtml);
      applyDiff(diff(currentFragments, fragments), elm);
      return elm;
    };

    const lazyTempDocument = cached(() => document.implementation.createHTMLDocument('undo'));
    const hasIframes = html => {
      return html.indexOf('</iframe>') !== -1;
    };
    const createFragmentedLevel = fragments => {
      return {
        type: 'fragmented',
        fragments,
        content: '',
        bookmark: null,
        beforeBookmark: null
      };
    };
    const createCompleteLevel = content => {
      return {
        type: 'complete',
        fragments: null,
        content,
        bookmark: null,
        beforeBookmark: null
      };
    };
    const createFromEditor = editor => {
      const fragments = read$2(editor.getBody());
      const trimmedFragments = bind$3(fragments, html => {
        const trimmed = trimInternal(editor.serializer, html);
        return trimmed.length > 0 ? [trimmed] : [];
      });
      const content = trimmedFragments.join('');
      return hasIframes(content) ? createFragmentedLevel(trimmedFragments) : createCompleteLevel(content);
    };
    const applyToEditor = (editor, level, before) => {
      const bookmark = before ? level.beforeBookmark : level.bookmark;
      if (level.type === 'fragmented') {
        write(level.fragments, editor.getBody());
      } else {
        editor.setContent(level.content, {
          format: 'raw',
          no_selection: isNonNullable(bookmark) && isPathBookmark(bookmark) ? !bookmark.isFakeCaret : true
        });
      }
      if (bookmark) {
        editor.selection.moveToBookmark(bookmark);
        editor.selection.scrollIntoView();
      }
    };
    const getLevelContent = level => {
      return level.type === 'fragmented' ? level.fragments.join('') : level.content;
    };
    const getCleanLevelContent = level => {
      const elm = SugarElement.fromTag('body', lazyTempDocument());
      set$1(elm, getLevelContent(level));
      each$e(descendants(elm, '*[data-mce-bogus]'), unwrap);
      return get$6(elm);
    };
    const hasEqualContent = (level1, level2) => getLevelContent(level1) === getLevelContent(level2);
    const hasEqualCleanedContent = (level1, level2) => getCleanLevelContent(level1) === getCleanLevelContent(level2);
    const isEq$1 = (level1, level2) => {
      if (!level1 || !level2) {
        return false;
      } else if (hasEqualContent(level1, level2)) {
        return true;
      } else {
        return hasEqualCleanedContent(level1, level2);
      }
    };

    const isUnlocked = locks => locks.get() === 0;

    const setTyping = (undoManager, typing, locks) => {
      if (isUnlocked(locks)) {
        undoManager.typing = typing;
      }
    };
    const endTyping = (undoManager, locks) => {
      if (undoManager.typing) {
        setTyping(undoManager, false, locks);
        undoManager.add();
      }
    };
    const endTypingLevelIgnoreLocks = undoManager => {
      if (undoManager.typing) {
        undoManager.typing = false;
        undoManager.add();
      }
    };

    const beforeChange$1 = (editor, locks, beforeBookmark) => {
      if (isUnlocked(locks)) {
        beforeBookmark.set(getUndoBookmark(editor.selection));
      }
    };
    const addUndoLevel$1 = (editor, undoManager, index, locks, beforeBookmark, level, event) => {
      const currentLevel = createFromEditor(editor);
      const newLevel = Tools.extend(level || {}, currentLevel);
      if (!isUnlocked(locks) || editor.removed) {
        return null;
      }
      const lastLevel = undoManager.data[index.get()];
      if (editor.dispatch('BeforeAddUndo', {
          level: newLevel,
          lastLevel,
          originalEvent: event
        }).isDefaultPrevented()) {
        return null;
      }
      if (lastLevel && isEq$1(lastLevel, newLevel)) {
        return null;
      }
      if (undoManager.data[index.get()]) {
        beforeBookmark.get().each(bm => {
          undoManager.data[index.get()].beforeBookmark = bm;
        });
      }
      const customUndoRedoLevels = getCustomUndoRedoLevels(editor);
      if (customUndoRedoLevels) {
        if (undoManager.data.length > customUndoRedoLevels) {
          for (let i = 0; i < undoManager.data.length - 1; i++) {
            undoManager.data[i] = undoManager.data[i + 1];
          }
          undoManager.data.length--;
          index.set(undoManager.data.length);
        }
      }
      newLevel.bookmark = getUndoBookmark(editor.selection);
      if (index.get() < undoManager.data.length - 1) {
        undoManager.data.length = index.get() + 1;
      }
      undoManager.data.push(newLevel);
      index.set(undoManager.data.length - 1);
      const args = {
        level: newLevel,
        lastLevel,
        originalEvent: event
      };
      if (index.get() > 0) {
        editor.setDirty(true);
        editor.dispatch('AddUndo', args);
        editor.dispatch('change', args);
      } else {
        editor.dispatch('AddUndo', args);
      }
      return newLevel;
    };
    const clear$1 = (editor, undoManager, index) => {
      undoManager.data = [];
      index.set(0);
      undoManager.typing = false;
      editor.dispatch('ClearUndos');
    };
    const extra$1 = (editor, undoManager, index, callback1, callback2) => {
      if (undoManager.transact(callback1)) {
        const bookmark = undoManager.data[index.get()].bookmark;
        const lastLevel = undoManager.data[index.get() - 1];
        applyToEditor(editor, lastLevel, true);
        if (undoManager.transact(callback2)) {
          undoManager.data[index.get() - 1].beforeBookmark = bookmark;
        }
      }
    };
    const redo$1 = (editor, index, data) => {
      let level;
      if (index.get() < data.length - 1) {
        index.set(index.get() + 1);
        level = data[index.get()];
        applyToEditor(editor, level, false);
        editor.setDirty(true);
        editor.dispatch('Redo', { level });
      }
      return level;
    };
    const undo$1 = (editor, undoManager, locks, index) => {
      let level;
      if (undoManager.typing) {
        undoManager.add();
        undoManager.typing = false;
        setTyping(undoManager, false, locks);
      }
      if (index.get() > 0) {
        index.set(index.get() - 1);
        level = undoManager.data[index.get()];
        applyToEditor(editor, level, true);
        editor.setDirty(true);
        editor.dispatch('Undo', { level });
      }
      return level;
    };
    const reset$1 = undoManager => {
      undoManager.clear();
      undoManager.add();
    };
    const hasUndo$1 = (editor, undoManager, index) => index.get() > 0 || undoManager.typing && undoManager.data[0] && !isEq$1(createFromEditor(editor), undoManager.data[0]);
    const hasRedo$1 = (undoManager, index) => index.get() < undoManager.data.length - 1 && !undoManager.typing;
    const transact$1 = (undoManager, locks, callback) => {
      endTyping(undoManager, locks);
      undoManager.beforeChange();
      undoManager.ignore(callback);
      return undoManager.add();
    };
    const ignore$1 = (locks, callback) => {
      try {
        locks.set(locks.get() + 1);
        callback();
      } finally {
        locks.set(locks.get() - 1);
      }
    };

    const addVisualInternal = (editor, elm) => {
      const dom = editor.dom;
      const scope = isNonNullable(elm) ? elm : editor.getBody();
      each$e(dom.select('table,a', scope), matchedElm => {
        switch (matchedElm.nodeName) {
        case 'TABLE':
          const cls = getVisualAidsTableClass(editor);
          const value = dom.getAttrib(matchedElm, 'border');
          if ((!value || value === '0') && editor.hasVisual) {
            dom.addClass(matchedElm, cls);
          } else {
            dom.removeClass(matchedElm, cls);
          }
          break;
        case 'A':
          if (!dom.getAttrib(matchedElm, 'href')) {
            const value = dom.getAttrib(matchedElm, 'name') || matchedElm.id;
            const cls = getVisualAidsAnchorClass(editor);
            if (value && editor.hasVisual) {
              dom.addClass(matchedElm, cls);
            } else {
              dom.removeClass(matchedElm, cls);
            }
          }
          break;
        }
      });
      editor.dispatch('VisualAid', {
        element: elm,
        hasVisual: editor.hasVisual
      });
    };

    const makePlainAdaptor = editor => ({
      init: { bindEvents: noop },
      undoManager: {
        beforeChange: (locks, beforeBookmark) => beforeChange$1(editor, locks, beforeBookmark),
        add: (undoManager, index, locks, beforeBookmark, level, event) => addUndoLevel$1(editor, undoManager, index, locks, beforeBookmark, level, event),
        undo: (undoManager, locks, index) => undo$1(editor, undoManager, locks, index),
        redo: (index, data) => redo$1(editor, index, data),
        clear: (undoManager, index) => clear$1(editor, undoManager, index),
        reset: undoManager => reset$1(undoManager),
        hasUndo: (undoManager, index) => hasUndo$1(editor, undoManager, index),
        hasRedo: (undoManager, index) => hasRedo$1(undoManager, index),
        transact: (undoManager, locks, callback) => transact$1(undoManager, locks, callback),
        ignore: (locks, callback) => ignore$1(locks, callback),
        extra: (undoManager, index, callback1, callback2) => extra$1(editor, undoManager, index, callback1, callback2)
      },
      formatter: {
        match: (name, vars, node, similar) => match$2(editor, name, vars, node, similar),
        matchAll: (names, vars) => matchAll(editor, names, vars),
        matchNode: (node, name, vars, similar) => matchNode(editor, node, name, vars, similar),
        canApply: name => canApply(editor, name),
        closest: names => closest(editor, names),
        apply: (name, vars, node) => applyFormat$1(editor, name, vars, node),
        remove: (name, vars, node, similar) => remove$2(editor, name, vars, node, similar),
        toggle: (name, vars, node) => toggle(editor, name, vars, node),
        formatChanged: (registeredFormatListeners, formats, callback, similar, vars) => formatChangedInternal(editor, registeredFormatListeners, formats, callback, similar, vars)
      },
      editor: {
        getContent: args => getContentInternal(editor, args),
        setContent: (content, args) => setContentInternal(editor, content, args),
        insertContent: (value, details) => insertHtmlAtCaret(editor, value, details),
        addVisual: elm => addVisualInternal(editor, elm)
      },
      selection: { getContent: (format, args) => getSelectedContentInternal(editor, format, args) },
      autocompleter: {
        addDecoration: range => create$9(editor, range),
        removeDecoration: () => remove$3(editor, SugarElement.fromDom(editor.getBody()))
      },
      raw: { getModel: () => Optional.none() }
    });
    const makeRtcAdaptor = rtcEditor => {
      const defaultVars = vars => isObject(vars) ? vars : {};
      const {init, undoManager, formatter, editor, selection, autocompleter, raw} = rtcEditor;
      return {
        init: { bindEvents: init.bindEvents },
        undoManager: {
          beforeChange: undoManager.beforeChange,
          add: undoManager.add,
          undo: undoManager.undo,
          redo: undoManager.redo,
          clear: undoManager.clear,
          reset: undoManager.reset,
          hasUndo: undoManager.hasUndo,
          hasRedo: undoManager.hasRedo,
          transact: (_undoManager, _locks, fn) => undoManager.transact(fn),
          ignore: (_locks, callback) => undoManager.ignore(callback),
          extra: (_undoManager, _index, callback1, callback2) => undoManager.extra(callback1, callback2)
        },
        formatter: {
          match: (name, vars, _node, similar) => formatter.match(name, defaultVars(vars), similar),
          matchAll: formatter.matchAll,
          matchNode: formatter.matchNode,
          canApply: name => formatter.canApply(name),
          closest: names => formatter.closest(names),
          apply: (name, vars, _node) => formatter.apply(name, defaultVars(vars)),
          remove: (name, vars, _node, _similar) => formatter.remove(name, defaultVars(vars)),
          toggle: (name, vars, _node) => formatter.toggle(name, defaultVars(vars)),
          formatChanged: (_rfl, formats, callback, similar, vars) => formatter.formatChanged(formats, callback, similar, vars)
        },
        editor: {
          getContent: args => editor.getContent(args),
          setContent: (content, args) => {
            return {
              content: editor.setContent(content, args),
              html: ''
            };
          },
          insertContent: (content, _details) => {
            editor.insertContent(content);
            return '';
          },
          addVisual: editor.addVisual
        },
        selection: { getContent: (_format, args) => selection.getContent(args) },
        autocompleter: {
          addDecoration: autocompleter.addDecoration,
          removeDecoration: autocompleter.removeDecoration
        },
        raw: { getModel: () => Optional.some(raw.getRawModel()) }
      };
    };
    const makeNoopAdaptor = () => {
      const nul = constant(null);
      const empty = constant('');
      return {
        init: { bindEvents: noop },
        undoManager: {
          beforeChange: noop,
          add: nul,
          undo: nul,
          redo: nul,
          clear: noop,
          reset: noop,
          hasUndo: never,
          hasRedo: never,
          transact: nul,
          ignore: noop,
          extra: noop
        },
        formatter: {
          match: never,
          matchAll: constant([]),
          matchNode: constant(undefined),
          canApply: never,
          closest: empty,
          apply: noop,
          remove: noop,
          toggle: noop,
          formatChanged: constant({ unbind: noop })
        },
        editor: {
          getContent: empty,
          setContent: constant({
            content: '',
            html: ''
          }),
          insertContent: constant(''),
          addVisual: noop
        },
        selection: { getContent: empty },
        autocompleter: {
          addDecoration: noop,
          removeDecoration: noop
        },
        raw: { getModel: constant(Optional.none()) }
      };
    };
    const isRtc = editor => has$2(editor.plugins, 'rtc');
    const getRtcSetup = editor => get$a(editor.plugins, 'rtc').bind(rtcPlugin => Optional.from(rtcPlugin.setup));
    const setup$s = editor => {
      const editorCast = editor;
      return getRtcSetup(editor).fold(() => {
        editorCast.rtcInstance = makePlainAdaptor(editor);
        return Optional.none();
      }, setup => {
        editorCast.rtcInstance = makeNoopAdaptor();
        return Optional.some(() => setup().then(rtcEditor => {
          editorCast.rtcInstance = makeRtcAdaptor(rtcEditor);
          return rtcEditor.rtc.isRemote;
        }));
      });
    };
    const getRtcInstanceWithFallback = editor => editor.rtcInstance ? editor.rtcInstance : makePlainAdaptor(editor);
    const getRtcInstanceWithError = editor => {
      const rtcInstance = editor.rtcInstance;
      if (!rtcInstance) {
        throw new Error('Failed to get RTC instance not yet initialized.');
      } else {
        return rtcInstance;
      }
    };
    const beforeChange = (editor, locks, beforeBookmark) => {
      getRtcInstanceWithError(editor).undoManager.beforeChange(locks, beforeBookmark);
    };
    const addUndoLevel = (editor, undoManager, index, locks, beforeBookmark, level, event) => getRtcInstanceWithError(editor).undoManager.add(undoManager, index, locks, beforeBookmark, level, event);
    const undo = (editor, undoManager, locks, index) => getRtcInstanceWithError(editor).undoManager.undo(undoManager, locks, index);
    const redo = (editor, index, data) => getRtcInstanceWithError(editor).undoManager.redo(index, data);
    const clear = (editor, undoManager, index) => {
      getRtcInstanceWithError(editor).undoManager.clear(undoManager, index);
    };
    const reset = (editor, undoManager) => {
      getRtcInstanceWithError(editor).undoManager.reset(undoManager);
    };
    const hasUndo = (editor, undoManager, index) => getRtcInstanceWithError(editor).undoManager.hasUndo(undoManager, index);
    const hasRedo = (editor, undoManager, index) => getRtcInstanceWithError(editor).undoManager.hasRedo(undoManager, index);
    const transact = (editor, undoManager, locks, callback) => getRtcInstanceWithError(editor).undoManager.transact(undoManager, locks, callback);
    const ignore = (editor, locks, callback) => {
      getRtcInstanceWithError(editor).undoManager.ignore(locks, callback);
    };
    const extra = (editor, undoManager, index, callback1, callback2) => {
      getRtcInstanceWithError(editor).undoManager.extra(undoManager, index, callback1, callback2);
    };
    const matchFormat = (editor, name, vars, node, similar) => getRtcInstanceWithError(editor).formatter.match(name, vars, node, similar);
    const matchAllFormats = (editor, names, vars) => getRtcInstanceWithError(editor).formatter.matchAll(names, vars);
    const matchNodeFormat = (editor, node, name, vars, similar) => getRtcInstanceWithError(editor).formatter.matchNode(node, name, vars, similar);
    const canApplyFormat = (editor, name) => getRtcInstanceWithError(editor).formatter.canApply(name);
    const closestFormat = (editor, names) => getRtcInstanceWithError(editor).formatter.closest(names);
    const applyFormat = (editor, name, vars, node) => {
      getRtcInstanceWithError(editor).formatter.apply(name, vars, node);
    };
    const removeFormat = (editor, name, vars, node, similar) => {
      getRtcInstanceWithError(editor).formatter.remove(name, vars, node, similar);
    };
    const toggleFormat = (editor, name, vars, node) => {
      getRtcInstanceWithError(editor).formatter.toggle(name, vars, node);
    };
    const formatChanged = (editor, registeredFormatListeners, formats, callback, similar, vars) => getRtcInstanceWithError(editor).formatter.formatChanged(registeredFormatListeners, formats, callback, similar, vars);
    const getContent$2 = (editor, args) => getRtcInstanceWithFallback(editor).editor.getContent(args);
    const setContent$2 = (editor, content, args) => getRtcInstanceWithFallback(editor).editor.setContent(content, args);
    const insertContent$1 = (editor, value, details) => getRtcInstanceWithFallback(editor).editor.insertContent(value, details);
    const getSelectedContent = (editor, format, args) => getRtcInstanceWithError(editor).selection.getContent(format, args);
    const addVisual$1 = (editor, elm) => getRtcInstanceWithError(editor).editor.addVisual(elm);
    const bindEvents = editor => getRtcInstanceWithError(editor).init.bindEvents();
    const addAutocompleterDecoration = (editor, range) => getRtcInstanceWithError(editor).autocompleter.addDecoration(range);
    const removeAutocompleterDecoration = editor => getRtcInstanceWithError(editor).autocompleter.removeDecoration();

    const getContent$1 = (editor, args = {}) => {
      const format = args.format ? args.format : 'html';
      return getSelectedContent(editor, format, args);
    };

    const removeEmpty = text => {
      if (text.dom.length === 0) {
        remove$6(text);
        return Optional.none();
      } else {
        return Optional.some(text);
      }
    };
    const walkPastBookmark = (node, start) => node.filter(elm => BookmarkManager.isBookmarkNode(elm.dom)).bind(start ? nextSibling : prevSibling);
    const merge$1 = (outer, inner, rng, start) => {
      const outerElm = outer.dom;
      const innerElm = inner.dom;
      const oldLength = start ? outerElm.length : innerElm.length;
      if (start) {
        mergeTextNodes(outerElm, innerElm, false, !start);
        rng.setStart(innerElm, oldLength);
      } else {
        mergeTextNodes(innerElm, outerElm, false, !start);
        rng.setEnd(innerElm, oldLength);
      }
    };
    const normalizeTextIfRequired = (inner, start) => {
      parent(inner).each(root => {
        const text = inner.dom;
        if (start && needsToBeNbspLeft(root, CaretPosition(text, 0))) {
          normalizeWhitespaceAfter(text, 0);
        } else if (!start && needsToBeNbspRight(root, CaretPosition(text, text.length))) {
          normalizeWhitespaceBefore(text, text.length);
        }
      });
    };
    const mergeAndNormalizeText = (outerNode, innerNode, rng, start) => {
      outerNode.bind(outer => {
        const normalizer = start ? normalizeWhitespaceBefore : normalizeWhitespaceAfter;
        normalizer(outer.dom, start ? outer.dom.length : 0);
        return innerNode.filter(isText$b).map(inner => merge$1(outer, inner, rng, start));
      }).orThunk(() => {
        const innerTextNode = walkPastBookmark(innerNode, start).or(innerNode).filter(isText$b);
        return innerTextNode.map(inner => normalizeTextIfRequired(inner, start));
      });
    };
    const rngSetContent = (rng, fragment) => {
      const firstChild = Optional.from(fragment.firstChild).map(SugarElement.fromDom);
      const lastChild = Optional.from(fragment.lastChild).map(SugarElement.fromDom);
      rng.deleteContents();
      rng.insertNode(fragment);
      const prevText = firstChild.bind(prevSibling).filter(isText$b).bind(removeEmpty);
      const nextText = lastChild.bind(nextSibling).filter(isText$b).bind(removeEmpty);
      mergeAndNormalizeText(prevText, firstChild, rng, true);
      mergeAndNormalizeText(nextText, lastChild, rng, false);
      rng.collapse(false);
    };
    const setupArgs$2 = (args, content) => ({
      format: 'html',
      ...args,
      set: true,
      selection: true,
      content
    });
    const cleanContent = (editor, args) => {
      if (args.format !== 'raw') {
        const rng = editor.selection.getRng();
        const contextBlock = editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock);
        const contextArgs = contextBlock ? { context: contextBlock.nodeName.toLowerCase() } : {};
        const node = editor.parser.parse(args.content, {
          forced_root_block: false,
          ...contextArgs,
          ...args
        });
        return HtmlSerializer({ validate: false }, editor.schema).serialize(node);
      } else {
        return args.content;
      }
    };
    const setContent$1 = (editor, content, args = {}) => {
      const defaultedArgs = setupArgs$2(args, content);
      preProcessSetContent(editor, defaultedArgs).each(updatedArgs => {
        const cleanedContent = cleanContent(editor, updatedArgs);
        const rng = editor.selection.getRng();
        rngSetContent(rng, rng.createContextualFragment(cleanedContent));
        editor.selection.setRng(rng);
        scrollRangeIntoView(editor, rng);
        postProcessSetContent(editor, cleanedContent, updatedArgs);
      });
    };

    const deleteFromCallbackMap = (callbackMap, selector, callback) => {
      if (has$2(callbackMap, selector)) {
        const newCallbacks = filter$5(callbackMap[selector], cb => cb !== callback);
        if (newCallbacks.length === 0) {
          delete callbackMap[selector];
        } else {
          callbackMap[selector] = newCallbacks;
        }
      }
    };
    var SelectorChanged = (dom, editor) => {
      let selectorChangedData;
      let currentSelectors;
      const findMatchingNode = (selector, nodes) => find$2(nodes, node => dom.is(node, selector));
      const getParents = elem => dom.getParents(elem, undefined, dom.getRoot());
      const setup = () => {
        selectorChangedData = {};
        currentSelectors = {};
        editor.on('NodeChange', e => {
          const node = e.element;
          const parents = getParents(node);
          const matchedSelectors = {};
          each$d(selectorChangedData, (callbacks, selector) => {
            findMatchingNode(selector, parents).each(node => {
              if (!currentSelectors[selector]) {
                each$e(callbacks, callback => {
                  callback(true, {
                    node,
                    selector,
                    parents
                  });
                });
                currentSelectors[selector] = callbacks;
              }
              matchedSelectors[selector] = callbacks;
            });
          });
          each$d(currentSelectors, (callbacks, selector) => {
            if (!matchedSelectors[selector]) {
              delete currentSelectors[selector];
              each$e(callbacks, callback => {
                callback(false, {
                  node,
                  selector,
                  parents
                });
              });
            }
          });
        });
      };
      return {
        selectorChangedWithUnbind: (selector, callback) => {
          if (!selectorChangedData) {
            setup();
          }
          if (!selectorChangedData[selector]) {
            selectorChangedData[selector] = [];
          }
          selectorChangedData[selector].push(callback);
          findMatchingNode(selector, getParents(editor.selection.getStart())).each(() => {
            currentSelectors[selector] = selectorChangedData[selector];
          });
          return {
            unbind: () => {
              deleteFromCallbackMap(selectorChangedData, selector, callback);
              deleteFromCallbackMap(currentSelectors, selector, callback);
            }
          };
        }
      };
    };

    const isAttachedToDom = node => {
      return !!(node && node.ownerDocument) && contains(SugarElement.fromDom(node.ownerDocument), SugarElement.fromDom(node));
    };
    const isValidRange = rng => {
      if (!rng) {
        return false;
      } else {
        return isAttachedToDom(rng.startContainer) && isAttachedToDom(rng.endContainer);
      }
    };
    const EditorSelection = (dom, win, serializer, editor) => {
      let selectedRange;
      let explicitRange;
      const {selectorChangedWithUnbind} = SelectorChanged(dom, editor);
      const setCursorLocation = (node, offset) => {
        const rng = dom.createRng();
        if (isNonNullable(node) && isNonNullable(offset)) {
          rng.setStart(node, offset);
          rng.setEnd(node, offset);
          setRng(rng);
          collapse(false);
        } else {
          moveEndPoint(dom, rng, editor.getBody(), true);
          setRng(rng);
        }
      };
      const getContent = args => getContent$1(editor, args);
      const setContent = (content, args) => setContent$1(editor, content, args);
      const getStart$1 = real => getStart(editor.getBody(), getRng$1(), real);
      const getEnd = real => getEnd$1(editor.getBody(), getRng$1(), real);
      const getBookmark = (type, normalized) => bookmarkManager.getBookmark(type, normalized);
      const moveToBookmark = bookmark => bookmarkManager.moveToBookmark(bookmark);
      const select$1 = (node, content) => {
        select(dom, node, content).each(setRng);
        return node;
      };
      const isCollapsed = () => {
        const rng = getRng$1(), sel = getSel();
        if (!rng || rng.item) {
          return false;
        }
        if (rng.compareEndPoints) {
          return rng.compareEndPoints('StartToEnd', rng) === 0;
        }
        return !sel || rng.collapsed;
      };
      const isEditable = () => {
        const rng = getRng$1();
        const fakeSelectedElements = editor.getBody().querySelectorAll('[data-mce-selected="1"]');
        if (fakeSelectedElements.length > 0) {
          return forall(fakeSelectedElements, el => dom.isEditable(el.parentElement));
        } else if (rng.startContainer === rng.endContainer) {
          return dom.isEditable(rng.startContainer);
        } else {
          return dom.isEditable(rng.startContainer) && dom.isEditable(rng.endContainer);
        }
      };
      const collapse = toStart => {
        const rng = getRng$1();
        rng.collapse(!!toStart);
        setRng(rng);
      };
      const getSel = () => win.getSelection ? win.getSelection() : win.document.selection;
      const getRng$1 = () => {
        let rng;
        const tryCompareBoundaryPoints = (how, sourceRange, destinationRange) => {
          try {
            return sourceRange.compareBoundaryPoints(how, destinationRange);
          } catch (ex) {
            return -1;
          }
        };
        const doc = win.document;
        if (isNonNullable(editor.bookmark) && !hasFocus(editor)) {
          const bookmark = getRng(editor);
          if (bookmark.isSome()) {
            return bookmark.map(r => processRanges(editor, [r])[0]).getOr(doc.createRange());
          }
        }
        try {
          const selection = getSel();
          if (selection && !isRestrictedNode(selection.anchorNode)) {
            if (selection.rangeCount > 0) {
              rng = selection.getRangeAt(0);
            } else {
              rng = doc.createRange();
            }
            rng = processRanges(editor, [rng])[0];
          }
        } catch (ex) {
        }
        if (!rng) {
          rng = doc.createRange();
        }
        if (isDocument$1(rng.startContainer) && rng.collapsed) {
          const elm = dom.getRoot();
          rng.setStart(elm, 0);
          rng.setEnd(elm, 0);
        }
        if (selectedRange && explicitRange) {
          if (tryCompareBoundaryPoints(rng.START_TO_START, rng, selectedRange) === 0 && tryCompareBoundaryPoints(rng.END_TO_END, rng, selectedRange) === 0) {
            rng = explicitRange;
          } else {
            selectedRange = null;
            explicitRange = null;
          }
        }
        return rng;
      };
      const setRng = (rng, forward) => {
        if (!isValidRange(rng)) {
          return;
        }
        const sel = getSel();
        const evt = editor.dispatch('SetSelectionRange', {
          range: rng,
          forward
        });
        rng = evt.range;
        if (sel) {
          explicitRange = rng;
          try {
            sel.removeAllRanges();
            sel.addRange(rng);
          } catch (ex) {
          }
          if (forward === false && sel.extend) {
            sel.collapse(rng.endContainer, rng.endOffset);
            sel.extend(rng.startContainer, rng.startOffset);
          }
          selectedRange = sel.rangeCount > 0 ? sel.getRangeAt(0) : null;
        }
        if (!rng.collapsed && rng.startContainer === rng.endContainer && (sel === null || sel === void 0 ? void 0 : sel.setBaseAndExtent)) {
          if (rng.endOffset - rng.startOffset < 2) {
            if (rng.startContainer.hasChildNodes()) {
              const node = rng.startContainer.childNodes[rng.startOffset];
              if (node && node.nodeName === 'IMG') {
                sel.setBaseAndExtent(rng.startContainer, rng.startOffset, rng.endContainer, rng.endOffset);
                if (sel.anchorNode !== rng.startContainer || sel.focusNode !== rng.endContainer) {
                  sel.setBaseAndExtent(node, 0, node, 1);
                }
              }
            }
          }
        }
        editor.dispatch('AfterSetSelectionRange', {
          range: rng,
          forward
        });
      };
      const setNode = elm => {
        setContent(dom.getOuterHTML(elm));
        return elm;
      };
      const getNode$1 = () => getNode(editor.getBody(), getRng$1());
      const getSelectedBlocks$1 = (startElm, endElm) => getSelectedBlocks(dom, getRng$1(), startElm, endElm);
      const isForward = () => {
        const sel = getSel();
        const anchorNode = sel === null || sel === void 0 ? void 0 : sel.anchorNode;
        const focusNode = sel === null || sel === void 0 ? void 0 : sel.focusNode;
        if (!sel || !anchorNode || !focusNode || isRestrictedNode(anchorNode) || isRestrictedNode(focusNode)) {
          return true;
        }
        const anchorRange = dom.createRng();
        const focusRange = dom.createRng();
        try {
          anchorRange.setStart(anchorNode, sel.anchorOffset);
          anchorRange.collapse(true);
          focusRange.setStart(focusNode, sel.focusOffset);
          focusRange.collapse(true);
        } catch (e) {
          return true;
        }
        return anchorRange.compareBoundaryPoints(anchorRange.START_TO_START, focusRange) <= 0;
      };
      const normalize = () => {
        const rng = getRng$1();
        const sel = getSel();
        if (!hasMultipleRanges(sel) && hasAnyRanges(editor)) {
          const normRng = normalize$2(dom, rng);
          normRng.each(normRng => {
            setRng(normRng, isForward());
          });
          return normRng.getOr(rng);
        }
        return rng;
      };
      const selectorChanged = (selector, callback) => {
        selectorChangedWithUnbind(selector, callback);
        return exports;
      };
      const getScrollContainer = () => {
        let scrollContainer;
        let node = dom.getRoot();
        while (node && node.nodeName !== 'BODY') {
          if (node.scrollHeight > node.clientHeight) {
            scrollContainer = node;
            break;
          }
          node = node.parentNode;
        }
        return scrollContainer;
      };
      const scrollIntoView = (elm, alignToTop) => {
        if (isNonNullable(elm)) {
          scrollElementIntoView(editor, elm, alignToTop);
        } else {
          scrollRangeIntoView(editor, getRng$1(), alignToTop);
        }
      };
      const placeCaretAt = (clientX, clientY) => setRng(fromPoint(clientX, clientY, editor.getDoc()));
      const getBoundingClientRect = () => {
        const rng = getRng$1();
        return rng.collapsed ? CaretPosition.fromRangeStart(rng).getClientRects()[0] : rng.getBoundingClientRect();
      };
      const destroy = () => {
        win = selectedRange = explicitRange = null;
        controlSelection.destroy();
      };
      const expand = (options = { type: 'word' }) => setRng(RangeUtils(dom).expand(getRng$1(), options));
      const exports = {
        dom,
        win,
        serializer,
        editor,
        expand,
        collapse,
        setCursorLocation,
        getContent,
        setContent,
        getBookmark,
        moveToBookmark,
        select: select$1,
        isCollapsed,
        isEditable,
        isForward,
        setNode,
        getNode: getNode$1,
        getSel,
        setRng,
        getRng: getRng$1,
        getStart: getStart$1,
        getEnd,
        getSelectedBlocks: getSelectedBlocks$1,
        normalize,
        selectorChanged,
        selectorChangedWithUnbind,
        getScrollContainer,
        scrollIntoView,
        placeCaretAt,
        getBoundingClientRect,
        destroy
      };
      const bookmarkManager = BookmarkManager(exports);
      const controlSelection = ControlSelection(exports, editor);
      exports.bookmarkManager = bookmarkManager;
      exports.controlSelection = controlSelection;
      return exports;
    };

    const register$3 = (htmlParser, settings, dom) => {
      htmlParser.addAttributeFilter('data-mce-tabindex', (nodes, name) => {
        let i = nodes.length;
        while (i--) {
          const node = nodes[i];
          node.attr('tabindex', node.attr('data-mce-tabindex'));
          node.attr(name, null);
        }
      });
      htmlParser.addAttributeFilter('src,href,style', (nodes, name) => {
        const internalName = 'data-mce-' + name;
        const urlConverter = settings.url_converter;
        const urlConverterScope = settings.url_converter_scope;
        let i = nodes.length;
        while (i--) {
          const node = nodes[i];
          let value = node.attr(internalName);
          if (value !== undefined) {
            node.attr(name, value.length > 0 ? value : null);
            node.attr(internalName, null);
          } else {
            value = node.attr(name);
            if (name === 'style') {
              value = dom.serializeStyle(dom.parseStyle(value), node.name);
            } else if (urlConverter) {
              value = urlConverter.call(urlConverterScope, value, name, node.name);
            }
            node.attr(name, value.length > 0 ? value : null);
          }
        }
      });
      htmlParser.addAttributeFilter('class', nodes => {
        let i = nodes.length;
        while (i--) {
          const node = nodes[i];
          let value = node.attr('class');
          if (value) {
            value = value.replace(/(?:^|\s)mce-item-\w+(?!\S)/g, '');
            node.attr('class', value.length > 0 ? value : null);
          }
        }
      });
      htmlParser.addAttributeFilter('data-mce-type', (nodes, name, args) => {
        let i = nodes.length;
        while (i--) {
          const node = nodes[i];
          if (node.attr('data-mce-type') === 'bookmark' && !args.cleanup) {
            const hasChildren = Optional.from(node.firstChild).exists(firstChild => {
              var _a;
              return !isZwsp((_a = firstChild.value) !== null && _a !== void 0 ? _a : '');
            });
            if (hasChildren) {
              node.unwrap();
            } else {
              node.remove();
            }
          }
        }
      });
      htmlParser.addNodeFilter('noscript', nodes => {
        var _a;
        let i = nodes.length;
        while (i--) {
          const node = nodes[i].firstChild;
          if (node) {
            node.value = Entities.decode((_a = node.value) !== null && _a !== void 0 ? _a : '');
          }
        }
      });
      htmlParser.addNodeFilter('script,style', (nodes, name) => {
        var _a;
        const trim = value => {
          return value.replace(/(<!--\[CDATA\[|\]\]-->)/g, '\n').replace(/^[\r\n]*|[\r\n]*$/g, '').replace(/^\s*((<!--)?(\s*\/\/)?\s*<!\[CDATA\[|(<!--\s*)?\/\*\s*<!\[CDATA\[\s*\*\/|(\/\/)?\s*<!--|\/\*\s*<!--\s*\*\/)\s*[\r\n]*/gi, '').replace(/\s*(\/\*\s*\]\]>\s*\*\/(-->)?|\s*\/\/\s*\]\]>(-->)?|\/\/\s*(-->)?|\]\]>|\/\*\s*-->\s*\*\/|\s*-->\s*)\s*$/g, '');
        };
        let i = nodes.length;
        while (i--) {
          const node = nodes[i];
          const firstChild = node.firstChild;
          const value = (_a = firstChild === null || firstChild === void 0 ? void 0 : firstChild.value) !== null && _a !== void 0 ? _a : '';
          if (name === 'script') {
            const type = node.attr('type');
            if (type) {
              node.attr('type', type === 'mce-no/type' ? null : type.replace(/^mce\-/, ''));
            }
            if (settings.element_format === 'xhtml' && firstChild && value.length > 0) {
              firstChild.value = '// <![CDATA[\n' + trim(value) + '\n// ]]>';
            }
          } else {
            if (settings.element_format === 'xhtml' && firstChild && value.length > 0) {
              firstChild.value = '<!--\n' + trim(value) + '\n-->';
            }
          }
        }
      });
      htmlParser.addNodeFilter('#comment', nodes => {
        let i = nodes.length;
        while (i--) {
          const node = nodes[i];
          const value = node.value;
          if (settings.preserve_cdata && (value === null || value === void 0 ? void 0 : value.indexOf('[CDATA[')) === 0) {
            node.name = '#cdata';
            node.type = 4;
            node.value = dom.decode(value.replace(/^\[CDATA\[|\]\]$/g, ''));
          } else if ((value === null || value === void 0 ? void 0 : value.indexOf('mce:protected ')) === 0) {
            node.name = '#text';
            node.type = 3;
            node.raw = true;
            node.value = unescape(value).substr(14);
          }
        }
      });
      htmlParser.addNodeFilter('xml:namespace,input', (nodes, name) => {
        let i = nodes.length;
        while (i--) {
          const node = nodes[i];
          if (node.type === 7) {
            node.remove();
          } else if (node.type === 1) {
            if (name === 'input' && !node.attr('type')) {
              node.attr('type', 'text');
            }
          }
        }
      });
      htmlParser.addAttributeFilter('data-mce-type', nodes => {
        each$e(nodes, node => {
          if (node.attr('data-mce-type') === 'format-caret') {
            if (node.isEmpty(htmlParser.schema.getNonEmptyElements())) {
              node.remove();
            } else {
              node.unwrap();
            }
          }
        });
      });
      htmlParser.addAttributeFilter('data-mce-src,data-mce-href,data-mce-style,' + 'data-mce-selected,data-mce-expando,data-mce-block,' + 'data-mce-type,data-mce-resize,data-mce-placeholder', (nodes, name) => {
        let i = nodes.length;
        while (i--) {
          nodes[i].attr(name, null);
        }
      });
    };
    const trimTrailingBr = rootNode => {
      const isBr = node => {
        return (node === null || node === void 0 ? void 0 : node.name) === 'br';
      };
      const brNode1 = rootNode.lastChild;
      if (isBr(brNode1)) {
        const brNode2 = brNode1.prev;
        if (isBr(brNode2)) {
          brNode1.remove();
          brNode2.remove();
        }
      }
    };

    const preProcess$1 = (editor, node, args) => {
      let oldDoc;
      const dom = editor.dom;
      let clonedNode = node.cloneNode(true);
      const impl = document.implementation;
      if (impl.createHTMLDocument) {
        const doc = impl.createHTMLDocument('');
        Tools.each(clonedNode.nodeName === 'BODY' ? clonedNode.childNodes : [clonedNode], node => {
          doc.body.appendChild(doc.importNode(node, true));
        });
        if (clonedNode.nodeName !== 'BODY') {
          clonedNode = doc.body.firstChild;
        } else {
          clonedNode = doc.body;
        }
        oldDoc = dom.doc;
        dom.doc = doc;
      }
      firePreProcess(editor, {
        ...args,
        node: clonedNode
      });
      if (oldDoc) {
        dom.doc = oldDoc;
      }
      return clonedNode;
    };
    const shouldFireEvent = (editor, args) => {
      return isNonNullable(editor) && editor.hasEventListeners('PreProcess') && !args.no_events;
    };
    const process$1 = (editor, node, args) => {
      return shouldFireEvent(editor, args) ? preProcess$1(editor, node, args) : node;
    };

    const addTempAttr = (htmlParser, tempAttrs, name) => {
      if (Tools.inArray(tempAttrs, name) === -1) {
        htmlParser.addAttributeFilter(name, (nodes, name) => {
          let i = nodes.length;
          while (i--) {
            nodes[i].attr(name, null);
          }
        });
        tempAttrs.push(name);
      }
    };
    const postProcess = (editor, args, content) => {
      if (!args.no_events && editor) {
        const outArgs = firePostProcess(editor, {
          ...args,
          content
        });
        return outArgs.content;
      } else {
        return content;
      }
    };
    const getHtmlFromNode = (dom, node, args) => {
      const html = trim$1(args.getInner ? node.innerHTML : dom.getOuterHTML(node));
      return args.selection || isWsPreserveElement(SugarElement.fromDom(node)) ? html : Tools.trim(html);
    };
    const parseHtml = (htmlParser, html, args) => {
      const parserArgs = args.selection ? {
        forced_root_block: false,
        ...args
      } : args;
      const rootNode = htmlParser.parse(html, parserArgs);
      trimTrailingBr(rootNode);
      return rootNode;
    };
    const serializeNode = (settings, schema, node) => {
      const htmlSerializer = HtmlSerializer(settings, schema);
      return htmlSerializer.serialize(node);
    };
    const toHtml = (editor, settings, schema, rootNode, args) => {
      const content = serializeNode(settings, schema, rootNode);
      return postProcess(editor, args, content);
    };
    const DomSerializerImpl = (settings, editor) => {
      const tempAttrs = ['data-mce-selected'];
      const dom = editor && editor.dom ? editor.dom : DOMUtils.DOM;
      const schema = editor && editor.schema ? editor.schema : Schema(settings);
      settings.entity_encoding = settings.entity_encoding || 'named';
      settings.remove_trailing_brs = 'remove_trailing_brs' in settings ? settings.remove_trailing_brs : true;
      const htmlParser = DomParser(settings, schema);
      register$3(htmlParser, settings, dom);
      const serialize = (node, parserArgs = {}) => {
        const args = {
          format: 'html',
          ...parserArgs
        };
        const targetNode = process$1(editor, node, args);
        const html = getHtmlFromNode(dom, targetNode, args);
        const rootNode = parseHtml(htmlParser, html, args);
        return args.format === 'tree' ? rootNode : toHtml(editor, settings, schema, rootNode, args);
      };
      return {
        schema,
        addNodeFilter: htmlParser.addNodeFilter,
        addAttributeFilter: htmlParser.addAttributeFilter,
        serialize: serialize,
        addRules: schema.addValidElements,
        setRules: schema.setValidElements,
        addTempAttr: curry(addTempAttr, htmlParser, tempAttrs),
        getTempAttrs: constant(tempAttrs),
        getNodeFilters: htmlParser.getNodeFilters,
        getAttributeFilters: htmlParser.getAttributeFilters,
        removeNodeFilter: htmlParser.removeNodeFilter,
        removeAttributeFilter: htmlParser.removeAttributeFilter
      };
    };

    const DomSerializer = (settings, editor) => {
      const domSerializer = DomSerializerImpl(settings, editor);
      return {
        schema: domSerializer.schema,
        addNodeFilter: domSerializer.addNodeFilter,
        addAttributeFilter: domSerializer.addAttributeFilter,
        serialize: domSerializer.serialize,
        addRules: domSerializer.addRules,
        setRules: domSerializer.setRules,
        addTempAttr: domSerializer.addTempAttr,
        getTempAttrs: domSerializer.getTempAttrs,
        getNodeFilters: domSerializer.getNodeFilters,
        getAttributeFilters: domSerializer.getAttributeFilters,
        removeNodeFilter: domSerializer.removeNodeFilter,
        removeAttributeFilter: domSerializer.removeAttributeFilter
      };
    };

    const defaultFormat$1 = 'html';
    const setupArgs$1 = (args, format) => ({
      ...args,
      format,
      get: true,
      getInner: true
    });
    const getContent = (editor, args = {}) => {
      const format = args.format ? args.format : defaultFormat$1;
      const defaultedArgs = setupArgs$1(args, format);
      return preProcessGetContent(editor, defaultedArgs).fold(identity, updatedArgs => {
        const content = getContent$2(editor, updatedArgs);
        return postProcessGetContent(editor, content, updatedArgs);
      });
    };

    const defaultFormat = 'html';
    const setupArgs = (args, content) => ({
      format: defaultFormat,
      ...args,
      set: true,
      content
    });
    const setContent = (editor, content, args = {}) => {
      const defaultedArgs = setupArgs(args, content);
      return preProcessSetContent(editor, defaultedArgs).map(updatedArgs => {
        const result = setContent$2(editor, updatedArgs.content, updatedArgs);
        postProcessSetContent(editor, result.html, updatedArgs);
        return result.content;
      }).getOr(content);
    };

    const removedOptions = ('autoresize_on_init,content_editable_state,padd_empty_with_br,block_elements,' + 'boolean_attributes,editor_deselector,editor_selector,elements,file_browser_callback_types,filepicker_validator_handler,' + 'force_hex_style_colors,force_p_newlines,gecko_spellcheck,images_dataimg_filter,media_scripts,mode,move_caret_before_on_enter_elements,' + 'non_empty_elements,self_closing_elements,short_ended_elements,special,spellchecker_select_languages,spellchecker_whitelist,' + 'tab_focus,tabfocus_elements,table_responsive_width,text_block_elements,text_inline_elements,toolbar_drawer,types,validate,whitespace_elements,' + 'paste_enable_default_filters,paste_filter_drop,paste_word_valid_elements,paste_retain_style_properties,paste_convert_word_fake_lists').split(',');
    const deprecatedOptions = 'template_cdate_classes,template_mdate_classes,template_selected_content_classes,template_preview_replace_values,template_replace_values,templates,template_cdate_format,template_mdate_format'.split(',');
    const removedPlugins = 'bbcode,colorpicker,contextmenu,fullpage,legacyoutput,spellchecker,textcolor'.split(',');
    const deprecatedPlugins = [{
        name: 'template',
        replacedWith: 'Advanced Template'
      }];
    const getMatchingOptions = (options, searchingFor) => {
      const settingNames = filter$5(searchingFor, setting => has$2(options, setting));
      return sort(settingNames);
    };
    const getRemovedOptions = options => {
      const settingNames = getMatchingOptions(options, removedOptions);
      const forcedRootBlock = options.forced_root_block;
      if (forcedRootBlock === false || forcedRootBlock === '') {
        settingNames.push('forced_root_block (false only)');
      }
      return sort(settingNames);
    };
    const getDeprecatedOptions = options => getMatchingOptions(options, deprecatedOptions);
    const getMatchingPlugins = (options, searchingFor) => {
      const plugins = Tools.makeMap(options.plugins, ' ');
      const hasPlugin = plugin => has$2(plugins, plugin);
      const pluginNames = filter$5(searchingFor, hasPlugin);
      return sort(pluginNames);
    };
    const getRemovedPlugins = options => getMatchingPlugins(options, removedPlugins);
    const getDeprecatedPlugins = options => getMatchingPlugins(options, deprecatedPlugins.map(entry => entry.name));
    const logRemovedWarnings = (rawOptions, normalizedOptions) => {
      const removedOptions = getRemovedOptions(rawOptions);
      const removedPlugins = getRemovedPlugins(normalizedOptions);
      const hasRemovedPlugins = removedPlugins.length > 0;
      const hasRemovedOptions = removedOptions.length > 0;
      const isLegacyMobileTheme = normalizedOptions.theme === 'mobile';
      if (hasRemovedPlugins || hasRemovedOptions || isLegacyMobileTheme) {
        const listJoiner = '\n- ';
        const themesMessage = isLegacyMobileTheme ? `\n\nThemes:${ listJoiner }mobile` : '';
        const pluginsMessage = hasRemovedPlugins ? `\n\nPlugins:${ listJoiner }${ removedPlugins.join(listJoiner) }` : '';
        const optionsMessage = hasRemovedOptions ? `\n\nOptions:${ listJoiner }${ removedOptions.join(listJoiner) }` : '';
        console.warn('The following deprecated features are currently enabled and have been removed in TinyMCE 6.0. These features will no longer work and should be removed from the TinyMCE configuration. ' + 'See https://www.tiny.cloud/docs/tinymce/6/migration-from-5x/ for more information.' + themesMessage + pluginsMessage + optionsMessage);
      }
    };
    const getPluginDescription = name => find$2(deprecatedPlugins, entry => entry.name === name).fold(() => name, entry => `${ name }, replaced by ${ entry.replacedWith }`);
    const logDeprecatedWarnings = (rawOptions, normalizedOptions) => {
      const deprecatedOptions = getDeprecatedOptions(rawOptions);
      const deprecatedPlugins = getDeprecatedPlugins(normalizedOptions);
      const hasDeprecatedPlugins = deprecatedPlugins.length > 0;
      const hasDeprecatedOptions = deprecatedOptions.length > 0;
      if (hasDeprecatedPlugins || hasDeprecatedOptions) {
        const listJoiner = '\n- ';
        const pluginsMessage = hasDeprecatedPlugins ? `\n\nPlugins:${ listJoiner }${ deprecatedPlugins.map(getPluginDescription).join(listJoiner) }` : '';
        const optionsMessage = hasDeprecatedOptions ? `\n\nOptions:${ listJoiner }${ deprecatedOptions.join(listJoiner) }` : '';
        console.warn('The following deprecated features are currently enabled but will be removed soon.' + pluginsMessage + optionsMessage);
      }
    };
    const logWarnings = (rawOptions, normalizedOptions) => {
      logRemovedWarnings(rawOptions, normalizedOptions);
      logDeprecatedWarnings(rawOptions, normalizedOptions);
    };

    const DOM$8 = DOMUtils.DOM;
    const restoreOriginalStyles = editor => {
      DOM$8.setStyle(editor.id, 'display', editor.orgDisplay);
    };
    const safeDestroy = x => Optional.from(x).each(x => x.destroy());
    const clearDomReferences = editor => {
      const ed = editor;
      ed.contentAreaContainer = ed.formElement = ed.container = ed.editorContainer = null;
      ed.bodyElement = ed.contentDocument = ed.contentWindow = null;
      ed.iframeElement = ed.targetElm = null;
      const selection = editor.selection;
      if (selection) {
        const dom = selection.dom;
        ed.selection = selection.win = selection.dom = dom.doc = null;
      }
    };
    const restoreForm = editor => {
      const form = editor.formElement;
      if (form) {
        if (form._mceOldSubmit) {
          form.submit = form._mceOldSubmit;
          delete form._mceOldSubmit;
        }
        DOM$8.unbind(form, 'submit reset', editor.formEventDelegate);
      }
    };
    const remove$1 = editor => {
      if (!editor.removed) {
        const {_selectionOverrides, editorUpload} = editor;
        const body = editor.getBody();
        const element = editor.getElement();
        if (body) {
          editor.save({ is_removing: true });
        }
        editor.removed = true;
        editor.unbindAllNativeEvents();
        if (editor.hasHiddenInput && isNonNullable(element === null || element === void 0 ? void 0 : element.nextSibling)) {
          DOM$8.remove(element.nextSibling);
        }
        fireRemove(editor);
        editor.editorManager.remove(editor);
        if (!editor.inline && body) {
          restoreOriginalStyles(editor);
        }
        fireDetach(editor);
        DOM$8.remove(editor.getContainer());
        safeDestroy(_selectionOverrides);
        safeDestroy(editorUpload);
        editor.destroy();
      }
    };
    const destroy = (editor, automatic) => {
      const {selection, dom} = editor;
      if (editor.destroyed) {
        return;
      }
      if (!automatic && !editor.removed) {
        editor.remove();
        return;
      }
      if (!automatic) {
        editor.editorManager.off('beforeunload', editor._beforeUnload);
        if (editor.theme && editor.theme.destroy) {
          editor.theme.destroy();
        }
        safeDestroy(selection);
        safeDestroy(dom);
      }
      restoreForm(editor);
      clearDomReferences(editor);
      editor.destroyed = true;
    };

    const CreateIconManager = () => {
      const lookup = {};
      const add = (id, iconPack) => {
        lookup[id] = iconPack;
      };
      const get = id => {
        if (lookup[id]) {
          return lookup[id];
        } else {
          return { icons: {} };
        }
      };
      const has = id => has$2(lookup, id);
      return {
        add,
        get,
        has
      };
    };
    const IconManager = CreateIconManager();

    const ModelManager = AddOnManager.ModelManager;

    const getProp = (propName, elm) => {
      const rawElm = elm.dom;
      return rawElm[propName];
    };
    const getComputedSizeProp = (propName, elm) => parseInt(get$7(elm, propName), 10);
    const getClientWidth = curry(getProp, 'clientWidth');
    const getClientHeight = curry(getProp, 'clientHeight');
    const getMarginTop = curry(getComputedSizeProp, 'margin-top');
    const getMarginLeft = curry(getComputedSizeProp, 'margin-left');
    const getBoundingClientRect = elm => elm.dom.getBoundingClientRect();
    const isInsideElementContentArea = (bodyElm, clientX, clientY) => {
      const clientWidth = getClientWidth(bodyElm);
      const clientHeight = getClientHeight(bodyElm);
      return clientX >= 0 && clientY >= 0 && clientX <= clientWidth && clientY <= clientHeight;
    };
    const transpose = (inline, elm, clientX, clientY) => {
      const clientRect = getBoundingClientRect(elm);
      const deltaX = inline ? clientRect.left + elm.dom.clientLeft + getMarginLeft(elm) : 0;
      const deltaY = inline ? clientRect.top + elm.dom.clientTop + getMarginTop(elm) : 0;
      const x = clientX - deltaX;
      const y = clientY - deltaY;
      return {
        x,
        y
      };
    };
    const isXYInContentArea = (editor, clientX, clientY) => {
      const bodyElm = SugarElement.fromDom(editor.getBody());
      const targetElm = editor.inline ? bodyElm : documentElement(bodyElm);
      const transposedPoint = transpose(editor.inline, targetElm, clientX, clientY);
      return isInsideElementContentArea(targetElm, transposedPoint.x, transposedPoint.y);
    };
    const fromDomSafe = node => Optional.from(node).map(SugarElement.fromDom);
    const isEditorAttachedToDom = editor => {
      const rawContainer = editor.inline ? editor.getBody() : editor.getContentAreaContainer();
      return fromDomSafe(rawContainer).map(inBody).getOr(false);
    };

    var NotificationManagerImpl = () => {
      const unimplemented = () => {
        throw new Error('Theme did not provide a NotificationManager implementation.');
      };
      return {
        open: unimplemented,
        close: unimplemented,
        getArgs: unimplemented
      };
    };

    const NotificationManager = editor => {
      const notifications = [];
      const getImplementation = () => {
        const theme = editor.theme;
        return theme && theme.getNotificationManagerImpl ? theme.getNotificationManagerImpl() : NotificationManagerImpl();
      };
      const getTopNotification = () => {
        return Optional.from(notifications[0]);
      };
      const isEqual = (a, b) => {
        return a.type === b.type && a.text === b.text && !a.progressBar && !a.timeout && !b.progressBar && !b.timeout;
      };
      const reposition = () => {
        each$e(notifications, notification => {
          notification.reposition();
        });
      };
      const addNotification = notification => {
        notifications.push(notification);
      };
      const closeNotification = notification => {
        findIndex$2(notifications, otherNotification => {
          return otherNotification === notification;
        }).each(index => {
          notifications.splice(index, 1);
        });
      };
      const open = (spec, fireEvent = true) => {
        if (editor.removed || !isEditorAttachedToDom(editor)) {
          return {};
        }
        if (fireEvent) {
          editor.dispatch('BeforeOpenNotification', { notification: spec });
        }
        return find$2(notifications, notification => {
          return isEqual(getImplementation().getArgs(notification), spec);
        }).getOrThunk(() => {
          editor.editorManager.setActive(editor);
          const notification = getImplementation().open(spec, () => {
            closeNotification(notification);
            reposition();
            getTopNotification().fold(() => editor.focus(), top => focus$1(SugarElement.fromDom(top.getEl())));
          });
          addNotification(notification);
          reposition();
          editor.dispatch('OpenNotification', { notification: { ...notification } });
          return notification;
        });
      };
      const close = () => {
        getTopNotification().each(notification => {
          getImplementation().close(notification);
          closeNotification(notification);
          reposition();
        });
      };
      const getNotifications = constant(notifications);
      const registerEvents = editor => {
        editor.on('SkinLoaded', () => {
          const serviceMessage = getServiceMessage(editor);
          if (serviceMessage) {
            open({
              text: serviceMessage,
              type: 'warning',
              timeout: 0
            }, false);
          }
          reposition();
        });
        editor.on('show ResizeEditor ResizeWindow NodeChange', () => {
          requestAnimationFrame(reposition);
        });
        editor.on('remove', () => {
          each$e(notifications.slice(), notification => {
            getImplementation().close(notification);
          });
        });
      };
      registerEvents(editor);
      return {
        open,
        close,
        getNotifications
      };
    };

    const PluginManager = AddOnManager.PluginManager;

    const ThemeManager = AddOnManager.ThemeManager;

    var WindowManagerImpl = () => {
      const unimplemented = () => {
        throw new Error('Theme did not provide a WindowManager implementation.');
      };
      return {
        open: unimplemented,
        openUrl: unimplemented,
        alert: unimplemented,
        confirm: unimplemented,
        close: unimplemented
      };
    };

    const WindowManager = editor => {
      let dialogs = [];
      const getImplementation = () => {
        const theme = editor.theme;
        return theme && theme.getWindowManagerImpl ? theme.getWindowManagerImpl() : WindowManagerImpl();
      };
      const funcBind = (scope, f) => {
        return (...args) => {
          return f ? f.apply(scope, args) : undefined;
        };
      };
      const fireOpenEvent = dialog => {
        editor.dispatch('OpenWindow', { dialog });
      };
      const fireCloseEvent = dialog => {
        editor.dispatch('CloseWindow', { dialog });
      };
      const addDialog = dialog => {
        dialogs.push(dialog);
        fireOpenEvent(dialog);
      };
      const closeDialog = dialog => {
        fireCloseEvent(dialog);
        dialogs = filter$5(dialogs, otherDialog => {
          return otherDialog !== dialog;
        });
        if (dialogs.length === 0) {
          editor.focus();
        }
      };
      const getTopDialog = () => {
        return Optional.from(dialogs[dialogs.length - 1]);
      };
      const storeSelectionAndOpenDialog = openDialog => {
        editor.editorManager.setActive(editor);
        store(editor);
        editor.ui.show();
        const dialog = openDialog();
        addDialog(dialog);
        return dialog;
      };
      const open = (args, params) => {
        return storeSelectionAndOpenDialog(() => getImplementation().open(args, params, closeDialog));
      };
      const openUrl = args => {
        return storeSelectionAndOpenDialog(() => getImplementation().openUrl(args, closeDialog));
      };
      const alert = (message, callback, scope) => {
        const windowManagerImpl = getImplementation();
        windowManagerImpl.alert(message, funcBind(scope ? scope : windowManagerImpl, callback));
      };
      const confirm = (message, callback, scope) => {
        const windowManagerImpl = getImplementation();
        windowManagerImpl.confirm(message, funcBind(scope ? scope : windowManagerImpl, callback));
      };
      const close = () => {
        getTopDialog().each(dialog => {
          getImplementation().close(dialog);
          closeDialog(dialog);
        });
      };
      editor.on('remove', () => {
        each$e(dialogs, dialog => {
          getImplementation().close(dialog);
        });
      });
      return {
        open,
        openUrl,
        alert,
        confirm,
        close
      };
    };

    const displayNotification = (editor, message) => {
      editor.notificationManager.open({
        type: 'error',
        text: message
      });
    };
    const displayError = (editor, message) => {
      if (editor._skinLoaded) {
        displayNotification(editor, message);
      } else {
        editor.on('SkinLoaded', () => {
          displayNotification(editor, message);
        });
      }
    };
    const uploadError = (editor, message) => {
      displayError(editor, I18n.translate([
        'Failed to upload image: {0}',
        message
      ]));
    };
    const logError = (editor, errorType, msg) => {
      fireError(editor, errorType, { message: msg });
      console.error(msg);
    };
    const createLoadError = (type, url, name) => name ? `Failed to load ${ type }: ${ name } from url ${ url }` : `Failed to load ${ type } url: ${ url }`;
    const pluginLoadError = (editor, url, name) => {
      logError(editor, 'PluginLoadError', createLoadError('plugin', url, name));
    };
    const iconsLoadError = (editor, url, name) => {
      logError(editor, 'IconsLoadError', createLoadError('icons', url, name));
    };
    const languageLoadError = (editor, url, name) => {
      logError(editor, 'LanguageLoadError', createLoadError('language', url, name));
    };
    const themeLoadError = (editor, url, name) => {
      logError(editor, 'ThemeLoadError', createLoadError('theme', url, name));
    };
    const modelLoadError = (editor, url, name) => {
      logError(editor, 'ModelLoadError', createLoadError('model', url, name));
    };
    const pluginInitError = (editor, name, err) => {
      const message = I18n.translate([
        'Failed to initialize plugin: {0}',
        name
      ]);
      fireError(editor, 'PluginLoadError', { message });
      initError(message, err);
      displayError(editor, message);
    };
    const initError = (message, ...x) => {
      const console = window.console;
      if (console) {
        if (console.error) {
          console.error(message, ...x);
        } else {
          console.log(message, ...x);
        }
      }
    };

    const isContentCssSkinName = url => /^[a-z0-9\-]+$/i.test(url);
    const getContentCssUrls = editor => {
      return transformToUrls(editor, getContentCss(editor));
    };
    const getFontCssUrls = editor => {
      return transformToUrls(editor, getFontCss(editor));
    };
    const transformToUrls = (editor, cssLinks) => {
      const skinUrl = editor.editorManager.baseURL + '/skins/content';
      const suffix = editor.editorManager.suffix;
      const contentCssFile = `content${ suffix }.css`;
      return map$3(cssLinks, url => {
        if (isContentCssSkinName(url) && !editor.inline) {
          return `${ skinUrl }/${ url }/${ contentCssFile }`;
        } else {
          return editor.documentBaseURI.toAbsolute(url);
        }
      });
    };
    const appendContentCssFromSettings = editor => {
      editor.contentCSS = editor.contentCSS.concat(getContentCssUrls(editor), getFontCssUrls(editor));
    };

    const getAllImages = elm => {
      return elm ? from(elm.getElementsByTagName('img')) : [];
    };
    const ImageScanner = (uploadStatus, blobCache) => {
      const cachedPromises = {};
      const findAll = (elm, predicate = always) => {
        const images = filter$5(getAllImages(elm), img => {
          const src = img.src;
          if (img.hasAttribute('data-mce-bogus')) {
            return false;
          }
          if (img.hasAttribute('data-mce-placeholder')) {
            return false;
          }
          if (!src || src === Env.transparentSrc) {
            return false;
          }
          if (startsWith(src, 'blob:')) {
            return !uploadStatus.isUploaded(src) && predicate(img);
          }
          if (startsWith(src, 'data:')) {
            return predicate(img);
          }
          return false;
        });
        const promises = map$3(images, img => {
          const imageSrc = img.src;
          if (has$2(cachedPromises, imageSrc)) {
            return cachedPromises[imageSrc].then(imageInfo => {
              if (isString(imageInfo)) {
                return imageInfo;
              } else {
                return {
                  image: img,
                  blobInfo: imageInfo.blobInfo
                };
              }
            });
          } else {
            const newPromise = imageToBlobInfo(blobCache, imageSrc).then(blobInfo => {
              delete cachedPromises[imageSrc];
              return {
                image: img,
                blobInfo
              };
            }).catch(error => {
              delete cachedPromises[imageSrc];
              return error;
            });
            cachedPromises[imageSrc] = newPromise;
            return newPromise;
          }
        });
        return Promise.all(promises);
      };
      return { findAll };
    };

    const UploadStatus = () => {
      const PENDING = 1, UPLOADED = 2;
      let blobUriStatuses = {};
      const createStatus = (status, resultUri) => {
        return {
          status,
          resultUri
        };
      };
      const hasBlobUri = blobUri => {
        return blobUri in blobUriStatuses;
      };
      const getResultUri = blobUri => {
        const result = blobUriStatuses[blobUri];
        return result ? result.resultUri : null;
      };
      const isPending = blobUri => {
        return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === PENDING : false;
      };
      const isUploaded = blobUri => {
        return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === UPLOADED : false;
      };
      const markPending = blobUri => {
        blobUriStatuses[blobUri] = createStatus(PENDING, null);
      };
      const markUploaded = (blobUri, resultUri) => {
        blobUriStatuses[blobUri] = createStatus(UPLOADED, resultUri);
      };
      const removeFailed = blobUri => {
        delete blobUriStatuses[blobUri];
      };
      const destroy = () => {
        blobUriStatuses = {};
      };
      return {
        hasBlobUri,
        getResultUri,
        isPending,
        isUploaded,
        markPending,
        markUploaded,
        removeFailed,
        destroy
      };
    };

    let count = 0;
    const seed = () => {
      const rnd = () => {
        return Math.round(Math.random() * 4294967295).toString(36);
      };
      const now = new Date().getTime();
      return 's' + now.toString(36) + rnd() + rnd() + rnd();
    };
    const uuid = prefix => {
      return prefix + count++ + seed();
    };

    const BlobCache = () => {
      let cache = [];
      const mimeToExt = mime => {
        const mimes = {
          'image/jpeg': 'jpg',
          'image/jpg': 'jpg',
          'image/gif': 'gif',
          'image/png': 'png',
          'image/apng': 'apng',
          'image/avif': 'avif',
          'image/svg+xml': 'svg',
          'image/webp': 'webp',
          'image/bmp': 'bmp',
          'image/tiff': 'tiff'
        };
        return mimes[mime.toLowerCase()] || 'dat';
      };
      const create = (o, blob, base64, name, filename) => {
        if (isString(o)) {
          const id = o;
          return toBlobInfo({
            id,
            name,
            filename,
            blob: blob,
            base64: base64
          });
        } else if (isObject(o)) {
          return toBlobInfo(o);
        } else {
          throw new Error('Unknown input type');
        }
      };
      const toBlobInfo = o => {
        if (!o.blob || !o.base64) {
          throw new Error('blob and base64 representations of the image are required for BlobInfo to be created');
        }
        const id = o.id || uuid('blobid');
        const name = o.name || id;
        const blob = o.blob;
        return {
          id: constant(id),
          name: constant(name),
          filename: constant(o.filename || name + '.' + mimeToExt(blob.type)),
          blob: constant(blob),
          base64: constant(o.base64),
          blobUri: constant(o.blobUri || URL.createObjectURL(blob)),
          uri: constant(o.uri)
        };
      };
      const add = blobInfo => {
        if (!get(blobInfo.id())) {
          cache.push(blobInfo);
        }
      };
      const findFirst = predicate => find$2(cache, predicate).getOrUndefined();
      const get = id => findFirst(cachedBlobInfo => cachedBlobInfo.id() === id);
      const getByUri = blobUri => findFirst(blobInfo => blobInfo.blobUri() === blobUri);
      const getByData = (base64, type) => findFirst(blobInfo => blobInfo.base64() === base64 && blobInfo.blob().type === type);
      const removeByUri = blobUri => {
        cache = filter$5(cache, blobInfo => {
          if (blobInfo.blobUri() === blobUri) {
            URL.revokeObjectURL(blobInfo.blobUri());
            return false;
          }
          return true;
        });
      };
      const destroy = () => {
        each$e(cache, cachedBlobInfo => {
          URL.revokeObjectURL(cachedBlobInfo.blobUri());
        });
        cache = [];
      };
      return {
        create,
        add,
        get,
        getByUri,
        getByData,
        findFirst,
        removeByUri,
        destroy
      };
    };

    const Uploader = (uploadStatus, settings) => {
      const pendingPromises = {};
      const pathJoin = (path1, path2) => {
        if (path1) {
          return path1.replace(/\/$/, '') + '/' + path2.replace(/^\//, '');
        }
        return path2;
      };
      const defaultHandler = (blobInfo, progress) => new Promise((success, failure) => {
        const xhr = new XMLHttpRequest();
        xhr.open('POST', settings.url);
        xhr.withCredentials = settings.credentials;
        xhr.upload.onprogress = e => {
          progress(e.loaded / e.total * 100);
        };
        xhr.onerror = () => {
          failure('Image upload failed due to a XHR Transport error. Code: ' + xhr.status);
        };
        xhr.onload = () => {
          if (xhr.status < 200 || xhr.status >= 300) {
            failure('HTTP Error: ' + xhr.status);
            return;
          }
          const json = JSON.parse(xhr.responseText);
          if (!json || !isString(json.location)) {
            failure('Invalid JSON: ' + xhr.responseText);
            return;
          }
          success(pathJoin(settings.basePath, json.location));
        };
        const formData = new FormData();
        formData.append('file', blobInfo.blob(), blobInfo.filename());
        xhr.send(formData);
      });
      const uploadHandler = isFunction(settings.handler) ? settings.handler : defaultHandler;
      const noUpload = () => new Promise(resolve => {
        resolve([]);
      });
      const handlerSuccess = (blobInfo, url) => ({
        url,
        blobInfo,
        status: true
      });
      const handlerFailure = (blobInfo, error) => ({
        url: '',
        blobInfo,
        status: false,
        error
      });
      const resolvePending = (blobUri, result) => {
        Tools.each(pendingPromises[blobUri], resolve => {
          resolve(result);
        });
        delete pendingPromises[blobUri];
      };
      const uploadBlobInfo = (blobInfo, handler, openNotification) => {
        uploadStatus.markPending(blobInfo.blobUri());
        return new Promise(resolve => {
          let notification;
          let progress;
          try {
            const closeNotification = () => {
              if (notification) {
                notification.close();
                progress = noop;
              }
            };
            const success = url => {
              closeNotification();
              uploadStatus.markUploaded(blobInfo.blobUri(), url);
              resolvePending(blobInfo.blobUri(), handlerSuccess(blobInfo, url));
              resolve(handlerSuccess(blobInfo, url));
            };
            const failure = error => {
              closeNotification();
              uploadStatus.removeFailed(blobInfo.blobUri());
              resolvePending(blobInfo.blobUri(), handlerFailure(blobInfo, error));
              resolve(handlerFailure(blobInfo, error));
            };
            progress = percent => {
              if (percent < 0 || percent > 100) {
                return;
              }
              Optional.from(notification).orThunk(() => Optional.from(openNotification).map(apply$1)).each(n => {
                notification = n;
                n.progressBar.value(percent);
              });
            };
            handler(blobInfo, progress).then(success, err => {
              failure(isString(err) ? { message: err } : err);
            });
          } catch (ex) {
            resolve(handlerFailure(blobInfo, ex));
          }
        });
      };
      const isDefaultHandler = handler => handler === defaultHandler;
      const pendingUploadBlobInfo = blobInfo => {
        const blobUri = blobInfo.blobUri();
        return new Promise(resolve => {
          pendingPromises[blobUri] = pendingPromises[blobUri] || [];
          pendingPromises[blobUri].push(resolve);
        });
      };
      const uploadBlobs = (blobInfos, openNotification) => {
        blobInfos = Tools.grep(blobInfos, blobInfo => !uploadStatus.isUploaded(blobInfo.blobUri()));
        return Promise.all(Tools.map(blobInfos, blobInfo => uploadStatus.isPending(blobInfo.blobUri()) ? pendingUploadBlobInfo(blobInfo) : uploadBlobInfo(blobInfo, uploadHandler, openNotification)));
      };
      const upload = (blobInfos, openNotification) => !settings.url && isDefaultHandler(uploadHandler) ? noUpload() : uploadBlobs(blobInfos, openNotification);
      return { upload };
    };

    const openNotification = editor => () => editor.notificationManager.open({
      text: editor.translate('Image uploading...'),
      type: 'info',
      timeout: -1,
      progressBar: true
    });
    const createUploader = (editor, uploadStatus) => Uploader(uploadStatus, {
      url: getImageUploadUrl(editor),
      basePath: getImageUploadBasePath(editor),
      credentials: getImagesUploadCredentials(editor),
      handler: getImagesUploadHandler(editor)
    });
    const ImageUploader = editor => {
      const uploadStatus = UploadStatus();
      const uploader = createUploader(editor, uploadStatus);
      return { upload: (blobInfos, showNotification = true) => uploader.upload(blobInfos, showNotification ? openNotification(editor) : undefined) };
    };

    const EditorUpload = editor => {
      const blobCache = BlobCache();
      let uploader, imageScanner;
      const uploadStatus = UploadStatus();
      const urlFilters = [];
      const aliveGuard = callback => {
        return result => {
          if (editor.selection) {
            return callback(result);
          }
          return [];
        };
      };
      const cacheInvalidator = url => url + (url.indexOf('?') === -1 ? '?' : '&') + new Date().getTime();
      const replaceString = (content, search, replace) => {
        let index = 0;
        do {
          index = content.indexOf(search, index);
          if (index !== -1) {
            content = content.substring(0, index) + replace + content.substr(index + search.length);
            index += replace.length - search.length + 1;
          }
        } while (index !== -1);
        return content;
      };
      const replaceImageUrl = (content, targetUrl, replacementUrl) => {
        const replacementString = `src="${ replacementUrl }"${ replacementUrl === Env.transparentSrc ? ' data-mce-placeholder="1"' : '' }`;
        content = replaceString(content, `src="${ targetUrl }"`, replacementString);
        content = replaceString(content, 'data-mce-src="' + targetUrl + '"', 'data-mce-src="' + replacementUrl + '"');
        return content;
      };
      const replaceUrlInUndoStack = (targetUrl, replacementUrl) => {
        each$e(editor.undoManager.data, level => {
          if (level.type === 'fragmented') {
            level.fragments = map$3(level.fragments, fragment => replaceImageUrl(fragment, targetUrl, replacementUrl));
          } else {
            level.content = replaceImageUrl(level.content, targetUrl, replacementUrl);
          }
        });
      };
      const replaceImageUriInView = (image, resultUri) => {
        const src = editor.convertURL(resultUri, 'src');
        replaceUrlInUndoStack(image.src, resultUri);
        setAll$1(SugarElement.fromDom(image), {
          'src': shouldReuseFileName(editor) ? cacheInvalidator(resultUri) : resultUri,
          'data-mce-src': src
        });
      };
      const uploadImages = () => {
        if (!uploader) {
          uploader = createUploader(editor, uploadStatus);
        }
        return scanForImages().then(aliveGuard(imageInfos => {
          const blobInfos = map$3(imageInfos, imageInfo => imageInfo.blobInfo);
          return uploader.upload(blobInfos, openNotification(editor)).then(aliveGuard(result => {
            const imagesToRemove = [];
            let shouldDispatchChange = false;
            const filteredResult = map$3(result, (uploadInfo, index) => {
              const {blobInfo, image} = imageInfos[index];
              let removed = false;
              if (uploadInfo.status && shouldReplaceBlobUris(editor)) {
                if (uploadInfo.url && !contains$1(image.src, uploadInfo.url)) {
                  shouldDispatchChange = true;
                }
                blobCache.removeByUri(image.src);
                if (isRtc(editor)) ; else {
                  replaceImageUriInView(image, uploadInfo.url);
                }
              } else if (uploadInfo.error) {
                if (uploadInfo.error.remove) {
                  replaceUrlInUndoStack(image.src, Env.transparentSrc);
                  imagesToRemove.push(image);
                  removed = true;
                }
                uploadError(editor, uploadInfo.error.message);
              }
              return {
                element: image,
                status: uploadInfo.status,
                uploadUri: uploadInfo.url,
                blobInfo,
                removed
              };
            });
            if (imagesToRemove.length > 0 && !isRtc(editor)) {
              editor.undoManager.transact(() => {
                each$e(imagesToRemove, element => {
                  editor.dom.remove(element);
                  blobCache.removeByUri(element.src);
                });
              });
            } else if (shouldDispatchChange) {
              editor.undoManager.dispatchChange();
            }
            return filteredResult;
          }));
        }));
      };
      const uploadImagesAuto = () => isAutomaticUploadsEnabled(editor) ? uploadImages() : Promise.resolve([]);
      const isValidDataUriImage = imgElm => forall(urlFilters, filter => filter(imgElm));
      const addFilter = filter => {
        urlFilters.push(filter);
      };
      const scanForImages = () => {
        if (!imageScanner) {
          imageScanner = ImageScanner(uploadStatus, blobCache);
        }
        return imageScanner.findAll(editor.getBody(), isValidDataUriImage).then(aliveGuard(result => {
          const filteredResult = filter$5(result, resultItem => {
            if (isString(resultItem)) {
              displayError(editor, resultItem);
              return false;
            } else if (resultItem.uriType === 'blob') {
              return false;
            } else {
              return true;
            }
          });
          if (isRtc(editor)) ; else {
            each$e(filteredResult, resultItem => {
              replaceUrlInUndoStack(resultItem.image.src, resultItem.blobInfo.blobUri());
              resultItem.image.src = resultItem.blobInfo.blobUri();
              resultItem.image.removeAttribute('data-mce-src');
            });
          }
          return filteredResult;
        }));
      };
      const destroy = () => {
        blobCache.destroy();
        uploadStatus.destroy();
        imageScanner = uploader = null;
      };
      const replaceBlobUris = content => {
        return content.replace(/src="(blob:[^"]+)"/g, (match, blobUri) => {
          const resultUri = uploadStatus.getResultUri(blobUri);
          if (resultUri) {
            return 'src="' + resultUri + '"';
          }
          let blobInfo = blobCache.getByUri(blobUri);
          if (!blobInfo) {
            blobInfo = foldl(editor.editorManager.get(), (result, editor) => {
              return result || editor.editorUpload && editor.editorUpload.blobCache.getByUri(blobUri);
            }, undefined);
          }
          if (blobInfo) {
            const blob = blobInfo.blob();
            return 'src="data:' + blob.type + ';base64,' + blobInfo.base64() + '"';
          }
          return match;
        });
      };
      editor.on('SetContent', () => {
        if (isAutomaticUploadsEnabled(editor)) {
          uploadImagesAuto();
        } else {
          scanForImages();
        }
      });
      editor.on('RawSaveContent', e => {
        e.content = replaceBlobUris(e.content);
      });
      editor.on('GetContent', e => {
        if (e.source_view || e.format === 'raw' || e.format === 'tree') {
          return;
        }
        e.content = replaceBlobUris(e.content);
      });
      editor.on('PostRender', () => {
        editor.parser.addNodeFilter('img', images => {
          each$e(images, img => {
            const src = img.attr('src');
            if (!src || blobCache.getByUri(src)) {
              return;
            }
            const resultUri = uploadStatus.getResultUri(src);
            if (resultUri) {
              img.attr('src', resultUri);
            }
          });
        });
      });
      return {
        blobCache,
        addFilter,
        uploadImages,
        uploadImagesAuto,
        scanForImages,
        destroy
      };
    };

    const get$1 = editor => {
      const dom = editor.dom;
      const schemaType = editor.schema.type;
      const formats = {
        valigntop: [{
            selector: 'td,th',
            styles: { verticalAlign: 'top' }
          }],
        valignmiddle: [{
            selector: 'td,th',
            styles: { verticalAlign: 'middle' }
          }],
        valignbottom: [{
            selector: 'td,th',
            styles: { verticalAlign: 'bottom' }
          }],
        alignleft: [
          {
            selector: 'figure.image',
            collapsed: false,
            classes: 'align-left',
            ceFalseOverride: true,
            preview: 'font-family font-size'
          },
          {
            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',
            styles: { textAlign: 'left' },
            inherit: false,
            preview: false
          },
          {
            selector: 'img,audio,video',
            collapsed: false,
            styles: { float: 'left' },
            preview: 'font-family font-size'
          },
          {
            selector: 'table',
            collapsed: false,
            styles: {
              marginLeft: '0px',
              marginRight: 'auto'
            },
            onformat: table => {
              dom.setStyle(table, 'float', null);
            },
            preview: 'font-family font-size'
          },
          {
            selector: '.mce-preview-object,[data-ephox-embed-iri]',
            ceFalseOverride: true,
            styles: { float: 'left' }
          }
        ],
        aligncenter: [
          {
            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',
            styles: { textAlign: 'center' },
            inherit: false,
            preview: 'font-family font-size'
          },
          {
            selector: 'figure.image',
            collapsed: false,
            classes: 'align-center',
            ceFalseOverride: true,
            preview: 'font-family font-size'
          },
          {
            selector: 'img,audio,video',
            collapsed: false,
            styles: {
              display: 'block',
              marginLeft: 'auto',
              marginRight: 'auto'
            },
            preview: false
          },
          {
            selector: 'table',
            collapsed: false,
            styles: {
              marginLeft: 'auto',
              marginRight: 'auto'
            },
            preview: 'font-family font-size'
          },
          {
            selector: '.mce-preview-object',
            ceFalseOverride: true,
            styles: {
              display: 'table',
              marginLeft: 'auto',
              marginRight: 'auto'
            },
            preview: false
          },
          {
            selector: '[data-ephox-embed-iri]',
            ceFalseOverride: true,
            styles: {
              marginLeft: 'auto',
              marginRight: 'auto'
            },
            preview: false
          }
        ],
        alignright: [
          {
            selector: 'figure.image',
            collapsed: false,
            classes: 'align-right',
            ceFalseOverride: true,
            preview: 'font-family font-size'
          },
          {
            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',
            styles: { textAlign: 'right' },
            inherit: false,
            preview: 'font-family font-size'
          },
          {
            selector: 'img,audio,video',
            collapsed: false,
            styles: { float: 'right' },
            preview: 'font-family font-size'
          },
          {
            selector: 'table',
            collapsed: false,
            styles: {
              marginRight: '0px',
              marginLeft: 'auto'
            },
            onformat: table => {
              dom.setStyle(table, 'float', null);
            },
            preview: 'font-family font-size'
          },
          {
            selector: '.mce-preview-object,[data-ephox-embed-iri]',
            ceFalseOverride: true,
            styles: { float: 'right' },
            preview: false
          }
        ],
        alignjustify: [{
            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',
            styles: { textAlign: 'justify' },
            inherit: false,
            preview: 'font-family font-size'
          }],
        bold: [
          {
            inline: 'strong',
            remove: 'all',
            preserve_attributes: [
              'class',
              'style'
            ]
          },
          {
            inline: 'span',
            styles: { fontWeight: 'bold' }
          },
          {
            inline: 'b',
            remove: 'all',
            preserve_attributes: [
              'class',
              'style'
            ]
          }
        ],
        italic: [
          {
            inline: 'em',
            remove: 'all',
            preserve_attributes: [
              'class',
              'style'
            ]
          },
          {
            inline: 'span',
            styles: { fontStyle: 'italic' }
          },
          {
            inline: 'i',
            remove: 'all',
            preserve_attributes: [
              'class',
              'style'
            ]
          }
        ],
        underline: [
          {
            inline: 'span',
            styles: { textDecoration: 'underline' },
            exact: true
          },
          {
            inline: 'u',
            remove: 'all',
            preserve_attributes: [
              'class',
              'style'
            ]
          }
        ],
        strikethrough: (() => {
          const span = {
            inline: 'span',
            styles: { textDecoration: 'line-through' },
            exact: true
          };
          const strike = {
            inline: 'strike',
            remove: 'all',
            preserve_attributes: [
              'class',
              'style'
            ]
          };
          const s = {
            inline: 's',
            remove: 'all',
            preserve_attributes: [
              'class',
              'style'
            ]
          };
          return schemaType !== 'html4' ? [
            s,
            span,
            strike
          ] : [
            span,
            s,
            strike
          ];
        })(),
        forecolor: {
          inline: 'span',
          styles: { color: '%value' },
          links: true,
          remove_similar: true,
          clear_child_styles: true
        },
        hilitecolor: {
          inline: 'span',
          styles: { backgroundColor: '%value' },
          links: true,
          remove_similar: true,
          clear_child_styles: true
        },
        fontname: {
          inline: 'span',
          toggle: false,
          styles: { fontFamily: '%value' },
          clear_child_styles: true
        },
        fontsize: {
          inline: 'span',
          toggle: false,
          styles: { fontSize: '%value' },
          clear_child_styles: true
        },
        lineheight: {
          selector: 'h1,h2,h3,h4,h5,h6,p,li,td,th,div',
          styles: { lineHeight: '%value' }
        },
        fontsize_class: {
          inline: 'span',
          attributes: { class: '%value' }
        },
        blockquote: {
          block: 'blockquote',
          wrapper: true,
          remove: 'all'
        },
        subscript: { inline: 'sub' },
        superscript: { inline: 'sup' },
        code: { inline: 'code' },
        link: {
          inline: 'a',
          selector: 'a',
          remove: 'all',
          split: true,
          deep: true,
          onmatch: (node, _fmt, _itemName) => {
            return isElement$6(node) && node.hasAttribute('href');
          },
          onformat: (elm, _fmt, vars) => {
            Tools.each(vars, (value, key) => {
              dom.setAttrib(elm, key, value);
            });
          }
        },
        lang: {
          inline: 'span',
          clear_child_styles: true,
          remove_similar: true,
          attributes: {
            'lang': '%value',
            'data-mce-lang': vars => {
              var _a;
              return (_a = vars === null || vars === void 0 ? void 0 : vars.customValue) !== null && _a !== void 0 ? _a : null;
            }
          }
        },
        removeformat: [
          {
            selector: 'b,strong,em,i,font,u,strike,s,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins,small',
            remove: 'all',
            split: true,
            expand: false,
            block_expand: true,
            deep: true
          },
          {
            selector: 'span',
            attributes: [
              'style',
              'class'
            ],
            remove: 'empty',
            split: true,
            expand: false,
            deep: true
          },
          {
            selector: '*',
            attributes: [
              'style',
              'class'
            ],
            split: false,
            expand: false,
            deep: true
          }
        ]
      };
      Tools.each('p h1 h2 h3 h4 h5 h6 div address pre dt dd samp'.split(/\s/), name => {
        formats[name] = {
          block: name,
          remove: 'all'
        };
      });
      return formats;
    };

    const genericBase = {
      remove_similar: true,
      inherit: false
    };
    const cellBase = {
      selector: 'td,th',
      ...genericBase
    };
    const cellFormats = {
      tablecellbackgroundcolor: {
        styles: { backgroundColor: '%value' },
        ...cellBase
      },
      tablecellverticalalign: {
        styles: { 'vertical-align': '%value' },
        ...cellBase
      },
      tablecellbordercolor: {
        styles: { borderColor: '%value' },
        ...cellBase
      },
      tablecellclass: {
        classes: ['%value'],
        ...cellBase
      },
      tableclass: {
        selector: 'table',
        classes: ['%value'],
        ...genericBase
      },
      tablecellborderstyle: {
        styles: { borderStyle: '%value' },
        ...cellBase
      },
      tablecellborderwidth: {
        styles: { borderWidth: '%value' },
        ...cellBase
      }
    };
    const get = constant(cellFormats);

    const FormatRegistry = editor => {
      const formats = {};
      const get$2 = name => isNonNullable(name) ? formats[name] : formats;
      const has = name => has$2(formats, name);
      const register = (name, format) => {
        if (name) {
          if (!isString(name)) {
            each$d(name, (format, name) => {
              register(name, format);
            });
          } else {
            if (!isArray$1(format)) {
              format = [format];
            }
            each$e(format, format => {
              if (isUndefined(format.deep)) {
                format.deep = !isSelectorFormat(format);
              }
              if (isUndefined(format.split)) {
                format.split = !isSelectorFormat(format) || isInlineFormat(format);
              }
              if (isUndefined(format.remove) && isSelectorFormat(format) && !isInlineFormat(format)) {
                format.remove = 'none';
              }
              if (isSelectorFormat(format) && isInlineFormat(format)) {
                format.mixed = true;
                format.block_expand = true;
              }
              if (isString(format.classes)) {
                format.classes = format.classes.split(/\s+/);
              }
            });
            formats[name] = format;
          }
        }
      };
      const unregister = name => {
        if (name && formats[name]) {
          delete formats[name];
        }
        return formats;
      };
      register(get$1(editor));
      register(get());
      register(getFormats(editor));
      return {
        get: get$2,
        has,
        register,
        unregister
      };
    };

    const each$3 = Tools.each;
    const dom = DOMUtils.DOM;
    const isPreviewItem = item => isNonNullable(item) && isObject(item);
    const parsedSelectorToHtml = (ancestry, editor) => {
      const schema = editor && editor.schema || Schema({});
      const decorate = (elm, item) => {
        if (item.classes.length > 0) {
          dom.addClass(elm, item.classes.join(' '));
        }
        dom.setAttribs(elm, item.attrs);
      };
      const createElement = sItem => {
        const item = isString(sItem) ? {
          name: sItem,
          classes: [],
          attrs: {}
        } : sItem;
        const elm = dom.create(item.name);
        decorate(elm, item);
        return elm;
      };
      const getRequiredParent = (elm, candidate) => {
        const elmRule = schema.getElementRule(elm.nodeName.toLowerCase());
        const parentsRequired = elmRule === null || elmRule === void 0 ? void 0 : elmRule.parentsRequired;
        if (parentsRequired && parentsRequired.length) {
          return candidate && contains$2(parentsRequired, candidate) ? candidate : parentsRequired[0];
        } else {
          return false;
        }
      };
      const wrapInHtml = (elm, ancestors, siblings) => {
        let parentCandidate;
        const ancestor = ancestors[0];
        const ancestorName = isPreviewItem(ancestor) ? ancestor.name : undefined;
        const parentRequired = getRequiredParent(elm, ancestorName);
        if (parentRequired) {
          if (ancestorName === parentRequired) {
            parentCandidate = ancestor;
            ancestors = ancestors.slice(1);
          } else {
            parentCandidate = parentRequired;
          }
        } else if (ancestor) {
          parentCandidate = ancestor;
          ancestors = ancestors.slice(1);
        } else if (!siblings) {
          return elm;
        }
        const parent = parentCandidate ? createElement(parentCandidate) : dom.create('div');
        parent.appendChild(elm);
        if (siblings) {
          Tools.each(siblings, sibling => {
            const siblingElm = createElement(sibling);
            parent.insertBefore(siblingElm, elm);
          });
        }
        const parentSiblings = isPreviewItem(parentCandidate) ? parentCandidate.siblings : undefined;
        return wrapInHtml(parent, ancestors, parentSiblings);
      };
      const fragment = dom.create('div');
      if (ancestry.length > 0) {
        const item = ancestry[0];
        const elm = createElement(item);
        const siblings = isPreviewItem(item) ? item.siblings : undefined;
        fragment.appendChild(wrapInHtml(elm, ancestry.slice(1), siblings));
      }
      return fragment;
    };
    const parseSelectorItem = item => {
      item = Tools.trim(item);
      let tagName = 'div';
      const obj = {
        name: tagName,
        classes: [],
        attrs: {},
        selector: item
      };
      if (item !== '*') {
        tagName = item.replace(/(?:([#\.]|::?)([\w\-]+)|(\[)([^\]]+)\]?)/g, ($0, $1, $2, $3, $4) => {
          switch ($1) {
          case '#':
            obj.attrs.id = $2;
            break;
          case '.':
            obj.classes.push($2);
            break;
          case ':':
            if (Tools.inArray('checked disabled enabled read-only required'.split(' '), $2) !== -1) {
              obj.attrs[$2] = $2;
            }
            break;
          }
          if ($3 === '[') {
            const m = $4.match(/([\w\-]+)(?:\=\"([^\"]+))?/);
            if (m) {
              obj.attrs[m[1]] = m[2];
            }
          }
          return '';
        });
      }
      obj.name = tagName || 'div';
      return obj;
    };
    const parseSelector = selector => {
      if (!isString(selector)) {
        return [];
      }
      selector = selector.split(/\s*,\s*/)[0];
      selector = selector.replace(/\s*(~\+|~|\+|>)\s*/g, '$1');
      return Tools.map(selector.split(/(?:>|\s+(?![^\[\]]+\]))/), item => {
        const siblings = Tools.map(item.split(/(?:~\+|~|\+)/), parseSelectorItem);
        const obj = siblings.pop();
        if (siblings.length) {
          obj.siblings = siblings;
        }
        return obj;
      }).reverse();
    };
    const getCssText = (editor, format) => {
      let previewCss = '';
      let previewStyles = getPreviewStyles(editor);
      if (previewStyles === '') {
        return '';
      }
      const removeVars = val => {
        return isString(val) ? val.replace(/%(\w+)/g, '') : '';
      };
      const getComputedStyle = (name, elm) => {
        return dom.getStyle(elm !== null && elm !== void 0 ? elm : editor.getBody(), name, true);
      };
      if (isString(format)) {
        const formats = editor.formatter.get(format);
        if (!formats) {
          return '';
        }
        format = formats[0];
      }
      if ('preview' in format) {
        const preview = format.preview;
        if (preview === false) {
          return '';
        } else {
          previewStyles = preview || previewStyles;
        }
      }
      let name = format.block || format.inline || 'span';
      let previewFrag;
      const items = parseSelector(format.selector);
      if (items.length > 0) {
        if (!items[0].name) {
          items[0].name = name;
        }
        name = format.selector;
        previewFrag = parsedSelectorToHtml(items, editor);
      } else {
        previewFrag = parsedSelectorToHtml([name], editor);
      }
      const previewElm = dom.select(name, previewFrag)[0] || previewFrag.firstChild;
      each$3(format.styles, (value, name) => {
        const newValue = removeVars(value);
        if (newValue) {
          dom.setStyle(previewElm, name, newValue);
        }
      });
      each$3(format.attributes, (value, name) => {
        const newValue = removeVars(value);
        if (newValue) {
          dom.setAttrib(previewElm, name, newValue);
        }
      });
      each$3(format.classes, value => {
        const newValue = removeVars(value);
        if (!dom.hasClass(previewElm, newValue)) {
          dom.addClass(previewElm, newValue);
        }
      });
      editor.dispatch('PreviewFormats');
      dom.setStyles(previewFrag, {
        position: 'absolute',
        left: -65535
      });
      editor.getBody().appendChild(previewFrag);
      const rawParentFontSize = getComputedStyle('fontSize');
      const parentFontSize = /px$/.test(rawParentFontSize) ? parseInt(rawParentFontSize, 10) : 0;
      each$3(previewStyles.split(' '), name => {
        let value = getComputedStyle(name, previewElm);
        if (name === 'background-color' && /transparent|rgba\s*\([^)]+,\s*0\)/.test(value)) {
          value = getComputedStyle(name);
          if (rgbaToHexString(value).toLowerCase() === '#ffffff') {
            return;
          }
        }
        if (name === 'color') {
          if (rgbaToHexString(value).toLowerCase() === '#000000') {
            return;
          }
        }
        if (name === 'font-size') {
          if (/em|%$/.test(value)) {
            if (parentFontSize === 0) {
              return;
            }
            const numValue = parseFloat(value) / (/%$/.test(value) ? 100 : 1);
            value = numValue * parentFontSize + 'px';
          }
        }
        if (name === 'border' && value) {
          previewCss += 'padding:0 2px;';
        }
        previewCss += name + ':' + value + ';';
      });
      editor.dispatch('AfterPreviewFormats');
      dom.remove(previewFrag);
      return previewCss;
    };

    const setup$r = editor => {
      editor.addShortcut('meta+b', '', 'Bold');
      editor.addShortcut('meta+i', '', 'Italic');
      editor.addShortcut('meta+u', '', 'Underline');
      for (let i = 1; i <= 6; i++) {
        editor.addShortcut('access+' + i, '', [
          'FormatBlock',
          false,
          'h' + i
        ]);
      }
      editor.addShortcut('access+7', '', [
        'FormatBlock',
        false,
        'p'
      ]);
      editor.addShortcut('access+8', '', [
        'FormatBlock',
        false,
        'div'
      ]);
      editor.addShortcut('access+9', '', [
        'FormatBlock',
        false,
        'address'
      ]);
    };

    const Formatter = editor => {
      const formats = FormatRegistry(editor);
      const formatChangeState = Cell({});
      setup$r(editor);
      setup$u(editor);
      if (!isRtc(editor)) {
        setup$t(formatChangeState, editor);
      }
      return {
        get: formats.get,
        has: formats.has,
        register: formats.register,
        unregister: formats.unregister,
        apply: (name, vars, node) => {
          applyFormat(editor, name, vars, node);
        },
        remove: (name, vars, node, similar) => {
          removeFormat(editor, name, vars, node, similar);
        },
        toggle: (name, vars, node) => {
          toggleFormat(editor, name, vars, node);
        },
        match: (name, vars, node, similar) => matchFormat(editor, name, vars, node, similar),
        closest: names => closestFormat(editor, names),
        matchAll: (names, vars) => matchAllFormats(editor, names, vars),
        matchNode: (node, name, vars, similar) => matchNodeFormat(editor, node, name, vars, similar),
        canApply: name => canApplyFormat(editor, name),
        formatChanged: (formats, callback, similar, vars) => formatChanged(editor, formatChangeState, formats, callback, similar, vars),
        getCssText: curry(getCssText, editor)
      };
    };

    const shouldIgnoreCommand = cmd => {
      switch (cmd.toLowerCase()) {
      case 'undo':
      case 'redo':
      case 'mcefocus':
        return true;
      default:
        return false;
      }
    };
    const registerEvents = (editor, undoManager, locks) => {
      const isFirstTypedCharacter = Cell(false);
      const addNonTypingUndoLevel = e => {
        setTyping(undoManager, false, locks);
        undoManager.add({}, e);
      };
      editor.on('init', () => {
        undoManager.add();
      });
      editor.on('BeforeExecCommand', e => {
        const cmd = e.command;
        if (!shouldIgnoreCommand(cmd)) {
          endTyping(undoManager, locks);
          undoManager.beforeChange();
        }
      });
      editor.on('ExecCommand', e => {
        const cmd = e.command;
        if (!shouldIgnoreCommand(cmd)) {
          addNonTypingUndoLevel(e);
        }
      });
      editor.on('ObjectResizeStart cut', () => {
        undoManager.beforeChange();
      });
      editor.on('SaveContent ObjectResized blur', addNonTypingUndoLevel);
      editor.on('dragend', addNonTypingUndoLevel);
      editor.on('keyup', e => {
        const keyCode = e.keyCode;
        if (e.isDefaultPrevented()) {
          return;
        }
        if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45 || e.ctrlKey) {
          addNonTypingUndoLevel();
          editor.nodeChanged();
        }
        if (keyCode === 46 || keyCode === 8) {
          editor.nodeChanged();
        }
        if (isFirstTypedCharacter.get() && undoManager.typing && !isEq$1(createFromEditor(editor), undoManager.data[0])) {
          if (!editor.isDirty()) {
            editor.setDirty(true);
          }
          editor.dispatch('TypingUndo');
          isFirstTypedCharacter.set(false);
          editor.nodeChanged();
        }
      });
      editor.on('keydown', e => {
        const keyCode = e.keyCode;
        if (e.isDefaultPrevented()) {
          return;
        }
        if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45) {
          if (undoManager.typing) {
            addNonTypingUndoLevel(e);
          }
          return;
        }
        const modKey = e.ctrlKey && !e.altKey || e.metaKey;
        if ((keyCode < 16 || keyCode > 20) && keyCode !== 224 && keyCode !== 91 && !undoManager.typing && !modKey) {
          undoManager.beforeChange();
          setTyping(undoManager, true, locks);
          undoManager.add({}, e);
          isFirstTypedCharacter.set(true);
        }
      });
      editor.on('mousedown', e => {
        if (undoManager.typing) {
          addNonTypingUndoLevel(e);
        }
      });
      const isInsertReplacementText = event => event.inputType === 'insertReplacementText';
      const isInsertTextDataNull = event => event.inputType === 'insertText' && event.data === null;
      const isInsertFromPasteOrDrop = event => event.inputType === 'insertFromPaste' || event.inputType === 'insertFromDrop';
      editor.on('input', e => {
        if (e.inputType && (isInsertReplacementText(e) || isInsertTextDataNull(e) || isInsertFromPasteOrDrop(e))) {
          addNonTypingUndoLevel(e);
        }
      });
      editor.on('AddUndo Undo Redo ClearUndos', e => {
        if (!e.isDefaultPrevented()) {
          editor.nodeChanged();
        }
      });
    };
    const addKeyboardShortcuts = editor => {
      editor.addShortcut('meta+z', '', 'Undo');
      editor.addShortcut('meta+y,meta+shift+z', '', 'Redo');
    };

    const UndoManager = editor => {
      const beforeBookmark = value$2();
      const locks = Cell(0);
      const index = Cell(0);
      const undoManager = {
        data: [],
        typing: false,
        beforeChange: () => {
          beforeChange(editor, locks, beforeBookmark);
        },
        add: (level, event) => {
          return addUndoLevel(editor, undoManager, index, locks, beforeBookmark, level, event);
        },
        dispatchChange: () => {
          editor.setDirty(true);
          const level = createFromEditor(editor);
          level.bookmark = getUndoBookmark(editor.selection);
          editor.dispatch('change', {
            level,
            lastLevel: get$b(undoManager.data, index.get()).getOrUndefined()
          });
        },
        undo: () => {
          return undo(editor, undoManager, locks, index);
        },
        redo: () => {
          return redo(editor, index, undoManager.data);
        },
        clear: () => {
          clear(editor, undoManager, index);
        },
        reset: () => {
          reset(editor, undoManager);
        },
        hasUndo: () => {
          return hasUndo(editor, undoManager, index);
        },
        hasRedo: () => {
          return hasRedo(editor, undoManager, index);
        },
        transact: callback => {
          return transact(editor, undoManager, locks, callback);
        },
        ignore: callback => {
          ignore(editor, locks, callback);
        },
        extra: (callback1, callback2) => {
          extra(editor, undoManager, index, callback1, callback2);
        }
      };
      if (!isRtc(editor)) {
        registerEvents(editor, undoManager, locks);
      }
      addKeyboardShortcuts(editor);
      return undoManager;
    };

    const nonTypingKeycodes = [
      9,
      27,
      VK.HOME,
      VK.END,
      19,
      20,
      44,
      144,
      145,
      33,
      34,
      45,
      16,
      17,
      18,
      91,
      92,
      93,
      VK.DOWN,
      VK.UP,
      VK.LEFT,
      VK.RIGHT
    ].concat(Env.browser.isFirefox() ? [224] : []);
    const placeholderAttr = 'data-mce-placeholder';
    const isKeyboardEvent = e => e.type === 'keydown' || e.type === 'keyup';
    const isDeleteEvent = e => {
      const keyCode = e.keyCode;
      return keyCode === VK.BACKSPACE || keyCode === VK.DELETE;
    };
    const isNonTypingKeyboardEvent = e => {
      if (isKeyboardEvent(e)) {
        const keyCode = e.keyCode;
        return !isDeleteEvent(e) && (VK.metaKeyPressed(e) || e.altKey || keyCode >= 112 && keyCode <= 123 || contains$2(nonTypingKeycodes, keyCode));
      } else {
        return false;
      }
    };
    const isTypingKeyboardEvent = e => isKeyboardEvent(e) && !(isDeleteEvent(e) || e.type === 'keyup' && e.keyCode === 229);
    const isVisuallyEmpty = (dom, rootElm, forcedRootBlock) => {
      if (isEmpty$2(SugarElement.fromDom(rootElm), false)) {
        const firstElement = rootElm.firstElementChild;
        if (!firstElement) {
          return true;
        } else if (dom.getStyle(rootElm.firstElementChild, 'padding-left') || dom.getStyle(rootElm.firstElementChild, 'padding-right')) {
          return false;
        } else {
          return forcedRootBlock === firstElement.nodeName.toLowerCase();
        }
      } else {
        return false;
      }
    };
    const setup$q = editor => {
      var _a;
      const dom = editor.dom;
      const rootBlock = getForcedRootBlock(editor);
      const placeholder = (_a = getPlaceholder(editor)) !== null && _a !== void 0 ? _a : '';
      const updatePlaceholder = (e, initial) => {
        if (isNonTypingKeyboardEvent(e)) {
          return;
        }
        const body = editor.getBody();
        const showPlaceholder = isTypingKeyboardEvent(e) ? false : isVisuallyEmpty(dom, body, rootBlock);
        const isPlaceholderShown = dom.getAttrib(body, placeholderAttr) !== '';
        if (isPlaceholderShown !== showPlaceholder || initial) {
          dom.setAttrib(body, placeholderAttr, showPlaceholder ? placeholder : null);
          dom.setAttrib(body, 'aria-placeholder', showPlaceholder ? placeholder : null);
          firePlaceholderToggle(editor, showPlaceholder);
          editor.on(showPlaceholder ? 'keydown' : 'keyup', updatePlaceholder);
          editor.off(showPlaceholder ? 'keyup' : 'keydown', updatePlaceholder);
        }
      };
      if (isNotEmpty(placeholder)) {
        editor.on('init', e => {
          updatePlaceholder(e, true);
          editor.on('change SetContent ExecCommand', updatePlaceholder);
          editor.on('paste', e => Delay.setEditorTimeout(editor, () => updatePlaceholder(e)));
        });
      }
    };

    const blockPosition = (block, position) => ({
      block,
      position
    });
    const blockBoundary = (from, to) => ({
      from,
      to
    });
    const getBlockPosition = (rootNode, pos) => {
      const rootElm = SugarElement.fromDom(rootNode);
      const containerElm = SugarElement.fromDom(pos.container());
      return getParentBlock$2(rootElm, containerElm).map(block => blockPosition(block, pos));
    };
    const isDifferentBlocks = blockBoundary => !eq(blockBoundary.from.block, blockBoundary.to.block);
    const getClosestHost = (root, scope) => {
      const isRoot = node => eq(node, root);
      const isHost = node => isTableCell$2(node) || isContentEditableTrue$3(node.dom);
      return closest$4(scope, isHost, isRoot).filter(isElement$7).getOr(root);
    };
    const hasSameHost = (rootNode, blockBoundary) => {
      const root = SugarElement.fromDom(rootNode);
      return eq(getClosestHost(root, blockBoundary.from.block), getClosestHost(root, blockBoundary.to.block));
    };
    const isEditable$1 = blockBoundary => isContentEditableFalse$b(blockBoundary.from.block.dom) === false && isContentEditableFalse$b(blockBoundary.to.block.dom) === false;
    const hasValidBlocks = blockBoundary => {
      const isValidBlock = block => isTextBlock$2(block) || hasBlockAttr(block.dom);
      return isValidBlock(blockBoundary.from.block) && isValidBlock(blockBoundary.to.block);
    };
    const skipLastBr = (rootNode, forward, blockPosition) => {
      if (isBr$6(blockPosition.position.getNode()) && !isEmpty$2(blockPosition.block)) {
        return positionIn(false, blockPosition.block.dom).bind(lastPositionInBlock => {
          if (lastPositionInBlock.isEqual(blockPosition.position)) {
            return fromPosition(forward, rootNode, lastPositionInBlock).bind(to => getBlockPosition(rootNode, to));
          } else {
            return Optional.some(blockPosition);
          }
        }).getOr(blockPosition);
      } else {
        return blockPosition;
      }
    };
    const readFromRange = (rootNode, forward, rng) => {
      const fromBlockPos = getBlockPosition(rootNode, CaretPosition.fromRangeStart(rng));
      const toBlockPos = fromBlockPos.bind(blockPos => fromPosition(forward, rootNode, blockPos.position).bind(to => getBlockPosition(rootNode, to).map(blockPos => skipLastBr(rootNode, forward, blockPos))));
      return lift2(fromBlockPos, toBlockPos, blockBoundary).filter(blockBoundary => isDifferentBlocks(blockBoundary) && hasSameHost(rootNode, blockBoundary) && isEditable$1(blockBoundary) && hasValidBlocks(blockBoundary));
    };
    const read$1 = (rootNode, forward, rng) => rng.collapsed ? readFromRange(rootNode, forward, rng) : Optional.none();

    const getChildrenUntilBlockBoundary = block => {
      const children = children$1(block);
      return findIndex$2(children, isBlock$2).fold(constant(children), index => children.slice(0, index));
    };
    const extractChildren = block => {
      const children = getChildrenUntilBlockBoundary(block);
      each$e(children, remove$6);
      return children;
    };
    const removeEmptyRoot = (rootNode, block) => {
      const parents = parentsAndSelf(block, rootNode);
      return find$2(parents.reverse(), element => isEmpty$2(element)).each(remove$6);
    };
    const isEmptyBefore = el => filter$5(prevSiblings(el), el => !isEmpty$2(el)).length === 0;
    const nestedBlockMerge = (rootNode, fromBlock, toBlock, insertionPoint) => {
      if (isEmpty$2(toBlock)) {
        fillWithPaddingBr(toBlock);
        return firstPositionIn(toBlock.dom);
      }
      if (isEmptyBefore(insertionPoint) && isEmpty$2(fromBlock)) {
        before$3(insertionPoint, SugarElement.fromTag('br'));
      }
      const position = prevPosition(toBlock.dom, CaretPosition.before(insertionPoint.dom));
      each$e(extractChildren(fromBlock), child => {
        before$3(insertionPoint, child);
      });
      removeEmptyRoot(rootNode, fromBlock);
      return position;
    };
    const sidelongBlockMerge = (rootNode, fromBlock, toBlock) => {
      if (isEmpty$2(toBlock)) {
        if (isEmpty$2(fromBlock)) {
          const getInlineToBlockDescendants = el => {
            const helper = (node, elements) => firstChild(node).fold(() => elements, child => isInline$1(child) ? helper(child, elements.concat(shallow$1(child))) : elements);
            return helper(el, []);
          };
          const newFromBlockDescendants = foldr(getInlineToBlockDescendants(toBlock), (element, descendant) => {
            wrap$2(element, descendant);
            return descendant;
          }, createPaddingBr());
          empty(fromBlock);
          append$1(fromBlock, newFromBlockDescendants);
        }
        remove$6(toBlock);
        return firstPositionIn(fromBlock.dom);
      }
      const position = lastPositionIn(toBlock.dom);
      each$e(extractChildren(fromBlock), child => {
        append$1(toBlock, child);
      });
      removeEmptyRoot(rootNode, fromBlock);
      return position;
    };
    const findInsertionPoint = (toBlock, block) => {
      const parentsAndSelf$1 = parentsAndSelf(block, toBlock);
      return Optional.from(parentsAndSelf$1[parentsAndSelf$1.length - 1]);
    };
    const getInsertionPoint = (fromBlock, toBlock) => contains(toBlock, fromBlock) ? findInsertionPoint(toBlock, fromBlock) : Optional.none();
    const trimBr = (first, block) => {
      positionIn(first, block.dom).bind(position => Optional.from(position.getNode())).map(SugarElement.fromDom).filter(isBr$5).each(remove$6);
    };
    const mergeBlockInto = (rootNode, fromBlock, toBlock) => {
      trimBr(true, fromBlock);
      trimBr(false, toBlock);
      return getInsertionPoint(fromBlock, toBlock).fold(curry(sidelongBlockMerge, rootNode, fromBlock, toBlock), curry(nestedBlockMerge, rootNode, fromBlock, toBlock));
    };
    const mergeBlocks = (rootNode, forward, block1, block2) => forward ? mergeBlockInto(rootNode, block2, block1) : mergeBlockInto(rootNode, block1, block2);

    const backspaceDelete$8 = (editor, forward) => {
      const rootNode = SugarElement.fromDom(editor.getBody());
      const position = read$1(rootNode.dom, forward, editor.selection.getRng()).map(blockBoundary => () => {
        mergeBlocks(rootNode, forward, blockBoundary.from.block, blockBoundary.to.block).each(pos => {
          editor.selection.setRng(pos.toRange());
        });
      });
      return position;
    };

    const deleteRangeMergeBlocks = (rootNode, selection) => {
      const rng = selection.getRng();
      return lift2(getParentBlock$2(rootNode, SugarElement.fromDom(rng.startContainer)), getParentBlock$2(rootNode, SugarElement.fromDom(rng.endContainer)), (block1, block2) => {
        if (!eq(block1, block2)) {
          return Optional.some(() => {
            rng.deleteContents();
            mergeBlocks(rootNode, true, block1, block2).each(pos => {
              selection.setRng(pos.toRange());
            });
          });
        } else {
          return Optional.none();
        }
      }).getOr(Optional.none());
    };
    const isRawNodeInTable = (root, rawNode) => {
      const node = SugarElement.fromDom(rawNode);
      const isRoot = curry(eq, root);
      return ancestor$4(node, isTableCell$2, isRoot).isSome();
    };
    const isSelectionInTable = (root, rng) => isRawNodeInTable(root, rng.startContainer) || isRawNodeInTable(root, rng.endContainer);
    const isEverythingSelected = (root, rng) => {
      const noPrevious = prevPosition(root.dom, CaretPosition.fromRangeStart(rng)).isNone();
      const noNext = nextPosition(root.dom, CaretPosition.fromRangeEnd(rng)).isNone();
      return !isSelectionInTable(root, rng) && noPrevious && noNext;
    };
    const emptyEditor = editor => {
      return Optional.some(() => {
        editor.setContent('');
        editor.selection.setCursorLocation();
      });
    };
    const deleteRange$2 = editor => {
      const rootNode = SugarElement.fromDom(editor.getBody());
      const rng = editor.selection.getRng();
      return isEverythingSelected(rootNode, rng) ? emptyEditor(editor) : deleteRangeMergeBlocks(rootNode, editor.selection);
    };
    const backspaceDelete$7 = (editor, _forward) => editor.selection.isCollapsed() ? Optional.none() : deleteRange$2(editor);

    const showCaret = (direction, editor, node, before, scrollIntoView) => Optional.from(editor._selectionOverrides.showCaret(direction, node, before, scrollIntoView));
    const getNodeRange = node => {
      const rng = node.ownerDocument.createRange();
      rng.selectNode(node);
      return rng;
    };
    const selectNode = (editor, node) => {
      const e = editor.dispatch('BeforeObjectSelected', { target: node });
      if (e.isDefaultPrevented()) {
        return Optional.none();
      }
      return Optional.some(getNodeRange(node));
    };
    const renderCaretAtRange = (editor, range, scrollIntoView) => {
      const normalizedRange = normalizeRange(1, editor.getBody(), range);
      const caretPosition = CaretPosition.fromRangeStart(normalizedRange);
      const caretPositionNode = caretPosition.getNode();
      if (isInlineFakeCaretTarget(caretPositionNode)) {
        return showCaret(1, editor, caretPositionNode, !caretPosition.isAtEnd(), false);
      }
      const caretPositionBeforeNode = caretPosition.getNode(true);
      if (isInlineFakeCaretTarget(caretPositionBeforeNode)) {
        return showCaret(1, editor, caretPositionBeforeNode, false, false);
      }
      const ceRoot = getContentEditableRoot$1(editor.dom.getRoot(), caretPosition.getNode());
      if (isInlineFakeCaretTarget(ceRoot)) {
        return showCaret(1, editor, ceRoot, false, scrollIntoView);
      }
      return Optional.none();
    };
    const renderRangeCaret = (editor, range, scrollIntoView) => range.collapsed ? renderCaretAtRange(editor, range, scrollIntoView).getOr(range) : range;

    const isBeforeBoundary = pos => isBeforeContentEditableFalse(pos) || isBeforeMedia(pos);
    const isAfterBoundary = pos => isAfterContentEditableFalse(pos) || isAfterMedia(pos);
    const trimEmptyTextNode = (dom, node) => {
      if (isText$a(node) && node.data.length === 0) {
        dom.remove(node);
      }
    };
    const deleteContentAndShowCaret = (editor, range, node, direction, forward, peekCaretPosition) => {
      showCaret(direction, editor, peekCaretPosition.getNode(!forward), forward, true).each(caretRange => {
        if (range.collapsed) {
          const deleteRange = range.cloneRange();
          if (forward) {
            deleteRange.setEnd(caretRange.startContainer, caretRange.startOffset);
          } else {
            deleteRange.setStart(caretRange.endContainer, caretRange.endOffset);
          }
          deleteRange.deleteContents();
        } else {
          range.deleteContents();
        }
        editor.selection.setRng(caretRange);
      });
      trimEmptyTextNode(editor.dom, node);
    };
    const deleteBoundaryText = (editor, forward) => {
      const range = editor.selection.getRng();
      if (!isText$a(range.commonAncestorContainer)) {
        return Optional.none();
      }
      const direction = forward ? HDirection.Forwards : HDirection.Backwards;
      const caretWalker = CaretWalker(editor.getBody());
      const getNextPosFn = curry(getVisualCaretPosition, forward ? caretWalker.next : caretWalker.prev);
      const isBeforeFn = forward ? isBeforeBoundary : isAfterBoundary;
      const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);
      const nextCaretPosition = getNextPosFn(caretPosition);
      const normalizedNextCaretPosition = nextCaretPosition ? normalizePosition(forward, nextCaretPosition) : nextCaretPosition;
      if (!normalizedNextCaretPosition || !isMoveInsideSameBlock(caretPosition, normalizedNextCaretPosition)) {
        return Optional.none();
      } else if (isBeforeFn(normalizedNextCaretPosition)) {
        return Optional.some(() => deleteContentAndShowCaret(editor, range, caretPosition.getNode(), direction, forward, normalizedNextCaretPosition));
      }
      const peekCaretPosition = getNextPosFn(normalizedNextCaretPosition);
      if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {
        if (isMoveInsideSameBlock(normalizedNextCaretPosition, peekCaretPosition)) {
          return Optional.some(() => deleteContentAndShowCaret(editor, range, caretPosition.getNode(), direction, forward, peekCaretPosition));
        }
      }
      return Optional.none();
    };
    const backspaceDelete$6 = (editor, forward) => deleteBoundaryText(editor, forward);

    const getEdgeCefPosition = (editor, atStart) => {
      const root = editor.getBody();
      return atStart ? firstPositionIn(root).filter(isBeforeContentEditableFalse) : lastPositionIn(root).filter(isAfterContentEditableFalse);
    };
    const isCefAtEdgeSelected = editor => {
      const rng = editor.selection.getRng();
      return !rng.collapsed && (getEdgeCefPosition(editor, true).exists(pos => pos.isEqual(CaretPosition.fromRangeStart(rng))) || getEdgeCefPosition(editor, false).exists(pos => pos.isEqual(CaretPosition.fromRangeEnd(rng))));
    };

    const isCompoundElement = node => isNonNullable(node) && (isTableCell$2(SugarElement.fromDom(node)) || isListItem$1(SugarElement.fromDom(node)));
    const DeleteAction = Adt.generate([
      { remove: ['element'] },
      { moveToElement: ['element'] },
      { moveToPosition: ['position'] }
    ]);
    const isAtContentEditableBlockCaret = (forward, from) => {
      const elm = from.getNode(!forward);
      const caretLocation = forward ? 'after' : 'before';
      return isElement$6(elm) && elm.getAttribute('data-mce-caret') === caretLocation;
    };
    const isDeleteFromCefDifferentBlocks = (root, forward, from, to) => {
      const inSameBlock = elm => isInline$1(SugarElement.fromDom(elm)) && !isInSameBlock(from, to, root);
      return getRelativeCefElm(!forward, from).fold(() => getRelativeCefElm(forward, to).fold(never, inSameBlock), inSameBlock);
    };
    const deleteEmptyBlockOrMoveToCef = (root, forward, from, to) => {
      const toCefElm = to.getNode(!forward);
      return getParentBlock$2(SugarElement.fromDom(root), SugarElement.fromDom(from.getNode())).map(blockElm => isEmpty$2(blockElm) ? DeleteAction.remove(blockElm.dom) : DeleteAction.moveToElement(toCefElm)).orThunk(() => Optional.some(DeleteAction.moveToElement(toCefElm)));
    };
    const findCefPosition = (root, forward, from) => fromPosition(forward, root, from).bind(to => {
      if (isCompoundElement(to.getNode())) {
        return Optional.none();
      } else if (isDeleteFromCefDifferentBlocks(root, forward, from, to)) {
        return Optional.none();
      } else if (forward && isContentEditableFalse$b(to.getNode())) {
        return deleteEmptyBlockOrMoveToCef(root, forward, from, to);
      } else if (!forward && isContentEditableFalse$b(to.getNode(true))) {
        return deleteEmptyBlockOrMoveToCef(root, forward, from, to);
      } else if (forward && isAfterContentEditableFalse(from)) {
        return Optional.some(DeleteAction.moveToPosition(to));
      } else if (!forward && isBeforeContentEditableFalse(from)) {
        return Optional.some(DeleteAction.moveToPosition(to));
      } else {
        return Optional.none();
      }
    });
    const getContentEditableBlockAction = (forward, elm) => {
      if (isNullable(elm)) {
        return Optional.none();
      } else if (forward && isContentEditableFalse$b(elm.nextSibling)) {
        return Optional.some(DeleteAction.moveToElement(elm.nextSibling));
      } else if (!forward && isContentEditableFalse$b(elm.previousSibling)) {
        return Optional.some(DeleteAction.moveToElement(elm.previousSibling));
      } else {
        return Optional.none();
      }
    };
    const skipMoveToActionFromInlineCefToContent = (root, from, deleteAction) => deleteAction.fold(elm => Optional.some(DeleteAction.remove(elm)), elm => Optional.some(DeleteAction.moveToElement(elm)), to => {
      if (isInSameBlock(from, to, root)) {
        return Optional.none();
      } else {
        return Optional.some(DeleteAction.moveToPosition(to));
      }
    });
    const getContentEditableAction = (root, forward, from) => {
      if (isAtContentEditableBlockCaret(forward, from)) {
        return getContentEditableBlockAction(forward, from.getNode(!forward)).orThunk(() => findCefPosition(root, forward, from));
      } else {
        return findCefPosition(root, forward, from).bind(deleteAction => skipMoveToActionFromInlineCefToContent(root, from, deleteAction));
      }
    };
    const read = (root, forward, rng) => {
      const normalizedRange = normalizeRange(forward ? 1 : -1, root, rng);
      const from = CaretPosition.fromRangeStart(normalizedRange);
      const rootElement = SugarElement.fromDom(root);
      if (!forward && isAfterContentEditableFalse(from)) {
        return Optional.some(DeleteAction.remove(from.getNode(true)));
      } else if (forward && isBeforeContentEditableFalse(from)) {
        return Optional.some(DeleteAction.remove(from.getNode()));
      } else if (!forward && isBeforeContentEditableFalse(from) && isAfterBr(rootElement, from)) {
        return findPreviousBr(rootElement, from).map(br => DeleteAction.remove(br.getNode()));
      } else if (forward && isAfterContentEditableFalse(from) && isBeforeBr$1(rootElement, from)) {
        return findNextBr(rootElement, from).map(br => DeleteAction.remove(br.getNode()));
      } else {
        return getContentEditableAction(root, forward, from);
      }
    };

    const deleteElement$1 = (editor, forward) => element => {
      editor._selectionOverrides.hideFakeCaret();
      deleteElement$2(editor, forward, SugarElement.fromDom(element));
      return true;
    };
    const moveToElement = (editor, forward) => element => {
      const pos = forward ? CaretPosition.before(element) : CaretPosition.after(element);
      editor.selection.setRng(pos.toRange());
      return true;
    };
    const moveToPosition = editor => pos => {
      editor.selection.setRng(pos.toRange());
      return true;
    };
    const getAncestorCe = (editor, node) => Optional.from(getContentEditableRoot$1(editor.getBody(), node));
    const backspaceDeleteCaret = (editor, forward) => {
      const selectedNode = editor.selection.getNode();
      return getAncestorCe(editor, selectedNode).filter(isContentEditableFalse$b).fold(() => read(editor.getBody(), forward, editor.selection.getRng()).map(deleteAction => () => deleteAction.fold(deleteElement$1(editor, forward), moveToElement(editor, forward), moveToPosition(editor))), () => Optional.some(noop));
    };
    const deleteOffscreenSelection = rootElement => {
      each$e(descendants(rootElement, '.mce-offscreen-selection'), remove$6);
    };
    const backspaceDeleteRange = (editor, forward) => {
      const selectedNode = editor.selection.getNode();
      if (isContentEditableFalse$b(selectedNode) && !isTableCell$3(selectedNode)) {
        const hasCefAncestor = getAncestorCe(editor, selectedNode.parentNode).filter(isContentEditableFalse$b);
        return hasCefAncestor.fold(() => Optional.some(() => {
          deleteOffscreenSelection(SugarElement.fromDom(editor.getBody()));
          deleteElement$2(editor, forward, SugarElement.fromDom(editor.selection.getNode()));
          paddEmptyBody(editor);
        }), () => Optional.some(noop));
      }
      if (isCefAtEdgeSelected(editor)) {
        return Optional.some(() => {
          deleteRangeContents(editor, editor.selection.getRng(), SugarElement.fromDom(editor.getBody()));
        });
      }
      return Optional.none();
    };
    const paddEmptyElement = editor => {
      const dom = editor.dom, selection = editor.selection;
      const ceRoot = getContentEditableRoot$1(editor.getBody(), selection.getNode());
      if (isContentEditableTrue$3(ceRoot) && dom.isBlock(ceRoot) && dom.isEmpty(ceRoot)) {
        const br = dom.create('br', { 'data-mce-bogus': '1' });
        dom.setHTML(ceRoot, '');
        ceRoot.appendChild(br);
        selection.setRng(CaretPosition.before(br).toRange());
      }
      return true;
    };
    const backspaceDelete$5 = (editor, forward) => {
      if (editor.selection.isCollapsed()) {
        return backspaceDeleteCaret(editor, forward);
      } else {
        return backspaceDeleteRange(editor, forward);
      }
    };

    const deleteCaret$2 = (editor, forward) => {
      const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());
      return fromPosition(forward, editor.getBody(), fromPos).filter(pos => forward ? isBeforeImageBlock(pos) : isAfterImageBlock(pos)).bind(pos => getChildNodeAtRelativeOffset(forward ? 0 : -1, pos)).map(elm => () => editor.selection.select(elm));
    };
    const backspaceDelete$4 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret$2(editor, forward) : Optional.none();

    const isText$2 = isText$a;
    const startsWithCaretContainer = node => isText$2(node) && node.data[0] === ZWSP$1;
    const endsWithCaretContainer = node => isText$2(node) && node.data[node.data.length - 1] === ZWSP$1;
    const createZwsp = node => {
      var _a;
      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;
      return doc.createTextNode(ZWSP$1);
    };
    const insertBefore = node => {
      var _a;
      if (isText$2(node.previousSibling)) {
        if (endsWithCaretContainer(node.previousSibling)) {
          return node.previousSibling;
        } else {
          node.previousSibling.appendData(ZWSP$1);
          return node.previousSibling;
        }
      } else if (isText$2(node)) {
        if (startsWithCaretContainer(node)) {
          return node;
        } else {
          node.insertData(0, ZWSP$1);
          return node;
        }
      } else {
        const newNode = createZwsp(node);
        (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(newNode, node);
        return newNode;
      }
    };
    const insertAfter = node => {
      var _a, _b;
      if (isText$2(node.nextSibling)) {
        if (startsWithCaretContainer(node.nextSibling)) {
          return node.nextSibling;
        } else {
          node.nextSibling.insertData(0, ZWSP$1);
          return node.nextSibling;
        }
      } else if (isText$2(node)) {
        if (endsWithCaretContainer(node)) {
          return node;
        } else {
          node.appendData(ZWSP$1);
          return node;
        }
      } else {
        const newNode = createZwsp(node);
        if (node.nextSibling) {
          (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(newNode, node.nextSibling);
        } else {
          (_b = node.parentNode) === null || _b === void 0 ? void 0 : _b.appendChild(newNode);
        }
        return newNode;
      }
    };
    const insertInline = (before, node) => before ? insertBefore(node) : insertAfter(node);
    const insertInlineBefore = curry(insertInline, true);
    const insertInlineAfter = curry(insertInline, false);

    const insertInlinePos = (pos, before) => {
      if (isText$a(pos.container())) {
        return insertInline(before, pos.container());
      } else {
        return insertInline(before, pos.getNode());
      }
    };
    const isPosCaretContainer = (pos, caret) => {
      const caretNode = caret.get();
      return caretNode && pos.container() === caretNode && isCaretContainerInline(caretNode);
    };
    const renderCaret = (caret, location) => location.fold(element => {
      remove$4(caret.get());
      const text = insertInlineBefore(element);
      caret.set(text);
      return Optional.some(CaretPosition(text, text.length - 1));
    }, element => firstPositionIn(element).map(pos => {
      if (!isPosCaretContainer(pos, caret)) {
        remove$4(caret.get());
        const text = insertInlinePos(pos, true);
        caret.set(text);
        return CaretPosition(text, 1);
      } else {
        const node = caret.get();
        return CaretPosition(node, 1);
      }
    }), element => lastPositionIn(element).map(pos => {
      if (!isPosCaretContainer(pos, caret)) {
        remove$4(caret.get());
        const text = insertInlinePos(pos, false);
        caret.set(text);
        return CaretPosition(text, text.length - 1);
      } else {
        const node = caret.get();
        return CaretPosition(node, node.length - 1);
      }
    }), element => {
      remove$4(caret.get());
      const text = insertInlineAfter(element);
      caret.set(text);
      return Optional.some(CaretPosition(text, 1));
    });

    const evaluateUntil = (fns, args) => {
      for (let i = 0; i < fns.length; i++) {
        const result = fns[i].apply(null, args);
        if (result.isSome()) {
          return result;
        }
      }
      return Optional.none();
    };

    const Location = Adt.generate([
      { before: ['element'] },
      { start: ['element'] },
      { end: ['element'] },
      { after: ['element'] }
    ]);
    const rescope$1 = (rootNode, node) => {
      const parentBlock = getParentBlock$3(node, rootNode);
      return parentBlock ? parentBlock : rootNode;
    };
    const before = (isInlineTarget, rootNode, pos) => {
      const nPos = normalizeForwards(pos);
      const scope = rescope$1(rootNode, nPos.container());
      return findRootInline(isInlineTarget, scope, nPos).fold(() => nextPosition(scope, nPos).bind(curry(findRootInline, isInlineTarget, scope)).map(inline => Location.before(inline)), Optional.none);
    };
    const isNotInsideFormatCaretContainer = (rootNode, elm) => getParentCaretContainer(rootNode, elm) === null;
    const findInsideRootInline = (isInlineTarget, rootNode, pos) => findRootInline(isInlineTarget, rootNode, pos).filter(curry(isNotInsideFormatCaretContainer, rootNode));
    const start$1 = (isInlineTarget, rootNode, pos) => {
      const nPos = normalizeBackwards(pos);
      return findInsideRootInline(isInlineTarget, rootNode, nPos).bind(inline => {
        const prevPos = prevPosition(inline, nPos);
        return prevPos.isNone() ? Optional.some(Location.start(inline)) : Optional.none();
      });
    };
    const end = (isInlineTarget, rootNode, pos) => {
      const nPos = normalizeForwards(pos);
      return findInsideRootInline(isInlineTarget, rootNode, nPos).bind(inline => {
        const nextPos = nextPosition(inline, nPos);
        return nextPos.isNone() ? Optional.some(Location.end(inline)) : Optional.none();
      });
    };
    const after = (isInlineTarget, rootNode, pos) => {
      const nPos = normalizeBackwards(pos);
      const scope = rescope$1(rootNode, nPos.container());
      return findRootInline(isInlineTarget, scope, nPos).fold(() => prevPosition(scope, nPos).bind(curry(findRootInline, isInlineTarget, scope)).map(inline => Location.after(inline)), Optional.none);
    };
    const isValidLocation = location => !isRtl(getElement(location));
    const readLocation = (isInlineTarget, rootNode, pos) => {
      const location = evaluateUntil([
        before,
        start$1,
        end,
        after
      ], [
        isInlineTarget,
        rootNode,
        pos
      ]);
      return location.filter(isValidLocation);
    };
    const getElement = location => location.fold(identity, identity, identity, identity);
    const getName = location => location.fold(constant('before'), constant('start'), constant('end'), constant('after'));
    const outside = location => location.fold(Location.before, Location.before, Location.after, Location.after);
    const inside = location => location.fold(Location.start, Location.start, Location.end, Location.end);
    const isEq = (location1, location2) => getName(location1) === getName(location2) && getElement(location1) === getElement(location2);
    const betweenInlines = (forward, isInlineTarget, rootNode, from, to, location) => lift2(findRootInline(isInlineTarget, rootNode, from), findRootInline(isInlineTarget, rootNode, to), (fromInline, toInline) => {
      if (fromInline !== toInline && hasSameParentBlock(rootNode, fromInline, toInline)) {
        return Location.after(forward ? fromInline : toInline);
      } else {
        return location;
      }
    }).getOr(location);
    const skipNoMovement = (fromLocation, toLocation) => fromLocation.fold(always, fromLocation => !isEq(fromLocation, toLocation));
    const findLocationTraverse = (forward, isInlineTarget, rootNode, fromLocation, pos) => {
      const from = normalizePosition(forward, pos);
      const to = fromPosition(forward, rootNode, from).map(curry(normalizePosition, forward));
      const location = to.fold(() => fromLocation.map(outside), to => readLocation(isInlineTarget, rootNode, to).map(curry(betweenInlines, forward, isInlineTarget, rootNode, from, to)).filter(curry(skipNoMovement, fromLocation)));
      return location.filter(isValidLocation);
    };
    const findLocationSimple = (forward, location) => {
      if (forward) {
        return location.fold(compose(Optional.some, Location.start), Optional.none, compose(Optional.some, Location.after), Optional.none);
      } else {
        return location.fold(Optional.none, compose(Optional.some, Location.before), Optional.none, compose(Optional.some, Location.end));
      }
    };
    const findLocation$1 = (forward, isInlineTarget, rootNode, pos) => {
      const from = normalizePosition(forward, pos);
      const fromLocation = readLocation(isInlineTarget, rootNode, from);
      return readLocation(isInlineTarget, rootNode, from).bind(curry(findLocationSimple, forward)).orThunk(() => findLocationTraverse(forward, isInlineTarget, rootNode, fromLocation, pos));
    };

    const hasSelectionModifyApi = editor => {
      return isFunction(editor.selection.getSel().modify);
    };
    const moveRel = (forward, selection, pos) => {
      const delta = forward ? 1 : -1;
      selection.setRng(CaretPosition(pos.container(), pos.offset() + delta).toRange());
      selection.getSel().modify('move', forward ? 'forward' : 'backward', 'word');
      return true;
    };
    const moveByWord = (forward, editor) => {
      const rng = editor.selection.getRng();
      const pos = forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);
      if (!hasSelectionModifyApi(editor)) {
        return false;
      } else if (forward && isBeforeInline(pos)) {
        return moveRel(true, editor.selection, pos);
      } else if (!forward && isAfterInline(pos)) {
        return moveRel(false, editor.selection, pos);
      } else {
        return false;
      }
    };

    var BreakType;
    (function (BreakType) {
      BreakType[BreakType['Br'] = 0] = 'Br';
      BreakType[BreakType['Block'] = 1] = 'Block';
      BreakType[BreakType['Wrap'] = 2] = 'Wrap';
      BreakType[BreakType['Eol'] = 3] = 'Eol';
    }(BreakType || (BreakType = {})));
    const flip = (direction, positions) => direction === HDirection.Backwards ? reverse(positions) : positions;
    const walk$1 = (direction, caretWalker, pos) => direction === HDirection.Forwards ? caretWalker.next(pos) : caretWalker.prev(pos);
    const getBreakType = (scope, direction, currentPos, nextPos) => {
      if (isBr$6(nextPos.getNode(direction === HDirection.Forwards))) {
        return BreakType.Br;
      } else if (isInSameBlock(currentPos, nextPos) === false) {
        return BreakType.Block;
      } else {
        return BreakType.Wrap;
      }
    };
    const getPositionsUntil = (predicate, direction, scope, start) => {
      const caretWalker = CaretWalker(scope);
      let currentPos = start;
      const positions = [];
      while (currentPos) {
        const nextPos = walk$1(direction, caretWalker, currentPos);
        if (!nextPos) {
          break;
        }
        if (isBr$6(nextPos.getNode(false))) {
          if (direction === HDirection.Forwards) {
            return {
              positions: flip(direction, positions).concat([nextPos]),
              breakType: BreakType.Br,
              breakAt: Optional.some(nextPos)
            };
          } else {
            return {
              positions: flip(direction, positions),
              breakType: BreakType.Br,
              breakAt: Optional.some(nextPos)
            };
          }
        }
        if (!nextPos.isVisible()) {
          currentPos = nextPos;
          continue;
        }
        if (predicate(currentPos, nextPos)) {
          const breakType = getBreakType(scope, direction, currentPos, nextPos);
          return {
            positions: flip(direction, positions),
            breakType,
            breakAt: Optional.some(nextPos)
          };
        }
        positions.push(nextPos);
        currentPos = nextPos;
      }
      return {
        positions: flip(direction, positions),
        breakType: BreakType.Eol,
        breakAt: Optional.none()
      };
    };
    const getAdjacentLinePositions = (direction, getPositionsUntilBreak, scope, start) => getPositionsUntilBreak(scope, start).breakAt.map(pos => {
      const positions = getPositionsUntilBreak(scope, pos).positions;
      return direction === HDirection.Backwards ? positions.concat(pos) : [pos].concat(positions);
    }).getOr([]);
    const findClosestHorizontalPositionFromPoint = (positions, x) => foldl(positions, (acc, newPos) => acc.fold(() => Optional.some(newPos), lastPos => lift2(head(lastPos.getClientRects()), head(newPos.getClientRects()), (lastRect, newRect) => {
      const lastDist = Math.abs(x - lastRect.left);
      const newDist = Math.abs(x - newRect.left);
      return newDist <= lastDist ? newPos : lastPos;
    }).or(acc)), Optional.none());
    const findClosestHorizontalPosition = (positions, pos) => head(pos.getClientRects()).bind(targetRect => findClosestHorizontalPositionFromPoint(positions, targetRect.left));
    const getPositionsUntilPreviousLine = curry(getPositionsUntil, CaretPosition.isAbove, -1);
    const getPositionsUntilNextLine = curry(getPositionsUntil, CaretPosition.isBelow, 1);
    const getPositionsAbove = curry(getAdjacentLinePositions, -1, getPositionsUntilPreviousLine);
    const getPositionsBelow = curry(getAdjacentLinePositions, 1, getPositionsUntilNextLine);
    const isAtFirstLine = (scope, pos) => getPositionsUntilPreviousLine(scope, pos).breakAt.isNone();
    const isAtLastLine = (scope, pos) => getPositionsUntilNextLine(scope, pos).breakAt.isNone();
    const getFirstLinePositions = scope => firstPositionIn(scope).map(pos => [pos].concat(getPositionsUntilNextLine(scope, pos).positions)).getOr([]);
    const getLastLinePositions = scope => lastPositionIn(scope).map(pos => getPositionsUntilPreviousLine(scope, pos).positions.concat(pos)).getOr([]);
    const getClosestPositionAbove = (scope, pos) => findClosestHorizontalPosition(getPositionsAbove(scope, pos), pos);
    const getClosestPositionBelow = (scope, pos) => findClosestHorizontalPosition(getPositionsBelow(scope, pos), pos);

    const isContentEditableFalse$4 = isContentEditableFalse$b;
    const distanceToRectLeft$1 = (clientRect, clientX) => Math.abs(clientRect.left - clientX);
    const distanceToRectRight$1 = (clientRect, clientX) => Math.abs(clientRect.right - clientX);
    const isNodeClientRect = rect => hasNonNullableKey(rect, 'node');
    const findClosestClientRect = (clientRects, clientX) => reduce(clientRects, (oldClientRect, clientRect) => {
      const oldDistance = Math.min(distanceToRectLeft$1(oldClientRect, clientX), distanceToRectRight$1(oldClientRect, clientX));
      const newDistance = Math.min(distanceToRectLeft$1(clientRect, clientX), distanceToRectRight$1(clientRect, clientX));
      if (newDistance === oldDistance && isNodeClientRect(clientRect) && isContentEditableFalse$4(clientRect.node)) {
        return clientRect;
      }
      if (newDistance < oldDistance) {
        return clientRect;
      }
      return oldClientRect;
    });

    const getNodeClientRects = node => {
      const toArrayWithNode = clientRects => {
        return map$3(clientRects, rect => {
          const clientRect = clone$1(rect);
          clientRect.node = node;
          return clientRect;
        });
      };
      if (isElement$6(node)) {
        return toArrayWithNode(node.getClientRects());
      } else if (isText$a(node)) {
        const rng = node.ownerDocument.createRange();
        rng.setStart(node, 0);
        rng.setEnd(node, node.data.length);
        return toArrayWithNode(rng.getClientRects());
      } else {
        return [];
      }
    };
    const getClientRects = nodes => bind$3(nodes, getNodeClientRects);

    var VDirection;
    (function (VDirection) {
      VDirection[VDirection['Up'] = -1] = 'Up';
      VDirection[VDirection['Down'] = 1] = 'Down';
    }(VDirection || (VDirection = {})));
    const findUntil = (direction, root, predicateFn, node) => {
      let currentNode = node;
      while (currentNode = findNode(currentNode, direction, isEditableCaretCandidate$1, root)) {
        if (predicateFn(currentNode)) {
          return;
        }
      }
    };
    const walkUntil = (direction, isAboveFn, isBeflowFn, root, predicateFn, caretPosition) => {
      let line = 0;
      const result = [];
      const add = node => {
        let clientRects = getClientRects([node]);
        if (direction === -1) {
          clientRects = clientRects.reverse();
        }
        for (let i = 0; i < clientRects.length; i++) {
          const clientRect = clientRects[i];
          if (isBeflowFn(clientRect, targetClientRect)) {
            continue;
          }
          if (result.length > 0 && isAboveFn(clientRect, last$2(result))) {
            line++;
          }
          clientRect.line = line;
          if (predicateFn(clientRect)) {
            return true;
          }
          result.push(clientRect);
        }
        return false;
      };
      const targetClientRect = last$2(caretPosition.getClientRects());
      if (!targetClientRect) {
        return result;
      }
      const node = caretPosition.getNode();
      if (node) {
        add(node);
        findUntil(direction, root, add, node);
      }
      return result;
    };
    const aboveLineNumber = (lineNumber, clientRect) => clientRect.line > lineNumber;
    const isLineNumber = (lineNumber, clientRect) => clientRect.line === lineNumber;
    const upUntil = curry(walkUntil, VDirection.Up, isAbove$1, isBelow$1);
    const downUntil = curry(walkUntil, VDirection.Down, isBelow$1, isAbove$1);
    const getLastClientRect = caretPosition => {
      return last$2(caretPosition.getClientRects());
    };
    const positionsUntil = (direction, root, predicateFn, node) => {
      const caretWalker = CaretWalker(root);
      let walkFn;
      let isBelowFn;
      let isAboveFn;
      let caretPosition;
      const result = [];
      let line = 0;
      if (direction === 1) {
        walkFn = caretWalker.next;
        isBelowFn = isBelow$1;
        isAboveFn = isAbove$1;
        caretPosition = CaretPosition.after(node);
      } else {
        walkFn = caretWalker.prev;
        isBelowFn = isAbove$1;
        isAboveFn = isBelow$1;
        caretPosition = CaretPosition.before(node);
      }
      const targetClientRect = getLastClientRect(caretPosition);
      do {
        if (!caretPosition.isVisible()) {
          continue;
        }
        const rect = getLastClientRect(caretPosition);
        if (isAboveFn(rect, targetClientRect)) {
          continue;
        }
        if (result.length > 0 && isBelowFn(rect, last$2(result))) {
          line++;
        }
        const clientRect = clone$1(rect);
        clientRect.position = caretPosition;
        clientRect.line = line;
        if (predicateFn(clientRect)) {
          return result;
        }
        result.push(clientRect);
      } while (caretPosition = walkFn(caretPosition));
      return result;
    };
    const isAboveLine = lineNumber => clientRect => aboveLineNumber(lineNumber, clientRect);
    const isLine = lineNumber => clientRect => isLineNumber(lineNumber, clientRect);

    const moveToRange = (editor, rng) => {
      editor.selection.setRng(rng);
      scrollRangeIntoView(editor, editor.selection.getRng());
    };
    const renderRangeCaretOpt = (editor, range, scrollIntoView) => Optional.some(renderRangeCaret(editor, range, scrollIntoView));
    const moveHorizontally = (editor, direction, range, isBefore, isAfter, isElement) => {
      const forwards = direction === HDirection.Forwards;
      const caretWalker = CaretWalker(editor.getBody());
      const getNextPosFn = curry(getVisualCaretPosition, forwards ? caretWalker.next : caretWalker.prev);
      const isBeforeFn = forwards ? isBefore : isAfter;
      if (!range.collapsed) {
        const node = getSelectedNode(range);
        if (isElement(node)) {
          return showCaret(direction, editor, node, direction === HDirection.Backwards, false);
        } else if (isCefAtEdgeSelected(editor)) {
          const newRange = range.cloneRange();
          newRange.collapse(direction === HDirection.Backwards);
          return Optional.from(newRange);
        }
      }
      const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);
      if (isBeforeFn(caretPosition)) {
        return selectNode(editor, caretPosition.getNode(!forwards));
      }
      let nextCaretPosition = getNextPosFn(caretPosition);
      const rangeIsInContainerBlock = isRangeInCaretContainerBlock(range);
      if (!nextCaretPosition) {
        return rangeIsInContainerBlock ? Optional.some(range) : Optional.none();
      } else {
        nextCaretPosition = normalizePosition(forwards, nextCaretPosition);
      }
      if (isBeforeFn(nextCaretPosition)) {
        return showCaret(direction, editor, nextCaretPosition.getNode(!forwards), forwards, false);
      }
      const peekCaretPosition = getNextPosFn(nextCaretPosition);
      if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {
        if (isMoveInsideSameBlock(nextCaretPosition, peekCaretPosition)) {
          return showCaret(direction, editor, peekCaretPosition.getNode(!forwards), forwards, false);
        }
      }
      if (rangeIsInContainerBlock) {
        return renderRangeCaretOpt(editor, nextCaretPosition.toRange(), false);
      }
      return Optional.none();
    };
    const moveVertically = (editor, direction, range, isBefore, isAfter, isElement) => {
      const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);
      const caretClientRect = last$2(caretPosition.getClientRects());
      const forwards = direction === VDirection.Down;
      const root = editor.getBody();
      if (!caretClientRect) {
        return Optional.none();
      }
      if (isCefAtEdgeSelected(editor)) {
        const caretPosition = forwards ? CaretPosition.fromRangeEnd(range) : CaretPosition.fromRangeStart(range);
        const getClosestFn = !forwards ? getClosestPositionAbove : getClosestPositionBelow;
        return getClosestFn(root, caretPosition).orThunk(() => Optional.from(caretPosition)).map(pos => pos.toRange());
      }
      const walkerFn = forwards ? downUntil : upUntil;
      const linePositions = walkerFn(root, isAboveLine(1), caretPosition);
      const nextLinePositions = filter$5(linePositions, isLine(1));
      const clientX = caretClientRect.left;
      const nextLineRect = findClosestClientRect(nextLinePositions, clientX);
      if (nextLineRect && isElement(nextLineRect.node)) {
        const dist1 = Math.abs(clientX - nextLineRect.left);
        const dist2 = Math.abs(clientX - nextLineRect.right);
        return showCaret(direction, editor, nextLineRect.node, dist1 < dist2, false);
      }
      let currentNode;
      if (isBefore(caretPosition)) {
        currentNode = caretPosition.getNode();
      } else if (isAfter(caretPosition)) {
        currentNode = caretPosition.getNode(true);
      } else {
        currentNode = getSelectedNode(range);
      }
      if (currentNode) {
        const caretPositions = positionsUntil(direction, root, isAboveLine(1), currentNode);
        let closestNextLineRect = findClosestClientRect(filter$5(caretPositions, isLine(1)), clientX);
        if (closestNextLineRect) {
          return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);
        }
        closestNextLineRect = last$2(filter$5(caretPositions, isLine(0)));
        if (closestNextLineRect) {
          return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);
        }
      }
      if (nextLinePositions.length === 0) {
        return getLineEndPoint(editor, forwards).filter(forwards ? isAfter : isBefore).map(pos => renderRangeCaret(editor, pos.toRange(), false));
      }
      return Optional.none();
    };
    const getLineEndPoint = (editor, forward) => {
      const rng = editor.selection.getRng();
      const from = forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);
      const host = getEditingHost(from.container(), editor.getBody());
      if (forward) {
        const lineInfo = getPositionsUntilNextLine(host, from);
        return last$3(lineInfo.positions);
      } else {
        const lineInfo = getPositionsUntilPreviousLine(host, from);
        return head(lineInfo.positions);
      }
    };
    const moveToLineEndPoint$3 = (editor, forward, isElementPosition) => getLineEndPoint(editor, forward).filter(isElementPosition).exists(pos => {
      editor.selection.setRng(pos.toRange());
      return true;
    });

    const setCaretPosition = (editor, pos) => {
      const rng = editor.dom.createRng();
      rng.setStart(pos.container(), pos.offset());
      rng.setEnd(pos.container(), pos.offset());
      editor.selection.setRng(rng);
    };
    const setSelected = (state, elm) => {
      if (state) {
        elm.setAttribute('data-mce-selected', 'inline-boundary');
      } else {
        elm.removeAttribute('data-mce-selected');
      }
    };
    const renderCaretLocation = (editor, caret, location) => renderCaret(caret, location).map(pos => {
      setCaretPosition(editor, pos);
      return location;
    });
    const getPositionFromRange = (range, root, forward) => {
      const start = CaretPosition.fromRangeStart(range);
      if (range.collapsed) {
        return start;
      } else {
        const end = CaretPosition.fromRangeEnd(range);
        return forward ? prevPosition(root, end).getOr(end) : nextPosition(root, start).getOr(start);
      }
    };
    const findLocation = (editor, caret, forward) => {
      const rootNode = editor.getBody();
      const from = getPositionFromRange(editor.selection.getRng(), rootNode, forward);
      const isInlineTarget$1 = curry(isInlineTarget, editor);
      const location = findLocation$1(forward, isInlineTarget$1, rootNode, from);
      return location.bind(location => renderCaretLocation(editor, caret, location));
    };
    const toggleInlines = (isInlineTarget, dom, elms) => {
      const inlineBoundaries = map$3(descendants(SugarElement.fromDom(dom.getRoot()), '*[data-mce-selected="inline-boundary"]'), e => e.dom);
      const selectedInlines = filter$5(inlineBoundaries, isInlineTarget);
      const targetInlines = filter$5(elms, isInlineTarget);
      each$e(difference(selectedInlines, targetInlines), curry(setSelected, false));
      each$e(difference(targetInlines, selectedInlines), curry(setSelected, true));
    };
    const safeRemoveCaretContainer = (editor, caret) => {
      const caretValue = caret.get();
      if (editor.selection.isCollapsed() && !editor.composing && caretValue) {
        const pos = CaretPosition.fromRangeStart(editor.selection.getRng());
        if (CaretPosition.isTextPosition(pos) && !isAtZwsp(pos)) {
          setCaretPosition(editor, removeAndReposition(caretValue, pos));
          caret.set(null);
        }
      }
    };
    const renderInsideInlineCaret = (isInlineTarget, editor, caret, elms) => {
      if (editor.selection.isCollapsed()) {
        const inlines = filter$5(elms, isInlineTarget);
        each$e(inlines, _inline => {
          const pos = CaretPosition.fromRangeStart(editor.selection.getRng());
          readLocation(isInlineTarget, editor.getBody(), pos).bind(location => renderCaretLocation(editor, caret, location));
        });
      }
    };
    const move$2 = (editor, caret, forward) => isInlineBoundariesEnabled(editor) ? findLocation(editor, caret, forward).isSome() : false;
    const moveWord = (forward, editor, _caret) => isInlineBoundariesEnabled(editor) ? moveByWord(forward, editor) : false;
    const setupSelectedState = editor => {
      const caret = Cell(null);
      const isInlineTarget$1 = curry(isInlineTarget, editor);
      editor.on('NodeChange', e => {
        if (isInlineBoundariesEnabled(editor)) {
          toggleInlines(isInlineTarget$1, editor.dom, e.parents);
          safeRemoveCaretContainer(editor, caret);
          renderInsideInlineCaret(isInlineTarget$1, editor, caret, e.parents);
        }
      });
      return caret;
    };
    const moveNextWord = curry(moveWord, true);
    const movePrevWord = curry(moveWord, false);
    const moveToLineEndPoint$2 = (editor, forward, caret) => {
      if (isInlineBoundariesEnabled(editor)) {
        const linePoint = getLineEndPoint(editor, forward).getOrThunk(() => {
          const rng = editor.selection.getRng();
          return forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);
        });
        return readLocation(curry(isInlineTarget, editor), editor.getBody(), linePoint).exists(loc => {
          const outsideLoc = outside(loc);
          return renderCaret(caret, outsideLoc).exists(pos => {
            setCaretPosition(editor, pos);
            return true;
          });
        });
      } else {
        return false;
      }
    };

    const rangeFromPositions = (from, to) => {
      const range = document.createRange();
      range.setStart(from.container(), from.offset());
      range.setEnd(to.container(), to.offset());
      return range;
    };
    const hasOnlyTwoOrLessPositionsLeft = elm => lift2(firstPositionIn(elm), lastPositionIn(elm), (firstPos, lastPos) => {
      const normalizedFirstPos = normalizePosition(true, firstPos);
      const normalizedLastPos = normalizePosition(false, lastPos);
      return nextPosition(elm, normalizedFirstPos).forall(pos => pos.isEqual(normalizedLastPos));
    }).getOr(true);
    const setCaretLocation = (editor, caret) => location => renderCaret(caret, location).map(pos => () => setCaretPosition(editor, pos));
    const deleteFromTo = (editor, caret, from, to) => {
      const rootNode = editor.getBody();
      const isInlineTarget$1 = curry(isInlineTarget, editor);
      editor.undoManager.ignore(() => {
        editor.selection.setRng(rangeFromPositions(from, to));
        execNativeDeleteCommand(editor);
        readLocation(isInlineTarget$1, rootNode, CaretPosition.fromRangeStart(editor.selection.getRng())).map(inside).bind(setCaretLocation(editor, caret)).each(call);
      });
      editor.nodeChanged();
    };
    const rescope = (rootNode, node) => {
      const parentBlock = getParentBlock$3(node, rootNode);
      return parentBlock ? parentBlock : rootNode;
    };
    const backspaceDeleteCollapsed = (editor, caret, forward, from) => {
      const rootNode = rescope(editor.getBody(), from.container());
      const isInlineTarget$1 = curry(isInlineTarget, editor);
      const fromLocation = readLocation(isInlineTarget$1, rootNode, from);
      const location = fromLocation.bind(location => {
        if (forward) {
          return location.fold(constant(Optional.some(inside(location))), Optional.none, constant(Optional.some(outside(location))), Optional.none);
        } else {
          return location.fold(Optional.none, constant(Optional.some(outside(location))), Optional.none, constant(Optional.some(inside(location))));
        }
      });
      return location.map(setCaretLocation(editor, caret)).getOrThunk(() => {
        const toPosition = navigate(forward, rootNode, from);
        const toLocation = toPosition.bind(pos => readLocation(isInlineTarget$1, rootNode, pos));
        return lift2(fromLocation, toLocation, () => findRootInline(isInlineTarget$1, rootNode, from).bind(elm => {
          if (hasOnlyTwoOrLessPositionsLeft(elm)) {
            return Optional.some(() => {
              deleteElement$2(editor, forward, SugarElement.fromDom(elm));
            });
          } else {
            return Optional.none();
          }
        })).getOrThunk(() => toLocation.bind(() => toPosition.map(to => {
          return () => {
            if (forward) {
              deleteFromTo(editor, caret, from, to);
            } else {
              deleteFromTo(editor, caret, to, from);
            }
          };
        })));
      });
    };
    const backspaceDelete$3 = (editor, caret, forward) => {
      if (editor.selection.isCollapsed() && isInlineBoundariesEnabled(editor)) {
        const from = CaretPosition.fromRangeStart(editor.selection.getRng());
        return backspaceDeleteCollapsed(editor, caret, forward, from);
      }
      return Optional.none();
    };

    const hasMultipleChildren = elm => childNodesCount(elm) > 1;
    const getParentsUntil = (editor, pred) => {
      const rootElm = SugarElement.fromDom(editor.getBody());
      const startElm = SugarElement.fromDom(editor.selection.getStart());
      const parents = parentsAndSelf(startElm, rootElm);
      return findIndex$2(parents, pred).fold(constant(parents), index => parents.slice(0, index));
    };
    const getParentInlinesUntilMultichildInline = editor => getParentsUntil(editor, elm => isBlock$2(elm) || hasMultipleChildren(elm));
    const getParentInlines = editor => getParentsUntil(editor, isBlock$2);
    const getFormatNodes = (editor, parentInlines) => {
      const isFormatElement$1 = curry(isFormatElement, editor);
      return bind$3(parentInlines, elm => isFormatElement$1(elm) ? [elm.dom] : []);
    };
    const getFormatNodesAtStart = editor => {
      const parentInlines = getParentInlines(editor);
      return getFormatNodes(editor, parentInlines);
    };
    const deleteLastPosition = (forward, editor, target, parentInlines) => {
      const formatNodes = getFormatNodes(editor, parentInlines);
      if (formatNodes.length === 0) {
        deleteElement$2(editor, forward, target);
      } else {
        const pos = replaceWithCaretFormat(target.dom, formatNodes);
        editor.selection.setRng(pos.toRange());
      }
    };
    const deleteCaret$1 = (editor, forward) => {
      const parentInlines = getParentInlinesUntilMultichildInline(editor);
      return last$3(parentInlines).bind(target => {
        const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());
        if (willDeleteLastPositionInElement(forward, fromPos, target.dom) && !isEmptyCaretFormatElement(target)) {
          return Optional.some(() => deleteLastPosition(forward, editor, target, parentInlines));
        } else {
          return Optional.none();
        }
      });
    };
    const isBrInEmptyElement = (editor, elm) => {
      const parentElm = elm.parentElement;
      return isBr$6(elm) && !isNull(parentElm) && editor.dom.isEmpty(parentElm);
    };
    const isEmptyCaret = elm => isEmptyCaretFormatElement(SugarElement.fromDom(elm));
    const createCaretFormatAtStart = (editor, formatNodes) => {
      const startElm = editor.selection.getStart();
      const pos = isBrInEmptyElement(editor, startElm) || isEmptyCaret(startElm) ? replaceWithCaretFormat(startElm, formatNodes) : createCaretFormatAtStart$1(editor, formatNodes);
      editor.selection.setRng(pos.toRange());
    };
    const updateCaretFormat = (editor, updateFormats) => {
      const missingFormats = difference(updateFormats, getFormatNodesAtStart(editor));
      if (missingFormats.length > 0) {
        createCaretFormatAtStart(editor, missingFormats);
      }
    };
    const rangeStartsAtTextContainer = rng => isText$a(rng.startContainer);
    const rangeStartsAtStartOfTextContainer = rng => rng.startOffset === 0 && rangeStartsAtTextContainer(rng);
    const rangeStartParentIsFormatElement = (editor, rng) => {
      const startParent = rng.startContainer.parentElement;
      return !isNull(startParent) && isFormatElement(editor, SugarElement.fromDom(startParent));
    };
    const rangeStartAndEndHaveSameParent = rng => {
      const startParent = rng.startContainer.parentNode;
      const endParent = rng.endContainer.parentNode;
      return !isNull(startParent) && !isNull(endParent) && startParent.isEqualNode(endParent);
    };
    const rangeEndsAtEndOfEndContainer = rng => {
      const endContainer = rng.endContainer;
      return rng.endOffset === (isText$a(endContainer) ? endContainer.length : endContainer.childNodes.length);
    };
    const rangeEndsAtEndOfStartContainer = rng => rangeStartAndEndHaveSameParent(rng) && rangeEndsAtEndOfEndContainer(rng);
    const rangeEndsAfterEndOfStartContainer = rng => !rng.endContainer.isEqualNode(rng.commonAncestorContainer);
    const rangeEndsAtOrAfterEndOfStartContainer = rng => rangeEndsAtEndOfStartContainer(rng) || rangeEndsAfterEndOfStartContainer(rng);
    const requiresDeleteRangeOverride = editor => {
      const rng = editor.selection.getRng();
      return rangeStartsAtStartOfTextContainer(rng) && rangeStartParentIsFormatElement(editor, rng) && rangeEndsAtOrAfterEndOfStartContainer(rng);
    };
    const deleteRange$1 = editor => {
      if (requiresDeleteRangeOverride(editor)) {
        const formatNodes = getFormatNodesAtStart(editor);
        return Optional.some(() => {
          execNativeDeleteCommand(editor);
          updateCaretFormat(editor, formatNodes);
        });
      } else {
        return Optional.none();
      }
    };
    const backspaceDelete$2 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret$1(editor, forward) : deleteRange$1(editor);
    const hasAncestorInlineCaret = elm => ancestor$1(elm, node => isCaretNode(node.dom), isBlock$2);
    const hasAncestorInlineCaretAtStart = editor => hasAncestorInlineCaret(SugarElement.fromDom(editor.selection.getStart()));
    const requiresRefreshCaretOverride = editor => {
      const rng = editor.selection.getRng();
      return rng.collapsed && (rangeStartsAtTextContainer(rng) || editor.dom.isEmpty(rng.startContainer)) && !hasAncestorInlineCaretAtStart(editor);
    };
    const refreshCaret = editor => {
      if (requiresRefreshCaretOverride(editor)) {
        createCaretFormatAtStart(editor, []);
      }
      return true;
    };

    const deleteElement = (editor, forward, element) => {
      if (isNonNullable(element)) {
        return Optional.some(() => {
          editor._selectionOverrides.hideFakeCaret();
          deleteElement$2(editor, forward, SugarElement.fromDom(element));
        });
      } else {
        return Optional.none();
      }
    };
    const deleteCaret = (editor, forward) => {
      const isNearMedia = forward ? isBeforeMedia : isAfterMedia;
      const direction = forward ? HDirection.Forwards : HDirection.Backwards;
      const fromPos = getNormalizedRangeEndPoint(direction, editor.getBody(), editor.selection.getRng());
      if (isNearMedia(fromPos)) {
        return deleteElement(editor, forward, fromPos.getNode(!forward));
      } else {
        return Optional.from(normalizePosition(forward, fromPos)).filter(pos => isNearMedia(pos) && isMoveInsideSameBlock(fromPos, pos)).bind(pos => deleteElement(editor, forward, pos.getNode(!forward)));
      }
    };
    const deleteRange = (editor, forward) => {
      const selectedNode = editor.selection.getNode();
      return isMedia$2(selectedNode) ? deleteElement(editor, forward, selectedNode) : Optional.none();
    };
    const backspaceDelete$1 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret(editor, forward) : deleteRange(editor, forward);

    const isEditable = target => closest$4(target, elm => isContentEditableTrue$3(elm.dom) || isContentEditableFalse$b(elm.dom)).exists(elm => isContentEditableTrue$3(elm.dom));
    const parseIndentValue = value => toInt(value !== null && value !== void 0 ? value : '').getOr(0);
    const getIndentStyleName = (useMargin, element) => {
      const indentStyleName = useMargin || isTable$1(element) ? 'margin' : 'padding';
      const suffix = get$7(element, 'direction') === 'rtl' ? '-right' : '-left';
      return indentStyleName + suffix;
    };
    const indentElement = (dom, command, useMargin, value, unit, element) => {
      const indentStyleName = getIndentStyleName(useMargin, SugarElement.fromDom(element));
      const parsedValue = parseIndentValue(dom.getStyle(element, indentStyleName));
      if (command === 'outdent') {
        const styleValue = Math.max(0, parsedValue - value);
        dom.setStyle(element, indentStyleName, styleValue ? styleValue + unit : '');
      } else {
        const styleValue = parsedValue + value + unit;
        dom.setStyle(element, indentStyleName, styleValue);
      }
    };
    const validateBlocks = (editor, blocks) => forall(blocks, block => {
      const indentStyleName = getIndentStyleName(shouldIndentUseMargin(editor), block);
      const intentValue = getRaw(block, indentStyleName).map(parseIndentValue).getOr(0);
      const contentEditable = editor.dom.getContentEditable(block.dom);
      return contentEditable !== 'false' && intentValue > 0;
    });
    const canOutdent = editor => {
      const blocks = getBlocksToIndent(editor);
      return !editor.mode.isReadOnly() && (blocks.length > 1 || validateBlocks(editor, blocks));
    };
    const isListComponent = el => isList(el) || isListItem$1(el);
    const parentIsListComponent = el => parent(el).exists(isListComponent);
    const getBlocksToIndent = editor => filter$5(fromDom$1(editor.selection.getSelectedBlocks()), el => !isListComponent(el) && !parentIsListComponent(el) && isEditable(el));
    const handle = (editor, command) => {
      var _a, _b;
      const {dom} = editor;
      const indentation = getIndentation(editor);
      const indentUnit = (_b = (_a = /[a-z%]+$/i.exec(indentation)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : 'px';
      const indentValue = parseIndentValue(indentation);
      const useMargin = shouldIndentUseMargin(editor);
      each$e(getBlocksToIndent(editor), block => {
        indentElement(dom, command, useMargin, indentValue, indentUnit, block.dom);
      });
    };
    const indent = editor => handle(editor, 'indent');
    const outdent = editor => handle(editor, 'outdent');

    const backspaceDelete = editor => {
      if (editor.selection.isCollapsed() && canOutdent(editor)) {
        const dom = editor.dom;
        const rng = editor.selection.getRng();
        const pos = CaretPosition.fromRangeStart(rng);
        const block = dom.getParent(rng.startContainer, dom.isBlock);
        if (block !== null && isAtStartOfBlock(SugarElement.fromDom(block), pos)) {
          return Optional.some(() => outdent(editor));
        }
      }
      return Optional.none();
    };

    const findAction = (editor, caret, forward) => findMap([
      backspaceDelete,
      backspaceDelete$5,
      backspaceDelete$6,
      (editor, forward) => backspaceDelete$3(editor, caret, forward),
      backspaceDelete$8,
      backspaceDelete$9,
      backspaceDelete$4,
      backspaceDelete$1,
      backspaceDelete$7,
      backspaceDelete$2
    ], item => item(editor, forward)).filter(_ => editor.selection.isEditable());
    const deleteCommand = (editor, caret) => {
      const result = findAction(editor, caret, false);
      result.fold(() => {
        execNativeDeleteCommand(editor);
        paddEmptyBody(editor);
      }, call);
    };
    const forwardDeleteCommand = (editor, caret) => {
      const result = findAction(editor, caret, true);
      result.fold(() => execNativeForwardDeleteCommand(editor), call);
    };
    const setup$p = (editor, caret) => {
      editor.addCommand('delete', () => {
        deleteCommand(editor, caret);
      });
      editor.addCommand('forwardDelete', () => {
        forwardDeleteCommand(editor, caret);
      });
    };

    const SIGNIFICANT_MOVE = 5;
    const LONGPRESS_DELAY = 400;
    const getTouch = event => {
      if (event.touches === undefined || event.touches.length !== 1) {
        return Optional.none();
      }
      return Optional.some(event.touches[0]);
    };
    const isFarEnough = (touch, data) => {
      const distX = Math.abs(touch.clientX - data.x);
      const distY = Math.abs(touch.clientY - data.y);
      return distX > SIGNIFICANT_MOVE || distY > SIGNIFICANT_MOVE;
    };
    const setup$o = editor => {
      const startData = value$2();
      const longpressFired = Cell(false);
      const debounceLongpress = last$1(e => {
        editor.dispatch('longpress', {
          ...e,
          type: 'longpress'
        });
        longpressFired.set(true);
      }, LONGPRESS_DELAY);
      editor.on('touchstart', e => {
        getTouch(e).each(touch => {
          debounceLongpress.cancel();
          const data = {
            x: touch.clientX,
            y: touch.clientY,
            target: e.target
          };
          debounceLongpress.throttle(e);
          longpressFired.set(false);
          startData.set(data);
        });
      }, true);
      editor.on('touchmove', e => {
        debounceLongpress.cancel();
        getTouch(e).each(touch => {
          startData.on(data => {
            if (isFarEnough(touch, data)) {
              startData.clear();
              longpressFired.set(false);
              editor.dispatch('longpresscancel');
            }
          });
        });
      }, true);
      editor.on('touchend touchcancel', e => {
        debounceLongpress.cancel();
        if (e.type === 'touchcancel') {
          return;
        }
        startData.get().filter(data => data.target.isEqualNode(e.target)).each(() => {
          if (longpressFired.get()) {
            e.preventDefault();
          } else {
            editor.dispatch('tap', {
              ...e,
              type: 'tap'
            });
          }
        });
      }, true);
    };

    const isBlockElement = (blockElements, node) => has$2(blockElements, node.nodeName);
    const isValidTarget = (schema, node) => {
      if (isText$a(node)) {
        return true;
      } else if (isElement$6(node)) {
        return !isBlockElement(schema.getBlockElements(), node) && !isBookmarkNode$1(node) && !isTransparentBlock(schema, node);
      } else {
        return false;
      }
    };
    const hasBlockParent = (blockElements, root, node) => {
      return exists(parents(SugarElement.fromDom(node), SugarElement.fromDom(root)), elm => {
        return isBlockElement(blockElements, elm.dom);
      });
    };
    const shouldRemoveTextNode = (blockElements, node) => {
      if (isText$a(node)) {
        if (node.data.length === 0) {
          return true;
        } else if (/^\s+$/.test(node.data) && (!node.nextSibling || isBlockElement(blockElements, node.nextSibling))) {
          return true;
        }
      }
      return false;
    };
    const createRootBlock = editor => editor.dom.create(getForcedRootBlock(editor), getForcedRootBlockAttrs(editor));
    const addRootBlocks = editor => {
      const dom = editor.dom, selection = editor.selection;
      const schema = editor.schema;
      const blockElements = schema.getBlockElements();
      const startNode = selection.getStart();
      const rootNode = editor.getBody();
      let rootBlockNode;
      let tempNode;
      let wrapped = false;
      const forcedRootBlock = getForcedRootBlock(editor);
      if (!startNode || !isElement$6(startNode)) {
        return;
      }
      const rootNodeName = rootNode.nodeName.toLowerCase();
      if (!schema.isValidChild(rootNodeName, forcedRootBlock.toLowerCase()) || hasBlockParent(blockElements, rootNode, startNode)) {
        return;
      }
      const rng = selection.getRng();
      const {startContainer, startOffset, endContainer, endOffset} = rng;
      const restoreSelection = hasFocus(editor);
      let node = rootNode.firstChild;
      while (node) {
        if (isElement$6(node)) {
          updateElement(schema, node);
        }
        if (isValidTarget(schema, node)) {
          if (shouldRemoveTextNode(blockElements, node)) {
            tempNode = node;
            node = node.nextSibling;
            dom.remove(tempNode);
            continue;
          }
          if (!rootBlockNode) {
            rootBlockNode = createRootBlock(editor);
            rootNode.insertBefore(rootBlockNode, node);
            wrapped = true;
          }
          tempNode = node;
          node = node.nextSibling;
          rootBlockNode.appendChild(tempNode);
        } else {
          rootBlockNode = null;
          node = node.nextSibling;
        }
      }
      if (wrapped && restoreSelection) {
        rng.setStart(startContainer, startOffset);
        rng.setEnd(endContainer, endOffset);
        selection.setRng(rng);
        editor.nodeChanged();
      }
    };
    const insertEmptyLine = (editor, root, insertBlock) => {
      const block = SugarElement.fromDom(createRootBlock(editor));
      const br = createPaddingBr();
      append$1(block, br);
      insertBlock(root, block);
      const rng = document.createRange();
      rng.setStartBefore(br.dom);
      rng.setEndBefore(br.dom);
      return rng;
    };
    const setup$n = editor => {
      editor.on('NodeChange', curry(addRootBlocks, editor));
    };

    const hasClass = checkClassName => node => (' ' + node.attr('class') + ' ').indexOf(checkClassName) !== -1;
    const replaceMatchWithSpan = (editor, content, cls) => {
      return function (match) {
        const args = arguments, index = args[args.length - 2];
        const prevChar = index > 0 ? content.charAt(index - 1) : '';
        if (prevChar === '"') {
          return match;
        }
        if (prevChar === '>') {
          const findStartTagIndex = content.lastIndexOf('<', index);
          if (findStartTagIndex !== -1) {
            const tagHtml = content.substring(findStartTagIndex, index);
            if (tagHtml.indexOf('contenteditable="false"') !== -1) {
              return match;
            }
          }
        }
        return '<span class="' + cls + '" data-mce-content="' + editor.dom.encode(args[0]) + '">' + editor.dom.encode(typeof args[1] === 'string' ? args[1] : args[0]) + '</span>';
      };
    };
    const convertRegExpsToNonEditable = (editor, nonEditableRegExps, e) => {
      let i = nonEditableRegExps.length, content = e.content;
      if (e.format === 'raw') {
        return;
      }
      while (i--) {
        content = content.replace(nonEditableRegExps[i], replaceMatchWithSpan(editor, content, getNonEditableClass(editor)));
      }
      e.content = content;
    };
    const setup$m = editor => {
      const contentEditableAttrName = 'contenteditable';
      const editClass = ' ' + Tools.trim(getEditableClass(editor)) + ' ';
      const nonEditClass = ' ' + Tools.trim(getNonEditableClass(editor)) + ' ';
      const hasEditClass = hasClass(editClass);
      const hasNonEditClass = hasClass(nonEditClass);
      const nonEditableRegExps = getNonEditableRegExps(editor);
      if (nonEditableRegExps.length > 0) {
        editor.on('BeforeSetContent', e => {
          convertRegExpsToNonEditable(editor, nonEditableRegExps, e);
        });
      }
      editor.parser.addAttributeFilter('class', nodes => {
        let i = nodes.length;
        while (i--) {
          const node = nodes[i];
          if (hasEditClass(node)) {
            node.attr(contentEditableAttrName, 'true');
          } else if (hasNonEditClass(node)) {
            node.attr(contentEditableAttrName, 'false');
          }
        }
      });
      editor.serializer.addAttributeFilter(contentEditableAttrName, nodes => {
        let i = nodes.length;
        while (i--) {
          const node = nodes[i];
          if (!hasEditClass(node) && !hasNonEditClass(node)) {
            continue;
          }
          if (nonEditableRegExps.length > 0 && node.attr('data-mce-content')) {
            node.name = '#text';
            node.type = 3;
            node.raw = true;
            node.value = node.attr('data-mce-content');
          } else {
            node.attr(contentEditableAttrName, null);
          }
        }
      });
    };

    const findBlockCaretContainer = editor => descendant(SugarElement.fromDom(editor.getBody()), '*[data-mce-caret]').map(elm => elm.dom).getOrNull();
    const showBlockCaretContainer = (editor, blockCaretContainer) => {
      if (blockCaretContainer.hasAttribute('data-mce-caret')) {
        showCaretContainerBlock(blockCaretContainer);
        editor.selection.setRng(editor.selection.getRng());
        editor.selection.scrollIntoView(blockCaretContainer);
      }
    };
    const handleBlockContainer = (editor, e) => {
      const blockCaretContainer = findBlockCaretContainer(editor);
      if (!blockCaretContainer) {
        return;
      }
      if (e.type === 'compositionstart') {
        e.preventDefault();
        e.stopPropagation();
        showBlockCaretContainer(editor, blockCaretContainer);
        return;
      }
      if (hasContent(blockCaretContainer)) {
        showBlockCaretContainer(editor, blockCaretContainer);
        editor.undoManager.add();
      }
    };
    const setup$l = editor => {
      editor.on('keyup compositionstart', curry(handleBlockContainer, editor));
    };

    const isContentEditableFalse$3 = isContentEditableFalse$b;
    const moveToCeFalseHorizontally = (direction, editor, range) => moveHorizontally(editor, direction, range, isBeforeContentEditableFalse, isAfterContentEditableFalse, isContentEditableFalse$3);
    const moveToCeFalseVertically = (direction, editor, range) => {
      const isBefore = caretPosition => isBeforeContentEditableFalse(caretPosition) || isBeforeTable(caretPosition);
      const isAfter = caretPosition => isAfterContentEditableFalse(caretPosition) || isAfterTable(caretPosition);
      return moveVertically(editor, direction, range, isBefore, isAfter, isContentEditableFalse$3);
    };
    const createTextBlock = editor => {
      const textBlock = editor.dom.create(getForcedRootBlock(editor));
      textBlock.innerHTML = '<br data-mce-bogus="1">';
      return textBlock;
    };
    const exitPreBlock = (editor, direction, range) => {
      const caretWalker = CaretWalker(editor.getBody());
      const getVisualCaretPosition$1 = curry(getVisualCaretPosition, direction === 1 ? caretWalker.next : caretWalker.prev);
      if (range.collapsed) {
        const pre = editor.dom.getParent(range.startContainer, 'PRE');
        if (!pre) {
          return;
        }
        const caretPos = getVisualCaretPosition$1(CaretPosition.fromRangeStart(range));
        if (!caretPos) {
          const newBlock = SugarElement.fromDom(createTextBlock(editor));
          if (direction === 1) {
            after$4(SugarElement.fromDom(pre), newBlock);
          } else {
            before$3(SugarElement.fromDom(pre), newBlock);
          }
          editor.selection.select(newBlock.dom, true);
          editor.selection.collapse();
        }
      }
    };
    const getHorizontalRange = (editor, forward) => {
      const direction = forward ? HDirection.Forwards : HDirection.Backwards;
      const range = editor.selection.getRng();
      return moveToCeFalseHorizontally(direction, editor, range).orThunk(() => {
        exitPreBlock(editor, direction, range);
        return Optional.none();
      });
    };
    const getVerticalRange = (editor, down) => {
      const direction = down ? 1 : -1;
      const range = editor.selection.getRng();
      return moveToCeFalseVertically(direction, editor, range).orThunk(() => {
        exitPreBlock(editor, direction, range);
        return Optional.none();
      });
    };
    const moveH$2 = (editor, forward) => getHorizontalRange(editor, forward).exists(newRange => {
      moveToRange(editor, newRange);
      return true;
    });
    const moveV$3 = (editor, down) => getVerticalRange(editor, down).exists(newRange => {
      moveToRange(editor, newRange);
      return true;
    });
    const moveToLineEndPoint$1 = (editor, forward) => {
      const isCefPosition = forward ? isAfterContentEditableFalse : isBeforeContentEditableFalse;
      return moveToLineEndPoint$3(editor, forward, isCefPosition);
    };
    const selectToEndPoint = (editor, forward) => getEdgeCefPosition(editor, !forward).map(pos => {
      const rng = pos.toRange();
      const curRng = editor.selection.getRng();
      if (forward) {
        rng.setStart(curRng.startContainer, curRng.startOffset);
      } else {
        rng.setEnd(curRng.endContainer, curRng.endOffset);
      }
      return rng;
    }).exists(rng => {
      moveToRange(editor, rng);
      return true;
    });

    const isTarget = node => contains$2(['figcaption'], name(node));
    const getClosestTargetBlock = (pos, root) => {
      const isRoot = curry(eq, root);
      return closest$4(SugarElement.fromDom(pos.container()), isBlock$2, isRoot).filter(isTarget);
    };
    const isAtFirstOrLastLine = (root, forward, pos) => forward ? isAtLastLine(root.dom, pos) : isAtFirstLine(root.dom, pos);
    const moveCaretToNewEmptyLine = (editor, forward) => {
      const root = SugarElement.fromDom(editor.getBody());
      const pos = CaretPosition.fromRangeStart(editor.selection.getRng());
      return getClosestTargetBlock(pos, root).exists(() => {
        if (isAtFirstOrLastLine(root, forward, pos)) {
          const insertFn = forward ? append$1 : prepend;
          const rng = insertEmptyLine(editor, root, insertFn);
          editor.selection.setRng(rng);
          return true;
        } else {
          return false;
        }
      });
    };
    const moveV$2 = (editor, forward) => {
      if (editor.selection.isCollapsed()) {
        return moveCaretToNewEmptyLine(editor, forward);
      } else {
        return false;
      }
    };

    const baseKeyPattern = {
      shiftKey: false,
      altKey: false,
      ctrlKey: false,
      metaKey: false,
      keyCode: 0
    };
    const defaultPatterns = patterns => map$3(patterns, pattern => ({
      ...baseKeyPattern,
      ...pattern
    }));
    const defaultDelayedPatterns = patterns => map$3(patterns, pattern => ({
      ...baseKeyPattern,
      ...pattern
    }));
    const matchesEvent = (pattern, evt) => evt.keyCode === pattern.keyCode && evt.shiftKey === pattern.shiftKey && evt.altKey === pattern.altKey && evt.ctrlKey === pattern.ctrlKey && evt.metaKey === pattern.metaKey;
    const match$1 = (patterns, evt) => bind$3(defaultPatterns(patterns), pattern => matchesEvent(pattern, evt) ? [pattern] : []);
    const matchDelayed = (patterns, evt) => bind$3(defaultDelayedPatterns(patterns), pattern => matchesEvent(pattern, evt) ? [pattern] : []);
    const action = (f, ...x) => () => f.apply(null, x);
    const execute = (patterns, evt) => find$2(match$1(patterns, evt), pattern => pattern.action());
    const executeWithDelayedAction = (patterns, evt) => findMap(matchDelayed(patterns, evt), pattern => pattern.action());

    const moveH$1 = (editor, forward) => {
      const direction = forward ? HDirection.Forwards : HDirection.Backwards;
      const range = editor.selection.getRng();
      return moveHorizontally(editor, direction, range, isBeforeMedia, isAfterMedia, isMedia$2).exists(newRange => {
        moveToRange(editor, newRange);
        return true;
      });
    };
    const moveV$1 = (editor, down) => {
      const direction = down ? 1 : -1;
      const range = editor.selection.getRng();
      return moveVertically(editor, direction, range, isBeforeMedia, isAfterMedia, isMedia$2).exists(newRange => {
        moveToRange(editor, newRange);
        return true;
      });
    };
    const moveToLineEndPoint = (editor, forward) => {
      const isNearMedia = forward ? isAfterMedia : isBeforeMedia;
      return moveToLineEndPoint$3(editor, forward, isNearMedia);
    };

    const adt = Adt.generate([
      { none: ['current'] },
      { first: ['current'] },
      {
        middle: [
          'current',
          'target'
        ]
      },
      { last: ['current'] }
    ]);
    const none = current => adt.none(current);
    const CellLocation = {
      ...adt,
      none
    };

    const firstLayer = (scope, selector) => {
      return filterFirstLayer(scope, selector, always);
    };
    const filterFirstLayer = (scope, selector, predicate) => {
      return bind$3(children$1(scope), x => {
        if (is$1(x, selector)) {
          return predicate(x) ? [x] : [];
        } else {
          return filterFirstLayer(x, selector, predicate);
        }
      });
    };

    const lookup$1 = (tags, element, isRoot = never) => {
      if (isRoot(element)) {
        return Optional.none();
      }
      if (contains$2(tags, name(element))) {
        return Optional.some(element);
      }
      const isRootOrUpperTable = elm => is$1(elm, 'table') || isRoot(elm);
      return ancestor$3(element, tags.join(','), isRootOrUpperTable);
    };
    const cell = (element, isRoot) => lookup$1([
      'td',
      'th'
    ], element, isRoot);
    const cells = ancestor => firstLayer(ancestor, 'th,td');
    const table = (element, isRoot) => closest$3(element, 'table', isRoot);

    const walk = (all, current, index, direction, isEligible = always) => {
      const forwards = direction === 1;
      if (!forwards && index <= 0) {
        return CellLocation.first(all[0]);
      } else if (forwards && index >= all.length - 1) {
        return CellLocation.last(all[all.length - 1]);
      } else {
        const newIndex = index + direction;
        const elem = all[newIndex];
        return isEligible(elem) ? CellLocation.middle(current, elem) : walk(all, current, newIndex, direction, isEligible);
      }
    };
    const detect = (current, isRoot) => {
      return table(current, isRoot).bind(table => {
        const all = cells(table);
        const index = findIndex$2(all, x => eq(current, x));
        return index.map(index => ({
          index,
          all
        }));
      });
    };
    const next = (current, isEligible, isRoot) => {
      const detection = detect(current, isRoot);
      return detection.fold(() => {
        return CellLocation.none(current);
      }, info => {
        return walk(info.all, current, info.index, 1, isEligible);
      });
    };
    const prev = (current, isEligible, isRoot) => {
      const detection = detect(current, isRoot);
      return detection.fold(() => {
        return CellLocation.none();
      }, info => {
        return walk(info.all, current, info.index, -1, isEligible);
      });
    };

    const deflate = (rect, delta) => ({
      left: rect.left - delta,
      top: rect.top - delta,
      right: rect.right + delta * 2,
      bottom: rect.bottom + delta * 2,
      width: rect.width + delta,
      height: rect.height + delta
    });
    const getCorners = (getYAxisValue, tds) => bind$3(tds, td => {
      const rect = deflate(clone$1(td.getBoundingClientRect()), -1);
      return [
        {
          x: rect.left,
          y: getYAxisValue(rect),
          cell: td
        },
        {
          x: rect.right,
          y: getYAxisValue(rect),
          cell: td
        }
      ];
    });
    const findClosestCorner = (corners, x, y) => foldl(corners, (acc, newCorner) => acc.fold(() => Optional.some(newCorner), oldCorner => {
      const oldDist = Math.sqrt(Math.abs(oldCorner.x - x) + Math.abs(oldCorner.y - y));
      const newDist = Math.sqrt(Math.abs(newCorner.x - x) + Math.abs(newCorner.y - y));
      return Optional.some(newDist < oldDist ? newCorner : oldCorner);
    }), Optional.none());
    const getClosestCell = (getYAxisValue, isTargetCorner, table, x, y) => {
      const cells = descendants(SugarElement.fromDom(table), 'td,th,caption').map(e => e.dom);
      const corners = filter$5(getCorners(getYAxisValue, cells), corner => isTargetCorner(corner, y));
      return findClosestCorner(corners, x, y).map(corner => corner.cell);
    };
    const getBottomValue = rect => rect.bottom;
    const getTopValue = rect => rect.top;
    const isAbove = (corner, y) => corner.y < y;
    const isBelow = (corner, y) => corner.y > y;
    const getClosestCellAbove = curry(getClosestCell, getBottomValue, isAbove);
    const getClosestCellBelow = curry(getClosestCell, getTopValue, isBelow);
    const findClosestPositionInAboveCell = (table, pos) => head(pos.getClientRects()).bind(rect => getClosestCellAbove(table, rect.left, rect.top)).bind(cell => findClosestHorizontalPosition(getLastLinePositions(cell), pos));
    const findClosestPositionInBelowCell = (table, pos) => last$3(pos.getClientRects()).bind(rect => getClosestCellBelow(table, rect.left, rect.top)).bind(cell => findClosestHorizontalPosition(getFirstLinePositions(cell), pos));

    const hasNextBreak = (getPositionsUntil, scope, lineInfo) => lineInfo.breakAt.exists(breakPos => getPositionsUntil(scope, breakPos).breakAt.isSome());
    const startsWithWrapBreak = lineInfo => lineInfo.breakType === BreakType.Wrap && lineInfo.positions.length === 0;
    const startsWithBrBreak = lineInfo => lineInfo.breakType === BreakType.Br && lineInfo.positions.length === 1;
    const isAtTableCellLine = (getPositionsUntil, scope, pos) => {
      const lineInfo = getPositionsUntil(scope, pos);
      if (startsWithWrapBreak(lineInfo) || !isBr$6(pos.getNode()) && startsWithBrBreak(lineInfo)) {
        return !hasNextBreak(getPositionsUntil, scope, lineInfo);
      } else {
        return lineInfo.breakAt.isNone();
      }
    };
    const isAtFirstTableCellLine = curry(isAtTableCellLine, getPositionsUntilPreviousLine);
    const isAtLastTableCellLine = curry(isAtTableCellLine, getPositionsUntilNextLine);
    const isCaretAtStartOrEndOfTable = (forward, rng, table) => {
      const caretPos = CaretPosition.fromRangeStart(rng);
      return positionIn(!forward, table).exists(pos => pos.isEqual(caretPos));
    };
    const navigateHorizontally = (editor, forward, table, _td) => {
      const rng = editor.selection.getRng();
      const direction = forward ? 1 : -1;
      if (isFakeCaretTableBrowser() && isCaretAtStartOrEndOfTable(forward, rng, table)) {
        showCaret(direction, editor, table, !forward, false).each(newRng => {
          moveToRange(editor, newRng);
        });
        return true;
      }
      return false;
    };
    const getClosestAbovePosition = (root, table, start) => findClosestPositionInAboveCell(table, start).orThunk(() => head(start.getClientRects()).bind(rect => findClosestHorizontalPositionFromPoint(getPositionsAbove(root, CaretPosition.before(table)), rect.left))).getOr(CaretPosition.before(table));
    const getClosestBelowPosition = (root, table, start) => findClosestPositionInBelowCell(table, start).orThunk(() => head(start.getClientRects()).bind(rect => findClosestHorizontalPositionFromPoint(getPositionsBelow(root, CaretPosition.after(table)), rect.left))).getOr(CaretPosition.after(table));
    const getTable = (previous, pos) => {
      const node = pos.getNode(previous);
      return isTable$2(node) ? Optional.some(node) : Optional.none();
    };
    const renderBlock = (down, editor, table) => {
      editor.undoManager.transact(() => {
        const insertFn = down ? after$4 : before$3;
        const rng = insertEmptyLine(editor, SugarElement.fromDom(table), insertFn);
        moveToRange(editor, rng);
      });
    };
    const moveCaret = (editor, down, pos) => {
      const table = down ? getTable(true, pos) : getTable(false, pos);
      const last = down === false;
      table.fold(() => moveToRange(editor, pos.toRange()), table => positionIn(last, editor.getBody()).filter(lastPos => lastPos.isEqual(pos)).fold(() => moveToRange(editor, pos.toRange()), _ => renderBlock(down, editor, table)));
    };
    const navigateVertically = (editor, down, table, td) => {
      const rng = editor.selection.getRng();
      const pos = CaretPosition.fromRangeStart(rng);
      const root = editor.getBody();
      if (!down && isAtFirstTableCellLine(td, pos)) {
        const newPos = getClosestAbovePosition(root, table, pos);
        moveCaret(editor, down, newPos);
        return true;
      } else if (down && isAtLastTableCellLine(td, pos)) {
        const newPos = getClosestBelowPosition(root, table, pos);
        moveCaret(editor, down, newPos);
        return true;
      } else {
        return false;
      }
    };
    const move$1 = (editor, forward, mover) => Optional.from(editor.dom.getParent(editor.selection.getNode(), 'td,th')).bind(td => Optional.from(editor.dom.getParent(td, 'table')).map(table => mover(editor, forward, table, td))).getOr(false);
    const moveH = (editor, forward) => move$1(editor, forward, navigateHorizontally);
    const moveV = (editor, forward) => move$1(editor, forward, navigateVertically);
    const getCellFirstCursorPosition = cell => {
      const selection = SimSelection.exact(cell, 0, cell, 0);
      return toNative(selection);
    };
    const tabGo = (editor, isRoot, cell) => {
      return cell.fold(Optional.none, Optional.none, (_current, next) => {
        return first(next).map(cell => {
          return getCellFirstCursorPosition(cell);
        });
      }, current => {
        editor.execCommand('mceTableInsertRowAfter');
        return tabForward(editor, isRoot, current);
      });
    };
    const tabForward = (editor, isRoot, cell) => tabGo(editor, isRoot, next(cell, isEditable$3));
    const tabBackward = (editor, isRoot, cell) => tabGo(editor, isRoot, prev(cell, isEditable$3));
    const handleTab = (editor, forward) => {
      const rootElements = [
        'table',
        'li',
        'dl'
      ];
      const body = SugarElement.fromDom(editor.getBody());
      const isRoot = element => {
        const name$1 = name(element);
        return eq(element, body) || contains$2(rootElements, name$1);
      };
      const rng = editor.selection.getRng();
      const container = SugarElement.fromDom(!forward ? rng.startContainer : rng.endContainer);
      return cell(container, isRoot).map(cell => {
        table(cell, isRoot).each(table => {
          editor.model.table.clearSelectedCells(table.dom);
        });
        editor.selection.collapse(!forward);
        const navigation = !forward ? tabBackward : tabForward;
        const rng = navigation(editor, isRoot, cell);
        rng.each(range => {
          editor.selection.setRng(range);
        });
        return true;
      }).getOr(false);
    };

    const executeKeydownOverride$4 = (editor, caret, evt) => {
      const isMac = Env.os.isMacOS() || Env.os.isiOS();
      execute([
        {
          keyCode: VK.RIGHT,
          action: action(moveH$2, editor, true)
        },
        {
          keyCode: VK.LEFT,
          action: action(moveH$2, editor, false)
        },
        {
          keyCode: VK.UP,
          action: action(moveV$3, editor, false)
        },
        {
          keyCode: VK.DOWN,
          action: action(moveV$3, editor, true)
        },
        ...isMac ? [
          {
            keyCode: VK.UP,
            action: action(selectToEndPoint, editor, false),
            metaKey: true,
            shiftKey: true
          },
          {
            keyCode: VK.DOWN,
            action: action(selectToEndPoint, editor, true),
            metaKey: true,
            shiftKey: true
          }
        ] : [],
        {
          keyCode: VK.RIGHT,
          action: action(moveH, editor, true)
        },
        {
          keyCode: VK.LEFT,
          action: action(moveH, editor, false)
        },
        {
          keyCode: VK.UP,
          action: action(moveV, editor, false)
        },
        {
          keyCode: VK.DOWN,
          action: action(moveV, editor, true)
        },
        {
          keyCode: VK.RIGHT,
          action: action(moveH$1, editor, true)
        },
        {
          keyCode: VK.LEFT,
          action: action(moveH$1, editor, false)
        },
        {
          keyCode: VK.UP,
          action: action(moveV$1, editor, false)
        },
        {
          keyCode: VK.DOWN,
          action: action(moveV$1, editor, true)
        },
        {
          keyCode: VK.RIGHT,
          action: action(move$2, editor, caret, true)
        },
        {
          keyCode: VK.LEFT,
          action: action(move$2, editor, caret, false)
        },
        {
          keyCode: VK.RIGHT,
          ctrlKey: !isMac,
          altKey: isMac,
          action: action(moveNextWord, editor, caret)
        },
        {
          keyCode: VK.LEFT,
          ctrlKey: !isMac,
          altKey: isMac,
          action: action(movePrevWord, editor, caret)
        },
        {
          keyCode: VK.UP,
          action: action(moveV$2, editor, false)
        },
        {
          keyCode: VK.DOWN,
          action: action(moveV$2, editor, true)
        }
      ], evt).each(_ => {
        evt.preventDefault();
      });
    };
    const setup$k = (editor, caret) => {
      editor.on('keydown', evt => {
        if (!evt.isDefaultPrevented()) {
          executeKeydownOverride$4(editor, caret, evt);
        }
      });
    };

    const point = (container, offset) => ({
      container,
      offset
    });

    const DOM$7 = DOMUtils.DOM;
    const alwaysNext = startNode => node => startNode === node ? -1 : 0;
    const isBoundary = dom => node => dom.isBlock(node) || contains$2([
      'BR',
      'IMG',
      'HR',
      'INPUT'
    ], node.nodeName) || dom.getContentEditable(node) === 'false';
    const textBefore = (node, offset, rootNode) => {
      if (isText$a(node) && offset >= 0) {
        return Optional.some(point(node, offset));
      } else {
        const textSeeker = TextSeeker(DOM$7);
        return Optional.from(textSeeker.backwards(node, offset, alwaysNext(node), rootNode)).map(prev => point(prev.container, prev.container.data.length));
      }
    };
    const textAfter = (node, offset, rootNode) => {
      if (isText$a(node) && offset >= node.length) {
        return Optional.some(point(node, offset));
      } else {
        const textSeeker = TextSeeker(DOM$7);
        return Optional.from(textSeeker.forwards(node, offset, alwaysNext(node), rootNode)).map(prev => point(prev.container, 0));
      }
    };
    const scanLeft = (node, offset, rootNode) => {
      if (!isText$a(node)) {
        return Optional.none();
      }
      const text = node.data;
      if (offset >= 0 && offset <= text.length) {
        return Optional.some(point(node, offset));
      } else {
        const textSeeker = TextSeeker(DOM$7);
        return Optional.from(textSeeker.backwards(node, offset, alwaysNext(node), rootNode)).bind(prev => {
          const prevText = prev.container.data;
          return scanLeft(prev.container, offset + prevText.length, rootNode);
        });
      }
    };
    const scanRight = (node, offset, rootNode) => {
      if (!isText$a(node)) {
        return Optional.none();
      }
      const text = node.data;
      if (offset <= text.length) {
        return Optional.some(point(node, offset));
      } else {
        const textSeeker = TextSeeker(DOM$7);
        return Optional.from(textSeeker.forwards(node, offset, alwaysNext(node), rootNode)).bind(next => scanRight(next.container, offset - text.length, rootNode));
      }
    };
    const repeatLeft = (dom, node, offset, process, rootNode) => {
      const search = TextSeeker(dom, isBoundary(dom));
      return Optional.from(search.backwards(node, offset, process, rootNode));
    };

    const isValidTextRange = rng => rng.collapsed && isText$a(rng.startContainer);
    const getText = rng => trim$1(rng.toString().replace(/\u00A0/g, ' '));
    const isWhitespace = chr => chr !== '' && ' \xA0\f\n\r\t\x0B'.indexOf(chr) !== -1;

    const stripTrigger = (text, trigger) => text.substring(trigger.length);
    const findTrigger = (text, index, trigger) => {
      let i;
      const firstChar = trigger.charAt(0);
      for (i = index - 1; i >= 0; i--) {
        const char = text.charAt(i);
        if (isWhitespace(char)) {
          return Optional.none();
        }
        if (firstChar === char && contains$1(text, trigger, i, index)) {
          break;
        }
      }
      return Optional.some(i);
    };
    const findStart = (dom, initRange, trigger, minChars = 0) => {
      if (!isValidTextRange(initRange)) {
        return Optional.none();
      }
      const buffer = {
        text: '',
        offset: 0
      };
      const findTriggerIndex = (element, offset, text) => {
        buffer.text = text + buffer.text;
        buffer.offset += offset;
        return findTrigger(buffer.text, buffer.offset, trigger).getOr(offset);
      };
      const root = dom.getParent(initRange.startContainer, dom.isBlock) || dom.getRoot();
      return repeatLeft(dom, initRange.startContainer, initRange.startOffset, findTriggerIndex, root).bind(spot => {
        const range = initRange.cloneRange();
        range.setStart(spot.container, spot.offset);
        range.setEnd(initRange.endContainer, initRange.endOffset);
        if (range.collapsed) {
          return Optional.none();
        }
        const text = getText(range);
        const triggerIndex = text.lastIndexOf(trigger);
        if (triggerIndex !== 0 || stripTrigger(text, trigger).length < minChars) {
          return Optional.none();
        } else {
          return Optional.some({
            text: stripTrigger(text, trigger),
            range,
            trigger
          });
        }
      });
    };
    const getContext = (dom, initRange, trigger, minChars = 0) => detect$1(SugarElement.fromDom(initRange.startContainer)).fold(() => findStart(dom, initRange, trigger, minChars), elm => {
      const range = dom.createRng();
      range.selectNode(elm.dom);
      const text = getText(range);
      return Optional.some({
        range,
        text: stripTrigger(text, trigger),
        trigger
      });
    });

    const isText$1 = node => node.nodeType === TEXT;
    const isElement = node => node.nodeType === ELEMENT;
    const toLast = node => {
      if (isText$1(node)) {
        return point(node, node.data.length);
      } else {
        const children = node.childNodes;
        return children.length > 0 ? toLast(children[children.length - 1]) : point(node, children.length);
      }
    };
    const toLeaf = (node, offset) => {
      const children = node.childNodes;
      if (children.length > 0 && offset < children.length) {
        return toLeaf(children[offset], 0);
      } else if (children.length > 0 && isElement(node) && children.length === offset) {
        return toLast(children[children.length - 1]);
      } else {
        return point(node, offset);
      }
    };

    const isPreviousCharContent = (dom, leaf) => {
      var _a;
      const root = (_a = dom.getParent(leaf.container, dom.isBlock)) !== null && _a !== void 0 ? _a : dom.getRoot();
      return repeatLeft(dom, leaf.container, leaf.offset, (_element, offset) => offset === 0 ? -1 : offset, root).filter(spot => {
        const char = spot.container.data.charAt(spot.offset - 1);
        return !isWhitespace(char);
      }).isSome();
    };
    const isStartOfWord = dom => rng => {
      const leaf = toLeaf(rng.startContainer, rng.startOffset);
      return !isPreviousCharContent(dom, leaf);
    };
    const getTriggerContext = (dom, initRange, database) => findMap(database.triggers, trigger => getContext(dom, initRange, trigger));
    const lookup = (editor, getDatabase) => {
      const database = getDatabase();
      const rng = editor.selection.getRng();
      return getTriggerContext(editor.dom, rng, database).bind(context => lookupWithContext(editor, getDatabase, context));
    };
    const lookupWithContext = (editor, getDatabase, context, fetchOptions = {}) => {
      var _a;
      const database = getDatabase();
      const rng = editor.selection.getRng();
      const startText = (_a = rng.startContainer.nodeValue) !== null && _a !== void 0 ? _a : '';
      const autocompleters = filter$5(database.lookupByTrigger(context.trigger), autocompleter => context.text.length >= autocompleter.minChars && autocompleter.matches.getOrThunk(() => isStartOfWord(editor.dom))(context.range, startText, context.text));
      if (autocompleters.length === 0) {
        return Optional.none();
      }
      const lookupData = Promise.all(map$3(autocompleters, ac => {
        const fetchResult = ac.fetch(context.text, ac.maxResults, fetchOptions);
        return fetchResult.then(results => ({
          matchText: context.text,
          items: results,
          columns: ac.columns,
          onAction: ac.onAction,
          highlightOn: ac.highlightOn
        }));
      }));
      return Optional.some({
        lookupData,
        context
      });
    };

    var SimpleResultType;
    (function (SimpleResultType) {
      SimpleResultType[SimpleResultType['Error'] = 0] = 'Error';
      SimpleResultType[SimpleResultType['Value'] = 1] = 'Value';
    }(SimpleResultType || (SimpleResultType = {})));
    const fold$1 = (res, onError, onValue) => res.stype === SimpleResultType.Error ? onError(res.serror) : onValue(res.svalue);
    const partition = results => {
      const values = [];
      const errors = [];
      each$e(results, obj => {
        fold$1(obj, err => errors.push(err), val => values.push(val));
      });
      return {
        values,
        errors
      };
    };
    const mapError = (res, f) => {
      if (res.stype === SimpleResultType.Error) {
        return {
          stype: SimpleResultType.Error,
          serror: f(res.serror)
        };
      } else {
        return res;
      }
    };
    const map = (res, f) => {
      if (res.stype === SimpleResultType.Value) {
        return {
          stype: SimpleResultType.Value,
          svalue: f(res.svalue)
        };
      } else {
        return res;
      }
    };
    const bind$1 = (res, f) => {
      if (res.stype === SimpleResultType.Value) {
        return f(res.svalue);
      } else {
        return res;
      }
    };
    const bindError = (res, f) => {
      if (res.stype === SimpleResultType.Error) {
        return f(res.serror);
      } else {
        return res;
      }
    };
    const svalue = v => ({
      stype: SimpleResultType.Value,
      svalue: v
    });
    const serror = e => ({
      stype: SimpleResultType.Error,
      serror: e
    });
    const toResult = res => fold$1(res, Result.error, Result.value);
    const fromResult = res => res.fold(serror, svalue);
    const SimpleResult = {
      fromResult,
      toResult,
      svalue,
      partition,
      serror,
      bind: bind$1,
      bindError,
      map,
      mapError,
      fold: fold$1
    };

    const formatObj = input => {
      return isObject(input) && keys(input).length > 100 ? ' removed due to size' : JSON.stringify(input, null, 2);
    };
    const formatErrors = errors => {
      const es = errors.length > 10 ? errors.slice(0, 10).concat([{
          path: [],
          getErrorInfo: constant('... (only showing first ten failures)')
        }]) : errors;
      return map$3(es, e => {
        return 'Failed path: (' + e.path.join(' > ') + ')\n' + e.getErrorInfo();
      });
    };

    const nu = (path, getErrorInfo) => {
      return SimpleResult.serror([{
          path,
          getErrorInfo
        }]);
    };
    const missingRequired = (path, key, obj) => nu(path, () => 'Could not find valid *required* value for "' + key + '" in ' + formatObj(obj));
    const missingKey = (path, key) => nu(path, () => 'Choice schema did not contain choice key: "' + key + '"');
    const missingBranch = (path, branches, branch) => nu(path, () => 'The chosen schema: "' + branch + '" did not exist in branches: ' + formatObj(branches));
    const custom = (path, err) => nu(path, constant(err));

    const chooseFrom = (path, input, branches, ch) => {
      const fields = get$a(branches, ch);
      return fields.fold(() => missingBranch(path, branches, ch), vp => vp.extract(path.concat(['branch: ' + ch]), input));
    };
    const choose$1 = (key, branches) => {
      const extract = (path, input) => {
        const choice = get$a(input, key);
        return choice.fold(() => missingKey(path, key), chosen => chooseFrom(path, input, branches, chosen));
      };
      const toString = () => 'chooseOn(' + key + '). Possible values: ' + keys(branches);
      return {
        extract,
        toString
      };
    };

    const shallow = (old, nu) => {
      return nu;
    };
    const deep = (old, nu) => {
      const bothObjects = isPlainObject(old) && isPlainObject(nu);
      return bothObjects ? deepMerge(old, nu) : nu;
    };
    const baseMerge = merger => {
      return (...objects) => {
        if (objects.length === 0) {
          throw new Error(`Can't merge zero objects`);
        }
        const ret = {};
        for (let j = 0; j < objects.length; j++) {
          const curObject = objects[j];
          for (const key in curObject) {
            if (has$2(curObject, key)) {
              ret[key] = merger(ret[key], curObject[key]);
            }
          }
        }
        return ret;
      };
    };
    const deepMerge = baseMerge(deep);
    const merge = baseMerge(shallow);

    const required = () => ({
      tag: 'required',
      process: {}
    });
    const defaultedThunk = fallbackThunk => ({
      tag: 'defaultedThunk',
      process: fallbackThunk
    });
    const defaulted$1 = fallback => defaultedThunk(constant(fallback));
    const asOption = () => ({
      tag: 'option',
      process: {}
    });

    const mergeValues = (values, base) => values.length > 0 ? SimpleResult.svalue(deepMerge(base, merge.apply(undefined, values))) : SimpleResult.svalue(base);
    const mergeErrors = errors => compose(SimpleResult.serror, flatten)(errors);
    const consolidateObj = (objects, base) => {
      const partition = SimpleResult.partition(objects);
      return partition.errors.length > 0 ? mergeErrors(partition.errors) : mergeValues(partition.values, base);
    };
    const consolidateArr = objects => {
      const partitions = SimpleResult.partition(objects);
      return partitions.errors.length > 0 ? mergeErrors(partitions.errors) : SimpleResult.svalue(partitions.values);
    };
    const ResultCombine = {
      consolidateObj,
      consolidateArr
    };

    const field$1 = (key, newKey, presence, prop) => ({
      tag: 'field',
      key,
      newKey,
      presence,
      prop
    });
    const customField$1 = (newKey, instantiator) => ({
      tag: 'custom',
      newKey,
      instantiator
    });
    const fold = (value, ifField, ifCustom) => {
      switch (value.tag) {
      case 'field':
        return ifField(value.key, value.newKey, value.presence, value.prop);
      case 'custom':
        return ifCustom(value.newKey, value.instantiator);
      }
    };

    const value = validator => {
      const extract = (path, val) => {
        return SimpleResult.bindError(validator(val), err => custom(path, err));
      };
      const toString = constant('val');
      return {
        extract,
        toString
      };
    };
    const anyValue$1 = value(SimpleResult.svalue);

    const requiredAccess = (path, obj, key, bundle) => get$a(obj, key).fold(() => missingRequired(path, key, obj), bundle);
    const fallbackAccess = (obj, key, fallback, bundle) => {
      const v = get$a(obj, key).getOrThunk(() => fallback(obj));
      return bundle(v);
    };
    const optionAccess = (obj, key, bundle) => bundle(get$a(obj, key));
    const optionDefaultedAccess = (obj, key, fallback, bundle) => {
      const opt = get$a(obj, key).map(val => val === true ? fallback(obj) : val);
      return bundle(opt);
    };
    const extractField = (field, path, obj, key, prop) => {
      const bundle = av => prop.extract(path.concat([key]), av);
      const bundleAsOption = optValue => optValue.fold(() => SimpleResult.svalue(Optional.none()), ov => {
        const result = prop.extract(path.concat([key]), ov);
        return SimpleResult.map(result, Optional.some);
      });
      switch (field.tag) {
      case 'required':
        return requiredAccess(path, obj, key, bundle);
      case 'defaultedThunk':
        return fallbackAccess(obj, key, field.process, bundle);
      case 'option':
        return optionAccess(obj, key, bundleAsOption);
      case 'defaultedOptionThunk':
        return optionDefaultedAccess(obj, key, field.process, bundleAsOption);
      case 'mergeWithThunk': {
          return fallbackAccess(obj, key, constant({}), v => {
            const result = deepMerge(field.process(obj), v);
            return bundle(result);
          });
        }
      }
    };
    const extractFields = (path, obj, fields) => {
      const success = {};
      const errors = [];
      for (const field of fields) {
        fold(field, (key, newKey, presence, prop) => {
          const result = extractField(presence, path, obj, key, prop);
          SimpleResult.fold(result, err => {
            errors.push(...err);
          }, res => {
            success[newKey] = res;
          });
        }, (newKey, instantiator) => {
          success[newKey] = instantiator(obj);
        });
      }
      return errors.length > 0 ? SimpleResult.serror(errors) : SimpleResult.svalue(success);
    };
    const objOf = values => {
      const extract = (path, o) => extractFields(path, o, values);
      const toString = () => {
        const fieldStrings = map$3(values, value => fold(value, (key, _okey, _presence, prop) => key + ' -> ' + prop.toString(), (newKey, _instantiator) => 'state(' + newKey + ')'));
        return 'obj{\n' + fieldStrings.join('\n') + '}';
      };
      return {
        extract,
        toString
      };
    };
    const arrOf = prop => {
      const extract = (path, array) => {
        const results = map$3(array, (a, i) => prop.extract(path.concat(['[' + i + ']']), a));
        return ResultCombine.consolidateArr(results);
      };
      const toString = () => 'array(' + prop.toString() + ')';
      return {
        extract,
        toString
      };
    };

    const valueOf = validator => value(v => validator(v).fold(SimpleResult.serror, SimpleResult.svalue));
    const extractValue = (label, prop, obj) => {
      const res = prop.extract([label], obj);
      return SimpleResult.mapError(res, errs => ({
        input: obj,
        errors: errs
      }));
    };
    const asRaw = (label, prop, obj) => SimpleResult.toResult(extractValue(label, prop, obj));
    const formatError = errInfo => {
      return 'Errors: \n' + formatErrors(errInfo.errors).join('\n') + '\n\nInput object: ' + formatObj(errInfo.input);
    };
    const choose = (key, branches) => choose$1(key, map$2(branches, objOf));

    const anyValue = constant(anyValue$1);
    const typedValue = (validator, expectedType) => value(a => {
      const actualType = typeof a;
      return validator(a) ? SimpleResult.svalue(a) : SimpleResult.serror(`Expected type: ${ expectedType } but got: ${ actualType }`);
    });
    const number = typedValue(isNumber, 'number');
    const string = typedValue(isString, 'string');
    const boolean = typedValue(isBoolean, 'boolean');
    const functionProcessor = typedValue(isFunction, 'function');

    const field = field$1;
    const customField = customField$1;
    const validateEnum = values => valueOf(value => contains$2(values, value) ? Result.value(value) : Result.error(`Unsupported value: "${ value }", choose one of "${ values.join(', ') }".`));
    const requiredOf = (key, schema) => field(key, key, required(), schema);
    const requiredString = key => requiredOf(key, string);
    const requiredFunction = key => requiredOf(key, functionProcessor);
    const requiredArrayOf = (key, schema) => field(key, key, required(), arrOf(schema));
    const optionOf = (key, schema) => field(key, key, asOption(), schema);
    const optionString = key => optionOf(key, string);
    const optionFunction = key => optionOf(key, functionProcessor);
    const defaulted = (key, fallback) => field(key, key, defaulted$1(fallback), anyValue());
    const defaultedOf = (key, fallback, schema) => field(key, key, defaulted$1(fallback), schema);
    const defaultedNumber = (key, fallback) => defaultedOf(key, fallback, number);
    const defaultedString = (key, fallback) => defaultedOf(key, fallback, string);
    const defaultedStringEnum = (key, fallback, values) => defaultedOf(key, fallback, validateEnum(values));
    const defaultedBoolean = (key, fallback) => defaultedOf(key, fallback, boolean);
    const defaultedFunction = (key, fallback) => defaultedOf(key, fallback, functionProcessor);
    const defaultedArrayOf = (key, fallback, schema) => defaultedOf(key, fallback, arrOf(schema));

    const type = requiredString('type');
    const fetch$1 = requiredFunction('fetch');
    const onAction = requiredFunction('onAction');
    const onSetup = defaultedFunction('onSetup', () => noop);
    const optionalText = optionString('text');
    const optionalIcon = optionString('icon');
    const optionalTooltip = optionString('tooltip');
    const optionalLabel = optionString('label');
    const active = defaultedBoolean('active', false);
    const enabled = defaultedBoolean('enabled', true);
    const primary = defaultedBoolean('primary', false);
    const defaultedColumns = num => defaulted('columns', num);
    const defaultedType = type => defaultedString('type', type);

    const autocompleterSchema = objOf([
      type,
      requiredString('trigger'),
      defaultedNumber('minChars', 1),
      defaultedColumns(1),
      defaultedNumber('maxResults', 10),
      optionFunction('matches'),
      fetch$1,
      onAction,
      defaultedArrayOf('highlightOn', [], string)
    ]);
    const createAutocompleter = spec => asRaw('Autocompleter', autocompleterSchema, {
      trigger: spec.ch,
      ...spec
    });

    const baseToolbarButtonFields = [
      enabled,
      optionalTooltip,
      optionalIcon,
      optionalText,
      onSetup
    ];

    const baseToolbarToggleButtonFields = [active].concat(baseToolbarButtonFields);

    const contextBarFields = [
      defaultedFunction('predicate', never),
      defaultedStringEnum('scope', 'node', [
        'node',
        'editor'
      ]),
      defaultedStringEnum('position', 'selection', [
        'node',
        'selection',
        'line'
      ])
    ];

    const contextButtonFields = baseToolbarButtonFields.concat([
      defaultedType('contextformbutton'),
      primary,
      onAction,
      customField('original', identity)
    ]);
    const contextToggleButtonFields = baseToolbarToggleButtonFields.concat([
      defaultedType('contextformbutton'),
      primary,
      onAction,
      customField('original', identity)
    ]);
    const launchButtonFields = baseToolbarButtonFields.concat([defaultedType('contextformbutton')]);
    const launchToggleButtonFields = baseToolbarToggleButtonFields.concat([defaultedType('contextformtogglebutton')]);
    const toggleOrNormal = choose('type', {
      contextformbutton: contextButtonFields,
      contextformtogglebutton: contextToggleButtonFields
    });
    objOf([
      defaultedType('contextform'),
      defaultedFunction('initValue', constant('')),
      optionalLabel,
      requiredArrayOf('commands', toggleOrNormal),
      optionOf('launch', choose('type', {
        contextformbutton: launchButtonFields,
        contextformtogglebutton: launchToggleButtonFields
      }))
    ].concat(contextBarFields));

    const register$2 = editor => {
      const popups = editor.ui.registry.getAll().popups;
      const dataset = map$2(popups, popup => createAutocompleter(popup).fold(err => {
        throw new Error(formatError(err));
      }, identity));
      const triggers = stringArray(mapToArray(dataset, v => v.trigger));
      const datasetValues = values(dataset);
      const lookupByTrigger = trigger => filter$5(datasetValues, dv => dv.trigger === trigger);
      return {
        dataset,
        triggers,
        lookupByTrigger
      };
    };

    const setupEditorInput = (editor, api) => {
      const update = last$1(api.load, 50);
      editor.on('keypress compositionend', e => {
        if (e.which === 27) {
          return;
        }
        update.throttle();
      });
      editor.on('keydown', e => {
        const keyCode = e.which;
        if (keyCode === 8) {
          update.throttle();
        } else if (keyCode === 27) {
          api.cancelIfNecessary();
        }
      });
      editor.on('remove', update.cancel);
    };
    const setup$j = editor => {
      const activeAutocompleter = value$2();
      const uiActive = Cell(false);
      const isActive = activeAutocompleter.isSet;
      const cancelIfNecessary = () => {
        if (isActive()) {
          removeAutocompleterDecoration(editor);
          fireAutocompleterEnd(editor);
          uiActive.set(false);
          activeAutocompleter.clear();
        }
      };
      const commenceIfNecessary = context => {
        if (!isActive()) {
          addAutocompleterDecoration(editor, context.range);
          activeAutocompleter.set({
            trigger: context.trigger,
            matchLength: context.text.length
          });
        }
      };
      const getAutocompleters = cached(() => register$2(editor));
      const doLookup = fetchOptions => activeAutocompleter.get().map(ac => getContext(editor.dom, editor.selection.getRng(), ac.trigger).bind(newContext => lookupWithContext(editor, getAutocompleters, newContext, fetchOptions))).getOrThunk(() => lookup(editor, getAutocompleters));
      const load = fetchOptions => {
        doLookup(fetchOptions).fold(cancelIfNecessary, lookupInfo => {
          commenceIfNecessary(lookupInfo.context);
          lookupInfo.lookupData.then(lookupData => {
            activeAutocompleter.get().map(ac => {
              const context = lookupInfo.context;
              if (ac.trigger === context.trigger) {
                if (context.text.length - ac.matchLength >= 10) {
                  cancelIfNecessary();
                } else {
                  activeAutocompleter.set({
                    ...ac,
                    matchLength: context.text.length
                  });
                  if (uiActive.get()) {
                    fireAutocompleterUpdate(editor, { lookupData });
                  } else {
                    uiActive.set(true);
                    fireAutocompleterStart(editor, { lookupData });
                  }
                }
              }
            });
          });
        });
      };
      editor.addCommand('mceAutocompleterReload', (_ui, value) => {
        const fetchOptions = isObject(value) ? value.fetchOptions : {};
        load(fetchOptions);
      });
      editor.addCommand('mceAutocompleterClose', cancelIfNecessary);
      setupEditorInput(editor, {
        cancelIfNecessary,
        load
      });
    };

    const createAndFireInputEvent = eventType => (editor, inputType, specifics = {}) => {
      const target = editor.getBody();
      const overrides = {
        bubbles: true,
        composed: true,
        data: null,
        isComposing: false,
        detail: 0,
        view: null,
        target,
        currentTarget: target,
        eventPhase: Event.AT_TARGET,
        originalTarget: target,
        explicitOriginalTarget: target,
        isTrusted: false,
        srcElement: target,
        cancelable: false,
        preventDefault: noop,
        inputType
      };
      const input = clone$3(new InputEvent(eventType));
      return editor.dispatch(eventType, {
        ...input,
        ...overrides,
        ...specifics
      });
    };
    const fireFakeInputEvent = createAndFireInputEvent('input');
    const fireFakeBeforeInputEvent = createAndFireInputEvent('beforeinput');

    const executeKeydownOverride$3 = (editor, caret, evt) => {
      const inputType = evt.keyCode === VK.BACKSPACE ? 'deleteContentBackward' : 'deleteContentForward';
      executeWithDelayedAction([
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete, editor)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$5, editor, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$5, editor, true)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$6, editor, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$6, editor, true)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$3, editor, caret, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$3, editor, caret, true)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$9, editor, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$9, editor, true)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$4, editor, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$4, editor, true)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$1, editor, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$1, editor, true)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$7, editor, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$7, editor, true)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$8, editor, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$8, editor, true)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$2, editor, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$2, editor, true)
        }
      ], evt).filter(_ => editor.selection.isEditable()).each(applyAction => {
        evt.preventDefault();
        const beforeInput = fireFakeBeforeInputEvent(editor, inputType);
        if (!beforeInput.isDefaultPrevented()) {
          applyAction();
          fireFakeInputEvent(editor, inputType);
        }
      });
    };
    const executeKeyupOverride = (editor, evt, isBackspaceKeydown) => {
      const platform = detect$2();
      const os = platform.os;
      const browser = platform.browser;
      const multiDeleteKeyPatterns = os.isMacOS() ? [
        {
          keyCode: VK.BACKSPACE,
          altKey: true,
          action: action(refreshCaret, editor)
        },
        {
          keyCode: VK.DELETE,
          altKey: true,
          action: action(refreshCaret, editor)
        }
      ] : [
        {
          keyCode: VK.BACKSPACE,
          ctrlKey: true,
          action: action(refreshCaret, editor)
        },
        {
          keyCode: VK.DELETE,
          ctrlKey: true,
          action: action(refreshCaret, editor)
        }
      ];
      if (os.isMacOS() && isBackspaceKeydown) {
        multiDeleteKeyPatterns.push({
          keyCode: browser.isFirefox() ? 224 : 91,
          action: action(refreshCaret, editor)
        });
      }
      execute([
        {
          keyCode: VK.BACKSPACE,
          action: action(paddEmptyElement, editor)
        },
        {
          keyCode: VK.DELETE,
          action: action(paddEmptyElement, editor)
        },
        ...multiDeleteKeyPatterns
      ], evt);
    };
    const setup$i = (editor, caret) => {
      let isBackspaceKeydown = false;
      editor.on('keydown', evt => {
        isBackspaceKeydown = evt.keyCode === VK.BACKSPACE;
        if (!evt.isDefaultPrevented()) {
          executeKeydownOverride$3(editor, caret, evt);
        }
      });
      editor.on('keyup', evt => {
        if (!evt.isDefaultPrevented()) {
          executeKeyupOverride(editor, evt, isBackspaceKeydown);
        }
        isBackspaceKeydown = false;
      });
    };

    const firstNonWhiteSpaceNodeSibling = node => {
      while (node) {
        if (isElement$6(node) || isText$a(node) && node.data && /[\r\n\s]/.test(node.data)) {
          return node;
        }
        node = node.nextSibling;
      }
      return null;
    };
    const moveToCaretPosition = (editor, root) => {
      const dom = editor.dom;
      const moveCaretBeforeOnEnterElementsMap = editor.schema.getMoveCaretBeforeOnEnterElements();
      if (!root) {
        return;
      }
      if (/^(LI|DT|DD)$/.test(root.nodeName)) {
        const firstChild = firstNonWhiteSpaceNodeSibling(root.firstChild);
        if (firstChild && /^(UL|OL|DL)$/.test(firstChild.nodeName)) {
          root.insertBefore(dom.doc.createTextNode(nbsp), root.firstChild);
        }
      }
      const rng = dom.createRng();
      root.normalize();
      if (root.hasChildNodes()) {
        const walker = new DomTreeWalker(root, root);
        let lastNode = root;
        let node;
        while (node = walker.current()) {
          if (isText$a(node)) {
            rng.setStart(node, 0);
            rng.setEnd(node, 0);
            break;
          }
          if (moveCaretBeforeOnEnterElementsMap[node.nodeName.toLowerCase()]) {
            rng.setStartBefore(node);
            rng.setEndBefore(node);
            break;
          }
          lastNode = node;
          node = walker.next();
        }
        if (!node) {
          rng.setStart(lastNode, 0);
          rng.setEnd(lastNode, 0);
        }
      } else {
        if (isBr$6(root)) {
          if (root.nextSibling && dom.isBlock(root.nextSibling)) {
            rng.setStartBefore(root);
            rng.setEndBefore(root);
          } else {
            rng.setStartAfter(root);
            rng.setEndAfter(root);
          }
        } else {
          rng.setStart(root, 0);
          rng.setEnd(root, 0);
        }
      }
      editor.selection.setRng(rng);
      scrollRangeIntoView(editor, rng);
    };
    const getEditableRoot = (dom, node) => {
      const root = dom.getRoot();
      let editableRoot;
      let parent = node;
      while (parent !== root && parent && dom.getContentEditable(parent) !== 'false') {
        if (dom.getContentEditable(parent) === 'true') {
          editableRoot = parent;
        }
        parent = parent.parentNode;
      }
      return parent !== root ? editableRoot : root;
    };
    const getParentBlock$1 = editor => {
      return Optional.from(editor.dom.getParent(editor.selection.getStart(true), editor.dom.isBlock));
    };
    const getParentBlockName = editor => {
      return getParentBlock$1(editor).fold(constant(''), parentBlock => {
        return parentBlock.nodeName.toUpperCase();
      });
    };
    const isListItemParentBlock = editor => {
      return getParentBlock$1(editor).filter(elm => {
        return isListItem$1(SugarElement.fromDom(elm));
      }).isSome();
    };

    const hasFirstChild = (elm, name) => {
      return elm.firstChild && elm.firstChild.nodeName === name;
    };
    const isFirstChild = elm => {
      var _a;
      return ((_a = elm.parentNode) === null || _a === void 0 ? void 0 : _a.firstChild) === elm;
    };
    const hasParent = (elm, parentName) => {
      const parentNode = elm === null || elm === void 0 ? void 0 : elm.parentNode;
      return isNonNullable(parentNode) && parentNode.nodeName === parentName;
    };
    const isListBlock = elm => {
      return isNonNullable(elm) && /^(OL|UL|LI)$/.test(elm.nodeName);
    };
    const isListItem = elm => {
      return isNonNullable(elm) && /^(LI|DT|DD)$/.test(elm.nodeName);
    };
    const isNestedList = elm => {
      return isListBlock(elm) && isListBlock(elm.parentNode);
    };
    const getContainerBlock = containerBlock => {
      const containerBlockParent = containerBlock.parentNode;
      return isListItem(containerBlockParent) ? containerBlockParent : containerBlock;
    };
    const isFirstOrLastLi = (containerBlock, parentBlock, first) => {
      let node = containerBlock[first ? 'firstChild' : 'lastChild'];
      while (node) {
        if (isElement$6(node)) {
          break;
        }
        node = node[first ? 'nextSibling' : 'previousSibling'];
      }
      return node === parentBlock;
    };
    const insert$3 = (editor, createNewBlock, containerBlock, parentBlock, newBlockName) => {
      const dom = editor.dom;
      const rng = editor.selection.getRng();
      const containerParent = containerBlock.parentNode;
      if (containerBlock === editor.getBody() || !containerParent) {
        return;
      }
      if (isNestedList(containerBlock)) {
        newBlockName = 'LI';
      }
      let newBlock = createNewBlock(newBlockName);
      if (isFirstOrLastLi(containerBlock, parentBlock, true) && isFirstOrLastLi(containerBlock, parentBlock, false)) {
        if (hasParent(containerBlock, 'LI')) {
          const containerBlockParent = getContainerBlock(containerBlock);
          dom.insertAfter(newBlock, containerBlockParent);
          if (isFirstChild(containerBlock)) {
            dom.remove(containerBlockParent);
          } else {
            dom.remove(containerBlock);
          }
        } else {
          dom.replace(newBlock, containerBlock);
        }
      } else if (isFirstOrLastLi(containerBlock, parentBlock, true)) {
        if (hasParent(containerBlock, 'LI')) {
          dom.insertAfter(newBlock, getContainerBlock(containerBlock));
          newBlock.appendChild(dom.doc.createTextNode(' '));
          newBlock.appendChild(containerBlock);
        } else {
          containerParent.insertBefore(newBlock, containerBlock);
        }
        dom.remove(parentBlock);
      } else if (isFirstOrLastLi(containerBlock, parentBlock, false)) {
        dom.insertAfter(newBlock, getContainerBlock(containerBlock));
        dom.remove(parentBlock);
      } else {
        containerBlock = getContainerBlock(containerBlock);
        const tmpRng = rng.cloneRange();
        tmpRng.setStartAfter(parentBlock);
        tmpRng.setEndAfter(containerBlock);
        const fragment = tmpRng.extractContents();
        if (newBlockName === 'LI' && hasFirstChild(fragment, 'LI')) {
          newBlock = fragment.firstChild;
          dom.insertAfter(fragment, containerBlock);
        } else {
          dom.insertAfter(fragment, containerBlock);
          dom.insertAfter(newBlock, containerBlock);
        }
        dom.remove(parentBlock);
      }
      moveToCaretPosition(editor, newBlock);
    };

    const trimZwsp = fragment => {
      each$e(descendants$1(SugarElement.fromDom(fragment), isText$b), text => {
        const rawNode = text.dom;
        rawNode.nodeValue = trim$1(rawNode.data);
      });
    };
    const isWithinNonEditableList = (editor, node) => {
      const parentList = editor.dom.getParent(node, 'ol,ul,dl');
      return parentList !== null && editor.dom.getContentEditableParent(parentList) === 'false';
    };
    const isEmptyAnchor = (dom, elm) => {
      return elm && elm.nodeName === 'A' && dom.isEmpty(elm);
    };
    const emptyBlock = elm => {
      elm.innerHTML = '<br data-mce-bogus="1">';
    };
    const containerAndSiblingName = (container, nodeName) => {
      return container.nodeName === nodeName || container.previousSibling && container.previousSibling.nodeName === nodeName;
    };
    const canSplitBlock = (dom, node) => {
      return isNonNullable(node) && dom.isBlock(node) && !/^(TD|TH|CAPTION|FORM)$/.test(node.nodeName) && !/^(fixed|absolute)/i.test(node.style.position) && dom.isEditable(node.parentNode) && dom.getContentEditable(node) !== 'false';
    };
    const trimInlineElementsOnLeftSideOfBlock = (dom, nonEmptyElementsMap, block) => {
      var _a;
      const firstChilds = [];
      if (!block) {
        return;
      }
      let currentNode = block;
      while (currentNode = currentNode.firstChild) {
        if (dom.isBlock(currentNode)) {
          return;
        }
        if (isElement$6(currentNode) && !nonEmptyElementsMap[currentNode.nodeName.toLowerCase()]) {
          firstChilds.push(currentNode);
        }
      }
      let i = firstChilds.length;
      while (i--) {
        currentNode = firstChilds[i];
        if (!currentNode.hasChildNodes() || currentNode.firstChild === currentNode.lastChild && ((_a = currentNode.firstChild) === null || _a === void 0 ? void 0 : _a.nodeValue) === '') {
          dom.remove(currentNode);
        } else {
          if (isEmptyAnchor(dom, currentNode)) {
            dom.remove(currentNode);
          }
        }
      }
    };
    const normalizeZwspOffset = (start, container, offset) => {
      if (!isText$a(container)) {
        return offset;
      } else if (start) {
        return offset === 1 && container.data.charAt(offset - 1) === ZWSP$1 ? 0 : offset;
      } else {
        return offset === container.data.length - 1 && container.data.charAt(offset) === ZWSP$1 ? container.data.length : offset;
      }
    };
    const includeZwspInRange = rng => {
      const newRng = rng.cloneRange();
      newRng.setStart(rng.startContainer, normalizeZwspOffset(true, rng.startContainer, rng.startOffset));
      newRng.setEnd(rng.endContainer, normalizeZwspOffset(false, rng.endContainer, rng.endOffset));
      return newRng;
    };
    const trimLeadingLineBreaks = node => {
      let currentNode = node;
      do {
        if (isText$a(currentNode)) {
          currentNode.data = currentNode.data.replace(/^[\r\n]+/, '');
        }
        currentNode = currentNode.firstChild;
      } while (currentNode);
    };
    const applyAttributes = (editor, node, forcedRootBlockAttrs) => {
      const dom = editor.dom;
      Optional.from(forcedRootBlockAttrs.style).map(dom.parseStyle).each(attrStyles => {
        const currentStyles = getAllRaw(SugarElement.fromDom(node));
        const newStyles = {
          ...currentStyles,
          ...attrStyles
        };
        dom.setStyles(node, newStyles);
      });
      const attrClassesOpt = Optional.from(forcedRootBlockAttrs.class).map(attrClasses => attrClasses.split(/\s+/));
      const currentClassesOpt = Optional.from(node.className).map(currentClasses => filter$5(currentClasses.split(/\s+/), clazz => clazz !== ''));
      lift2(attrClassesOpt, currentClassesOpt, (attrClasses, currentClasses) => {
        const filteredClasses = filter$5(currentClasses, clazz => !contains$2(attrClasses, clazz));
        const newClasses = [
          ...attrClasses,
          ...filteredClasses
        ];
        dom.setAttrib(node, 'class', newClasses.join(' '));
      });
      const appliedAttrs = [
        'style',
        'class'
      ];
      const remainingAttrs = filter$4(forcedRootBlockAttrs, (_, attrs) => !contains$2(appliedAttrs, attrs));
      dom.setAttribs(node, remainingAttrs);
    };
    const setForcedBlockAttrs = (editor, node) => {
      const forcedRootBlockName = getForcedRootBlock(editor);
      if (forcedRootBlockName.toLowerCase() === node.tagName.toLowerCase()) {
        const forcedRootBlockAttrs = getForcedRootBlockAttrs(editor);
        applyAttributes(editor, node, forcedRootBlockAttrs);
      }
    };
    const wrapSelfAndSiblingsInDefaultBlock = (editor, newBlockName, rng, container, offset) => {
      var _a, _b;
      const dom = editor.dom;
      const editableRoot = (_a = getEditableRoot(dom, container)) !== null && _a !== void 0 ? _a : dom.getRoot();
      let parentBlock = dom.getParent(container, dom.isBlock);
      if (!parentBlock || !canSplitBlock(dom, parentBlock)) {
        parentBlock = parentBlock || editableRoot;
        if (!parentBlock.hasChildNodes()) {
          const newBlock = dom.create(newBlockName);
          setForcedBlockAttrs(editor, newBlock);
          parentBlock.appendChild(newBlock);
          rng.setStart(newBlock, 0);
          rng.setEnd(newBlock, 0);
          return newBlock;
        }
        let node = container;
        while (node && node.parentNode !== parentBlock) {
          node = node.parentNode;
        }
        let startNode;
        while (node && !dom.isBlock(node)) {
          startNode = node;
          node = node.previousSibling;
        }
        const startNodeName = (_b = startNode === null || startNode === void 0 ? void 0 : startNode.parentElement) === null || _b === void 0 ? void 0 : _b.nodeName;
        if (startNode && startNodeName && editor.schema.isValidChild(startNodeName, newBlockName.toLowerCase())) {
          const startNodeParent = startNode.parentNode;
          const newBlock = dom.create(newBlockName);
          setForcedBlockAttrs(editor, newBlock);
          startNodeParent.insertBefore(newBlock, startNode);
          node = startNode;
          while (node && !dom.isBlock(node)) {
            const next = node.nextSibling;
            newBlock.appendChild(node);
            node = next;
          }
          rng.setStart(container, offset);
          rng.setEnd(container, offset);
        }
      }
      return container;
    };
    const addBrToBlockIfNeeded = (dom, block) => {
      block.normalize();
      const lastChild = block.lastChild;
      if (!lastChild || isElement$6(lastChild) && /^(left|right)$/gi.test(dom.getStyle(lastChild, 'float', true))) {
        dom.add(block, 'br');
      }
    };
    const shouldEndContainer = (editor, container) => {
      const optionValue = shouldEndContainerOnEmptyBlock(editor);
      if (isNullable(container)) {
        return false;
      } else if (isString(optionValue)) {
        return contains$2(Tools.explode(optionValue), container.nodeName.toLowerCase());
      } else {
        return optionValue;
      }
    };
    const insert$2 = (editor, evt) => {
      let container;
      let offset;
      let parentBlockName;
      let containerBlock;
      let isAfterLastNodeInContainer = false;
      const dom = editor.dom;
      const schema = editor.schema, nonEmptyElementsMap = schema.getNonEmptyElements();
      const rng = editor.selection.getRng();
      const newBlockName = getForcedRootBlock(editor);
      const createNewBlock = name => {
        let node = container;
        const textInlineElements = schema.getTextInlineElements();
        let block;
        if (name || parentBlockName === 'TABLE' || parentBlockName === 'HR') {
          block = dom.create(name || newBlockName);
        } else {
          block = parentBlock.cloneNode(false);
        }
        let caretNode = block;
        if (shouldKeepStyles(editor) === false) {
          dom.setAttrib(block, 'style', null);
          dom.setAttrib(block, 'class', null);
        } else {
          do {
            if (textInlineElements[node.nodeName]) {
              if (isCaretNode(node) || isBookmarkNode$1(node)) {
                continue;
              }
              const clonedNode = node.cloneNode(false);
              dom.setAttrib(clonedNode, 'id', '');
              if (block.hasChildNodes()) {
                clonedNode.appendChild(block.firstChild);
                block.appendChild(clonedNode);
              } else {
                caretNode = clonedNode;
                block.appendChild(clonedNode);
              }
            }
          } while ((node = node.parentNode) && node !== editableRoot);
        }
        setForcedBlockAttrs(editor, block);
        emptyBlock(caretNode);
        return block;
      };
      const isCaretAtStartOrEndOfBlock = start => {
        const normalizedOffset = normalizeZwspOffset(start, container, offset);
        if (isText$a(container) && (start ? normalizedOffset > 0 : normalizedOffset < container.data.length)) {
          return false;
        }
        if (container.parentNode === parentBlock && isAfterLastNodeInContainer && !start) {
          return true;
        }
        if (start && isElement$6(container) && container === parentBlock.firstChild) {
          return true;
        }
        if (containerAndSiblingName(container, 'TABLE') || containerAndSiblingName(container, 'HR')) {
          return isAfterLastNodeInContainer && !start || !isAfterLastNodeInContainer && start;
        }
        const walker = new DomTreeWalker(container, parentBlock);
        if (isText$a(container)) {
          if (start && normalizedOffset === 0) {
            walker.prev();
          } else if (!start && normalizedOffset === container.data.length) {
            walker.next();
          }
        }
        let node;
        while (node = walker.current()) {
          if (isElement$6(node)) {
            if (!node.getAttribute('data-mce-bogus')) {
              const name = node.nodeName.toLowerCase();
              if (nonEmptyElementsMap[name] && name !== 'br') {
                return false;
              }
            }
          } else if (isText$a(node) && !isWhitespaceText(node.data)) {
            return false;
          }
          if (start) {
            walker.prev();
          } else {
            walker.next();
          }
        }
        return true;
      };
      const insertNewBlockAfter = () => {
        let block;
        if (/^(H[1-6]|PRE|FIGURE)$/.test(parentBlockName) && containerBlockName !== 'HGROUP') {
          block = createNewBlock(newBlockName);
        } else {
          block = createNewBlock();
        }
        if (shouldEndContainer(editor, containerBlock) && canSplitBlock(dom, containerBlock) && dom.isEmpty(parentBlock)) {
          block = dom.split(containerBlock, parentBlock);
        } else {
          dom.insertAfter(block, parentBlock);
        }
        moveToCaretPosition(editor, block);
        return block;
      };
      normalize$2(dom, rng).each(normRng => {
        rng.setStart(normRng.startContainer, normRng.startOffset);
        rng.setEnd(normRng.endContainer, normRng.endOffset);
      });
      container = rng.startContainer;
      offset = rng.startOffset;
      const shiftKey = !!(evt && evt.shiftKey);
      const ctrlKey = !!(evt && evt.ctrlKey);
      if (isElement$6(container) && container.hasChildNodes()) {
        isAfterLastNodeInContainer = offset > container.childNodes.length - 1;
        container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;
        if (isAfterLastNodeInContainer && isText$a(container)) {
          offset = container.data.length;
        } else {
          offset = 0;
        }
      }
      const editableRoot = getEditableRoot(dom, container);
      if (!editableRoot || isWithinNonEditableList(editor, container)) {
        return;
      }
      if (!shiftKey) {
        container = wrapSelfAndSiblingsInDefaultBlock(editor, newBlockName, rng, container, offset);
      }
      let parentBlock = dom.getParent(container, dom.isBlock) || dom.getRoot();
      containerBlock = isNonNullable(parentBlock === null || parentBlock === void 0 ? void 0 : parentBlock.parentNode) ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;
      parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : '';
      const containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : '';
      if (containerBlockName === 'LI' && !ctrlKey) {
        const liBlock = containerBlock;
        parentBlock = liBlock;
        containerBlock = liBlock.parentNode;
        parentBlockName = containerBlockName;
      }
      if (/^(LI|DT|DD)$/.test(parentBlockName) && isElement$6(containerBlock)) {
        if (dom.isEmpty(parentBlock)) {
          insert$3(editor, createNewBlock, containerBlock, parentBlock, newBlockName);
          return;
        }
      }
      if (parentBlock === editor.getBody() || !canSplitBlock(dom, parentBlock)) {
        return;
      }
      const parentBlockParent = parentBlock.parentNode;
      let newBlock;
      if (isCaretContainerBlock$1(parentBlock)) {
        newBlock = showCaretContainerBlock(parentBlock);
        if (dom.isEmpty(parentBlock)) {
          emptyBlock(parentBlock);
        }
        setForcedBlockAttrs(editor, newBlock);
        moveToCaretPosition(editor, newBlock);
      } else if (isCaretAtStartOrEndOfBlock(false)) {
        newBlock = insertNewBlockAfter();
      } else if (isCaretAtStartOrEndOfBlock(true) && parentBlockParent) {
        newBlock = parentBlockParent.insertBefore(createNewBlock(), parentBlock);
        moveToCaretPosition(editor, containerAndSiblingName(parentBlock, 'HR') ? newBlock : parentBlock);
      } else {
        const tmpRng = includeZwspInRange(rng).cloneRange();
        tmpRng.setEndAfter(parentBlock);
        const fragment = tmpRng.extractContents();
        trimZwsp(fragment);
        trimLeadingLineBreaks(fragment);
        newBlock = fragment.firstChild;
        dom.insertAfter(fragment, parentBlock);
        trimInlineElementsOnLeftSideOfBlock(dom, nonEmptyElementsMap, newBlock);
        addBrToBlockIfNeeded(dom, parentBlock);
        if (dom.isEmpty(parentBlock)) {
          emptyBlock(parentBlock);
        }
        newBlock.normalize();
        if (dom.isEmpty(newBlock)) {
          dom.remove(newBlock);
          insertNewBlockAfter();
        } else {
          setForcedBlockAttrs(editor, newBlock);
          moveToCaretPosition(editor, newBlock);
        }
      }
      dom.setAttrib(newBlock, 'id', '');
      editor.dispatch('NewBlock', { newBlock });
    };
    const fakeEventName$1 = 'insertParagraph';
    const blockbreak = {
      insert: insert$2,
      fakeEventName: fakeEventName$1
    };

    const hasRightSideContent = (schema, container, parentBlock) => {
      const walker = new DomTreeWalker(container, parentBlock);
      let node;
      const nonEmptyElementsMap = schema.getNonEmptyElements();
      while (node = walker.next()) {
        if (nonEmptyElementsMap[node.nodeName.toLowerCase()] || isText$a(node) && node.length > 0) {
          return true;
        }
      }
      return false;
    };
    const moveSelectionToBr = (editor, brElm, extraBr) => {
      const rng = editor.dom.createRng();
      if (!extraBr) {
        rng.setStartAfter(brElm);
        rng.setEndAfter(brElm);
      } else {
        rng.setStartBefore(brElm);
        rng.setEndBefore(brElm);
      }
      editor.selection.setRng(rng);
      scrollRangeIntoView(editor, rng);
    };
    const insertBrAtCaret = (editor, evt) => {
      const selection = editor.selection;
      const dom = editor.dom;
      const rng = selection.getRng();
      let brElm;
      let extraBr = false;
      normalize$2(dom, rng).each(normRng => {
        rng.setStart(normRng.startContainer, normRng.startOffset);
        rng.setEnd(normRng.endContainer, normRng.endOffset);
      });
      let offset = rng.startOffset;
      let container = rng.startContainer;
      if (isElement$6(container) && container.hasChildNodes()) {
        const isAfterLastNodeInContainer = offset > container.childNodes.length - 1;
        container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;
        if (isAfterLastNodeInContainer && isText$a(container)) {
          offset = container.data.length;
        } else {
          offset = 0;
        }
      }
      let parentBlock = dom.getParent(container, dom.isBlock);
      const containerBlock = parentBlock && parentBlock.parentNode ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;
      const containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : '';
      const isControlKey = !!(evt && evt.ctrlKey);
      if (containerBlockName === 'LI' && !isControlKey) {
        parentBlock = containerBlock;
      }
      if (isText$a(container) && offset >= container.data.length) {
        if (!hasRightSideContent(editor.schema, container, parentBlock || dom.getRoot())) {
          brElm = dom.create('br');
          rng.insertNode(brElm);
          rng.setStartAfter(brElm);
          rng.setEndAfter(brElm);
          extraBr = true;
        }
      }
      brElm = dom.create('br');
      rangeInsertNode(dom, rng, brElm);
      moveSelectionToBr(editor, brElm, extraBr);
      editor.undoManager.add();
    };
    const insertBrBefore = (editor, inline) => {
      const br = SugarElement.fromTag('br');
      before$3(SugarElement.fromDom(inline), br);
      editor.undoManager.add();
    };
    const insertBrAfter = (editor, inline) => {
      if (!hasBrAfter(editor.getBody(), inline)) {
        after$4(SugarElement.fromDom(inline), SugarElement.fromTag('br'));
      }
      const br = SugarElement.fromTag('br');
      after$4(SugarElement.fromDom(inline), br);
      moveSelectionToBr(editor, br.dom, false);
      editor.undoManager.add();
    };
    const isBeforeBr = pos => {
      return isBr$6(pos.getNode());
    };
    const hasBrAfter = (rootNode, startNode) => {
      if (isBeforeBr(CaretPosition.after(startNode))) {
        return true;
      } else {
        return nextPosition(rootNode, CaretPosition.after(startNode)).map(pos => {
          return isBr$6(pos.getNode());
        }).getOr(false);
      }
    };
    const isAnchorLink = elm => {
      return elm && elm.nodeName === 'A' && 'href' in elm;
    };
    const isInsideAnchor = location => {
      return location.fold(never, isAnchorLink, isAnchorLink, never);
    };
    const readInlineAnchorLocation = editor => {
      const isInlineTarget$1 = curry(isInlineTarget, editor);
      const position = CaretPosition.fromRangeStart(editor.selection.getRng());
      return readLocation(isInlineTarget$1, editor.getBody(), position).filter(isInsideAnchor);
    };
    const insertBrOutsideAnchor = (editor, location) => {
      location.fold(noop, curry(insertBrBefore, editor), curry(insertBrAfter, editor), noop);
    };
    const insert$1 = (editor, evt) => {
      const anchorLocation = readInlineAnchorLocation(editor);
      if (anchorLocation.isSome()) {
        anchorLocation.each(curry(insertBrOutsideAnchor, editor));
      } else {
        insertBrAtCaret(editor, evt);
      }
    };
    const fakeEventName = 'insertLineBreak';
    const linebreak = {
      insert: insert$1,
      fakeEventName
    };

    const matchesSelector = (editor, selector) => {
      return getParentBlock$1(editor).filter(parentBlock => {
        return selector.length > 0 && is$1(SugarElement.fromDom(parentBlock), selector);
      }).isSome();
    };
    const shouldInsertBr = editor => {
      return matchesSelector(editor, getBrNewLineSelector(editor));
    };
    const shouldBlockNewLine$1 = editor => {
      return matchesSelector(editor, getNoNewLineSelector(editor));
    };

    const newLineAction = Adt.generate([
      { br: [] },
      { block: [] },
      { none: [] }
    ]);
    const shouldBlockNewLine = (editor, _shiftKey) => {
      return shouldBlockNewLine$1(editor);
    };
    const inListBlock = requiredState => {
      return (editor, _shiftKey) => {
        return isListItemParentBlock(editor) === requiredState;
      };
    };
    const inBlock = (blockName, requiredState) => (editor, _shiftKey) => {
      const state = getParentBlockName(editor) === blockName.toUpperCase();
      return state === requiredState;
    };
    const inCefBlock = editor => {
      const editableRoot = getEditableRoot(editor.dom, editor.selection.getStart());
      return isNullable(editableRoot);
    };
    const inPreBlock = requiredState => inBlock('pre', requiredState);
    const inSummaryBlock = () => inBlock('summary', true);
    const shouldPutBrInPre = requiredState => {
      return (editor, _shiftKey) => {
        return shouldPutBrInPre$1(editor) === requiredState;
      };
    };
    const inBrContext = (editor, _shiftKey) => {
      return shouldInsertBr(editor);
    };
    const hasShiftKey = (_editor, shiftKey) => {
      return shiftKey;
    };
    const canInsertIntoEditableRoot = editor => {
      const forcedRootBlock = getForcedRootBlock(editor);
      const rootEditable = getEditableRoot(editor.dom, editor.selection.getStart());
      return isNonNullable(rootEditable) && editor.schema.isValidChild(rootEditable.nodeName, forcedRootBlock);
    };
    const match = (predicates, action) => {
      return (editor, shiftKey) => {
        const isMatch = foldl(predicates, (res, p) => {
          return res && p(editor, shiftKey);
        }, true);
        return isMatch ? Optional.some(action) : Optional.none();
      };
    };
    const getAction = (editor, evt) => {
      return evaluateUntil([
        match([shouldBlockNewLine], newLineAction.none()),
        match([
          inPreBlock(true),
          inCefBlock
        ], newLineAction.none()),
        match([inSummaryBlock()], newLineAction.br()),
        match([
          inPreBlock(true),
          shouldPutBrInPre(false),
          hasShiftKey
        ], newLineAction.br()),
        match([
          inPreBlock(true),
          shouldPutBrInPre(false)
        ], newLineAction.block()),
        match([
          inPreBlock(true),
          shouldPutBrInPre(true),
          hasShiftKey
        ], newLineAction.block()),
        match([
          inPreBlock(true),
          shouldPutBrInPre(true)
        ], newLineAction.br()),
        match([
          inListBlock(true),
          hasShiftKey
        ], newLineAction.br()),
        match([inListBlock(true)], newLineAction.block()),
        match([inBrContext], newLineAction.br()),
        match([hasShiftKey], newLineAction.br()),
        match([canInsertIntoEditableRoot], newLineAction.block())
      ], [
        editor,
        !!(evt && evt.shiftKey)
      ]).getOr(newLineAction.none());
    };

    const insertBreak = (breakType, editor, evt) => {
      if (!editor.selection.isCollapsed()) {
        execEditorDeleteCommand(editor);
      }
      if (isNonNullable(evt)) {
        const event = fireFakeBeforeInputEvent(editor, breakType.fakeEventName);
        if (event.isDefaultPrevented()) {
          return;
        }
      }
      breakType.insert(editor, evt);
      if (isNonNullable(evt)) {
        fireFakeInputEvent(editor, breakType.fakeEventName);
      }
    };
    const insert = (editor, evt) => {
      const br = () => insertBreak(linebreak, editor, evt);
      const block = () => insertBreak(blockbreak, editor, evt);
      const logicalAction = getAction(editor, evt);
      switch (getNewlineBehavior(editor)) {
      case 'linebreak':
        logicalAction.fold(br, br, noop);
        break;
      case 'block':
        logicalAction.fold(block, block, noop);
        break;
      case 'invert':
        logicalAction.fold(block, br, noop);
        break;
      default:
        logicalAction.fold(br, block, noop);
        break;
      }
    };

    const handleEnterKeyEvent = (editor, event) => {
      if (event.isDefaultPrevented()) {
        return;
      }
      event.preventDefault();
      endTypingLevelIgnoreLocks(editor.undoManager);
      editor.undoManager.transact(() => {
        insert(editor, event);
      });
    };
    const setup$h = editor => {
      editor.on('keydown', event => {
        if (event.keyCode === VK.ENTER) {
          handleEnterKeyEvent(editor, event);
        }
      });
    };

    const executeKeydownOverride$2 = (editor, caret, evt) => {
      const isMac = Env.os.isMacOS() || Env.os.isiOS();
      execute([
        {
          keyCode: VK.END,
          action: action(moveToLineEndPoint$1, editor, true)
        },
        {
          keyCode: VK.HOME,
          action: action(moveToLineEndPoint$1, editor, false)
        },
        ...!isMac ? [
          {
            keyCode: VK.HOME,
            action: action(selectToEndPoint, editor, false),
            ctrlKey: true,
            shiftKey: true
          },
          {
            keyCode: VK.END,
            action: action(selectToEndPoint, editor, true),
            ctrlKey: true,
            shiftKey: true
          }
        ] : [],
        {
          keyCode: VK.END,
          action: action(moveToLineEndPoint, editor, true)
        },
        {
          keyCode: VK.HOME,
          action: action(moveToLineEndPoint, editor, false)
        },
        {
          keyCode: VK.END,
          action: action(moveToLineEndPoint$2, editor, true, caret)
        },
        {
          keyCode: VK.HOME,
          action: action(moveToLineEndPoint$2, editor, false, caret)
        }
      ], evt).each(_ => {
        evt.preventDefault();
      });
    };
    const setup$g = (editor, caret) => {
      editor.on('keydown', evt => {
        if (!evt.isDefaultPrevented()) {
          executeKeydownOverride$2(editor, caret, evt);
        }
      });
    };

    const setup$f = editor => {
      editor.on('input', e => {
        if (!e.isComposing) {
          normalizeNbspsInEditor(editor);
        }
      });
    };

    const platform = detect$2();
    const executeKeyupAction = (editor, caret, evt) => {
      execute([
        {
          keyCode: VK.PAGE_UP,
          action: action(moveToLineEndPoint$2, editor, false, caret)
        },
        {
          keyCode: VK.PAGE_DOWN,
          action: action(moveToLineEndPoint$2, editor, true, caret)
        }
      ], evt);
    };
    const stopImmediatePropagation = e => e.stopImmediatePropagation();
    const isPageUpDown = evt => evt.keyCode === VK.PAGE_UP || evt.keyCode === VK.PAGE_DOWN;
    const setNodeChangeBlocker = (blocked, editor, block) => {
      if (block && !blocked.get()) {
        editor.on('NodeChange', stopImmediatePropagation, true);
      } else if (!block && blocked.get()) {
        editor.off('NodeChange', stopImmediatePropagation);
      }
      blocked.set(block);
    };
    const setup$e = (editor, caret) => {
      if (platform.os.isMacOS()) {
        return;
      }
      const blocked = Cell(false);
      editor.on('keydown', evt => {
        if (isPageUpDown(evt)) {
          setNodeChangeBlocker(blocked, editor, true);
        }
      });
      editor.on('keyup', evt => {
        if (!evt.isDefaultPrevented()) {
          executeKeyupAction(editor, caret, evt);
        }
        if (isPageUpDown(evt) && blocked.get()) {
          setNodeChangeBlocker(blocked, editor, false);
          editor.nodeChanged();
        }
      });
    };

    const insertTextAtPosition = (text, pos) => {
      const container = pos.container();
      const offset = pos.offset();
      if (isText$a(container)) {
        container.insertData(offset, text);
        return Optional.some(CaretPosition(container, offset + text.length));
      } else {
        return getElementFromPosition(pos).map(elm => {
          const textNode = SugarElement.fromText(text);
          if (pos.isAtEnd()) {
            after$4(elm, textNode);
          } else {
            before$3(elm, textNode);
          }
          return CaretPosition(textNode.dom, text.length);
        });
      }
    };
    const insertNbspAtPosition = curry(insertTextAtPosition, nbsp);
    const insertSpaceAtPosition = curry(insertTextAtPosition, ' ');

    const locationToCaretPosition = root => location => location.fold(element => prevPosition(root.dom, CaretPosition.before(element)), element => firstPositionIn(element), element => lastPositionIn(element), element => nextPosition(root.dom, CaretPosition.after(element)));
    const insertInlineBoundarySpaceOrNbsp = (root, pos) => checkPos => needsToHaveNbsp(root, checkPos) ? insertNbspAtPosition(pos) : insertSpaceAtPosition(pos);
    const setSelection = editor => pos => {
      editor.selection.setRng(pos.toRange());
      editor.nodeChanged();
      return true;
    };
    const insertSpaceOrNbspAtSelection = editor => {
      const pos = CaretPosition.fromRangeStart(editor.selection.getRng());
      const root = SugarElement.fromDom(editor.getBody());
      if (editor.selection.isCollapsed()) {
        const isInlineTarget$1 = curry(isInlineTarget, editor);
        const caretPosition = CaretPosition.fromRangeStart(editor.selection.getRng());
        return readLocation(isInlineTarget$1, editor.getBody(), caretPosition).bind(locationToCaretPosition(root)).map(checkPos => () => insertInlineBoundarySpaceOrNbsp(root, pos)(checkPos).each(setSelection(editor)));
      } else {
        return Optional.none();
      }
    };

    const executeKeydownOverride$1 = (editor, evt) => {
      executeWithDelayedAction([{
          keyCode: VK.SPACEBAR,
          action: action(insertSpaceOrNbspAtSelection, editor)
        }], evt).each(applyAction => {
        evt.preventDefault();
        const event = fireFakeBeforeInputEvent(editor, 'insertText', { data: ' ' });
        if (!event.isDefaultPrevented()) {
          applyAction();
          fireFakeInputEvent(editor, 'insertText', { data: ' ' });
        }
      });
    };
    const setup$d = editor => {
      editor.on('keydown', evt => {
        if (!evt.isDefaultPrevented()) {
          executeKeydownOverride$1(editor, evt);
        }
      });
    };

    const tableTabNavigation = editor => {
      if (hasTableTabNavigation(editor)) {
        return [
          {
            keyCode: VK.TAB,
            action: action(handleTab, editor, true)
          },
          {
            keyCode: VK.TAB,
            shiftKey: true,
            action: action(handleTab, editor, false)
          }
        ];
      } else {
        return [];
      }
    };
    const executeKeydownOverride = (editor, evt) => {
      execute([...tableTabNavigation(editor)], evt).each(_ => {
        evt.preventDefault();
      });
    };
    const setup$c = editor => {
      editor.on('keydown', evt => {
        if (!evt.isDefaultPrevented()) {
          executeKeydownOverride(editor, evt);
        }
      });
    };

    const setup$b = editor => {
      editor.addShortcut('Meta+P', '', 'mcePrint');
      setup$j(editor);
      if (isRtc(editor)) {
        return Cell(null);
      } else {
        const caret = setupSelectedState(editor);
        setup$l(editor);
        setup$k(editor, caret);
        setup$i(editor, caret);
        setup$h(editor);
        setup$d(editor);
        setup$f(editor);
        setup$c(editor);
        setup$g(editor, caret);
        setup$e(editor, caret);
        return caret;
      }
    };

    class NodeChange {
      constructor(editor) {
        this.lastPath = [];
        this.editor = editor;
        let lastRng;
        const self = this;
        if (!('onselectionchange' in editor.getDoc())) {
          editor.on('NodeChange click mouseup keyup focus', e => {
            const nativeRng = editor.selection.getRng();
            const fakeRng = {
              startContainer: nativeRng.startContainer,
              startOffset: nativeRng.startOffset,
              endContainer: nativeRng.endContainer,
              endOffset: nativeRng.endOffset
            };
            if (e.type === 'nodechange' || !isEq$4(fakeRng, lastRng)) {
              editor.dispatch('SelectionChange');
            }
            lastRng = fakeRng;
          });
        }
        editor.on('contextmenu', () => {
          editor.dispatch('SelectionChange');
        });
        editor.on('SelectionChange', () => {
          const startElm = editor.selection.getStart(true);
          if (!startElm) {
            return;
          }
          if (hasAnyRanges(editor) && !self.isSameElementPath(startElm) && editor.dom.isChildOf(startElm, editor.getBody())) {
            editor.nodeChanged({ selectionChange: true });
          }
        });
        editor.on('mouseup', e => {
          if (!e.isDefaultPrevented() && hasAnyRanges(editor)) {
            if (editor.selection.getNode().nodeName === 'IMG') {
              Delay.setEditorTimeout(editor, () => {
                editor.nodeChanged();
              });
            } else {
              editor.nodeChanged();
            }
          }
        });
      }
      nodeChanged(args = {}) {
        const selection = this.editor.selection;
        let node;
        if (this.editor.initialized && selection && !shouldDisableNodeChange(this.editor) && !this.editor.mode.isReadOnly()) {
          const root = this.editor.getBody();
          node = selection.getStart(true) || root;
          if (node.ownerDocument !== this.editor.getDoc() || !this.editor.dom.isChildOf(node, root)) {
            node = root;
          }
          const parents = [];
          this.editor.dom.getParent(node, node => {
            if (node === root) {
              return true;
            } else {
              parents.push(node);
              return false;
            }
          });
          this.editor.dispatch('NodeChange', {
            ...args,
            element: node,
            parents
          });
        }
      }
      isSameElementPath(startElm) {
        let i;
        const editor = this.editor;
        const currentPath = reverse(editor.dom.getParents(startElm, always, editor.getBody()));
        if (currentPath.length === this.lastPath.length) {
          for (i = currentPath.length; i >= 0; i--) {
            if (currentPath[i] !== this.lastPath[i]) {
              break;
            }
          }
          if (i === -1) {
            this.lastPath = currentPath;
            return true;
          }
        }
        this.lastPath = currentPath;
        return false;
      }
    }

    const internalMimeType = 'x-tinymce/html';
    const internalHtmlMime = constant(internalMimeType);
    const internalMark = '<!-- ' + internalMimeType + ' -->';
    const mark = html => internalMark + html;
    const unmark = html => html.replace(internalMark, '');
    const isMarked = html => html.indexOf(internalMark) !== -1;

    const isPlainText = text => {
      return !/<(?:\/?(?!(?:div|p|br|span)>)\w+|(?:(?!(?:span style="white-space:\s?pre;?">)|br\s?\/>))\w+\s[^>]+)>/i.test(text);
    };
    const openContainer = (rootTag, rootAttrs) => {
      let tag = '<' + rootTag;
      const attrs = mapToArray(rootAttrs, (value, key) => key + '="' + Entities.encodeAllRaw(value) + '"');
      if (attrs.length) {
        tag += ' ' + attrs.join(' ');
      }
      return tag + '>';
    };
    const toBlockElements = (text, rootTag, rootAttrs) => {
      const blocks = text.split(/\n\n/);
      const tagOpen = openContainer(rootTag, rootAttrs);
      const tagClose = '</' + rootTag + '>';
      const paragraphs = map$3(blocks, p => {
        return p.split(/\n/).join('<br />');
      });
      const stitch = p => {
        return tagOpen + p + tagClose;
      };
      return paragraphs.length === 1 ? paragraphs[0] : map$3(paragraphs, stitch).join('');
    };

    const pasteBinDefaultContent = '%MCEPASTEBIN%';
    const create$6 = (editor, lastRngCell) => {
      const {dom, selection} = editor;
      const body = editor.getBody();
      lastRngCell.set(selection.getRng());
      const pasteBinElm = dom.add(editor.getBody(), 'div', {
        'id': 'mcepastebin',
        'class': 'mce-pastebin',
        'contentEditable': true,
        'data-mce-bogus': 'all',
        'style': 'position: fixed; top: 50%; width: 10px; height: 10px; overflow: hidden; opacity: 0'
      }, pasteBinDefaultContent);
      if (Env.browser.isFirefox()) {
        dom.setStyle(pasteBinElm, 'left', dom.getStyle(body, 'direction', true) === 'rtl' ? 65535 : -65535);
      }
      dom.bind(pasteBinElm, 'beforedeactivate focusin focusout', e => {
        e.stopPropagation();
      });
      pasteBinElm.focus();
      selection.select(pasteBinElm, true);
    };
    const remove = (editor, lastRngCell) => {
      const dom = editor.dom;
      if (getEl(editor)) {
        let pasteBinClone;
        const lastRng = lastRngCell.get();
        while (pasteBinClone = getEl(editor)) {
          dom.remove(pasteBinClone);
          dom.unbind(pasteBinClone);
        }
        if (lastRng) {
          editor.selection.setRng(lastRng);
        }
      }
      lastRngCell.set(null);
    };
    const getEl = editor => editor.dom.get('mcepastebin');
    const isPasteBin = elm => isNonNullable(elm) && elm.id === 'mcepastebin';
    const getHtml = editor => {
      const dom = editor.dom;
      const copyAndRemove = (toElm, fromElm) => {
        toElm.appendChild(fromElm);
        dom.remove(fromElm, true);
      };
      const [pasteBinElm, ...pasteBinClones] = filter$5(editor.getBody().childNodes, isPasteBin);
      each$e(pasteBinClones, pasteBinClone => {
        copyAndRemove(pasteBinElm, pasteBinClone);
      });
      const dirtyWrappers = dom.select('div[id=mcepastebin]', pasteBinElm);
      for (let i = dirtyWrappers.length - 1; i >= 0; i--) {
        const cleanWrapper = dom.create('div');
        pasteBinElm.insertBefore(cleanWrapper, dirtyWrappers[i]);
        copyAndRemove(cleanWrapper, dirtyWrappers[i]);
      }
      return pasteBinElm ? pasteBinElm.innerHTML : '';
    };
    const isDefaultPasteBinContent = content => content === pasteBinDefaultContent;
    const PasteBin = editor => {
      const lastRng = Cell(null);
      return {
        create: () => create$6(editor, lastRng),
        remove: () => remove(editor, lastRng),
        getEl: () => getEl(editor),
        getHtml: () => getHtml(editor),
        getLastRng: lastRng.get
      };
    };

    const filter$1 = (content, items) => {
      Tools.each(items, v => {
        if (is$4(v, RegExp)) {
          content = content.replace(v, '');
        } else {
          content = content.replace(v[0], v[1]);
        }
      });
      return content;
    };
    const innerText = html => {
      const schema = Schema();
      const domParser = DomParser({}, schema);
      let text = '';
      const voidElements = schema.getVoidElements();
      const ignoreElements = Tools.makeMap('script noscript style textarea video audio iframe object', ' ');
      const blockElements = schema.getBlockElements();
      const walk = node => {
        const name = node.name, currentNode = node;
        if (name === 'br') {
          text += '\n';
          return;
        }
        if (name === 'wbr') {
          return;
        }
        if (voidElements[name]) {
          text += ' ';
        }
        if (ignoreElements[name]) {
          text += ' ';
          return;
        }
        if (node.type === 3) {
          text += node.value;
        }
        if (!(node.name in schema.getVoidElements())) {
          let currentNode = node.firstChild;
          if (currentNode) {
            do {
              walk(currentNode);
            } while (currentNode = currentNode.next);
          }
        }
        if (blockElements[name] && currentNode.next) {
          text += '\n';
          if (name === 'p') {
            text += '\n';
          }
        }
      };
      html = filter$1(html, [/<!\[[^\]]+\]>/g]);
      walk(domParser.parse(html));
      return text;
    };
    const trimHtml = html => {
      const trimSpaces = (all, s1, s2) => {
        if (!s1 && !s2) {
          return ' ';
        }
        return nbsp;
      };
      html = filter$1(html, [
        /^[\s\S]*<body[^>]*>\s*|\s*<\/body[^>]*>[\s\S]*$/ig,
        /<!--StartFragment-->|<!--EndFragment-->/g,
        [
          /( ?)<span class="Apple-converted-space">\u00a0<\/span>( ?)/g,
          trimSpaces
        ],
        /<br class="Apple-interchange-newline">/g,
        /<br>$/i
      ]);
      return html;
    };
    const createIdGenerator = prefix => {
      let count = 0;
      return () => {
        return prefix + count++;
      };
    };
    const getImageMimeType = ext => {
      const lowerExt = ext.toLowerCase();
      const mimeOverrides = {
        jpg: 'jpeg',
        jpe: 'jpeg',
        jfi: 'jpeg',
        jif: 'jpeg',
        jfif: 'jpeg',
        pjpeg: 'jpeg',
        pjp: 'jpeg',
        svg: 'svg+xml'
      };
      return Tools.hasOwn(mimeOverrides, lowerExt) ? 'image/' + mimeOverrides[lowerExt] : 'image/' + lowerExt;
    };

    const preProcess = (editor, html) => {
      const parser = DomParser({ sanitize: shouldSanitizeXss(editor) }, editor.schema);
      parser.addNodeFilter('meta', nodes => {
        Tools.each(nodes, node => {
          node.remove();
        });
      });
      const fragment = parser.parse(html, {
        forced_root_block: false,
        isRootContent: true
      });
      return HtmlSerializer({ validate: true }, editor.schema).serialize(fragment);
    };
    const processResult = (content, cancelled) => ({
      content,
      cancelled
    });
    const postProcessFilter = (editor, html, internal) => {
      const tempBody = editor.dom.create('div', { style: 'display:none' }, html);
      const postProcessArgs = firePastePostProcess(editor, tempBody, internal);
      return processResult(postProcessArgs.node.innerHTML, postProcessArgs.isDefaultPrevented());
    };
    const filterContent = (editor, content, internal) => {
      const preProcessArgs = firePastePreProcess(editor, content, internal);
      const filteredContent = preProcess(editor, preProcessArgs.content);
      if (editor.hasEventListeners('PastePostProcess') && !preProcessArgs.isDefaultPrevented()) {
        return postProcessFilter(editor, filteredContent, internal);
      } else {
        return processResult(filteredContent, preProcessArgs.isDefaultPrevented());
      }
    };
    const process = (editor, html, internal) => {
      return filterContent(editor, html, internal);
    };

    const pasteHtml$1 = (editor, html) => {
      editor.insertContent(html, {
        merge: shouldPasteMergeFormats(editor),
        paste: true
      });
      return true;
    };
    const isAbsoluteUrl = url => /^https?:\/\/[\w\-\/+=.,!;:&%@^~(){}?#]+$/i.test(url);
    const isImageUrl = (editor, url) => {
      return isAbsoluteUrl(url) && exists(getAllowedImageFileTypes(editor), type => endsWith(url.toLowerCase(), `.${ type.toLowerCase() }`));
    };
    const createImage = (editor, url, pasteHtmlFn) => {
      editor.undoManager.extra(() => {
        pasteHtmlFn(editor, url);
      }, () => {
        editor.insertContent('<img src="' + url + '">');
      });
      return true;
    };
    const createLink = (editor, url, pasteHtmlFn) => {
      editor.undoManager.extra(() => {
        pasteHtmlFn(editor, url);
      }, () => {
        editor.execCommand('mceInsertLink', false, url);
      });
      return true;
    };
    const linkSelection = (editor, html, pasteHtmlFn) => !editor.selection.isCollapsed() && isAbsoluteUrl(html) ? createLink(editor, html, pasteHtmlFn) : false;
    const insertImage = (editor, html, pasteHtmlFn) => isImageUrl(editor, html) ? createImage(editor, html, pasteHtmlFn) : false;
    const smartInsertContent = (editor, html) => {
      Tools.each([
        linkSelection,
        insertImage,
        pasteHtml$1
      ], action => {
        return !action(editor, html, pasteHtml$1);
      });
    };
    const insertContent = (editor, html, pasteAsText) => {
      if (pasteAsText || !isSmartPasteEnabled(editor)) {
        pasteHtml$1(editor, html);
      } else {
        smartInsertContent(editor, html);
      }
    };

    const uniqueId = createIdGenerator('mceclip');
    const doPaste = (editor, content, internal, pasteAsText) => {
      const args = process(editor, content, internal);
      if (!args.cancelled) {
        insertContent(editor, args.content, pasteAsText);
      }
    };
    const pasteHtml = (editor, html, internalFlag) => {
      const internal = internalFlag ? internalFlag : isMarked(html);
      doPaste(editor, unmark(html), internal, false);
    };
    const pasteText = (editor, text) => {
      const encodedText = editor.dom.encode(text).replace(/\r\n/g, '\n');
      const normalizedText = normalize$4(encodedText, getPasteTabSpaces(editor));
      const html = toBlockElements(normalizedText, getForcedRootBlock(editor), getForcedRootBlockAttrs(editor));
      doPaste(editor, html, false, true);
    };
    const getDataTransferItems = dataTransfer => {
      const items = {};
      if (dataTransfer && dataTransfer.types) {
        for (let i = 0; i < dataTransfer.types.length; i++) {
          const contentType = dataTransfer.types[i];
          try {
            items[contentType] = dataTransfer.getData(contentType);
          } catch (ex) {
            items[contentType] = '';
          }
        }
      }
      return items;
    };
    const hasContentType = (clipboardContent, mimeType) => mimeType in clipboardContent && clipboardContent[mimeType].length > 0;
    const hasHtmlOrText = content => hasContentType(content, 'text/html') || hasContentType(content, 'text/plain');
    const extractFilename = (editor, str) => {
      const m = str.match(/([\s\S]+?)(?:\.[a-z0-9.]+)$/i);
      return isNonNullable(m) ? editor.dom.encode(m[1]) : undefined;
    };
    const createBlobInfo = (editor, blobCache, file, base64) => {
      const id = uniqueId();
      const useFileName = shouldReuseFileName(editor) && isNonNullable(file.name);
      const name = useFileName ? extractFilename(editor, file.name) : id;
      const filename = useFileName ? file.name : undefined;
      const blobInfo = blobCache.create(id, file, base64, name, filename);
      blobCache.add(blobInfo);
      return blobInfo;
    };
    const pasteImage = (editor, imageItem) => {
      parseDataUri(imageItem.uri).each(({data, type, base64Encoded}) => {
        const base64 = base64Encoded ? data : btoa(data);
        const file = imageItem.file;
        const blobCache = editor.editorUpload.blobCache;
        const existingBlobInfo = blobCache.getByData(base64, type);
        const blobInfo = existingBlobInfo !== null && existingBlobInfo !== void 0 ? existingBlobInfo : createBlobInfo(editor, blobCache, file, base64);
        pasteHtml(editor, `<img src="${ blobInfo.blobUri() }">`, false);
      });
    };
    const isClipboardEvent = event => event.type === 'paste';
    const readFilesAsDataUris = items => Promise.all(map$3(items, file => {
      return blobToDataUri(file).then(uri => ({
        file,
        uri
      }));
    }));
    const isImage = editor => {
      const allowedExtensions = getAllowedImageFileTypes(editor);
      return file => startsWith(file.type, 'image/') && exists(allowedExtensions, extension => {
        return getImageMimeType(extension) === file.type;
      });
    };
    const getImagesFromDataTransfer = (editor, dataTransfer) => {
      const items = dataTransfer.items ? bind$3(from(dataTransfer.items), item => {
        return item.kind === 'file' ? [item.getAsFile()] : [];
      }) : [];
      const files = dataTransfer.files ? from(dataTransfer.files) : [];
      return filter$5(items.length > 0 ? items : files, isImage(editor));
    };
    const pasteImageData = (editor, e, rng) => {
      const dataTransfer = isClipboardEvent(e) ? e.clipboardData : e.dataTransfer;
      if (shouldPasteDataImages(editor) && dataTransfer) {
        const images = getImagesFromDataTransfer(editor, dataTransfer);
        if (images.length > 0) {
          e.preventDefault();
          readFilesAsDataUris(images).then(fileResults => {
            if (rng) {
              editor.selection.setRng(rng);
            }
            each$e(fileResults, result => {
              pasteImage(editor, result);
            });
          });
          return true;
        }
      }
      return false;
    };
    const isBrokenAndroidClipboardEvent = e => {
      var _a, _b;
      return Env.os.isAndroid() && ((_b = (_a = e.clipboardData) === null || _a === void 0 ? void 0 : _a.items) === null || _b === void 0 ? void 0 : _b.length) === 0;
    };
    const isKeyboardPasteEvent = e => VK.metaKeyPressed(e) && e.keyCode === 86 || e.shiftKey && e.keyCode === 45;
    const insertClipboardContent = (editor, clipboardContent, html, plainTextMode) => {
      let content = trimHtml(html);
      const isInternal = hasContentType(clipboardContent, internalHtmlMime()) || isMarked(html);
      const isPlainTextHtml = !isInternal && isPlainText(content);
      const isAbsoluteUrl$1 = isAbsoluteUrl(content);
      if (isDefaultPasteBinContent(content) || !content.length || isPlainTextHtml && !isAbsoluteUrl$1) {
        plainTextMode = true;
      }
      if (plainTextMode || isAbsoluteUrl$1) {
        if (hasContentType(clipboardContent, 'text/plain') && isPlainTextHtml) {
          content = clipboardContent['text/plain'];
        } else {
          content = innerText(content);
        }
      }
      if (isDefaultPasteBinContent(content)) {
        return;
      }
      if (plainTextMode) {
        pasteText(editor, content);
      } else {
        pasteHtml(editor, content, isInternal);
      }
    };
    const registerEventHandlers = (editor, pasteBin, pasteFormat) => {
      let keyboardPastePlainTextState;
      const getLastRng = () => pasteBin.getLastRng() || editor.selection.getRng();
      editor.on('keydown', e => {
        if (isKeyboardPasteEvent(e) && !e.isDefaultPrevented()) {
          keyboardPastePlainTextState = e.shiftKey && e.keyCode === 86;
        }
      });
      editor.on('paste', e => {
        if (e.isDefaultPrevented() || isBrokenAndroidClipboardEvent(e)) {
          return;
        }
        const plainTextMode = pasteFormat.get() === 'text' || keyboardPastePlainTextState;
        keyboardPastePlainTextState = false;
        const clipboardContent = getDataTransferItems(e.clipboardData);
        if (!hasHtmlOrText(clipboardContent) && pasteImageData(editor, e, getLastRng())) {
          return;
        }
        if (hasContentType(clipboardContent, 'text/html')) {
          e.preventDefault();
          insertClipboardContent(editor, clipboardContent, clipboardContent['text/html'], plainTextMode);
        } else if (hasContentType(clipboardContent, 'text/plain') && hasContentType(clipboardContent, 'text/uri-list')) {
          e.preventDefault();
          insertClipboardContent(editor, clipboardContent, clipboardContent['text/plain'], plainTextMode);
        } else {
          pasteBin.create();
          Delay.setEditorTimeout(editor, () => {
            const html = pasteBin.getHtml();
            pasteBin.remove();
            insertClipboardContent(editor, clipboardContent, html, plainTextMode);
          }, 0);
        }
      });
    };
    const registerDataImageFilter = editor => {
      const isWebKitFakeUrl = src => startsWith(src, 'webkit-fake-url');
      const isDataUri = src => startsWith(src, 'data:');
      const isPasteInsert = args => {
        var _a;
        return ((_a = args.data) === null || _a === void 0 ? void 0 : _a.paste) === true;
      };
      editor.parser.addNodeFilter('img', (nodes, name, args) => {
        if (!shouldPasteDataImages(editor) && isPasteInsert(args)) {
          for (const node of nodes) {
            const src = node.attr('src');
            if (isString(src) && !node.attr('data-mce-object') && src !== Env.transparentSrc) {
              if (isWebKitFakeUrl(src)) {
                node.remove();
              } else if (!shouldAllowHtmlDataUrls(editor) && isDataUri(src)) {
                node.remove();
              }
            }
          }
        }
      });
    };
    const registerEventsAndFilters = (editor, pasteBin, pasteFormat) => {
      registerEventHandlers(editor, pasteBin, pasteFormat);
      registerDataImageFilter(editor);
    };

    const togglePlainTextPaste = (editor, pasteFormat) => {
      if (pasteFormat.get() === 'text') {
        pasteFormat.set('html');
        firePastePlainTextToggle(editor, false);
      } else {
        pasteFormat.set('text');
        firePastePlainTextToggle(editor, true);
      }
      editor.focus();
    };
    const register$1 = (editor, pasteFormat) => {
      editor.addCommand('mceTogglePlainTextPaste', () => {
        togglePlainTextPaste(editor, pasteFormat);
      });
      editor.addCommand('mceInsertClipboardContent', (ui, value) => {
        if (value.html) {
          pasteHtml(editor, value.html, value.internal);
        }
        if (value.text) {
          pasteText(editor, value.text);
        }
      });
    };

    const setHtml5Clipboard = (clipboardData, html, text) => {
      if (clipboardData) {
        try {
          clipboardData.clearData();
          clipboardData.setData('text/html', html);
          clipboardData.setData('text/plain', text);
          clipboardData.setData(internalHtmlMime(), html);
          return true;
        } catch (e) {
          return false;
        }
      } else {
        return false;
      }
    };
    const setClipboardData = (evt, data, fallback, done) => {
      if (setHtml5Clipboard(evt.clipboardData, data.html, data.text)) {
        evt.preventDefault();
        done();
      } else {
        fallback(data.html, done);
      }
    };
    const fallback$1 = editor => (html, done) => {
      const {dom, selection} = editor;
      const outer = dom.create('div', {
        'contenteditable': 'false',
        'data-mce-bogus': 'all'
      });
      const inner = dom.create('div', { contenteditable: 'true' }, html);
      dom.setStyles(outer, {
        position: 'fixed',
        top: '0',
        left: '-3000px',
        width: '1000px',
        overflow: 'hidden'
      });
      outer.appendChild(inner);
      dom.add(editor.getBody(), outer);
      const range = selection.getRng();
      inner.focus();
      const offscreenRange = dom.createRng();
      offscreenRange.selectNodeContents(inner);
      selection.setRng(offscreenRange);
      Delay.setEditorTimeout(editor, () => {
        selection.setRng(range);
        dom.remove(outer);
        done();
      }, 0);
    };
    const getData = editor => ({
      html: mark(editor.selection.getContent({ contextual: true })),
      text: editor.selection.getContent({ format: 'text' })
    });
    const isTableSelection = editor => !!editor.dom.getParent(editor.selection.getStart(), 'td[data-mce-selected],th[data-mce-selected]', editor.getBody());
    const hasSelectedContent = editor => !editor.selection.isCollapsed() || isTableSelection(editor);
    const cut = editor => evt => {
      if (!evt.isDefaultPrevented() && hasSelectedContent(editor)) {
        setClipboardData(evt, getData(editor), fallback$1(editor), () => {
          if (Env.browser.isChromium() || Env.browser.isFirefox()) {
            const rng = editor.selection.getRng();
            Delay.setEditorTimeout(editor, () => {
              editor.selection.setRng(rng);
              editor.execCommand('Delete');
            }, 0);
          } else {
            editor.execCommand('Delete');
          }
        });
      }
    };
    const copy = editor => evt => {
      if (!evt.isDefaultPrevented() && hasSelectedContent(editor)) {
        setClipboardData(evt, getData(editor), fallback$1(editor), noop);
      }
    };
    const register = editor => {
      editor.on('cut', cut(editor));
      editor.on('copy', copy(editor));
    };

    const getCaretRangeFromEvent = (editor, e) => {
      var _a, _b;
      return RangeUtils.getCaretRangeFromPoint((_a = e.clientX) !== null && _a !== void 0 ? _a : 0, (_b = e.clientY) !== null && _b !== void 0 ? _b : 0, editor.getDoc());
    };
    const isPlainTextFileUrl = content => {
      const plainTextContent = content['text/plain'];
      return plainTextContent ? plainTextContent.indexOf('file://') === 0 : false;
    };
    const setFocusedRange = (editor, rng) => {
      editor.focus();
      if (rng) {
        editor.selection.setRng(rng);
      }
    };
    const hasImage = dataTransfer => exists(dataTransfer.files, file => /^image\//.test(file.type));
    const isTransparentBlockDrop = (dom, schema, target, dropContent) => {
      const parentTransparent = dom.getParent(target, node => isTransparentBlock(schema, node));
      if (parentTransparent && has$2(dropContent, 'text/html')) {
        const fragment = new DOMParser().parseFromString(dropContent['text/html'], 'text/html').body;
        return !isNull(fragment.querySelector(parentTransparent.nodeName.toLowerCase()));
      } else {
        return false;
      }
    };
    const setup$a = (editor, draggingInternallyState) => {
      if (shouldPasteBlockDrop(editor)) {
        editor.on('dragend dragover draggesture dragdrop drop drag', e => {
          e.preventDefault();
          e.stopPropagation();
        });
      }
      if (!shouldPasteDataImages(editor)) {
        editor.on('drop', e => {
          const dataTransfer = e.dataTransfer;
          if (dataTransfer && hasImage(dataTransfer)) {
            e.preventDefault();
          }
        });
      }
      editor.on('drop', e => {
        if (e.isDefaultPrevented()) {
          return;
        }
        const rng = getCaretRangeFromEvent(editor, e);
        if (isNullable(rng)) {
          return;
        }
        const dropContent = getDataTransferItems(e.dataTransfer);
        const internal = hasContentType(dropContent, internalHtmlMime());
        if ((!hasHtmlOrText(dropContent) || isPlainTextFileUrl(dropContent)) && pasteImageData(editor, e, rng)) {
          return;
        }
        const internalContent = dropContent[internalHtmlMime()];
        const content = internalContent || dropContent['text/html'] || dropContent['text/plain'];
        const transparentElementDrop = isTransparentBlockDrop(editor.dom, editor.schema, rng.startContainer, dropContent);
        if (draggingInternallyState.get() && !transparentElementDrop) {
          return;
        }
        if (content) {
          e.preventDefault();
          Delay.setEditorTimeout(editor, () => {
            editor.undoManager.transact(() => {
              if (internalContent) {
                editor.execCommand('Delete');
              }
              setFocusedRange(editor, rng);
              const trimmedContent = trimHtml(content);
              if (dropContent['text/html']) {
                pasteHtml(editor, trimmedContent, internal);
              } else {
                pasteText(editor, trimmedContent);
              }
            });
          });
        }
      });
      editor.on('dragstart', _e => {
        draggingInternallyState.set(true);
      });
      editor.on('dragover dragend', e => {
        if (shouldPasteDataImages(editor) && !draggingInternallyState.get()) {
          e.preventDefault();
          setFocusedRange(editor, getCaretRangeFromEvent(editor, e));
        }
        if (e.type === 'dragend') {
          draggingInternallyState.set(false);
        }
      });
    };

    const setup$9 = editor => {
      const processEvent = f => e => {
        f(editor, e);
      };
      const preProcess = getPastePreProcess(editor);
      if (isFunction(preProcess)) {
        editor.on('PastePreProcess', processEvent(preProcess));
      }
      const postProcess = getPastePostProcess(editor);
      if (isFunction(postProcess)) {
        editor.on('PastePostProcess', processEvent(postProcess));
      }
    };

    const addPreProcessFilter = (editor, filterFunc) => {
      editor.on('PastePreProcess', e => {
        e.content = filterFunc(editor, e.content, e.internal);
      });
    };
    const rgbRegExp = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/gi;
    const rgbToHex = value => Tools.trim(value).replace(rgbRegExp, rgbaToHexString).toLowerCase();
    const removeWebKitStyles = (editor, content, internal) => {
      const webKitStylesOption = getPasteWebkitStyles(editor);
      if (internal || webKitStylesOption === 'all' || !shouldPasteRemoveWebKitStyles(editor)) {
        return content;
      }
      const webKitStyles = webKitStylesOption ? webKitStylesOption.split(/[, ]/) : [];
      if (webKitStyles && webKitStylesOption !== 'none') {
        const dom = editor.dom, node = editor.selection.getNode();
        content = content.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, (all, before, value, after) => {
          const inputStyles = dom.parseStyle(dom.decode(value));
          const outputStyles = {};
          for (let i = 0; i < webKitStyles.length; i++) {
            const inputValue = inputStyles[webKitStyles[i]];
            let compareInput = inputValue;
            let currentValue = dom.getStyle(node, webKitStyles[i], true);
            if (/color/.test(webKitStyles[i])) {
              compareInput = rgbToHex(compareInput);
              currentValue = rgbToHex(currentValue);
            }
            if (currentValue !== compareInput) {
              outputStyles[webKitStyles[i]] = inputValue;
            }
          }
          const outputStyle = dom.serializeStyle(outputStyles, 'span');
          if (outputStyle) {
            return before + ' style="' + outputStyle + '"' + after;
          }
          return before + after;
        });
      } else {
        content = content.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, '$1$3');
      }
      content = content.replace(/(<[^>]+) data-mce-style="([^"]+)"([^>]*>)/gi, (all, before, value, after) => {
        return before + ' style="' + value + '"' + after;
      });
      return content;
    };
    const setup$8 = editor => {
      if (Env.browser.isChromium() || Env.browser.isSafari()) {
        addPreProcessFilter(editor, removeWebKitStyles);
      }
    };

    const setup$7 = editor => {
      const draggingInternallyState = Cell(false);
      const pasteFormat = Cell(isPasteAsTextEnabled(editor) ? 'text' : 'html');
      const pasteBin = PasteBin(editor);
      setup$8(editor);
      register$1(editor, pasteFormat);
      setup$9(editor);
      editor.on('PreInit', () => {
        register(editor);
        setup$a(editor, draggingInternallyState);
        registerEventsAndFilters(editor, pasteBin, pasteFormat);
      });
    };

    const preventSummaryToggle = editor => {
      editor.on('click', e => {
        if (editor.dom.getParent(e.target, 'details')) {
          e.preventDefault();
        }
      });
    };
    const filterDetails = editor => {
      editor.parser.addNodeFilter('details', elms => {
        each$e(elms, details => {
          details.attr('data-mce-open', details.attr('open'));
          details.attr('open', 'open');
        });
      });
      editor.serializer.addNodeFilter('details', elms => {
        each$e(elms, details => {
          const open = details.attr('data-mce-open');
          details.attr('open', isString(open) ? open : null);
          details.attr('data-mce-open', null);
        });
      });
    };
    const setup$6 = editor => {
      preventSummaryToggle(editor);
      filterDetails(editor);
    };

    const isBr = isBr$6;
    const isText = isText$a;
    const isContentEditableFalse$2 = elm => isContentEditableFalse$b(elm.dom);
    const isContentEditableTrue = elm => isContentEditableTrue$3(elm.dom);
    const isRoot = rootNode => elm => eq(SugarElement.fromDom(rootNode), elm);
    const getClosestScope = (node, rootNode) => closest$4(SugarElement.fromDom(node), elm => isContentEditableTrue(elm) || isBlock$2(elm), isRoot(rootNode)).getOr(SugarElement.fromDom(rootNode)).dom;
    const getClosestCef = (node, rootNode) => closest$4(SugarElement.fromDom(node), isContentEditableFalse$2, isRoot(rootNode));
    const findEdgeCaretCandidate = (startNode, scope, forward) => {
      const walker = new DomTreeWalker(startNode, scope);
      const next = forward ? walker.next.bind(walker) : walker.prev.bind(walker);
      let result = startNode;
      for (let current = forward ? startNode : next(); current && !isBr(current); current = next()) {
        if (isCaretCandidate$3(current)) {
          result = current;
        }
      }
      return result;
    };
    const findClosestBlockRange = (startRng, rootNode) => {
      const startPos = CaretPosition.fromRangeStart(startRng);
      const clickNode = startPos.getNode();
      const scope = getClosestScope(clickNode, rootNode);
      const startNode = findEdgeCaretCandidate(clickNode, scope, false);
      const endNode = findEdgeCaretCandidate(clickNode, scope, true);
      const rng = document.createRange();
      getClosestCef(startNode, scope).fold(() => {
        if (isText(startNode)) {
          rng.setStart(startNode, 0);
        } else {
          rng.setStartBefore(startNode);
        }
      }, cef => rng.setStartBefore(cef.dom));
      getClosestCef(endNode, scope).fold(() => {
        if (isText(endNode)) {
          rng.setEnd(endNode, endNode.data.length);
        } else {
          rng.setEndAfter(endNode);
        }
      }, cef => rng.setEndAfter(cef.dom));
      return rng;
    };
    const onTripleClickSelect = editor => {
      const rng = findClosestBlockRange(editor.selection.getRng(), editor.getBody());
      editor.selection.setRng(normalize(rng));
    };
    const setup$5 = editor => {
      editor.on('mousedown', e => {
        if (e.detail >= 3) {
          e.preventDefault();
          onTripleClickSelect(editor);
        }
      });
    };

    var FakeCaretPosition;
    (function (FakeCaretPosition) {
      FakeCaretPosition['Before'] = 'before';
      FakeCaretPosition['After'] = 'after';
    }(FakeCaretPosition || (FakeCaretPosition = {})));
    const distanceToRectLeft = (clientRect, clientX) => Math.abs(clientRect.left - clientX);
    const distanceToRectRight = (clientRect, clientX) => Math.abs(clientRect.right - clientX);
    const isInsideY = (clientY, clientRect) => clientY >= clientRect.top && clientY <= clientRect.bottom;
    const collidesY = (r1, r2) => r1.top < r2.bottom && r1.bottom > r2.top;
    const isOverlapping = (r1, r2) => {
      const overlap = overlapY(r1, r2) / Math.min(r1.height, r2.height);
      return collidesY(r1, r2) && overlap > 0.5;
    };
    const splitRectsPerAxis = (rects, y) => {
      const intersectingRects = filter$5(rects, rect => isInsideY(y, rect));
      return boundingClientRectFromRects(intersectingRects).fold(() => [
        [],
        rects
      ], boundingRect => {
        const {
          pass: horizontal,
          fail: vertical
        } = partition$2(rects, rect => isOverlapping(rect, boundingRect));
        return [
          horizontal,
          vertical
        ];
      });
    };
    const clientInfo = (rect, clientX) => {
      return {
        node: rect.node,
        position: distanceToRectLeft(rect, clientX) < distanceToRectRight(rect, clientX) ? FakeCaretPosition.Before : FakeCaretPosition.After
      };
    };
    const horizontalDistance = (rect, x, _y) => x > rect.left && x < rect.right ? 0 : Math.min(Math.abs(rect.left - x), Math.abs(rect.right - x));
    const closestChildCaretCandidateNodeRect = (children, clientX, clientY) => {
      const caretCandidateRect = rect => {
        if (isCaretCandidate$3(rect.node)) {
          return Optional.some(rect);
        } else if (isElement$6(rect.node)) {
          return closestChildCaretCandidateNodeRect(from(rect.node.childNodes), clientX, clientY);
        } else {
          return Optional.none();
        }
      };
      const getClosestTextNode = (rects, distance) => {
        if (rects.length >= 2) {
          const r1 = caretCandidateRect(rects[0]).getOr(rects[0]);
          const r2 = caretCandidateRect(rects[1]).getOr(rects[1]);
          const deltaDistance = Math.abs(distance(r1, clientX, clientY) - distance(r2, clientX, clientY));
          if (deltaDistance < 2) {
            if (isText$a(r1.node)) {
              return Optional.some(r1);
            } else if (isText$a(r2.node)) {
              return Optional.some(r2);
            }
          }
        }
        return Optional.none();
      };
      const findClosestCaretCandidateNodeRect = (rects, distance) => {
        const sortedRects = sort(rects, (r1, r2) => distance(r1, clientX, clientY) - distance(r2, clientX, clientY));
        return getClosestTextNode(sortedRects, distance).orThunk(() => findMap(sortedRects, caretCandidateRect));
      };
      const [horizontalRects, verticalRects] = splitRectsPerAxis(getClientRects(children), clientY);
      const {
        pass: above,
        fail: below
      } = partition$2(verticalRects, rect => rect.top < clientY);
      return findClosestCaretCandidateNodeRect(horizontalRects, horizontalDistance).orThunk(() => findClosestCaretCandidateNodeRect(below, distanceToRectEdgeFromXY)).orThunk(() => findClosestCaretCandidateNodeRect(above, distanceToRectEdgeFromXY));
    };
    const traverseUp = (rootElm, scope, clientX, clientY) => {
      const helper = (scope, prevScope) => {
        const isDragGhostContainer = node => isElement$6(node) && node.classList.contains('mce-drag-container');
        const childNodesWithoutGhost = filter$5(scope.dom.childNodes, not(isDragGhostContainer));
        return prevScope.fold(() => closestChildCaretCandidateNodeRect(childNodesWithoutGhost, clientX, clientY), prevScope => {
          const uncheckedChildren = filter$5(childNodesWithoutGhost, node => node !== prevScope.dom);
          return closestChildCaretCandidateNodeRect(uncheckedChildren, clientX, clientY);
        }).orThunk(() => {
          const parent = eq(scope, rootElm) ? Optional.none() : parentElement(scope);
          return parent.bind(newScope => helper(newScope, Optional.some(scope)));
        });
      };
      return helper(scope, Optional.none());
    };
    const closestCaretCandidateNodeRect = (root, clientX, clientY) => {
      const rootElm = SugarElement.fromDom(root);
      const ownerDoc = documentOrOwner(rootElm);
      const elementAtPoint = SugarElement.fromPoint(ownerDoc, clientX, clientY).filter(elm => contains(rootElm, elm));
      const element = elementAtPoint.getOr(rootElm);
      return traverseUp(rootElm, element, clientX, clientY);
    };
    const closestFakeCaretCandidate = (root, clientX, clientY) => closestCaretCandidateNodeRect(root, clientX, clientY).filter(rect => isFakeCaretTarget(rect.node)).map(rect => clientInfo(rect, clientX));

    const getAbsolutePosition = elm => {
      var _a, _b;
      const clientRect = elm.getBoundingClientRect();
      const doc = elm.ownerDocument;
      const docElem = doc.documentElement;
      const win = doc.defaultView;
      return {
        top: clientRect.top + ((_a = win === null || win === void 0 ? void 0 : win.scrollY) !== null && _a !== void 0 ? _a : 0) - docElem.clientTop,
        left: clientRect.left + ((_b = win === null || win === void 0 ? void 0 : win.scrollX) !== null && _b !== void 0 ? _b : 0) - docElem.clientLeft
      };
    };
    const getBodyPosition = editor => editor.inline ? getAbsolutePosition(editor.getBody()) : {
      left: 0,
      top: 0
    };
    const getScrollPosition = editor => {
      const body = editor.getBody();
      return editor.inline ? {
        left: body.scrollLeft,
        top: body.scrollTop
      } : {
        left: 0,
        top: 0
      };
    };
    const getBodyScroll = editor => {
      const body = editor.getBody(), docElm = editor.getDoc().documentElement;
      const inlineScroll = {
        left: body.scrollLeft,
        top: body.scrollTop
      };
      const iframeScroll = {
        left: body.scrollLeft || docElm.scrollLeft,
        top: body.scrollTop || docElm.scrollTop
      };
      return editor.inline ? inlineScroll : iframeScroll;
    };
    const getMousePosition = (editor, event) => {
      if (event.target.ownerDocument !== editor.getDoc()) {
        const iframePosition = getAbsolutePosition(editor.getContentAreaContainer());
        const scrollPosition = getBodyScroll(editor);
        return {
          left: event.pageX - iframePosition.left + scrollPosition.left,
          top: event.pageY - iframePosition.top + scrollPosition.top
        };
      }
      return {
        left: event.pageX,
        top: event.pageY
      };
    };
    const calculatePosition = (bodyPosition, scrollPosition, mousePosition) => ({
      pageX: mousePosition.left - bodyPosition.left + scrollPosition.left,
      pageY: mousePosition.top - bodyPosition.top + scrollPosition.top
    });
    const calc = (editor, event) => calculatePosition(getBodyPosition(editor), getScrollPosition(editor), getMousePosition(editor, event));

    const makeDndEventFromMouseEvent = (type, mouseEvent, extra) => ({
      ...mouseEvent,
      dataTransfer: null,
      type,
      ...extra
    });
    const makeDndEvent = (type, props) => {
      const fail = die('Function not supported on simulated event.');
      const event = {
        bubbles: true,
        cancelBubble: false,
        cancelable: true,
        composed: false,
        currentTarget: null,
        defaultPrevented: false,
        eventPhase: 0,
        isTrusted: true,
        returnValue: false,
        srcElement: null,
        target: null,
        timeStamp: 0,
        type,
        composedPath: fail,
        initEvent: fail,
        preventDefault: noop,
        stopImmediatePropagation: noop,
        stopPropagation: noop,
        AT_TARGET: window.Event.AT_TARGET,
        BUBBLING_PHASE: window.Event.BUBBLING_PHASE,
        CAPTURING_PHASE: window.Event.CAPTURING_PHASE,
        NONE: window.Event.NONE,
        altKey: false,
        button: 0,
        buttons: 0,
        clientX: 0,
        clientY: 0,
        ctrlKey: false,
        metaKey: false,
        movementX: 0,
        movementY: 0,
        offsetX: 0,
        offsetY: 0,
        pageX: 0,
        pageY: 0,
        relatedTarget: null,
        screenX: 0,
        screenY: 0,
        shiftKey: false,
        x: 0,
        y: 0,
        detail: 0,
        view: null,
        which: 0,
        initUIEvent: fail,
        initMouseEvent: fail,
        getModifierState: fail,
        dataTransfer: null,
        ...props
      };
      return event;
    };
    const fallback = target => ({
      target,
      srcElement: target
    });
    const dndEvent = type => target => makeDndEvent(type, fallback(target));
    const dndEventFromMouseEvent = type => (mouseEvent, target) => makeDndEventFromMouseEvent(type, mouseEvent, fallback(target));
    const makeDragstartEventFromMouseEvent = dndEventFromMouseEvent('dragstart');
    const makeDropEventFromMouseEvent = dndEventFromMouseEvent('drop');
    const makeDragendEvent = dndEvent('dragend');
    const makeDragendEventFromMouseEvent = dndEventFromMouseEvent('dragend');

    const scrollPixelsPerInterval = 32;
    const scrollIntervalValue = 100;
    const mouseRangeToTriggerScrollInsideEditor = 8;
    const mouseRangeToTriggerScrollOutsideEditor = 16;
    const isContentEditableFalse$1 = isContentEditableFalse$b;
    const isContentEditable = or(isContentEditableFalse$1, isContentEditableTrue$3);
    const isDraggable = (dom, rootElm, elm) => isContentEditableFalse$1(elm) && elm !== rootElm && dom.isEditable(elm.parentElement);
    const isValidDropTarget = (editor, targetElement, dragElement) => {
      if (isNullable(targetElement)) {
        return false;
      } else if (targetElement === dragElement || editor.dom.isChildOf(targetElement, dragElement)) {
        return false;
      } else {
        return editor.dom.isEditable(targetElement);
      }
    };
    const cloneElement = elm => {
      const cloneElm = elm.cloneNode(true);
      cloneElm.removeAttribute('data-mce-selected');
      return cloneElm;
    };
    const createGhost = (editor, elm, width, height) => {
      const dom = editor.dom;
      const clonedElm = elm.cloneNode(true);
      dom.setStyles(clonedElm, {
        width,
        height
      });
      dom.setAttrib(clonedElm, 'data-mce-selected', null);
      const ghostElm = dom.create('div', {
        'class': 'mce-drag-container',
        'data-mce-bogus': 'all',
        'unselectable': 'on',
        'contenteditable': 'false'
      });
      dom.setStyles(ghostElm, {
        position: 'absolute',
        opacity: 0.5,
        overflow: 'hidden',
        border: 0,
        padding: 0,
        margin: 0,
        width,
        height
      });
      dom.setStyles(clonedElm, {
        margin: 0,
        boxSizing: 'border-box'
      });
      ghostElm.appendChild(clonedElm);
      return ghostElm;
    };
    const appendGhostToBody = (ghostElm, bodyElm) => {
      if (ghostElm.parentNode !== bodyElm) {
        bodyElm.appendChild(ghostElm);
      }
    };
    const scrollEditor = (direction, amount) => win => () => {
      const current = direction === 'left' ? win.scrollX : win.scrollY;
      win.scroll({
        [direction]: current + amount,
        behavior: 'smooth'
      });
    };
    const scrollLeft = scrollEditor('left', -scrollPixelsPerInterval);
    const scrollRight = scrollEditor('left', scrollPixelsPerInterval);
    const scrollUp = scrollEditor('top', -scrollPixelsPerInterval);
    const scrollDown = scrollEditor('top', scrollPixelsPerInterval);
    const moveGhost = (ghostElm, position, width, height, maxX, maxY, mouseY, mouseX, contentAreaContainer, win, state, mouseEventOriginatedFromWithinTheEditor) => {
      let overflowX = 0, overflowY = 0;
      ghostElm.style.left = position.pageX + 'px';
      ghostElm.style.top = position.pageY + 'px';
      if (position.pageX + width > maxX) {
        overflowX = position.pageX + width - maxX;
      }
      if (position.pageY + height > maxY) {
        overflowY = position.pageY + height - maxY;
      }
      ghostElm.style.width = width - overflowX + 'px';
      ghostElm.style.height = height - overflowY + 'px';
      const clientHeight = contentAreaContainer.clientHeight;
      const clientWidth = contentAreaContainer.clientWidth;
      const outerMouseY = mouseY + contentAreaContainer.getBoundingClientRect().top;
      const outerMouseX = mouseX + contentAreaContainer.getBoundingClientRect().left;
      state.on(state => {
        state.intervalId.clear();
        if (state.dragging && mouseEventOriginatedFromWithinTheEditor) {
          if (mouseY + mouseRangeToTriggerScrollInsideEditor >= clientHeight) {
            state.intervalId.set(scrollDown(win));
          } else if (mouseY - mouseRangeToTriggerScrollInsideEditor <= 0) {
            state.intervalId.set(scrollUp(win));
          } else if (mouseX + mouseRangeToTriggerScrollInsideEditor >= clientWidth) {
            state.intervalId.set(scrollRight(win));
          } else if (mouseX - mouseRangeToTriggerScrollInsideEditor <= 0) {
            state.intervalId.set(scrollLeft(win));
          } else if (outerMouseY + mouseRangeToTriggerScrollOutsideEditor >= window.innerHeight) {
            state.intervalId.set(scrollDown(window));
          } else if (outerMouseY - mouseRangeToTriggerScrollOutsideEditor <= 0) {
            state.intervalId.set(scrollUp(window));
          } else if (outerMouseX + mouseRangeToTriggerScrollOutsideEditor >= window.innerWidth) {
            state.intervalId.set(scrollRight(window));
          } else if (outerMouseX - mouseRangeToTriggerScrollOutsideEditor <= 0) {
            state.intervalId.set(scrollLeft(window));
          }
        }
      });
    };
    const removeElement = elm => {
      if (elm && elm.parentNode) {
        elm.parentNode.removeChild(elm);
      }
    };
    const removeElementWithPadding = (dom, elm) => {
      const parentBlock = dom.getParent(elm.parentNode, dom.isBlock);
      removeElement(elm);
      if (parentBlock && parentBlock !== dom.getRoot() && dom.isEmpty(parentBlock)) {
        fillWithPaddingBr(SugarElement.fromDom(parentBlock));
      }
    };
    const isLeftMouseButtonPressed = e => e.button === 0;
    const applyRelPos = (state, position) => ({
      pageX: position.pageX - state.relX,
      pageY: position.pageY + 5
    });
    const start = (state, editor) => e => {
      if (isLeftMouseButtonPressed(e)) {
        const ceElm = find$2(editor.dom.getParents(e.target), isContentEditable).getOr(null);
        if (isNonNullable(ceElm) && isDraggable(editor.dom, editor.getBody(), ceElm)) {
          const elmPos = editor.dom.getPos(ceElm);
          const bodyElm = editor.getBody();
          const docElm = editor.getDoc().documentElement;
          state.set({
            element: ceElm,
            dragging: false,
            screenX: e.screenX,
            screenY: e.screenY,
            maxX: (editor.inline ? bodyElm.scrollWidth : docElm.offsetWidth) - 2,
            maxY: (editor.inline ? bodyElm.scrollHeight : docElm.offsetHeight) - 2,
            relX: e.pageX - elmPos.x,
            relY: e.pageY - elmPos.y,
            width: ceElm.offsetWidth,
            height: ceElm.offsetHeight,
            ghost: createGhost(editor, ceElm, ceElm.offsetWidth, ceElm.offsetHeight),
            intervalId: repeatable(scrollIntervalValue)
          });
        }
      }
    };
    const placeCaretAt = (editor, clientX, clientY) => {
      editor._selectionOverrides.hideFakeCaret();
      closestFakeCaretCandidate(editor.getBody(), clientX, clientY).fold(() => editor.selection.placeCaretAt(clientX, clientY), caretInfo => {
        const range = editor._selectionOverrides.showCaret(1, caretInfo.node, caretInfo.position === FakeCaretPosition.Before, false);
        if (range) {
          editor.selection.setRng(range);
        } else {
          editor.selection.placeCaretAt(clientX, clientY);
        }
      });
    };
    const move = (state, editor) => {
      const throttledPlaceCaretAt = first$1((clientX, clientY) => placeCaretAt(editor, clientX, clientY), 0);
      editor.on('remove', throttledPlaceCaretAt.cancel);
      const state_ = state;
      return e => state.on(state => {
        const movement = Math.max(Math.abs(e.screenX - state.screenX), Math.abs(e.screenY - state.screenY));
        if (!state.dragging && movement > 10) {
          const args = editor.dispatch('dragstart', makeDragstartEventFromMouseEvent(e, state.element));
          if (args.isDefaultPrevented()) {
            return;
          }
          state.dragging = true;
          editor.focus();
        }
        if (state.dragging) {
          const mouseEventOriginatedFromWithinTheEditor = e.currentTarget === editor.getDoc().documentElement;
          const targetPos = applyRelPos(state, calc(editor, e));
          appendGhostToBody(state.ghost, editor.getBody());
          moveGhost(state.ghost, targetPos, state.width, state.height, state.maxX, state.maxY, e.clientY, e.clientX, editor.getContentAreaContainer(), editor.getWin(), state_, mouseEventOriginatedFromWithinTheEditor);
          throttledPlaceCaretAt.throttle(e.clientX, e.clientY);
        }
      });
    };
    const getRawTarget = selection => {
      const sel = selection.getSel();
      if (isNonNullable(sel)) {
        const rng = sel.getRangeAt(0);
        const startContainer = rng.startContainer;
        return isText$a(startContainer) ? startContainer.parentNode : startContainer;
      } else {
        return null;
      }
    };
    const drop = (state, editor) => e => {
      state.on(state => {
        var _a;
        state.intervalId.clear();
        if (state.dragging) {
          if (isValidDropTarget(editor, getRawTarget(editor.selection), state.element)) {
            const targetClone = cloneElement(state.element);
            const dropTarget = (_a = editor.getDoc().elementFromPoint(e.clientX, e.clientY)) !== null && _a !== void 0 ? _a : editor.getBody();
            const args = editor.dispatch('drop', makeDropEventFromMouseEvent(e, dropTarget));
            if (!args.isDefaultPrevented()) {
              editor.undoManager.transact(() => {
                removeElementWithPadding(editor.dom, state.element);
                editor.insertContent(editor.dom.getOuterHTML(targetClone));
                editor._selectionOverrides.hideFakeCaret();
              });
            }
          }
          editor.dispatch('dragend', makeDragendEventFromMouseEvent(e, editor.getBody()));
        }
      });
      removeDragState(state);
    };
    const stopDragging = (state, editor, e) => {
      state.on(state => {
        state.intervalId.clear();
        if (state.dragging) {
          const event = e.fold(() => makeDragendEvent(state.element), mouseEvent => makeDragendEventFromMouseEvent(mouseEvent, state.element));
          editor.dispatch('dragend', event);
        }
      });
      removeDragState(state);
    };
    const stop = (state, editor) => e => stopDragging(state, editor, Optional.some(e));
    const removeDragState = state => {
      state.on(state => {
        state.intervalId.clear();
        removeElement(state.ghost);
      });
      state.clear();
    };
    const bindFakeDragEvents = editor => {
      const state = value$2();
      const pageDom = DOMUtils.DOM;
      const rootDocument = document;
      const dragStartHandler = start(state, editor);
      const dragHandler = move(state, editor);
      const dropHandler = drop(state, editor);
      const dragEndHandler = stop(state, editor);
      editor.on('mousedown', dragStartHandler);
      editor.on('mousemove', dragHandler);
      editor.on('mouseup', dropHandler);
      pageDom.bind(rootDocument, 'mousemove', dragHandler);
      pageDom.bind(rootDocument, 'mouseup', dragEndHandler);
      editor.on('remove', () => {
        pageDom.unbind(rootDocument, 'mousemove', dragHandler);
        pageDom.unbind(rootDocument, 'mouseup', dragEndHandler);
      });
      editor.on('keydown', e => {
        if (e.keyCode === VK.ESC) {
          stopDragging(state, editor, Optional.none());
        }
      });
    };
    const blockUnsupportedFileDrop = editor => {
      const preventFileDrop = e => {
        if (!e.isDefaultPrevented()) {
          const dataTransfer = e.dataTransfer;
          if (dataTransfer && (contains$2(dataTransfer.types, 'Files') || dataTransfer.files.length > 0)) {
            e.preventDefault();
            if (e.type === 'drop') {
              displayError(editor, 'Dropped file type is not supported');
            }
          }
        }
      };
      const preventFileDropIfUIElement = e => {
        if (isUIElement(editor, e.target)) {
          preventFileDrop(e);
        }
      };
      const setup = () => {
        const pageDom = DOMUtils.DOM;
        const dom = editor.dom;
        const doc = document;
        const editorRoot = editor.inline ? editor.getBody() : editor.getDoc();
        const eventNames = [
          'drop',
          'dragover'
        ];
        each$e(eventNames, name => {
          pageDom.bind(doc, name, preventFileDropIfUIElement);
          dom.bind(editorRoot, name, preventFileDrop);
        });
        editor.on('remove', () => {
          each$e(eventNames, name => {
            pageDom.unbind(doc, name, preventFileDropIfUIElement);
            dom.unbind(editorRoot, name, preventFileDrop);
          });
        });
      };
      editor.on('init', () => {
        Delay.setEditorTimeout(editor, setup, 0);
      });
    };
    const init$2 = editor => {
      bindFakeDragEvents(editor);
      if (shouldBlockUnsupportedDrop(editor)) {
        blockUnsupportedFileDrop(editor);
      }
    };

    const setup$4 = editor => {
      const renderFocusCaret = first$1(() => {
        if (!editor.removed && editor.getBody().contains(document.activeElement)) {
          const rng = editor.selection.getRng();
          if (rng.collapsed) {
            const caretRange = renderRangeCaret(editor, rng, false);
            editor.selection.setRng(caretRange);
          }
        }
      }, 0);
      editor.on('focus', () => {
        renderFocusCaret.throttle();
      });
      editor.on('blur', () => {
        renderFocusCaret.cancel();
      });
    };

    const setup$3 = editor => {
      editor.on('init', () => {
        editor.on('focusin', e => {
          const target = e.target;
          if (isMedia$2(target)) {
            const ceRoot = getContentEditableRoot$1(editor.getBody(), target);
            const node = isContentEditableFalse$b(ceRoot) ? ceRoot : target;
            if (editor.selection.getNode() !== node) {
              selectNode(editor, node).each(rng => editor.selection.setRng(rng));
            }
          }
        });
      });
    };

    const isContentEditableFalse = isContentEditableFalse$b;
    const getContentEditableRoot = (editor, node) => getContentEditableRoot$1(editor.getBody(), node);
    const SelectionOverrides = editor => {
      const selection = editor.selection, dom = editor.dom;
      const rootNode = editor.getBody();
      const fakeCaret = FakeCaret(editor, rootNode, dom.isBlock, () => hasFocus(editor));
      const realSelectionId = 'sel-' + dom.uniqueId();
      const elementSelectionAttr = 'data-mce-selected';
      let selectedElement;
      const isFakeSelectionElement = node => isNonNullable(node) && dom.hasClass(node, 'mce-offscreen-selection');
      const isFakeSelectionTargetElement = node => node !== rootNode && (isContentEditableFalse(node) || isMedia$2(node)) && dom.isChildOf(node, rootNode) && dom.isEditable(node.parentNode);
      const setRange = range => {
        if (range) {
          selection.setRng(range);
        }
      };
      const showCaret = (direction, node, before, scrollIntoView = true) => {
        const e = editor.dispatch('ShowCaret', {
          target: node,
          direction,
          before
        });
        if (e.isDefaultPrevented()) {
          return null;
        }
        if (scrollIntoView) {
          selection.scrollIntoView(node, direction === -1);
        }
        return fakeCaret.show(before, node);
      };
      const showBlockCaretContainer = blockCaretContainer => {
        if (blockCaretContainer.hasAttribute('data-mce-caret')) {
          showCaretContainerBlock(blockCaretContainer);
          selection.scrollIntoView(blockCaretContainer);
        }
      };
      const registerEvents = () => {
        editor.on('click', e => {
          if (!dom.isEditable(e.target)) {
            e.preventDefault();
            editor.focus();
          }
        });
        editor.on('blur NewBlock', removeElementSelection);
        editor.on('ResizeWindow FullscreenStateChanged', fakeCaret.reposition);
        editor.on('tap', e => {
          const targetElm = e.target;
          const contentEditableRoot = getContentEditableRoot(editor, targetElm);
          if (isContentEditableFalse(contentEditableRoot)) {
            e.preventDefault();
            selectNode(editor, contentEditableRoot).each(setElementSelection);
          } else if (isFakeSelectionTargetElement(targetElm)) {
            selectNode(editor, targetElm).each(setElementSelection);
          }
        }, true);
        editor.on('mousedown', e => {
          const targetElm = e.target;
          if (targetElm !== rootNode && targetElm.nodeName !== 'HTML' && !dom.isChildOf(targetElm, rootNode)) {
            return;
          }
          if (!isXYInContentArea(editor, e.clientX, e.clientY)) {
            return;
          }
          removeElementSelection();
          hideFakeCaret();
          const closestContentEditable = getContentEditableRoot(editor, targetElm);
          if (isContentEditableFalse(closestContentEditable)) {
            e.preventDefault();
            selectNode(editor, closestContentEditable).each(setElementSelection);
          } else {
            closestFakeCaretCandidate(rootNode, e.clientX, e.clientY).each(caretInfo => {
              e.preventDefault();
              const range = showCaret(1, caretInfo.node, caretInfo.position === FakeCaretPosition.Before, false);
              setRange(range);
              if (isElement$6(closestContentEditable)) {
                closestContentEditable.focus();
              } else {
                editor.getBody().focus();
              }
            });
          }
        });
        editor.on('keypress', e => {
          if (VK.modifierPressed(e)) {
            return;
          }
          if (isContentEditableFalse(selection.getNode())) {
            e.preventDefault();
          }
        });
        editor.on('GetSelectionRange', e => {
          let rng = e.range;
          if (selectedElement) {
            if (!selectedElement.parentNode) {
              selectedElement = null;
              return;
            }
            rng = rng.cloneRange();
            rng.selectNode(selectedElement);
            e.range = rng;
          }
        });
        editor.on('SetSelectionRange', e => {
          e.range = normalizeVoidElementSelection(e.range);
          const rng = setElementSelection(e.range, e.forward);
          if (rng) {
            e.range = rng;
          }
        });
        const isPasteBin = node => isElement$6(node) && node.id === 'mcepastebin';
        editor.on('AfterSetSelectionRange', e => {
          const rng = e.range;
          const parent = rng.startContainer.parentElement;
          if (!isRangeInCaretContainer(rng) && !isPasteBin(parent)) {
            hideFakeCaret();
          }
          if (!isFakeSelectionElement(parent)) {
            removeElementSelection();
          }
        });
        init$2(editor);
        setup$4(editor);
        setup$3(editor);
      };
      const isWithinCaretContainer = node => isCaretContainer$2(node) || startsWithCaretContainer$1(node) || endsWithCaretContainer$1(node);
      const isRangeInCaretContainer = rng => isWithinCaretContainer(rng.startContainer) || isWithinCaretContainer(rng.endContainer);
      const normalizeVoidElementSelection = rng => {
        const voidElements = editor.schema.getVoidElements();
        const newRng = dom.createRng();
        const startContainer = rng.startContainer;
        const startOffset = rng.startOffset;
        const endContainer = rng.endContainer;
        const endOffset = rng.endOffset;
        if (has$2(voidElements, startContainer.nodeName.toLowerCase())) {
          if (startOffset === 0) {
            newRng.setStartBefore(startContainer);
          } else {
            newRng.setStartAfter(startContainer);
          }
        } else {
          newRng.setStart(startContainer, startOffset);
        }
        if (has$2(voidElements, endContainer.nodeName.toLowerCase())) {
          if (endOffset === 0) {
            newRng.setEndBefore(endContainer);
          } else {
            newRng.setEndAfter(endContainer);
          }
        } else {
          newRng.setEnd(endContainer, endOffset);
        }
        return newRng;
      };
      const setupOffscreenSelection = (node, targetClone) => {
        const body = SugarElement.fromDom(editor.getBody());
        const doc = editor.getDoc();
        const realSelectionContainer = descendant(body, '#' + realSelectionId).getOrThunk(() => {
          const newContainer = SugarElement.fromHtml('<div data-mce-bogus="all" class="mce-offscreen-selection"></div>', doc);
          set$3(newContainer, 'id', realSelectionId);
          append$1(body, newContainer);
          return newContainer;
        });
        const newRange = dom.createRng();
        empty(realSelectionContainer);
        append(realSelectionContainer, [
          SugarElement.fromText(nbsp, doc),
          SugarElement.fromDom(targetClone),
          SugarElement.fromText(nbsp, doc)
        ]);
        newRange.setStart(realSelectionContainer.dom.firstChild, 1);
        newRange.setEnd(realSelectionContainer.dom.lastChild, 0);
        setAll(realSelectionContainer, { top: dom.getPos(node, editor.getBody()).y + 'px' });
        focus$1(realSelectionContainer);
        const sel = selection.getSel();
        if (sel) {
          sel.removeAllRanges();
          sel.addRange(newRange);
        }
        return newRange;
      };
      const selectElement = elm => {
        const targetClone = elm.cloneNode(true);
        const e = editor.dispatch('ObjectSelected', {
          target: elm,
          targetClone
        });
        if (e.isDefaultPrevented()) {
          return null;
        }
        const range = setupOffscreenSelection(elm, e.targetClone);
        const nodeElm = SugarElement.fromDom(elm);
        each$e(descendants(SugarElement.fromDom(editor.getBody()), `*[${ elementSelectionAttr }]`), elm => {
          if (!eq(nodeElm, elm)) {
            remove$b(elm, elementSelectionAttr);
          }
        });
        if (!dom.getAttrib(elm, elementSelectionAttr)) {
          elm.setAttribute(elementSelectionAttr, '1');
        }
        selectedElement = elm;
        hideFakeCaret();
        return range;
      };
      const setElementSelection = (range, forward) => {
        if (!range) {
          return null;
        }
        if (range.collapsed) {
          if (!isRangeInCaretContainer(range)) {
            const dir = forward ? 1 : -1;
            const caretPosition = getNormalizedRangeEndPoint(dir, rootNode, range);
            const beforeNode = caretPosition.getNode(!forward);
            if (isNonNullable(beforeNode)) {
              if (isFakeCaretTarget(beforeNode)) {
                return showCaret(dir, beforeNode, forward ? !caretPosition.isAtEnd() : false, false);
              }
              if (isCaretContainerInline(beforeNode) && isContentEditableFalse$b(beforeNode.nextSibling)) {
                const rng = dom.createRng();
                rng.setStart(beforeNode, 0);
                rng.setEnd(beforeNode, 0);
                return rng;
              }
            }
            const afterNode = caretPosition.getNode(forward);
            if (isNonNullable(afterNode)) {
              if (isFakeCaretTarget(afterNode)) {
                return showCaret(dir, afterNode, forward ? false : !caretPosition.isAtEnd(), false);
              }
              if (isCaretContainerInline(afterNode) && isContentEditableFalse$b(afterNode.previousSibling)) {
                const rng = dom.createRng();
                rng.setStart(afterNode, 1);
                rng.setEnd(afterNode, 1);
                return rng;
              }
            }
          }
          return null;
        }
        let startContainer = range.startContainer;
        let startOffset = range.startOffset;
        const endOffset = range.endOffset;
        if (isText$a(startContainer) && startOffset === 0 && isContentEditableFalse(startContainer.parentNode)) {
          startContainer = startContainer.parentNode;
          startOffset = dom.nodeIndex(startContainer);
          startContainer = startContainer.parentNode;
        }
        if (!isElement$6(startContainer)) {
          return null;
        }
        if (endOffset === startOffset + 1 && startContainer === range.endContainer) {
          const node = startContainer.childNodes[startOffset];
          if (isFakeSelectionTargetElement(node)) {
            return selectElement(node);
          }
        }
        return null;
      };
      const removeElementSelection = () => {
        if (selectedElement) {
          selectedElement.removeAttribute(elementSelectionAttr);
        }
        descendant(SugarElement.fromDom(editor.getBody()), '#' + realSelectionId).each(remove$6);
        selectedElement = null;
      };
      const destroy = () => {
        fakeCaret.destroy();
        selectedElement = null;
      };
      const hideFakeCaret = () => {
        fakeCaret.hide();
      };
      if (!isRtc(editor)) {
        registerEvents();
      }
      return {
        showCaret,
        showBlockCaretContainer,
        hideFakeCaret,
        destroy
      };
    };

    const getNormalizedTextOffset = (container, offset) => {
      let normalizedOffset = offset;
      for (let node = container.previousSibling; isText$a(node); node = node.previousSibling) {
        normalizedOffset += node.data.length;
      }
      return normalizedOffset;
    };
    const generatePath = (dom, root, node, offset, normalized) => {
      if (isText$a(node) && (offset < 0 || offset > node.data.length)) {
        return [];
      }
      const p = normalized && isText$a(node) ? [getNormalizedTextOffset(node, offset)] : [offset];
      let current = node;
      while (current !== root && current.parentNode) {
        p.push(dom.nodeIndex(current, normalized));
        current = current.parentNode;
      }
      return current === root ? p.reverse() : [];
    };
    const generatePathRange = (dom, root, startNode, startOffset, endNode, endOffset, normalized = false) => {
      const start = generatePath(dom, root, startNode, startOffset, normalized);
      const end = generatePath(dom, root, endNode, endOffset, normalized);
      return {
        start,
        end
      };
    };
    const resolvePath = (root, path) => {
      const nodePath = path.slice();
      const offset = nodePath.pop();
      if (!isNumber(offset)) {
        return Optional.none();
      } else {
        const resolvedNode = foldl(nodePath, (optNode, index) => optNode.bind(node => Optional.from(node.childNodes[index])), Optional.some(root));
        return resolvedNode.bind(node => {
          if (isText$a(node) && (offset < 0 || offset > node.data.length)) {
            return Optional.none();
          } else {
            return Optional.some({
              node,
              offset
            });
          }
        });
      }
    };
    const resolvePathRange = (root, range) => resolvePath(root, range.start).bind(({
      node: startNode,
      offset: startOffset
    }) => resolvePath(root, range.end).map(({
      node: endNode,
      offset: endOffset
    }) => {
      const rng = document.createRange();
      rng.setStart(startNode, startOffset);
      rng.setEnd(endNode, endOffset);
      return rng;
    }));
    const generatePathRangeFromRange = (dom, root, range, normalized = false) => generatePathRange(dom, root, range.startContainer, range.startOffset, range.endContainer, range.endOffset, normalized);

    const cleanEmptyNodes = (dom, node, isRoot) => {
      if (node && dom.isEmpty(node) && !isRoot(node)) {
        const parent = node.parentNode;
        dom.remove(node);
        cleanEmptyNodes(dom, parent, isRoot);
      }
    };
    const deleteRng = (dom, rng, isRoot, clean = true) => {
      const startParent = rng.startContainer.parentNode;
      const endParent = rng.endContainer.parentNode;
      rng.deleteContents();
      if (clean && !isRoot(rng.startContainer)) {
        if (isText$a(rng.startContainer) && rng.startContainer.data.length === 0) {
          dom.remove(rng.startContainer);
        }
        if (isText$a(rng.endContainer) && rng.endContainer.data.length === 0) {
          dom.remove(rng.endContainer);
        }
        cleanEmptyNodes(dom, startParent, isRoot);
        if (startParent !== endParent) {
          cleanEmptyNodes(dom, endParent, isRoot);
        }
      }
    };
    const getParentBlock = (editor, rng) => Optional.from(editor.dom.getParent(rng.startContainer, editor.dom.isBlock));
    const resolveFromDynamicPatterns = (patternSet, block, beforeText) => {
      const dynamicPatterns = patternSet.dynamicPatternsLookup({
        text: beforeText,
        block
      });
      return {
        ...patternSet,
        blockPatterns: getBlockPatterns(dynamicPatterns).concat(patternSet.blockPatterns),
        inlinePatterns: getInlinePatterns(dynamicPatterns).concat(patternSet.inlinePatterns)
      };
    };
    const getBeforeText = (dom, block, node, offset) => {
      const rng = dom.createRng();
      rng.setStart(block, 0);
      rng.setEnd(node, offset);
      return rng.toString();
    };

    const startsWithSingleSpace = s => /^\s[^\s]/.test(s);
    const stripPattern = (dom, block, pattern) => {
      const firstTextNode = textAfter(block, 0, block);
      firstTextNode.each(spot => {
        const node = spot.container;
        scanRight(node, pattern.start.length, block).each(end => {
          const rng = dom.createRng();
          rng.setStart(node, 0);
          rng.setEnd(end.container, end.offset);
          deleteRng(dom, rng, e => e === block);
        });
        const text = SugarElement.fromDom(node);
        const textContent = get$3(text);
        if (startsWithSingleSpace(textContent)) {
          set(text, textContent.slice(1));
        }
      });
    };
    const applyPattern$1 = (editor, match) => {
      const dom = editor.dom;
      const pattern = match.pattern;
      const rng = resolvePathRange(dom.getRoot(), match.range).getOrDie('Unable to resolve path range');
      const isBlockFormatName = (name, formatter) => {
        const formatSet = formatter.get(name);
        return isArray$1(formatSet) && head(formatSet).exists(format => has$2(format, 'block'));
      };
      getParentBlock(editor, rng).each(block => {
        if (pattern.type === 'block-format') {
          if (isBlockFormatName(pattern.format, editor.formatter)) {
            editor.undoManager.transact(() => {
              stripPattern(editor.dom, block, pattern);
              editor.formatter.apply(pattern.format);
            });
          }
        } else if (pattern.type === 'block-command') {
          editor.undoManager.transact(() => {
            stripPattern(editor.dom, block, pattern);
            editor.execCommand(pattern.cmd, false, pattern.value);
          });
        }
      });
      return true;
    };
    const sortPatterns$1 = patterns => sort(patterns, (a, b) => b.start.length - a.start.length);
    const findPattern$1 = (patterns, text) => {
      const sortedPatterns = sortPatterns$1(patterns);
      const nuText = text.replace(nbsp, ' ');
      return find$2(sortedPatterns, pattern => text.indexOf(pattern.start) === 0 || nuText.indexOf(pattern.start) === 0);
    };
    const findPatterns$1 = (editor, block, patternSet, normalizedMatches) => {
      var _a;
      const dom = editor.dom;
      const forcedRootBlock = getForcedRootBlock(editor);
      if (!dom.is(block, forcedRootBlock)) {
        return [];
      }
      const blockText = (_a = block.textContent) !== null && _a !== void 0 ? _a : '';
      return findPattern$1(patternSet.blockPatterns, blockText).map(pattern => {
        if (Tools.trim(blockText).length === pattern.start.length) {
          return [];
        }
        return [{
            pattern,
            range: generatePathRange(dom, dom.getRoot(), block, 0, block, 0, normalizedMatches)
          }];
      }).getOr([]);
    };
    const applyMatches$1 = (editor, matches) => {
      if (matches.length === 0) {
        return;
      }
      const bookmark = editor.selection.getBookmark();
      each$e(matches, match => applyPattern$1(editor, match));
      editor.selection.moveToBookmark(bookmark);
    };

    const newMarker = (dom, id) => dom.create('span', {
      'data-mce-type': 'bookmark',
      id
    });
    const rangeFromMarker = (dom, marker) => {
      const rng = dom.createRng();
      rng.setStartAfter(marker.start);
      rng.setEndBefore(marker.end);
      return rng;
    };
    const createMarker = (dom, markerPrefix, pathRange) => {
      const rng = resolvePathRange(dom.getRoot(), pathRange).getOrDie('Unable to resolve path range');
      const startNode = rng.startContainer;
      const endNode = rng.endContainer;
      const textEnd = rng.endOffset === 0 ? endNode : endNode.splitText(rng.endOffset);
      const textStart = rng.startOffset === 0 ? startNode : startNode.splitText(rng.startOffset);
      const startParentNode = textStart.parentNode;
      const endParentNode = textEnd.parentNode;
      return {
        prefix: markerPrefix,
        end: endParentNode.insertBefore(newMarker(dom, markerPrefix + '-end'), textEnd),
        start: startParentNode.insertBefore(newMarker(dom, markerPrefix + '-start'), textStart)
      };
    };
    const removeMarker = (dom, marker, isRoot) => {
      cleanEmptyNodes(dom, dom.get(marker.prefix + '-end'), isRoot);
      cleanEmptyNodes(dom, dom.get(marker.prefix + '-start'), isRoot);
    };

    const isReplacementPattern = pattern => pattern.start.length === 0;
    const matchesPattern = patternContent => (element, offset) => {
      const text = element.data;
      const searchText = text.substring(0, offset);
      const startEndIndex = searchText.lastIndexOf(patternContent.charAt(patternContent.length - 1));
      const startIndex = searchText.lastIndexOf(patternContent);
      if (startIndex !== -1) {
        return startIndex + patternContent.length;
      } else if (startEndIndex !== -1) {
        return startEndIndex + 1;
      } else {
        return -1;
      }
    };
    const findPatternStartFromSpot = (dom, pattern, block, spot) => {
      const startPattern = pattern.start;
      const startSpot = repeatLeft(dom, spot.container, spot.offset, matchesPattern(startPattern), block);
      return startSpot.bind(spot => {
        var _a, _b;
        const startPatternIndex = (_b = (_a = block.textContent) === null || _a === void 0 ? void 0 : _a.indexOf(startPattern)) !== null && _b !== void 0 ? _b : -1;
        const isCompleteMatch = startPatternIndex !== -1 && spot.offset >= startPatternIndex + startPattern.length;
        if (isCompleteMatch) {
          const rng = dom.createRng();
          rng.setStart(spot.container, spot.offset - startPattern.length);
          rng.setEnd(spot.container, spot.offset);
          return Optional.some(rng);
        } else {
          const offset = spot.offset - startPattern.length;
          return scanLeft(spot.container, offset, block).map(nextSpot => {
            const rng = dom.createRng();
            rng.setStart(nextSpot.container, nextSpot.offset);
            rng.setEnd(spot.container, spot.offset);
            return rng;
          }).filter(rng => rng.toString() === startPattern).orThunk(() => findPatternStartFromSpot(dom, pattern, block, point(spot.container, 0)));
        }
      });
    };
    const findPatternStart = (dom, pattern, node, offset, block, requireGap = false) => {
      if (pattern.start.length === 0 && !requireGap) {
        const rng = dom.createRng();
        rng.setStart(node, offset);
        rng.setEnd(node, offset);
        return Optional.some(rng);
      }
      return textBefore(node, offset, block).bind(spot => {
        const start = findPatternStartFromSpot(dom, pattern, block, spot);
        return start.bind(startRange => {
          var _a;
          if (requireGap) {
            if (startRange.endContainer === spot.container && startRange.endOffset === spot.offset) {
              return Optional.none();
            } else if (spot.offset === 0 && ((_a = startRange.endContainer.textContent) === null || _a === void 0 ? void 0 : _a.length) === startRange.endOffset) {
              return Optional.none();
            }
          }
          return Optional.some(startRange);
        });
      });
    };
    const findPattern = (editor, block, details, normalizedMatches) => {
      const dom = editor.dom;
      const root = dom.getRoot();
      const pattern = details.pattern;
      const endNode = details.position.container;
      const endOffset = details.position.offset;
      return scanLeft(endNode, endOffset - details.pattern.end.length, block).bind(spot => {
        const endPathRng = generatePathRange(dom, root, spot.container, spot.offset, endNode, endOffset, normalizedMatches);
        if (isReplacementPattern(pattern)) {
          return Optional.some({
            matches: [{
                pattern,
                startRng: endPathRng,
                endRng: endPathRng
              }],
            position: spot
          });
        } else {
          const resultsOpt = findPatternsRec(editor, details.remainingPatterns, spot.container, spot.offset, block, normalizedMatches);
          const results = resultsOpt.getOr({
            matches: [],
            position: spot
          });
          const pos = results.position;
          const start = findPatternStart(dom, pattern, pos.container, pos.offset, block, resultsOpt.isNone());
          return start.map(startRng => {
            const startPathRng = generatePathRangeFromRange(dom, root, startRng, normalizedMatches);
            return {
              matches: results.matches.concat([{
                  pattern,
                  startRng: startPathRng,
                  endRng: endPathRng
                }]),
              position: point(startRng.startContainer, startRng.startOffset)
            };
          });
        }
      });
    };
    const findPatternsRec = (editor, patterns, node, offset, block, normalizedMatches) => {
      const dom = editor.dom;
      return textBefore(node, offset, dom.getRoot()).bind(endSpot => {
        const text = getBeforeText(dom, block, node, offset);
        for (let i = 0; i < patterns.length; i++) {
          const pattern = patterns[i];
          if (!endsWith(text, pattern.end)) {
            continue;
          }
          const patternsWithoutCurrent = patterns.slice();
          patternsWithoutCurrent.splice(i, 1);
          const result = findPattern(editor, block, {
            pattern,
            remainingPatterns: patternsWithoutCurrent,
            position: endSpot
          }, normalizedMatches);
          if (result.isNone() && offset > 0) {
            return findPatternsRec(editor, patterns, node, offset - 1, block, normalizedMatches);
          }
          if (result.isSome()) {
            return result;
          }
        }
        return Optional.none();
      });
    };
    const applyPattern = (editor, pattern, patternRange) => {
      editor.selection.setRng(patternRange);
      if (pattern.type === 'inline-format') {
        each$e(pattern.format, format => {
          editor.formatter.apply(format);
        });
      } else {
        editor.execCommand(pattern.cmd, false, pattern.value);
      }
    };
    const applyReplacementPattern = (editor, pattern, marker, isRoot) => {
      const markerRange = rangeFromMarker(editor.dom, marker);
      deleteRng(editor.dom, markerRange, isRoot);
      applyPattern(editor, pattern, markerRange);
    };
    const applyPatternWithContent = (editor, pattern, startMarker, endMarker, isRoot) => {
      const dom = editor.dom;
      const markerEndRange = rangeFromMarker(dom, endMarker);
      const markerStartRange = rangeFromMarker(dom, startMarker);
      deleteRng(dom, markerStartRange, isRoot);
      deleteRng(dom, markerEndRange, isRoot);
      const patternMarker = {
        prefix: startMarker.prefix,
        start: startMarker.end,
        end: endMarker.start
      };
      const patternRange = rangeFromMarker(dom, patternMarker);
      applyPattern(editor, pattern, patternRange);
    };
    const addMarkers = (dom, matches) => {
      const markerPrefix = generate$1('mce_textpattern');
      const matchesWithEnds = foldr(matches, (acc, match) => {
        const endMarker = createMarker(dom, markerPrefix + `_end${ acc.length }`, match.endRng);
        return acc.concat([{
            ...match,
            endMarker
          }]);
      }, []);
      return foldr(matchesWithEnds, (acc, match) => {
        const idx = matchesWithEnds.length - acc.length - 1;
        const startMarker = isReplacementPattern(match.pattern) ? match.endMarker : createMarker(dom, markerPrefix + `_start${ idx }`, match.startRng);
        return acc.concat([{
            ...match,
            startMarker
          }]);
      }, []);
    };
    const sortPatterns = patterns => sort(patterns, (a, b) => b.end.length - a.end.length);
    const getBestMatches = (matches, matchesWithSortedPatterns) => {
      const hasSameMatches = forall(matches, match => exists(matchesWithSortedPatterns, sortedMatch => match.pattern.start === sortedMatch.pattern.start && match.pattern.end === sortedMatch.pattern.end));
      if (matches.length === matchesWithSortedPatterns.length) {
        if (hasSameMatches) {
          return matches;
        } else {
          return matchesWithSortedPatterns;
        }
      }
      return matches.length > matchesWithSortedPatterns.length ? matches : matchesWithSortedPatterns;
    };
    const findPatterns = (editor, block, node, offset, patternSet, normalizedMatches) => {
      const matches = findPatternsRec(editor, patternSet.inlinePatterns, node, offset, block, normalizedMatches).fold(() => [], result => result.matches);
      const matchesWithSortedPatterns = findPatternsRec(editor, sortPatterns(patternSet.inlinePatterns), node, offset, block, normalizedMatches).fold(() => [], result => result.matches);
      return getBestMatches(matches, matchesWithSortedPatterns);
    };
    const applyMatches = (editor, matches) => {
      if (matches.length === 0) {
        return;
      }
      const dom = editor.dom;
      const bookmark = editor.selection.getBookmark();
      const matchesWithMarkers = addMarkers(dom, matches);
      each$e(matchesWithMarkers, match => {
        const block = dom.getParent(match.startMarker.start, dom.isBlock);
        const isRoot = node => node === block;
        if (isReplacementPattern(match.pattern)) {
          applyReplacementPattern(editor, match.pattern, match.endMarker, isRoot);
        } else {
          applyPatternWithContent(editor, match.pattern, match.startMarker, match.endMarker, isRoot);
        }
        removeMarker(dom, match.endMarker, isRoot);
        removeMarker(dom, match.startMarker, isRoot);
      });
      editor.selection.moveToBookmark(bookmark);
    };

    const handleEnter = (editor, patternSet) => {
      const rng = editor.selection.getRng();
      return getParentBlock(editor, rng).map(block => {
        var _a;
        const offset = Math.max(0, rng.startOffset);
        const dynamicPatternSet = resolveFromDynamicPatterns(patternSet, block, (_a = block.textContent) !== null && _a !== void 0 ? _a : '');
        const inlineMatches = findPatterns(editor, block, rng.startContainer, offset, dynamicPatternSet, true);
        const blockMatches = findPatterns$1(editor, block, dynamicPatternSet, true);
        if (blockMatches.length > 0 || inlineMatches.length > 0) {
          editor.undoManager.add();
          editor.undoManager.extra(() => {
            editor.execCommand('mceInsertNewLine');
          }, () => {
            editor.insertContent(zeroWidth);
            applyMatches(editor, inlineMatches);
            applyMatches$1(editor, blockMatches);
            const range = editor.selection.getRng();
            const spot = textBefore(range.startContainer, range.startOffset, editor.dom.getRoot());
            editor.execCommand('mceInsertNewLine');
            spot.each(s => {
              const node = s.container;
              if (node.data.charAt(s.offset - 1) === zeroWidth) {
                node.deleteData(s.offset - 1, 1);
                cleanEmptyNodes(editor.dom, node.parentNode, e => e === editor.dom.getRoot());
              }
            });
          });
          return true;
        }
        return false;
      }).getOr(false);
    };
    const handleInlineKey = (editor, patternSet) => {
      const rng = editor.selection.getRng();
      getParentBlock(editor, rng).map(block => {
        const offset = Math.max(0, rng.startOffset - 1);
        const beforeText = getBeforeText(editor.dom, block, rng.startContainer, offset);
        const dynamicPatternSet = resolveFromDynamicPatterns(patternSet, block, beforeText);
        const inlineMatches = findPatterns(editor, block, rng.startContainer, offset, dynamicPatternSet, false);
        if (inlineMatches.length > 0) {
          editor.undoManager.transact(() => {
            applyMatches(editor, inlineMatches);
          });
        }
      });
    };
    const checkKeyEvent = (codes, event, predicate) => {
      for (let i = 0; i < codes.length; i++) {
        if (predicate(codes[i], event)) {
          return true;
        }
      }
      return false;
    };
    const checkKeyCode = (codes, event) => checkKeyEvent(codes, event, (code, event) => {
      return code === event.keyCode && !VK.modifierPressed(event);
    });
    const checkCharCode = (chars, event) => checkKeyEvent(chars, event, (chr, event) => {
      return chr.charCodeAt(0) === event.charCode;
    });

    const setup$2 = editor => {
      const charCodes = [
        ',',
        '.',
        ';',
        ':',
        '!',
        '?'
      ];
      const keyCodes = [32];
      const getPatternSet = () => createPatternSet(getTextPatterns(editor), getTextPatternsLookup(editor));
      const hasDynamicPatterns = () => hasTextPatternsLookup(editor);
      editor.on('keydown', e => {
        if (e.keyCode === 13 && !VK.modifierPressed(e) && editor.selection.isCollapsed()) {
          const patternSet = getPatternSet();
          const hasPatterns = patternSet.inlinePatterns.length > 0 || patternSet.blockPatterns.length > 0 || hasDynamicPatterns();
          if (hasPatterns && handleEnter(editor, patternSet)) {
            e.preventDefault();
          }
        }
      }, true);
      const handleInlineTrigger = () => {
        if (editor.selection.isCollapsed()) {
          const patternSet = getPatternSet();
          const hasPatterns = patternSet.inlinePatterns.length > 0 || hasDynamicPatterns();
          if (hasPatterns) {
            handleInlineKey(editor, patternSet);
          }
        }
      };
      editor.on('keyup', e => {
        if (checkKeyCode(keyCodes, e)) {
          handleInlineTrigger();
        }
      });
      editor.on('keypress', e => {
        if (checkCharCode(charCodes, e)) {
          Delay.setEditorTimeout(editor, handleInlineTrigger);
        }
      });
    };

    const setup$1 = editor => {
      setup$2(editor);
    };

    const Quirks = editor => {
      const each = Tools.each;
      const BACKSPACE = VK.BACKSPACE, DELETE = VK.DELETE, dom = editor.dom, selection = editor.selection, parser = editor.parser;
      const browser = Env.browser;
      const isGecko = browser.isFirefox();
      const isWebKit = browser.isChromium() || browser.isSafari();
      const isiOS = Env.deviceType.isiPhone() || Env.deviceType.isiPad();
      const isMac = Env.os.isMacOS() || Env.os.isiOS();
      const setEditorCommandState = (cmd, state) => {
        try {
          editor.getDoc().execCommand(cmd, false, String(state));
        } catch (ex) {
        }
      };
      const isDefaultPrevented = e => {
        return e.isDefaultPrevented();
      };
      const emptyEditorWhenDeleting = () => {
        const serializeRng = rng => {
          const body = dom.create('body');
          const contents = rng.cloneContents();
          body.appendChild(contents);
          return selection.serializer.serialize(body, { format: 'html' });
        };
        const allContentsSelected = rng => {
          const selection = serializeRng(rng);
          const allRng = dom.createRng();
          allRng.selectNode(editor.getBody());
          const allSelection = serializeRng(allRng);
          return selection === allSelection;
        };
        editor.on('keydown', e => {
          const keyCode = e.keyCode;
          if (!isDefaultPrevented(e) && (keyCode === DELETE || keyCode === BACKSPACE) && editor.selection.isEditable()) {
            const isCollapsed = editor.selection.isCollapsed();
            const body = editor.getBody();
            if (isCollapsed && !dom.isEmpty(body)) {
              return;
            }
            if (!isCollapsed && !allContentsSelected(editor.selection.getRng())) {
              return;
            }
            e.preventDefault();
            editor.setContent('');
            if (body.firstChild && dom.isBlock(body.firstChild)) {
              editor.selection.setCursorLocation(body.firstChild, 0);
            } else {
              editor.selection.setCursorLocation(body, 0);
            }
            editor.nodeChanged();
          }
        });
      };
      const selectAll = () => {
        editor.shortcuts.add('meta+a', null, 'SelectAll');
      };
      const documentElementEditingFocus = () => {
        if (!editor.inline) {
          dom.bind(editor.getDoc(), 'mousedown mouseup', e => {
            let rng;
            if (e.target === editor.getDoc().documentElement) {
              rng = selection.getRng();
              editor.getBody().focus();
              if (e.type === 'mousedown') {
                if (isCaretContainer$2(rng.startContainer)) {
                  return;
                }
                selection.placeCaretAt(e.clientX, e.clientY);
              } else {
                selection.setRng(rng);
              }
            }
          });
        }
      };
      const removeHrOnBackspace = () => {
        editor.on('keydown', e => {
          if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {
            if (!editor.getBody().getElementsByTagName('hr').length) {
              return;
            }
            if (selection.isCollapsed() && selection.getRng().startOffset === 0) {
              const node = selection.getNode();
              const previousSibling = node.previousSibling;
              if (node.nodeName === 'HR') {
                dom.remove(node);
                e.preventDefault();
                return;
              }
              if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === 'hr') {
                dom.remove(previousSibling);
                e.preventDefault();
              }
            }
          }
        });
      };
      const focusBody = () => {
        if (!Range.prototype.getClientRects) {
          editor.on('mousedown', e => {
            if (!isDefaultPrevented(e) && e.target.nodeName === 'HTML') {
              const body = editor.getBody();
              body.blur();
              Delay.setEditorTimeout(editor, () => {
                body.focus();
              });
            }
          });
        }
      };
      const selectControlElements = () => {
        const visualAidsAnchorClass = getVisualAidsAnchorClass(editor);
        editor.on('click', e => {
          const target = e.target;
          if (/^(IMG|HR)$/.test(target.nodeName) && dom.isEditable(target.parentNode)) {
            e.preventDefault();
            editor.selection.select(target);
            editor.nodeChanged();
          }
          if (target.nodeName === 'A' && dom.hasClass(target, visualAidsAnchorClass) && target.childNodes.length === 0 && dom.isEditable(target.parentNode)) {
            e.preventDefault();
            selection.select(target);
          }
        });
      };
      const removeStylesWhenDeletingAcrossBlockElements = () => {
        const getAttributeApplyFunction = () => {
          const template = dom.getAttribs(selection.getStart().cloneNode(false));
          return () => {
            const target = selection.getStart();
            if (target !== editor.getBody()) {
              dom.setAttrib(target, 'style', null);
              each(template, attr => {
                target.setAttributeNode(attr.cloneNode(true));
              });
            }
          };
        };
        const isSelectionAcrossElements = () => {
          return !selection.isCollapsed() && dom.getParent(selection.getStart(), dom.isBlock) !== dom.getParent(selection.getEnd(), dom.isBlock);
        };
        editor.on('keypress', e => {
          let applyAttributes;
          if (!isDefaultPrevented(e) && (e.keyCode === 8 || e.keyCode === 46) && isSelectionAcrossElements()) {
            applyAttributes = getAttributeApplyFunction();
            editor.getDoc().execCommand('delete', false);
            applyAttributes();
            e.preventDefault();
            return false;
          } else {
            return true;
          }
        });
        dom.bind(editor.getDoc(), 'cut', e => {
          if (!isDefaultPrevented(e) && isSelectionAcrossElements()) {
            const applyAttributes = getAttributeApplyFunction();
            Delay.setEditorTimeout(editor, () => {
              applyAttributes();
            });
          }
        });
      };
      const disableBackspaceIntoATable = () => {
        editor.on('keydown', e => {
          if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {
            if (selection.isCollapsed() && selection.getRng().startOffset === 0) {
              const previousSibling = selection.getNode().previousSibling;
              if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === 'table') {
                e.preventDefault();
                return false;
              }
            }
          }
          return true;
        });
      };
      const removeBlockQuoteOnBackSpace = () => {
        editor.on('keydown', e => {
          if (isDefaultPrevented(e) || e.keyCode !== VK.BACKSPACE) {
            return;
          }
          let rng = selection.getRng();
          const container = rng.startContainer;
          const offset = rng.startOffset;
          const root = dom.getRoot();
          let parent = container;
          if (!rng.collapsed || offset !== 0) {
            return;
          }
          while (parent.parentNode && parent.parentNode.firstChild === parent && parent.parentNode !== root) {
            parent = parent.parentNode;
          }
          if (parent.nodeName === 'BLOCKQUOTE') {
            editor.formatter.toggle('blockquote', undefined, parent);
            rng = dom.createRng();
            rng.setStart(container, 0);
            rng.setEnd(container, 0);
            selection.setRng(rng);
          }
        });
      };
      const setGeckoEditingOptions = () => {
        const setOpts = () => {
          setEditorCommandState('StyleWithCSS', false);
          setEditorCommandState('enableInlineTableEditing', false);
          if (!getObjectResizing(editor)) {
            setEditorCommandState('enableObjectResizing', false);
          }
        };
        if (!isReadOnly$1(editor)) {
          editor.on('BeforeExecCommand mousedown', setOpts);
        }
      };
      const addBrAfterLastLinks = () => {
        const fixLinks = () => {
          each(dom.select('a:not([data-mce-block])'), node => {
            var _a;
            let parentNode = node.parentNode;
            const root = dom.getRoot();
            if ((parentNode === null || parentNode === void 0 ? void 0 : parentNode.lastChild) === node) {
              while (parentNode && !dom.isBlock(parentNode)) {
                if (((_a = parentNode.parentNode) === null || _a === void 0 ? void 0 : _a.lastChild) !== parentNode || parentNode === root) {
                  return;
                }
                parentNode = parentNode.parentNode;
              }
              dom.add(parentNode, 'br', { 'data-mce-bogus': 1 });
            }
          });
        };
        editor.on('SetContent ExecCommand', e => {
          if (e.type === 'setcontent' || e.command === 'mceInsertLink') {
            fixLinks();
          }
        });
      };
      const setDefaultBlockType = () => {
        editor.on('init', () => {
          setEditorCommandState('DefaultParagraphSeparator', getForcedRootBlock(editor));
        });
      };
      const isAllContentSelected = editor => {
        const body = editor.getBody();
        const rng = editor.selection.getRng();
        return rng.startContainer === rng.endContainer && rng.startContainer === body && rng.startOffset === 0 && rng.endOffset === body.childNodes.length;
      };
      const normalizeSelection = () => {
        editor.on('keyup focusin mouseup', e => {
          if (!VK.modifierPressed(e) && !isAllContentSelected(editor)) {
            selection.normalize();
          }
        }, true);
      };
      const showBrokenImageIcon = () => {
        editor.contentStyles.push('img:-moz-broken {' + '-moz-force-broken-image-icon:1;' + 'min-width:24px;' + 'min-height:24px' + '}');
      };
      const restoreFocusOnKeyDown = () => {
        if (!editor.inline) {
          editor.on('keydown', () => {
            if (document.activeElement === document.body) {
              editor.getWin().focus();
            }
          });
        }
      };
      const bodyHeight = () => {
        if (!editor.inline) {
          editor.contentStyles.push('body {min-height: 150px}');
          editor.on('click', e => {
            let rng;
            if (e.target.nodeName === 'HTML') {
              rng = editor.selection.getRng();
              editor.getBody().focus();
              editor.selection.setRng(rng);
              editor.selection.normalize();
              editor.nodeChanged();
            }
          });
        }
      };
      const blockCmdArrowNavigation = () => {
        if (isMac) {
          editor.on('keydown', e => {
            if (VK.metaKeyPressed(e) && !e.shiftKey && (e.keyCode === 37 || e.keyCode === 39)) {
              e.preventDefault();
              const selection = editor.selection.getSel();
              selection.modify('move', e.keyCode === 37 ? 'backward' : 'forward', 'lineboundary');
            }
          });
        }
      };
      const tapLinksAndImages = () => {
        editor.on('click', e => {
          let elm = e.target;
          do {
            if (elm.tagName === 'A') {
              e.preventDefault();
              return;
            }
          } while (elm = elm.parentNode);
        });
        editor.contentStyles.push('.mce-content-body {-webkit-touch-callout: none}');
      };
      const blockFormSubmitInsideEditor = () => {
        editor.on('init', () => {
          editor.dom.bind(editor.getBody(), 'submit', e => {
            e.preventDefault();
          });
        });
      };
      const removeAppleInterchangeBrs = () => {
        parser.addNodeFilter('br', nodes => {
          let i = nodes.length;
          while (i--) {
            if (nodes[i].attr('class') === 'Apple-interchange-newline') {
              nodes[i].remove();
            }
          }
        });
      };
      const refreshContentEditable = noop;
      const isHidden = () => {
        if (!isGecko || editor.removed) {
          return false;
        }
        const sel = editor.selection.getSel();
        return !sel || !sel.rangeCount || sel.rangeCount === 0;
      };
      const setupRtc = () => {
        if (isWebKit) {
          documentElementEditingFocus();
          selectControlElements();
          blockFormSubmitInsideEditor();
          selectAll();
          if (isiOS) {
            restoreFocusOnKeyDown();
            bodyHeight();
            tapLinksAndImages();
          }
        }
        if (isGecko) {
          focusBody();
          setGeckoEditingOptions();
          showBrokenImageIcon();
          blockCmdArrowNavigation();
        }
      };
      const setup = () => {
        removeBlockQuoteOnBackSpace();
        emptyEditorWhenDeleting();
        if (!Env.windowsPhone) {
          normalizeSelection();
        }
        if (isWebKit) {
          documentElementEditingFocus();
          selectControlElements();
          setDefaultBlockType();
          blockFormSubmitInsideEditor();
          disableBackspaceIntoATable();
          removeAppleInterchangeBrs();
          if (isiOS) {
            restoreFocusOnKeyDown();
            bodyHeight();
            tapLinksAndImages();
          } else {
            selectAll();
          }
        }
        if (isGecko) {
          removeHrOnBackspace();
          focusBody();
          removeStylesWhenDeletingAcrossBlockElements();
          setGeckoEditingOptions();
          addBrAfterLastLinks();
          showBrokenImageIcon();
          blockCmdArrowNavigation();
          disableBackspaceIntoATable();
        }
      };
      if (isRtc(editor)) {
        setupRtc();
      } else {
        setup();
      }
      return {
        refreshContentEditable,
        isHidden
      };
    };

    const DOM$6 = DOMUtils.DOM;
    const appendStyle = (editor, text) => {
      const body = SugarElement.fromDom(editor.getBody());
      const container = getStyleContainer(getRootNode(body));
      const style = SugarElement.fromTag('style');
      set$3(style, 'type', 'text/css');
      append$1(style, SugarElement.fromText(text));
      append$1(container, style);
      editor.on('remove', () => {
        remove$6(style);
      });
    };
    const getRootName = editor => editor.inline ? editor.getElement().nodeName.toLowerCase() : undefined;
    const removeUndefined = obj => filter$4(obj, v => isUndefined(v) === false);
    const mkParserSettings = editor => {
      const getOption = editor.options.get;
      const blobCache = editor.editorUpload.blobCache;
      return removeUndefined({
        allow_conditional_comments: getOption('allow_conditional_comments'),
        allow_html_data_urls: getOption('allow_html_data_urls'),
        allow_svg_data_urls: getOption('allow_svg_data_urls'),
        allow_html_in_named_anchor: getOption('allow_html_in_named_anchor'),
        allow_script_urls: getOption('allow_script_urls'),
        allow_unsafe_link_target: getOption('allow_unsafe_link_target'),
        convert_fonts_to_spans: getOption('convert_fonts_to_spans'),
        fix_list_elements: getOption('fix_list_elements'),
        font_size_legacy_values: getOption('font_size_legacy_values'),
        forced_root_block: getOption('forced_root_block'),
        forced_root_block_attrs: getOption('forced_root_block_attrs'),
        preserve_cdata: getOption('preserve_cdata'),
        remove_trailing_brs: getOption('remove_trailing_brs'),
        inline_styles: getOption('inline_styles'),
        root_name: getRootName(editor),
        sanitize: getOption('xss_sanitization'),
        validate: true,
        blob_cache: blobCache,
        document: editor.getDoc()
      });
    };
    const mkSchemaSettings = editor => {
      const getOption = editor.options.get;
      return removeUndefined({
        custom_elements: getOption('custom_elements'),
        extended_valid_elements: getOption('extended_valid_elements'),
        invalid_elements: getOption('invalid_elements'),
        invalid_styles: getOption('invalid_styles'),
        schema: getOption('schema'),
        valid_children: getOption('valid_children'),
        valid_classes: getOption('valid_classes'),
        valid_elements: getOption('valid_elements'),
        valid_styles: getOption('valid_styles'),
        verify_html: getOption('verify_html'),
        padd_empty_block_inline_children: getOption('format_empty_lines')
      });
    };
    const mkSerializerSettings = editor => {
      const getOption = editor.options.get;
      return {
        ...mkParserSettings(editor),
        ...mkSchemaSettings(editor),
        ...removeUndefined({
          url_converter: getOption('url_converter'),
          url_converter_scope: getOption('url_converter_scope'),
          element_format: getOption('element_format'),
          entities: getOption('entities'),
          entity_encoding: getOption('entity_encoding'),
          indent: getOption('indent'),
          indent_after: getOption('indent_after'),
          indent_before: getOption('indent_before')
        })
      };
    };
    const createParser = editor => {
      const parser = DomParser(mkParserSettings(editor), editor.schema);
      parser.addAttributeFilter('src,href,style,tabindex', (nodes, name) => {
        const dom = editor.dom;
        const internalName = 'data-mce-' + name;
        let i = nodes.length;
        while (i--) {
          const node = nodes[i];
          let value = node.attr(name);
          if (value && !node.attr(internalName)) {
            if (value.indexOf('data:') === 0 || value.indexOf('blob:') === 0) {
              continue;
            }
            if (name === 'style') {
              value = dom.serializeStyle(dom.parseStyle(value), node.name);
              if (!value.length) {
                value = null;
              }
              node.attr(internalName, value);
              node.attr(name, value);
            } else if (name === 'tabindex') {
              node.attr(internalName, value);
              node.attr(name, null);
            } else {
              node.attr(internalName, editor.convertURL(value, name, node.name));
            }
          }
        }
      });
      parser.addNodeFilter('script', nodes => {
        let i = nodes.length;
        while (i--) {
          const node = nodes[i];
          const type = node.attr('type') || 'no/type';
          if (type.indexOf('mce-') !== 0) {
            node.attr('type', 'mce-' + type);
          }
        }
      });
      if (shouldPreserveCData(editor)) {
        parser.addNodeFilter('#cdata', nodes => {
          var _a;
          let i = nodes.length;
          while (i--) {
            const node = nodes[i];
            node.type = 8;
            node.name = '#comment';
            node.value = '[CDATA[' + editor.dom.encode((_a = node.value) !== null && _a !== void 0 ? _a : '') + ']]';
          }
        });
      }
      parser.addNodeFilter('p,h1,h2,h3,h4,h5,h6,div', nodes => {
        let i = nodes.length;
        const nonEmptyElements = editor.schema.getNonEmptyElements();
        while (i--) {
          const node = nodes[i];
          if (node.isEmpty(nonEmptyElements) && node.getAll('br').length === 0) {
            node.append(new AstNode('br', 1));
          }
        }
      });
      return parser;
    };
    const autoFocus = editor => {
      const autoFocus = getAutoFocus(editor);
      if (autoFocus) {
        Delay.setEditorTimeout(editor, () => {
          let focusEditor;
          if (autoFocus === true) {
            focusEditor = editor;
          } else {
            focusEditor = editor.editorManager.get(autoFocus);
          }
          if (focusEditor && !focusEditor.destroyed) {
            focusEditor.focus();
            focusEditor.selection.scrollIntoView();
          }
        }, 100);
      }
    };
    const moveSelectionToFirstCaretPosition = editor => {
      const root = editor.dom.getRoot();
      if (!editor.inline && (!hasAnyRanges(editor) || editor.selection.getStart(true) === root)) {
        firstPositionIn(root).each(pos => {
          const node = pos.getNode();
          const caretPos = isTable$2(node) ? firstPositionIn(node).getOr(pos) : pos;
          editor.selection.setRng(caretPos.toRange());
        });
      }
    };
    const initEditor = editor => {
      editor.bindPendingEventDelegates();
      editor.initialized = true;
      fireInit(editor);
      editor.focus(true);
      moveSelectionToFirstCaretPosition(editor);
      editor.nodeChanged({ initial: true });
      const initInstanceCallback = getInitInstanceCallback(editor);
      if (isFunction(initInstanceCallback)) {
        initInstanceCallback.call(editor, editor);
      }
      autoFocus(editor);
    };
    const getStyleSheetLoader$1 = editor => editor.inline ? editor.ui.styleSheetLoader : editor.dom.styleSheetLoader;
    const makeStylesheetLoadingPromises = (editor, css, framedFonts) => {
      const promises = [getStyleSheetLoader$1(editor).loadAll(css)];
      if (editor.inline) {
        return promises;
      } else {
        return promises.concat([editor.ui.styleSheetLoader.loadAll(framedFonts)]);
      }
    };
    const loadContentCss = editor => {
      const styleSheetLoader = getStyleSheetLoader$1(editor);
      const fontCss = getFontCss(editor);
      const css = editor.contentCSS;
      const removeCss = () => {
        styleSheetLoader.unloadAll(css);
        if (!editor.inline) {
          editor.ui.styleSheetLoader.unloadAll(fontCss);
        }
      };
      const loaded = () => {
        if (editor.removed) {
          removeCss();
        } else {
          editor.on('remove', removeCss);
        }
      };
      if (editor.contentStyles.length > 0) {
        let contentCssText = '';
        Tools.each(editor.contentStyles, style => {
          contentCssText += style + '\r\n';
        });
        editor.dom.addStyle(contentCssText);
      }
      const allStylesheets = Promise.all(makeStylesheetLoadingPromises(editor, css, fontCss)).then(loaded).catch(loaded);
      const contentStyle = getContentStyle(editor);
      if (contentStyle) {
        appendStyle(editor, contentStyle);
      }
      return allStylesheets;
    };
    const preInit = editor => {
      const doc = editor.getDoc(), body = editor.getBody();
      firePreInit(editor);
      if (!shouldBrowserSpellcheck(editor)) {
        doc.body.spellcheck = false;
        DOM$6.setAttrib(body, 'spellcheck', 'false');
      }
      editor.quirks = Quirks(editor);
      firePostRender(editor);
      const directionality = getDirectionality(editor);
      if (directionality !== undefined) {
        body.dir = directionality;
      }
      const protect = getProtect(editor);
      if (protect) {
        editor.on('BeforeSetContent', e => {
          Tools.each(protect, pattern => {
            e.content = e.content.replace(pattern, str => {
              return '<!--mce:protected ' + escape(str) + '-->';
            });
          });
        });
      }
      editor.on('SetContent', () => {
        editor.addVisual(editor.getBody());
      });
      editor.on('compositionstart compositionend', e => {
        editor.composing = e.type === 'compositionstart';
      });
    };
    const loadInitialContent = editor => {
      if (!isRtc(editor)) {
        editor.load({
          initial: true,
          format: 'html'
        });
      }
      editor.startContent = editor.getContent({ format: 'raw' });
    };
    const initEditorWithInitialContent = editor => {
      if (editor.removed !== true) {
        loadInitialContent(editor);
        initEditor(editor);
      }
    };
    const contentBodyLoaded = editor => {
      const targetElm = editor.getElement();
      let doc = editor.getDoc();
      if (editor.inline) {
        DOM$6.addClass(targetElm, 'mce-content-body');
        editor.contentDocument = doc = document;
        editor.contentWindow = window;
        editor.bodyElement = targetElm;
        editor.contentAreaContainer = targetElm;
      }
      const body = editor.getBody();
      body.disabled = true;
      editor.readonly = isReadOnly$1(editor);
      if (!editor.readonly) {
        if (editor.inline && DOM$6.getStyle(body, 'position', true) === 'static') {
          body.style.position = 'relative';
        }
        body.contentEditable = 'true';
      }
      body.disabled = false;
      editor.editorUpload = EditorUpload(editor);
      editor.schema = Schema(mkSchemaSettings(editor));
      editor.dom = DOMUtils(doc, {
        keep_values: true,
        url_converter: editor.convertURL,
        url_converter_scope: editor,
        update_styles: true,
        root_element: editor.inline ? editor.getBody() : null,
        collect: editor.inline,
        schema: editor.schema,
        contentCssCors: shouldUseContentCssCors(editor),
        referrerPolicy: getReferrerPolicy(editor),
        onSetAttrib: e => {
          editor.dispatch('SetAttrib', e);
        }
      });
      editor.parser = createParser(editor);
      editor.serializer = DomSerializer(mkSerializerSettings(editor), editor);
      editor.selection = EditorSelection(editor.dom, editor.getWin(), editor.serializer, editor);
      editor.annotator = Annotator(editor);
      editor.formatter = Formatter(editor);
      editor.undoManager = UndoManager(editor);
      editor._nodeChangeDispatcher = new NodeChange(editor);
      editor._selectionOverrides = SelectionOverrides(editor);
      setup$o(editor);
      setup$6(editor);
      setup$m(editor);
      if (!isRtc(editor)) {
        setup$5(editor);
        setup$1(editor);
      }
      const caret = setup$b(editor);
      setup$p(editor, caret);
      setup$n(editor);
      setup$q(editor);
      setup$7(editor);
      const setupRtcThunk = setup$s(editor);
      preInit(editor);
      setupRtcThunk.fold(() => {
        loadContentCss(editor).then(() => initEditorWithInitialContent(editor));
      }, setupRtc => {
        editor.setProgressState(true);
        loadContentCss(editor).then(() => {
          setupRtc().then(_rtcMode => {
            editor.setProgressState(false);
            initEditorWithInitialContent(editor);
            bindEvents(editor);
          }, err => {
            editor.notificationManager.open({
              type: 'error',
              text: String(err)
            });
            initEditorWithInitialContent(editor);
            bindEvents(editor);
          });
        });
      });
    };

    const filter = always;
    const bind = (element, event, handler) => bind$2(element, event, filter, handler);

    const DOM$5 = DOMUtils.DOM;
    const createIframeElement = (id, title, customAttrs, tabindex) => {
      const iframe = SugarElement.fromTag('iframe');
      tabindex.each(t => set$3(iframe, 'tabindex', t));
      setAll$1(iframe, customAttrs);
      setAll$1(iframe, {
        id: id + '_ifr',
        frameBorder: '0',
        allowTransparency: 'true',
        title
      });
      add$2(iframe, 'tox-edit-area__iframe');
      return iframe;
    };
    const getIframeHtml = editor => {
      let iframeHTML = getDocType(editor) + '<html><head>';
      if (getDocumentBaseUrl(editor) !== editor.documentBaseUrl) {
        iframeHTML += '<base href="' + editor.documentBaseURI.getURI() + '" />';
      }
      iframeHTML += '<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />';
      const bodyId = getBodyId(editor);
      const bodyClass = getBodyClass(editor);
      const translatedAriaText = editor.translate(getIframeAriaText(editor));
      if (getContentSecurityPolicy(editor)) {
        iframeHTML += '<meta http-equiv="Content-Security-Policy" content="' + getContentSecurityPolicy(editor) + '" />';
      }
      iframeHTML += '</head>' + `<body id="${ bodyId }" class="mce-content-body ${ bodyClass }" data-id="${ editor.id }" aria-label="${ translatedAriaText }">` + '<br>' + '</body></html>';
      return iframeHTML;
    };
    const createIframe = (editor, boxInfo) => {
      const iframeTitle = editor.translate('Rich Text Area');
      const tabindex = getOpt(SugarElement.fromDom(editor.getElement()), 'tabindex').bind(toInt);
      const ifr = createIframeElement(editor.id, iframeTitle, getIframeAttrs(editor), tabindex).dom;
      ifr.onload = () => {
        ifr.onload = null;
        editor.dispatch('load');
      };
      editor.contentAreaContainer = boxInfo.iframeContainer;
      editor.iframeElement = ifr;
      editor.iframeHTML = getIframeHtml(editor);
      DOM$5.add(boxInfo.iframeContainer, ifr);
    };
    const setupIframeBody = editor => {
      const iframe = editor.iframeElement;
      const binder = bind(SugarElement.fromDom(iframe), 'load', () => {
        binder.unbind();
        editor.contentDocument = iframe.contentDocument;
        contentBodyLoaded(editor);
      });
      if (Env.browser.isFirefox()) {
        const doc = editor.getDoc();
        doc.open();
        doc.write(editor.iframeHTML);
        doc.close();
      } else {
        iframe.srcdoc = editor.iframeHTML;
      }
    };
    const init$1 = (editor, boxInfo) => {
      createIframe(editor, boxInfo);
      if (boxInfo.editorContainer) {
        boxInfo.editorContainer.style.display = editor.orgDisplay;
        editor.hidden = DOM$5.isHidden(boxInfo.editorContainer);
      }
      editor.getElement().style.display = 'none';
      DOM$5.setAttrib(editor.id, 'aria-hidden', 'true');
      editor.getElement().style.visibility = editor.orgVisibility;
      setupIframeBody(editor);
    };

    const DOM$4 = DOMUtils.DOM;
    const initPlugin = (editor, initializedPlugins, plugin) => {
      const Plugin = PluginManager.get(plugin);
      const pluginUrl = PluginManager.urls[plugin] || editor.documentBaseUrl.replace(/\/$/, '');
      plugin = Tools.trim(plugin);
      if (Plugin && Tools.inArray(initializedPlugins, plugin) === -1) {
        if (editor.plugins[plugin]) {
          return;
        }
        try {
          const pluginInstance = Plugin(editor, pluginUrl) || {};
          editor.plugins[plugin] = pluginInstance;
          if (isFunction(pluginInstance.init)) {
            pluginInstance.init(editor, pluginUrl);
            initializedPlugins.push(plugin);
          }
        } catch (e) {
          pluginInitError(editor, plugin, e);
        }
      }
    };
    const trimLegacyPrefix = name => {
      return name.replace(/^\-/, '');
    };
    const initPlugins = editor => {
      const initializedPlugins = [];
      each$e(getPlugins(editor), name => {
        initPlugin(editor, initializedPlugins, trimLegacyPrefix(name));
      });
    };
    const initIcons = editor => {
      const iconPackName = Tools.trim(getIconPackName(editor));
      const currentIcons = editor.ui.registry.getAll().icons;
      const loadIcons = {
        ...IconManager.get('default').icons,
        ...IconManager.get(iconPackName).icons
      };
      each$d(loadIcons, (svgData, icon) => {
        if (!has$2(currentIcons, icon)) {
          editor.ui.registry.addIcon(icon, svgData);
        }
      });
    };
    const initTheme = editor => {
      const theme = getTheme(editor);
      if (isString(theme)) {
        const Theme = ThemeManager.get(theme);
        editor.theme = Theme(editor, ThemeManager.urls[theme]) || {};
        if (isFunction(editor.theme.init)) {
          editor.theme.init(editor, ThemeManager.urls[theme] || editor.documentBaseUrl.replace(/\/$/, ''));
        }
      } else {
        editor.theme = {};
      }
    };
    const initModel = editor => {
      const model = getModel(editor);
      const Model = ModelManager.get(model);
      editor.model = Model(editor, ModelManager.urls[model]);
    };
    const renderFromLoadedTheme = editor => {
      const render = editor.theme.renderUI;
      return render ? render() : renderThemeFalse(editor);
    };
    const renderFromThemeFunc = editor => {
      const elm = editor.getElement();
      const theme = getTheme(editor);
      const info = theme(editor, elm);
      if (info.editorContainer.nodeType) {
        info.editorContainer.id = info.editorContainer.id || editor.id + '_parent';
      }
      if (info.iframeContainer && info.iframeContainer.nodeType) {
        info.iframeContainer.id = info.iframeContainer.id || editor.id + '_iframecontainer';
      }
      info.height = info.iframeHeight ? info.iframeHeight : elm.offsetHeight;
      return info;
    };
    const createThemeFalseResult = (element, iframe) => {
      return {
        editorContainer: element,
        iframeContainer: iframe,
        api: {}
      };
    };
    const renderThemeFalseIframe = targetElement => {
      const iframeContainer = DOM$4.create('div');
      DOM$4.insertAfter(iframeContainer, targetElement);
      return createThemeFalseResult(iframeContainer, iframeContainer);
    };
    const renderThemeFalse = editor => {
      const targetElement = editor.getElement();
      return editor.inline ? createThemeFalseResult(null) : renderThemeFalseIframe(targetElement);
    };
    const renderThemeUi = editor => {
      const elm = editor.getElement();
      editor.orgDisplay = elm.style.display;
      if (isString(getTheme(editor))) {
        return renderFromLoadedTheme(editor);
      } else if (isFunction(getTheme(editor))) {
        return renderFromThemeFunc(editor);
      } else {
        return renderThemeFalse(editor);
      }
    };
    const augmentEditorUiApi = (editor, api) => {
      const uiApiFacade = {
        show: Optional.from(api.show).getOr(noop),
        hide: Optional.from(api.hide).getOr(noop),
        isEnabled: Optional.from(api.isEnabled).getOr(always),
        setEnabled: state => {
          if (!editor.mode.isReadOnly()) {
            Optional.from(api.setEnabled).each(f => f(state));
          }
        }
      };
      editor.ui = {
        ...editor.ui,
        ...uiApiFacade
      };
    };
    const init = async editor => {
      editor.dispatch('ScriptsLoaded');
      initIcons(editor);
      initTheme(editor);
      initModel(editor);
      initPlugins(editor);
      const renderInfo = await renderThemeUi(editor);
      augmentEditorUiApi(editor, Optional.from(renderInfo.api).getOr({}));
      editor.editorContainer = renderInfo.editorContainer;
      appendContentCssFromSettings(editor);
      if (editor.inline) {
        contentBodyLoaded(editor);
      } else {
        init$1(editor, {
          editorContainer: renderInfo.editorContainer,
          iframeContainer: renderInfo.iframeContainer
        });
      }
    };

    const DOM$3 = DOMUtils.DOM;
    const hasSkipLoadPrefix = name => name.charAt(0) === '-';
    const loadLanguage = (scriptLoader, editor) => {
      const languageCode = getLanguageCode(editor);
      const languageUrl = getLanguageUrl(editor);
      if (!I18n.hasCode(languageCode) && languageCode !== 'en') {
        const url = isNotEmpty(languageUrl) ? languageUrl : `${ editor.editorManager.baseURL }/langs/${ languageCode }.js`;
        scriptLoader.add(url).catch(() => {
          languageLoadError(editor, url, languageCode);
        });
      }
    };
    const loadTheme = (editor, suffix) => {
      const theme = getTheme(editor);
      if (isString(theme) && !hasSkipLoadPrefix(theme) && !has$2(ThemeManager.urls, theme)) {
        const themeUrl = getThemeUrl(editor);
        const url = themeUrl ? editor.documentBaseURI.toAbsolute(themeUrl) : `themes/${ theme }/theme${ suffix }.js`;
        ThemeManager.load(theme, url).catch(() => {
          themeLoadError(editor, url, theme);
        });
      }
    };
    const loadModel = (editor, suffix) => {
      const model = getModel(editor);
      if (model !== 'plugin' && !has$2(ModelManager.urls, model)) {
        const modelUrl = getModelUrl(editor);
        const url = isString(modelUrl) ? editor.documentBaseURI.toAbsolute(modelUrl) : `models/${ model }/model${ suffix }.js`;
        ModelManager.load(model, url).catch(() => {
          modelLoadError(editor, url, model);
        });
      }
    };
    const getIconsUrlMetaFromUrl = editor => Optional.from(getIconsUrl(editor)).filter(isNotEmpty).map(url => ({
      url,
      name: Optional.none()
    }));
    const getIconsUrlMetaFromName = (editor, name, suffix) => Optional.from(name).filter(name => isNotEmpty(name) && !IconManager.has(name)).map(name => ({
      url: `${ editor.editorManager.baseURL }/icons/${ name }/icons${ suffix }.js`,
      name: Optional.some(name)
    }));
    const loadIcons = (scriptLoader, editor, suffix) => {
      const defaultIconsUrl = getIconsUrlMetaFromName(editor, 'default', suffix);
      const customIconsUrl = getIconsUrlMetaFromUrl(editor).orThunk(() => getIconsUrlMetaFromName(editor, getIconPackName(editor), ''));
      each$e(cat([
        defaultIconsUrl,
        customIconsUrl
      ]), urlMeta => {
        scriptLoader.add(urlMeta.url).catch(() => {
          iconsLoadError(editor, urlMeta.url, urlMeta.name.getOrUndefined());
        });
      });
    };
    const loadPlugins = (editor, suffix) => {
      const loadPlugin = (name, url) => {
        PluginManager.load(name, url).catch(() => {
          pluginLoadError(editor, url, name);
        });
      };
      each$d(getExternalPlugins$1(editor), (url, name) => {
        loadPlugin(name, url);
        editor.options.set('plugins', getPlugins(editor).concat(name));
      });
      each$e(getPlugins(editor), plugin => {
        plugin = Tools.trim(plugin);
        if (plugin && !PluginManager.urls[plugin] && !hasSkipLoadPrefix(plugin)) {
          loadPlugin(plugin, `plugins/${ plugin }/plugin${ suffix }.js`);
        }
      });
    };
    const isThemeLoaded = editor => {
      const theme = getTheme(editor);
      return !isString(theme) || isNonNullable(ThemeManager.get(theme));
    };
    const isModelLoaded = editor => {
      const model = getModel(editor);
      return isNonNullable(ModelManager.get(model));
    };
    const loadScripts = (editor, suffix) => {
      const scriptLoader = ScriptLoader.ScriptLoader;
      const initEditor = () => {
        if (!editor.removed && isThemeLoaded(editor) && isModelLoaded(editor)) {
          init(editor);
        }
      };
      loadTheme(editor, suffix);
      loadModel(editor, suffix);
      loadLanguage(scriptLoader, editor);
      loadIcons(scriptLoader, editor, suffix);
      loadPlugins(editor, suffix);
      scriptLoader.loadQueue().then(initEditor, initEditor);
    };
    const getStyleSheetLoader = (element, editor) => instance.forElement(element, {
      contentCssCors: hasContentCssCors(editor),
      referrerPolicy: getReferrerPolicy(editor)
    });
    const render = editor => {
      const id = editor.id;
      I18n.setCode(getLanguageCode(editor));
      const readyHandler = () => {
        DOM$3.unbind(window, 'ready', readyHandler);
        editor.render();
      };
      if (!EventUtils.Event.domLoaded) {
        DOM$3.bind(window, 'ready', readyHandler);
        return;
      }
      if (!editor.getElement()) {
        return;
      }
      const element = SugarElement.fromDom(editor.getElement());
      const snapshot = clone$4(element);
      editor.on('remove', () => {
        eachr(element.dom.attributes, attr => remove$b(element, attr.name));
        setAll$1(element, snapshot);
      });
      editor.ui.styleSheetLoader = getStyleSheetLoader(element, editor);
      if (!isInline(editor)) {
        editor.orgVisibility = editor.getElement().style.visibility;
        editor.getElement().style.visibility = 'hidden';
      } else {
        editor.inline = true;
      }
      const form = editor.getElement().form || DOM$3.getParent(id, 'form');
      if (form) {
        editor.formElement = form;
        if (hasHiddenInput(editor) && !isTextareaOrInput(editor.getElement())) {
          DOM$3.insertAfter(DOM$3.create('input', {
            type: 'hidden',
            name: id
          }), id);
          editor.hasHiddenInput = true;
        }
        editor.formEventDelegate = e => {
          editor.dispatch(e.type, e);
        };
        DOM$3.bind(form, 'submit reset', editor.formEventDelegate);
        editor.on('reset', () => {
          editor.resetContent();
        });
        if (shouldPatchSubmit(editor) && !form.submit.nodeType && !form.submit.length && !form._mceOldSubmit) {
          form._mceOldSubmit = form.submit;
          form.submit = () => {
            editor.editorManager.triggerSave();
            editor.setDirty(false);
            return form._mceOldSubmit(form);
          };
        }
      }
      editor.windowManager = WindowManager(editor);
      editor.notificationManager = NotificationManager(editor);
      if (isEncodingXml(editor)) {
        editor.on('GetContent', e => {
          if (e.save) {
            e.content = DOM$3.encode(e.content);
          }
        });
      }
      if (shouldAddFormSubmitTrigger(editor)) {
        editor.on('submit', () => {
          if (editor.initialized) {
            editor.save();
          }
        });
      }
      if (shouldAddUnloadTrigger(editor)) {
        editor._beforeUnload = () => {
          if (editor.initialized && !editor.destroyed && !editor.isHidden()) {
            editor.save({
              format: 'raw',
              no_events: true,
              set_dirty: false
            });
          }
        };
        editor.editorManager.on('BeforeUnload', editor._beforeUnload);
      }
      editor.editorManager.add(editor);
      loadScripts(editor, editor.suffix);
    };

    const sectionResult = (sections, settings) => ({
      sections: constant(sections),
      options: constant(settings)
    });
    const deviceDetection = detect$2().deviceType;
    const isPhone = deviceDetection.isPhone();
    const isTablet = deviceDetection.isTablet();
    const normalizePlugins = plugins => {
      if (isNullable(plugins)) {
        return [];
      } else {
        const pluginNames = isArray$1(plugins) ? plugins : plugins.split(/[ ,]/);
        const trimmedPlugins = map$3(pluginNames, trim$3);
        return filter$5(trimmedPlugins, isNotEmpty);
      }
    };
    const extractSections = (keys, options) => {
      const result = bifilter(options, (value, key) => {
        return contains$2(keys, key);
      });
      return sectionResult(result.t, result.f);
    };
    const getSection = (sectionResult, name, defaults = {}) => {
      const sections = sectionResult.sections();
      const sectionOptions = get$a(sections, name).getOr({});
      return Tools.extend({}, defaults, sectionOptions);
    };
    const hasSection = (sectionResult, name) => {
      return has$2(sectionResult.sections(), name);
    };
    const getSectionConfig = (sectionResult, name) => {
      return hasSection(sectionResult, name) ? sectionResult.sections()[name] : {};
    };
    const getMobileOverrideOptions = (mobileOptions, isPhone) => {
      const defaultMobileOptions = {
        table_grid: false,
        object_resizing: false,
        resize: false,
        toolbar_mode: get$a(mobileOptions, 'toolbar_mode').getOr('scrolling'),
        toolbar_sticky: false
      };
      const defaultPhoneOptions = { menubar: false };
      return {
        ...defaultMobileOptions,
        ...isPhone ? defaultPhoneOptions : {}
      };
    };
    const getExternalPlugins = (overrideOptions, options) => {
      var _a;
      const userDefinedExternalPlugins = (_a = options.external_plugins) !== null && _a !== void 0 ? _a : {};
      if (overrideOptions && overrideOptions.external_plugins) {
        return Tools.extend({}, overrideOptions.external_plugins, userDefinedExternalPlugins);
      } else {
        return userDefinedExternalPlugins;
      }
    };
    const combinePlugins = (forcedPlugins, plugins) => [
      ...normalizePlugins(forcedPlugins),
      ...normalizePlugins(plugins)
    ];
    const getPlatformPlugins = (isMobileDevice, sectionResult, desktopPlugins, mobilePlugins) => {
      if (isMobileDevice && hasSection(sectionResult, 'mobile')) {
        return mobilePlugins;
      } else {
        return desktopPlugins;
      }
    };
    const processPlugins = (isMobileDevice, sectionResult, defaultOverrideOptions, options) => {
      const forcedPlugins = normalizePlugins(defaultOverrideOptions.forced_plugins);
      const desktopPlugins = normalizePlugins(options.plugins);
      const mobileConfig = getSectionConfig(sectionResult, 'mobile');
      const mobilePlugins = mobileConfig.plugins ? normalizePlugins(mobileConfig.plugins) : desktopPlugins;
      const platformPlugins = getPlatformPlugins(isMobileDevice, sectionResult, desktopPlugins, mobilePlugins);
      const combinedPlugins = combinePlugins(forcedPlugins, platformPlugins);
      return Tools.extend(options, {
        forced_plugins: forcedPlugins,
        plugins: combinedPlugins
      });
    };
    const isOnMobile = (isMobileDevice, sectionResult) => {
      return isMobileDevice && hasSection(sectionResult, 'mobile');
    };
    const combineOptions = (isMobileDevice, isPhone, defaultOptions, defaultOverrideOptions, options) => {
      var _a;
      const deviceOverrideOptions = isMobileDevice ? { mobile: getMobileOverrideOptions((_a = options.mobile) !== null && _a !== void 0 ? _a : {}, isPhone) } : {};
      const sectionResult = extractSections(['mobile'], deepMerge(deviceOverrideOptions, options));
      const extendedOptions = Tools.extend(defaultOptions, defaultOverrideOptions, sectionResult.options(), isOnMobile(isMobileDevice, sectionResult) ? getSection(sectionResult, 'mobile') : {}, { external_plugins: getExternalPlugins(defaultOverrideOptions, sectionResult.options()) });
      return processPlugins(isMobileDevice, sectionResult, defaultOverrideOptions, extendedOptions);
    };
    const normalizeOptions = (defaultOverrideOptions, options) => combineOptions(isPhone || isTablet, isPhone, options, defaultOverrideOptions, options);

    const addVisual = (editor, elm) => addVisual$1(editor, elm);

    const registerExecCommands$3 = editor => {
      const toggleFormat = (name, value) => {
        editor.formatter.toggle(name, value);
        editor.nodeChanged();
      };
      const toggleAlign = align => () => {
        each$e('left,center,right,justify'.split(','), name => {
          if (align !== name) {
            editor.formatter.remove('align' + name);
          }
        });
        if (align !== 'none') {
          toggleFormat('align' + align);
        }
      };
      editor.editorCommands.addCommands({
        JustifyLeft: toggleAlign('left'),
        JustifyCenter: toggleAlign('center'),
        JustifyRight: toggleAlign('right'),
        JustifyFull: toggleAlign('justify'),
        JustifyNone: toggleAlign('none')
      });
    };
    const registerQueryStateCommands$1 = editor => {
      const alignStates = name => () => {
        const selection = editor.selection;
        const nodes = selection.isCollapsed() ? [editor.dom.getParent(selection.getNode(), editor.dom.isBlock)] : selection.getSelectedBlocks();
        return exists(nodes, node => isNonNullable(editor.formatter.matchNode(node, name)));
      };
      editor.editorCommands.addCommands({
        JustifyLeft: alignStates('alignleft'),
        JustifyCenter: alignStates('aligncenter'),
        JustifyRight: alignStates('alignright'),
        JustifyFull: alignStates('alignjustify')
      }, 'state');
    };
    const registerCommands$a = editor => {
      registerExecCommands$3(editor);
      registerQueryStateCommands$1(editor);
    };

    const registerCommands$9 = editor => {
      editor.editorCommands.addCommands({
        'Cut,Copy,Paste': command => {
          const doc = editor.getDoc();
          let failed;
          try {
            doc.execCommand(command);
          } catch (ex) {
            failed = true;
          }
          if (command === 'paste' && !doc.queryCommandEnabled(command)) {
            failed = true;
          }
          if (failed || !doc.queryCommandSupported(command)) {
            let msg = editor.translate(`Your browser doesn't support direct access to the clipboard. ` + 'Please use the Ctrl+X/C/V keyboard shortcuts instead.');
            if (Env.os.isMacOS() || Env.os.isiOS()) {
              msg = msg.replace(/Ctrl\+/g, '\u2318+');
            }
            editor.notificationManager.open({
              text: msg,
              type: 'error'
            });
          }
        }
      });
    };

    const trimOrPadLeftRight = (dom, rng, html) => {
      const root = SugarElement.fromDom(dom.getRoot());
      if (needsToBeNbspLeft(root, CaretPosition.fromRangeStart(rng))) {
        html = html.replace(/^ /, '&nbsp;');
      } else {
        html = html.replace(/^&nbsp;/, ' ');
      }
      if (needsToBeNbspRight(root, CaretPosition.fromRangeEnd(rng))) {
        html = html.replace(/(&nbsp;| )(<br( \/)>)?$/, '&nbsp;');
      } else {
        html = html.replace(/&nbsp;(<br( \/)?>)?$/, ' ');
      }
      return html;
    };

    const processValue$1 = value => {
      if (typeof value !== 'string') {
        const details = Tools.extend({
          paste: value.paste,
          data: { paste: value.paste }
        }, value);
        return {
          content: value.content,
          details
        };
      }
      return {
        content: value,
        details: {}
      };
    };
    const trimOrPad = (editor, value) => {
      const selection = editor.selection;
      const dom = editor.dom;
      if (/^ | $/.test(value)) {
        return trimOrPadLeftRight(dom, selection.getRng(), value);
      } else {
        return value;
      }
    };
    const insertAtCaret = (editor, value) => {
      if (editor.selection.isEditable()) {
        const {content, details} = processValue$1(value);
        preProcessSetContent(editor, {
          ...details,
          content: trimOrPad(editor, content),
          format: 'html',
          set: false,
          selection: true
        }).each(args => {
          const insertedContent = insertContent$1(editor, args.content, details);
          postProcessSetContent(editor, insertedContent, args);
          editor.addVisual();
        });
      }
    };

    const registerCommands$8 = editor => {
      editor.editorCommands.addCommands({
        mceCleanup: () => {
          const bm = editor.selection.getBookmark();
          editor.setContent(editor.getContent());
          editor.selection.moveToBookmark(bm);
        },
        insertImage: (_command, _ui, value) => {
          insertAtCaret(editor, editor.dom.createHTML('img', { src: value }));
        },
        insertHorizontalRule: () => {
          editor.execCommand('mceInsertContent', false, '<hr>');
        },
        insertText: (_command, _ui, value) => {
          insertAtCaret(editor, editor.dom.encode(value));
        },
        insertHTML: (_command, _ui, value) => {
          insertAtCaret(editor, value);
        },
        mceInsertContent: (_command, _ui, value) => {
          insertAtCaret(editor, value);
        },
        mceSetContent: (_command, _ui, value) => {
          editor.setContent(value);
        },
        mceReplaceContent: (_command, _ui, value) => {
          editor.execCommand('mceInsertContent', false, value.replace(/\{\$selection\}/g, editor.selection.getContent({ format: 'text' })));
        },
        mceNewDocument: () => {
          editor.setContent('');
        }
      });
    };

    const legacyPropNames = {
      'font-size': 'size',
      'font-family': 'face'
    };
    const isFont = isTag('font');
    const getSpecifiedFontProp = (propName, rootElm, elm) => {
      const getProperty = elm => getRaw(elm, propName).orThunk(() => {
        if (isFont(elm)) {
          return get$a(legacyPropNames, propName).bind(legacyPropName => getOpt(elm, legacyPropName));
        } else {
          return Optional.none();
        }
      });
      const isRoot = elm => eq(SugarElement.fromDom(rootElm), elm);
      return closest$1(SugarElement.fromDom(elm), elm => getProperty(elm), isRoot);
    };
    const normalizeFontFamily = fontFamily => fontFamily.replace(/[\'\"\\]/g, '').replace(/,\s+/g, ',');
    const getComputedFontProp = (propName, elm) => Optional.from(DOMUtils.DOM.getStyle(elm, propName, true));
    const getFontProp = propName => (rootElm, elm) => Optional.from(elm).map(SugarElement.fromDom).filter(isElement$7).bind(element => getSpecifiedFontProp(propName, rootElm, element.dom).or(getComputedFontProp(propName, element.dom))).getOr('');
    const getFontSize = getFontProp('font-size');
    const getFontFamily = compose(normalizeFontFamily, getFontProp('font-family'));

    const findFirstCaretElement = editor => firstPositionIn(editor.getBody()).bind(caret => {
      const container = caret.container();
      return Optional.from(isText$a(container) ? container.parentNode : container);
    });
    const getCaretElement = editor => Optional.from(editor.selection.getRng()).bind(rng => {
      const root = editor.getBody();
      const atStartOfNode = rng.startContainer === root && rng.startOffset === 0;
      return atStartOfNode ? Optional.none() : Optional.from(editor.selection.getStart(true));
    });
    const bindRange = (editor, binder) => getCaretElement(editor).orThunk(curry(findFirstCaretElement, editor)).map(SugarElement.fromDom).filter(isElement$7).bind(binder);
    const mapRange = (editor, mapper) => bindRange(editor, compose1(Optional.some, mapper));

    const fromFontSizeNumber = (editor, value) => {
      if (/^[0-9.]+$/.test(value)) {
        const fontSizeNumber = parseInt(value, 10);
        if (fontSizeNumber >= 1 && fontSizeNumber <= 7) {
          const fontSizes = getFontStyleValues(editor);
          const fontClasses = getFontSizeClasses(editor);
          if (fontClasses.length > 0) {
            return fontClasses[fontSizeNumber - 1] || value;
          } else {
            return fontSizes[fontSizeNumber - 1] || value;
          }
        } else {
          return value;
        }
      } else {
        return value;
      }
    };
    const normalizeFontNames = font => {
      const fonts = font.split(/\s*,\s*/);
      return map$3(fonts, font => {
        if (font.indexOf(' ') !== -1 && !(startsWith(font, '"') || startsWith(font, `'`))) {
          return `'${ font }'`;
        } else {
          return font;
        }
      }).join(',');
    };
    const fontNameAction = (editor, value) => {
      const font = fromFontSizeNumber(editor, value);
      editor.formatter.toggle('fontname', { value: normalizeFontNames(font) });
      editor.nodeChanged();
    };
    const fontNameQuery = editor => mapRange(editor, elm => getFontFamily(editor.getBody(), elm.dom)).getOr('');
    const fontSizeAction = (editor, value) => {
      editor.formatter.toggle('fontsize', { value: fromFontSizeNumber(editor, value) });
      editor.nodeChanged();
    };
    const fontSizeQuery = editor => mapRange(editor, elm => getFontSize(editor.getBody(), elm.dom)).getOr('');

    const lineHeightQuery = editor => mapRange(editor, elm => {
      const root = SugarElement.fromDom(editor.getBody());
      const specifiedStyle = closest$1(elm, elm => getRaw(elm, 'line-height'), curry(eq, root));
      const computedStyle = () => {
        const lineHeight = parseFloat(get$7(elm, 'line-height'));
        const fontSize = parseFloat(get$7(elm, 'font-size'));
        return String(lineHeight / fontSize);
      };
      return specifiedStyle.getOrThunk(computedStyle);
    }).getOr('');
    const lineHeightAction = (editor, lineHeight) => {
      editor.formatter.toggle('lineheight', { value: String(lineHeight) });
      editor.nodeChanged();
    };

    const registerExecCommands$2 = editor => {
      const toggleFormat = (name, value) => {
        editor.formatter.toggle(name, value);
        editor.nodeChanged();
      };
      editor.editorCommands.addCommands({
        'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': command => {
          toggleFormat(command);
        },
        'ForeColor,HiliteColor': (command, _ui, value) => {
          toggleFormat(command, { value });
        },
        'BackColor': (_command, _ui, value) => {
          toggleFormat('hilitecolor', { value });
        },
        'FontName': (_command, _ui, value) => {
          fontNameAction(editor, value);
        },
        'FontSize': (_command, _ui, value) => {
          fontSizeAction(editor, value);
        },
        'LineHeight': (_command, _ui, value) => {
          lineHeightAction(editor, value);
        },
        'Lang': (command, _ui, lang) => {
          var _a;
          toggleFormat(command, {
            value: lang.code,
            customValue: (_a = lang.customCode) !== null && _a !== void 0 ? _a : null
          });
        },
        'RemoveFormat': command => {
          editor.formatter.remove(command);
        },
        'mceBlockQuote': () => {
          toggleFormat('blockquote');
        },
        'FormatBlock': (_command, _ui, value) => {
          toggleFormat(isString(value) ? value : 'p');
        },
        'mceToggleFormat': (_command, _ui, value) => {
          toggleFormat(value);
        }
      });
    };
    const registerQueryValueCommands = editor => {
      const isFormatMatch = name => editor.formatter.match(name);
      editor.editorCommands.addCommands({
        'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': command => isFormatMatch(command),
        'mceBlockQuote': () => isFormatMatch('blockquote')
      }, 'state');
      editor.editorCommands.addQueryValueHandler('FontName', () => fontNameQuery(editor));
      editor.editorCommands.addQueryValueHandler('FontSize', () => fontSizeQuery(editor));
      editor.editorCommands.addQueryValueHandler('LineHeight', () => lineHeightQuery(editor));
    };
    const registerCommands$7 = editor => {
      registerExecCommands$2(editor);
      registerQueryValueCommands(editor);
    };

    const registerCommands$6 = editor => {
      editor.editorCommands.addCommands({
        mceAddUndoLevel: () => {
          editor.undoManager.add();
        },
        mceEndUndoLevel: () => {
          editor.undoManager.add();
        },
        Undo: () => {
          editor.undoManager.undo();
        },
        Redo: () => {
          editor.undoManager.redo();
        }
      });
    };

    const registerCommands$5 = editor => {
      editor.editorCommands.addCommands({
        Indent: () => {
          indent(editor);
        },
        Outdent: () => {
          outdent(editor);
        }
      });
      editor.editorCommands.addCommands({ Outdent: () => canOutdent(editor) }, 'state');
    };

    const registerCommands$4 = editor => {
      const applyLinkToSelection = (_command, _ui, value) => {
        const linkDetails = isString(value) ? { href: value } : value;
        const anchor = editor.dom.getParent(editor.selection.getNode(), 'a');
        if (isObject(linkDetails) && isString(linkDetails.href)) {
          linkDetails.href = linkDetails.href.replace(/ /g, '%20');
          if (!anchor || !linkDetails.href) {
            editor.formatter.remove('link');
          }
          if (linkDetails.href) {
            editor.formatter.apply('link', linkDetails, anchor);
          }
        }
      };
      editor.editorCommands.addCommands({
        unlink: () => {
          if (editor.selection.isCollapsed()) {
            const elm = editor.dom.getParent(editor.selection.getStart(), 'a');
            if (elm) {
              editor.dom.remove(elm, true);
            }
            return;
          }
          editor.formatter.remove('link');
        },
        mceInsertLink: applyLinkToSelection,
        createLink: applyLinkToSelection
      });
    };

    const registerExecCommands$1 = editor => {
      editor.editorCommands.addCommands({
        'InsertUnorderedList,InsertOrderedList': command => {
          editor.getDoc().execCommand(command);
          const listElm = editor.dom.getParent(editor.selection.getNode(), 'ol,ul');
          if (listElm) {
            const listParent = listElm.parentNode;
            if (listParent && /^(H[1-6]|P|ADDRESS|PRE)$/.test(listParent.nodeName)) {
              const bm = editor.selection.getBookmark();
              editor.dom.split(listParent, listElm);
              editor.selection.moveToBookmark(bm);
            }
          }
        }
      });
    };
    const registerQueryStateCommands = editor => {
      editor.editorCommands.addCommands({
        'InsertUnorderedList,InsertOrderedList': command => {
          const list = editor.dom.getParent(editor.selection.getNode(), 'ul,ol');
          return list && (command === 'insertunorderedlist' && list.tagName === 'UL' || command === 'insertorderedlist' && list.tagName === 'OL');
        }
      }, 'state');
    };
    const registerCommands$3 = editor => {
      registerExecCommands$1(editor);
      registerQueryStateCommands(editor);
    };

    const registerCommands$2 = editor => {
      editor.editorCommands.addCommands({
        insertParagraph: () => {
          insertBreak(blockbreak, editor);
        },
        mceInsertNewLine: (_command, _ui, value) => {
          insert(editor, value);
        },
        InsertLineBreak: (_command, _ui, _value) => {
          insertBreak(linebreak, editor);
        }
      });
    };

    const registerCommands$1 = editor => {
      editor.editorCommands.addCommands({
        mceSelectNodeDepth: (_command, _ui, value) => {
          let counter = 0;
          editor.dom.getParent(editor.selection.getNode(), node => {
            if (isElement$6(node) && counter++ === value) {
              editor.selection.select(node);
              return false;
            } else {
              return true;
            }
          }, editor.getBody());
        },
        mceSelectNode: (_command, _ui, value) => {
          editor.selection.select(value);
        },
        selectAll: () => {
          const editingHost = editor.dom.getParent(editor.selection.getStart(), isContentEditableTrue$3);
          if (editingHost) {
            const rng = editor.dom.createRng();
            rng.selectNodeContents(editingHost);
            editor.selection.setRng(rng);
          }
        }
      });
    };

    const registerExecCommands = editor => {
      editor.editorCommands.addCommands({
        mceRemoveNode: (_command, _ui, value) => {
          const node = value !== null && value !== void 0 ? value : editor.selection.getNode();
          if (node !== editor.getBody()) {
            const bm = editor.selection.getBookmark();
            editor.dom.remove(node, true);
            editor.selection.moveToBookmark(bm);
          }
        },
        mcePrint: () => {
          editor.getWin().print();
        },
        mceFocus: (_command, _ui, value) => {
          focus(editor, value === true);
        },
        mceToggleVisualAid: () => {
          editor.hasVisual = !editor.hasVisual;
          editor.addVisual();
        }
      });
    };
    const registerCommands = editor => {
      registerCommands$a(editor);
      registerCommands$9(editor);
      registerCommands$6(editor);
      registerCommands$1(editor);
      registerCommands$8(editor);
      registerCommands$4(editor);
      registerCommands$5(editor);
      registerCommands$2(editor);
      registerCommands$3(editor);
      registerCommands$7(editor);
      registerExecCommands(editor);
    };

    const selectionSafeCommands = ['toggleview'];
    const isSelectionSafeCommand = command => contains$2(selectionSafeCommands, command.toLowerCase());
    class EditorCommands {
      constructor(editor) {
        this.commands = {
          state: {},
          exec: {},
          value: {}
        };
        this.editor = editor;
      }
      execCommand(command, ui = false, value, args) {
        const editor = this.editor;
        const lowerCaseCommand = command.toLowerCase();
        const skipFocus = args === null || args === void 0 ? void 0 : args.skip_focus;
        if (editor.removed) {
          return false;
        }
        if (lowerCaseCommand !== 'mcefocus') {
          if (!/^(mceAddUndoLevel|mceEndUndoLevel)$/i.test(lowerCaseCommand) && !skipFocus) {
            editor.focus();
          } else {
            restore(editor);
          }
        }
        const eventArgs = editor.dispatch('BeforeExecCommand', {
          command,
          ui,
          value
        });
        if (eventArgs.isDefaultPrevented()) {
          return false;
        }
        const func = this.commands.exec[lowerCaseCommand];
        if (isFunction(func)) {
          func(lowerCaseCommand, ui, value);
          editor.dispatch('ExecCommand', {
            command,
            ui,
            value
          });
          return true;
        }
        return false;
      }
      queryCommandState(command) {
        if (!isSelectionSafeCommand(command) && this.editor.quirks.isHidden() || this.editor.removed) {
          return false;
        }
        const lowerCaseCommand = command.toLowerCase();
        const func = this.commands.state[lowerCaseCommand];
        if (isFunction(func)) {
          return func(lowerCaseCommand);
        }
        return false;
      }
      queryCommandValue(command) {
        if (!isSelectionSafeCommand(command) && this.editor.quirks.isHidden() || this.editor.removed) {
          return '';
        }
        const lowerCaseCommand = command.toLowerCase();
        const func = this.commands.value[lowerCaseCommand];
        if (isFunction(func)) {
          return func(lowerCaseCommand);
        }
        return '';
      }
      addCommands(commandList, type = 'exec') {
        const commands = this.commands;
        each$d(commandList, (callback, command) => {
          each$e(command.toLowerCase().split(','), command => {
            commands[type][command] = callback;
          });
        });
      }
      addCommand(command, callback, scope) {
        const lowerCaseCommand = command.toLowerCase();
        this.commands.exec[lowerCaseCommand] = (_command, ui, value) => callback.call(scope !== null && scope !== void 0 ? scope : this.editor, ui, value);
      }
      queryCommandSupported(command) {
        const lowerCaseCommand = command.toLowerCase();
        if (this.commands.exec[lowerCaseCommand]) {
          return true;
        } else {
          return false;
        }
      }
      addQueryStateHandler(command, callback, scope) {
        this.commands.state[command.toLowerCase()] = () => callback.call(scope !== null && scope !== void 0 ? scope : this.editor);
      }
      addQueryValueHandler(command, callback, scope) {
        this.commands.value[command.toLowerCase()] = () => callback.call(scope !== null && scope !== void 0 ? scope : this.editor);
      }
    }

    const internalContentEditableAttr = 'data-mce-contenteditable';
    const toggleClass = (elm, cls, state) => {
      if (has(elm, cls) && !state) {
        remove$8(elm, cls);
      } else if (state) {
        add$2(elm, cls);
      }
    };
    const setEditorCommandState = (editor, cmd, state) => {
      try {
        editor.getDoc().execCommand(cmd, false, String(state));
      } catch (ex) {
      }
    };
    const setContentEditable = (elm, state) => {
      elm.dom.contentEditable = state ? 'true' : 'false';
    };
    const switchOffContentEditableTrue = elm => {
      each$e(descendants(elm, '*[contenteditable="true"]'), elm => {
        set$3(elm, internalContentEditableAttr, 'true');
        setContentEditable(elm, false);
      });
    };
    const switchOnContentEditableTrue = elm => {
      each$e(descendants(elm, `*[${ internalContentEditableAttr }="true"]`), elm => {
        remove$b(elm, internalContentEditableAttr);
        setContentEditable(elm, true);
      });
    };
    const removeFakeSelection = editor => {
      Optional.from(editor.selection.getNode()).each(elm => {
        elm.removeAttribute('data-mce-selected');
      });
    };
    const restoreFakeSelection = editor => {
      editor.selection.setRng(editor.selection.getRng());
    };
    const toggleReadOnly = (editor, state) => {
      const body = SugarElement.fromDom(editor.getBody());
      toggleClass(body, 'mce-content-readonly', state);
      if (state) {
        editor.selection.controlSelection.hideResizeRect();
        editor._selectionOverrides.hideFakeCaret();
        removeFakeSelection(editor);
        editor.readonly = true;
        setContentEditable(body, false);
        switchOffContentEditableTrue(body);
      } else {
        editor.readonly = false;
        setContentEditable(body, true);
        switchOnContentEditableTrue(body);
        setEditorCommandState(editor, 'StyleWithCSS', false);
        setEditorCommandState(editor, 'enableInlineTableEditing', false);
        setEditorCommandState(editor, 'enableObjectResizing', false);
        if (hasEditorOrUiFocus(editor)) {
          editor.focus();
        }
        restoreFakeSelection(editor);
        editor.nodeChanged();
      }
    };
    const isReadOnly = editor => editor.readonly;
    const registerFilters = editor => {
      editor.parser.addAttributeFilter('contenteditable', nodes => {
        if (isReadOnly(editor)) {
          each$e(nodes, node => {
            node.attr(internalContentEditableAttr, node.attr('contenteditable'));
            node.attr('contenteditable', 'false');
          });
        }
      });
      editor.serializer.addAttributeFilter(internalContentEditableAttr, nodes => {
        if (isReadOnly(editor)) {
          each$e(nodes, node => {
            node.attr('contenteditable', node.attr(internalContentEditableAttr));
          });
        }
      });
      editor.serializer.addTempAttr(internalContentEditableAttr);
    };
    const registerReadOnlyContentFilters = editor => {
      if (editor.serializer) {
        registerFilters(editor);
      } else {
        editor.on('PreInit', () => {
          registerFilters(editor);
        });
      }
    };
    const isClickEvent = e => e.type === 'click';
    const allowedEvents = ['copy'];
    const isReadOnlyAllowedEvent = e => contains$2(allowedEvents, e.type);
    const getAnchorHrefOpt = (editor, elm) => {
      const isRoot = elm => eq(elm, SugarElement.fromDom(editor.getBody()));
      return closest$3(elm, 'a', isRoot).bind(a => getOpt(a, 'href'));
    };
    const processReadonlyEvents = (editor, e) => {
      if (isClickEvent(e) && !VK.metaKeyPressed(e)) {
        const elm = SugarElement.fromDom(e.target);
        getAnchorHrefOpt(editor, elm).each(href => {
          e.preventDefault();
          if (/^#/.test(href)) {
            const targetEl = editor.dom.select(`${ href },[name="${ removeLeading(href, '#') }"]`);
            if (targetEl.length) {
              editor.selection.scrollIntoView(targetEl[0], true);
            }
          } else {
            window.open(href, '_blank', 'rel=noopener noreferrer,menubar=yes,toolbar=yes,location=yes,status=yes,resizable=yes,scrollbars=yes');
          }
        });
      } else if (isReadOnlyAllowedEvent(e)) {
        editor.dispatch(e.type, e);
      }
    };
    const registerReadOnlySelectionBlockers = editor => {
      editor.on('ShowCaret', e => {
        if (isReadOnly(editor)) {
          e.preventDefault();
        }
      });
      editor.on('ObjectSelected', e => {
        if (isReadOnly(editor)) {
          e.preventDefault();
        }
      });
    };

    const nativeEvents = Tools.makeMap('focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange ' + 'mouseout mouseenter mouseleave wheel keydown keypress keyup input beforeinput contextmenu dragstart dragend dragover ' + 'draggesture dragdrop drop drag submit ' + 'compositionstart compositionend compositionupdate touchstart touchmove touchend touchcancel', ' ');
    class EventDispatcher {
      constructor(settings) {
        this.bindings = {};
        this.settings = settings || {};
        this.scope = this.settings.scope || this;
        this.toggleEvent = this.settings.toggleEvent || never;
      }
      static isNative(name) {
        return !!nativeEvents[name.toLowerCase()];
      }
      fire(name, args) {
        return this.dispatch(name, args);
      }
      dispatch(name, args) {
        const lcName = name.toLowerCase();
        const event = normalize$3(lcName, args !== null && args !== void 0 ? args : {}, this.scope);
        if (this.settings.beforeFire) {
          this.settings.beforeFire(event);
        }
        const handlers = this.bindings[lcName];
        if (handlers) {
          for (let i = 0, l = handlers.length; i < l; i++) {
            const callback = handlers[i];
            if (callback.removed) {
              continue;
            }
            if (callback.once) {
              this.off(lcName, callback.func);
            }
            if (event.isImmediatePropagationStopped()) {
              return event;
            }
            if (callback.func.call(this.scope, event) === false) {
              event.preventDefault();
              return event;
            }
          }
        }
        return event;
      }
      on(name, callback, prepend, extra) {
        if (callback === false) {
          callback = never;
        }
        if (callback) {
          const wrappedCallback = {
            func: callback,
            removed: false
          };
          if (extra) {
            Tools.extend(wrappedCallback, extra);
          }
          const names = name.toLowerCase().split(' ');
          let i = names.length;
          while (i--) {
            const currentName = names[i];
            let handlers = this.bindings[currentName];
            if (!handlers) {
              handlers = [];
              this.toggleEvent(currentName, true);
            }
            if (prepend) {
              handlers = [
                wrappedCallback,
                ...handlers
              ];
            } else {
              handlers = [
                ...handlers,
                wrappedCallback
              ];
            }
            this.bindings[currentName] = handlers;
          }
        }
        return this;
      }
      off(name, callback) {
        if (name) {
          const names = name.toLowerCase().split(' ');
          let i = names.length;
          while (i--) {
            const currentName = names[i];
            let handlers = this.bindings[currentName];
            if (!currentName) {
              each$d(this.bindings, (_value, bindingName) => {
                this.toggleEvent(bindingName, false);
                delete this.bindings[bindingName];
              });
              return this;
            }
            if (handlers) {
              if (!callback) {
                handlers.length = 0;
              } else {
                const filteredHandlers = partition$2(handlers, handler => handler.func === callback);
                handlers = filteredHandlers.fail;
                this.bindings[currentName] = handlers;
                each$e(filteredHandlers.pass, handler => {
                  handler.removed = true;
                });
              }
              if (!handlers.length) {
                this.toggleEvent(name, false);
                delete this.bindings[currentName];
              }
            }
          }
        } else {
          each$d(this.bindings, (_value, name) => {
            this.toggleEvent(name, false);
          });
          this.bindings = {};
        }
        return this;
      }
      once(name, callback, prepend) {
        return this.on(name, callback, prepend, { once: true });
      }
      has(name) {
        name = name.toLowerCase();
        const binding = this.bindings[name];
        return !(!binding || binding.length === 0);
      }
    }

    const getEventDispatcher = obj => {
      if (!obj._eventDispatcher) {
        obj._eventDispatcher = new EventDispatcher({
          scope: obj,
          toggleEvent: (name, state) => {
            if (EventDispatcher.isNative(name) && obj.toggleNativeEvent) {
              obj.toggleNativeEvent(name, state);
            }
          }
        });
      }
      return obj._eventDispatcher;
    };
    const Observable = {
      fire(name, args, bubble) {
        return this.dispatch(name, args, bubble);
      },
      dispatch(name, args, bubble) {
        const self = this;
        if (self.removed && name !== 'remove' && name !== 'detach') {
          return normalize$3(name.toLowerCase(), args !== null && args !== void 0 ? args : {}, self);
        }
        const dispatcherArgs = getEventDispatcher(self).dispatch(name, args);
        if (bubble !== false && self.parent) {
          let parent = self.parent();
          while (parent && !dispatcherArgs.isPropagationStopped()) {
            parent.dispatch(name, dispatcherArgs, false);
            parent = parent.parent ? parent.parent() : undefined;
          }
        }
        return dispatcherArgs;
      },
      on(name, callback, prepend) {
        return getEventDispatcher(this).on(name, callback, prepend);
      },
      off(name, callback) {
        return getEventDispatcher(this).off(name, callback);
      },
      once(name, callback) {
        return getEventDispatcher(this).once(name, callback);
      },
      hasEventListeners(name) {
        return getEventDispatcher(this).has(name);
      }
    };

    const DOM$2 = DOMUtils.DOM;
    let customEventRootDelegates;
    const getEventTarget = (editor, eventName) => {
      if (eventName === 'selectionchange') {
        return editor.getDoc();
      }
      if (!editor.inline && /^(?:mouse|touch|click|contextmenu|drop|dragover|dragend)/.test(eventName)) {
        return editor.getDoc().documentElement;
      }
      const eventRoot = getEventRoot(editor);
      if (eventRoot) {
        if (!editor.eventRoot) {
          editor.eventRoot = DOM$2.select(eventRoot)[0];
        }
        return editor.eventRoot;
      }
      return editor.getBody();
    };
    const isListening = editor => !editor.hidden && !isReadOnly(editor);
    const fireEvent = (editor, eventName, e) => {
      if (isListening(editor)) {
        editor.dispatch(eventName, e);
      } else if (isReadOnly(editor)) {
        processReadonlyEvents(editor, e);
      }
    };
    const bindEventDelegate = (editor, eventName) => {
      if (!editor.delegates) {
        editor.delegates = {};
      }
      if (editor.delegates[eventName] || editor.removed) {
        return;
      }
      const eventRootElm = getEventTarget(editor, eventName);
      if (getEventRoot(editor)) {
        if (!customEventRootDelegates) {
          customEventRootDelegates = {};
          editor.editorManager.on('removeEditor', () => {
            if (!editor.editorManager.activeEditor) {
              if (customEventRootDelegates) {
                each$d(customEventRootDelegates, (_value, name) => {
                  editor.dom.unbind(getEventTarget(editor, name));
                });
                customEventRootDelegates = null;
              }
            }
          });
        }
        if (customEventRootDelegates[eventName]) {
          return;
        }
        const delegate = e => {
          const target = e.target;
          const editors = editor.editorManager.get();
          let i = editors.length;
          while (i--) {
            const body = editors[i].getBody();
            if (body === target || DOM$2.isChildOf(target, body)) {
              fireEvent(editors[i], eventName, e);
            }
          }
        };
        customEventRootDelegates[eventName] = delegate;
        DOM$2.bind(eventRootElm, eventName, delegate);
      } else {
        const delegate = e => {
          fireEvent(editor, eventName, e);
        };
        DOM$2.bind(eventRootElm, eventName, delegate);
        editor.delegates[eventName] = delegate;
      }
    };
    const EditorObservable = {
      ...Observable,
      bindPendingEventDelegates() {
        const self = this;
        Tools.each(self._pendingNativeEvents, name => {
          bindEventDelegate(self, name);
        });
      },
      toggleNativeEvent(name, state) {
        const self = this;
        if (name === 'focus' || name === 'blur') {
          return;
        }
        if (self.removed) {
          return;
        }
        if (state) {
          if (self.initialized) {
            bindEventDelegate(self, name);
          } else {
            if (!self._pendingNativeEvents) {
              self._pendingNativeEvents = [name];
            } else {
              self._pendingNativeEvents.push(name);
            }
          }
        } else if (self.initialized && self.delegates) {
          self.dom.unbind(getEventTarget(self, name), name, self.delegates[name]);
          delete self.delegates[name];
        }
      },
      unbindAllNativeEvents() {
        const self = this;
        const body = self.getBody();
        const dom = self.dom;
        if (self.delegates) {
          each$d(self.delegates, (value, name) => {
            self.dom.unbind(getEventTarget(self, name), name, value);
          });
          delete self.delegates;
        }
        if (!self.inline && body && dom) {
          body.onload = null;
          dom.unbind(self.getWin());
          dom.unbind(self.getDoc());
        }
        if (dom) {
          dom.unbind(body);
          dom.unbind(self.getContainer());
        }
      }
    };

    const stringListProcessor = value => {
      if (isString(value)) {
        return {
          value: value.split(/[ ,]/),
          valid: true
        };
      } else if (isArrayOf(value, isString)) {
        return {
          value,
          valid: true
        };
      } else {
        return {
          valid: false,
          message: `The value must be a string[] or a comma/space separated string.`
        };
      }
    };
    const getBuiltInProcessor = type => {
      const validator = (() => {
        switch (type) {
        case 'array':
          return isArray$1;
        case 'boolean':
          return isBoolean;
        case 'function':
          return isFunction;
        case 'number':
          return isNumber;
        case 'object':
          return isObject;
        case 'string':
          return isString;
        case 'string[]':
          return stringListProcessor;
        case 'object[]':
          return val => isArrayOf(val, isObject);
        case 'regexp':
          return val => is$4(val, RegExp);
        default:
          return always;
        }
      })();
      return value => processValue(value, validator, `The value must be a ${ type }.`);
    };
    const isBuiltInSpec = spec => isString(spec.processor);
    const getErrorMessage = (message, result) => {
      const additionalText = isEmpty$3(result.message) ? '' : `. ${ result.message }`;
      return message + additionalText;
    };
    const isValidResult = result => result.valid;
    const processValue = (value, processor, message = '') => {
      const result = processor(value);
      if (isBoolean(result)) {
        return result ? {
          value: value,
          valid: true
        } : {
          valid: false,
          message
        };
      } else {
        return result;
      }
    };
    const processDefaultValue = (name, defaultValue, processor) => {
      if (!isUndefined(defaultValue)) {
        const result = processValue(defaultValue, processor);
        if (isValidResult(result)) {
          return result.value;
        } else {
          console.error(getErrorMessage(`Invalid default value passed for the "${ name }" option`, result));
        }
      }
      return undefined;
    };
    const create$5 = (editor, initialOptions) => {
      const registry = {};
      const values = {};
      const setValue = (name, value, processor) => {
        const result = processValue(value, processor);
        if (isValidResult(result)) {
          values[name] = result.value;
          return true;
        } else {
          console.warn(getErrorMessage(`Invalid value passed for the ${ name } option`, result));
          return false;
        }
      };
      const register = (name, spec) => {
        const processor = isBuiltInSpec(spec) ? getBuiltInProcessor(spec.processor) : spec.processor;
        const defaultValue = processDefaultValue(name, spec.default, processor);
        registry[name] = {
          ...spec,
          default: defaultValue,
          processor
        };
        const initValue = get$a(values, name).orThunk(() => get$a(initialOptions, name));
        initValue.each(value => setValue(name, value, processor));
      };
      const isRegistered = name => has$2(registry, name);
      const get = name => get$a(values, name).orThunk(() => get$a(registry, name).map(spec => spec.default)).getOrUndefined();
      const set = (name, value) => {
        if (!isRegistered(name)) {
          console.warn(`"${ name }" is not a registered option. Ensure the option has been registered before setting a value.`);
          return false;
        } else {
          const spec = registry[name];
          if (spec.immutable) {
            console.error(`"${ name }" is an immutable option and cannot be updated`);
            return false;
          } else {
            return setValue(name, value, spec.processor);
          }
        }
      };
      const unset = name => {
        const registered = isRegistered(name);
        if (registered) {
          delete values[name];
        }
        return registered;
      };
      const isSet = name => has$2(values, name);
      return {
        register,
        isRegistered,
        get,
        set,
        unset,
        isSet
      };
    };

    const defaultModes = [
      'design',
      'readonly'
    ];
    const switchToMode = (editor, activeMode, availableModes, mode) => {
      const oldMode = availableModes[activeMode.get()];
      const newMode = availableModes[mode];
      try {
        newMode.activate();
      } catch (e) {
        console.error(`problem while activating editor mode ${ mode }:`, e);
        return;
      }
      oldMode.deactivate();
      if (oldMode.editorReadOnly !== newMode.editorReadOnly) {
        toggleReadOnly(editor, newMode.editorReadOnly);
      }
      activeMode.set(mode);
      fireSwitchMode(editor, mode);
    };
    const setMode = (editor, availableModes, activeMode, mode) => {
      if (mode === activeMode.get()) {
        return;
      } else if (!has$2(availableModes, mode)) {
        throw new Error(`Editor mode '${ mode }' is invalid`);
      }
      if (editor.initialized) {
        switchToMode(editor, activeMode, availableModes, mode);
      } else {
        editor.on('init', () => switchToMode(editor, activeMode, availableModes, mode));
      }
    };
    const registerMode = (availableModes, mode, api) => {
      if (contains$2(defaultModes, mode)) {
        throw new Error(`Cannot override default mode ${ mode }`);
      }
      return {
        ...availableModes,
        [mode]: {
          ...api,
          deactivate: () => {
            try {
              api.deactivate();
            } catch (e) {
              console.error(`problem while deactivating editor mode ${ mode }:`, e);
            }
          }
        }
      };
    };

    const create$4 = editor => {
      const activeMode = Cell('design');
      const availableModes = Cell({
        design: {
          activate: noop,
          deactivate: noop,
          editorReadOnly: false
        },
        readonly: {
          activate: noop,
          deactivate: noop,
          editorReadOnly: true
        }
      });
      registerReadOnlyContentFilters(editor);
      registerReadOnlySelectionBlockers(editor);
      return {
        isReadOnly: () => isReadOnly(editor),
        set: mode => setMode(editor, availableModes.get(), activeMode, mode),
        get: () => activeMode.get(),
        register: (mode, api) => {
          availableModes.set(registerMode(availableModes.get(), mode, api));
        }
      };
    };

    const each$2 = Tools.each, explode = Tools.explode;
    const keyCodeLookup = {
      f1: 112,
      f2: 113,
      f3: 114,
      f4: 115,
      f5: 116,
      f6: 117,
      f7: 118,
      f8: 119,
      f9: 120,
      f10: 121,
      f11: 122,
      f12: 123
    };
    const modifierNames = Tools.makeMap('alt,ctrl,shift,meta,access');
    const isModifier = key => key in modifierNames;
    const parseShortcut = pattern => {
      const shortcut = {};
      const isMac = Env.os.isMacOS() || Env.os.isiOS();
      each$2(explode(pattern.toLowerCase(), '+'), value => {
        if (isModifier(value)) {
          shortcut[value] = true;
        } else {
          if (/^[0-9]{2,}$/.test(value)) {
            shortcut.keyCode = parseInt(value, 10);
          } else {
            shortcut.charCode = value.charCodeAt(0);
            shortcut.keyCode = keyCodeLookup[value] || value.toUpperCase().charCodeAt(0);
          }
        }
      });
      const id = [shortcut.keyCode];
      let key;
      for (key in modifierNames) {
        if (shortcut[key]) {
          id.push(key);
        } else {
          shortcut[key] = false;
        }
      }
      shortcut.id = id.join(',');
      if (shortcut.access) {
        shortcut.alt = true;
        if (isMac) {
          shortcut.ctrl = true;
        } else {
          shortcut.shift = true;
        }
      }
      if (shortcut.meta) {
        if (isMac) {
          shortcut.meta = true;
        } else {
          shortcut.ctrl = true;
          shortcut.meta = false;
        }
      }
      return shortcut;
    };
    class Shortcuts {
      constructor(editor) {
        this.shortcuts = {};
        this.pendingPatterns = [];
        this.editor = editor;
        const self = this;
        editor.on('keyup keypress keydown', e => {
          if ((self.hasModifier(e) || self.isFunctionKey(e)) && !e.isDefaultPrevented()) {
            each$2(self.shortcuts, shortcut => {
              if (self.matchShortcut(e, shortcut)) {
                self.pendingPatterns = shortcut.subpatterns.slice(0);
                if (e.type === 'keydown') {
                  self.executeShortcutAction(shortcut);
                }
              }
            });
            if (self.matchShortcut(e, self.pendingPatterns[0])) {
              if (self.pendingPatterns.length === 1) {
                if (e.type === 'keydown') {
                  self.executeShortcutAction(self.pendingPatterns[0]);
                }
              }
              self.pendingPatterns.shift();
            }
          }
        });
      }
      add(pattern, desc, cmdFunc, scope) {
        const self = this;
        const func = self.normalizeCommandFunc(cmdFunc);
        each$2(explode(Tools.trim(pattern)), pattern => {
          const shortcut = self.createShortcut(pattern, desc, func, scope);
          self.shortcuts[shortcut.id] = shortcut;
        });
        return true;
      }
      remove(pattern) {
        const shortcut = this.createShortcut(pattern);
        if (this.shortcuts[shortcut.id]) {
          delete this.shortcuts[shortcut.id];
          return true;
        }
        return false;
      }
      normalizeCommandFunc(cmdFunc) {
        const self = this;
        const cmd = cmdFunc;
        if (typeof cmd === 'string') {
          return () => {
            self.editor.execCommand(cmd, false, null);
          };
        } else if (Tools.isArray(cmd)) {
          return () => {
            self.editor.execCommand(cmd[0], cmd[1], cmd[2]);
          };
        } else {
          return cmd;
        }
      }
      createShortcut(pattern, desc, cmdFunc, scope) {
        const shortcuts = Tools.map(explode(pattern, '>'), parseShortcut);
        shortcuts[shortcuts.length - 1] = Tools.extend(shortcuts[shortcuts.length - 1], {
          func: cmdFunc,
          scope: scope || this.editor
        });
        return Tools.extend(shortcuts[0], {
          desc: this.editor.translate(desc),
          subpatterns: shortcuts.slice(1)
        });
      }
      hasModifier(e) {
        return e.altKey || e.ctrlKey || e.metaKey;
      }
      isFunctionKey(e) {
        return e.type === 'keydown' && e.keyCode >= 112 && e.keyCode <= 123;
      }
      matchShortcut(e, shortcut) {
        if (!shortcut) {
          return false;
        }
        if (shortcut.ctrl !== e.ctrlKey || shortcut.meta !== e.metaKey) {
          return false;
        }
        if (shortcut.alt !== e.altKey || shortcut.shift !== e.shiftKey) {
          return false;
        }
        if (e.keyCode === shortcut.keyCode || e.charCode && e.charCode === shortcut.charCode) {
          e.preventDefault();
          return true;
        }
        return false;
      }
      executeShortcutAction(shortcut) {
        return shortcut.func ? shortcut.func.call(shortcut.scope) : null;
      }
    }

    const create$3 = () => {
      const buttons = {};
      const menuItems = {};
      const popups = {};
      const icons = {};
      const contextMenus = {};
      const contextToolbars = {};
      const sidebars = {};
      const views = {};
      const add = (collection, type) => (name, spec) => {
        collection[name.toLowerCase()] = {
          ...spec,
          type
        };
      };
      const addIcon = (name, svgData) => icons[name.toLowerCase()] = svgData;
      return {
        addButton: add(buttons, 'button'),
        addGroupToolbarButton: add(buttons, 'grouptoolbarbutton'),
        addToggleButton: add(buttons, 'togglebutton'),
        addMenuButton: add(buttons, 'menubutton'),
        addSplitButton: add(buttons, 'splitbutton'),
        addMenuItem: add(menuItems, 'menuitem'),
        addNestedMenuItem: add(menuItems, 'nestedmenuitem'),
        addToggleMenuItem: add(menuItems, 'togglemenuitem'),
        addAutocompleter: add(popups, 'autocompleter'),
        addContextMenu: add(contextMenus, 'contextmenu'),
        addContextToolbar: add(contextToolbars, 'contexttoolbar'),
        addContextForm: add(contextToolbars, 'contextform'),
        addSidebar: add(sidebars, 'sidebar'),
        addView: add(views, 'views'),
        addIcon,
        getAll: () => ({
          buttons,
          menuItems,
          icons,
          popups,
          contextMenus,
          contextToolbars,
          sidebars,
          views
        })
      };
    };

    const registry = () => {
      const bridge = create$3();
      return {
        addAutocompleter: bridge.addAutocompleter,
        addButton: bridge.addButton,
        addContextForm: bridge.addContextForm,
        addContextMenu: bridge.addContextMenu,
        addContextToolbar: bridge.addContextToolbar,
        addIcon: bridge.addIcon,
        addMenuButton: bridge.addMenuButton,
        addMenuItem: bridge.addMenuItem,
        addNestedMenuItem: bridge.addNestedMenuItem,
        addSidebar: bridge.addSidebar,
        addSplitButton: bridge.addSplitButton,
        addToggleButton: bridge.addToggleButton,
        addGroupToolbarButton: bridge.addGroupToolbarButton,
        addToggleMenuItem: bridge.addToggleMenuItem,
        addView: bridge.addView,
        getAll: bridge.getAll
      };
    };

    const DOM$1 = DOMUtils.DOM;
    const extend = Tools.extend, each$1 = Tools.each;
    class Editor {
      constructor(id, options, editorManager) {
        this.plugins = {};
        this.contentCSS = [];
        this.contentStyles = [];
        this.loadedCSS = {};
        this.isNotDirty = false;
        this.composing = false;
        this.destroyed = false;
        this.hasHiddenInput = false;
        this.iframeElement = null;
        this.initialized = false;
        this.readonly = false;
        this.removed = false;
        this.startContent = '';
        this._pendingNativeEvents = [];
        this._skinLoaded = false;
        this.editorManager = editorManager;
        this.documentBaseUrl = editorManager.documentBaseURL;
        extend(this, EditorObservable);
        const self = this;
        this.id = id;
        this.hidden = false;
        const normalizedOptions = normalizeOptions(editorManager.defaultOptions, options);
        this.options = create$5(self, normalizedOptions);
        register$7(self);
        const getOption = this.options.get;
        if (getOption('deprecation_warnings')) {
          logWarnings(options, normalizedOptions);
        }
        const suffix = getOption('suffix');
        if (suffix) {
          editorManager.suffix = suffix;
        }
        this.suffix = editorManager.suffix;
        const baseUrl = getOption('base_url');
        if (baseUrl) {
          editorManager._setBaseUrl(baseUrl);
        }
        this.baseUri = editorManager.baseURI;
        const referrerPolicy = getReferrerPolicy(self);
        if (referrerPolicy) {
          ScriptLoader.ScriptLoader._setReferrerPolicy(referrerPolicy);
          DOMUtils.DOM.styleSheetLoader._setReferrerPolicy(referrerPolicy);
        }
        const contentCssCors = hasContentCssCors(self);
        if (isNonNullable(contentCssCors)) {
          DOMUtils.DOM.styleSheetLoader._setContentCssCors(contentCssCors);
        }
        AddOnManager.languageLoad = getOption('language_load');
        AddOnManager.baseURL = editorManager.baseURL;
        this.setDirty(false);
        this.documentBaseURI = new URI(getDocumentBaseUrl(self), { base_uri: this.baseUri });
        this.baseURI = this.baseUri;
        this.inline = isInline(self);
        this.hasVisual = isVisualAidsEnabled(self);
        this.shortcuts = new Shortcuts(this);
        this.editorCommands = new EditorCommands(this);
        registerCommands(this);
        const cacheSuffix = getOption('cache_suffix');
        if (cacheSuffix) {
          Env.cacheSuffix = cacheSuffix.replace(/^[\?\&]+/, '');
        }
        this.ui = {
          registry: registry(),
          styleSheetLoader: undefined,
          show: noop,
          hide: noop,
          setEnabled: noop,
          isEnabled: always
        };
        this.mode = create$4(self);
        editorManager.dispatch('SetupEditor', { editor: this });
        const setupCallback = getSetupCallback(self);
        if (isFunction(setupCallback)) {
          setupCallback.call(self, self);
        }
      }
      render() {
        render(this);
      }
      focus(skipFocus) {
        this.execCommand('mceFocus', false, skipFocus);
      }
      hasFocus() {
        return hasFocus(this);
      }
      translate(text) {
        return I18n.translate(text);
      }
      getParam(name, defaultVal, type) {
        const options = this.options;
        if (!options.isRegistered(name)) {
          if (isNonNullable(type)) {
            options.register(name, {
              processor: type,
              default: defaultVal
            });
          } else {
            options.register(name, {
              processor: always,
              default: defaultVal
            });
          }
        }
        return !options.isSet(name) && !isUndefined(defaultVal) ? defaultVal : options.get(name);
      }
      hasPlugin(name, loaded) {
        const hasPlugin = contains$2(getPlugins(this), name);
        if (hasPlugin) {
          return loaded ? PluginManager.get(name) !== undefined : true;
        } else {
          return false;
        }
      }
      nodeChanged(args) {
        this._nodeChangeDispatcher.nodeChanged(args);
      }
      addCommand(name, callback, scope) {
        this.editorCommands.addCommand(name, callback, scope);
      }
      addQueryStateHandler(name, callback, scope) {
        this.editorCommands.addQueryStateHandler(name, callback, scope);
      }
      addQueryValueHandler(name, callback, scope) {
        this.editorCommands.addQueryValueHandler(name, callback, scope);
      }
      addShortcut(pattern, desc, cmdFunc, scope) {
        this.shortcuts.add(pattern, desc, cmdFunc, scope);
      }
      execCommand(cmd, ui, value, args) {
        return this.editorCommands.execCommand(cmd, ui, value, args);
      }
      queryCommandState(cmd) {
        return this.editorCommands.queryCommandState(cmd);
      }
      queryCommandValue(cmd) {
        return this.editorCommands.queryCommandValue(cmd);
      }
      queryCommandSupported(cmd) {
        return this.editorCommands.queryCommandSupported(cmd);
      }
      show() {
        const self = this;
        if (self.hidden) {
          self.hidden = false;
          if (self.inline) {
            self.getBody().contentEditable = 'true';
          } else {
            DOM$1.show(self.getContainer());
            DOM$1.hide(self.id);
          }
          self.load();
          self.dispatch('show');
        }
      }
      hide() {
        const self = this;
        if (!self.hidden) {
          self.save();
          if (self.inline) {
            self.getBody().contentEditable = 'false';
            if (self === self.editorManager.focusedEditor) {
              self.editorManager.focusedEditor = null;
            }
          } else {
            DOM$1.hide(self.getContainer());
            DOM$1.setStyle(self.id, 'display', self.orgDisplay);
          }
          self.hidden = true;
          self.dispatch('hide');
        }
      }
      isHidden() {
        return this.hidden;
      }
      setProgressState(state, time) {
        this.dispatch('ProgressState', {
          state,
          time
        });
      }
      load(args = {}) {
        const self = this;
        const elm = self.getElement();
        if (self.removed) {
          return '';
        }
        if (elm) {
          const loadArgs = {
            ...args,
            load: true
          };
          const value = isTextareaOrInput(elm) ? elm.value : elm.innerHTML;
          const html = self.setContent(value, loadArgs);
          if (!loadArgs.no_events) {
            self.dispatch('LoadContent', {
              ...loadArgs,
              element: elm
            });
          }
          return html;
        } else {
          return '';
        }
      }
      save(args = {}) {
        const self = this;
        let elm = self.getElement();
        if (!elm || !self.initialized || self.removed) {
          return '';
        }
        const getArgs = {
          ...args,
          save: true,
          element: elm
        };
        let html = self.getContent(getArgs);
        const saveArgs = {
          ...getArgs,
          content: html
        };
        if (!saveArgs.no_events) {
          self.dispatch('SaveContent', saveArgs);
        }
        if (saveArgs.format === 'raw') {
          self.dispatch('RawSaveContent', saveArgs);
        }
        html = saveArgs.content;
        if (!isTextareaOrInput(elm)) {
          if (args.is_removing || !self.inline) {
            elm.innerHTML = html;
          }
          const form = DOM$1.getParent(self.id, 'form');
          if (form) {
            each$1(form.elements, elm => {
              if (elm.name === self.id) {
                elm.value = html;
                return false;
              } else {
                return true;
              }
            });
          }
        } else {
          elm.value = html;
        }
        saveArgs.element = getArgs.element = elm = null;
        if (saveArgs.set_dirty !== false) {
          self.setDirty(false);
        }
        return html;
      }
      setContent(content, args) {
        return setContent(this, content, args);
      }
      getContent(args) {
        return getContent(this, args);
      }
      insertContent(content, args) {
        if (args) {
          content = extend({ content }, args);
        }
        this.execCommand('mceInsertContent', false, content);
      }
      resetContent(initialContent) {
        if (initialContent === undefined) {
          setContent(this, this.startContent, { format: 'raw' });
        } else {
          setContent(this, initialContent);
        }
        this.undoManager.reset();
        this.setDirty(false);
        this.nodeChanged();
      }
      isDirty() {
        return !this.isNotDirty;
      }
      setDirty(state) {
        const oldState = !this.isNotDirty;
        this.isNotDirty = !state;
        if (state && state !== oldState) {
          this.dispatch('dirty');
        }
      }
      getContainer() {
        const self = this;
        if (!self.container) {
          self.container = self.editorContainer || DOM$1.get(self.id + '_parent');
        }
        return self.container;
      }
      getContentAreaContainer() {
        return this.contentAreaContainer;
      }
      getElement() {
        if (!this.targetElm) {
          this.targetElm = DOM$1.get(this.id);
        }
        return this.targetElm;
      }
      getWin() {
        const self = this;
        if (!self.contentWindow) {
          const elm = self.iframeElement;
          if (elm) {
            self.contentWindow = elm.contentWindow;
          }
        }
        return self.contentWindow;
      }
      getDoc() {
        const self = this;
        if (!self.contentDocument) {
          const win = self.getWin();
          if (win) {
            self.contentDocument = win.document;
          }
        }
        return self.contentDocument;
      }
      getBody() {
        var _a, _b;
        const doc = this.getDoc();
        return (_b = (_a = this.bodyElement) !== null && _a !== void 0 ? _a : doc === null || doc === void 0 ? void 0 : doc.body) !== null && _b !== void 0 ? _b : null;
      }
      convertURL(url, name, elm) {
        const self = this, getOption = self.options.get;
        const urlConverterCallback = getUrlConverterCallback(self);
        if (isFunction(urlConverterCallback)) {
          return urlConverterCallback.call(self, url, elm, true, name);
        }
        if (!getOption('convert_urls') || elm === 'link' || isObject(elm) && elm.nodeName === 'LINK' || url.indexOf('file:') === 0 || url.length === 0) {
          return url;
        }
        if (getOption('relative_urls')) {
          return self.documentBaseURI.toRelative(url);
        }
        url = self.documentBaseURI.toAbsolute(url, getOption('remove_script_host'));
        return url;
      }
      addVisual(elm) {
        addVisual(this, elm);
      }
      remove() {
        remove$1(this);
      }
      destroy(automatic) {
        destroy(this, automatic);
      }
      uploadImages() {
        return this.editorUpload.uploadImages();
      }
      _scanForImages() {
        return this.editorUpload.scanForImages();
      }
    }

    const DOM = DOMUtils.DOM;
    const each = Tools.each;
    let boundGlobalEvents = false;
    let beforeUnloadDelegate;
    let editors = [];
    const globalEventDelegate = e => {
      const type = e.type;
      each(EditorManager.get(), editor => {
        switch (type) {
        case 'scroll':
          editor.dispatch('ScrollWindow', e);
          break;
        case 'resize':
          editor.dispatch('ResizeWindow', e);
          break;
        }
      });
    };
    const toggleGlobalEvents = state => {
      if (state !== boundGlobalEvents) {
        const DOM = DOMUtils.DOM;
        if (state) {
          DOM.bind(window, 'resize', globalEventDelegate);
          DOM.bind(window, 'scroll', globalEventDelegate);
        } else {
          DOM.unbind(window, 'resize', globalEventDelegate);
          DOM.unbind(window, 'scroll', globalEventDelegate);
        }
        boundGlobalEvents = state;
      }
    };
    const removeEditorFromList = targetEditor => {
      const oldEditors = editors;
      editors = filter$5(editors, editor => {
        return targetEditor !== editor;
      });
      if (EditorManager.activeEditor === targetEditor) {
        EditorManager.activeEditor = editors.length > 0 ? editors[0] : null;
      }
      if (EditorManager.focusedEditor === targetEditor) {
        EditorManager.focusedEditor = null;
      }
      return oldEditors.length !== editors.length;
    };
    const purgeDestroyedEditor = editor => {
      if (editor && editor.initialized && !(editor.getContainer() || editor.getBody()).parentNode) {
        removeEditorFromList(editor);
        editor.unbindAllNativeEvents();
        editor.destroy(true);
        editor.removed = true;
      }
    };
    const isQuirksMode = document.compatMode !== 'CSS1Compat';
    const EditorManager = {
      ...Observable,
      baseURI: null,
      baseURL: null,
      defaultOptions: {},
      documentBaseURL: null,
      suffix: null,
      majorVersion: '6',
      minorVersion: '4.2',
      releaseDate: '2023-04-26',
      i18n: I18n,
      activeEditor: null,
      focusedEditor: null,
      setup() {
        const self = this;
        let baseURL = '';
        let suffix = '';
        let documentBaseURL = URI.getDocumentBaseUrl(document.location);
        if (/^[^:]+:\/\/\/?[^\/]+\//.test(documentBaseURL)) {
          documentBaseURL = documentBaseURL.replace(/[\?#].*$/, '').replace(/[\/\\][^\/]+$/, '');
          if (!/[\/\\]$/.test(documentBaseURL)) {
            documentBaseURL += '/';
          }
        }
        const preInit = window.tinymce || window.tinyMCEPreInit;
        if (preInit) {
          baseURL = preInit.base || preInit.baseURL;
          suffix = preInit.suffix;
        } else {
          const scripts = document.getElementsByTagName('script');
          for (let i = 0; i < scripts.length; i++) {
            const src = scripts[i].src || '';
            if (src === '') {
              continue;
            }
            const srcScript = src.substring(src.lastIndexOf('/'));
            if (/tinymce(\.full|\.jquery|)(\.min|\.dev|)\.js/.test(src)) {
              if (srcScript.indexOf('.min') !== -1) {
                suffix = '.min';
              }
              baseURL = src.substring(0, src.lastIndexOf('/'));
              break;
            }
          }
          if (!baseURL && document.currentScript) {
            const src = document.currentScript.src;
            if (src.indexOf('.min') !== -1) {
              suffix = '.min';
            }
            baseURL = src.substring(0, src.lastIndexOf('/'));
          }
        }
        self.baseURL = new URI(documentBaseURL).toAbsolute(baseURL);
        self.documentBaseURL = documentBaseURL;
        self.baseURI = new URI(self.baseURL);
        self.suffix = suffix;
        setup$v(self);
      },
      overrideDefaults(defaultOptions) {
        const baseUrl = defaultOptions.base_url;
        if (baseUrl) {
          this._setBaseUrl(baseUrl);
        }
        const suffix = defaultOptions.suffix;
        if (suffix) {
          this.suffix = suffix;
        }
        this.defaultOptions = defaultOptions;
        const pluginBaseUrls = defaultOptions.plugin_base_urls;
        if (pluginBaseUrls !== undefined) {
          each$d(pluginBaseUrls, (pluginBaseUrl, pluginName) => {
            AddOnManager.PluginManager.urls[pluginName] = pluginBaseUrl;
          });
        }
      },
      init(options) {
        const self = this;
        let result;
        const invalidInlineTargets = Tools.makeMap('area base basefont br col frame hr img input isindex link meta param embed source wbr track ' + 'colgroup option table tbody tfoot thead tr th td script noscript style textarea video audio iframe object menu', ' ');
        const isInvalidInlineTarget = (options, elm) => options.inline && elm.tagName.toLowerCase() in invalidInlineTargets;
        const createId = elm => {
          let id = elm.id;
          if (!id) {
            id = get$a(elm, 'name').filter(name => !DOM.get(name)).getOrThunk(DOM.uniqueId);
            elm.setAttribute('id', id);
          }
          return id;
        };
        const execCallback = name => {
          const callback = options[name];
          if (!callback) {
            return;
          }
          return callback.apply(self, []);
        };
        const findTargets = options => {
          if (Env.browser.isIE() || Env.browser.isEdge()) {
            initError('TinyMCE does not support the browser you are using. For a list of supported' + ' browsers please see: https://www.tiny.cloud/docs/tinymce/6/support/#supportedwebbrowsers');
            return [];
          } else if (isQuirksMode) {
            initError('Failed to initialize the editor as the document is not in standards mode. ' + 'TinyMCE requires standards mode.');
            return [];
          } else if (isString(options.selector)) {
            return DOM.select(options.selector);
          } else if (isNonNullable(options.target)) {
            return [options.target];
          } else {
            return [];
          }
        };
        let provideResults = editors => {
          result = editors;
        };
        const initEditors = () => {
          let initCount = 0;
          const editors = [];
          let targets;
          const createEditor = (id, options, targetElm) => {
            const editor = new Editor(id, options, self);
            editors.push(editor);
            editor.on('init', () => {
              if (++initCount === targets.length) {
                provideResults(editors);
              }
            });
            editor.targetElm = editor.targetElm || targetElm;
            editor.render();
          };
          DOM.unbind(window, 'ready', initEditors);
          execCallback('onpageload');
          targets = unique$1(findTargets(options));
          Tools.each(targets, elm => {
            purgeDestroyedEditor(self.get(elm.id));
          });
          targets = Tools.grep(targets, elm => {
            return !self.get(elm.id);
          });
          if (targets.length === 0) {
            provideResults([]);
          } else {
            each(targets, elm => {
              if (isInvalidInlineTarget(options, elm)) {
                initError('Could not initialize inline editor on invalid inline target element', elm);
              } else {
                createEditor(createId(elm), options, elm);
              }
            });
          }
        };
        DOM.bind(window, 'ready', initEditors);
        return new Promise(resolve => {
          if (result) {
            resolve(result);
          } else {
            provideResults = editors => {
              resolve(editors);
            };
          }
        });
      },
      get(id) {
        if (arguments.length === 0) {
          return editors.slice(0);
        } else if (isString(id)) {
          return find$2(editors, editor => {
            return editor.id === id;
          }).getOr(null);
        } else if (isNumber(id)) {
          return editors[id] ? editors[id] : null;
        } else {
          return null;
        }
      },
      add(editor) {
        const self = this;
        const existingEditor = self.get(editor.id);
        if (existingEditor === editor) {
          return editor;
        }
        if (existingEditor === null) {
          editors.push(editor);
        }
        toggleGlobalEvents(true);
        self.activeEditor = editor;
        self.dispatch('AddEditor', { editor });
        if (!beforeUnloadDelegate) {
          beforeUnloadDelegate = e => {
            const event = self.dispatch('BeforeUnload');
            if (event.returnValue) {
              e.preventDefault();
              e.returnValue = event.returnValue;
              return event.returnValue;
            }
          };
          window.addEventListener('beforeunload', beforeUnloadDelegate);
        }
        return editor;
      },
      createEditor(id, options) {
        return this.add(new Editor(id, options, this));
      },
      remove(selector) {
        const self = this;
        let editor;
        if (!selector) {
          for (let i = editors.length - 1; i >= 0; i--) {
            self.remove(editors[i]);
          }
          return;
        }
        if (isString(selector)) {
          each(DOM.select(selector), elm => {
            editor = self.get(elm.id);
            if (editor) {
              self.remove(editor);
            }
          });
          return;
        }
        editor = selector;
        if (isNull(self.get(editor.id))) {
          return null;
        }
        if (removeEditorFromList(editor)) {
          self.dispatch('RemoveEditor', { editor });
        }
        if (editors.length === 0) {
          window.removeEventListener('beforeunload', beforeUnloadDelegate);
        }
        editor.remove();
        toggleGlobalEvents(editors.length > 0);
        return editor;
      },
      execCommand(cmd, ui, value) {
        var _a;
        const self = this;
        const editorId = isObject(value) ? (_a = value.id) !== null && _a !== void 0 ? _a : value.index : value;
        switch (cmd) {
        case 'mceAddEditor': {
            if (!self.get(editorId)) {
              const editorOptions = value.options;
              new Editor(editorId, editorOptions, self).render();
            }
            return true;
          }
        case 'mceRemoveEditor': {
            const editor = self.get(editorId);
            if (editor) {
              editor.remove();
            }
            return true;
          }
        case 'mceToggleEditor': {
            const editor = self.get(editorId);
            if (!editor) {
              self.execCommand('mceAddEditor', false, value);
              return true;
            }
            if (editor.isHidden()) {
              editor.show();
            } else {
              editor.hide();
            }
            return true;
          }
        }
        if (self.activeEditor) {
          return self.activeEditor.execCommand(cmd, ui, value);
        }
        return false;
      },
      triggerSave: () => {
        each(editors, editor => {
          editor.save();
        });
      },
      addI18n: (code, items) => {
        I18n.add(code, items);
      },
      translate: text => {
        return I18n.translate(text);
      },
      setActive(editor) {
        const activeEditor = this.activeEditor;
        if (this.activeEditor !== editor) {
          if (activeEditor) {
            activeEditor.dispatch('deactivate', { relatedTarget: editor });
          }
          editor.dispatch('activate', { relatedTarget: activeEditor });
        }
        this.activeEditor = editor;
      },
      _setBaseUrl(baseUrl) {
        this.baseURL = new URI(this.documentBaseURL).toAbsolute(baseUrl.replace(/\/+$/, ''));
        this.baseURI = new URI(this.baseURL);
      }
    };
    EditorManager.setup();

    const setup = () => {
      const dataValue = value$2();
      const FakeClipboardItem = items => ({
        items,
        types: keys(items),
        getType: type => get$a(items, type).getOrUndefined()
      });
      const write = data => {
        dataValue.set(data);
      };
      const read = () => dataValue.get().getOrUndefined();
      const clear = dataValue.clear;
      return {
        FakeClipboardItem,
        write,
        read,
        clear
      };
    };
    const FakeClipboard = setup();

    const min = Math.min, max = Math.max, round = Math.round;
    const relativePosition = (rect, targetRect, rel) => {
      let x = targetRect.x;
      let y = targetRect.y;
      const w = rect.w;
      const h = rect.h;
      const targetW = targetRect.w;
      const targetH = targetRect.h;
      const relChars = (rel || '').split('');
      if (relChars[0] === 'b') {
        y += targetH;
      }
      if (relChars[1] === 'r') {
        x += targetW;
      }
      if (relChars[0] === 'c') {
        y += round(targetH / 2);
      }
      if (relChars[1] === 'c') {
        x += round(targetW / 2);
      }
      if (relChars[3] === 'b') {
        y -= h;
      }
      if (relChars[4] === 'r') {
        x -= w;
      }
      if (relChars[3] === 'c') {
        y -= round(h / 2);
      }
      if (relChars[4] === 'c') {
        x -= round(w / 2);
      }
      return create$2(x, y, w, h);
    };
    const findBestRelativePosition = (rect, targetRect, constrainRect, rels) => {
      for (let i = 0; i < rels.length; i++) {
        const pos = relativePosition(rect, targetRect, rels[i]);
        if (pos.x >= constrainRect.x && pos.x + pos.w <= constrainRect.w + constrainRect.x && pos.y >= constrainRect.y && pos.y + pos.h <= constrainRect.h + constrainRect.y) {
          return rels[i];
        }
      }
      return null;
    };
    const inflate = (rect, w, h) => {
      return create$2(rect.x - w, rect.y - h, rect.w + w * 2, rect.h + h * 2);
    };
    const intersect = (rect, cropRect) => {
      const x1 = max(rect.x, cropRect.x);
      const y1 = max(rect.y, cropRect.y);
      const x2 = min(rect.x + rect.w, cropRect.x + cropRect.w);
      const y2 = min(rect.y + rect.h, cropRect.y + cropRect.h);
      if (x2 - x1 < 0 || y2 - y1 < 0) {
        return null;
      }
      return create$2(x1, y1, x2 - x1, y2 - y1);
    };
    const clamp = (rect, clampRect, fixedSize) => {
      let x1 = rect.x;
      let y1 = rect.y;
      let x2 = rect.x + rect.w;
      let y2 = rect.y + rect.h;
      const cx2 = clampRect.x + clampRect.w;
      const cy2 = clampRect.y + clampRect.h;
      const underflowX1 = max(0, clampRect.x - x1);
      const underflowY1 = max(0, clampRect.y - y1);
      const overflowX2 = max(0, x2 - cx2);
      const overflowY2 = max(0, y2 - cy2);
      x1 += underflowX1;
      y1 += underflowY1;
      if (fixedSize) {
        x2 += underflowX1;
        y2 += underflowY1;
        x1 -= overflowX2;
        y1 -= overflowY2;
      }
      x2 -= overflowX2;
      y2 -= overflowY2;
      return create$2(x1, y1, x2 - x1, y2 - y1);
    };
    const create$2 = (x, y, w, h) => {
      return {
        x,
        y,
        w,
        h
      };
    };
    const fromClientRect = clientRect => {
      return create$2(clientRect.left, clientRect.top, clientRect.width, clientRect.height);
    };
    const Rect = {
      inflate,
      relativePosition,
      findBestRelativePosition,
      intersect,
      clamp,
      create: create$2,
      fromClientRect
    };

    const awaiter = (resolveCb, rejectCb, timeout = 1000) => {
      let done = false;
      let timer = null;
      const complete = completer => (...args) => {
        if (!done) {
          done = true;
          if (timer !== null) {
            clearTimeout(timer);
            timer = null;
          }
          completer.apply(null, args);
        }
      };
      const resolve = complete(resolveCb);
      const reject = complete(rejectCb);
      const start = (...args) => {
        if (!done && timer === null) {
          timer = setTimeout(() => reject.apply(null, args), timeout);
        }
      };
      return {
        start,
        resolve,
        reject
      };
    };
    const create$1 = () => {
      const tasks = {};
      const resultFns = {};
      const load = (id, url) => {
        const loadErrMsg = `Script at URL "${ url }" failed to load`;
        const runErrMsg = `Script at URL "${ url }" did not call \`tinymce.Resource.add('${ id }', data)\` within 1 second`;
        if (tasks[id] !== undefined) {
          return tasks[id];
        } else {
          const task = new Promise((resolve, reject) => {
            const waiter = awaiter(resolve, reject);
            resultFns[id] = waiter.resolve;
            ScriptLoader.ScriptLoader.loadScript(url).then(() => waiter.start(runErrMsg), () => waiter.reject(loadErrMsg));
          });
          tasks[id] = task;
          return task;
        }
      };
      const add = (id, data) => {
        if (resultFns[id] !== undefined) {
          resultFns[id](data);
          delete resultFns[id];
        }
        tasks[id] = Promise.resolve(data);
      };
      const unload = id => {
        delete tasks[id];
      };
      return {
        load,
        add,
        unload
      };
    };
    const Resource = create$1();

    const create = () => (() => {
      let data = {};
      let keys = [];
      const storage = {
        getItem: key => {
          const item = data[key];
          return item ? item : null;
        },
        setItem: (key, value) => {
          keys.push(key);
          data[key] = String(value);
        },
        key: index => {
          return keys[index];
        },
        removeItem: key => {
          keys = keys.filter(k => k === key);
          delete data[key];
        },
        clear: () => {
          keys = [];
          data = {};
        },
        length: 0
      };
      Object.defineProperty(storage, 'length', {
        get: () => keys.length,
        configurable: false,
        enumerable: false
      });
      return storage;
    })();

    let localStorage;
    try {
      const test = '__storage_test__';
      localStorage = window.localStorage;
      localStorage.setItem(test, test);
      localStorage.removeItem(test);
    } catch (e) {
      localStorage = create();
    }
    var LocalStorage = localStorage;

    const publicApi = {
      geom: { Rect },
      util: {
        Delay,
        Tools,
        VK,
        URI,
        EventDispatcher,
        Observable,
        I18n,
        LocalStorage,
        ImageUploader
      },
      dom: {
        EventUtils,
        TreeWalker: DomTreeWalker,
        TextSeeker,
        DOMUtils,
        ScriptLoader,
        RangeUtils,
        Serializer: DomSerializer,
        StyleSheetLoader,
        ControlSelection,
        BookmarkManager,
        Selection: EditorSelection,
        Event: EventUtils.Event
      },
      html: {
        Styles,
        Entities,
        Node: AstNode,
        Schema,
        DomParser,
        Writer,
        Serializer: HtmlSerializer
      },
      Env,
      AddOnManager,
      Annotator,
      Formatter,
      UndoManager,
      EditorCommands,
      WindowManager,
      NotificationManager,
      EditorObservable,
      Shortcuts,
      Editor,
      FocusManager,
      EditorManager,
      DOM: DOMUtils.DOM,
      ScriptLoader: ScriptLoader.ScriptLoader,
      PluginManager,
      ThemeManager,
      ModelManager,
      IconManager,
      Resource,
      FakeClipboard,
      trim: Tools.trim,
      isArray: Tools.isArray,
      is: Tools.is,
      toArray: Tools.toArray,
      makeMap: Tools.makeMap,
      each: Tools.each,
      map: Tools.map,
      grep: Tools.grep,
      inArray: Tools.inArray,
      extend: Tools.extend,
      walk: Tools.walk,
      resolve: Tools.resolve,
      explode: Tools.explode,
      _addCacheSuffix: Tools._addCacheSuffix
    };
    const tinymce = Tools.extend(EditorManager, publicApi);

    const exportToModuleLoaders = tinymce => {
      if (true) {
        try {
          module.exports = tinymce;
        } catch (_) {
        }
      }
    };
    const exportToWindowGlobal = tinymce => {
      window.tinymce = tinymce;
      window.tinyMCE = tinymce;
    };
    exportToWindowGlobal(tinymce);
    exportToModuleLoaders(tinymce);

})();


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfc3ltZm9ueV9zdGltdWx1cy1icmlkZ2VfZGlzdF9pbmRleF9qcy1ub2RlX21vZHVsZXNfY29yZS1qc19tb2R1bGVzX2VzX2RhLTA5ZmRlNi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyQkFBMkI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLHFEQUFxRCxRQUFRO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1Q0FBdUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUNBQXVDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNkJBQTZCLEVBQUUsSUFBSTtBQUM3RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFdBQVcsdUJBQXVCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCw4Q0FBOEMsS0FBSztBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsbUJBQW1CO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGVBQWU7QUFDaEUsdURBQXVELHFCQUFxQjtBQUM1RSxrQkFBa0IsZUFBZSxFQUFFLFlBQVksRUFBRSxZQUFZLElBQUksZ0JBQWdCLEdBQUcsZ0JBQWdCO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGVBQWU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxnQkFBZ0I7QUFDNUQscUJBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsWUFBWSxpQ0FBaUMsZ0JBQWdCO0FBQ2hHO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQixnQkFBZ0IsMEJBQTBCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDZCQUE2QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdCQUF3QjtBQUN4QztBQUNBLG9CQUFvQixTQUFTO0FBQzdCLHVEQUF1RCxRQUFRO0FBQy9EO0FBQ0EsNkRBQTZELHVEQUF1RDtBQUNwSDtBQUNBO0FBQ0Esb0JBQW9CLHlDQUF5QztBQUM3RCw2QkFBNkI7QUFDN0IsZ0VBQWdFLFlBQVk7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELDJDQUEyQztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHdDQUF3QztBQUM1RTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtDQUFrQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsS0FBSztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCx3QkFBd0IsR0FBRyxnQkFBZ0IsTUFBTSxjQUFjO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsNEJBQTRCO0FBQ2hFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0JBQXdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxZQUFZO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsWUFBWTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFlBQVk7QUFDaEQ7QUFDQSxnQ0FBZ0Msb0RBQW9ELElBQUksV0FBVztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRCxvQkFBb0Isa0NBQWtDO0FBQ3RELHFDQUFxQyxpQ0FBaUM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsZ0JBQWdCLGtDQUFrQztBQUNsRCxpQ0FBaUMsaUNBQWlDO0FBQ2xFLHFEQUFxRCxRQUFRO0FBQzdEO0FBQ0E7QUFDQSx1Q0FBdUMsS0FBSztBQUM1QztBQUNBO0FBQ0EsdUNBQXVDLEtBQUs7QUFDNUM7QUFDQTtBQUNBLHVDQUF1Qyx3QkFBd0I7QUFDL0Q7QUFDQTtBQUNBLHVDQUF1Qyx3QkFBd0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLG1CQUFtQjtBQUNqRTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixLQUFLO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCLEdBQUcsZUFBZTtBQUN6RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLGNBQWMsS0FBSyxNQUFNO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsZ0JBQWdCLEdBQUcsV0FBVztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQSwrQ0FBK0MsV0FBVyxxQkFBcUIsY0FBYyxJQUFJLFdBQVcsR0FBRyxXQUFXLFNBQVMscUJBQXFCLElBQUksV0FBVztBQUN2Syx1QkFBdUIsZUFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtCQUErQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxXQUFXO0FBQ2hFLDZEQUE2RCxXQUFXLEdBQUcsT0FBTztBQUNsRiwrQ0FBK0MsMkpBQTJKO0FBQzFNO0FBQ0E7QUFDQSx5RUFBeUUsV0FBVyxRQUFRLE1BQU07QUFDbEc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1DQUFtQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdELGlDQUFpQyxtQkFBbUI7QUFDcEQsc0NBQXNDLFlBQVksR0FBRyxhQUFhO0FBQ2xFLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUFJO0FBQ2hCO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxVQUFVO0FBQ3BFO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxZQUFZLElBQUk7QUFDaEI7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsS0FBSyxxQ0FBcUMsZ0JBQWdCO0FBQzlIO0FBQ0E7QUFDQSwyREFBMkQsS0FBSyxTQUFTLGdCQUFnQjtBQUN6RixhQUFhO0FBQ2IsU0FBUztBQUNULFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRyxLQUFLLFNBQVMsZ0JBQWdCO0FBQ3hJO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxLQUFLLFNBQVMsZ0JBQWdCO0FBQzdGO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsZUFBZSwwQkFBMEI7QUFDekM7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsS0FBSyxTQUFTLGdCQUFnQjtBQUM3RjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsWUFBWSxLQUFLO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxrQ0FBa0M7QUFDckYsaUJBQWlCLElBQUk7QUFDckIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5Q0FBeUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsbUJBQW1CLEdBQUcsY0FBYztBQUN6RiwrRUFBK0UsYUFBYSxpQ0FBaUMsZUFBZSxvQ0FBb0MsMkJBQTJCLGdCQUFnQixpQkFBaUI7QUFDNU87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELG1CQUFtQixHQUFHLHVCQUF1QjtBQUM5RiwyQ0FBMkMsYUFBYSxTQUFTLGNBQWM7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUYsTUFBTSxhQUFhLDZCQUE2QjtBQUN6STtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsTUFBTSxhQUFhLDhCQUE4QjtBQUMzSTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0NBQWtDLGdFQUFnRSxJQUFJO0FBQ2hJLGlDQUFpQyxPQUFPLEdBQUcsVUFBVTtBQUNyRCw4Q0FBOEMsNkJBQTZCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU2Tjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdjJFNUs7QUFDMkM7O0FBRTVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLGlFQUFpQjtBQUN6QyxRQUFRLElBQXNDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0dBQWtCO0FBQ25ELGFBQWEsK0dBQWlDO0FBQzlDO0FBQ0E7QUFDQSw2Q0FBNkMsZ0dBQWtCO0FBQy9EO0FBQ0E7QUFDQTs7QUFFNEI7Ozs7Ozs7Ozs7O0FDaEQ1QixpQkFBaUIsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDbkQsa0JBQWtCLG1CQUFPLENBQUMscUZBQTRCOztBQUV0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1RBLG9CQUFvQixtQkFBTyxDQUFDLHVGQUE2QjtBQUN6RCxrQkFBa0IsbUJBQU8sQ0FBQyxxRkFBNEI7O0FBRXREOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDVEEsaUJBQWlCLG1CQUFPLENBQUMsaUZBQTBCOztBQUVuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1JBLHNCQUFzQixtQkFBTyxDQUFDLDZGQUFnQztBQUM5RCxhQUFhLG1CQUFPLENBQUMscUZBQTRCO0FBQ2pELHFCQUFxQixnSUFBZ0Q7O0FBRXJFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ25CQSxlQUFlLG1CQUFPLENBQUMsNkVBQXdCOztBQUUvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDVEEsc0JBQXNCLG1CQUFPLENBQUMsNkZBQWdDO0FBQzlELHNCQUFzQixtQkFBTyxDQUFDLDZGQUFnQztBQUM5RCx3QkFBd0IsbUJBQU8sQ0FBQyxtR0FBbUM7O0FBRW5FLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFdBQVcsZ0JBQWdCO0FBQ2pDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMvQkEsV0FBVyxtQkFBTyxDQUFDLHFHQUFvQztBQUN2RCxrQkFBa0IsbUJBQU8sQ0FBQyxxR0FBb0M7QUFDOUQsb0JBQW9CLG1CQUFPLENBQUMsdUZBQTZCO0FBQ3pELGVBQWUsbUJBQU8sQ0FBQyw2RUFBd0I7QUFDL0Msd0JBQXdCLG1CQUFPLENBQUMsbUdBQW1DO0FBQ25FLHlCQUF5QixtQkFBTyxDQUFDLG1HQUFtQzs7QUFFcEU7O0FBRUEsc0JBQXNCLGtFQUFrRTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EsNENBQTRDO0FBQzVDLDRDQUE0QztBQUM1Qyw0Q0FBNEM7QUFDNUMsNENBQTRDO0FBQzVDLFVBQVU7QUFDViw0Q0FBNEM7QUFDNUMsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3hFQSxzQkFBc0IsbUJBQU8sQ0FBQyw2RkFBZ0M7QUFDOUQsd0JBQXdCLG1CQUFPLENBQUMsbUdBQW1DO0FBQ25FLHFCQUFxQixtQkFBTyxDQUFDLHlGQUE4Qjs7QUFFM0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2ZBLGtCQUFrQixtQkFBTyxDQUFDLHFHQUFvQzs7QUFFOUQ7Ozs7Ozs7Ozs7O0FDRkEsY0FBYyxtQkFBTyxDQUFDLDJFQUF1QjtBQUM3QyxvQkFBb0IsbUJBQU8sQ0FBQyx1RkFBNkI7QUFDekQsZUFBZSxtQkFBTyxDQUFDLDZFQUF3QjtBQUMvQyxzQkFBc0IsbUJBQU8sQ0FBQyw2RkFBZ0M7O0FBRTlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7Ozs7Ozs7OztBQ3JCQSw4QkFBOEIsbUJBQU8sQ0FBQyw2R0FBd0M7O0FBRTlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDTkEsa0JBQWtCLG1CQUFPLENBQUMscUdBQW9DOztBQUU5RCw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1BBLDRCQUE0QixtQkFBTyxDQUFDLHFHQUFvQztBQUN4RSxpQkFBaUIsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDbkQsaUJBQWlCLG1CQUFPLENBQUMsaUZBQTBCO0FBQ25ELHNCQUFzQixtQkFBTyxDQUFDLDZGQUFnQzs7QUFFOUQ7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRCxtQkFBbUI7O0FBRXBFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQkFBZ0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM1QkEsYUFBYSxtQkFBTyxDQUFDLDJGQUErQjtBQUNwRCxjQUFjLG1CQUFPLENBQUMsMkVBQXVCO0FBQzdDLHFDQUFxQyxtQkFBTyxDQUFDLCtIQUFpRDtBQUM5RiwyQkFBMkIsbUJBQU8sQ0FBQyx1R0FBcUM7O0FBRXhFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDZkEsWUFBWSxtQkFBTyxDQUFDLHFFQUFvQjs7QUFFeEM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7QUNQRDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7Ozs7Ozs7Ozs7O0FDSkEsa0JBQWtCLG1CQUFPLENBQUMsaUZBQTBCO0FBQ3BELDJCQUEyQixtQkFBTyxDQUFDLHVHQUFxQztBQUN4RSwrQkFBK0IsbUJBQU8sQ0FBQywrR0FBeUM7O0FBRWhGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ1BhO0FBQ2Isb0JBQW9CLG1CQUFPLENBQUMseUZBQThCO0FBQzFELDJCQUEyQixtQkFBTyxDQUFDLHVHQUFxQztBQUN4RSwrQkFBK0IsbUJBQU8sQ0FBQywrR0FBeUM7O0FBRWhGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ1RhO0FBQ2IsZUFBZSxtQkFBTyxDQUFDLDZFQUF3QjtBQUMvQywwQkFBMEIsbUJBQU8sQ0FBQyxxR0FBb0M7O0FBRXRFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDYkEsa0JBQWtCLG1CQUFPLENBQUMscUZBQTRCO0FBQ3RELHFCQUFxQixtQkFBTyxDQUFDLHVHQUFxQzs7QUFFbEU7QUFDQSwwREFBMEQsY0FBYztBQUN4RSwwREFBMEQsY0FBYztBQUN4RTtBQUNBOzs7Ozs7Ozs7OztBQ1BBLGlCQUFpQixtQkFBTyxDQUFDLGlGQUEwQjtBQUNuRCwyQkFBMkIsbUJBQU8sQ0FBQyx1R0FBcUM7QUFDeEUsa0JBQWtCLG1CQUFPLENBQUMscUZBQTRCO0FBQ3RELDJCQUEyQixtQkFBTyxDQUFDLHVHQUFxQzs7QUFFeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNLGdCQUFnQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKOzs7Ozs7Ozs7OztBQzFCQSxhQUFhLG1CQUFPLENBQUMsdUVBQXFCOztBQUUxQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0Msa0RBQWtEO0FBQ3BGLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjs7Ozs7Ozs7Ozs7QUNYQSxZQUFZLG1CQUFPLENBQUMscUVBQW9COztBQUV4QztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTyxtQkFBbUIsYUFBYTtBQUN4RSxDQUFDOzs7Ozs7Ozs7OztBQ05EOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNUQSxhQUFhLG1CQUFPLENBQUMsdUVBQXFCO0FBQzFDLGVBQWUsbUJBQU8sQ0FBQyw2RUFBd0I7O0FBRS9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsQ0E7QUFDQSw0QkFBNEIsbUJBQU8sQ0FBQyx5R0FBc0M7O0FBRTFFO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7O0FDTkE7Ozs7Ozs7Ozs7O0FDQUEsYUFBYSxtQkFBTyxDQUFDLHVFQUFxQjtBQUMxQyxnQkFBZ0IsbUJBQU8sQ0FBQyw2RkFBZ0M7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDVEEsa0JBQWtCLG1CQUFPLENBQUMscUdBQW9DOztBQUU5RDtBQUNBOztBQUVBLDZCQUE2QixtQ0FBbUM7QUFDaEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7Ozs7Ozs7Ozs7QUNkQSxrQ0FBa0MsbUJBQU8sQ0FBQyx1SEFBNkM7QUFDdkYsc0JBQXNCLG1CQUFPLENBQUMsNkZBQWdDO0FBQzlELDhCQUE4QixtQkFBTyxDQUFDLHlHQUFzQzs7QUFFNUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDWkEsWUFBWSxtQkFBTyxDQUFDLHFFQUFvQjtBQUN4QywrQkFBK0IsbUJBQU8sQ0FBQywrR0FBeUM7O0FBRWhGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7OztBQ1RZO0FBQ2Isa0JBQWtCLG1CQUFPLENBQUMsaUZBQTBCO0FBQ3BELFlBQVksbUJBQU8sQ0FBQyxxRUFBb0I7QUFDeEMsZUFBZSxtQkFBTyxDQUFDLDZFQUF3QjtBQUMvQyxhQUFhLG1CQUFPLENBQUMscUZBQTRCO0FBQ2pELDhCQUE4QixtQkFBTyxDQUFDLDZHQUF3Qzs7QUFFOUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MscUJBQXFCO0FBQ3pEO0FBQ0Esa0NBQWtDO0FBQ2xDLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7Ozs7Ozs7Ozs7O0FDN0JGLGFBQWEsbUJBQU8sQ0FBQyx1RUFBcUI7QUFDMUMsK0JBQStCLHdKQUE0RDtBQUMzRixrQ0FBa0MsbUJBQU8sQ0FBQyx1SEFBNkM7QUFDdkYsb0JBQW9CLG1CQUFPLENBQUMseUZBQThCO0FBQzFELDJCQUEyQixtQkFBTyxDQUFDLHVHQUFxQztBQUN4RSxnQ0FBZ0MsbUJBQU8sQ0FBQyxpSEFBMEM7QUFDbEYsZUFBZSxtQkFBTyxDQUFDLDZFQUF3Qjs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osOERBQThEO0FBQzlELElBQUk7QUFDSixrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JEQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ05BLGtCQUFrQixtQkFBTyxDQUFDLG1HQUFtQzs7QUFFN0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7O0FDVEQsa0JBQWtCLG1CQUFPLENBQUMsbUhBQTJDO0FBQ3JFLGdCQUFnQixtQkFBTyxDQUFDLCtFQUF5QjtBQUNqRCxrQkFBa0IsbUJBQU8sQ0FBQyxtR0FBbUM7O0FBRTdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1pBLFlBQVksbUJBQU8sQ0FBQyxxRUFBb0I7O0FBRXhDO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7O0FDUFk7QUFDYixrQkFBa0IsbUJBQU8sQ0FBQyxxR0FBb0M7QUFDOUQsZ0JBQWdCLG1CQUFPLENBQUMsK0VBQXlCO0FBQ2pELGVBQWUsbUJBQU8sQ0FBQyw2RUFBd0I7QUFDL0MsYUFBYSxtQkFBTyxDQUFDLDJGQUErQjtBQUNwRCxpQkFBaUIsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDbkQsa0JBQWtCLG1CQUFPLENBQUMsbUdBQW1DOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLGdCQUFnQjtBQUMvQztBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pDQSxrQkFBa0IsbUJBQU8sQ0FBQyxtR0FBbUM7O0FBRTdEOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNOQSxrQkFBa0IsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDcEQsYUFBYSxtQkFBTyxDQUFDLDJGQUErQjs7QUFFcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MsYUFBYTtBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2hCQSxrQkFBa0IsbUJBQU8sQ0FBQyxxR0FBb0M7QUFDOUQsZ0JBQWdCLG1CQUFPLENBQUMsK0VBQXlCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0JBQWdCO0FBQ3BCOzs7Ozs7Ozs7OztBQ1JBLGlCQUFpQixtQkFBTyxDQUFDLGlGQUEwQjtBQUNuRCxrQkFBa0IsbUJBQU8sQ0FBQyxxR0FBb0M7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNSQSxrQkFBa0IsbUJBQU8sQ0FBQyxtR0FBbUM7O0FBRTdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1ZBLGFBQWEsbUJBQU8sQ0FBQyx1RUFBcUI7QUFDMUMsaUJBQWlCLG1CQUFPLENBQUMsaUZBQTBCOztBQUVuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1RBLGtCQUFrQixtQkFBTyxDQUFDLHFHQUFvQztBQUM5RCxjQUFjLG1CQUFPLENBQUMsMkVBQXVCO0FBQzdDLGlCQUFpQixtQkFBTyxDQUFDLGlGQUEwQjtBQUNuRCxjQUFjLG1CQUFPLENBQUMsaUZBQTBCO0FBQ2hELGVBQWUsbUJBQU8sQ0FBQyw2RUFBd0I7O0FBRS9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUJBLGdCQUFnQixtQkFBTyxDQUFDLCtFQUF5QjtBQUNqRCx3QkFBd0IsbUJBQU8sQ0FBQyxtR0FBbUM7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFCQUFNLGdCQUFnQixxQkFBTTtBQUMzQztBQUNBLGlCQUFpQixjQUFjOzs7Ozs7Ozs7OztBQ2IvQixrQkFBa0IsbUJBQU8sQ0FBQyxxR0FBb0M7QUFDOUQsZUFBZSxtQkFBTyxDQUFDLDZFQUF3Qjs7QUFFL0MsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDVkE7Ozs7Ozs7Ozs7O0FDQUEsaUJBQWlCLG1CQUFPLENBQUMsbUZBQTJCOztBQUVwRDs7Ozs7Ozs7Ozs7QUNGQSxrQkFBa0IsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDcEQsWUFBWSxtQkFBTyxDQUFDLHFFQUFvQjtBQUN4QyxvQkFBb0IsbUJBQU8sQ0FBQyx5R0FBc0M7O0FBRWxFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLEdBQUc7QUFDSCxDQUFDOzs7Ozs7Ozs7OztBQ1ZELGtCQUFrQixtQkFBTyxDQUFDLHFHQUFvQztBQUM5RCxZQUFZLG1CQUFPLENBQUMscUVBQW9CO0FBQ3hDLGNBQWMsbUJBQU8sQ0FBQyxpRkFBMEI7O0FBRWhEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLEVBQUU7Ozs7Ozs7Ozs7O0FDZEYsaUJBQWlCLG1CQUFPLENBQUMsaUZBQTBCO0FBQ25ELGVBQWUsbUJBQU8sQ0FBQyw2RUFBd0I7QUFDL0MscUJBQXFCLG1CQUFPLENBQUMseUdBQXNDOztBQUVuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pCQSxrQkFBa0IsbUJBQU8sQ0FBQyxxR0FBb0M7QUFDOUQsaUJBQWlCLG1CQUFPLENBQUMsaUZBQTBCO0FBQ25ELFlBQVksbUJBQU8sQ0FBQyxtRkFBMkI7O0FBRS9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7QUNiQSxlQUFlLG1CQUFPLENBQUMsNkVBQXdCO0FBQy9DLGtDQUFrQyxtQkFBTyxDQUFDLHVIQUE2Qzs7QUFFdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDVEEsc0JBQXNCLG1CQUFPLENBQUMsMkdBQXVDO0FBQ3JFLGFBQWEsbUJBQU8sQ0FBQyx1RUFBcUI7QUFDMUMsZUFBZSxtQkFBTyxDQUFDLDZFQUF3QjtBQUMvQyxrQ0FBa0MsbUJBQU8sQ0FBQyx1SEFBNkM7QUFDdkYsYUFBYSxtQkFBTyxDQUFDLDJGQUErQjtBQUNwRCxhQUFhLG1CQUFPLENBQUMsbUZBQTJCO0FBQ2hELGdCQUFnQixtQkFBTyxDQUFDLCtFQUF5QjtBQUNqRCxpQkFBaUIsbUJBQU8sQ0FBQyxpRkFBMEI7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckVBLGNBQWMsbUJBQU8sQ0FBQyxpRkFBMEI7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNQQSxtQkFBbUIsbUJBQU8sQ0FBQyxtRkFBMkI7O0FBRXREOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7Ozs7Ozs7Ozs7O0FDVkEsa0JBQWtCLG1CQUFPLENBQUMscUdBQW9DO0FBQzlELFlBQVksbUJBQU8sQ0FBQyxxRUFBb0I7QUFDeEMsaUJBQWlCLG1CQUFPLENBQUMsaUZBQTBCO0FBQ25ELGNBQWMsbUJBQU8sQ0FBQyx5RUFBc0I7QUFDNUMsaUJBQWlCLG1CQUFPLENBQUMsbUZBQTJCO0FBQ3BELG9CQUFvQixtQkFBTyxDQUFDLHVGQUE2Qjs7QUFFekQseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsZ0JBQWdCO0FBQzFEO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7QUNuREQsWUFBWSxtQkFBTyxDQUFDLHFFQUFvQjtBQUN4QyxpQkFBaUIsbUJBQU8sQ0FBQyxpRkFBMEI7O0FBRW5EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDSkEsaUJBQWlCLG1CQUFPLENBQUMsaUZBQTBCO0FBQ25ELG1CQUFtQixtQkFBTyxDQUFDLG1GQUEyQjs7QUFFdEQ7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOzs7Ozs7Ozs7OztBQ1RBOzs7Ozs7Ozs7OztBQ0FBLGlCQUFpQixtQkFBTyxDQUFDLG1GQUEyQjtBQUNwRCxpQkFBaUIsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDbkQsb0JBQW9CLG1CQUFPLENBQUMsdUdBQXFDO0FBQ2pFLHdCQUF3QixtQkFBTyxDQUFDLDZGQUFnQzs7QUFFaEU7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ1phO0FBQ2Isd0JBQXdCLGdJQUF3RDtBQUNoRixhQUFhLG1CQUFPLENBQUMscUZBQTRCO0FBQ2pELCtCQUErQixtQkFBTyxDQUFDLCtHQUF5QztBQUNoRixxQkFBcUIsbUJBQU8sQ0FBQyw2RkFBZ0M7QUFDN0QsZ0JBQWdCLG1CQUFPLENBQUMsNkVBQXdCOztBQUVoRCwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQSw4REFBOEQseURBQXlEO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNmYTtBQUNiLFFBQVEsbUJBQU8sQ0FBQyx1RUFBcUI7QUFDckMsV0FBVyxtQkFBTyxDQUFDLHFGQUE0QjtBQUMvQyxjQUFjLG1CQUFPLENBQUMseUVBQXNCO0FBQzVDLG1CQUFtQixtQkFBTyxDQUFDLHFGQUE0QjtBQUN2RCxpQkFBaUIsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDbkQsZ0NBQWdDLG1CQUFPLENBQUMsaUhBQTBDO0FBQ2xGLHFCQUFxQixtQkFBTyxDQUFDLHlHQUFzQztBQUNuRSxxQkFBcUIsbUJBQU8sQ0FBQyx5R0FBc0M7QUFDbkUscUJBQXFCLG1CQUFPLENBQUMsNkZBQWdDO0FBQzdELGtDQUFrQyxtQkFBTyxDQUFDLHVIQUE2QztBQUN2RixvQkFBb0IsbUJBQU8sQ0FBQyx5RkFBOEI7QUFDMUQsc0JBQXNCLG1CQUFPLENBQUMsNkZBQWdDO0FBQzlELGdCQUFnQixtQkFBTyxDQUFDLDZFQUF3QjtBQUNoRCxvQkFBb0IsbUJBQU8sQ0FBQyx1RkFBNkI7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCOztBQUUvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLDhDQUE4QztBQUM5QyxnREFBZ0Q7QUFDaEQsTUFBTSxxQkFBcUI7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLG9CQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxTQUFTLG9GQUFvRjtBQUNuRzs7QUFFQTtBQUNBO0FBQ0Esa0VBQWtFLGVBQWU7QUFDakY7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNsR2E7QUFDYixZQUFZLG1CQUFPLENBQUMscUVBQW9CO0FBQ3hDLGlCQUFpQixtQkFBTyxDQUFDLGlGQUEwQjtBQUNuRCxlQUFlLG1CQUFPLENBQUMsNkVBQXdCO0FBQy9DLGFBQWEsbUJBQU8sQ0FBQyxxRkFBNEI7QUFDakQscUJBQXFCLG1CQUFPLENBQUMseUdBQXNDO0FBQ25FLG9CQUFvQixtQkFBTyxDQUFDLHlGQUE4QjtBQUMxRCxzQkFBc0IsbUJBQU8sQ0FBQyw2RkFBZ0M7QUFDOUQsY0FBYyxtQkFBTyxDQUFDLHlFQUFzQjs7QUFFNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoREE7Ozs7Ozs7Ozs7O0FDQUEsZUFBZSxtQkFBTyxDQUFDLDZFQUF3Qjs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNOQSxrQkFBa0IsbUJBQU8sQ0FBQyxxR0FBb0M7QUFDOUQsWUFBWSxtQkFBTyxDQUFDLHFFQUFvQjtBQUN4QyxpQkFBaUIsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDbkQsYUFBYSxtQkFBTyxDQUFDLDJGQUErQjtBQUNwRCxrQkFBa0IsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDcEQsaUNBQWlDLHlIQUFrRDtBQUNuRixvQkFBb0IsbUJBQU8sQ0FBQyx1RkFBNkI7QUFDekQsMEJBQTBCLG1CQUFPLENBQUMsdUZBQTZCOztBQUUvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDLGFBQWEsY0FBYyxVQUFVO0FBQzNFLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsaUNBQWlDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxzQkFBc0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGlCQUFpQjtBQUM3RTtBQUNBLE1BQU07QUFDTixJQUFJLGdCQUFnQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7OztBQ3JERDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1RBLGVBQWUsbUJBQU8sQ0FBQyw2RUFBd0I7O0FBRS9DO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDSmE7QUFDYixrQkFBa0IsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDcEQsa0JBQWtCLG1CQUFPLENBQUMscUdBQW9DO0FBQzlELFdBQVcsbUJBQU8sQ0FBQyxxRkFBNEI7QUFDL0MsWUFBWSxtQkFBTyxDQUFDLHFFQUFvQjtBQUN4QyxpQkFBaUIsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDbkQsa0NBQWtDLG1CQUFPLENBQUMseUhBQThDO0FBQ3hGLGlDQUFpQyxtQkFBTyxDQUFDLHFIQUE0QztBQUNyRixlQUFlLG1CQUFPLENBQUMsNkVBQXdCO0FBQy9DLG9CQUFvQixtQkFBTyxDQUFDLHVGQUE2Qjs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixNQUFNLDJCQUEyQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRyxLQUFLLE1BQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxlQUFlO0FBQzdELG1CQUFtQiwwQ0FBMEM7QUFDN0QsQ0FBQyxzQ0FBc0M7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7Ozs7Ozs7Ozs7O0FDeERGO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLDZFQUF3QjtBQUMvQyw2QkFBNkIsbUJBQU8sQ0FBQywyR0FBdUM7QUFDNUUsa0JBQWtCLG1CQUFPLENBQUMscUZBQTRCO0FBQ3RELGlCQUFpQixtQkFBTyxDQUFDLGlGQUEwQjtBQUNuRCxXQUFXLG1CQUFPLENBQUMsbUVBQW1CO0FBQ3RDLDRCQUE0QixtQkFBTyxDQUFDLHlHQUFzQztBQUMxRSxnQkFBZ0IsbUJBQU8sQ0FBQywrRUFBeUI7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0JBQWdCO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7Ozs7Ozs7Ozs7QUNsRkEsa0JBQWtCLG1CQUFPLENBQUMsaUZBQTBCO0FBQ3BELDhCQUE4QixtQkFBTyxDQUFDLHlHQUFzQztBQUM1RSwyQkFBMkIsbUJBQU8sQ0FBQyx1R0FBcUM7QUFDeEUsZUFBZSxtQkFBTyxDQUFDLDZFQUF3QjtBQUMvQyxzQkFBc0IsbUJBQU8sQ0FBQyw2RkFBZ0M7QUFDOUQsaUJBQWlCLG1CQUFPLENBQUMsaUZBQTBCOztBQUVuRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ25CQSxrQkFBa0IsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDcEQscUJBQXFCLG1CQUFPLENBQUMsdUZBQTZCO0FBQzFELDhCQUE4QixtQkFBTyxDQUFDLHlHQUFzQztBQUM1RSxlQUFlLG1CQUFPLENBQUMsNkVBQXdCO0FBQy9DLG9CQUFvQixtQkFBTyxDQUFDLHlGQUE4Qjs7QUFFMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQkFBZ0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMUNBLGtCQUFrQixtQkFBTyxDQUFDLGlGQUEwQjtBQUNwRCxXQUFXLG1CQUFPLENBQUMscUZBQTRCO0FBQy9DLGlDQUFpQyxtQkFBTyxDQUFDLHFIQUE0QztBQUNyRiwrQkFBK0IsbUJBQU8sQ0FBQywrR0FBeUM7QUFDaEYsc0JBQXNCLG1CQUFPLENBQUMsNkZBQWdDO0FBQzlELG9CQUFvQixtQkFBTyxDQUFDLHlGQUE4QjtBQUMxRCxhQUFhLG1CQUFPLENBQUMsMkZBQStCO0FBQ3BELHFCQUFxQixtQkFBTyxDQUFDLHVGQUE2Qjs7QUFFMUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQkFBZ0I7QUFDcEI7QUFDQTs7Ozs7Ozs7Ozs7QUNyQkE7QUFDQSxjQUFjLG1CQUFPLENBQUMsaUZBQTBCO0FBQ2hELHNCQUFzQixtQkFBTyxDQUFDLDZGQUFnQztBQUM5RCwyQkFBMkIsOElBQXVEO0FBQ2xGLGlCQUFpQixtQkFBTyxDQUFDLCtGQUFpQzs7QUFFMUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3RCQSx5QkFBeUIsbUJBQU8sQ0FBQyxtR0FBbUM7QUFDcEUsa0JBQWtCLG1CQUFPLENBQUMscUZBQTRCOztBQUV0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7Ozs7Ozs7Ozs7QUNWQTtBQUNBLFNBQVM7Ozs7Ozs7Ozs7O0FDRFQsYUFBYSxtQkFBTyxDQUFDLDJGQUErQjtBQUNwRCxpQkFBaUIsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDbkQsZUFBZSxtQkFBTyxDQUFDLDZFQUF3QjtBQUMvQyxnQkFBZ0IsbUJBQU8sQ0FBQywrRUFBeUI7QUFDakQsK0JBQStCLG1CQUFPLENBQUMsMkdBQXVDOztBQUU5RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7Ozs7Ozs7OztBQ3BCQSxrQkFBa0IsbUJBQU8sQ0FBQyxxR0FBb0M7O0FBRTlELCtCQUErQjs7Ozs7Ozs7Ozs7QUNGL0Isa0JBQWtCLG1CQUFPLENBQUMscUdBQW9DO0FBQzlELGFBQWEsbUJBQU8sQ0FBQywyRkFBK0I7QUFDcEQsc0JBQXNCLG1CQUFPLENBQUMsNkZBQWdDO0FBQzlELGNBQWMsc0hBQThDO0FBQzVELGlCQUFpQixtQkFBTyxDQUFDLGlGQUEwQjs7QUFFbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ25CQSx5QkFBeUIsbUJBQU8sQ0FBQyxtR0FBbUM7QUFDcEUsa0JBQWtCLG1CQUFPLENBQUMscUZBQTRCOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ1JhO0FBQ2IsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQSw0RUFBNEUsTUFBTTs7QUFFbEY7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsRUFBRTs7Ozs7Ozs7Ozs7QUNiRjtBQUNBLDBCQUEwQixtQkFBTyxDQUFDLHVIQUE2QztBQUMvRSxlQUFlLG1CQUFPLENBQUMsNkVBQXdCO0FBQy9DLHlCQUF5QixtQkFBTyxDQUFDLG1HQUFtQzs7QUFFcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7OztBQ3pCWTtBQUNiLDRCQUE0QixtQkFBTyxDQUFDLHFHQUFvQztBQUN4RSxjQUFjLG1CQUFPLENBQUMseUVBQXNCOztBQUU1QztBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7Ozs7Ozs7Ozs7O0FDUkEsV0FBVyxtQkFBTyxDQUFDLHFGQUE0QjtBQUMvQyxpQkFBaUIsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDbkQsZUFBZSxtQkFBTyxDQUFDLDZFQUF3Qjs7QUFFL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2RBLGlCQUFpQixtQkFBTyxDQUFDLG1GQUEyQjtBQUNwRCxrQkFBa0IsbUJBQU8sQ0FBQyxxR0FBb0M7QUFDOUQsZ0NBQWdDLG1CQUFPLENBQUMscUhBQTRDO0FBQ3BGLGtDQUFrQyxtQkFBTyxDQUFDLHlIQUE4QztBQUN4RixlQUFlLG1CQUFPLENBQUMsNkVBQXdCOztBQUUvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDYkEsYUFBYSxtQkFBTyxDQUFDLHVFQUFxQjs7QUFFMUM7Ozs7Ozs7Ozs7O0FDRkEscUJBQXFCLGdJQUFnRDs7QUFFckU7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFCQUFxQjtBQUM1Qyx5QkFBeUI7QUFDekIsR0FBRztBQUNIOzs7Ozs7Ozs7OztBQ1JBLHdCQUF3QixtQkFBTyxDQUFDLG1HQUFtQzs7QUFFbkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1RBLHFCQUFxQixnSUFBZ0Q7QUFDckUsYUFBYSxtQkFBTyxDQUFDLDJGQUErQjtBQUNwRCxzQkFBc0IsbUJBQU8sQ0FBQyw2RkFBZ0M7O0FBRTlEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxnQ0FBZ0M7QUFDNUU7QUFDQTs7Ozs7Ozs7Ozs7QUNYQSxhQUFhLG1CQUFPLENBQUMsdUVBQXFCO0FBQzFDLFVBQVUsbUJBQU8sQ0FBQyxpRUFBa0I7O0FBRXBDOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNQQSxhQUFhLG1CQUFPLENBQUMsdUVBQXFCO0FBQzFDLDJCQUEyQixtQkFBTyxDQUFDLHVHQUFxQzs7QUFFeEU7QUFDQSw2REFBNkQ7O0FBRTdEOzs7Ozs7Ozs7OztBQ05BLGNBQWMsbUJBQU8sQ0FBQyx5RUFBc0I7QUFDNUMsWUFBWSxtQkFBTyxDQUFDLG1GQUEyQjs7QUFFL0M7QUFDQSxxRUFBcUU7QUFDckUsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7OztBQ1hELGtCQUFrQixtQkFBTyxDQUFDLHFHQUFvQztBQUM5RCwwQkFBMEIsbUJBQU8sQ0FBQyx1R0FBcUM7QUFDdkUsZUFBZSxtQkFBTyxDQUFDLDZFQUF3QjtBQUMvQyw2QkFBNkIsbUJBQU8sQ0FBQywyR0FBdUM7O0FBRTVFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNuQ0Esa0JBQWtCLG1CQUFPLENBQUMscUdBQW9DO0FBQzlELDZCQUE2QixtQkFBTyxDQUFDLDJHQUF1QztBQUM1RSxlQUFlLG1CQUFPLENBQUMsNkVBQXdCO0FBQy9DLGtCQUFrQixtQkFBTyxDQUFDLGlGQUEwQjs7QUFFcEQ7QUFDQTtBQUNBOztBQUVBLHVCQUF1QiwrQ0FBK0M7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixxQkFBcUI7QUFDOUM7QUFDQTtBQUNBLHlCQUF5QixvQkFBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzdCQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLDZGQUFnQztBQUN6RCxZQUFZLG1CQUFPLENBQUMscUVBQW9COztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7QUNaRCxXQUFXLG1CQUFPLENBQUMscUZBQTRCO0FBQy9DLGlCQUFpQixtQkFBTyxDQUFDLG1GQUEyQjtBQUNwRCxzQkFBc0IsbUJBQU8sQ0FBQyw2RkFBZ0M7QUFDOUQsb0JBQW9CLG1CQUFPLENBQUMseUZBQThCOztBQUUxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSSxVQUFVO0FBQ25CO0FBQ0E7Ozs7Ozs7Ozs7O0FDbkJBLG9CQUFvQixtQkFBTyxDQUFDLG1IQUEyQzs7QUFFdkU7QUFDQTs7Ozs7Ozs7Ozs7QUNIQSxrQkFBa0IsbUJBQU8sQ0FBQyxxR0FBb0M7O0FBRTlEO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNKQSwwQkFBMEIsbUJBQU8sQ0FBQyx1R0FBcUM7O0FBRXZFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNYQTtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLHVGQUE2QjtBQUN6RCw2QkFBNkIsbUJBQU8sQ0FBQywyR0FBdUM7O0FBRTVFO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNOQSxZQUFZLG1CQUFPLENBQUMsK0VBQXlCOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNSQSwwQkFBMEIsbUJBQU8sQ0FBQyx1R0FBcUM7O0FBRXZFOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjs7Ozs7Ozs7Ozs7QUNSQSw2QkFBNkIsbUJBQU8sQ0FBQywyR0FBdUM7O0FBRTVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDUkEsV0FBVyxtQkFBTyxDQUFDLHFGQUE0QjtBQUMvQyxlQUFlLG1CQUFPLENBQUMsNkVBQXdCO0FBQy9DLGVBQWUsbUJBQU8sQ0FBQyw2RUFBd0I7QUFDL0MsZ0JBQWdCLG1CQUFPLENBQUMsK0VBQXlCO0FBQ2pELDBCQUEwQixtQkFBTyxDQUFDLHFHQUFvQztBQUN0RSxzQkFBc0IsbUJBQU8sQ0FBQyw2RkFBZ0M7O0FBRTlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3hCQSxrQkFBa0IsbUJBQU8sQ0FBQyxtRkFBMkI7QUFDckQsZUFBZSxtQkFBTyxDQUFDLDZFQUF3Qjs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1JBLHNCQUFzQixtQkFBTyxDQUFDLDZGQUFnQzs7QUFFOUQ7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7Ozs7Ozs7QUNQQSxjQUFjLG1CQUFPLENBQUMseUVBQXNCOztBQUU1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNQQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1JBLGtCQUFrQixtQkFBTyxDQUFDLHFHQUFvQzs7QUFFOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNSQTtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLG1IQUEyQzs7QUFFdkU7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ0xBLGtCQUFrQixtQkFBTyxDQUFDLGlGQUEwQjtBQUNwRCxZQUFZLG1CQUFPLENBQUMscUVBQW9COztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxhQUFhO0FBQzFEO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7Ozs7Ozs7Ozs7QUNYRCxhQUFhLG1CQUFPLENBQUMsdUVBQXFCO0FBQzFDLGlCQUFpQixtQkFBTyxDQUFDLGlGQUEwQjs7QUFFbkQ7O0FBRUE7Ozs7Ozs7Ozs7O0FDTEEsV0FBVyxtQkFBTyxDQUFDLG1FQUFtQjtBQUN0QyxhQUFhLG1CQUFPLENBQUMsMkZBQStCO0FBQ3BELG1DQUFtQyxtQkFBTyxDQUFDLDZHQUF3QztBQUNuRixxQkFBcUIsZ0lBQWdEOztBQUVyRTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0EsR0FBRztBQUNIOzs7Ozs7Ozs7OztBQ1ZBLHNCQUFzQixtQkFBTyxDQUFDLDZGQUFnQzs7QUFFOUQsU0FBUzs7Ozs7Ozs7Ozs7QUNGVCxhQUFhLG1CQUFPLENBQUMsdUVBQXFCO0FBQzFDLGFBQWEsbUJBQU8sQ0FBQyx1RUFBcUI7QUFDMUMsYUFBYSxtQkFBTyxDQUFDLDJGQUErQjtBQUNwRCxVQUFVLG1CQUFPLENBQUMsaUVBQWtCO0FBQ3BDLG9CQUFvQixtQkFBTyxDQUFDLG1IQUEyQztBQUN2RSx3QkFBd0IsbUJBQU8sQ0FBQyw2RkFBZ0M7O0FBRWhFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ0ZhO0FBQ2IsaUJBQWlCLG1CQUFPLENBQUMsbUZBQTJCO0FBQ3BELGFBQWEsbUJBQU8sQ0FBQywyRkFBK0I7QUFDcEQsa0NBQWtDLG1CQUFPLENBQUMsdUhBQTZDO0FBQ3ZGLG9CQUFvQixtQkFBTyxDQUFDLHVHQUFxQztBQUNqRSxxQkFBcUIsbUJBQU8sQ0FBQyx5R0FBc0M7QUFDbkUsZ0NBQWdDLG1CQUFPLENBQUMsaUhBQTBDO0FBQ2xGLG9CQUFvQixtQkFBTyxDQUFDLHVGQUE2QjtBQUN6RCx3QkFBd0IsbUJBQU8sQ0FBQyxpR0FBa0M7QUFDbEUsOEJBQThCLG1CQUFPLENBQUMsNkdBQXdDO0FBQzlFLHdCQUF3QixtQkFBTyxDQUFDLGlHQUFrQztBQUNsRSx3QkFBd0IsbUJBQU8sQ0FBQyxpR0FBa0M7QUFDbEUsa0JBQWtCLG1CQUFPLENBQUMsaUZBQTBCO0FBQ3BELGNBQWMsbUJBQU8sQ0FBQyx5RUFBc0I7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQSw4REFBOEQsWUFBWTtBQUMxRSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0JBQWdCOztBQUVwQjtBQUNBOzs7Ozs7Ozs7Ozs7QUNoRWE7QUFDYixzQkFBc0IsbUJBQU8sQ0FBQyw2RkFBZ0M7QUFDOUQsdUJBQXVCLG1CQUFPLENBQUMsK0ZBQWlDO0FBQ2hFLGdCQUFnQixtQkFBTyxDQUFDLDZFQUF3QjtBQUNoRCwwQkFBMEIsbUJBQU8sQ0FBQyx1RkFBNkI7QUFDL0QscUJBQXFCLGdJQUFnRDtBQUNyRSxxQkFBcUIsbUJBQU8sQ0FBQyx5RkFBOEI7QUFDM0QsNkJBQTZCLG1CQUFPLENBQUMsNkdBQXdDO0FBQzdFLGNBQWMsbUJBQU8sQ0FBQyx5RUFBc0I7QUFDNUMsa0JBQWtCLG1CQUFPLENBQUMsaUZBQTBCOztBQUVwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLGlCQUFpQjtBQUNwRCxFQUFFLGdCQUFnQjs7Ozs7Ozs7Ozs7QUM3RGxCLGFBQWEsbUJBQU8sQ0FBQywyRkFBK0I7QUFDcEQsb0JBQW9CLG1CQUFPLENBQUMseUZBQThCO0FBQzFELHNCQUFzQixtQkFBTyxDQUFDLDZGQUFnQztBQUM5RCxzQkFBc0IsbUJBQU8sQ0FBQyw2RkFBZ0M7O0FBRTlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNaQTtBQUNBLFFBQVEsbUJBQU8sQ0FBQyx1RUFBcUI7QUFDckMsYUFBYSxtQkFBTyxDQUFDLHVFQUFxQjtBQUMxQyxZQUFZLG1CQUFPLENBQUMsdUZBQTZCO0FBQ2pELG9DQUFvQyxtQkFBTyxDQUFDLDZIQUFnRDs7QUFFNUY7QUFDQTs7QUFFQSwwQkFBMEIsVUFBVTs7QUFFcEM7QUFDQTtBQUNBO0FBQ0EsTUFBTSwyREFBMkQ7QUFDakU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtFQUErRTtBQUN2RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxDQUFDO0FBQ0Q7QUFDQSx1Q0FBdUM7QUFDdkMsQ0FBQztBQUNEO0FBQ0Esd0NBQXdDO0FBQ3hDLENBQUM7QUFDRDtBQUNBLDRDQUE0QztBQUM1QyxDQUFDO0FBQ0Q7QUFDQSx5Q0FBeUM7QUFDekMsQ0FBQztBQUNEO0FBQ0EsdUNBQXVDO0FBQ3ZDLENBQUM7QUFDRDtBQUNBLHNDQUFzQztBQUN0QyxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEM7QUFDMUMsQ0FBQztBQUNEO0FBQ0EsdUNBQXVDO0FBQ3ZDLENBQUM7QUFDRDtBQUNBLDBDQUEwQztBQUMxQyxDQUFDOzs7Ozs7Ozs7OztBQ3hERCxvQkFBb0IsbUJBQU8sQ0FBQyx5RkFBOEI7QUFDMUQsb0JBQW9CLG1CQUFPLENBQUMseUZBQThCOztBQUUxRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1RBO0FBQ0EsUUFBUSxtQkFBTyxDQUFDLHVFQUFxQjtBQUNyQyxXQUFXLG1CQUFPLENBQUMscUZBQTRCOztBQUUvQztBQUNBO0FBQ0E7QUFDQSxJQUFJLGlFQUFpRTtBQUNyRTtBQUNBLENBQUM7Ozs7Ozs7Ozs7O0FDVEQsUUFBUSxtQkFBTyxDQUFDLHVFQUFxQjtBQUNyQyxpQkFBaUIsbUJBQU8sQ0FBQyxtRkFBMkI7QUFDcEQsWUFBWSxtQkFBTyxDQUFDLHVGQUE2QjtBQUNqRCxXQUFXLG1CQUFPLENBQUMscUZBQTRCO0FBQy9DLGtCQUFrQixtQkFBTyxDQUFDLHFHQUFvQztBQUM5RCxZQUFZLG1CQUFPLENBQUMscUVBQW9CO0FBQ3hDLGlCQUFpQixtQkFBTyxDQUFDLGlGQUEwQjtBQUNuRCxlQUFlLG1CQUFPLENBQUMsNkVBQXdCO0FBQy9DLGlCQUFpQixtQkFBTyxDQUFDLGlGQUEwQjtBQUNuRCwwQkFBMEIsbUJBQU8sQ0FBQywrR0FBeUM7QUFDM0Usb0JBQW9CLG1CQUFPLENBQUMsbUhBQTJDOztBQUV2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXLFFBQVE7QUFDdkM7QUFDQSx3Q0FBd0M7QUFDeEMsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTSw4RkFBOEY7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7Ozs7Ozs7Ozs7QUN2RWE7QUFDYixRQUFRLG1CQUFPLENBQUMsdUVBQXFCO0FBQ3JDLGNBQWMsbUJBQU8sQ0FBQyx5RUFBc0I7QUFDNUMsa0JBQWtCLG1CQUFPLENBQUMsaUZBQTBCO0FBQ3BELGFBQWEsbUJBQU8sQ0FBQyx1RUFBcUI7QUFDMUMsV0FBVyxtQkFBTyxDQUFDLG1FQUFtQjtBQUN0QyxrQkFBa0IsbUJBQU8sQ0FBQyxxR0FBb0M7QUFDOUQsZUFBZSxtQkFBTyxDQUFDLDZFQUF3QjtBQUMvQyxhQUFhLG1CQUFPLENBQUMsMkZBQStCO0FBQ3BELHdCQUF3QixtQkFBTyxDQUFDLGlHQUFrQztBQUNsRSxvQkFBb0IsbUJBQU8sQ0FBQyx1R0FBcUM7QUFDakUsZUFBZSxtQkFBTyxDQUFDLDZFQUF3QjtBQUMvQyxrQkFBa0IsbUJBQU8sQ0FBQyxtRkFBMkI7QUFDckQsWUFBWSxtQkFBTyxDQUFDLHFFQUFvQjtBQUN4QywwQkFBMEIsOElBQXVEO0FBQ2pGLCtCQUErQix3SkFBNEQ7QUFDM0YscUJBQXFCLGdJQUFnRDtBQUNyRSxzQkFBc0IsbUJBQU8sQ0FBQyw2RkFBZ0M7QUFDOUQsV0FBVyw2R0FBd0M7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JELE1BQU07QUFDTjtBQUNBLHFDQUFxQyxjQUFjLE9BQU87QUFDMUQsc0NBQXNDLGNBQWMsT0FBTztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHNFQUFzRSx5QkFBeUI7QUFDL0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSSw2REFBNkQ7QUFDakU7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZHQSxRQUFRLG1CQUFPLENBQUMsdUVBQXFCO0FBQ3JDLGFBQWEsbUJBQU8sQ0FBQyxxRkFBNEI7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBLElBQUksMEVBQTBFO0FBQzlFO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7QUNSRDtBQUNBLFFBQVEsbUJBQU8sQ0FBQyx1RUFBcUI7QUFDckMsa0JBQWtCLG1CQUFPLENBQUMsaUZBQTBCO0FBQ3BELGFBQWEsbUJBQU8sQ0FBQyxxRkFBNEI7O0FBRWpEO0FBQ0E7QUFDQSxJQUFJLGtEQUFrRDtBQUN0RDtBQUNBLENBQUM7Ozs7Ozs7Ozs7O0FDVEQsUUFBUSxtQkFBTyxDQUFDLHVFQUFxQjtBQUNyQyxrQkFBa0IsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDcEQscUJBQXFCLGdJQUFnRDs7QUFFckU7QUFDQTtBQUNBO0FBQ0EsSUFBSSxvR0FBb0c7QUFDeEc7QUFDQSxDQUFDOzs7Ozs7Ozs7OztBQ1RELFFBQVEsbUJBQU8sQ0FBQyx1RUFBcUI7QUFDckMsb0JBQW9CLG1CQUFPLENBQUMsbUhBQTJDO0FBQ3ZFLFlBQVksbUJBQU8sQ0FBQyxxRUFBb0I7QUFDeEMsa0NBQWtDLG1CQUFPLENBQUMseUhBQThDO0FBQ3hGLGVBQWUsbUJBQU8sQ0FBQyw2RUFBd0I7O0FBRS9DO0FBQ0E7QUFDQSxtREFBbUQsbUNBQW1DOztBQUV0RjtBQUNBO0FBQ0EsSUFBSSw4Q0FBOEM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7OztBQ2pCRCxRQUFRLG1CQUFPLENBQUMsdUVBQXFCO0FBQ3JDLFlBQVksbUJBQU8sQ0FBQyxxRUFBb0I7QUFDeEMsZUFBZSxtQkFBTyxDQUFDLDZFQUF3QjtBQUMvQywyQkFBMkIsbUJBQU8sQ0FBQyx5R0FBc0M7QUFDekUsK0JBQStCLG1CQUFPLENBQUMsMkdBQXVDOztBQUU5RSw4Q0FBOEMsMEJBQTBCOztBQUV4RTtBQUNBO0FBQ0EsSUFBSSw0RkFBNEY7QUFDaEc7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7O0FDZEQsUUFBUSxtQkFBTyxDQUFDLHVFQUFxQjtBQUNyQyxxQkFBcUIsbUJBQU8sQ0FBQyx5R0FBc0M7O0FBRW5FO0FBQ0E7QUFDQSxJQUFJLDhCQUE4QjtBQUNsQztBQUNBLENBQUM7Ozs7Ozs7Ozs7O0FDUEQsNEJBQTRCLG1CQUFPLENBQUMscUdBQW9DO0FBQ3hFLG9CQUFvQixtQkFBTyxDQUFDLHlGQUE4QjtBQUMxRCxlQUFlLG1CQUFPLENBQUMsMkZBQStCOztBQUV0RDtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsY0FBYztBQUN4RTs7Ozs7Ozs7Ozs7QUNSQSxRQUFRLG1CQUFPLENBQUMsdUVBQXFCO0FBQ3JDLGlCQUFpQixtQkFBTyxDQUFDLG1GQUEyQjtBQUNwRCxZQUFZLG1CQUFPLENBQUMsdUZBQTZCO0FBQ2pELFdBQVcsbUJBQU8sQ0FBQyxxRkFBNEI7QUFDL0MsbUJBQW1CLG1CQUFPLENBQUMscUZBQTRCO0FBQ3ZELGVBQWUsbUJBQU8sQ0FBQyw2RUFBd0I7QUFDL0MsZUFBZSxtQkFBTyxDQUFDLDZFQUF3QjtBQUMvQyxhQUFhLG1CQUFPLENBQUMscUZBQTRCO0FBQ2pELFlBQVksbUJBQU8sQ0FBQyxxRUFBb0I7O0FBRXhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLHlDQUF5QyxhQUFhO0FBQ3RELENBQUM7O0FBRUQ7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QyxDQUFDOztBQUVEOztBQUVBLElBQUksNkRBQTZEO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7QUN2REQsUUFBUSxtQkFBTyxDQUFDLHVFQUFxQjtBQUNyQyxhQUFhLG1CQUFPLENBQUMsdUVBQXFCO0FBQzFDLHFCQUFxQixtQkFBTyxDQUFDLDZGQUFnQzs7QUFFN0QsSUFBSSxjQUFjLElBQUksYUFBYTs7QUFFbkM7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNSYTtBQUNiLGFBQWEseUhBQStDO0FBQzVELGVBQWUsbUJBQU8sQ0FBQyw2RUFBd0I7QUFDL0MsMEJBQTBCLG1CQUFPLENBQUMsdUZBQTZCO0FBQy9ELHFCQUFxQixtQkFBTyxDQUFDLHlGQUE4QjtBQUMzRCw2QkFBNkIsbUJBQU8sQ0FBQyw2R0FBd0M7O0FBRTdFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7QUM5Qlk7QUFDYixRQUFRLG1CQUFPLENBQUMsdUVBQXFCO0FBQ3JDLGFBQWEsbUJBQU8sQ0FBQyx1RUFBcUI7QUFDMUMsV0FBVyxtQkFBTyxDQUFDLHFGQUE0QjtBQUMvQyxrQkFBa0IsbUJBQU8sQ0FBQyxxR0FBb0M7QUFDOUQsY0FBYyxtQkFBTyxDQUFDLHlFQUFzQjtBQUM1QyxrQkFBa0IsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDcEQsb0JBQW9CLG1CQUFPLENBQUMsbUhBQTJDO0FBQ3ZFLFlBQVksbUJBQU8sQ0FBQyxxRUFBb0I7QUFDeEMsYUFBYSxtQkFBTyxDQUFDLDJGQUErQjtBQUNwRCxvQkFBb0IsbUJBQU8sQ0FBQyx1R0FBcUM7QUFDakUsZUFBZSxtQkFBTyxDQUFDLDZFQUF3QjtBQUMvQyxzQkFBc0IsbUJBQU8sQ0FBQyw2RkFBZ0M7QUFDOUQsb0JBQW9CLG1CQUFPLENBQUMseUZBQThCO0FBQzFELGdCQUFnQixtQkFBTyxDQUFDLDZFQUF3QjtBQUNoRCwrQkFBK0IsbUJBQU8sQ0FBQywrR0FBeUM7QUFDaEYseUJBQXlCLG1CQUFPLENBQUMscUZBQTRCO0FBQzdELGlCQUFpQixtQkFBTyxDQUFDLGlGQUEwQjtBQUNuRCxnQ0FBZ0MsbUJBQU8sQ0FBQyxxSEFBNEM7QUFDcEYsa0NBQWtDLG1CQUFPLENBQUMsdUlBQXFEO0FBQy9GLGtDQUFrQyxtQkFBTyxDQUFDLHlIQUE4QztBQUN4RixxQ0FBcUMsbUJBQU8sQ0FBQywrSEFBaUQ7QUFDOUYsMkJBQTJCLG1CQUFPLENBQUMsdUdBQXFDO0FBQ3hFLDZCQUE2QixtQkFBTyxDQUFDLDJHQUF1QztBQUM1RSxpQ0FBaUMsbUJBQU8sQ0FBQyxxSEFBNEM7QUFDckYsb0JBQW9CLG1CQUFPLENBQUMseUZBQThCO0FBQzFELDRCQUE0QixtQkFBTyxDQUFDLDJHQUF1QztBQUMzRSxhQUFhLG1CQUFPLENBQUMsdUVBQXFCO0FBQzFDLGdCQUFnQixtQkFBTyxDQUFDLCtFQUF5QjtBQUNqRCxpQkFBaUIsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDbkQsVUFBVSxtQkFBTyxDQUFDLGlFQUFrQjtBQUNwQyxzQkFBc0IsbUJBQU8sQ0FBQyw2RkFBZ0M7QUFDOUQsbUNBQW1DLG1CQUFPLENBQUMsNkdBQXdDO0FBQ25GLDRCQUE0QixtQkFBTyxDQUFDLDJHQUF1QztBQUMzRSw4QkFBOEIsbUJBQU8sQ0FBQywrR0FBeUM7QUFDL0UscUJBQXFCLG1CQUFPLENBQUMsNkZBQWdDO0FBQzdELDBCQUEwQixtQkFBTyxDQUFDLHVGQUE2QjtBQUMvRCxlQUFlLHdIQUErQzs7QUFFOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRCx1QkFBdUIseUNBQXlDLFVBQVU7QUFDMUUsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUY7QUFDQSxNQUFNO0FBQ047QUFDQSxvREFBb0QsZ0RBQWdEO0FBQ3BHLE1BQU07QUFDTixJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLGlDQUFpQztBQUNoSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxzRkFBc0YsY0FBYztBQUNwRztBQUNBO0FBQ0E7O0FBRUEsSUFBSSwyRkFBMkY7QUFDL0Y7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVELElBQUksb0RBQW9EO0FBQ3hELDJCQUEyQixvQkFBb0I7QUFDL0MsMkJBQTJCO0FBQzNCLENBQUM7O0FBRUQsSUFBSSwwRUFBMEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxJQUFJLHNEQUFzRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQzVQQTtBQUNBO0FBQ2E7QUFDYixRQUFRLG1CQUFPLENBQUMsdUVBQXFCO0FBQ3JDLGtCQUFrQixtQkFBTyxDQUFDLGlGQUEwQjtBQUNwRCxhQUFhLG1CQUFPLENBQUMsdUVBQXFCO0FBQzFDLGtCQUFrQixtQkFBTyxDQUFDLHFHQUFvQztBQUM5RCxhQUFhLG1CQUFPLENBQUMsMkZBQStCO0FBQ3BELGlCQUFpQixtQkFBTyxDQUFDLGlGQUEwQjtBQUNuRCxvQkFBb0IsbUJBQU8sQ0FBQyx1R0FBcUM7QUFDakUsZUFBZSxtQkFBTyxDQUFDLDZFQUF3QjtBQUMvQyw0QkFBNEIsbUJBQU8sQ0FBQywyR0FBdUM7QUFDM0UsZ0NBQWdDLG1CQUFPLENBQUMsaUhBQTBDOztBQUVsRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsTUFBTSwrQ0FBK0M7QUFDckQ7QUFDQSxHQUFHO0FBQ0g7Ozs7Ozs7Ozs7O0FDMURBLFFBQVEsbUJBQU8sQ0FBQyx1RUFBcUI7QUFDckMsaUJBQWlCLG1CQUFPLENBQUMsbUZBQTJCO0FBQ3BELGFBQWEsbUJBQU8sQ0FBQywyRkFBK0I7QUFDcEQsZUFBZSxtQkFBTyxDQUFDLDZFQUF3QjtBQUMvQyxhQUFhLG1CQUFPLENBQUMsdUVBQXFCO0FBQzFDLDZCQUE2QixtQkFBTyxDQUFDLDZHQUF3Qzs7QUFFN0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSSwrREFBK0Q7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7O0FDckJELDRCQUE0QixtQkFBTyxDQUFDLDJHQUF1Qzs7QUFFM0U7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ0pBO0FBQ0EsbUJBQU8sQ0FBQyxpR0FBa0M7QUFDMUMsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDbEMsbUJBQU8sQ0FBQyx5RkFBOEI7QUFDdEMsbUJBQU8sQ0FBQyx5RkFBOEI7QUFDdEMsbUJBQU8sQ0FBQywySEFBK0M7Ozs7Ozs7Ozs7O0FDTHZELFFBQVEsbUJBQU8sQ0FBQyx1RUFBcUI7QUFDckMsYUFBYSxtQkFBTyxDQUFDLDJGQUErQjtBQUNwRCxlQUFlLG1CQUFPLENBQUMsNkVBQXdCO0FBQy9DLGtCQUFrQixtQkFBTyxDQUFDLHFGQUE0QjtBQUN0RCxhQUFhLG1CQUFPLENBQUMsdUVBQXFCO0FBQzFDLDZCQUE2QixtQkFBTyxDQUFDLDZHQUF3Qzs7QUFFN0U7O0FBRUE7QUFDQTtBQUNBLElBQUksK0RBQStEO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7QUNoQkQsNEJBQTRCLG1CQUFPLENBQUMsMkdBQXVDO0FBQzNFLDhCQUE4QixtQkFBTyxDQUFDLCtHQUF5Qzs7QUFFL0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNUQSxhQUFhLG1CQUFPLENBQUMsdUVBQXFCO0FBQzFDLG1CQUFtQixtQkFBTyxDQUFDLHFGQUE0QjtBQUN2RCw0QkFBNEIsbUJBQU8sQ0FBQywyR0FBdUM7QUFDM0UsMkJBQTJCLG1CQUFPLENBQUMseUZBQThCO0FBQ2pFLGtDQUFrQyxtQkFBTyxDQUFDLHVIQUE2QztBQUN2RixzQkFBc0IsbUJBQU8sQ0FBQyw2RkFBZ0M7O0FBRTlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7QUNyQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxZQUFZO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrRkFBa0Y7O0FBRWxGO0FBQ0E7QUFDQSxzQkFBc0IsbURBQW1EO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNEJBQTRCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLG9DQUFvQztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELE9BQU87QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywrQkFBK0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE9BQU87QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGVBQWU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFdBQVc7QUFDWCxXQUFXO0FBQ1gsWUFBWTtBQUNaLGFBQWE7QUFDYixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxxR0FBcUc7QUFDckc7QUFDQSwrREFBK0Q7QUFDL0QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUc7QUFDdkc7QUFDQSw0Q0FBNEM7QUFDNUMsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxTQUFTO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsU0FBUztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDO0FBQ0EsNkNBQTZDLElBQUk7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE1BQU07QUFDaEQsc0JBQXNCLDBCQUEwQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsb0NBQW9DO0FBQ3BDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxPQUFPO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLCtFQUErRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsWUFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSw2QkFBNkIsWUFBWTtBQUN6QyxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsT0FBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsVUFBVTtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFVBQVU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywrQkFBK0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxPQUFPO0FBQzVELFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFVBQVU7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFlBQVk7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxVQUFVO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLGtCQUFrQixLQUFLLElBQUk7QUFDM0c7QUFDQTtBQUNBLDZDQUE2QyxvQkFBb0IsNkJBQTZCLGtCQUFrQjtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxvQkFBb0IsS0FBSyxLQUFLO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGtCQUFrQixLQUFLLE1BQU07QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWEsSUFBSSxvQkFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywrQkFBK0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHdCQUF3QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdUJBQXVCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsb0JBQW9CO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxTQUFTLFFBQVE7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxJQUFJO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLG1DQUFtQyxxQkFBcUI7QUFDeEQsaUNBQWlDLHFCQUFxQjtBQUN0RCxpQ0FBaUMscUJBQXFCO0FBQ3RELHVDQUF1QyxxQkFBcUI7QUFDNUQsbUNBQW1DLHFCQUFxQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsZ0RBQWdELHVCQUF1QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1Asd0NBQXdDLHFCQUFxQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxxQ0FBcUMscUJBQXFCO0FBQzFELDBDQUEwQyxxQkFBcUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLG9DQUFvQyxxQkFBcUI7QUFDekQsa0NBQWtDLHFCQUFxQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxtQ0FBbUMscUJBQXFCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDJDQUEyQyxxQkFBcUI7QUFDaEUseUNBQXlDLHVCQUF1QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asb0NBQW9DLHFCQUFxQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGdDQUFnQyx1QkFBdUI7QUFDdkQsaURBQWlELHVCQUF1QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGdEQUFnRCx1QkFBdUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw4Q0FBOEMsc0JBQXNCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsOENBQThDLHNCQUFzQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsbUNBQW1DLHFCQUFxQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsMENBQTBDLHFCQUFxQjtBQUMvRCxrREFBa0QscUJBQXFCO0FBQ3ZFLDJDQUEyQyxxQkFBcUI7QUFDaEUseUNBQXlDLG9DQUFvQztBQUM3RSx5Q0FBeUMscUJBQXFCO0FBQzlELHdDQUF3QyxvQ0FBb0M7QUFDNUUseUNBQXlDLHFCQUFxQjtBQUM5RCx1Q0FBdUMsb0NBQW9DO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxxQ0FBcUMsdURBQXVEO0FBQzVGO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxrQ0FBa0Msb0JBQW9CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGtDQUFrQyxxQkFBcUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCwyQ0FBMkMsdUJBQXVCO0FBQ2xFLDRDQUE0Qyx1QkFBdUI7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUNBQWlDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLGlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxlQUFlO0FBQzNELFNBQVM7QUFDVDtBQUNBO0FBQ0EsK0NBQStDLHdCQUF3Qiw2QkFBNkIsb0NBQW9DLE1BQU0sK0JBQStCLG1CQUFtQixNQUFNLHdCQUF3Qix3QkFBd0IsbUJBQW1CLGlCQUFpQixZQUFZLGVBQWUsZ0JBQWdCLE1BQU07QUFDM1U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssK0JBQStCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxnQkFBZ0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxlQUFlO0FBQ3pEO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyw0QkFBNEI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw2QkFBNkI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxNQUFNO0FBQ2hEO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsTUFBTTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLGtCQUFrQixJQUFJLDJCQUEyQjtBQUN0STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE9BQU87QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsNkJBQTZCLGdCQUFnQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxTQUFTO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0RBQXNEO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0JBQWtCO0FBQzVDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCwwQkFBMEI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEMsZ0JBQWdCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLCtCQUErQjtBQUM1QztBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUMsc0JBQXNCLGtCQUFrQjtBQUN4QyxhQUFhLGVBQWUsZ0JBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHlCQUF5QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNEJBQTRCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0JBQW9CO0FBQzdDLHlCQUF5QixrQkFBa0I7QUFDM0MseUJBQXlCLHdCQUF3QjtBQUNqRCwrQ0FBK0MsNEJBQTRCO0FBQzNFLDZDQUE2Qyx5QkFBeUI7QUFDdEU7QUFDQTtBQUNBLHlCQUF5Qix5QkFBeUI7QUFDbEQseUJBQXlCLDRCQUE0QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHVEQUF1RCxTQUFTO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE1BQU07QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsa0dBQWtHLE9BQU87O0FBRXpHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHlCQUF5QjtBQUM5RCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsbUJBQW1CO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsVUFBVTtBQUM5RCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msc0JBQXNCLFFBQVEsc0JBQXNCO0FBQ3RGO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEscUJBQXFCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxtQkFBbUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx1Q0FBdUMsY0FBYztBQUNyRDtBQUNBLG1EQUFtRCxnQkFBZ0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYscUNBQXFDO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyx1QkFBdUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDhCQUE4QjtBQUNuRTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHFCQUFxQjtBQUMzRDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHFCQUFxQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSx5REFBeUQsT0FBTztBQUNoRTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDJCQUEyQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxLQUFLO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxNQUFNO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxNQUFNO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsTUFBTTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEMsV0FBVyxhQUFhLE9BQU8sNkJBQTZCLFdBQVc7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxPQUFPO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxrREFBa0QsT0FBTztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsOEJBQThCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLFFBQVEsc0JBQXNCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNCQUFzQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNElBQTRJLFdBQVc7QUFDdkosYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMklBQTJJLFdBQVc7QUFDdEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELG9CQUFvQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxTQUFTO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxTQUFTO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsTUFBTTtBQUNuQztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx1RkFBdUY7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLDBEQUEwRCwwQ0FBMEM7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsK0NBQStDLGlCQUFpQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Qsa0RBQWtEO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixrREFBa0QsdUJBQXVCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsWUFBWTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsZ0JBQWdCO0FBQzFELG1GQUFtRjtBQUNuRiwwQkFBMEIsT0FBTztBQUNqQyxtQkFBbUIsT0FBTztBQUMxQjtBQUNBLCtCQUErQixTQUFTO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLHFDQUFxQyxpQkFBaUI7QUFDdEQ7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGlCQUFpQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViwwQkFBMEIsa0JBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0JBQW9CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFVBQVU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLCtCQUErQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwrQkFBK0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixTQUFTO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsbUNBQW1DO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxVQUFVO0FBQ2xCLFFBQVEsa0JBQWtCO0FBQzFCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHVDQUF1QztBQUN2RjtBQUNBLDBCQUEwQix1QkFBdUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSEFBb0g7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLE1BQU07QUFDeEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsS0FBSztBQUM1QztBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0EsNkNBQTZDLE1BQU07QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDBCQUEwQjtBQUMzRCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDBCQUEwQjtBQUNwRTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsdUJBQXVCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLGFBQWE7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsZUFBZTtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsRUFBRSxpQkFBaUIsRUFBRTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRSx3REFBd0Q7QUFDeEQsd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGVBQWU7QUFDdEQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxrQ0FBa0M7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEVBQUU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQkFBZ0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQkFBZ0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxPQUFPO0FBQ3pFO0FBQ0E7QUFDQSxtREFBbUQsT0FBTztBQUMxRDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELEtBQUssWUFBWSxPQUFPO0FBQzdFLFNBQVM7QUFDVDtBQUNBO0FBQ0EsdURBQXVELEtBQUssWUFBWSxPQUFPO0FBQy9FO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekIsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsTUFBTTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxVQUFVLElBQUksTUFBTSxLQUFLLFVBQVU7QUFDaEYsbUhBQW1ILFNBQVMsNEJBQTRCLFNBQVM7QUFDaks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtFQUErRSxpQkFBaUI7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw2QkFBNkIsdUJBQXVCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0JBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFdBQVc7QUFDL0MsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxzQ0FBc0MsaUJBQWlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGdCQUFnQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUNBQWlDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsbUJBQW1CLGdGQUFnRjtBQUNuRztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsYUFBYTtBQUNiLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYSxxRUFBcUU7QUFDbEY7QUFDQSxnQkFBZ0IsNkJBQTZCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1QscUJBQXFCLDJEQUEyRDtBQUNoRjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1QscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywrQ0FBK0M7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZ0NBQWdDLGlCQUFpQjtBQUNqRCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2Y7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMkJBQTJCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsY0FBYztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLFlBQVk7QUFDL0UsbUVBQW1FLFlBQVksR0FBRyxpQ0FBaUM7QUFDbkgsbUVBQW1FLFlBQVksR0FBRyxpQ0FBaUM7QUFDbkg7QUFDQTtBQUNBO0FBQ0EsK0hBQStILE1BQU0saUJBQWlCLG9CQUFvQjtBQUMxSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxZQUFZLEdBQUcsOERBQThEO0FBQ25KLHNFQUFzRSxZQUFZLEdBQUcsb0NBQW9DO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQ0FBbUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Qsb0JBQW9CO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxnREFBZ0QsZ0JBQWdCLG1CQUFtQjtBQUNuRjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxFQUFFO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGNBQWM7QUFDbkQ7QUFDQTtBQUNBLDJFQUEyRSxNQUFNLEtBQUssT0FBTyxZQUFZLEtBQUssdUJBQXVCLE9BQU8sUUFBUSxLQUFLO0FBQ3pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsRUFBRTtBQUN6QztBQUNBO0FBQ0EsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUyxJQUFJLEtBQUssSUFBSSxnQkFBZ0I7QUFDM0QsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLHdDQUF3QyxlQUFlO0FBQ3ZELGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZ0JBQWdCLElBQUksMEVBQTBFO0FBQ3pJLGtEQUFrRCxXQUFXO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7QUFDWCwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixXQUFXO0FBQ1g7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixXQUFXO0FBQ1g7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNkJBQTZCO0FBQ25EO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQ0FBZ0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsU0FBUztBQUNUO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHFCQUFxQixlQUFlO0FBQ3BDLHVCQUF1QixlQUFlO0FBQ3RDLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyQkFBMkI7QUFDN0M7QUFDQSxPQUFPO0FBQ1A7QUFDQSxrQkFBa0IsNEJBQTRCO0FBQzlDO0FBQ0EsT0FBTztBQUNQO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0EsT0FBTztBQUNQO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsNkNBQTZDO0FBQzdDLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGNBQWM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxxQkFBcUI7QUFDN0IsUUFBUSw0QkFBNEI7QUFDcEMsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHVCQUF1QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLHFCQUFxQjtBQUM3QixRQUFRLG9CQUFvQjtBQUM1QixRQUFRLGtCQUFrQjtBQUMxQixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssNkJBQTZCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSywrQkFBK0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzREFBc0Q7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLG1CQUFtQjtBQUMzQixRQUFRLG9CQUFvQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDJDQUEyQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQ0FBa0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixlQUFlLFlBQVksWUFBWTtBQUNuSSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJJQUEySSxPQUFPLHFCQUFxQixtQkFBbUI7QUFDMUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxzREFBc0QsWUFBWTtBQUNsRSxvQkFBb0I7QUFDcEI7QUFDQSxxREFBcUQsWUFBWTtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFVBQVU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsUUFBUTtBQUNoQixRQUFRLFdBQVc7QUFDbkIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsdUVBQXVFLFdBQVc7QUFDbEY7QUFDQTtBQUNBLHFEQUFxRCxXQUFXO0FBQ2hFO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHVCQUF1QjtBQUN4RDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdGQUF3RjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsVUFBVSxhQUFhLGNBQWMsa0JBQWtCO0FBQzFGLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMscUNBQXFDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDhCQUE4QixnQkFBZ0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrREFBa0QsdUJBQXVCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSwyREFBMkQsVUFBVTtBQUNyRTtBQUNBLHFIQUFxSCxvQkFBb0I7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLCtCQUErQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsMEJBQTBCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msb0JBQW9CO0FBQzVELE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asd0NBQXdDLHlCQUF5QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsK0NBQStDLGtCQUFrQjtBQUNqRSwwQ0FBMEMsZ0JBQWdCO0FBQzFELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIseUJBQXlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsMkJBQTJCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyw2Q0FBNkM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxrREFBa0Q7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxzQkFBc0I7QUFDL0Y7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQsZ0JBQWdCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsWUFBWTtBQUMvRTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsT0FBTztBQUNQO0FBQ0E7QUFDQSwrSEFBK0gsS0FBSztBQUNwSTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsZ0JBQWdCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMscUJBQXFCO0FBQy9EO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0RBQW9ELG9DQUFvQyxvQkFBb0IsMEJBQTBCO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGtCQUFrQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osU0FBUztBQUNULHNEQUFzRCw0QkFBNEI7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixlQUFlO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxnREFBZ0QsZUFBZTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsUUFBUSw2QkFBNkIsV0FBVyxjQUFjLFdBQVcsaUJBQWlCLG9CQUFvQjtBQUM1SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSw4QkFBOEIsVUFBVSxjQUFjO0FBQ3RIO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLE9BQU8sU0FBUyxRQUFRO0FBQ2hIO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHLE9BQU8sU0FBUyxRQUFRO0FBQzFIO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGVBQWUsOEJBQThCLFVBQVUsTUFBTSxTQUFTLFFBQVE7QUFDOUU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRLFVBQVUsUUFBUTtBQUNuRTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0EsMkRBQTJEO0FBQzNELDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsMEZBQTBGLGFBQWE7QUFDOUo7QUFDQSxnTUFBZ00sSUFBSSx1RkFBdUY7QUFDM1I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLFFBQVE7QUFDUixvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLG9DQUFvQywwQkFBMEI7QUFDOUQsUUFBUTtBQUNSLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLCtEQUErRCxZQUFZO0FBQzNFLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx5RUFBeUUsYUFBYSxrQ0FBa0MsZ0JBQWdCO0FBQ3hJLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixNQUFNO0FBQzVCLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxpQ0FBaUM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsMENBQTBDO0FBQ3RGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4Q0FBOEMsMkJBQTJCO0FBQ3pFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDLFNBQVM7QUFDVDtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsMENBQTBDLG1DQUFtQztBQUM3RTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELGNBQWM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esb0NBQW9DLDZCQUE2QjtBQUNqRTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELE1BQU0sV0FBVywwQkFBMEI7QUFDOUY7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxPQUFPO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsWUFBWTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw2RUFBNkUsTUFBTTtBQUNuRjtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsZ0JBQWdCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixrRkFBa0YsTUFBTTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysd0VBQXdFLE9BQU87QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE1BQU07QUFDbEM7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsK0RBQStELE1BQU07QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHlDQUF5QyxNQUFNO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELE1BQU07QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCx1RUFBdUUsTUFBTTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHNCQUFzQixHQUFHO0FBQ3pCO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsd0JBQXdCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGNBQWM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGVBQWU7QUFDL0QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsMEJBQTBCLG9CQUFvQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCx1QkFBdUI7QUFDekU7QUFDQSx3Q0FBd0MsNkJBQTZCO0FBQ3JFO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsS0FBSztBQUNuRCw2Q0FBNkMsS0FBSywwQ0FBMEMsSUFBSTtBQUNoRztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxJQUEwQjtBQUNwQztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bob3R3aXJlZC9zdGltdWx1cy9kaXN0L3N0aW11bHVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac3ltZm9ueS9zdGltdWx1cy1icmlkZ2UvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYS1jYWxsYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYS1jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYS1wb3NzaWJsZS1wcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FkZC10by11bnNjb3BhYmxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1zbGljZS1zaW1wbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LXNsaWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi1yYXcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvcHktY29uc3RydWN0b3ItcHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29ycmVjdC1wcm90b3R5cGUtZ2V0dGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtaXRlci1yZXN1bHQtb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RhdGUtdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4tYWNjZXNzb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLWdsb2JhbC1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RvY3VtZW50LWFsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RvbS1pdGVyYWJsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RvbS10b2tlbi1saXN0LXByb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW5naW5lLXVzZXItYWdlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VuZ2luZS12OC12ZXJzaW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lcnJvci1zdGFjay1jbGVhci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXJyb3Itc3RhY2staW5zdGFsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXJyb3Itc3RhY2staW5zdGFsbGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Vycm9yLXRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tYXBwbHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtY29udGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1uYXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLW5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy1hY2Nlc3Nvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzLWNsYXVzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtYnVpbHQtaW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1qc29uLXJlcGxhY2VyLWZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtbWV0aG9kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hpZGRlbi1rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9odG1sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pZTgtZG9tLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2luaGVyaXQtaWYtcmVxdWlyZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2luc3BlY3Qtc291cmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnN0YWxsLWVycm9yLWNhdXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWNhbGxhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtZm9yY2VkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1udWxsLW9yLXVuZGVmaW5lZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1wdXJlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9yLWNyZWF0ZS1jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3ItZGVmaW5lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvcnMtY29yZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9sZW5ndGgtb2YtYXJyYXktbGlrZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbWFrZS1idWlsdC1pbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbWF0aC10cnVuYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbm9ybWFsaXplLXN0cmluZy1hcmd1bWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWFzc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0aWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy1leHRlcm5hbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtaXMtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qtc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb3JkaW5hcnktdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vd24ta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcHJveHktYWNjZXNzb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC1rZXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC1zdG9yZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zdHJpbmctbXVsdGlieXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zdHJpbmctdHJpbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3ltYm9sLWNvbnN0cnVjdG9yLWRldGVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3ltYm9sLWRlZmluZS10by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3N5bWJvbC1yZWdpc3RyeS1kZXRlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RoaXMtbnVtYmVyLXZhbHVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWludGVnZXItb3ItaW5maW5pdHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWxlbmd0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXByb3BlcnR5LWtleS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tc3RyaW5nLXRhZy1zdXBwb3J0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RyeS10by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3VpZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdXNlLXN5bWJvbC1hcy11aWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3Y4LXByb3RvdHlwZS1kZWZpbmUtYnVnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWFrLW1hcC1iYXNpYy1kZXRlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wtd3JhcHBlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3doaXRlc3BhY2VzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93cmFwLWVycm9yLWNvbnN0cnVjdG9yLXdpdGgtY2F1c2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmRhdGUudG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuZXJyb3IuY2F1c2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5lcnJvci50by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5mdW5jdGlvbi5iaW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuanNvbi5zdHJpbmdpZnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5udW1iZXIuY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuYXNzaWduLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5yZWZsZWN0LmNvbnN0cnVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnJlZmxlY3QudG8tc3RyaW5nLXRhZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5mb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wua2V5LWZvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC50by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90aW55bWNlL3RpbnltY2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcblN0aW11bHVzIDMuMi4xXG5Db3B5cmlnaHQgwqkgMjAyMiBCYXNlY2FtcCwgTExDXG4gKi9cbmNsYXNzIEV2ZW50TGlzdGVuZXIge1xuICAgIGNvbnN0cnVjdG9yKGV2ZW50VGFyZ2V0LCBldmVudE5hbWUsIGV2ZW50T3B0aW9ucykge1xuICAgICAgICB0aGlzLmV2ZW50VGFyZ2V0ID0gZXZlbnRUYXJnZXQ7XG4gICAgICAgIHRoaXMuZXZlbnROYW1lID0gZXZlbnROYW1lO1xuICAgICAgICB0aGlzLmV2ZW50T3B0aW9ucyA9IGV2ZW50T3B0aW9ucztcbiAgICAgICAgdGhpcy51bm9yZGVyZWRCaW5kaW5ncyA9IG5ldyBTZXQoKTtcbiAgICB9XG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5ldmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyKHRoaXMuZXZlbnROYW1lLCB0aGlzLCB0aGlzLmV2ZW50T3B0aW9ucyk7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuZXZlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLmV2ZW50TmFtZSwgdGhpcywgdGhpcy5ldmVudE9wdGlvbnMpO1xuICAgIH1cbiAgICBiaW5kaW5nQ29ubmVjdGVkKGJpbmRpbmcpIHtcbiAgICAgICAgdGhpcy51bm9yZGVyZWRCaW5kaW5ncy5hZGQoYmluZGluZyk7XG4gICAgfVxuICAgIGJpbmRpbmdEaXNjb25uZWN0ZWQoYmluZGluZykge1xuICAgICAgICB0aGlzLnVub3JkZXJlZEJpbmRpbmdzLmRlbGV0ZShiaW5kaW5nKTtcbiAgICB9XG4gICAgaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgZXh0ZW5kZWRFdmVudCA9IGV4dGVuZEV2ZW50KGV2ZW50KTtcbiAgICAgICAgZm9yIChjb25zdCBiaW5kaW5nIG9mIHRoaXMuYmluZGluZ3MpIHtcbiAgICAgICAgICAgIGlmIChleHRlbmRlZEV2ZW50LmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYmluZGluZy5oYW5kbGVFdmVudChleHRlbmRlZEV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNCaW5kaW5ncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5vcmRlcmVkQmluZGluZ3Muc2l6ZSA+IDA7XG4gICAgfVxuICAgIGdldCBiaW5kaW5ncygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy51bm9yZGVyZWRCaW5kaW5ncykuc29ydCgobGVmdCwgcmlnaHQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxlZnRJbmRleCA9IGxlZnQuaW5kZXgsIHJpZ2h0SW5kZXggPSByaWdodC5pbmRleDtcbiAgICAgICAgICAgIHJldHVybiBsZWZ0SW5kZXggPCByaWdodEluZGV4ID8gLTEgOiBsZWZ0SW5kZXggPiByaWdodEluZGV4ID8gMSA6IDA7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGV4dGVuZEV2ZW50KGV2ZW50KSB7XG4gICAgaWYgKFwiaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkXCIgaW4gZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgeyBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gfSA9IGV2ZW50O1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihldmVudCwge1xuICAgICAgICAgICAgaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiBmYWxzZSxcbiAgICAgICAgICAgIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNsYXNzIERpc3BhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKGFwcGxpY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuYXBwbGljYXRpb24gPSBhcHBsaWNhdGlvbjtcbiAgICAgICAgdGhpcy5ldmVudExpc3RlbmVyTWFwcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMuZm9yRWFjaCgoZXZlbnRMaXN0ZW5lcikgPT4gZXZlbnRMaXN0ZW5lci5jb25uZWN0KCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5ldmVudExpc3RlbmVycy5mb3JFYWNoKChldmVudExpc3RlbmVyKSA9PiBldmVudExpc3RlbmVyLmRpc2Nvbm5lY3QoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmV2ZW50TGlzdGVuZXJNYXBzLnZhbHVlcygpKS5yZWR1Y2UoKGxpc3RlbmVycywgbWFwKSA9PiBsaXN0ZW5lcnMuY29uY2F0KEFycmF5LmZyb20obWFwLnZhbHVlcygpKSksIFtdKTtcbiAgICB9XG4gICAgYmluZGluZ0Nvbm5lY3RlZChiaW5kaW5nKSB7XG4gICAgICAgIHRoaXMuZmV0Y2hFdmVudExpc3RlbmVyRm9yQmluZGluZyhiaW5kaW5nKS5iaW5kaW5nQ29ubmVjdGVkKGJpbmRpbmcpO1xuICAgIH1cbiAgICBiaW5kaW5nRGlzY29ubmVjdGVkKGJpbmRpbmcsIGNsZWFyRXZlbnRMaXN0ZW5lcnMgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmZldGNoRXZlbnRMaXN0ZW5lckZvckJpbmRpbmcoYmluZGluZykuYmluZGluZ0Rpc2Nvbm5lY3RlZChiaW5kaW5nKTtcbiAgICAgICAgaWYgKGNsZWFyRXZlbnRMaXN0ZW5lcnMpXG4gICAgICAgICAgICB0aGlzLmNsZWFyRXZlbnRMaXN0ZW5lcnNGb3JCaW5kaW5nKGJpbmRpbmcpO1xuICAgIH1cbiAgICBoYW5kbGVFcnJvcihlcnJvciwgbWVzc2FnZSwgZGV0YWlsID0ge30pIHtcbiAgICAgICAgdGhpcy5hcHBsaWNhdGlvbi5oYW5kbGVFcnJvcihlcnJvciwgYEVycm9yICR7bWVzc2FnZX1gLCBkZXRhaWwpO1xuICAgIH1cbiAgICBjbGVhckV2ZW50TGlzdGVuZXJzRm9yQmluZGluZyhiaW5kaW5nKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50TGlzdGVuZXIgPSB0aGlzLmZldGNoRXZlbnRMaXN0ZW5lckZvckJpbmRpbmcoYmluZGluZyk7XG4gICAgICAgIGlmICghZXZlbnRMaXN0ZW5lci5oYXNCaW5kaW5ncygpKSB7XG4gICAgICAgICAgICBldmVudExpc3RlbmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTWFwcGVkRXZlbnRMaXN0ZW5lckZvcihiaW5kaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVNYXBwZWRFdmVudExpc3RlbmVyRm9yKGJpbmRpbmcpIHtcbiAgICAgICAgY29uc3QgeyBldmVudFRhcmdldCwgZXZlbnROYW1lLCBldmVudE9wdGlvbnMgfSA9IGJpbmRpbmc7XG4gICAgICAgIGNvbnN0IGV2ZW50TGlzdGVuZXJNYXAgPSB0aGlzLmZldGNoRXZlbnRMaXN0ZW5lck1hcEZvckV2ZW50VGFyZ2V0KGV2ZW50VGFyZ2V0KTtcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLmNhY2hlS2V5KGV2ZW50TmFtZSwgZXZlbnRPcHRpb25zKTtcbiAgICAgICAgZXZlbnRMaXN0ZW5lck1hcC5kZWxldGUoY2FjaGVLZXkpO1xuICAgICAgICBpZiAoZXZlbnRMaXN0ZW5lck1hcC5zaXplID09IDApXG4gICAgICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJNYXBzLmRlbGV0ZShldmVudFRhcmdldCk7XG4gICAgfVxuICAgIGZldGNoRXZlbnRMaXN0ZW5lckZvckJpbmRpbmcoYmluZGluZykge1xuICAgICAgICBjb25zdCB7IGV2ZW50VGFyZ2V0LCBldmVudE5hbWUsIGV2ZW50T3B0aW9ucyB9ID0gYmluZGluZztcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hFdmVudExpc3RlbmVyKGV2ZW50VGFyZ2V0LCBldmVudE5hbWUsIGV2ZW50T3B0aW9ucyk7XG4gICAgfVxuICAgIGZldGNoRXZlbnRMaXN0ZW5lcihldmVudFRhcmdldCwgZXZlbnROYW1lLCBldmVudE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZXZlbnRMaXN0ZW5lck1hcCA9IHRoaXMuZmV0Y2hFdmVudExpc3RlbmVyTWFwRm9yRXZlbnRUYXJnZXQoZXZlbnRUYXJnZXQpO1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMuY2FjaGVLZXkoZXZlbnROYW1lLCBldmVudE9wdGlvbnMpO1xuICAgICAgICBsZXQgZXZlbnRMaXN0ZW5lciA9IGV2ZW50TGlzdGVuZXJNYXAuZ2V0KGNhY2hlS2V5KTtcbiAgICAgICAgaWYgKCFldmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBldmVudExpc3RlbmVyID0gdGhpcy5jcmVhdGVFdmVudExpc3RlbmVyKGV2ZW50VGFyZ2V0LCBldmVudE5hbWUsIGV2ZW50T3B0aW9ucyk7XG4gICAgICAgICAgICBldmVudExpc3RlbmVyTWFwLnNldChjYWNoZUtleSwgZXZlbnRMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50TGlzdGVuZXI7XG4gICAgfVxuICAgIGNyZWF0ZUV2ZW50TGlzdGVuZXIoZXZlbnRUYXJnZXQsIGV2ZW50TmFtZSwgZXZlbnRPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50TGlzdGVuZXIgPSBuZXcgRXZlbnRMaXN0ZW5lcihldmVudFRhcmdldCwgZXZlbnROYW1lLCBldmVudE9wdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICBldmVudExpc3RlbmVyLmNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZlbnRMaXN0ZW5lcjtcbiAgICB9XG4gICAgZmV0Y2hFdmVudExpc3RlbmVyTWFwRm9yRXZlbnRUYXJnZXQoZXZlbnRUYXJnZXQpIHtcbiAgICAgICAgbGV0IGV2ZW50TGlzdGVuZXJNYXAgPSB0aGlzLmV2ZW50TGlzdGVuZXJNYXBzLmdldChldmVudFRhcmdldCk7XG4gICAgICAgIGlmICghZXZlbnRMaXN0ZW5lck1hcCkge1xuICAgICAgICAgICAgZXZlbnRMaXN0ZW5lck1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lck1hcHMuc2V0KGV2ZW50VGFyZ2V0LCBldmVudExpc3RlbmVyTWFwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZlbnRMaXN0ZW5lck1hcDtcbiAgICB9XG4gICAgY2FjaGVLZXkoZXZlbnROYW1lLCBldmVudE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcGFydHMgPSBbZXZlbnROYW1lXTtcbiAgICAgICAgT2JqZWN0LmtleXMoZXZlbnRPcHRpb25zKVxuICAgICAgICAgICAgLnNvcnQoKVxuICAgICAgICAgICAgLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgcGFydHMucHVzaChgJHtldmVudE9wdGlvbnNba2V5XSA/IFwiXCIgOiBcIiFcIn0ke2tleX1gKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKFwiOlwiKTtcbiAgICB9XG59XG5cbmNvbnN0IGRlZmF1bHRBY3Rpb25EZXNjcmlwdG9yRmlsdGVycyA9IHtcbiAgICBzdG9wKHsgZXZlbnQsIHZhbHVlIH0pIHtcbiAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgcHJldmVudCh7IGV2ZW50LCB2YWx1ZSB9KSB7XG4gICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgc2VsZih7IGV2ZW50LCB2YWx1ZSwgZWxlbWVudCB9KSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQgPT09IGV2ZW50LnRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5jb25zdCBkZXNjcmlwdG9yUGF0dGVybiA9IC9eKD86KC4rPykoPzpcXC4oLis/KSk/KD86QCh3aW5kb3d8ZG9jdW1lbnQpKT8tPik/KC4rPykoPzojKFteOl0rPykpKD86OiguKykpPyQvO1xuZnVuY3Rpb24gcGFyc2VBY3Rpb25EZXNjcmlwdG9yU3RyaW5nKGRlc2NyaXB0b3JTdHJpbmcpIHtcbiAgICBjb25zdCBzb3VyY2UgPSBkZXNjcmlwdG9yU3RyaW5nLnRyaW0oKTtcbiAgICBjb25zdCBtYXRjaGVzID0gc291cmNlLm1hdGNoKGRlc2NyaXB0b3JQYXR0ZXJuKSB8fCBbXTtcbiAgICBsZXQgZXZlbnROYW1lID0gbWF0Y2hlc1sxXTtcbiAgICBsZXQga2V5RmlsdGVyID0gbWF0Y2hlc1syXTtcbiAgICBpZiAoa2V5RmlsdGVyICYmICFbXCJrZXlkb3duXCIsIFwia2V5dXBcIiwgXCJrZXlwcmVzc1wiXS5pbmNsdWRlcyhldmVudE5hbWUpKSB7XG4gICAgICAgIGV2ZW50TmFtZSArPSBgLiR7a2V5RmlsdGVyfWA7XG4gICAgICAgIGtleUZpbHRlciA9IFwiXCI7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGV2ZW50VGFyZ2V0OiBwYXJzZUV2ZW50VGFyZ2V0KG1hdGNoZXNbM10pLFxuICAgICAgICBldmVudE5hbWUsXG4gICAgICAgIGV2ZW50T3B0aW9uczogbWF0Y2hlc1s2XSA/IHBhcnNlRXZlbnRPcHRpb25zKG1hdGNoZXNbNl0pIDoge30sXG4gICAgICAgIGlkZW50aWZpZXI6IG1hdGNoZXNbNF0sXG4gICAgICAgIG1ldGhvZE5hbWU6IG1hdGNoZXNbNV0sXG4gICAgICAgIGtleUZpbHRlcixcbiAgICB9O1xufVxuZnVuY3Rpb24gcGFyc2VFdmVudFRhcmdldChldmVudFRhcmdldE5hbWUpIHtcbiAgICBpZiAoZXZlbnRUYXJnZXROYW1lID09IFwid2luZG93XCIpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICB9XG4gICAgZWxzZSBpZiAoZXZlbnRUYXJnZXROYW1lID09IFwiZG9jdW1lbnRcIikge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VFdmVudE9wdGlvbnMoZXZlbnRPcHRpb25zKSB7XG4gICAgcmV0dXJuIGV2ZW50T3B0aW9uc1xuICAgICAgICAuc3BsaXQoXCI6XCIpXG4gICAgICAgIC5yZWR1Y2UoKG9wdGlvbnMsIHRva2VuKSA9PiBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHsgW3Rva2VuLnJlcGxhY2UoL14hLywgXCJcIildOiAhL14hLy50ZXN0KHRva2VuKSB9KSwge30pO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5RXZlbnRUYXJnZXQoZXZlbnRUYXJnZXQpIHtcbiAgICBpZiAoZXZlbnRUYXJnZXQgPT0gd2luZG93KSB7XG4gICAgICAgIHJldHVybiBcIndpbmRvd1wiO1xuICAgIH1cbiAgICBlbHNlIGlmIChldmVudFRhcmdldCA9PSBkb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gXCJkb2N1bWVudFwiO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY2FtZWxpemUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvKD86W18tXSkoW2EtejAtOV0pL2csIChfLCBjaGFyKSA9PiBjaGFyLnRvVXBwZXJDYXNlKCkpO1xufVxuZnVuY3Rpb24gbmFtZXNwYWNlQ2FtZWxpemUodmFsdWUpIHtcbiAgICByZXR1cm4gY2FtZWxpemUodmFsdWUucmVwbGFjZSgvLS0vZywgXCItXCIpLnJlcGxhY2UoL19fL2csIFwiX1wiKSk7XG59XG5mdW5jdGlvbiBjYXBpdGFsaXplKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdmFsdWUuc2xpY2UoMSk7XG59XG5mdW5jdGlvbiBkYXNoZXJpemUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvKFtBLVpdKS9nLCAoXywgY2hhcikgPT4gYC0ke2NoYXIudG9Mb3dlckNhc2UoKX1gKTtcbn1cbmZ1bmN0aW9uIHRva2VuaXplKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLm1hdGNoKC9bXlxcc10rL2cpIHx8IFtdO1xufVxuXG5jbGFzcyBBY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGluZGV4LCBkZXNjcmlwdG9yLCBzY2hlbWEpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLmV2ZW50VGFyZ2V0ID0gZGVzY3JpcHRvci5ldmVudFRhcmdldCB8fCBlbGVtZW50O1xuICAgICAgICB0aGlzLmV2ZW50TmFtZSA9IGRlc2NyaXB0b3IuZXZlbnROYW1lIHx8IGdldERlZmF1bHRFdmVudE5hbWVGb3JFbGVtZW50KGVsZW1lbnQpIHx8IGVycm9yKFwibWlzc2luZyBldmVudCBuYW1lXCIpO1xuICAgICAgICB0aGlzLmV2ZW50T3B0aW9ucyA9IGRlc2NyaXB0b3IuZXZlbnRPcHRpb25zIHx8IHt9O1xuICAgICAgICB0aGlzLmlkZW50aWZpZXIgPSBkZXNjcmlwdG9yLmlkZW50aWZpZXIgfHwgZXJyb3IoXCJtaXNzaW5nIGlkZW50aWZpZXJcIik7XG4gICAgICAgIHRoaXMubWV0aG9kTmFtZSA9IGRlc2NyaXB0b3IubWV0aG9kTmFtZSB8fCBlcnJvcihcIm1pc3NpbmcgbWV0aG9kIG5hbWVcIik7XG4gICAgICAgIHRoaXMua2V5RmlsdGVyID0gZGVzY3JpcHRvci5rZXlGaWx0ZXIgfHwgXCJcIjtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgfVxuICAgIHN0YXRpYyBmb3JUb2tlbih0b2tlbiwgc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyh0b2tlbi5lbGVtZW50LCB0b2tlbi5pbmRleCwgcGFyc2VBY3Rpb25EZXNjcmlwdG9yU3RyaW5nKHRva2VuLmNvbnRlbnQpLCBzY2hlbWEpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgY29uc3QgZXZlbnRGaWx0ZXIgPSB0aGlzLmtleUZpbHRlciA/IGAuJHt0aGlzLmtleUZpbHRlcn1gIDogXCJcIjtcbiAgICAgICAgY29uc3QgZXZlbnRUYXJnZXQgPSB0aGlzLmV2ZW50VGFyZ2V0TmFtZSA/IGBAJHt0aGlzLmV2ZW50VGFyZ2V0TmFtZX1gIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuZXZlbnROYW1lfSR7ZXZlbnRGaWx0ZXJ9JHtldmVudFRhcmdldH0tPiR7dGhpcy5pZGVudGlmaWVyfSMke3RoaXMubWV0aG9kTmFtZX1gO1xuICAgIH1cbiAgICBpc0ZpbHRlclRhcmdldChldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMua2V5RmlsdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlsdGVyZXMgPSB0aGlzLmtleUZpbHRlci5zcGxpdChcIitcIik7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVycyA9IFtcIm1ldGFcIiwgXCJjdHJsXCIsIFwiYWx0XCIsIFwic2hpZnRcIl07XG4gICAgICAgIGNvbnN0IFttZXRhLCBjdHJsLCBhbHQsIHNoaWZ0XSA9IG1vZGlmaWVycy5tYXAoKG1vZGlmaWVyKSA9PiBmaWx0ZXJlcy5pbmNsdWRlcyhtb2RpZmllcikpO1xuICAgICAgICBpZiAoZXZlbnQubWV0YUtleSAhPT0gbWV0YSB8fCBldmVudC5jdHJsS2V5ICE9PSBjdHJsIHx8IGV2ZW50LmFsdEtleSAhPT0gYWx0IHx8IGV2ZW50LnNoaWZ0S2V5ICE9PSBzaGlmdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhbmRhcmRGaWx0ZXIgPSBmaWx0ZXJlcy5maWx0ZXIoKGtleSkgPT4gIW1vZGlmaWVycy5pbmNsdWRlcyhrZXkpKVswXTtcbiAgICAgICAgaWYgKCFzdGFuZGFyZEZpbHRlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMua2V5TWFwcGluZ3MsIHN0YW5kYXJkRmlsdGVyKSkge1xuICAgICAgICAgICAgZXJyb3IoYGNvbnRhaW5zIHVua25vd24ga2V5IGZpbHRlcjogJHt0aGlzLmtleUZpbHRlcn1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5rZXlNYXBwaW5nc1tzdGFuZGFyZEZpbHRlcl0udG9Mb3dlckNhc2UoKSAhPT0gZXZlbnQua2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIGdldCBwYXJhbXMoKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHt9O1xuICAgICAgICBjb25zdCBwYXR0ZXJuID0gbmV3IFJlZ0V4cChgXmRhdGEtJHt0aGlzLmlkZW50aWZpZXJ9LSguKyktcGFyYW0kYCwgXCJpXCIpO1xuICAgICAgICBmb3IgKGNvbnN0IHsgbmFtZSwgdmFsdWUgfSBvZiBBcnJheS5mcm9tKHRoaXMuZWxlbWVudC5hdHRyaWJ1dGVzKSkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBuYW1lLm1hdGNoKHBhdHRlcm4pO1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gbWF0Y2ggJiYgbWF0Y2hbMV07XG4gICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zW2NhbWVsaXplKGtleSldID0gdHlwZWNhc3QodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIGdldCBldmVudFRhcmdldE5hbWUoKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlFdmVudFRhcmdldCh0aGlzLmV2ZW50VGFyZ2V0KTtcbiAgICB9XG4gICAgZ2V0IGtleU1hcHBpbmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2hlbWEua2V5TWFwcGluZ3M7XG4gICAgfVxufVxuY29uc3QgZGVmYXVsdEV2ZW50TmFtZXMgPSB7XG4gICAgYTogKCkgPT4gXCJjbGlja1wiLFxuICAgIGJ1dHRvbjogKCkgPT4gXCJjbGlja1wiLFxuICAgIGZvcm06ICgpID0+IFwic3VibWl0XCIsXG4gICAgZGV0YWlsczogKCkgPT4gXCJ0b2dnbGVcIixcbiAgICBpbnB1dDogKGUpID0+IChlLmdldEF0dHJpYnV0ZShcInR5cGVcIikgPT0gXCJzdWJtaXRcIiA/IFwiY2xpY2tcIiA6IFwiaW5wdXRcIiksXG4gICAgc2VsZWN0OiAoKSA9PiBcImNoYW5nZVwiLFxuICAgIHRleHRhcmVhOiAoKSA9PiBcImlucHV0XCIsXG59O1xuZnVuY3Rpb24gZ2V0RGVmYXVsdEV2ZW50TmFtZUZvckVsZW1lbnQoZWxlbWVudCkge1xuICAgIGNvbnN0IHRhZ05hbWUgPSBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAodGFnTmFtZSBpbiBkZWZhdWx0RXZlbnROYW1lcykge1xuICAgICAgICByZXR1cm4gZGVmYXVsdEV2ZW50TmFtZXNbdGFnTmFtZV0oZWxlbWVudCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZXJyb3IobWVzc2FnZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbn1cbmZ1bmN0aW9uIHR5cGVjYXN0KHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAob19PKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG5cbmNsYXNzIEJpbmRpbmcge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIGFjdGlvbikge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmFjdGlvbiA9IGFjdGlvbjtcbiAgICB9XG4gICAgZ2V0IGluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3Rpb24uaW5kZXg7XG4gICAgfVxuICAgIGdldCBldmVudFRhcmdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aW9uLmV2ZW50VGFyZ2V0O1xuICAgIH1cbiAgICBnZXQgZXZlbnRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3Rpb24uZXZlbnRPcHRpb25zO1xuICAgIH1cbiAgICBnZXQgaWRlbnRpZmllcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5pZGVudGlmaWVyO1xuICAgIH1cbiAgICBoYW5kbGVFdmVudChldmVudCkge1xuICAgICAgICBpZiAodGhpcy53aWxsQmVJbnZva2VkQnlFdmVudChldmVudCkgJiYgdGhpcy5hcHBseUV2ZW50TW9kaWZpZXJzKGV2ZW50KSkge1xuICAgICAgICAgICAgdGhpcy5pbnZva2VXaXRoRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBldmVudE5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGlvbi5ldmVudE5hbWU7XG4gICAgfVxuICAgIGdldCBtZXRob2QoKSB7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IHRoaXMuY29udHJvbGxlclt0aGlzLm1ldGhvZE5hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2Q7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBY3Rpb24gXCIke3RoaXMuYWN0aW9ufVwiIHJlZmVyZW5jZXMgdW5kZWZpbmVkIG1ldGhvZCBcIiR7dGhpcy5tZXRob2ROYW1lfVwiYCk7XG4gICAgfVxuICAgIGFwcGx5RXZlbnRNb2RpZmllcnMoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgeyBlbGVtZW50IH0gPSB0aGlzLmFjdGlvbjtcbiAgICAgICAgY29uc3QgeyBhY3Rpb25EZXNjcmlwdG9yRmlsdGVycyB9ID0gdGhpcy5jb250ZXh0LmFwcGxpY2F0aW9uO1xuICAgICAgICBsZXQgcGFzc2VzID0gdHJ1ZTtcbiAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuZXZlbnRPcHRpb25zKSkge1xuICAgICAgICAgICAgaWYgKG5hbWUgaW4gYWN0aW9uRGVzY3JpcHRvckZpbHRlcnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXIgPSBhY3Rpb25EZXNjcmlwdG9yRmlsdGVyc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBwYXNzZXMgPSBwYXNzZXMgJiYgZmlsdGVyKHsgbmFtZSwgdmFsdWUsIGV2ZW50LCBlbGVtZW50IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhc3NlcztcbiAgICB9XG4gICAgaW52b2tlV2l0aEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHsgdGFyZ2V0LCBjdXJyZW50VGFyZ2V0IH0gPSBldmVudDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcGFyYW1zIH0gPSB0aGlzLmFjdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbkV2ZW50ID0gT2JqZWN0LmFzc2lnbihldmVudCwgeyBwYXJhbXMgfSk7XG4gICAgICAgICAgICB0aGlzLm1ldGhvZC5jYWxsKHRoaXMuY29udHJvbGxlciwgYWN0aW9uRXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmxvZ0RlYnVnQWN0aXZpdHkodGhpcy5tZXRob2ROYW1lLCB7IGV2ZW50LCB0YXJnZXQsIGN1cnJlbnRUYXJnZXQsIGFjdGlvbjogdGhpcy5tZXRob2ROYW1lIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgeyBpZGVudGlmaWVyLCBjb250cm9sbGVyLCBlbGVtZW50LCBpbmRleCB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGRldGFpbCA9IHsgaWRlbnRpZmllciwgY29udHJvbGxlciwgZWxlbWVudCwgaW5kZXgsIGV2ZW50IH07XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuaGFuZGxlRXJyb3IoZXJyb3IsIGBpbnZva2luZyBhY3Rpb24gXCIke3RoaXMuYWN0aW9ufVwiYCwgZGV0YWlsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aWxsQmVJbnZva2VkQnlFdmVudChldmVudCkge1xuICAgICAgICBjb25zdCBldmVudFRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgS2V5Ym9hcmRFdmVudCAmJiB0aGlzLmFjdGlvbi5pc0ZpbHRlclRhcmdldChldmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lbGVtZW50ID09PSBldmVudFRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXZlbnRUYXJnZXQgaW5zdGFuY2VvZiBFbGVtZW50ICYmIHRoaXMuZWxlbWVudC5jb250YWlucyhldmVudFRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjb3BlLmNvbnRhaW5zRWxlbWVudChldmVudFRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY29wZS5jb250YWluc0VsZW1lbnQodGhpcy5hY3Rpb24uZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGNvbnRyb2xsZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuY29udHJvbGxlcjtcbiAgICB9XG4gICAgZ2V0IG1ldGhvZE5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGlvbi5tZXRob2ROYW1lO1xuICAgIH1cbiAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGUuZWxlbWVudDtcbiAgICB9XG4gICAgZ2V0IHNjb3BlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LnNjb3BlO1xuICAgIH1cbn1cblxuY2xhc3MgRWxlbWVudE9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBkZWxlZ2F0ZSkge1xuICAgICAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXJJbml0ID0geyBhdHRyaWJ1dGVzOiB0cnVlLCBjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWUgfTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgICAgICAgdGhpcy5lbGVtZW50cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKG11dGF0aW9ucykgPT4gdGhpcy5wcm9jZXNzTXV0YXRpb25zKG11dGF0aW9ucykpO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmVsZW1lbnQsIHRoaXMubXV0YXRpb25PYnNlcnZlckluaXQpO1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGF1c2UoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIGlmICghdGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmVsZW1lbnQsIHRoaXMubXV0YXRpb25PYnNlcnZlckluaXQpO1xuICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWZyZXNoKCkge1xuICAgICAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gbmV3IFNldCh0aGlzLm1hdGNoRWxlbWVudHNJblRyZWUoKSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgQXJyYXkuZnJvbSh0aGlzLmVsZW1lbnRzKSkge1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlcy5oYXMoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBBcnJheS5mcm9tKG1hdGNoZXMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHByb2Nlc3NNdXRhdGlvbnMobXV0YXRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgbXV0YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzTXV0YXRpb24obXV0YXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHByb2Nlc3NNdXRhdGlvbihtdXRhdGlvbikge1xuICAgICAgICBpZiAobXV0YXRpb24udHlwZSA9PSBcImF0dHJpYnV0ZXNcIikge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzQXR0cmlidXRlQ2hhbmdlKG11dGF0aW9uLnRhcmdldCwgbXV0YXRpb24uYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobXV0YXRpb24udHlwZSA9PSBcImNoaWxkTGlzdFwiKSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NSZW1vdmVkTm9kZXMobXV0YXRpb24ucmVtb3ZlZE5vZGVzKTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0FkZGVkTm9kZXMobXV0YXRpb24uYWRkZWROb2Rlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvY2Vzc0F0dHJpYnV0ZUNoYW5nZShub2RlLCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBub2RlO1xuICAgICAgICBpZiAodGhpcy5lbGVtZW50cy5oYXMoZWxlbWVudCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlbGVnYXRlLmVsZW1lbnRBdHRyaWJ1dGVDaGFuZ2VkICYmIHRoaXMubWF0Y2hFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5lbGVtZW50QXR0cmlidXRlQ2hhbmdlZChlbGVtZW50LCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgICAgICAgdGhpcy5hZGRFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb2Nlc3NSZW1vdmVkTm9kZXMobm9kZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIEFycmF5LmZyb20obm9kZXMpKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50RnJvbU5vZGUobm9kZSk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc1RyZWUoZWxlbWVudCwgdGhpcy5yZW1vdmVFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm9jZXNzQWRkZWROb2Rlcyhub2Rlcykge1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgQXJyYXkuZnJvbShub2RlcykpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRGcm9tTm9kZShub2RlKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIHRoaXMuZWxlbWVudElzQWN0aXZlKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzVHJlZShlbGVtZW50LCB0aGlzLmFkZEVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG1hdGNoRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLm1hdGNoRWxlbWVudChlbGVtZW50KTtcbiAgICB9XG4gICAgbWF0Y2hFbGVtZW50c0luVHJlZSh0cmVlID0gdGhpcy5lbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLm1hdGNoRWxlbWVudHNJblRyZWUodHJlZSk7XG4gICAgfVxuICAgIHByb2Nlc3NUcmVlKHRyZWUsIHByb2Nlc3Nvcikge1xuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy5tYXRjaEVsZW1lbnRzSW5UcmVlKHRyZWUpKSB7XG4gICAgICAgICAgICBwcm9jZXNzb3IuY2FsbCh0aGlzLCBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbGVtZW50RnJvbU5vZGUobm9kZSkge1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxlbWVudElzQWN0aXZlKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuaXNDb25uZWN0ZWQgIT0gdGhpcy5lbGVtZW50LmlzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50LmNvbnRhaW5zKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICBpZiAoIXRoaXMuZWxlbWVudHMuaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lbGVtZW50SXNBY3RpdmUoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRzLmFkZChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZS5lbGVtZW50TWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlLmVsZW1lbnRNYXRjaGVkKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudHMuaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzLmRlbGV0ZShlbGVtZW50KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlbGVnYXRlLmVsZW1lbnRVbm1hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlLmVsZW1lbnRVbm1hdGNoZWQoZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIEF0dHJpYnV0ZU9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBhdHRyaWJ1dGVOYW1lLCBkZWxlZ2F0ZSkge1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGVOYW1lO1xuICAgICAgICB0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XG4gICAgICAgIHRoaXMuZWxlbWVudE9ic2VydmVyID0gbmV3IEVsZW1lbnRPYnNlcnZlcihlbGVtZW50LCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRPYnNlcnZlci5lbGVtZW50O1xuICAgIH1cbiAgICBnZXQgc2VsZWN0b3IoKSB7XG4gICAgICAgIHJldHVybiBgWyR7dGhpcy5hdHRyaWJ1dGVOYW1lfV1gO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50T2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICB9XG4gICAgcGF1c2UoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5lbGVtZW50T2JzZXJ2ZXIucGF1c2UoY2FsbGJhY2spO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICB0aGlzLmVsZW1lbnRPYnNlcnZlci5zdG9wKCk7XG4gICAgfVxuICAgIHJlZnJlc2goKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudE9ic2VydmVyLnJlZnJlc2goKTtcbiAgICB9XG4gICAgZ2V0IHN0YXJ0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRPYnNlcnZlci5zdGFydGVkO1xuICAgIH1cbiAgICBtYXRjaEVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZWxlbWVudC5oYXNBdHRyaWJ1dGUodGhpcy5hdHRyaWJ1dGVOYW1lKTtcbiAgICB9XG4gICAgbWF0Y2hFbGVtZW50c0luVHJlZSh0cmVlKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdGhpcy5tYXRjaEVsZW1lbnQodHJlZSkgPyBbdHJlZV0gOiBbXTtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IEFycmF5LmZyb20odHJlZS5xdWVyeVNlbGVjdG9yQWxsKHRoaXMuc2VsZWN0b3IpKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoLmNvbmNhdChtYXRjaGVzKTtcbiAgICB9XG4gICAgZWxlbWVudE1hdGNoZWQoZWxlbWVudCkge1xuICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZS5lbGVtZW50TWF0Y2hlZEF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5lbGVtZW50TWF0Y2hlZEF0dHJpYnV0ZShlbGVtZW50LCB0aGlzLmF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsZW1lbnRVbm1hdGNoZWQoZWxlbWVudCkge1xuICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZS5lbGVtZW50VW5tYXRjaGVkQXR0cmlidXRlKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLmVsZW1lbnRVbm1hdGNoZWRBdHRyaWJ1dGUoZWxlbWVudCwgdGhpcy5hdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbGVtZW50QXR0cmlidXRlQ2hhbmdlZChlbGVtZW50LCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmRlbGVnYXRlLmVsZW1lbnRBdHRyaWJ1dGVWYWx1ZUNoYW5nZWQgJiYgdGhpcy5hdHRyaWJ1dGVOYW1lID09IGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUuZWxlbWVudEF0dHJpYnV0ZVZhbHVlQ2hhbmdlZChlbGVtZW50LCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gYWRkKG1hcCwga2V5LCB2YWx1ZSkge1xuICAgIGZldGNoKG1hcCwga2V5KS5hZGQodmFsdWUpO1xufVxuZnVuY3Rpb24gZGVsKG1hcCwga2V5LCB2YWx1ZSkge1xuICAgIGZldGNoKG1hcCwga2V5KS5kZWxldGUodmFsdWUpO1xuICAgIHBydW5lKG1hcCwga2V5KTtcbn1cbmZ1bmN0aW9uIGZldGNoKG1hcCwga2V5KSB7XG4gICAgbGV0IHZhbHVlcyA9IG1hcC5nZXQoa2V5KTtcbiAgICBpZiAoIXZhbHVlcykge1xuICAgICAgICB2YWx1ZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIG1hcC5zZXQoa2V5LCB2YWx1ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xufVxuZnVuY3Rpb24gcHJ1bmUobWFwLCBrZXkpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBtYXAuZ2V0KGtleSk7XG4gICAgaWYgKHZhbHVlcyAhPSBudWxsICYmIHZhbHVlcy5zaXplID09IDApIHtcbiAgICAgICAgbWFwLmRlbGV0ZShrZXkpO1xuICAgIH1cbn1cblxuY2xhc3MgTXVsdGltYXAge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZhbHVlc0J5S2V5ID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBnZXQga2V5cygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy52YWx1ZXNCeUtleS5rZXlzKCkpO1xuICAgIH1cbiAgICBnZXQgdmFsdWVzKCkge1xuICAgICAgICBjb25zdCBzZXRzID0gQXJyYXkuZnJvbSh0aGlzLnZhbHVlc0J5S2V5LnZhbHVlcygpKTtcbiAgICAgICAgcmV0dXJuIHNldHMucmVkdWNlKCh2YWx1ZXMsIHNldCkgPT4gdmFsdWVzLmNvbmNhdChBcnJheS5mcm9tKHNldCkpLCBbXSk7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICBjb25zdCBzZXRzID0gQXJyYXkuZnJvbSh0aGlzLnZhbHVlc0J5S2V5LnZhbHVlcygpKTtcbiAgICAgICAgcmV0dXJuIHNldHMucmVkdWNlKChzaXplLCBzZXQpID0+IHNpemUgKyBzZXQuc2l6ZSwgMCk7XG4gICAgfVxuICAgIGFkZChrZXksIHZhbHVlKSB7XG4gICAgICAgIGFkZCh0aGlzLnZhbHVlc0J5S2V5LCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgZGVsZXRlKGtleSwgdmFsdWUpIHtcbiAgICAgICAgZGVsKHRoaXMudmFsdWVzQnlLZXksIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICBoYXMoa2V5LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLnZhbHVlc0J5S2V5LmdldChrZXkpO1xuICAgICAgICByZXR1cm4gdmFsdWVzICE9IG51bGwgJiYgdmFsdWVzLmhhcyh2YWx1ZSk7XG4gICAgfVxuICAgIGhhc0tleShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzQnlLZXkuaGFzKGtleSk7XG4gICAgfVxuICAgIGhhc1ZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHNldHMgPSBBcnJheS5mcm9tKHRoaXMudmFsdWVzQnlLZXkudmFsdWVzKCkpO1xuICAgICAgICByZXR1cm4gc2V0cy5zb21lKChzZXQpID0+IHNldC5oYXModmFsdWUpKTtcbiAgICB9XG4gICAgZ2V0VmFsdWVzRm9yS2V5KGtleSkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLnZhbHVlc0J5S2V5LmdldChrZXkpO1xuICAgICAgICByZXR1cm4gdmFsdWVzID8gQXJyYXkuZnJvbSh2YWx1ZXMpIDogW107XG4gICAgfVxuICAgIGdldEtleXNGb3JWYWx1ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnZhbHVlc0J5S2V5KVxuICAgICAgICAgICAgLmZpbHRlcigoW19rZXksIHZhbHVlc10pID0+IHZhbHVlcy5oYXModmFsdWUpKVxuICAgICAgICAgICAgLm1hcCgoW2tleSwgX3ZhbHVlc10pID0+IGtleSk7XG4gICAgfVxufVxuXG5jbGFzcyBJbmRleGVkTXVsdGltYXAgZXh0ZW5kcyBNdWx0aW1hcCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMua2V5c0J5VmFsdWUgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGdldCB2YWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMua2V5c0J5VmFsdWUua2V5cygpKTtcbiAgICB9XG4gICAgYWRkKGtleSwgdmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWRkKGtleSwgdmFsdWUpO1xuICAgICAgICBhZGQodGhpcy5rZXlzQnlWYWx1ZSwgdmFsdWUsIGtleSk7XG4gICAgfVxuICAgIGRlbGV0ZShrZXksIHZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmRlbGV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgZGVsKHRoaXMua2V5c0J5VmFsdWUsIHZhbHVlLCBrZXkpO1xuICAgIH1cbiAgICBoYXNWYWx1ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlzQnlWYWx1ZS5oYXModmFsdWUpO1xuICAgIH1cbiAgICBnZXRLZXlzRm9yVmFsdWUodmFsdWUpIHtcbiAgICAgICAgY29uc3Qgc2V0ID0gdGhpcy5rZXlzQnlWYWx1ZS5nZXQodmFsdWUpO1xuICAgICAgICByZXR1cm4gc2V0ID8gQXJyYXkuZnJvbShzZXQpIDogW107XG4gICAgfVxufVxuXG5jbGFzcyBTZWxlY3Rvck9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBzZWxlY3RvciwgZGVsZWdhdGUsIGRldGFpbHMgPSB7fSkge1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gICAgICAgIHRoaXMuZWxlbWVudE9ic2VydmVyID0gbmV3IEVsZW1lbnRPYnNlcnZlcihlbGVtZW50LCB0aGlzKTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICAgICAgICB0aGlzLm1hdGNoZXNCeUVsZW1lbnQgPSBuZXcgTXVsdGltYXAoKTtcbiAgICB9XG4gICAgZ2V0IHN0YXJ0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRPYnNlcnZlci5zdGFydGVkO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50T2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICB9XG4gICAgcGF1c2UoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5lbGVtZW50T2JzZXJ2ZXIucGF1c2UoY2FsbGJhY2spO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICB0aGlzLmVsZW1lbnRPYnNlcnZlci5zdG9wKCk7XG4gICAgfVxuICAgIHJlZnJlc2goKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudE9ic2VydmVyLnJlZnJlc2goKTtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRPYnNlcnZlci5lbGVtZW50O1xuICAgIH1cbiAgICBtYXRjaEVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gZWxlbWVudC5tYXRjaGVzKHRoaXMuc2VsZWN0b3IpO1xuICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZS5zZWxlY3Rvck1hdGNoRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXMgJiYgdGhpcy5kZWxlZ2F0ZS5zZWxlY3Rvck1hdGNoRWxlbWVudChlbGVtZW50LCB0aGlzLmRldGFpbHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgIH1cbiAgICBtYXRjaEVsZW1lbnRzSW5UcmVlKHRyZWUpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0aGlzLm1hdGNoRWxlbWVudCh0cmVlKSA/IFt0cmVlXSA6IFtdO1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gQXJyYXkuZnJvbSh0cmVlLnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5zZWxlY3RvcikpLmZpbHRlcigobWF0Y2gpID0+IHRoaXMubWF0Y2hFbGVtZW50KG1hdGNoKSk7XG4gICAgICAgIHJldHVybiBtYXRjaC5jb25jYXQobWF0Y2hlcyk7XG4gICAgfVxuICAgIGVsZW1lbnRNYXRjaGVkKGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rvck1hdGNoZWQoZWxlbWVudCk7XG4gICAgfVxuICAgIGVsZW1lbnRVbm1hdGNoZWQoZWxlbWVudCkge1xuICAgICAgICB0aGlzLnNlbGVjdG9yVW5tYXRjaGVkKGVsZW1lbnQpO1xuICAgIH1cbiAgICBlbGVtZW50QXR0cmlidXRlQ2hhbmdlZChlbGVtZW50LCBfYXR0cmlidXRlTmFtZSkge1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gdGhpcy5tYXRjaEVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgIGNvbnN0IG1hdGNoZWRCZWZvcmUgPSB0aGlzLm1hdGNoZXNCeUVsZW1lbnQuaGFzKHRoaXMuc2VsZWN0b3IsIGVsZW1lbnQpO1xuICAgICAgICBpZiAoIW1hdGNoZXMgJiYgbWF0Y2hlZEJlZm9yZSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RvclVubWF0Y2hlZChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZWxlY3Rvck1hdGNoZWQoZWxlbWVudCkge1xuICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZS5zZWxlY3Rvck1hdGNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUuc2VsZWN0b3JNYXRjaGVkKGVsZW1lbnQsIHRoaXMuc2VsZWN0b3IsIHRoaXMuZGV0YWlscyk7XG4gICAgICAgICAgICB0aGlzLm1hdGNoZXNCeUVsZW1lbnQuYWRkKHRoaXMuc2VsZWN0b3IsIGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbGVjdG9yVW5tYXRjaGVkKGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5zZWxlY3RvclVubWF0Y2hlZChlbGVtZW50LCB0aGlzLnNlbGVjdG9yLCB0aGlzLmRldGFpbHMpO1xuICAgICAgICB0aGlzLm1hdGNoZXNCeUVsZW1lbnQuZGVsZXRlKHRoaXMuc2VsZWN0b3IsIGVsZW1lbnQpO1xuICAgIH1cbn1cblxuY2xhc3MgU3RyaW5nTWFwT2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGRlbGVnYXRlKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RyaW5nTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigobXV0YXRpb25zKSA9PiB0aGlzLnByb2Nlc3NNdXRhdGlvbnMobXV0YXRpb25zKSk7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25PYnNlcnZlci5vYnNlcnZlKHRoaXMuZWxlbWVudCwgeyBhdHRyaWJ1dGVzOiB0cnVlLCBhdHRyaWJ1dGVPbGRWYWx1ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25PYnNlcnZlci50YWtlUmVjb3JkcygpO1xuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlZnJlc2goKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBvZiB0aGlzLmtub3duQXR0cmlidXRlTmFtZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvY2Vzc011dGF0aW9ucyhtdXRhdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NNdXRhdGlvbihtdXRhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvY2Vzc011dGF0aW9uKG11dGF0aW9uKSB7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWUgPSBtdXRhdGlvbi5hdHRyaWJ1dGVOYW1lO1xuICAgICAgICBpZiAoYXR0cmlidXRlTmFtZSkge1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIG11dGF0aW9uLm9sZFZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWZyZXNoQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZGVsZWdhdGUuZ2V0U3RyaW5nTWFwS2V5Rm9yQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICBpZiAoa2V5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zdHJpbmdNYXAuaGFzKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJpbmdNYXBLZXlBZGRlZChrZXksIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RyaW5nTWFwLmdldChhdHRyaWJ1dGVOYW1lKSAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyaW5nTWFwVmFsdWVDaGFuZ2VkKHZhbHVlLCBrZXksIG9sZFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLnN0cmluZ01hcC5nZXQoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJpbmdNYXAuZGVsZXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChvbGRWYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJpbmdNYXBLZXlSZW1vdmVkKGtleSwgYXR0cmlidXRlTmFtZSwgb2xkVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJpbmdNYXAuc2V0KGF0dHJpYnV0ZU5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdHJpbmdNYXBLZXlBZGRlZChrZXksIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUuc3RyaW5nTWFwS2V5QWRkZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUuc3RyaW5nTWFwS2V5QWRkZWQoa2V5LCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdHJpbmdNYXBWYWx1ZUNoYW5nZWQodmFsdWUsIGtleSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUuc3RyaW5nTWFwVmFsdWVDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLnN0cmluZ01hcFZhbHVlQ2hhbmdlZCh2YWx1ZSwga2V5LCBvbGRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RyaW5nTWFwS2V5UmVtb3ZlZChrZXksIGF0dHJpYnV0ZU5hbWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmRlbGVnYXRlLnN0cmluZ01hcEtleVJlbW92ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUuc3RyaW5nTWFwS2V5UmVtb3ZlZChrZXksIGF0dHJpYnV0ZU5hbWUsIG9sZFZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQga25vd25BdHRyaWJ1dGVOYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldCh0aGlzLmN1cnJlbnRBdHRyaWJ1dGVOYW1lcy5jb25jYXQodGhpcy5yZWNvcmRlZEF0dHJpYnV0ZU5hbWVzKSkpO1xuICAgIH1cbiAgICBnZXQgY3VycmVudEF0dHJpYnV0ZU5hbWVzKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmVsZW1lbnQuYXR0cmlidXRlcykubWFwKChhdHRyaWJ1dGUpID0+IGF0dHJpYnV0ZS5uYW1lKTtcbiAgICB9XG4gICAgZ2V0IHJlY29yZGVkQXR0cmlidXRlTmFtZXMoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuc3RyaW5nTWFwLmtleXMoKSk7XG4gICAgfVxufVxuXG5jbGFzcyBUb2tlbkxpc3RPYnNlcnZlciB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgYXR0cmlidXRlTmFtZSwgZGVsZWdhdGUpIHtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVPYnNlcnZlciA9IG5ldyBBdHRyaWJ1dGVPYnNlcnZlcihlbGVtZW50LCBhdHRyaWJ1dGVOYW1lLCB0aGlzKTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICAgICAgICB0aGlzLnRva2Vuc0J5RWxlbWVudCA9IG5ldyBNdWx0aW1hcCgpO1xuICAgIH1cbiAgICBnZXQgc3RhcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlT2JzZXJ2ZXIuc3RhcnRlZDtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICB9XG4gICAgcGF1c2UoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVPYnNlcnZlci5wYXVzZShjYWxsYmFjayk7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlT2JzZXJ2ZXIuc3RvcCgpO1xuICAgIH1cbiAgICByZWZyZXNoKCkge1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZU9ic2VydmVyLnJlZnJlc2goKTtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZU9ic2VydmVyLmVsZW1lbnQ7XG4gICAgfVxuICAgIGdldCBhdHRyaWJ1dGVOYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVPYnNlcnZlci5hdHRyaWJ1dGVOYW1lO1xuICAgIH1cbiAgICBlbGVtZW50TWF0Y2hlZEF0dHJpYnV0ZShlbGVtZW50KSB7XG4gICAgICAgIHRoaXMudG9rZW5zTWF0Y2hlZCh0aGlzLnJlYWRUb2tlbnNGb3JFbGVtZW50KGVsZW1lbnQpKTtcbiAgICB9XG4gICAgZWxlbWVudEF0dHJpYnV0ZVZhbHVlQ2hhbmdlZChlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IFt1bm1hdGNoZWRUb2tlbnMsIG1hdGNoZWRUb2tlbnNdID0gdGhpcy5yZWZyZXNoVG9rZW5zRm9yRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgdGhpcy50b2tlbnNVbm1hdGNoZWQodW5tYXRjaGVkVG9rZW5zKTtcbiAgICAgICAgdGhpcy50b2tlbnNNYXRjaGVkKG1hdGNoZWRUb2tlbnMpO1xuICAgIH1cbiAgICBlbGVtZW50VW5tYXRjaGVkQXR0cmlidXRlKGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy50b2tlbnNVbm1hdGNoZWQodGhpcy50b2tlbnNCeUVsZW1lbnQuZ2V0VmFsdWVzRm9yS2V5KGVsZW1lbnQpKTtcbiAgICB9XG4gICAgdG9rZW5zTWF0Y2hlZCh0b2tlbnMpIHtcbiAgICAgICAgdG9rZW5zLmZvckVhY2goKHRva2VuKSA9PiB0aGlzLnRva2VuTWF0Y2hlZCh0b2tlbikpO1xuICAgIH1cbiAgICB0b2tlbnNVbm1hdGNoZWQodG9rZW5zKSB7XG4gICAgICAgIHRva2Vucy5mb3JFYWNoKCh0b2tlbikgPT4gdGhpcy50b2tlblVubWF0Y2hlZCh0b2tlbikpO1xuICAgIH1cbiAgICB0b2tlbk1hdGNoZWQodG9rZW4pIHtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS50b2tlbk1hdGNoZWQodG9rZW4pO1xuICAgICAgICB0aGlzLnRva2Vuc0J5RWxlbWVudC5hZGQodG9rZW4uZWxlbWVudCwgdG9rZW4pO1xuICAgIH1cbiAgICB0b2tlblVubWF0Y2hlZCh0b2tlbikge1xuICAgICAgICB0aGlzLmRlbGVnYXRlLnRva2VuVW5tYXRjaGVkKHRva2VuKTtcbiAgICAgICAgdGhpcy50b2tlbnNCeUVsZW1lbnQuZGVsZXRlKHRva2VuLmVsZW1lbnQsIHRva2VuKTtcbiAgICB9XG4gICAgcmVmcmVzaFRva2Vuc0ZvckVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICBjb25zdCBwcmV2aW91c1Rva2VucyA9IHRoaXMudG9rZW5zQnlFbGVtZW50LmdldFZhbHVlc0ZvcktleShlbGVtZW50KTtcbiAgICAgICAgY29uc3QgY3VycmVudFRva2VucyA9IHRoaXMucmVhZFRva2Vuc0ZvckVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgIGNvbnN0IGZpcnN0RGlmZmVyaW5nSW5kZXggPSB6aXAocHJldmlvdXNUb2tlbnMsIGN1cnJlbnRUb2tlbnMpLmZpbmRJbmRleCgoW3ByZXZpb3VzVG9rZW4sIGN1cnJlbnRUb2tlbl0pID0+ICF0b2tlbnNBcmVFcXVhbChwcmV2aW91c1Rva2VuLCBjdXJyZW50VG9rZW4pKTtcbiAgICAgICAgaWYgKGZpcnN0RGlmZmVyaW5nSW5kZXggPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBbW10sIFtdXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbcHJldmlvdXNUb2tlbnMuc2xpY2UoZmlyc3REaWZmZXJpbmdJbmRleCksIGN1cnJlbnRUb2tlbnMuc2xpY2UoZmlyc3REaWZmZXJpbmdJbmRleCldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlYWRUb2tlbnNGb3JFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlTmFtZSA9IHRoaXMuYXR0cmlidXRlTmFtZTtcbiAgICAgICAgY29uc3QgdG9rZW5TdHJpbmcgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSB8fCBcIlwiO1xuICAgICAgICByZXR1cm4gcGFyc2VUb2tlblN0cmluZyh0b2tlblN0cmluZywgZWxlbWVudCwgYXR0cmlidXRlTmFtZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VUb2tlblN0cmluZyh0b2tlblN0cmluZywgZWxlbWVudCwgYXR0cmlidXRlTmFtZSkge1xuICAgIHJldHVybiB0b2tlblN0cmluZ1xuICAgICAgICAudHJpbSgpXG4gICAgICAgIC5zcGxpdCgvXFxzKy8pXG4gICAgICAgIC5maWx0ZXIoKGNvbnRlbnQpID0+IGNvbnRlbnQubGVuZ3RoKVxuICAgICAgICAubWFwKChjb250ZW50LCBpbmRleCkgPT4gKHsgZWxlbWVudCwgYXR0cmlidXRlTmFtZSwgY29udGVudCwgaW5kZXggfSkpO1xufVxuZnVuY3Rpb24gemlwKGxlZnQsIHJpZ2h0KSB7XG4gICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgobGVmdC5sZW5ndGgsIHJpZ2h0Lmxlbmd0aCk7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oeyBsZW5ndGggfSwgKF8sIGluZGV4KSA9PiBbbGVmdFtpbmRleF0sIHJpZ2h0W2luZGV4XV0pO1xufVxuZnVuY3Rpb24gdG9rZW5zQXJlRXF1YWwobGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gbGVmdCAmJiByaWdodCAmJiBsZWZ0LmluZGV4ID09IHJpZ2h0LmluZGV4ICYmIGxlZnQuY29udGVudCA9PSByaWdodC5jb250ZW50O1xufVxuXG5jbGFzcyBWYWx1ZUxpc3RPYnNlcnZlciB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgYXR0cmlidXRlTmFtZSwgZGVsZWdhdGUpIHtcbiAgICAgICAgdGhpcy50b2tlbkxpc3RPYnNlcnZlciA9IG5ldyBUb2tlbkxpc3RPYnNlcnZlcihlbGVtZW50LCBhdHRyaWJ1dGVOYW1lLCB0aGlzKTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICAgICAgICB0aGlzLnBhcnNlUmVzdWx0c0J5VG9rZW4gPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICB0aGlzLnZhbHVlc0J5VG9rZW5CeUVsZW1lbnQgPSBuZXcgV2Vha01hcCgpO1xuICAgIH1cbiAgICBnZXQgc3RhcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5MaXN0T2JzZXJ2ZXIuc3RhcnRlZDtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMudG9rZW5MaXN0T2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy50b2tlbkxpc3RPYnNlcnZlci5zdG9wKCk7XG4gICAgfVxuICAgIHJlZnJlc2goKSB7XG4gICAgICAgIHRoaXMudG9rZW5MaXN0T2JzZXJ2ZXIucmVmcmVzaCgpO1xuICAgIH1cbiAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5MaXN0T2JzZXJ2ZXIuZWxlbWVudDtcbiAgICB9XG4gICAgZ2V0IGF0dHJpYnV0ZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRva2VuTGlzdE9ic2VydmVyLmF0dHJpYnV0ZU5hbWU7XG4gICAgfVxuICAgIHRva2VuTWF0Y2hlZCh0b2tlbikge1xuICAgICAgICBjb25zdCB7IGVsZW1lbnQgfSA9IHRva2VuO1xuICAgICAgICBjb25zdCB7IHZhbHVlIH0gPSB0aGlzLmZldGNoUGFyc2VSZXN1bHRGb3JUb2tlbih0b2tlbik7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5mZXRjaFZhbHVlc0J5VG9rZW5Gb3JFbGVtZW50KGVsZW1lbnQpLnNldCh0b2tlbiwgdmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5lbGVtZW50TWF0Y2hlZFZhbHVlKGVsZW1lbnQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b2tlblVubWF0Y2hlZCh0b2tlbikge1xuICAgICAgICBjb25zdCB7IGVsZW1lbnQgfSA9IHRva2VuO1xuICAgICAgICBjb25zdCB7IHZhbHVlIH0gPSB0aGlzLmZldGNoUGFyc2VSZXN1bHRGb3JUb2tlbih0b2tlbik7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5mZXRjaFZhbHVlc0J5VG9rZW5Gb3JFbGVtZW50KGVsZW1lbnQpLmRlbGV0ZSh0b2tlbik7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLmVsZW1lbnRVbm1hdGNoZWRWYWx1ZShlbGVtZW50LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmV0Y2hQYXJzZVJlc3VsdEZvclRva2VuKHRva2VuKSB7XG4gICAgICAgIGxldCBwYXJzZVJlc3VsdCA9IHRoaXMucGFyc2VSZXN1bHRzQnlUb2tlbi5nZXQodG9rZW4pO1xuICAgICAgICBpZiAoIXBhcnNlUmVzdWx0KSB7XG4gICAgICAgICAgICBwYXJzZVJlc3VsdCA9IHRoaXMucGFyc2VUb2tlbih0b2tlbik7XG4gICAgICAgICAgICB0aGlzLnBhcnNlUmVzdWx0c0J5VG9rZW4uc2V0KHRva2VuLCBwYXJzZVJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlUmVzdWx0O1xuICAgIH1cbiAgICBmZXRjaFZhbHVlc0J5VG9rZW5Gb3JFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgbGV0IHZhbHVlc0J5VG9rZW4gPSB0aGlzLnZhbHVlc0J5VG9rZW5CeUVsZW1lbnQuZ2V0KGVsZW1lbnQpO1xuICAgICAgICBpZiAoIXZhbHVlc0J5VG9rZW4pIHtcbiAgICAgICAgICAgIHZhbHVlc0J5VG9rZW4gPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlc0J5VG9rZW5CeUVsZW1lbnQuc2V0KGVsZW1lbnQsIHZhbHVlc0J5VG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZXNCeVRva2VuO1xuICAgIH1cbiAgICBwYXJzZVRva2VuKHRva2VuKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZGVsZWdhdGUucGFyc2VWYWx1ZUZvclRva2VuKHRva2VuKTtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4geyBlcnJvciB9O1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBCaW5kaW5nT2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIGRlbGVnYXRlKSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgICAgICAgdGhpcy5iaW5kaW5nc0J5QWN0aW9uID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZhbHVlTGlzdE9ic2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlTGlzdE9ic2VydmVyID0gbmV3IFZhbHVlTGlzdE9ic2VydmVyKHRoaXMuZWxlbWVudCwgdGhpcy5hY3Rpb25BdHRyaWJ1dGUsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZUxpc3RPYnNlcnZlci5zdGFydCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlTGlzdE9ic2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlTGlzdE9ic2VydmVyLnN0b3AoKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnZhbHVlTGlzdE9ic2VydmVyO1xuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0QWxsQWN0aW9ucygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBlbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LmVsZW1lbnQ7XG4gICAgfVxuICAgIGdldCBpZGVudGlmaWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LmlkZW50aWZpZXI7XG4gICAgfVxuICAgIGdldCBhY3Rpb25BdHRyaWJ1dGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjaGVtYS5hY3Rpb25BdHRyaWJ1dGU7XG4gICAgfVxuICAgIGdldCBzY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuc2NoZW1hO1xuICAgIH1cbiAgICBnZXQgYmluZGluZ3MoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuYmluZGluZ3NCeUFjdGlvbi52YWx1ZXMoKSk7XG4gICAgfVxuICAgIGNvbm5lY3RBY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGJpbmRpbmcgPSBuZXcgQmluZGluZyh0aGlzLmNvbnRleHQsIGFjdGlvbik7XG4gICAgICAgIHRoaXMuYmluZGluZ3NCeUFjdGlvbi5zZXQoYWN0aW9uLCBiaW5kaW5nKTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5iaW5kaW5nQ29ubmVjdGVkKGJpbmRpbmcpO1xuICAgIH1cbiAgICBkaXNjb25uZWN0QWN0aW9uKGFjdGlvbikge1xuICAgICAgICBjb25zdCBiaW5kaW5nID0gdGhpcy5iaW5kaW5nc0J5QWN0aW9uLmdldChhY3Rpb24pO1xuICAgICAgICBpZiAoYmluZGluZykge1xuICAgICAgICAgICAgdGhpcy5iaW5kaW5nc0J5QWN0aW9uLmRlbGV0ZShhY3Rpb24pO1xuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5iaW5kaW5nRGlzY29ubmVjdGVkKGJpbmRpbmcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpc2Nvbm5lY3RBbGxBY3Rpb25zKCkge1xuICAgICAgICB0aGlzLmJpbmRpbmdzLmZvckVhY2goKGJpbmRpbmcpID0+IHRoaXMuZGVsZWdhdGUuYmluZGluZ0Rpc2Nvbm5lY3RlZChiaW5kaW5nLCB0cnVlKSk7XG4gICAgICAgIHRoaXMuYmluZGluZ3NCeUFjdGlvbi5jbGVhcigpO1xuICAgIH1cbiAgICBwYXJzZVZhbHVlRm9yVG9rZW4odG9rZW4pIHtcbiAgICAgICAgY29uc3QgYWN0aW9uID0gQWN0aW9uLmZvclRva2VuKHRva2VuLCB0aGlzLnNjaGVtYSk7XG4gICAgICAgIGlmIChhY3Rpb24uaWRlbnRpZmllciA9PSB0aGlzLmlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb247XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxlbWVudE1hdGNoZWRWYWx1ZShlbGVtZW50LCBhY3Rpb24pIHtcbiAgICAgICAgdGhpcy5jb25uZWN0QWN0aW9uKGFjdGlvbik7XG4gICAgfVxuICAgIGVsZW1lbnRVbm1hdGNoZWRWYWx1ZShlbGVtZW50LCBhY3Rpb24pIHtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0QWN0aW9uKGFjdGlvbik7XG4gICAgfVxufVxuXG5jbGFzcyBWYWx1ZU9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCByZWNlaXZlcikge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIHRoaXMuc3RyaW5nTWFwT2JzZXJ2ZXIgPSBuZXcgU3RyaW5nTWFwT2JzZXJ2ZXIodGhpcy5lbGVtZW50LCB0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZURlc2NyaXB0b3JNYXAgPSB0aGlzLmNvbnRyb2xsZXIudmFsdWVEZXNjcmlwdG9yTWFwO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgdGhpcy5zdHJpbmdNYXBPYnNlcnZlci5zdGFydCgpO1xuICAgICAgICB0aGlzLmludm9rZUNoYW5nZWRDYWxsYmFja3NGb3JEZWZhdWx0VmFsdWVzKCk7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMuc3RyaW5nTWFwT2JzZXJ2ZXIuc3RvcCgpO1xuICAgIH1cbiAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5lbGVtZW50O1xuICAgIH1cbiAgICBnZXQgY29udHJvbGxlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5jb250cm9sbGVyO1xuICAgIH1cbiAgICBnZXRTdHJpbmdNYXBLZXlGb3JBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSkge1xuICAgICAgICBpZiAoYXR0cmlidXRlTmFtZSBpbiB0aGlzLnZhbHVlRGVzY3JpcHRvck1hcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVEZXNjcmlwdG9yTWFwW2F0dHJpYnV0ZU5hbWVdLm5hbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RyaW5nTWFwS2V5QWRkZWQoa2V5LCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB0aGlzLnZhbHVlRGVzY3JpcHRvck1hcFthdHRyaWJ1dGVOYW1lXTtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1ZhbHVlKGtleSkpIHtcbiAgICAgICAgICAgIHRoaXMuaW52b2tlQ2hhbmdlZENhbGxiYWNrKGtleSwgZGVzY3JpcHRvci53cml0ZXIodGhpcy5yZWNlaXZlcltrZXldKSwgZGVzY3JpcHRvci53cml0ZXIoZGVzY3JpcHRvci5kZWZhdWx0VmFsdWUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdHJpbmdNYXBWYWx1ZUNoYW5nZWQodmFsdWUsIG5hbWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB0aGlzLnZhbHVlRGVzY3JpcHRvck5hbWVNYXBbbmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKG9sZFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICBvbGRWYWx1ZSA9IGRlc2NyaXB0b3Iud3JpdGVyKGRlc2NyaXB0b3IuZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmludm9rZUNoYW5nZWRDYWxsYmFjayhuYW1lLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgIH1cbiAgICBzdHJpbmdNYXBLZXlSZW1vdmVkKGtleSwgYXR0cmlidXRlTmFtZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IHRoaXMudmFsdWVEZXNjcmlwdG9yTmFtZU1hcFtrZXldO1xuICAgICAgICBpZiAodGhpcy5oYXNWYWx1ZShrZXkpKSB7XG4gICAgICAgICAgICB0aGlzLmludm9rZUNoYW5nZWRDYWxsYmFjayhrZXksIGRlc2NyaXB0b3Iud3JpdGVyKHRoaXMucmVjZWl2ZXJba2V5XSksIG9sZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW52b2tlQ2hhbmdlZENhbGxiYWNrKGtleSwgZGVzY3JpcHRvci53cml0ZXIoZGVzY3JpcHRvci5kZWZhdWx0VmFsdWUpLCBvbGRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW52b2tlQ2hhbmdlZENhbGxiYWNrc0ZvckRlZmF1bHRWYWx1ZXMoKSB7XG4gICAgICAgIGZvciAoY29uc3QgeyBrZXksIG5hbWUsIGRlZmF1bHRWYWx1ZSwgd3JpdGVyIH0gb2YgdGhpcy52YWx1ZURlc2NyaXB0b3JzKSB7XG4gICAgICAgICAgICBpZiAoZGVmYXVsdFZhbHVlICE9IHVuZGVmaW5lZCAmJiAhdGhpcy5jb250cm9sbGVyLmRhdGEuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmludm9rZUNoYW5nZWRDYWxsYmFjayhuYW1lLCB3cml0ZXIoZGVmYXVsdFZhbHVlKSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpbnZva2VDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgcmF3VmFsdWUsIHJhd09sZFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNoYW5nZWRNZXRob2ROYW1lID0gYCR7bmFtZX1DaGFuZ2VkYDtcbiAgICAgICAgY29uc3QgY2hhbmdlZE1ldGhvZCA9IHRoaXMucmVjZWl2ZXJbY2hhbmdlZE1ldGhvZE5hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIGNoYW5nZWRNZXRob2QgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gdGhpcy52YWx1ZURlc2NyaXB0b3JOYW1lTWFwW25hbWVdO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRlc2NyaXB0b3IucmVhZGVyKHJhd1ZhbHVlKTtcbiAgICAgICAgICAgICAgICBsZXQgb2xkVmFsdWUgPSByYXdPbGRWYWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAocmF3T2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWUgPSBkZXNjcmlwdG9yLnJlYWRlcihyYXdPbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoYW5nZWRNZXRob2QuY2FsbCh0aGlzLnJlY2VpdmVyLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSBgU3RpbXVsdXMgVmFsdWUgXCIke3RoaXMuY29udGV4dC5pZGVudGlmaWVyfS4ke2Rlc2NyaXB0b3IubmFtZX1cIiAtICR7ZXJyb3IubWVzc2FnZX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgdmFsdWVEZXNjcmlwdG9ycygpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZURlc2NyaXB0b3JNYXAgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZURlc2NyaXB0b3JNYXApLm1hcCgoa2V5KSA9PiB2YWx1ZURlc2NyaXB0b3JNYXBba2V5XSk7XG4gICAgfVxuICAgIGdldCB2YWx1ZURlc2NyaXB0b3JOYW1lTWFwKCkge1xuICAgICAgICBjb25zdCBkZXNjcmlwdG9ycyA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLnZhbHVlRGVzY3JpcHRvck1hcCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gdGhpcy52YWx1ZURlc2NyaXB0b3JNYXBba2V5XTtcbiAgICAgICAgICAgIGRlc2NyaXB0b3JzW2Rlc2NyaXB0b3IubmFtZV0gPSBkZXNjcmlwdG9yO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3JzO1xuICAgIH1cbiAgICBoYXNWYWx1ZShhdHRyaWJ1dGVOYW1lKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB0aGlzLnZhbHVlRGVzY3JpcHRvck5hbWVNYXBbYXR0cmlidXRlTmFtZV07XG4gICAgICAgIGNvbnN0IGhhc01ldGhvZE5hbWUgPSBgaGFzJHtjYXBpdGFsaXplKGRlc2NyaXB0b3IubmFtZSl9YDtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjZWl2ZXJbaGFzTWV0aG9kTmFtZV07XG4gICAgfVxufVxuXG5jbGFzcyBUYXJnZXRPYnNlcnZlciB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgZGVsZWdhdGUpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICAgICAgICB0aGlzLnRhcmdldHNCeU5hbWUgPSBuZXcgTXVsdGltYXAoKTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICghdGhpcy50b2tlbkxpc3RPYnNlcnZlcikge1xuICAgICAgICAgICAgdGhpcy50b2tlbkxpc3RPYnNlcnZlciA9IG5ldyBUb2tlbkxpc3RPYnNlcnZlcih0aGlzLmVsZW1lbnQsIHRoaXMuYXR0cmlidXRlTmFtZSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLnRva2VuTGlzdE9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKHRoaXMudG9rZW5MaXN0T2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdEFsbFRhcmdldHMoKTtcbiAgICAgICAgICAgIHRoaXMudG9rZW5MaXN0T2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMudG9rZW5MaXN0T2JzZXJ2ZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9rZW5NYXRjaGVkKHsgZWxlbWVudCwgY29udGVudDogbmFtZSB9KSB7XG4gICAgICAgIGlmICh0aGlzLnNjb3BlLmNvbnRhaW5zRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0VGFyZ2V0KGVsZW1lbnQsIG5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRva2VuVW5tYXRjaGVkKHsgZWxlbWVudCwgY29udGVudDogbmFtZSB9KSB7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdFRhcmdldChlbGVtZW50LCBuYW1lKTtcbiAgICB9XG4gICAgY29ubmVjdFRhcmdldChlbGVtZW50LCBuYW1lKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCF0aGlzLnRhcmdldHNCeU5hbWUuaGFzKG5hbWUsIGVsZW1lbnQpKSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldHNCeU5hbWUuYWRkKG5hbWUsIGVsZW1lbnQpO1xuICAgICAgICAgICAgKF9hID0gdGhpcy50b2tlbkxpc3RPYnNlcnZlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhdXNlKCgpID0+IHRoaXMuZGVsZWdhdGUudGFyZ2V0Q29ubmVjdGVkKGVsZW1lbnQsIG5hbWUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNjb25uZWN0VGFyZ2V0KGVsZW1lbnQsIG5hbWUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy50YXJnZXRzQnlOYW1lLmhhcyhuYW1lLCBlbGVtZW50KSkge1xuICAgICAgICAgICAgdGhpcy50YXJnZXRzQnlOYW1lLmRlbGV0ZShuYW1lLCBlbGVtZW50KTtcbiAgICAgICAgICAgIChfYSA9IHRoaXMudG9rZW5MaXN0T2JzZXJ2ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXVzZSgoKSA9PiB0aGlzLmRlbGVnYXRlLnRhcmdldERpc2Nvbm5lY3RlZChlbGVtZW50LCBuYW1lKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzY29ubmVjdEFsbFRhcmdldHMoKSB7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLnRhcmdldHNCeU5hbWUua2V5cykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMudGFyZ2V0c0J5TmFtZS5nZXRWYWx1ZXNGb3JLZXkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3RUYXJnZXQoZWxlbWVudCwgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGF0dHJpYnV0ZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiBgZGF0YS0ke3RoaXMuY29udGV4dC5pZGVudGlmaWVyfS10YXJnZXRgO1xuICAgIH1cbiAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5lbGVtZW50O1xuICAgIH1cbiAgICBnZXQgc2NvcGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuc2NvcGU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWFkSW5oZXJpdGFibGVTdGF0aWNBcnJheVZhbHVlcyhjb25zdHJ1Y3RvciwgcHJvcGVydHlOYW1lKSB7XG4gICAgY29uc3QgYW5jZXN0b3JzID0gZ2V0QW5jZXN0b3JzRm9yQ29uc3RydWN0b3IoY29uc3RydWN0b3IpO1xuICAgIHJldHVybiBBcnJheS5mcm9tKGFuY2VzdG9ycy5yZWR1Y2UoKHZhbHVlcywgY29uc3RydWN0b3IpID0+IHtcbiAgICAgICAgZ2V0T3duU3RhdGljQXJyYXlWYWx1ZXMoY29uc3RydWN0b3IsIHByb3BlcnR5TmFtZSkuZm9yRWFjaCgobmFtZSkgPT4gdmFsdWVzLmFkZChuYW1lKSk7XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfSwgbmV3IFNldCgpKSk7XG59XG5mdW5jdGlvbiByZWFkSW5oZXJpdGFibGVTdGF0aWNPYmplY3RQYWlycyhjb25zdHJ1Y3RvciwgcHJvcGVydHlOYW1lKSB7XG4gICAgY29uc3QgYW5jZXN0b3JzID0gZ2V0QW5jZXN0b3JzRm9yQ29uc3RydWN0b3IoY29uc3RydWN0b3IpO1xuICAgIHJldHVybiBhbmNlc3RvcnMucmVkdWNlKChwYWlycywgY29uc3RydWN0b3IpID0+IHtcbiAgICAgICAgcGFpcnMucHVzaCguLi5nZXRPd25TdGF0aWNPYmplY3RQYWlycyhjb25zdHJ1Y3RvciwgcHJvcGVydHlOYW1lKSk7XG4gICAgICAgIHJldHVybiBwYWlycztcbiAgICB9LCBbXSk7XG59XG5mdW5jdGlvbiBnZXRBbmNlc3RvcnNGb3JDb25zdHJ1Y3Rvcihjb25zdHJ1Y3Rvcikge1xuICAgIGNvbnN0IGFuY2VzdG9ycyA9IFtdO1xuICAgIHdoaWxlIChjb25zdHJ1Y3Rvcikge1xuICAgICAgICBhbmNlc3RvcnMucHVzaChjb25zdHJ1Y3Rvcik7XG4gICAgICAgIGNvbnN0cnVjdG9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGNvbnN0cnVjdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuY2VzdG9ycy5yZXZlcnNlKCk7XG59XG5mdW5jdGlvbiBnZXRPd25TdGF0aWNBcnJheVZhbHVlcyhjb25zdHJ1Y3RvciwgcHJvcGVydHlOYW1lKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IGNvbnN0cnVjdG9yW3Byb3BlcnR5TmFtZV07XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZGVmaW5pdGlvbikgPyBkZWZpbml0aW9uIDogW107XG59XG5mdW5jdGlvbiBnZXRPd25TdGF0aWNPYmplY3RQYWlycyhjb25zdHJ1Y3RvciwgcHJvcGVydHlOYW1lKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IGNvbnN0cnVjdG9yW3Byb3BlcnR5TmFtZV07XG4gICAgcmV0dXJuIGRlZmluaXRpb24gPyBPYmplY3Qua2V5cyhkZWZpbml0aW9uKS5tYXAoKGtleSkgPT4gW2tleSwgZGVmaW5pdGlvbltrZXldXSkgOiBbXTtcbn1cblxuY2xhc3MgT3V0bGV0T2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIGRlbGVnYXRlKSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgICAgICAgdGhpcy5vdXRsZXRzQnlOYW1lID0gbmV3IE11bHRpbWFwKCk7XG4gICAgICAgIHRoaXMub3V0bGV0RWxlbWVudHNCeU5hbWUgPSBuZXcgTXVsdGltYXAoKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rvck9ic2VydmVyTWFwID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0b3JPYnNlcnZlck1hcC5zaXplID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLm91dGxldERlZmluaXRpb25zLmZvckVhY2goKG91dGxldE5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IHRoaXMuc2VsZWN0b3Iob3V0bGV0TmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGV0YWlscyA9IHsgb3V0bGV0TmFtZSB9O1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yT2JzZXJ2ZXJNYXAuc2V0KG91dGxldE5hbWUsIG5ldyBTZWxlY3Rvck9ic2VydmVyKGRvY3VtZW50LmJvZHksIHNlbGVjdG9yLCB0aGlzLCBkZXRhaWxzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdG9yT2JzZXJ2ZXJNYXAuZm9yRWFjaCgob2JzZXJ2ZXIpID0+IG9ic2VydmVyLnN0YXJ0KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVwZW5kZW50Q29udGV4dHMuZm9yRWFjaCgoY29udGV4dCkgPT4gY29udGV4dC5yZWZyZXNoKCkpO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rvck9ic2VydmVyTWFwLnNpemUgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3RBbGxPdXRsZXRzKCk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdG9yT2JzZXJ2ZXJNYXAuZm9yRWFjaCgob2JzZXJ2ZXIpID0+IG9ic2VydmVyLnN0b3AoKSk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdG9yT2JzZXJ2ZXJNYXAuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWZyZXNoKCkge1xuICAgICAgICB0aGlzLnNlbGVjdG9yT2JzZXJ2ZXJNYXAuZm9yRWFjaCgob2JzZXJ2ZXIpID0+IG9ic2VydmVyLnJlZnJlc2goKSk7XG4gICAgfVxuICAgIHNlbGVjdG9yTWF0Y2hlZChlbGVtZW50LCBfc2VsZWN0b3IsIHsgb3V0bGV0TmFtZSB9KSB7XG4gICAgICAgIGNvbnN0IG91dGxldCA9IHRoaXMuZ2V0T3V0bGV0KGVsZW1lbnQsIG91dGxldE5hbWUpO1xuICAgICAgICBpZiAob3V0bGV0KSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RPdXRsZXQob3V0bGV0LCBlbGVtZW50LCBvdXRsZXROYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZWxlY3RvclVubWF0Y2hlZChlbGVtZW50LCBfc2VsZWN0b3IsIHsgb3V0bGV0TmFtZSB9KSB7XG4gICAgICAgIGNvbnN0IG91dGxldCA9IHRoaXMuZ2V0T3V0bGV0RnJvbU1hcChlbGVtZW50LCBvdXRsZXROYW1lKTtcbiAgICAgICAgaWYgKG91dGxldCkge1xuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0T3V0bGV0KG91dGxldCwgZWxlbWVudCwgb3V0bGV0TmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VsZWN0b3JNYXRjaEVsZW1lbnQoZWxlbWVudCwgeyBvdXRsZXROYW1lIH0pIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmhhc091dGxldChlbGVtZW50LCBvdXRsZXROYW1lKSAmJlxuICAgICAgICAgICAgZWxlbWVudC5tYXRjaGVzKGBbJHt0aGlzLmNvbnRleHQuYXBwbGljYXRpb24uc2NoZW1hLmNvbnRyb2xsZXJBdHRyaWJ1dGV9fj0ke291dGxldE5hbWV9XWApKTtcbiAgICB9XG4gICAgY29ubmVjdE91dGxldChvdXRsZXQsIGVsZW1lbnQsIG91dGxldE5hbWUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMub3V0bGV0RWxlbWVudHNCeU5hbWUuaGFzKG91dGxldE5hbWUsIGVsZW1lbnQpKSB7XG4gICAgICAgICAgICB0aGlzLm91dGxldHNCeU5hbWUuYWRkKG91dGxldE5hbWUsIG91dGxldCk7XG4gICAgICAgICAgICB0aGlzLm91dGxldEVsZW1lbnRzQnlOYW1lLmFkZChvdXRsZXROYW1lLCBlbGVtZW50KTtcbiAgICAgICAgICAgIChfYSA9IHRoaXMuc2VsZWN0b3JPYnNlcnZlck1hcC5nZXQob3V0bGV0TmFtZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXVzZSgoKSA9PiB0aGlzLmRlbGVnYXRlLm91dGxldENvbm5lY3RlZChvdXRsZXQsIGVsZW1lbnQsIG91dGxldE5hbWUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNjb25uZWN0T3V0bGV0KG91dGxldCwgZWxlbWVudCwgb3V0bGV0TmFtZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLm91dGxldEVsZW1lbnRzQnlOYW1lLmhhcyhvdXRsZXROYW1lLCBlbGVtZW50KSkge1xuICAgICAgICAgICAgdGhpcy5vdXRsZXRzQnlOYW1lLmRlbGV0ZShvdXRsZXROYW1lLCBvdXRsZXQpO1xuICAgICAgICAgICAgdGhpcy5vdXRsZXRFbGVtZW50c0J5TmFtZS5kZWxldGUob3V0bGV0TmFtZSwgZWxlbWVudCk7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLnNlbGVjdG9yT2JzZXJ2ZXJNYXBcbiAgICAgICAgICAgICAgICAuZ2V0KG91dGxldE5hbWUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGF1c2UoKCkgPT4gdGhpcy5kZWxlZ2F0ZS5vdXRsZXREaXNjb25uZWN0ZWQob3V0bGV0LCBlbGVtZW50LCBvdXRsZXROYW1lKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzY29ubmVjdEFsbE91dGxldHMoKSB7XG4gICAgICAgIGZvciAoY29uc3Qgb3V0bGV0TmFtZSBvZiB0aGlzLm91dGxldEVsZW1lbnRzQnlOYW1lLmtleXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0aGlzLm91dGxldEVsZW1lbnRzQnlOYW1lLmdldFZhbHVlc0ZvcktleShvdXRsZXROYW1lKSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgb3V0bGV0IG9mIHRoaXMub3V0bGV0c0J5TmFtZS5nZXRWYWx1ZXNGb3JLZXkob3V0bGV0TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0T3V0bGV0KG91dGxldCwgZWxlbWVudCwgb3V0bGV0TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNlbGVjdG9yKG91dGxldE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGUub3V0bGV0cy5nZXRTZWxlY3RvckZvck91dGxldE5hbWUob3V0bGV0TmFtZSk7XG4gICAgfVxuICAgIGdldCBvdXRsZXREZXBlbmRlbmNpZXMoKSB7XG4gICAgICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IG5ldyBNdWx0aW1hcCgpO1xuICAgICAgICB0aGlzLnJvdXRlci5tb2R1bGVzLmZvckVhY2goKG1vZHVsZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29uc3RydWN0b3IgPSBtb2R1bGUuZGVmaW5pdGlvbi5jb250cm9sbGVyQ29uc3RydWN0b3I7XG4gICAgICAgICAgICBjb25zdCBvdXRsZXRzID0gcmVhZEluaGVyaXRhYmxlU3RhdGljQXJyYXlWYWx1ZXMoY29uc3RydWN0b3IsIFwib3V0bGV0c1wiKTtcbiAgICAgICAgICAgIG91dGxldHMuZm9yRWFjaCgob3V0bGV0KSA9PiBkZXBlbmRlbmNpZXMuYWRkKG91dGxldCwgbW9kdWxlLmlkZW50aWZpZXIpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkZXBlbmRlbmNpZXM7XG4gICAgfVxuICAgIGdldCBvdXRsZXREZWZpbml0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0bGV0RGVwZW5kZW5jaWVzLmdldEtleXNGb3JWYWx1ZSh0aGlzLmlkZW50aWZpZXIpO1xuICAgIH1cbiAgICBnZXQgZGVwZW5kZW50Q29udHJvbGxlcklkZW50aWZpZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vdXRsZXREZXBlbmRlbmNpZXMuZ2V0VmFsdWVzRm9yS2V5KHRoaXMuaWRlbnRpZmllcik7XG4gICAgfVxuICAgIGdldCBkZXBlbmRlbnRDb250ZXh0cygpIHtcbiAgICAgICAgY29uc3QgaWRlbnRpZmllcnMgPSB0aGlzLmRlcGVuZGVudENvbnRyb2xsZXJJZGVudGlmaWVycztcbiAgICAgICAgcmV0dXJuIHRoaXMucm91dGVyLmNvbnRleHRzLmZpbHRlcigoY29udGV4dCkgPT4gaWRlbnRpZmllcnMuaW5jbHVkZXMoY29udGV4dC5pZGVudGlmaWVyKSk7XG4gICAgfVxuICAgIGhhc091dGxldChlbGVtZW50LCBvdXRsZXROYW1lKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuZ2V0T3V0bGV0KGVsZW1lbnQsIG91dGxldE5hbWUpIHx8ICEhdGhpcy5nZXRPdXRsZXRGcm9tTWFwKGVsZW1lbnQsIG91dGxldE5hbWUpO1xuICAgIH1cbiAgICBnZXRPdXRsZXQoZWxlbWVudCwgb3V0bGV0TmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBsaWNhdGlvbi5nZXRDb250cm9sbGVyRm9yRWxlbWVudEFuZElkZW50aWZpZXIoZWxlbWVudCwgb3V0bGV0TmFtZSk7XG4gICAgfVxuICAgIGdldE91dGxldEZyb21NYXAoZWxlbWVudCwgb3V0bGV0TmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vdXRsZXRzQnlOYW1lLmdldFZhbHVlc0ZvcktleShvdXRsZXROYW1lKS5maW5kKChvdXRsZXQpID0+IG91dGxldC5lbGVtZW50ID09PSBlbGVtZW50KTtcbiAgICB9XG4gICAgZ2V0IHNjb3BlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LnNjb3BlO1xuICAgIH1cbiAgICBnZXQgaWRlbnRpZmllcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5pZGVudGlmaWVyO1xuICAgIH1cbiAgICBnZXQgYXBwbGljYXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuYXBwbGljYXRpb247XG4gICAgfVxuICAgIGdldCByb3V0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGxpY2F0aW9uLnJvdXRlcjtcbiAgICB9XG59XG5cbmNsYXNzIENvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKG1vZHVsZSwgc2NvcGUpIHtcbiAgICAgICAgdGhpcy5sb2dEZWJ1Z0FjdGl2aXR5ID0gKGZ1bmN0aW9uTmFtZSwgZGV0YWlsID0ge30pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgaWRlbnRpZmllciwgY29udHJvbGxlciwgZWxlbWVudCB9ID0gdGhpcztcbiAgICAgICAgICAgIGRldGFpbCA9IE9iamVjdC5hc3NpZ24oeyBpZGVudGlmaWVyLCBjb250cm9sbGVyLCBlbGVtZW50IH0sIGRldGFpbCk7XG4gICAgICAgICAgICB0aGlzLmFwcGxpY2F0aW9uLmxvZ0RlYnVnQWN0aXZpdHkodGhpcy5pZGVudGlmaWVyLCBmdW5jdGlvbk5hbWUsIGRldGFpbCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubW9kdWxlID0gbW9kdWxlO1xuICAgICAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgICAgIHRoaXMuY29udHJvbGxlciA9IG5ldyBtb2R1bGUuY29udHJvbGxlckNvbnN0cnVjdG9yKHRoaXMpO1xuICAgICAgICB0aGlzLmJpbmRpbmdPYnNlcnZlciA9IG5ldyBCaW5kaW5nT2JzZXJ2ZXIodGhpcywgdGhpcy5kaXNwYXRjaGVyKTtcbiAgICAgICAgdGhpcy52YWx1ZU9ic2VydmVyID0gbmV3IFZhbHVlT2JzZXJ2ZXIodGhpcywgdGhpcy5jb250cm9sbGVyKTtcbiAgICAgICAgdGhpcy50YXJnZXRPYnNlcnZlciA9IG5ldyBUYXJnZXRPYnNlcnZlcih0aGlzLCB0aGlzKTtcbiAgICAgICAgdGhpcy5vdXRsZXRPYnNlcnZlciA9IG5ldyBPdXRsZXRPYnNlcnZlcih0aGlzLCB0aGlzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbGxlci5pbml0aWFsaXplKCk7XG4gICAgICAgICAgICB0aGlzLmxvZ0RlYnVnQWN0aXZpdHkoXCJpbml0aWFsaXplXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihlcnJvciwgXCJpbml0aWFsaXppbmcgY29udHJvbGxlclwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25uZWN0KCkge1xuICAgICAgICB0aGlzLmJpbmRpbmdPYnNlcnZlci5zdGFydCgpO1xuICAgICAgICB0aGlzLnZhbHVlT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICAgICAgdGhpcy50YXJnZXRPYnNlcnZlci5zdGFydCgpO1xuICAgICAgICB0aGlzLm91dGxldE9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXIuY29ubmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5sb2dEZWJ1Z0FjdGl2aXR5KFwiY29ubmVjdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IsIFwiY29ubmVjdGluZyBjb250cm9sbGVyXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlZnJlc2goKSB7XG4gICAgICAgIHRoaXMub3V0bGV0T2JzZXJ2ZXIucmVmcmVzaCgpO1xuICAgIH1cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIHRoaXMubG9nRGVidWdBY3Rpdml0eShcImRpc2Nvbm5lY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUVycm9yKGVycm9yLCBcImRpc2Nvbm5lY3RpbmcgY29udHJvbGxlclwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm91dGxldE9ic2VydmVyLnN0b3AoKTtcbiAgICAgICAgdGhpcy50YXJnZXRPYnNlcnZlci5zdG9wKCk7XG4gICAgICAgIHRoaXMudmFsdWVPYnNlcnZlci5zdG9wKCk7XG4gICAgICAgIHRoaXMuYmluZGluZ09ic2VydmVyLnN0b3AoKTtcbiAgICB9XG4gICAgZ2V0IGFwcGxpY2F0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2R1bGUuYXBwbGljYXRpb247XG4gICAgfVxuICAgIGdldCBpZGVudGlmaWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2R1bGUuaWRlbnRpZmllcjtcbiAgICB9XG4gICAgZ2V0IHNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbGljYXRpb24uc2NoZW1hO1xuICAgIH1cbiAgICBnZXQgZGlzcGF0Y2hlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbGljYXRpb24uZGlzcGF0Y2hlcjtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlLmVsZW1lbnQ7XG4gICAgfVxuICAgIGdldCBwYXJlbnRFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICAgIGhhbmRsZUVycm9yKGVycm9yLCBtZXNzYWdlLCBkZXRhaWwgPSB7fSkge1xuICAgICAgICBjb25zdCB7IGlkZW50aWZpZXIsIGNvbnRyb2xsZXIsIGVsZW1lbnQgfSA9IHRoaXM7XG4gICAgICAgIGRldGFpbCA9IE9iamVjdC5hc3NpZ24oeyBpZGVudGlmaWVyLCBjb250cm9sbGVyLCBlbGVtZW50IH0sIGRldGFpbCk7XG4gICAgICAgIHRoaXMuYXBwbGljYXRpb24uaGFuZGxlRXJyb3IoZXJyb3IsIGBFcnJvciAke21lc3NhZ2V9YCwgZGV0YWlsKTtcbiAgICB9XG4gICAgdGFyZ2V0Q29ubmVjdGVkKGVsZW1lbnQsIG5hbWUpIHtcbiAgICAgICAgdGhpcy5pbnZva2VDb250cm9sbGVyTWV0aG9kKGAke25hbWV9VGFyZ2V0Q29ubmVjdGVkYCwgZWxlbWVudCk7XG4gICAgfVxuICAgIHRhcmdldERpc2Nvbm5lY3RlZChlbGVtZW50LCBuYW1lKSB7XG4gICAgICAgIHRoaXMuaW52b2tlQ29udHJvbGxlck1ldGhvZChgJHtuYW1lfVRhcmdldERpc2Nvbm5lY3RlZGAsIGVsZW1lbnQpO1xuICAgIH1cbiAgICBvdXRsZXRDb25uZWN0ZWQob3V0bGV0LCBlbGVtZW50LCBuYW1lKSB7XG4gICAgICAgIHRoaXMuaW52b2tlQ29udHJvbGxlck1ldGhvZChgJHtuYW1lc3BhY2VDYW1lbGl6ZShuYW1lKX1PdXRsZXRDb25uZWN0ZWRgLCBvdXRsZXQsIGVsZW1lbnQpO1xuICAgIH1cbiAgICBvdXRsZXREaXNjb25uZWN0ZWQob3V0bGV0LCBlbGVtZW50LCBuYW1lKSB7XG4gICAgICAgIHRoaXMuaW52b2tlQ29udHJvbGxlck1ldGhvZChgJHtuYW1lc3BhY2VDYW1lbGl6ZShuYW1lKX1PdXRsZXREaXNjb25uZWN0ZWRgLCBvdXRsZXQsIGVsZW1lbnQpO1xuICAgIH1cbiAgICBpbnZva2VDb250cm9sbGVyTWV0aG9kKG1ldGhvZE5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IHRoaXMuY29udHJvbGxlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBjb250cm9sbGVyW21ldGhvZE5hbWVdID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29udHJvbGxlclttZXRob2ROYW1lXSguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gYmxlc3MoY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gc2hhZG93KGNvbnN0cnVjdG9yLCBnZXRCbGVzc2VkUHJvcGVydGllcyhjb25zdHJ1Y3RvcikpO1xufVxuZnVuY3Rpb24gc2hhZG93KGNvbnN0cnVjdG9yLCBwcm9wZXJ0aWVzKSB7XG4gICAgY29uc3Qgc2hhZG93Q29uc3RydWN0b3IgPSBleHRlbmQoY29uc3RydWN0b3IpO1xuICAgIGNvbnN0IHNoYWRvd1Byb3BlcnRpZXMgPSBnZXRTaGFkb3dQcm9wZXJ0aWVzKGNvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvcGVydGllcyk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc2hhZG93Q29uc3RydWN0b3IucHJvdG90eXBlLCBzaGFkb3dQcm9wZXJ0aWVzKTtcbiAgICByZXR1cm4gc2hhZG93Q29uc3RydWN0b3I7XG59XG5mdW5jdGlvbiBnZXRCbGVzc2VkUHJvcGVydGllcyhjb25zdHJ1Y3Rvcikge1xuICAgIGNvbnN0IGJsZXNzaW5ncyA9IHJlYWRJbmhlcml0YWJsZVN0YXRpY0FycmF5VmFsdWVzKGNvbnN0cnVjdG9yLCBcImJsZXNzaW5nc1wiKTtcbiAgICByZXR1cm4gYmxlc3NpbmdzLnJlZHVjZSgoYmxlc3NlZFByb3BlcnRpZXMsIGJsZXNzaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBibGVzc2luZyhjb25zdHJ1Y3Rvcik7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBibGVzc2VkUHJvcGVydGllc1trZXldIHx8IHt9O1xuICAgICAgICAgICAgYmxlc3NlZFByb3BlcnRpZXNba2V5XSA9IE9iamVjdC5hc3NpZ24oZGVzY3JpcHRvciwgcHJvcGVydGllc1trZXldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmxlc3NlZFByb3BlcnRpZXM7XG4gICAgfSwge30pO1xufVxuZnVuY3Rpb24gZ2V0U2hhZG93UHJvcGVydGllcyhwcm90b3R5cGUsIHByb3BlcnRpZXMpIHtcbiAgICByZXR1cm4gZ2V0T3duS2V5cyhwcm9wZXJ0aWVzKS5yZWR1Y2UoKHNoYWRvd1Byb3BlcnRpZXMsIGtleSkgPT4ge1xuICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gZ2V0U2hhZG93ZWREZXNjcmlwdG9yKHByb3RvdHlwZSwgcHJvcGVydGllcywga2V5KTtcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc2hhZG93UHJvcGVydGllcywgeyBba2V5XTogZGVzY3JpcHRvciB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2hhZG93UHJvcGVydGllcztcbiAgICB9LCB7fSk7XG59XG5mdW5jdGlvbiBnZXRTaGFkb3dlZERlc2NyaXB0b3IocHJvdG90eXBlLCBwcm9wZXJ0aWVzLCBrZXkpIHtcbiAgICBjb25zdCBzaGFkb3dpbmdEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90b3R5cGUsIGtleSk7XG4gICAgY29uc3Qgc2hhZG93ZWRCeVZhbHVlID0gc2hhZG93aW5nRGVzY3JpcHRvciAmJiBcInZhbHVlXCIgaW4gc2hhZG93aW5nRGVzY3JpcHRvcjtcbiAgICBpZiAoIXNoYWRvd2VkQnlWYWx1ZSkge1xuICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm9wZXJ0aWVzLCBrZXkpLnZhbHVlO1xuICAgICAgICBpZiAoc2hhZG93aW5nRGVzY3JpcHRvcikge1xuICAgICAgICAgICAgZGVzY3JpcHRvci5nZXQgPSBzaGFkb3dpbmdEZXNjcmlwdG9yLmdldCB8fCBkZXNjcmlwdG9yLmdldDtcbiAgICAgICAgICAgIGRlc2NyaXB0b3Iuc2V0ID0gc2hhZG93aW5nRGVzY3JpcHRvci5zZXQgfHwgZGVzY3JpcHRvci5zZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gICAgfVxufVxuY29uc3QgZ2V0T3duS2V5cyA9ICgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gKG9iamVjdCkgPT4gWy4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iamVjdCksIC4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG4gICAgfVxufSkoKTtcbmNvbnN0IGV4dGVuZCA9ICgoKSA9PiB7XG4gICAgZnVuY3Rpb24gZXh0ZW5kV2l0aFJlZmxlY3QoY29uc3RydWN0b3IpIHtcbiAgICAgICAgZnVuY3Rpb24gZXh0ZW5kZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5jb25zdHJ1Y3QoY29uc3RydWN0b3IsIGFyZ3VtZW50cywgbmV3LnRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgZXh0ZW5kZWQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShjb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBleHRlbmRlZCB9LFxuICAgICAgICB9KTtcbiAgICAgICAgUmVmbGVjdC5zZXRQcm90b3R5cGVPZihleHRlbmRlZCwgY29uc3RydWN0b3IpO1xuICAgICAgICByZXR1cm4gZXh0ZW5kZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRlc3RSZWZsZWN0RXh0ZW5zaW9uKCkge1xuICAgICAgICBjb25zdCBhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5hLmNhbGwodGhpcyk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGIgPSBleHRlbmRXaXRoUmVmbGVjdChhKTtcbiAgICAgICAgYi5wcm90b3R5cGUuYSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBiKCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHRlc3RSZWZsZWN0RXh0ZW5zaW9uKCk7XG4gICAgICAgIHJldHVybiBleHRlbmRXaXRoUmVmbGVjdDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiAoY29uc3RydWN0b3IpID0+IGNsYXNzIGV4dGVuZGVkIGV4dGVuZHMgY29uc3RydWN0b3Ige1xuICAgICAgICB9O1xuICAgIH1cbn0pKCk7XG5cbmZ1bmN0aW9uIGJsZXNzRGVmaW5pdGlvbihkZWZpbml0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWRlbnRpZmllcjogZGVmaW5pdGlvbi5pZGVudGlmaWVyLFxuICAgICAgICBjb250cm9sbGVyQ29uc3RydWN0b3I6IGJsZXNzKGRlZmluaXRpb24uY29udHJvbGxlckNvbnN0cnVjdG9yKSxcbiAgICB9O1xufVxuXG5jbGFzcyBNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGFwcGxpY2F0aW9uLCBkZWZpbml0aW9uKSB7XG4gICAgICAgIHRoaXMuYXBwbGljYXRpb24gPSBhcHBsaWNhdGlvbjtcbiAgICAgICAgdGhpcy5kZWZpbml0aW9uID0gYmxlc3NEZWZpbml0aW9uKGRlZmluaXRpb24pO1xuICAgICAgICB0aGlzLmNvbnRleHRzQnlTY29wZSA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIHRoaXMuY29ubmVjdGVkQ29udGV4dHMgPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIGdldCBpZGVudGlmaWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWZpbml0aW9uLmlkZW50aWZpZXI7XG4gICAgfVxuICAgIGdldCBjb250cm9sbGVyQ29uc3RydWN0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZmluaXRpb24uY29udHJvbGxlckNvbnN0cnVjdG9yO1xuICAgIH1cbiAgICBnZXQgY29udGV4dHMoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuY29ubmVjdGVkQ29udGV4dHMpO1xuICAgIH1cbiAgICBjb25uZWN0Q29udGV4dEZvclNjb3BlKHNjb3BlKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmZldGNoQ29udGV4dEZvclNjb3BlKHNjb3BlKTtcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRDb250ZXh0cy5hZGQoY29udGV4dCk7XG4gICAgICAgIGNvbnRleHQuY29ubmVjdCgpO1xuICAgIH1cbiAgICBkaXNjb25uZWN0Q29udGV4dEZvclNjb3BlKHNjb3BlKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmNvbnRleHRzQnlTY29wZS5nZXQoc2NvcGUpO1xuICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0ZWRDb250ZXh0cy5kZWxldGUoY29udGV4dCk7XG4gICAgICAgICAgICBjb250ZXh0LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmZXRjaENvbnRleHRGb3JTY29wZShzY29wZSkge1xuICAgICAgICBsZXQgY29udGV4dCA9IHRoaXMuY29udGV4dHNCeVNjb3BlLmdldChzY29wZSk7XG4gICAgICAgIGlmICghY29udGV4dCkge1xuICAgICAgICAgICAgY29udGV4dCA9IG5ldyBDb250ZXh0KHRoaXMsIHNjb3BlKTtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dHNCeVNjb3BlLnNldChzY29wZSwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxufVxuXG5jbGFzcyBDbGFzc01hcCB7XG4gICAgY29uc3RydWN0b3Ioc2NvcGUpIHtcbiAgICAgICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgIH1cbiAgICBoYXMobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmhhcyh0aGlzLmdldERhdGFLZXkobmFtZSkpO1xuICAgIH1cbiAgICBnZXQobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBbGwobmFtZSlbMF07XG4gICAgfVxuICAgIGdldEFsbChuYW1lKSB7XG4gICAgICAgIGNvbnN0IHRva2VuU3RyaW5nID0gdGhpcy5kYXRhLmdldCh0aGlzLmdldERhdGFLZXkobmFtZSkpIHx8IFwiXCI7XG4gICAgICAgIHJldHVybiB0b2tlbml6ZSh0b2tlblN0cmluZyk7XG4gICAgfVxuICAgIGdldEF0dHJpYnV0ZU5hbWUobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmdldEF0dHJpYnV0ZU5hbWVGb3JLZXkodGhpcy5nZXREYXRhS2V5KG5hbWUpKTtcbiAgICB9XG4gICAgZ2V0RGF0YUtleShuYW1lKSB7XG4gICAgICAgIHJldHVybiBgJHtuYW1lfS1jbGFzc2A7XG4gICAgfVxuICAgIGdldCBkYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY29wZS5kYXRhO1xuICAgIH1cbn1cblxuY2xhc3MgRGF0YU1hcCB7XG4gICAgY29uc3RydWN0b3Ioc2NvcGUpIHtcbiAgICAgICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgIH1cbiAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGUuZWxlbWVudDtcbiAgICB9XG4gICAgZ2V0IGlkZW50aWZpZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlLmlkZW50aWZpZXI7XG4gICAgfVxuICAgIGdldChrZXkpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuZ2V0QXR0cmlidXRlTmFtZUZvcktleShrZXkpO1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuZ2V0QXR0cmlidXRlTmFtZUZvcktleShrZXkpO1xuICAgICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGtleSk7XG4gICAgfVxuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuZ2V0QXR0cmlidXRlTmFtZUZvcktleShrZXkpO1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50Lmhhc0F0dHJpYnV0ZShuYW1lKTtcbiAgICB9XG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICBpZiAodGhpcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuZ2V0QXR0cmlidXRlTmFtZUZvcktleShrZXkpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEF0dHJpYnV0ZU5hbWVGb3JLZXkoa2V5KSB7XG4gICAgICAgIHJldHVybiBgZGF0YS0ke3RoaXMuaWRlbnRpZmllcn0tJHtkYXNoZXJpemUoa2V5KX1gO1xuICAgIH1cbn1cblxuY2xhc3MgR3VpZGUge1xuICAgIGNvbnN0cnVjdG9yKGxvZ2dlcikge1xuICAgICAgICB0aGlzLndhcm5lZEtleXNCeU9iamVjdCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgIH1cbiAgICB3YXJuKG9iamVjdCwga2V5LCBtZXNzYWdlKSB7XG4gICAgICAgIGxldCB3YXJuZWRLZXlzID0gdGhpcy53YXJuZWRLZXlzQnlPYmplY3QuZ2V0KG9iamVjdCk7XG4gICAgICAgIGlmICghd2FybmVkS2V5cykge1xuICAgICAgICAgICAgd2FybmVkS2V5cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIHRoaXMud2FybmVkS2V5c0J5T2JqZWN0LnNldChvYmplY3QsIHdhcm5lZEtleXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghd2FybmVkS2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgd2FybmVkS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4obWVzc2FnZSwgb2JqZWN0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gYXR0cmlidXRlVmFsdWVDb250YWluc1Rva2VuKGF0dHJpYnV0ZU5hbWUsIHRva2VuKSB7XG4gICAgcmV0dXJuIGBbJHthdHRyaWJ1dGVOYW1lfX49XCIke3Rva2VufVwiXWA7XG59XG5cbmNsYXNzIFRhcmdldFNldCB7XG4gICAgY29uc3RydWN0b3Ioc2NvcGUpIHtcbiAgICAgICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgIH1cbiAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGUuZWxlbWVudDtcbiAgICB9XG4gICAgZ2V0IGlkZW50aWZpZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlLmlkZW50aWZpZXI7XG4gICAgfVxuICAgIGdldCBzY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlLnNjaGVtYTtcbiAgICB9XG4gICAgaGFzKHRhcmdldE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZCh0YXJnZXROYW1lKSAhPSBudWxsO1xuICAgIH1cbiAgICBmaW5kKC4uLnRhcmdldE5hbWVzKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXROYW1lcy5yZWR1Y2UoKHRhcmdldCwgdGFyZ2V0TmFtZSkgPT4gdGFyZ2V0IHx8IHRoaXMuZmluZFRhcmdldCh0YXJnZXROYW1lKSB8fCB0aGlzLmZpbmRMZWdhY3lUYXJnZXQodGFyZ2V0TmFtZSksIHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGZpbmRBbGwoLi4udGFyZ2V0TmFtZXMpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldE5hbWVzLnJlZHVjZSgodGFyZ2V0cywgdGFyZ2V0TmFtZSkgPT4gW1xuICAgICAgICAgICAgLi4udGFyZ2V0cyxcbiAgICAgICAgICAgIC4uLnRoaXMuZmluZEFsbFRhcmdldHModGFyZ2V0TmFtZSksXG4gICAgICAgICAgICAuLi50aGlzLmZpbmRBbGxMZWdhY3lUYXJnZXRzKHRhcmdldE5hbWUpLFxuICAgICAgICBdLCBbXSk7XG4gICAgfVxuICAgIGZpbmRUYXJnZXQodGFyZ2V0TmFtZSkge1xuICAgICAgICBjb25zdCBzZWxlY3RvciA9IHRoaXMuZ2V0U2VsZWN0b3JGb3JUYXJnZXROYW1lKHRhcmdldE5hbWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5zY29wZS5maW5kRWxlbWVudChzZWxlY3Rvcik7XG4gICAgfVxuICAgIGZpbmRBbGxUYXJnZXRzKHRhcmdldE5hbWUpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSB0aGlzLmdldFNlbGVjdG9yRm9yVGFyZ2V0TmFtZSh0YXJnZXROYW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGUuZmluZEFsbEVsZW1lbnRzKHNlbGVjdG9yKTtcbiAgICB9XG4gICAgZ2V0U2VsZWN0b3JGb3JUYXJnZXROYW1lKHRhcmdldE5hbWUpIHtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlTmFtZSA9IHRoaXMuc2NoZW1hLnRhcmdldEF0dHJpYnV0ZUZvclNjb3BlKHRoaXMuaWRlbnRpZmllcik7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVWYWx1ZUNvbnRhaW5zVG9rZW4oYXR0cmlidXRlTmFtZSwgdGFyZ2V0TmFtZSk7XG4gICAgfVxuICAgIGZpbmRMZWdhY3lUYXJnZXQodGFyZ2V0TmFtZSkge1xuICAgICAgICBjb25zdCBzZWxlY3RvciA9IHRoaXMuZ2V0TGVnYWN5U2VsZWN0b3JGb3JUYXJnZXROYW1lKHRhcmdldE5hbWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGUodGhpcy5zY29wZS5maW5kRWxlbWVudChzZWxlY3RvciksIHRhcmdldE5hbWUpO1xuICAgIH1cbiAgICBmaW5kQWxsTGVnYWN5VGFyZ2V0cyh0YXJnZXROYW1lKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gdGhpcy5nZXRMZWdhY3lTZWxlY3RvckZvclRhcmdldE5hbWUodGFyZ2V0TmFtZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlLmZpbmRBbGxFbGVtZW50cyhzZWxlY3RvcikubWFwKChlbGVtZW50KSA9PiB0aGlzLmRlcHJlY2F0ZShlbGVtZW50LCB0YXJnZXROYW1lKSk7XG4gICAgfVxuICAgIGdldExlZ2FjeVNlbGVjdG9yRm9yVGFyZ2V0TmFtZSh0YXJnZXROYW1lKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldERlc2NyaXB0b3IgPSBgJHt0aGlzLmlkZW50aWZpZXJ9LiR7dGFyZ2V0TmFtZX1gO1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlVmFsdWVDb250YWluc1Rva2VuKHRoaXMuc2NoZW1hLnRhcmdldEF0dHJpYnV0ZSwgdGFyZ2V0RGVzY3JpcHRvcik7XG4gICAgfVxuICAgIGRlcHJlY2F0ZShlbGVtZW50LCB0YXJnZXROYW1lKSB7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCB7IGlkZW50aWZpZXIgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVOYW1lID0gdGhpcy5zY2hlbWEudGFyZ2V0QXR0cmlidXRlO1xuICAgICAgICAgICAgY29uc3QgcmV2aXNlZEF0dHJpYnV0ZU5hbWUgPSB0aGlzLnNjaGVtYS50YXJnZXRBdHRyaWJ1dGVGb3JTY29wZShpZGVudGlmaWVyKTtcbiAgICAgICAgICAgIHRoaXMuZ3VpZGUud2FybihlbGVtZW50LCBgdGFyZ2V0OiR7dGFyZ2V0TmFtZX1gLCBgUGxlYXNlIHJlcGxhY2UgJHthdHRyaWJ1dGVOYW1lfT1cIiR7aWRlbnRpZmllcn0uJHt0YXJnZXROYW1lfVwiIHdpdGggJHtyZXZpc2VkQXR0cmlidXRlTmFtZX09XCIke3RhcmdldE5hbWV9XCIuIGAgK1xuICAgICAgICAgICAgICAgIGBUaGUgJHthdHRyaWJ1dGVOYW1lfSBhdHRyaWJ1dGUgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24gb2YgU3RpbXVsdXMuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICAgIGdldCBndWlkZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGUuZ3VpZGU7XG4gICAgfVxufVxuXG5jbGFzcyBPdXRsZXRTZXQge1xuICAgIGNvbnN0cnVjdG9yKHNjb3BlLCBjb250cm9sbGVyRWxlbWVudCkge1xuICAgICAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgICAgIHRoaXMuY29udHJvbGxlckVsZW1lbnQgPSBjb250cm9sbGVyRWxlbWVudDtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlLmVsZW1lbnQ7XG4gICAgfVxuICAgIGdldCBpZGVudGlmaWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY29wZS5pZGVudGlmaWVyO1xuICAgIH1cbiAgICBnZXQgc2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY29wZS5zY2hlbWE7XG4gICAgfVxuICAgIGhhcyhvdXRsZXROYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmQob3V0bGV0TmFtZSkgIT0gbnVsbDtcbiAgICB9XG4gICAgZmluZCguLi5vdXRsZXROYW1lcykge1xuICAgICAgICByZXR1cm4gb3V0bGV0TmFtZXMucmVkdWNlKChvdXRsZXQsIG91dGxldE5hbWUpID0+IG91dGxldCB8fCB0aGlzLmZpbmRPdXRsZXQob3V0bGV0TmFtZSksIHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGZpbmRBbGwoLi4ub3V0bGV0TmFtZXMpIHtcbiAgICAgICAgcmV0dXJuIG91dGxldE5hbWVzLnJlZHVjZSgob3V0bGV0cywgb3V0bGV0TmFtZSkgPT4gWy4uLm91dGxldHMsIC4uLnRoaXMuZmluZEFsbE91dGxldHMob3V0bGV0TmFtZSldLCBbXSk7XG4gICAgfVxuICAgIGdldFNlbGVjdG9yRm9yT3V0bGV0TmFtZShvdXRsZXROYW1lKSB7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWUgPSB0aGlzLnNjaGVtYS5vdXRsZXRBdHRyaWJ1dGVGb3JTY29wZSh0aGlzLmlkZW50aWZpZXIsIG91dGxldE5hbWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sbGVyRWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgfVxuICAgIGZpbmRPdXRsZXQob3V0bGV0TmFtZSkge1xuICAgICAgICBjb25zdCBzZWxlY3RvciA9IHRoaXMuZ2V0U2VsZWN0b3JGb3JPdXRsZXROYW1lKG91dGxldE5hbWUpO1xuICAgICAgICBpZiAoc2VsZWN0b3IpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5kRWxlbWVudChzZWxlY3Rvciwgb3V0bGV0TmFtZSk7XG4gICAgfVxuICAgIGZpbmRBbGxPdXRsZXRzKG91dGxldE5hbWUpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSB0aGlzLmdldFNlbGVjdG9yRm9yT3V0bGV0TmFtZShvdXRsZXROYW1lKTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yID8gdGhpcy5maW5kQWxsRWxlbWVudHMoc2VsZWN0b3IsIG91dGxldE5hbWUpIDogW107XG4gICAgfVxuICAgIGZpbmRFbGVtZW50KHNlbGVjdG9yLCBvdXRsZXROYW1lKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5zY29wZS5xdWVyeUVsZW1lbnRzKHNlbGVjdG9yKTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzLmZpbHRlcigoZWxlbWVudCkgPT4gdGhpcy5tYXRjaGVzRWxlbWVudChlbGVtZW50LCBzZWxlY3Rvciwgb3V0bGV0TmFtZSkpWzBdO1xuICAgIH1cbiAgICBmaW5kQWxsRWxlbWVudHMoc2VsZWN0b3IsIG91dGxldE5hbWUpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLnNjb3BlLnF1ZXJ5RWxlbWVudHMoc2VsZWN0b3IpO1xuICAgICAgICByZXR1cm4gZWxlbWVudHMuZmlsdGVyKChlbGVtZW50KSA9PiB0aGlzLm1hdGNoZXNFbGVtZW50KGVsZW1lbnQsIHNlbGVjdG9yLCBvdXRsZXROYW1lKSk7XG4gICAgfVxuICAgIG1hdGNoZXNFbGVtZW50KGVsZW1lbnQsIHNlbGVjdG9yLCBvdXRsZXROYW1lKSB7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXJBdHRyaWJ1dGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSh0aGlzLnNjb3BlLnNjaGVtYS5jb250cm9sbGVyQXR0cmlidXRlKSB8fCBcIlwiO1xuICAgICAgICByZXR1cm4gZWxlbWVudC5tYXRjaGVzKHNlbGVjdG9yKSAmJiBjb250cm9sbGVyQXR0cmlidXRlLnNwbGl0KFwiIFwiKS5pbmNsdWRlcyhvdXRsZXROYW1lKTtcbiAgICB9XG59XG5cbmNsYXNzIFNjb3BlIHtcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEsIGVsZW1lbnQsIGlkZW50aWZpZXIsIGxvZ2dlcikge1xuICAgICAgICB0aGlzLnRhcmdldHMgPSBuZXcgVGFyZ2V0U2V0KHRoaXMpO1xuICAgICAgICB0aGlzLmNsYXNzZXMgPSBuZXcgQ2xhc3NNYXAodGhpcyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBEYXRhTWFwKHRoaXMpO1xuICAgICAgICB0aGlzLmNvbnRhaW5zRWxlbWVudCA9IChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5jbG9zZXN0KHRoaXMuY29udHJvbGxlclNlbGVjdG9yKSA9PT0gdGhpcy5lbGVtZW50O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5pZGVudGlmaWVyID0gaWRlbnRpZmllcjtcbiAgICAgICAgdGhpcy5ndWlkZSA9IG5ldyBHdWlkZShsb2dnZXIpO1xuICAgICAgICB0aGlzLm91dGxldHMgPSBuZXcgT3V0bGV0U2V0KHRoaXMuZG9jdW1lbnRTY29wZSwgZWxlbWVudCk7XG4gICAgfVxuICAgIGZpbmRFbGVtZW50KHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQubWF0Y2hlcyhzZWxlY3RvcikgPyB0aGlzLmVsZW1lbnQgOiB0aGlzLnF1ZXJ5RWxlbWVudHMoc2VsZWN0b3IpLmZpbmQodGhpcy5jb250YWluc0VsZW1lbnQpO1xuICAgIH1cbiAgICBmaW5kQWxsRWxlbWVudHMoc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIC4uLih0aGlzLmVsZW1lbnQubWF0Y2hlcyhzZWxlY3RvcikgPyBbdGhpcy5lbGVtZW50XSA6IFtdKSxcbiAgICAgICAgICAgIC4uLnRoaXMucXVlcnlFbGVtZW50cyhzZWxlY3RvcikuZmlsdGVyKHRoaXMuY29udGFpbnNFbGVtZW50KSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgcXVlcnlFbGVtZW50cyhzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuICAgIH1cbiAgICBnZXQgY29udHJvbGxlclNlbGVjdG9yKCkge1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlVmFsdWVDb250YWluc1Rva2VuKHRoaXMuc2NoZW1hLmNvbnRyb2xsZXJBdHRyaWJ1dGUsIHRoaXMuaWRlbnRpZmllcik7XG4gICAgfVxuICAgIGdldCBpc0RvY3VtZW50U2NvcGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB9XG4gICAgZ2V0IGRvY3VtZW50U2NvcGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzRG9jdW1lbnRTY29wZVxuICAgICAgICAgICAgPyB0aGlzXG4gICAgICAgICAgICA6IG5ldyBTY29wZSh0aGlzLnNjaGVtYSwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB0aGlzLmlkZW50aWZpZXIsIHRoaXMuZ3VpZGUubG9nZ2VyKTtcbiAgICB9XG59XG5cbmNsYXNzIFNjb3BlT2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIHNjaGVtYSwgZGVsZWdhdGUpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgICAgICAgdGhpcy52YWx1ZUxpc3RPYnNlcnZlciA9IG5ldyBWYWx1ZUxpc3RPYnNlcnZlcih0aGlzLmVsZW1lbnQsIHRoaXMuY29udHJvbGxlckF0dHJpYnV0ZSwgdGhpcyk7XG4gICAgICAgIHRoaXMuc2NvcGVzQnlJZGVudGlmaWVyQnlFbGVtZW50ID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgdGhpcy5zY29wZVJlZmVyZW5jZUNvdW50cyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICB0aGlzLnZhbHVlTGlzdE9ic2VydmVyLnN0YXJ0KCk7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMudmFsdWVMaXN0T2JzZXJ2ZXIuc3RvcCgpO1xuICAgIH1cbiAgICBnZXQgY29udHJvbGxlckF0dHJpYnV0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NoZW1hLmNvbnRyb2xsZXJBdHRyaWJ1dGU7XG4gICAgfVxuICAgIHBhcnNlVmFsdWVGb3JUb2tlbih0b2tlbikge1xuICAgICAgICBjb25zdCB7IGVsZW1lbnQsIGNvbnRlbnQ6IGlkZW50aWZpZXIgfSA9IHRva2VuO1xuICAgICAgICBjb25zdCBzY29wZXNCeUlkZW50aWZpZXIgPSB0aGlzLmZldGNoU2NvcGVzQnlJZGVudGlmaWVyRm9yRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgbGV0IHNjb3BlID0gc2NvcGVzQnlJZGVudGlmaWVyLmdldChpZGVudGlmaWVyKTtcbiAgICAgICAgaWYgKCFzY29wZSkge1xuICAgICAgICAgICAgc2NvcGUgPSB0aGlzLmRlbGVnYXRlLmNyZWF0ZVNjb3BlRm9yRWxlbWVudEFuZElkZW50aWZpZXIoZWxlbWVudCwgaWRlbnRpZmllcik7XG4gICAgICAgICAgICBzY29wZXNCeUlkZW50aWZpZXIuc2V0KGlkZW50aWZpZXIsIHNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NvcGU7XG4gICAgfVxuICAgIGVsZW1lbnRNYXRjaGVkVmFsdWUoZWxlbWVudCwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlQ291bnQgPSAodGhpcy5zY29wZVJlZmVyZW5jZUNvdW50cy5nZXQodmFsdWUpIHx8IDApICsgMTtcbiAgICAgICAgdGhpcy5zY29wZVJlZmVyZW5jZUNvdW50cy5zZXQodmFsdWUsIHJlZmVyZW5jZUNvdW50KTtcbiAgICAgICAgaWYgKHJlZmVyZW5jZUNvdW50ID09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUuc2NvcGVDb25uZWN0ZWQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsZW1lbnRVbm1hdGNoZWRWYWx1ZShlbGVtZW50LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCByZWZlcmVuY2VDb3VudCA9IHRoaXMuc2NvcGVSZWZlcmVuY2VDb3VudHMuZ2V0KHZhbHVlKTtcbiAgICAgICAgaWYgKHJlZmVyZW5jZUNvdW50KSB7XG4gICAgICAgICAgICB0aGlzLnNjb3BlUmVmZXJlbmNlQ291bnRzLnNldCh2YWx1ZSwgcmVmZXJlbmNlQ291bnQgLSAxKTtcbiAgICAgICAgICAgIGlmIChyZWZlcmVuY2VDb3VudCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5zY29wZURpc2Nvbm5lY3RlZCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmV0Y2hTY29wZXNCeUlkZW50aWZpZXJGb3JFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgbGV0IHNjb3Blc0J5SWRlbnRpZmllciA9IHRoaXMuc2NvcGVzQnlJZGVudGlmaWVyQnlFbGVtZW50LmdldChlbGVtZW50KTtcbiAgICAgICAgaWYgKCFzY29wZXNCeUlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIHNjb3Blc0J5SWRlbnRpZmllciA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuc2NvcGVzQnlJZGVudGlmaWVyQnlFbGVtZW50LnNldChlbGVtZW50LCBzY29wZXNCeUlkZW50aWZpZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY29wZXNCeUlkZW50aWZpZXI7XG4gICAgfVxufVxuXG5jbGFzcyBSb3V0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGFwcGxpY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuYXBwbGljYXRpb24gPSBhcHBsaWNhdGlvbjtcbiAgICAgICAgdGhpcy5zY29wZU9ic2VydmVyID0gbmV3IFNjb3BlT2JzZXJ2ZXIodGhpcy5lbGVtZW50LCB0aGlzLnNjaGVtYSwgdGhpcyk7XG4gICAgICAgIHRoaXMuc2NvcGVzQnlJZGVudGlmaWVyID0gbmV3IE11bHRpbWFwKCk7XG4gICAgICAgIHRoaXMubW9kdWxlc0J5SWRlbnRpZmllciA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGxpY2F0aW9uLmVsZW1lbnQ7XG4gICAgfVxuICAgIGdldCBzY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGxpY2F0aW9uLnNjaGVtYTtcbiAgICB9XG4gICAgZ2V0IGxvZ2dlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbGljYXRpb24ubG9nZ2VyO1xuICAgIH1cbiAgICBnZXQgY29udHJvbGxlckF0dHJpYnV0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NoZW1hLmNvbnRyb2xsZXJBdHRyaWJ1dGU7XG4gICAgfVxuICAgIGdldCBtb2R1bGVzKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLm1vZHVsZXNCeUlkZW50aWZpZXIudmFsdWVzKCkpO1xuICAgIH1cbiAgICBnZXQgY29udGV4dHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZHVsZXMucmVkdWNlKChjb250ZXh0cywgbW9kdWxlKSA9PiBjb250ZXh0cy5jb25jYXQobW9kdWxlLmNvbnRleHRzKSwgW10pO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgdGhpcy5zY29wZU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMuc2NvcGVPYnNlcnZlci5zdG9wKCk7XG4gICAgfVxuICAgIGxvYWREZWZpbml0aW9uKGRlZmluaXRpb24pIHtcbiAgICAgICAgdGhpcy51bmxvYWRJZGVudGlmaWVyKGRlZmluaXRpb24uaWRlbnRpZmllcik7XG4gICAgICAgIGNvbnN0IG1vZHVsZSA9IG5ldyBNb2R1bGUodGhpcy5hcHBsaWNhdGlvbiwgZGVmaW5pdGlvbik7XG4gICAgICAgIHRoaXMuY29ubmVjdE1vZHVsZShtb2R1bGUpO1xuICAgICAgICBjb25zdCBhZnRlckxvYWQgPSBkZWZpbml0aW9uLmNvbnRyb2xsZXJDb25zdHJ1Y3Rvci5hZnRlckxvYWQ7XG4gICAgICAgIGlmIChhZnRlckxvYWQpIHtcbiAgICAgICAgICAgIGFmdGVyTG9hZChkZWZpbml0aW9uLmlkZW50aWZpZXIsIHRoaXMuYXBwbGljYXRpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVubG9hZElkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICAgICAgICBjb25zdCBtb2R1bGUgPSB0aGlzLm1vZHVsZXNCeUlkZW50aWZpZXIuZ2V0KGlkZW50aWZpZXIpO1xuICAgICAgICBpZiAobW9kdWxlKSB7XG4gICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3RNb2R1bGUobW9kdWxlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRDb250ZXh0Rm9yRWxlbWVudEFuZElkZW50aWZpZXIoZWxlbWVudCwgaWRlbnRpZmllcikge1xuICAgICAgICBjb25zdCBtb2R1bGUgPSB0aGlzLm1vZHVsZXNCeUlkZW50aWZpZXIuZ2V0KGlkZW50aWZpZXIpO1xuICAgICAgICBpZiAobW9kdWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kdWxlLmNvbnRleHRzLmZpbmQoKGNvbnRleHQpID0+IGNvbnRleHQuZWxlbWVudCA9PSBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVFcnJvcihlcnJvciwgbWVzc2FnZSwgZGV0YWlsKSB7XG4gICAgICAgIHRoaXMuYXBwbGljYXRpb24uaGFuZGxlRXJyb3IoZXJyb3IsIG1lc3NhZ2UsIGRldGFpbCk7XG4gICAgfVxuICAgIGNyZWF0ZVNjb3BlRm9yRWxlbWVudEFuZElkZW50aWZpZXIoZWxlbWVudCwgaWRlbnRpZmllcikge1xuICAgICAgICByZXR1cm4gbmV3IFNjb3BlKHRoaXMuc2NoZW1hLCBlbGVtZW50LCBpZGVudGlmaWVyLCB0aGlzLmxvZ2dlcik7XG4gICAgfVxuICAgIHNjb3BlQ29ubmVjdGVkKHNjb3BlKSB7XG4gICAgICAgIHRoaXMuc2NvcGVzQnlJZGVudGlmaWVyLmFkZChzY29wZS5pZGVudGlmaWVyLCBzY29wZSk7XG4gICAgICAgIGNvbnN0IG1vZHVsZSA9IHRoaXMubW9kdWxlc0J5SWRlbnRpZmllci5nZXQoc2NvcGUuaWRlbnRpZmllcik7XG4gICAgICAgIGlmIChtb2R1bGUpIHtcbiAgICAgICAgICAgIG1vZHVsZS5jb25uZWN0Q29udGV4dEZvclNjb3BlKHNjb3BlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzY29wZURpc2Nvbm5lY3RlZChzY29wZSkge1xuICAgICAgICB0aGlzLnNjb3Blc0J5SWRlbnRpZmllci5kZWxldGUoc2NvcGUuaWRlbnRpZmllciwgc2NvcGUpO1xuICAgICAgICBjb25zdCBtb2R1bGUgPSB0aGlzLm1vZHVsZXNCeUlkZW50aWZpZXIuZ2V0KHNjb3BlLmlkZW50aWZpZXIpO1xuICAgICAgICBpZiAobW9kdWxlKSB7XG4gICAgICAgICAgICBtb2R1bGUuZGlzY29ubmVjdENvbnRleHRGb3JTY29wZShzY29wZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29ubmVjdE1vZHVsZShtb2R1bGUpIHtcbiAgICAgICAgdGhpcy5tb2R1bGVzQnlJZGVudGlmaWVyLnNldChtb2R1bGUuaWRlbnRpZmllciwgbW9kdWxlKTtcbiAgICAgICAgY29uc3Qgc2NvcGVzID0gdGhpcy5zY29wZXNCeUlkZW50aWZpZXIuZ2V0VmFsdWVzRm9yS2V5KG1vZHVsZS5pZGVudGlmaWVyKTtcbiAgICAgICAgc2NvcGVzLmZvckVhY2goKHNjb3BlKSA9PiBtb2R1bGUuY29ubmVjdENvbnRleHRGb3JTY29wZShzY29wZSkpO1xuICAgIH1cbiAgICBkaXNjb25uZWN0TW9kdWxlKG1vZHVsZSkge1xuICAgICAgICB0aGlzLm1vZHVsZXNCeUlkZW50aWZpZXIuZGVsZXRlKG1vZHVsZS5pZGVudGlmaWVyKTtcbiAgICAgICAgY29uc3Qgc2NvcGVzID0gdGhpcy5zY29wZXNCeUlkZW50aWZpZXIuZ2V0VmFsdWVzRm9yS2V5KG1vZHVsZS5pZGVudGlmaWVyKTtcbiAgICAgICAgc2NvcGVzLmZvckVhY2goKHNjb3BlKSA9PiBtb2R1bGUuZGlzY29ubmVjdENvbnRleHRGb3JTY29wZShzY29wZSkpO1xuICAgIH1cbn1cblxuY29uc3QgZGVmYXVsdFNjaGVtYSA9IHtcbiAgICBjb250cm9sbGVyQXR0cmlidXRlOiBcImRhdGEtY29udHJvbGxlclwiLFxuICAgIGFjdGlvbkF0dHJpYnV0ZTogXCJkYXRhLWFjdGlvblwiLFxuICAgIHRhcmdldEF0dHJpYnV0ZTogXCJkYXRhLXRhcmdldFwiLFxuICAgIHRhcmdldEF0dHJpYnV0ZUZvclNjb3BlOiAoaWRlbnRpZmllcikgPT4gYGRhdGEtJHtpZGVudGlmaWVyfS10YXJnZXRgLFxuICAgIG91dGxldEF0dHJpYnV0ZUZvclNjb3BlOiAoaWRlbnRpZmllciwgb3V0bGV0KSA9PiBgZGF0YS0ke2lkZW50aWZpZXJ9LSR7b3V0bGV0fS1vdXRsZXRgLFxuICAgIGtleU1hcHBpbmdzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBlbnRlcjogXCJFbnRlclwiLCB0YWI6IFwiVGFiXCIsIGVzYzogXCJFc2NhcGVcIiwgc3BhY2U6IFwiIFwiLCB1cDogXCJBcnJvd1VwXCIsIGRvd246IFwiQXJyb3dEb3duXCIsIGxlZnQ6IFwiQXJyb3dMZWZ0XCIsIHJpZ2h0OiBcIkFycm93UmlnaHRcIiwgaG9tZTogXCJIb21lXCIsIGVuZDogXCJFbmRcIiB9LCBvYmplY3RGcm9tRW50cmllcyhcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCIuc3BsaXQoXCJcIikubWFwKChjKSA9PiBbYywgY10pKSksIG9iamVjdEZyb21FbnRyaWVzKFwiMDEyMzQ1Njc4OVwiLnNwbGl0KFwiXCIpLm1hcCgobikgPT4gW24sIG5dKSkpLFxufTtcbmZ1bmN0aW9uIG9iamVjdEZyb21FbnRyaWVzKGFycmF5KSB7XG4gICAgcmV0dXJuIGFycmF5LnJlZHVjZSgobWVtbywgW2ssIHZdKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtZW1vKSwgeyBba106IHYgfSkpLCB7fSk7XG59XG5cbmNsYXNzIEFwcGxpY2F0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBzY2hlbWEgPSBkZWZhdWx0U2NoZW1hKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gY29uc29sZTtcbiAgICAgICAgdGhpcy5kZWJ1ZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxvZ0RlYnVnQWN0aXZpdHkgPSAoaWRlbnRpZmllciwgZnVuY3Rpb25OYW1lLCBkZXRhaWwgPSB7fSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ0Zvcm1hdHRlZE1lc3NhZ2UoaWRlbnRpZmllciwgZnVuY3Rpb25OYW1lLCBkZXRhaWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyID0gbmV3IERpc3BhdGNoZXIodGhpcyk7XG4gICAgICAgIHRoaXMucm91dGVyID0gbmV3IFJvdXRlcih0aGlzKTtcbiAgICAgICAgdGhpcy5hY3Rpb25EZXNjcmlwdG9yRmlsdGVycyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRBY3Rpb25EZXNjcmlwdG9yRmlsdGVycyk7XG4gICAgfVxuICAgIHN0YXRpYyBzdGFydChlbGVtZW50LCBzY2hlbWEpIHtcbiAgICAgICAgY29uc3QgYXBwbGljYXRpb24gPSBuZXcgdGhpcyhlbGVtZW50LCBzY2hlbWEpO1xuICAgICAgICBhcHBsaWNhdGlvbi5zdGFydCgpO1xuICAgICAgICByZXR1cm4gYXBwbGljYXRpb247XG4gICAgfVxuICAgIGFzeW5jIHN0YXJ0KCkge1xuICAgICAgICBhd2FpdCBkb21SZWFkeSgpO1xuICAgICAgICB0aGlzLmxvZ0RlYnVnQWN0aXZpdHkoXCJhcHBsaWNhdGlvblwiLCBcInN0YXJ0aW5nXCIpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoZXIuc3RhcnQoKTtcbiAgICAgICAgdGhpcy5yb3V0ZXIuc3RhcnQoKTtcbiAgICAgICAgdGhpcy5sb2dEZWJ1Z0FjdGl2aXR5KFwiYXBwbGljYXRpb25cIiwgXCJzdGFydFwiKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy5sb2dEZWJ1Z0FjdGl2aXR5KFwiYXBwbGljYXRpb25cIiwgXCJzdG9wcGluZ1wiKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyLnN0b3AoKTtcbiAgICAgICAgdGhpcy5yb3V0ZXIuc3RvcCgpO1xuICAgICAgICB0aGlzLmxvZ0RlYnVnQWN0aXZpdHkoXCJhcHBsaWNhdGlvblwiLCBcInN0b3BcIik7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGlkZW50aWZpZXIsIGNvbnRyb2xsZXJDb25zdHJ1Y3Rvcikge1xuICAgICAgICB0aGlzLmxvYWQoeyBpZGVudGlmaWVyLCBjb250cm9sbGVyQ29uc3RydWN0b3IgfSk7XG4gICAgfVxuICAgIHJlZ2lzdGVyQWN0aW9uT3B0aW9uKG5hbWUsIGZpbHRlcikge1xuICAgICAgICB0aGlzLmFjdGlvbkRlc2NyaXB0b3JGaWx0ZXJzW25hbWVdID0gZmlsdGVyO1xuICAgIH1cbiAgICBsb2FkKGhlYWQsIC4uLnJlc3QpIHtcbiAgICAgICAgY29uc3QgZGVmaW5pdGlvbnMgPSBBcnJheS5pc0FycmF5KGhlYWQpID8gaGVhZCA6IFtoZWFkLCAuLi5yZXN0XTtcbiAgICAgICAgZGVmaW5pdGlvbnMuZm9yRWFjaCgoZGVmaW5pdGlvbikgPT4ge1xuICAgICAgICAgICAgaWYgKGRlZmluaXRpb24uY29udHJvbGxlckNvbnN0cnVjdG9yLnNob3VsZExvYWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvdXRlci5sb2FkRGVmaW5pdGlvbihkZWZpbml0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVubG9hZChoZWFkLCAuLi5yZXN0KSB7XG4gICAgICAgIGNvbnN0IGlkZW50aWZpZXJzID0gQXJyYXkuaXNBcnJheShoZWFkKSA/IGhlYWQgOiBbaGVhZCwgLi4ucmVzdF07XG4gICAgICAgIGlkZW50aWZpZXJzLmZvckVhY2goKGlkZW50aWZpZXIpID0+IHRoaXMucm91dGVyLnVubG9hZElkZW50aWZpZXIoaWRlbnRpZmllcikpO1xuICAgIH1cbiAgICBnZXQgY29udHJvbGxlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvdXRlci5jb250ZXh0cy5tYXAoKGNvbnRleHQpID0+IGNvbnRleHQuY29udHJvbGxlcik7XG4gICAgfVxuICAgIGdldENvbnRyb2xsZXJGb3JFbGVtZW50QW5kSWRlbnRpZmllcihlbGVtZW50LCBpZGVudGlmaWVyKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLnJvdXRlci5nZXRDb250ZXh0Rm9yRWxlbWVudEFuZElkZW50aWZpZXIoZWxlbWVudCwgaWRlbnRpZmllcik7XG4gICAgICAgIHJldHVybiBjb250ZXh0ID8gY29udGV4dC5jb250cm9sbGVyIDogbnVsbDtcbiAgICB9XG4gICAgaGFuZGxlRXJyb3IoZXJyb3IsIG1lc3NhZ2UsIGRldGFpbCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGAlc1xcblxcbiVvXFxuXFxuJW9gLCBtZXNzYWdlLCBlcnJvciwgZGV0YWlsKTtcbiAgICAgICAgKF9hID0gd2luZG93Lm9uZXJyb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHdpbmRvdywgbWVzc2FnZSwgXCJcIiwgMCwgMCwgZXJyb3IpO1xuICAgIH1cbiAgICBsb2dGb3JtYXR0ZWRNZXNzYWdlKGlkZW50aWZpZXIsIGZ1bmN0aW9uTmFtZSwgZGV0YWlsID0ge30pIHtcbiAgICAgICAgZGV0YWlsID0gT2JqZWN0LmFzc2lnbih7IGFwcGxpY2F0aW9uOiB0aGlzIH0sIGRldGFpbCk7XG4gICAgICAgIHRoaXMubG9nZ2VyLmdyb3VwQ29sbGFwc2VkKGAke2lkZW50aWZpZXJ9ICMke2Z1bmN0aW9uTmFtZX1gKTtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiZGV0YWlsczpcIiwgT2JqZWN0LmFzc2lnbih7fSwgZGV0YWlsKSk7XG4gICAgICAgIHRoaXMubG9nZ2VyLmdyb3VwRW5kKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZG9tUmVhZHkoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09IFwibG9hZGluZ1wiKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCAoKSA9PiByZXNvbHZlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIENsYXNzUHJvcGVydGllc0JsZXNzaW5nKGNvbnN0cnVjdG9yKSB7XG4gICAgY29uc3QgY2xhc3NlcyA9IHJlYWRJbmhlcml0YWJsZVN0YXRpY0FycmF5VmFsdWVzKGNvbnN0cnVjdG9yLCBcImNsYXNzZXNcIik7XG4gICAgcmV0dXJuIGNsYXNzZXMucmVkdWNlKChwcm9wZXJ0aWVzLCBjbGFzc0RlZmluaXRpb24pID0+IHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocHJvcGVydGllcywgcHJvcGVydGllc0ZvckNsYXNzRGVmaW5pdGlvbihjbGFzc0RlZmluaXRpb24pKTtcbiAgICB9LCB7fSk7XG59XG5mdW5jdGlvbiBwcm9wZXJ0aWVzRm9yQ2xhc3NEZWZpbml0aW9uKGtleSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIFtgJHtrZXl9Q2xhc3NgXToge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgY2xhc3NlcyB9ID0gdGhpcztcbiAgICAgICAgICAgICAgICBpZiAoY2xhc3Nlcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xhc3Nlcy5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGNsYXNzZXMuZ2V0QXR0cmlidXRlTmFtZShrZXkpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgYXR0cmlidXRlIFwiJHthdHRyaWJ1dGV9XCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBbYCR7a2V5fUNsYXNzZXNgXToge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNsYXNzZXMuZ2V0QWxsKGtleSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBbYGhhcyR7Y2FwaXRhbGl6ZShrZXkpfUNsYXNzYF06IHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jbGFzc2VzLmhhcyhrZXkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBPdXRsZXRQcm9wZXJ0aWVzQmxlc3NpbmcoY29uc3RydWN0b3IpIHtcbiAgICBjb25zdCBvdXRsZXRzID0gcmVhZEluaGVyaXRhYmxlU3RhdGljQXJyYXlWYWx1ZXMoY29uc3RydWN0b3IsIFwib3V0bGV0c1wiKTtcbiAgICByZXR1cm4gb3V0bGV0cy5yZWR1Y2UoKHByb3BlcnRpZXMsIG91dGxldERlZmluaXRpb24pID0+IHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocHJvcGVydGllcywgcHJvcGVydGllc0Zvck91dGxldERlZmluaXRpb24ob3V0bGV0RGVmaW5pdGlvbikpO1xuICAgIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIHByb3BlcnRpZXNGb3JPdXRsZXREZWZpbml0aW9uKG5hbWUpIHtcbiAgICBjb25zdCBjYW1lbGl6ZWROYW1lID0gbmFtZXNwYWNlQ2FtZWxpemUobmFtZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgW2Ake2NhbWVsaXplZE5hbWV9T3V0bGV0YF06IHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRsZXQgPSB0aGlzLm91dGxldHMuZmluZChuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAob3V0bGV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG91dGxldENvbnRyb2xsZXIgPSB0aGlzLmFwcGxpY2F0aW9uLmdldENvbnRyb2xsZXJGb3JFbGVtZW50QW5kSWRlbnRpZmllcihvdXRsZXQsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3V0bGV0Q29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dGxldENvbnRyb2xsZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgXCJkYXRhLWNvbnRyb2xsZXI9JHtuYW1lfVwiIGF0dHJpYnV0ZSBvbiBvdXRsZXQgZWxlbWVudCBmb3IgXCIke3RoaXMuaWRlbnRpZmllcn1cIiBjb250cm9sbGVyYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIG91dGxldCBlbGVtZW50IFwiJHtuYW1lfVwiIGZvciBcIiR7dGhpcy5pZGVudGlmaWVyfVwiIGNvbnRyb2xsZXJgKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIFtgJHtjYW1lbGl6ZWROYW1lfU91dGxldHNgXToge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dGxldHMgPSB0aGlzLm91dGxldHMuZmluZEFsbChuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAob3V0bGV0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXRsZXRzXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKChvdXRsZXQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSB0aGlzLmFwcGxpY2F0aW9uLmdldENvbnRyb2xsZXJGb3JFbGVtZW50QW5kSWRlbnRpZmllcihvdXRsZXQsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVGhlIHByb3ZpZGVkIG91dGxldCBlbGVtZW50IGlzIG1pc3NpbmcgdGhlIG91dGxldCBjb250cm9sbGVyIFwiJHtuYW1lfVwiIGZvciBcIiR7dGhpcy5pZGVudGlmaWVyfVwiYCwgb3V0bGV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKGNvbnRyb2xsZXIpID0+IGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBbYCR7Y2FtZWxpemVkTmFtZX1PdXRsZXRFbGVtZW50YF06IHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRsZXQgPSB0aGlzLm91dGxldHMuZmluZChuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAob3V0bGV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXRsZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3Npbmcgb3V0bGV0IGVsZW1lbnQgXCIke25hbWV9XCIgZm9yIFwiJHt0aGlzLmlkZW50aWZpZXJ9XCIgY29udHJvbGxlcmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIFtgJHtjYW1lbGl6ZWROYW1lfU91dGxldEVsZW1lbnRzYF06IHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vdXRsZXRzLmZpbmRBbGwobmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBbYGhhcyR7Y2FwaXRhbGl6ZShjYW1lbGl6ZWROYW1lKX1PdXRsZXRgXToge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm91dGxldHMuaGFzKG5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBUYXJnZXRQcm9wZXJ0aWVzQmxlc3NpbmcoY29uc3RydWN0b3IpIHtcbiAgICBjb25zdCB0YXJnZXRzID0gcmVhZEluaGVyaXRhYmxlU3RhdGljQXJyYXlWYWx1ZXMoY29uc3RydWN0b3IsIFwidGFyZ2V0c1wiKTtcbiAgICByZXR1cm4gdGFyZ2V0cy5yZWR1Y2UoKHByb3BlcnRpZXMsIHRhcmdldERlZmluaXRpb24pID0+IHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocHJvcGVydGllcywgcHJvcGVydGllc0ZvclRhcmdldERlZmluaXRpb24odGFyZ2V0RGVmaW5pdGlvbikpO1xuICAgIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIHByb3BlcnRpZXNGb3JUYXJnZXREZWZpbml0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBbYCR7bmFtZX1UYXJnZXRgXToge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMudGFyZ2V0cy5maW5kKG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyB0YXJnZXQgZWxlbWVudCBcIiR7bmFtZX1cIiBmb3IgXCIke3RoaXMuaWRlbnRpZmllcn1cIiBjb250cm9sbGVyYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgW2Ake25hbWV9VGFyZ2V0c2BdOiB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0cy5maW5kQWxsKG5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgW2BoYXMke2NhcGl0YWxpemUobmFtZSl9VGFyZ2V0YF06IHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50YXJnZXRzLmhhcyhuYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gVmFsdWVQcm9wZXJ0aWVzQmxlc3NpbmcoY29uc3RydWN0b3IpIHtcbiAgICBjb25zdCB2YWx1ZURlZmluaXRpb25QYWlycyA9IHJlYWRJbmhlcml0YWJsZVN0YXRpY09iamVjdFBhaXJzKGNvbnN0cnVjdG9yLCBcInZhbHVlc1wiKTtcbiAgICBjb25zdCBwcm9wZXJ0eURlc2NyaXB0b3JNYXAgPSB7XG4gICAgICAgIHZhbHVlRGVzY3JpcHRvck1hcDoge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZURlZmluaXRpb25QYWlycy5yZWR1Y2UoKHJlc3VsdCwgdmFsdWVEZWZpbml0aW9uUGFpcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZURlc2NyaXB0b3IgPSBwYXJzZVZhbHVlRGVmaW5pdGlvblBhaXIodmFsdWVEZWZpbml0aW9uUGFpciwgdGhpcy5pZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlTmFtZSA9IHRoaXMuZGF0YS5nZXRBdHRyaWJ1dGVOYW1lRm9yS2V5KHZhbHVlRGVzY3JpcHRvci5rZXkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihyZXN1bHQsIHsgW2F0dHJpYnV0ZU5hbWVdOiB2YWx1ZURlc2NyaXB0b3IgfSk7XG4gICAgICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiB2YWx1ZURlZmluaXRpb25QYWlycy5yZWR1Y2UoKHByb3BlcnRpZXMsIHZhbHVlRGVmaW5pdGlvblBhaXIpID0+IHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocHJvcGVydGllcywgcHJvcGVydGllc0ZvclZhbHVlRGVmaW5pdGlvblBhaXIodmFsdWVEZWZpbml0aW9uUGFpcikpO1xuICAgIH0sIHByb3BlcnR5RGVzY3JpcHRvck1hcCk7XG59XG5mdW5jdGlvbiBwcm9wZXJ0aWVzRm9yVmFsdWVEZWZpbml0aW9uUGFpcih2YWx1ZURlZmluaXRpb25QYWlyLCBjb250cm9sbGVyKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IHBhcnNlVmFsdWVEZWZpbml0aW9uUGFpcih2YWx1ZURlZmluaXRpb25QYWlyLCBjb250cm9sbGVyKTtcbiAgICBjb25zdCB7IGtleSwgbmFtZSwgcmVhZGVyOiByZWFkLCB3cml0ZXI6IHdyaXRlIH0gPSBkZWZpbml0aW9uO1xuICAgIHJldHVybiB7XG4gICAgICAgIFtuYW1lXToge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5kYXRhLmdldChrZXkpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmaW5pdGlvbi5kZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5zZXQoa2V5LCB3cml0ZSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIFtgaGFzJHtjYXBpdGFsaXplKG5hbWUpfWBdOiB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5oYXMoa2V5KSB8fCBkZWZpbml0aW9uLmhhc0N1c3RvbURlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlVmFsdWVEZWZpbml0aW9uUGFpcihbdG9rZW4sIHR5cGVEZWZpbml0aW9uXSwgY29udHJvbGxlcikge1xuICAgIHJldHVybiB2YWx1ZURlc2NyaXB0b3JGb3JUb2tlbkFuZFR5cGVEZWZpbml0aW9uKHtcbiAgICAgICAgY29udHJvbGxlcixcbiAgICAgICAgdG9rZW4sXG4gICAgICAgIHR5cGVEZWZpbml0aW9uLFxuICAgIH0pO1xufVxuZnVuY3Rpb24gcGFyc2VWYWx1ZVR5cGVDb25zdGFudChjb25zdGFudCkge1xuICAgIHN3aXRjaCAoY29uc3RhbnQpIHtcbiAgICAgICAgY2FzZSBBcnJheTpcbiAgICAgICAgICAgIHJldHVybiBcImFycmF5XCI7XG4gICAgICAgIGNhc2UgQm9vbGVhbjpcbiAgICAgICAgICAgIHJldHVybiBcImJvb2xlYW5cIjtcbiAgICAgICAgY2FzZSBOdW1iZXI6XG4gICAgICAgICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICAgICAgY2FzZSBPYmplY3Q6XG4gICAgICAgICAgICByZXR1cm4gXCJvYmplY3RcIjtcbiAgICAgICAgY2FzZSBTdHJpbmc6XG4gICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZVZhbHVlVHlwZURlZmF1bHQoZGVmYXVsdFZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJib29sZWFuXCI7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGVmYXVsdFZhbHVlKSlcbiAgICAgICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRlZmF1bHRWYWx1ZSkgPT09IFwiW29iamVjdCBPYmplY3RdXCIpXG4gICAgICAgIHJldHVybiBcIm9iamVjdFwiO1xufVxuZnVuY3Rpb24gcGFyc2VWYWx1ZVR5cGVPYmplY3QocGF5bG9hZCkge1xuICAgIGNvbnN0IHR5cGVGcm9tT2JqZWN0ID0gcGFyc2VWYWx1ZVR5cGVDb25zdGFudChwYXlsb2FkLnR5cGVPYmplY3QudHlwZSk7XG4gICAgaWYgKCF0eXBlRnJvbU9iamVjdClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGRlZmF1bHRWYWx1ZVR5cGUgPSBwYXJzZVZhbHVlVHlwZURlZmF1bHQocGF5bG9hZC50eXBlT2JqZWN0LmRlZmF1bHQpO1xuICAgIGlmICh0eXBlRnJvbU9iamVjdCAhPT0gZGVmYXVsdFZhbHVlVHlwZSkge1xuICAgICAgICBjb25zdCBwcm9wZXJ0eVBhdGggPSBwYXlsb2FkLmNvbnRyb2xsZXIgPyBgJHtwYXlsb2FkLmNvbnRyb2xsZXJ9LiR7cGF5bG9hZC50b2tlbn1gIDogcGF5bG9hZC50b2tlbjtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgc3BlY2lmaWVkIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBTdGltdWx1cyBWYWx1ZSBcIiR7cHJvcGVydHlQYXRofVwiIG11c3QgbWF0Y2ggdGhlIGRlZmluZWQgdHlwZSBcIiR7dHlwZUZyb21PYmplY3R9XCIuIFRoZSBwcm92aWRlZCBkZWZhdWx0IHZhbHVlIG9mIFwiJHtwYXlsb2FkLnR5cGVPYmplY3QuZGVmYXVsdH1cIiBpcyBvZiB0eXBlIFwiJHtkZWZhdWx0VmFsdWVUeXBlfVwiLmApO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZUZyb21PYmplY3Q7XG59XG5mdW5jdGlvbiBwYXJzZVZhbHVlVHlwZURlZmluaXRpb24ocGF5bG9hZCkge1xuICAgIGNvbnN0IHR5cGVGcm9tT2JqZWN0ID0gcGFyc2VWYWx1ZVR5cGVPYmplY3Qoe1xuICAgICAgICBjb250cm9sbGVyOiBwYXlsb2FkLmNvbnRyb2xsZXIsXG4gICAgICAgIHRva2VuOiBwYXlsb2FkLnRva2VuLFxuICAgICAgICB0eXBlT2JqZWN0OiBwYXlsb2FkLnR5cGVEZWZpbml0aW9uLFxuICAgIH0pO1xuICAgIGNvbnN0IHR5cGVGcm9tRGVmYXVsdFZhbHVlID0gcGFyc2VWYWx1ZVR5cGVEZWZhdWx0KHBheWxvYWQudHlwZURlZmluaXRpb24pO1xuICAgIGNvbnN0IHR5cGVGcm9tQ29uc3RhbnQgPSBwYXJzZVZhbHVlVHlwZUNvbnN0YW50KHBheWxvYWQudHlwZURlZmluaXRpb24pO1xuICAgIGNvbnN0IHR5cGUgPSB0eXBlRnJvbU9iamVjdCB8fCB0eXBlRnJvbURlZmF1bHRWYWx1ZSB8fCB0eXBlRnJvbUNvbnN0YW50O1xuICAgIGlmICh0eXBlKVxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICBjb25zdCBwcm9wZXJ0eVBhdGggPSBwYXlsb2FkLmNvbnRyb2xsZXIgPyBgJHtwYXlsb2FkLmNvbnRyb2xsZXJ9LiR7cGF5bG9hZC50eXBlRGVmaW5pdGlvbn1gIDogcGF5bG9hZC50b2tlbjtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gdmFsdWUgdHlwZSBcIiR7cHJvcGVydHlQYXRofVwiIGZvciBcIiR7cGF5bG9hZC50b2tlbn1cIiB2YWx1ZWApO1xufVxuZnVuY3Rpb24gZGVmYXVsdFZhbHVlRm9yRGVmaW5pdGlvbih0eXBlRGVmaW5pdGlvbikge1xuICAgIGNvbnN0IGNvbnN0YW50ID0gcGFyc2VWYWx1ZVR5cGVDb25zdGFudCh0eXBlRGVmaW5pdGlvbik7XG4gICAgaWYgKGNvbnN0YW50KVxuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlc0J5VHlwZVtjb25zdGFudF07XG4gICAgY29uc3QgZGVmYXVsdFZhbHVlID0gdHlwZURlZmluaXRpb24uZGVmYXVsdDtcbiAgICBpZiAoZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgcmV0dXJuIHR5cGVEZWZpbml0aW9uO1xufVxuZnVuY3Rpb24gdmFsdWVEZXNjcmlwdG9yRm9yVG9rZW5BbmRUeXBlRGVmaW5pdGlvbihwYXlsb2FkKSB7XG4gICAgY29uc3Qga2V5ID0gYCR7ZGFzaGVyaXplKHBheWxvYWQudG9rZW4pfS12YWx1ZWA7XG4gICAgY29uc3QgdHlwZSA9IHBhcnNlVmFsdWVUeXBlRGVmaW5pdGlvbihwYXlsb2FkKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlLFxuICAgICAgICBrZXksXG4gICAgICAgIG5hbWU6IGNhbWVsaXplKGtleSksXG4gICAgICAgIGdldCBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlRm9yRGVmaW5pdGlvbihwYXlsb2FkLnR5cGVEZWZpbml0aW9uKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGhhc0N1c3RvbURlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVZhbHVlVHlwZURlZmF1bHQocGF5bG9hZC50eXBlRGVmaW5pdGlvbikgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgfSxcbiAgICAgICAgcmVhZGVyOiByZWFkZXJzW3R5cGVdLFxuICAgICAgICB3cml0ZXI6IHdyaXRlcnNbdHlwZV0gfHwgd3JpdGVycy5kZWZhdWx0LFxuICAgIH07XG59XG5jb25zdCBkZWZhdWx0VmFsdWVzQnlUeXBlID0ge1xuICAgIGdldCBhcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG4gICAgYm9vbGVhbjogZmFsc2UsXG4gICAgbnVtYmVyOiAwLFxuICAgIGdldCBvYmplY3QoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9LFxuICAgIHN0cmluZzogXCJcIixcbn07XG5jb25zdCByZWFkZXJzID0ge1xuICAgIGFycmF5KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGV4cGVjdGVkIHZhbHVlIG9mIHR5cGUgXCJhcnJheVwiIGJ1dCBpbnN0ZWFkIGdvdCB2YWx1ZSBcIiR7dmFsdWV9XCIgb2YgdHlwZSBcIiR7cGFyc2VWYWx1ZVR5cGVEZWZhdWx0KGFycmF5KX1cImApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICB9LFxuICAgIGJvb2xlYW4odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEodmFsdWUgPT0gXCIwXCIgfHwgU3RyaW5nKHZhbHVlKS50b0xvd2VyQ2FzZSgpID09IFwiZmFsc2VcIik7XG4gICAgfSxcbiAgICBudW1iZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgfSxcbiAgICBvYmplY3QodmFsdWUpIHtcbiAgICAgICAgY29uc3Qgb2JqZWN0ID0gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICAgIGlmIChvYmplY3QgPT09IG51bGwgfHwgdHlwZW9mIG9iamVjdCAhPSBcIm9iamVjdFwiIHx8IEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZXhwZWN0ZWQgdmFsdWUgb2YgdHlwZSBcIm9iamVjdFwiIGJ1dCBpbnN0ZWFkIGdvdCB2YWx1ZSBcIiR7dmFsdWV9XCIgb2YgdHlwZSBcIiR7cGFyc2VWYWx1ZVR5cGVEZWZhdWx0KG9iamVjdCl9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG4gICAgc3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxufTtcbmNvbnN0IHdyaXRlcnMgPSB7XG4gICAgZGVmYXVsdDogd3JpdGVTdHJpbmcsXG4gICAgYXJyYXk6IHdyaXRlSlNPTixcbiAgICBvYmplY3Q6IHdyaXRlSlNPTixcbn07XG5mdW5jdGlvbiB3cml0ZUpTT04odmFsdWUpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xufVxuZnVuY3Rpb24gd3JpdGVTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gYCR7dmFsdWV9YDtcbn1cblxuY2xhc3MgQ29udHJvbGxlciB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IHNob3VsZExvYWQoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBzdGF0aWMgYWZ0ZXJMb2FkKF9pZGVudGlmaWVyLCBfYXBwbGljYXRpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBnZXQgYXBwbGljYXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuYXBwbGljYXRpb247XG4gICAgfVxuICAgIGdldCBzY29wZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5zY29wZTtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlLmVsZW1lbnQ7XG4gICAgfVxuICAgIGdldCBpZGVudGlmaWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY29wZS5pZGVudGlmaWVyO1xuICAgIH1cbiAgICBnZXQgdGFyZ2V0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGUudGFyZ2V0cztcbiAgICB9XG4gICAgZ2V0IG91dGxldHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlLm91dGxldHM7XG4gICAgfVxuICAgIGdldCBjbGFzc2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY29wZS5jbGFzc2VzO1xuICAgIH1cbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGUuZGF0YTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZSgpIHtcbiAgICB9XG4gICAgY29ubmVjdCgpIHtcbiAgICB9XG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICB9XG4gICAgZGlzcGF0Y2goZXZlbnROYW1lLCB7IHRhcmdldCA9IHRoaXMuZWxlbWVudCwgZGV0YWlsID0ge30sIHByZWZpeCA9IHRoaXMuaWRlbnRpZmllciwgYnViYmxlcyA9IHRydWUsIGNhbmNlbGFibGUgPSB0cnVlIH0gPSB7fSkge1xuICAgICAgICBjb25zdCB0eXBlID0gcHJlZml4ID8gYCR7cHJlZml4fToke2V2ZW50TmFtZX1gIDogZXZlbnROYW1lO1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudCh0eXBlLCB7IGRldGFpbCwgYnViYmxlcywgY2FuY2VsYWJsZSB9KTtcbiAgICAgICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfVxufVxuQ29udHJvbGxlci5ibGVzc2luZ3MgPSBbXG4gICAgQ2xhc3NQcm9wZXJ0aWVzQmxlc3NpbmcsXG4gICAgVGFyZ2V0UHJvcGVydGllc0JsZXNzaW5nLFxuICAgIFZhbHVlUHJvcGVydGllc0JsZXNzaW5nLFxuICAgIE91dGxldFByb3BlcnRpZXNCbGVzc2luZyxcbl07XG5Db250cm9sbGVyLnRhcmdldHMgPSBbXTtcbkNvbnRyb2xsZXIub3V0bGV0cyA9IFtdO1xuQ29udHJvbGxlci52YWx1ZXMgPSB7fTtcblxuZXhwb3J0IHsgQXBwbGljYXRpb24sIEF0dHJpYnV0ZU9ic2VydmVyLCBDb250ZXh0LCBDb250cm9sbGVyLCBFbGVtZW50T2JzZXJ2ZXIsIEluZGV4ZWRNdWx0aW1hcCwgTXVsdGltYXAsIFNlbGVjdG9yT2JzZXJ2ZXIsIFN0cmluZ01hcE9ic2VydmVyLCBUb2tlbkxpc3RPYnNlcnZlciwgVmFsdWVMaXN0T2JzZXJ2ZXIsIGFkZCwgZGVmYXVsdFNjaGVtYSwgZGVsLCBmZXRjaCwgcHJ1bmUgfTtcbiIsImltcG9ydCB7IEFwcGxpY2F0aW9uIH0gZnJvbSAnQGhvdHdpcmVkL3N0aW11bHVzJztcbmltcG9ydCBzeW1mb255Q29udHJvbGxlcnMgZnJvbSAnLi93ZWJwYWNrL2xvYWRlciFAc3ltZm9ueS9zdGltdWx1cy1icmlkZ2UvY29udHJvbGxlcnMuanNvbic7XG5cbi8qXG5TdGltdWx1cyBXZWJwYWNrIEhlbHBlcnMgMS4wLjBcbkNvcHlyaWdodCDCqSAyMDIxIEJhc2VjYW1wLCBMTENcbiAqL1xuZnVuY3Rpb24gZGVmaW5pdGlvbnNGcm9tQ29udGV4dChjb250ZXh0KSB7XG4gICAgcmV0dXJuIGNvbnRleHQua2V5cygpXG4gICAgICAgIC5tYXAoKGtleSkgPT4gZGVmaW5pdGlvbkZvck1vZHVsZVdpdGhDb250ZXh0QW5kS2V5KGNvbnRleHQsIGtleSkpXG4gICAgICAgIC5maWx0ZXIoKHZhbHVlKSA9PiB2YWx1ZSk7XG59XG5mdW5jdGlvbiBkZWZpbml0aW9uRm9yTW9kdWxlV2l0aENvbnRleHRBbmRLZXkoY29udGV4dCwga2V5KSB7XG4gICAgY29uc3QgaWRlbnRpZmllciA9IGlkZW50aWZpZXJGb3JDb250ZXh0S2V5KGtleSk7XG4gICAgaWYgKGlkZW50aWZpZXIpIHtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb25Gb3JNb2R1bGVBbmRJZGVudGlmaWVyKGNvbnRleHQoa2V5KSwgaWRlbnRpZmllcik7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVmaW5pdGlvbkZvck1vZHVsZUFuZElkZW50aWZpZXIobW9kdWxlLCBpZGVudGlmaWVyKSB7XG4gICAgY29uc3QgY29udHJvbGxlckNvbnN0cnVjdG9yID0gbW9kdWxlLmRlZmF1bHQ7XG4gICAgaWYgKHR5cGVvZiBjb250cm9sbGVyQ29uc3RydWN0b3IgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiB7IGlkZW50aWZpZXIsIGNvbnRyb2xsZXJDb25zdHJ1Y3RvciB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlkZW50aWZpZXJGb3JDb250ZXh0S2V5KGtleSkge1xuICAgIGNvbnN0IGxvZ2ljYWxOYW1lID0gKGtleS5tYXRjaCgvXig/OlxcLlxcLyk/KC4rKSg/OltfLV1jb250cm9sbGVyXFwuLis/KSQvKSB8fCBbXSlbMV07XG4gICAgaWYgKGxvZ2ljYWxOYW1lKSB7XG4gICAgICAgIHJldHVybiBsb2dpY2FsTmFtZS5yZXBsYWNlKC9fL2csIFwiLVwiKS5yZXBsYWNlKC9cXC8vZywgXCItLVwiKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0U3RpbXVsdXNBcHAoY29udGV4dCkge1xuICAgIGNvbnN0IGFwcGxpY2F0aW9uID0gQXBwbGljYXRpb24uc3RhcnQoKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgYXBwbGljYXRpb24uZGVidWcgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoY29udGV4dCkge1xuICAgICAgICBhcHBsaWNhdGlvbi5sb2FkKGRlZmluaXRpb25zRnJvbUNvbnRleHQoY29udGV4dCkpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGNvbnRyb2xsZXJOYW1lIGluIHN5bWZvbnlDb250cm9sbGVycykge1xuICAgICAgICBpZiAoIXN5bWZvbnlDb250cm9sbGVycy5oYXNPd25Qcm9wZXJ0eShjb250cm9sbGVyTmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGFwcGxpY2F0aW9uLnJlZ2lzdGVyKGNvbnRyb2xsZXJOYW1lLCBzeW1mb255Q29udHJvbGxlcnNbY29udHJvbGxlck5hbWVdKTtcbiAgICB9XG4gICAgcmV0dXJuIGFwcGxpY2F0aW9uO1xufVxuXG5leHBvcnQgeyBzdGFydFN0aW11bHVzQXBwIH07XG4iLCJ2YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIHRyeVRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RyeS10by1zdHJpbmcnKTtcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbi8vIGBBc3NlcnQ6IElzQ2FsbGFibGUoYXJndW1lbnQpIGlzIHRydWVgXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNDYWxsYWJsZShhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgJFR5cGVFcnJvcih0cnlUb1N0cmluZyhhcmd1bWVudCkgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG59O1xuIiwidmFyIGlzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY29uc3RydWN0b3InKTtcbnZhciB0cnlUb1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90cnktdG8tc3RyaW5nJyk7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG4vLyBgQXNzZXJ0OiBJc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSBpcyB0cnVlYFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGlzQ29uc3RydWN0b3IoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG4gIHRocm93ICRUeXBlRXJyb3IodHJ5VG9TdHJpbmcoYXJndW1lbnQpICsgJyBpcyBub3QgYSBjb25zdHJ1Y3RvcicpO1xufTtcbiIsInZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG5cbnZhciAkU3RyaW5nID0gU3RyaW5nO1xudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmICh0eXBlb2YgYXJndW1lbnQgPT0gJ29iamVjdCcgfHwgaXNDYWxsYWJsZShhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgJFR5cGVFcnJvcihcIkNhbid0IHNldCBcIiArICRTdHJpbmcoYXJndW1lbnQpICsgJyBhcyBhIHByb3RvdHlwZScpO1xufTtcbiIsInZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZScpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKS5mO1xuXG52YXIgVU5TQ09QQUJMRVMgPSB3ZWxsS25vd25TeW1ib2woJ3Vuc2NvcGFibGVzJyk7XG52YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5cbi8vIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuaWYgKEFycmF5UHJvdG90eXBlW1VOU0NPUEFCTEVTXSA9PSB1bmRlZmluZWQpIHtcbiAgZGVmaW5lUHJvcGVydHkoQXJyYXlQcm90b3R5cGUsIFVOU0NPUEFCTEVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBjcmVhdGUobnVsbClcbiAgfSk7XG59XG5cbi8vIGFkZCBhIGtleSB0byBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICBBcnJheVByb3RvdHlwZVtVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xuXG52YXIgJFN0cmluZyA9IFN0cmluZztcbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG4vLyBgQXNzZXJ0OiBUeXBlKGFyZ3VtZW50KSBpcyBPYmplY3RgXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNPYmplY3QoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG4gIHRocm93ICRUeXBlRXJyb3IoJFN0cmluZyhhcmd1bWVudCkgKyAnIGlzIG5vdCBhbiBvYmplY3QnKTtcbn07XG4iLCJ2YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4Jyk7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbGVuZ3RoLW9mLWFycmF5LWxpa2UnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS57IGluZGV4T2YsIGluY2x1ZGVzIH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UoTyk7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGZyb21JbmRleCwgbGVuZ3RoKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgIGlmICgoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykgJiYgT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5pbmNsdWRlc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG4gIGluY2x1ZGVzOiBjcmVhdGVNZXRob2QodHJ1ZSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5kZXhPZmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluZGV4b2ZcbiAgaW5kZXhPZjogY3JlYXRlTWV0aG9kKGZhbHNlKVxufTtcbiIsInZhciBiaW5kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtY29udGV4dCcpO1xudmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xudmFyIEluZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9sZW5ndGgtb2YtYXJyYXktbGlrZScpO1xudmFyIGFycmF5U3BlY2llc0NyZWF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNyZWF0ZScpO1xuXG52YXIgcHVzaCA9IHVuY3VycnlUaGlzKFtdLnB1c2gpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnsgZm9yRWFjaCwgbWFwLCBmaWx0ZXIsIHNvbWUsIGV2ZXJ5LCBmaW5kLCBmaW5kSW5kZXgsIGZpbHRlclJlamVjdCB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKFRZUEUpIHtcbiAgdmFyIElTX01BUCA9IFRZUEUgPT0gMTtcbiAgdmFyIElTX0ZJTFRFUiA9IFRZUEUgPT0gMjtcbiAgdmFyIElTX1NPTUUgPSBUWVBFID09IDM7XG4gIHZhciBJU19FVkVSWSA9IFRZUEUgPT0gNDtcbiAgdmFyIElTX0ZJTkRfSU5ERVggPSBUWVBFID09IDY7XG4gIHZhciBJU19GSUxURVJfUkVKRUNUID0gVFlQRSA9PSA3O1xuICB2YXIgTk9fSE9MRVMgPSBUWVBFID09IDUgfHwgSVNfRklORF9JTkRFWDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgY2FsbGJhY2tmbiwgdGhhdCwgc3BlY2lmaWNDcmVhdGUpIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgc2VsZiA9IEluZGV4ZWRPYmplY3QoTyk7XG4gICAgdmFyIGJvdW5kRnVuY3Rpb24gPSBiaW5kKGNhbGxiYWNrZm4sIHRoYXQpO1xuICAgIHZhciBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZShzZWxmKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBjcmVhdGUgPSBzcGVjaWZpY0NyZWF0ZSB8fCBhcnJheVNwZWNpZXNDcmVhdGU7XG4gICAgdmFyIHRhcmdldCA9IElTX01BUCA/IGNyZWF0ZSgkdGhpcywgbGVuZ3RoKSA6IElTX0ZJTFRFUiB8fCBJU19GSUxURVJfUkVKRUNUID8gY3JlYXRlKCR0aGlzLCAwKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgdmFsdWUsIHJlc3VsdDtcbiAgICBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKE5PX0hPTEVTIHx8IGluZGV4IGluIHNlbGYpIHtcbiAgICAgIHZhbHVlID0gc2VsZltpbmRleF07XG4gICAgICByZXN1bHQgPSBib3VuZEZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgTyk7XG4gICAgICBpZiAoVFlQRSkge1xuICAgICAgICBpZiAoSVNfTUFQKSB0YXJnZXRbaW5kZXhdID0gcmVzdWx0OyAvLyBtYXBcbiAgICAgICAgZWxzZSBpZiAocmVzdWx0KSBzd2l0Y2ggKFRZUEUpIHtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiB0cnVlOyAgICAgICAgICAgICAgLy8gc29tZVxuICAgICAgICAgIGNhc2UgNTogcmV0dXJuIHZhbHVlOyAgICAgICAgICAgICAvLyBmaW5kXG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gaW5kZXg7ICAgICAgICAgICAgIC8vIGZpbmRJbmRleFxuICAgICAgICAgIGNhc2UgMjogcHVzaCh0YXJnZXQsIHZhbHVlKTsgICAgICAvLyBmaWx0ZXJcbiAgICAgICAgfSBlbHNlIHN3aXRjaCAoVFlQRSkge1xuICAgICAgICAgIGNhc2UgNDogcmV0dXJuIGZhbHNlOyAgICAgICAgICAgICAvLyBldmVyeVxuICAgICAgICAgIGNhc2UgNzogcHVzaCh0YXJnZXQsIHZhbHVlKTsgICAgICAvLyBmaWx0ZXJSZWplY3RcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogdGFyZ2V0O1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZvcmVhY2hcbiAgZm9yRWFjaDogY3JlYXRlTWV0aG9kKDApLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLm1hcGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLm1hcFxuICBtYXA6IGNyZWF0ZU1ldGhvZCgxKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5maWx0ZXJgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maWx0ZXJcbiAgZmlsdGVyOiBjcmVhdGVNZXRob2QoMiksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuc29tZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNvbWVcbiAgc29tZTogY3JlYXRlTWV0aG9kKDMpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmV2ZXJ5YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZXZlcnlcbiAgZXZlcnk6IGNyZWF0ZU1ldGhvZCg0KSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5maW5kYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZFxuICBmaW5kOiBjcmVhdGVNZXRob2QoNSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZEluZGV4XG4gIGZpbmRJbmRleDogY3JlYXRlTWV0aG9kKDYpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbHRlclJlamVjdGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWFycmF5LWZpbHRlcmluZ1xuICBmaWx0ZXJSZWplY3Q6IGNyZWF0ZU1ldGhvZCg3KVxufTtcbiIsInZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9sZW5ndGgtb2YtYXJyYXktbGlrZScpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eScpO1xuXG52YXIgJEFycmF5ID0gQXJyYXk7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlKE8pO1xuICB2YXIgayA9IHRvQWJzb2x1dGVJbmRleChzdGFydCwgbGVuZ3RoKTtcbiAgdmFyIGZpbiA9IHRvQWJzb2x1dGVJbmRleChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IGVuZCwgbGVuZ3RoKTtcbiAgdmFyIHJlc3VsdCA9ICRBcnJheShtYXgoZmluIC0gaywgMCkpO1xuICBmb3IgKHZhciBuID0gMDsgayA8IGZpbjsgaysrLCBuKyspIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgbiwgT1trXSk7XG4gIHJlc3VsdC5sZW5ndGggPSBuO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsInZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB1bmN1cnJ5VGhpcyhbXS5zbGljZSk7XG4iLCJ2YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1hcnJheScpO1xudmFyIGlzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY29uc3RydWN0b3InKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIFNQRUNJRVMgPSB3ZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcbnZhciAkQXJyYXkgPSBBcnJheTtcblxuLy8gYSBwYXJ0IG9mIGBBcnJheVNwZWNpZXNDcmVhdGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheXNwZWNpZXNjcmVhdGVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9yaWdpbmFsQXJyYXkpIHtcbiAgdmFyIEM7XG4gIGlmIChpc0FycmF5KG9yaWdpbmFsQXJyYXkpKSB7XG4gICAgQyA9IG9yaWdpbmFsQXJyYXkuY29uc3RydWN0b3I7XG4gICAgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcbiAgICBpZiAoaXNDb25zdHJ1Y3RvcihDKSAmJiAoQyA9PT0gJEFycmF5IHx8IGlzQXJyYXkoQy5wcm90b3R5cGUpKSkgQyA9IHVuZGVmaW5lZDtcbiAgICBlbHNlIGlmIChpc09iamVjdChDKSkge1xuICAgICAgQyA9IENbU1BFQ0lFU107XG4gICAgICBpZiAoQyA9PT0gbnVsbCkgQyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gcmV0dXJuIEMgPT09IHVuZGVmaW5lZCA/ICRBcnJheSA6IEM7XG59O1xuIiwidmFyIGFycmF5U3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3InKTtcblxuLy8gYEFycmF5U3BlY2llc0NyZWF0ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5c3BlY2llc2NyZWF0ZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWxBcnJheSwgbGVuZ3RoKSB7XG4gIHJldHVybiBuZXcgKGFycmF5U3BlY2llc0NvbnN0cnVjdG9yKG9yaWdpbmFsQXJyYXkpKShsZW5ndGggPT09IDAgPyAwIDogbGVuZ3RoKTtcbn07XG4iLCJ2YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG5cbnZhciB0b1N0cmluZyA9IHVuY3VycnlUaGlzKHt9LnRvU3RyaW5nKTtcbnZhciBzdHJpbmdTbGljZSA9IHVuY3VycnlUaGlzKCcnLnNsaWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHN0cmluZ1NsaWNlKHRvU3RyaW5nKGl0KSwgOCwgLTEpO1xufTtcbiIsInZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tc3RyaW5nLXRhZy1zdXBwb3J0Jyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIGNsYXNzb2ZSYXcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG52YXIgJE9iamVjdCA9IE9iamVjdDtcblxuLy8gRVMzIHdyb25nIGhlcmVcbnZhciBDT1JSRUNUX0FSR1VNRU5UUyA9IGNsYXNzb2ZSYXcoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbn07XG5cbi8vIGdldHRpbmcgdGFnIGZyb20gRVM2KyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2Bcbm1vZHVsZS5leHBvcnRzID0gVE9fU1RSSU5HX1RBR19TVVBQT1JUID8gY2xhc3NvZlJhdyA6IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgdGFnLCByZXN1bHQ7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mICh0YWcgPSB0cnlHZXQoTyA9ICRPYmplY3QoaXQpLCBUT19TVFJJTkdfVEFHKSkgPT0gJ3N0cmluZycgPyB0YWdcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IENPUlJFQ1RfQVJHVU1FTlRTID8gY2xhc3NvZlJhdyhPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChyZXN1bHQgPSBjbGFzc29mUmF3KE8pKSA9PSAnT2JqZWN0JyAmJiBpc0NhbGxhYmxlKE8uY2FsbGVlKSA/ICdBcmd1bWVudHMnIDogcmVzdWx0O1xufTtcbiIsInZhciBoYXNPd24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eScpO1xudmFyIG93bktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb3duLWtleXMnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UsIGV4Y2VwdGlvbnMpIHtcbiAgdmFyIGtleXMgPSBvd25LZXlzKHNvdXJjZSk7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKCFoYXNPd24odGFyZ2V0LCBrZXkpICYmICEoZXhjZXB0aW9ucyAmJiBoYXNPd24oZXhjZXB0aW9ucywga2V5KSkpIHtcbiAgICAgIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICB9XG4gIH1cbn07XG4iLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGKCkgeyAvKiBlbXB0eSAqLyB9XG4gIEYucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbnVsbDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRwcm90b3R5cGVvZiAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBGKCkpICE9PSBGLnByb3RvdHlwZTtcbn0pO1xuIiwiLy8gYENyZWF0ZUl0ZXJSZXN1bHRPYmplY3RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1jcmVhdGVpdGVycmVzdWx0b2JqZWN0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSwgZG9uZSkge1xuICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6IGRvbmUgfTtcbn07XG4iLCJ2YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gREVTQ1JJUFRPUlMgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKG9iamVjdCwga2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB0b1Byb3BlcnR5S2V5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXByb3BlcnR5LWtleScpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBwcm9wZXJ0eUtleSA9IHRvUHJvcGVydHlLZXkoa2V5KTtcbiAgaWYgKHByb3BlcnR5S2V5IGluIG9iamVjdCkgZGVmaW5lUHJvcGVydHlNb2R1bGUuZihvYmplY3QsIHByb3BlcnR5S2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMCwgdmFsdWUpKTtcbiAgZWxzZSBvYmplY3RbcHJvcGVydHlLZXldID0gdmFsdWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIG9yZGluYXJ5VG9QcmltaXRpdmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb3JkaW5hcnktdG8tcHJpbWl0aXZlJyk7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG4vLyBgRGF0ZS5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV0oaGludClgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1kYXRlLnByb3RvdHlwZS1AQHRvcHJpbWl0aXZlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChoaW50KSB7XG4gIGFuT2JqZWN0KHRoaXMpO1xuICBpZiAoaGludCA9PT0gJ3N0cmluZycgfHwgaGludCA9PT0gJ2RlZmF1bHQnKSBoaW50ID0gJ3N0cmluZyc7XG4gIGVsc2UgaWYgKGhpbnQgIT09ICdudW1iZXInKSB0aHJvdyAkVHlwZUVycm9yKCdJbmNvcnJlY3QgaGludCcpO1xuICByZXR1cm4gb3JkaW5hcnlUb1ByaW1pdGl2ZSh0aGlzLCBoaW50KTtcbn07XG4iLCJ2YXIgbWFrZUJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbWFrZS1idWlsdC1pbicpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBuYW1lLCBkZXNjcmlwdG9yKSB7XG4gIGlmIChkZXNjcmlwdG9yLmdldCkgbWFrZUJ1aWx0SW4oZGVzY3JpcHRvci5nZXQsIG5hbWUsIHsgZ2V0dGVyOiB0cnVlIH0pO1xuICBpZiAoZGVzY3JpcHRvci5zZXQpIG1ha2VCdWlsdEluKGRlc2NyaXB0b3Iuc2V0LCBuYW1lLCB7IHNldHRlcjogdHJ1ZSB9KTtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5LmYodGFyZ2V0LCBuYW1lLCBkZXNjcmlwdG9yKTtcbn07XG4iLCJ2YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcbnZhciBtYWtlQnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9tYWtlLWJ1aWx0LWluJyk7XG52YXIgZGVmaW5lR2xvYmFsUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWdsb2JhbC1wcm9wZXJ0eScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICB2YXIgc2ltcGxlID0gb3B0aW9ucy5lbnVtZXJhYmxlO1xuICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uYW1lIDoga2V5O1xuICBpZiAoaXNDYWxsYWJsZSh2YWx1ZSkpIG1ha2VCdWlsdEluKHZhbHVlLCBuYW1lLCBvcHRpb25zKTtcbiAgaWYgKG9wdGlvbnMuZ2xvYmFsKSB7XG4gICAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gICAgZWxzZSBkZWZpbmVHbG9iYWxQcm9wZXJ0eShrZXksIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFvcHRpb25zLnVuc2FmZSkgZGVsZXRlIE9ba2V5XTtcbiAgICAgIGVsc2UgaWYgKE9ba2V5XSkgc2ltcGxlID0gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gICAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gICAgZWxzZSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKE8sIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6ICFvcHRpb25zLm5vbkNvbmZpZ3VyYWJsZSxcbiAgICAgIHdyaXRhYmxlOiAhb3B0aW9ucy5ub25Xcml0YWJsZVxuICAgIH0pO1xuICB9IHJldHVybiBPO1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgZGVmaW5lUHJvcGVydHkoZ2xvYmFsLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGdsb2JhbFtrZXldID0gdmFsdWU7XG4gIH0gcmV0dXJuIHZhbHVlO1xufTtcbiIsInZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG4vLyBEZXRlY3QgSUU4J3MgaW5jb21wbGV0ZSBkZWZpbmVQcm9wZXJ0eSBpbXBsZW1lbnRhdGlvblxubW9kdWxlLmV4cG9ydHMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIDEsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pWzFdICE9IDc7XG59KTtcbiIsInZhciBkb2N1bWVudEFsbCA9IHR5cGVvZiBkb2N1bWVudCA9PSAnb2JqZWN0JyAmJiBkb2N1bWVudC5hbGw7XG5cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtSXNIVE1MRERBLWludGVybmFsLXNsb3Rcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL25vLXR5cGVvZi11bmRlZmluZWQgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbnZhciBJU19IVE1MRERBID0gdHlwZW9mIGRvY3VtZW50QWxsID09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50QWxsICE9PSB1bmRlZmluZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhbGw6IGRvY3VtZW50QWxsLFxuICBJU19IVE1MRERBOiBJU19IVE1MRERBXG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcblxudmFyIGRvY3VtZW50ID0gZ2xvYmFsLmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgRVhJU1RTID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gRVhJU1RTID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG4iLCIvLyBpdGVyYWJsZSBET00gY29sbGVjdGlvbnNcbi8vIGZsYWcgLSBgaXRlcmFibGVgIGludGVyZmFjZSAtICdlbnRyaWVzJywgJ2tleXMnLCAndmFsdWVzJywgJ2ZvckVhY2gnIG1ldGhvZHNcbm1vZHVsZS5leHBvcnRzID0ge1xuICBDU1NSdWxlTGlzdDogMCxcbiAgQ1NTU3R5bGVEZWNsYXJhdGlvbjogMCxcbiAgQ1NTVmFsdWVMaXN0OiAwLFxuICBDbGllbnRSZWN0TGlzdDogMCxcbiAgRE9NUmVjdExpc3Q6IDAsXG4gIERPTVN0cmluZ0xpc3Q6IDAsXG4gIERPTVRva2VuTGlzdDogMSxcbiAgRGF0YVRyYW5zZmVySXRlbUxpc3Q6IDAsXG4gIEZpbGVMaXN0OiAwLFxuICBIVE1MQWxsQ29sbGVjdGlvbjogMCxcbiAgSFRNTENvbGxlY3Rpb246IDAsXG4gIEhUTUxGb3JtRWxlbWVudDogMCxcbiAgSFRNTFNlbGVjdEVsZW1lbnQ6IDAsXG4gIE1lZGlhTGlzdDogMCxcbiAgTWltZVR5cGVBcnJheTogMCxcbiAgTmFtZWROb2RlTWFwOiAwLFxuICBOb2RlTGlzdDogMSxcbiAgUGFpbnRSZXF1ZXN0TGlzdDogMCxcbiAgUGx1Z2luOiAwLFxuICBQbHVnaW5BcnJheTogMCxcbiAgU1ZHTGVuZ3RoTGlzdDogMCxcbiAgU1ZHTnVtYmVyTGlzdDogMCxcbiAgU1ZHUGF0aFNlZ0xpc3Q6IDAsXG4gIFNWR1BvaW50TGlzdDogMCxcbiAgU1ZHU3RyaW5nTGlzdDogMCxcbiAgU1ZHVHJhbnNmb3JtTGlzdDogMCxcbiAgU291cmNlQnVmZmVyTGlzdDogMCxcbiAgU3R5bGVTaGVldExpc3Q6IDAsXG4gIFRleHRUcmFja0N1ZUxpc3Q6IDAsXG4gIFRleHRUcmFja0xpc3Q6IDAsXG4gIFRvdWNoTGlzdDogMFxufTtcbiIsIi8vIGluIG9sZCBXZWJLaXQgdmVyc2lvbnMsIGBlbGVtZW50LmNsYXNzTGlzdGAgaXMgbm90IGFuIGluc3RhbmNlIG9mIGdsb2JhbCBgRE9NVG9rZW5MaXN0YFxudmFyIGRvY3VtZW50Q3JlYXRlRWxlbWVudCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kb2N1bWVudC1jcmVhdGUtZWxlbWVudCcpO1xuXG52YXIgY2xhc3NMaXN0ID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50KCdzcGFuJykuY2xhc3NMaXN0O1xudmFyIERPTVRva2VuTGlzdFByb3RvdHlwZSA9IGNsYXNzTGlzdCAmJiBjbGFzc0xpc3QuY29uc3RydWN0b3IgJiYgY2xhc3NMaXN0LmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01Ub2tlbkxpc3RQcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGUgPyB1bmRlZmluZWQgOiBET01Ub2tlbkxpc3RQcm90b3R5cGU7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gJ3VuZGVmaW5lZCcgJiYgU3RyaW5nKG5hdmlnYXRvci51c2VyQWdlbnQpIHx8ICcnO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciB1c2VyQWdlbnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLXVzZXItYWdlbnQnKTtcblxudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciBEZW5vID0gZ2xvYmFsLkRlbm87XG52YXIgdmVyc2lvbnMgPSBwcm9jZXNzICYmIHByb2Nlc3MudmVyc2lvbnMgfHwgRGVubyAmJiBEZW5vLnZlcnNpb247XG52YXIgdjggPSB2ZXJzaW9ucyAmJiB2ZXJzaW9ucy52ODtcbnZhciBtYXRjaCwgdmVyc2lvbjtcblxuaWYgKHY4KSB7XG4gIG1hdGNoID0gdjguc3BsaXQoJy4nKTtcbiAgLy8gaW4gb2xkIENocm9tZSwgdmVyc2lvbnMgb2YgVjggaXNuJ3QgVjggPSBDaHJvbWUgLyAxMFxuICAvLyBidXQgdGhlaXIgY29ycmVjdCB2ZXJzaW9ucyBhcmUgbm90IGludGVyZXN0aW5nIGZvciB1c1xuICB2ZXJzaW9uID0gbWF0Y2hbMF0gPiAwICYmIG1hdGNoWzBdIDwgNCA/IDEgOiArKG1hdGNoWzBdICsgbWF0Y2hbMV0pO1xufVxuXG4vLyBCcm93c2VyRlMgTm9kZUpTIGBwcm9jZXNzYCBwb2x5ZmlsbCBpbmNvcnJlY3RseSBzZXQgYC52OGAgdG8gYDAuMGBcbi8vIHNvIGNoZWNrIGB1c2VyQWdlbnRgIGV2ZW4gaWYgYC52OGAgZXhpc3RzLCBidXQgMFxuaWYgKCF2ZXJzaW9uICYmIHVzZXJBZ2VudCkge1xuICBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvRWRnZVxcLyhcXGQrKS8pO1xuICBpZiAoIW1hdGNoIHx8IG1hdGNoWzFdID49IDc0KSB7XG4gICAgbWF0Y2ggPSB1c2VyQWdlbnQubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS8pO1xuICAgIGlmIChtYXRjaCkgdmVyc2lvbiA9ICttYXRjaFsxXTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHZlcnNpb247XG4iLCIvLyBJRTgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gW1xuICAnY29uc3RydWN0b3InLFxuICAnaGFzT3duUHJvcGVydHknLFxuICAnaXNQcm90b3R5cGVPZicsXG4gICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG4gICd0b0xvY2FsZVN0cmluZycsXG4gICd0b1N0cmluZycsXG4gICd2YWx1ZU9mJ1xuXTtcbiIsInZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcblxudmFyICRFcnJvciA9IEVycm9yO1xudmFyIHJlcGxhY2UgPSB1bmN1cnJ5VGhpcygnJy5yZXBsYWNlKTtcblxudmFyIFRFU1QgPSAoZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gU3RyaW5nKCRFcnJvcihhcmcpLnN0YWNrKTsgfSkoJ3p4Y2FzZCcpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlZG9zL25vLXZ1bG5lcmFibGUgLS0gc2FmZVxudmFyIFY4X09SX0NIQUtSQV9TVEFDS19FTlRSWSA9IC9cXG5cXHMqYXQgW146XSo6W15cXG5dKi87XG52YXIgSVNfVjhfT1JfQ0hBS1JBX1NUQUNLID0gVjhfT1JfQ0hBS1JBX1NUQUNLX0VOVFJZLnRlc3QoVEVTVCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0YWNrLCBkcm9wRW50cmllcykge1xuICBpZiAoSVNfVjhfT1JfQ0hBS1JBX1NUQUNLICYmIHR5cGVvZiBzdGFjayA9PSAnc3RyaW5nJyAmJiAhJEVycm9yLnByZXBhcmVTdGFja1RyYWNlKSB7XG4gICAgd2hpbGUgKGRyb3BFbnRyaWVzLS0pIHN0YWNrID0gcmVwbGFjZShzdGFjaywgVjhfT1JfQ0hBS1JBX1NUQUNLX0VOVFJZLCAnJyk7XG4gIH0gcmV0dXJuIHN0YWNrO1xufTtcbiIsInZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG52YXIgY2xlYXJFcnJvclN0YWNrID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Vycm9yLXN0YWNrLWNsZWFyJyk7XG52YXIgRVJST1JfU1RBQ0tfSU5TVEFMTEFCTEUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXJyb3Itc3RhY2staW5zdGFsbGFibGUnKTtcblxuLy8gbm9uLXN0YW5kYXJkIFY4XG52YXIgY2FwdHVyZVN0YWNrVHJhY2UgPSBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXJyb3IsIEMsIHN0YWNrLCBkcm9wRW50cmllcykge1xuICBpZiAoRVJST1JfU1RBQ0tfSU5TVEFMTEFCTEUpIHtcbiAgICBpZiAoY2FwdHVyZVN0YWNrVHJhY2UpIGNhcHR1cmVTdGFja1RyYWNlKGVycm9yLCBDKTtcbiAgICBlbHNlIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShlcnJvciwgJ3N0YWNrJywgY2xlYXJFcnJvclN0YWNrKHN0YWNrLCBkcm9wRW50cmllcykpO1xuICB9XG59O1xuIiwidmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVycm9yID0gRXJyb3IoJ2EnKTtcbiAgaWYgKCEoJ3N0YWNrJyBpbiBlcnJvcikpIHJldHVybiB0cnVlO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVycm9yLCAnc3RhY2snLCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgNykpO1xuICByZXR1cm4gZXJyb3Iuc3RhY2sgIT09IDc7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUnKTtcbnZhciBub3JtYWxpemVTdHJpbmdBcmd1bWVudCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9ub3JtYWxpemUtc3RyaW5nLWFyZ3VtZW50Jyk7XG5cbnZhciBuYXRpdmVFcnJvclRvU3RyaW5nID0gRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nO1xuXG52YXIgSU5DT1JSRUNUX1RPX1NUUklORyA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgaWYgKERFU0NSSVBUT1JTKSB7XG4gICAgLy8gQ2hyb21lIDMyLSBpbmNvcnJlY3RseSBjYWxsIGFjY2Vzc29yXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG4gICAgdmFyIG9iamVjdCA9IGNyZWF0ZShPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICduYW1lJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzID09PSBvYmplY3Q7XG4gICAgfSB9KSk7XG4gICAgaWYgKG5hdGl2ZUVycm9yVG9TdHJpbmcuY2FsbChvYmplY3QpICE9PSAndHJ1ZScpIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIEZGMTAtIGRvZXMgbm90IHByb3Blcmx5IGhhbmRsZSBub24tc3RyaW5nc1xuICByZXR1cm4gbmF0aXZlRXJyb3JUb1N0cmluZy5jYWxsKHsgbWVzc2FnZTogMSwgbmFtZTogMiB9KSAhPT0gJzI6IDEnXG4gICAgLy8gSUU4IGRvZXMgbm90IHByb3Blcmx5IGhhbmRsZSBkZWZhdWx0c1xuICAgIHx8IG5hdGl2ZUVycm9yVG9TdHJpbmcuY2FsbCh7fSkgIT09ICdFcnJvcic7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBJTkNPUlJFQ1RfVE9fU1RSSU5HID8gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHZhciBPID0gYW5PYmplY3QodGhpcyk7XG4gIHZhciBuYW1lID0gbm9ybWFsaXplU3RyaW5nQXJndW1lbnQoTy5uYW1lLCAnRXJyb3InKTtcbiAgdmFyIG1lc3NhZ2UgPSBub3JtYWxpemVTdHJpbmdBcmd1bWVudChPLm1lc3NhZ2UpO1xuICByZXR1cm4gIW5hbWUgPyBtZXNzYWdlIDogIW1lc3NhZ2UgPyBuYW1lIDogbmFtZSArICc6ICcgKyBtZXNzYWdlO1xufSA6IG5hdGl2ZUVycm9yVG9TdHJpbmc7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJykuZjtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG52YXIgZGVmaW5lQnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4nKTtcbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtZ2xvYmFsLXByb3BlcnR5Jyk7XG52YXIgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jb3B5LWNvbnN0cnVjdG9yLXByb3BlcnRpZXMnKTtcbnZhciBpc0ZvcmNlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1mb3JjZWQnKTtcblxuLypcbiAgb3B0aW9ucy50YXJnZXQgICAgICAgICAtIG5hbWUgb2YgdGhlIHRhcmdldCBvYmplY3RcbiAgb3B0aW9ucy5nbG9iYWwgICAgICAgICAtIHRhcmdldCBpcyB0aGUgZ2xvYmFsIG9iamVjdFxuICBvcHRpb25zLnN0YXQgICAgICAgICAgIC0gZXhwb3J0IGFzIHN0YXRpYyBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnByb3RvICAgICAgICAgIC0gZXhwb3J0IGFzIHByb3RvdHlwZSBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnJlYWwgICAgICAgICAgIC0gcmVhbCBwcm90b3R5cGUgbWV0aG9kIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy5mb3JjZWQgICAgICAgICAtIGV4cG9ydCBldmVuIGlmIHRoZSBuYXRpdmUgZmVhdHVyZSBpcyBhdmFpbGFibGVcbiAgb3B0aW9ucy5iaW5kICAgICAgICAgICAtIGJpbmQgbWV0aG9kcyB0byB0aGUgdGFyZ2V0LCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMud3JhcCAgICAgICAgICAgLSB3cmFwIGNvbnN0cnVjdG9ycyB0byBwcmV2ZW50aW5nIGdsb2JhbCBwb2xsdXRpb24sIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy51bnNhZmUgICAgICAgICAtIHVzZSB0aGUgc2ltcGxlIGFzc2lnbm1lbnQgb2YgcHJvcGVydHkgaW5zdGVhZCBvZiBkZWxldGUgKyBkZWZpbmVQcm9wZXJ0eVxuICBvcHRpb25zLnNoYW0gICAgICAgICAgIC0gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuICBvcHRpb25zLmVudW1lcmFibGUgICAgIC0gZXhwb3J0IGFzIGVudW1lcmFibGUgcHJvcGVydHlcbiAgb3B0aW9ucy5kb250Q2FsbEdldFNldCAtIHByZXZlbnQgY2FsbGluZyBhIGdldHRlciBvbiB0YXJnZXRcbiAgb3B0aW9ucy5uYW1lICAgICAgICAgICAtIHRoZSAubmFtZSBvZiB0aGUgZnVuY3Rpb24gaWYgaXQgZG9lcyBub3QgbWF0Y2ggdGhlIGtleVxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xuICB2YXIgVEFSR0VUID0gb3B0aW9ucy50YXJnZXQ7XG4gIHZhciBHTE9CQUwgPSBvcHRpb25zLmdsb2JhbDtcbiAgdmFyIFNUQVRJQyA9IG9wdGlvbnMuc3RhdDtcbiAgdmFyIEZPUkNFRCwgdGFyZ2V0LCBrZXksIHRhcmdldFByb3BlcnR5LCBzb3VyY2VQcm9wZXJ0eSwgZGVzY3JpcHRvcjtcbiAgaWYgKEdMT0JBTCkge1xuICAgIHRhcmdldCA9IGdsb2JhbDtcbiAgfSBlbHNlIGlmIChTVEFUSUMpIHtcbiAgICB0YXJnZXQgPSBnbG9iYWxbVEFSR0VUXSB8fCBkZWZpbmVHbG9iYWxQcm9wZXJ0eShUQVJHRVQsIHt9KTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQgPSAoZ2xvYmFsW1RBUkdFVF0gfHwge30pLnByb3RvdHlwZTtcbiAgfVxuICBpZiAodGFyZ2V0KSBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICBzb3VyY2VQcm9wZXJ0eSA9IHNvdXJjZVtrZXldO1xuICAgIGlmIChvcHRpb25zLmRvbnRDYWxsR2V0U2V0KSB7XG4gICAgICBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KTtcbiAgICAgIHRhcmdldFByb3BlcnR5ID0gZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIH0gZWxzZSB0YXJnZXRQcm9wZXJ0eSA9IHRhcmdldFtrZXldO1xuICAgIEZPUkNFRCA9IGlzRm9yY2VkKEdMT0JBTCA/IGtleSA6IFRBUkdFVCArIChTVEFUSUMgPyAnLicgOiAnIycpICsga2V5LCBvcHRpb25zLmZvcmNlZCk7XG4gICAgLy8gY29udGFpbmVkIGluIHRhcmdldFxuICAgIGlmICghRk9SQ0VEICYmIHRhcmdldFByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2Ygc291cmNlUHJvcGVydHkgPT0gdHlwZW9mIHRhcmdldFByb3BlcnR5KSBjb250aW51ZTtcbiAgICAgIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMoc291cmNlUHJvcGVydHksIHRhcmdldFByb3BlcnR5KTtcbiAgICB9XG4gICAgLy8gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuICAgIGlmIChvcHRpb25zLnNoYW0gfHwgKHRhcmdldFByb3BlcnR5ICYmIHRhcmdldFByb3BlcnR5LnNoYW0pKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoc291cmNlUHJvcGVydHksICdzaGFtJywgdHJ1ZSk7XG4gICAgfVxuICAgIGRlZmluZUJ1aWx0SW4odGFyZ2V0LCBrZXksIHNvdXJjZVByb3BlcnR5LCBvcHRpb25zKTtcbiAgfVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG4iLCJ2YXIgTkFUSVZFX0JJTkQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1uYXRpdmUnKTtcblxudmFyIEZ1bmN0aW9uUHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIGFwcGx5ID0gRnVuY3Rpb25Qcm90b3R5cGUuYXBwbHk7XG52YXIgY2FsbCA9IEZ1bmN0aW9uUHJvdG90eXBlLmNhbGw7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1yZWZsZWN0IC0tIHNhZmVcbm1vZHVsZS5leHBvcnRzID0gdHlwZW9mIFJlZmxlY3QgPT0gJ29iamVjdCcgJiYgUmVmbGVjdC5hcHBseSB8fCAoTkFUSVZFX0JJTkQgPyBjYWxsLmJpbmQoYXBwbHkpIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY2FsbC5hcHBseShhcHBseSwgYXJndW1lbnRzKTtcbn0pO1xuIiwidmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy1jbGF1c2UnKTtcbnZhciBhQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1jYWxsYWJsZScpO1xudmFyIE5BVElWRV9CSU5EID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtbmF0aXZlJyk7XG5cbnZhciBiaW5kID0gdW5jdXJyeVRoaXModW5jdXJyeVRoaXMuYmluZCk7XG5cbi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIHRoYXQpIHtcbiAgYUNhbGxhYmxlKGZuKTtcbiAgcmV0dXJuIHRoYXQgPT09IHVuZGVmaW5lZCA/IGZuIDogTkFUSVZFX0JJTkQgPyBiaW5kKGZuLCB0aGF0KSA6IGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuIiwidmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWZ1bmN0aW9uLXByb3RvdHlwZS1iaW5kIC0tIHNhZmVcbiAgdmFyIHRlc3QgPSAoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KS5iaW5kKCk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgLS0gc2FmZVxuICByZXR1cm4gdHlwZW9mIHRlc3QgIT0gJ2Z1bmN0aW9uJyB8fCB0ZXN0Lmhhc093blByb3BlcnR5KCdwcm90b3R5cGUnKTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xudmFyIGFDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLWNhbGxhYmxlJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcbnZhciBhcnJheVNsaWNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LXNsaWNlJyk7XG52YXIgTkFUSVZFX0JJTkQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1uYXRpdmUnKTtcblxudmFyICRGdW5jdGlvbiA9IEZ1bmN0aW9uO1xudmFyIGNvbmNhdCA9IHVuY3VycnlUaGlzKFtdLmNvbmNhdCk7XG52YXIgam9pbiA9IHVuY3VycnlUaGlzKFtdLmpvaW4pO1xudmFyIGZhY3RvcmllcyA9IHt9O1xuXG52YXIgY29uc3RydWN0ID0gZnVuY3Rpb24gKEMsIGFyZ3NMZW5ndGgsIGFyZ3MpIHtcbiAgaWYgKCFoYXNPd24oZmFjdG9yaWVzLCBhcmdzTGVuZ3RoKSkge1xuICAgIGZvciAodmFyIGxpc3QgPSBbXSwgaSA9IDA7IGkgPCBhcmdzTGVuZ3RoOyBpKyspIGxpc3RbaV0gPSAnYVsnICsgaSArICddJztcbiAgICBmYWN0b3JpZXNbYXJnc0xlbmd0aF0gPSAkRnVuY3Rpb24oJ0MsYScsICdyZXR1cm4gbmV3IEMoJyArIGpvaW4obGlzdCwgJywnKSArICcpJyk7XG4gIH0gcmV0dXJuIGZhY3Rvcmllc1thcmdzTGVuZ3RoXShDLCBhcmdzKTtcbn07XG5cbi8vIGBGdW5jdGlvbi5wcm90b3R5cGUuYmluZGAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tZnVuY3Rpb24tcHJvdG90eXBlLWJpbmQgLS0gZGV0ZWN0aW9uXG5tb2R1bGUuZXhwb3J0cyA9IE5BVElWRV9CSU5EID8gJEZ1bmN0aW9uLmJpbmQgOiBmdW5jdGlvbiBiaW5kKHRoYXQgLyogLCAuLi5hcmdzICovKSB7XG4gIHZhciBGID0gYUNhbGxhYmxlKHRoaXMpO1xuICB2YXIgUHJvdG90eXBlID0gRi5wcm90b3R5cGU7XG4gIHZhciBwYXJ0QXJncyA9IGFycmF5U2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgdmFyIGJvdW5kRnVuY3Rpb24gPSBmdW5jdGlvbiBib3VuZCgvKiBhcmdzLi4uICovKSB7XG4gICAgdmFyIGFyZ3MgPSBjb25jYXQocGFydEFyZ3MsIGFycmF5U2xpY2UoYXJndW1lbnRzKSk7XG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBib3VuZEZ1bmN0aW9uID8gY29uc3RydWN0KEYsIGFyZ3MubGVuZ3RoLCBhcmdzKSA6IEYuYXBwbHkodGhhdCwgYXJncyk7XG4gIH07XG4gIGlmIChpc09iamVjdChQcm90b3R5cGUpKSBib3VuZEZ1bmN0aW9uLnByb3RvdHlwZSA9IFByb3RvdHlwZTtcbiAgcmV0dXJuIGJvdW5kRnVuY3Rpb247XG59O1xuIiwidmFyIE5BVElWRV9CSU5EID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtbmF0aXZlJyk7XG5cbnZhciBjYWxsID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGw7XG5cbm1vZHVsZS5leHBvcnRzID0gTkFUSVZFX0JJTkQgPyBjYWxsLmJpbmQoY2FsbCkgOiBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBjYWxsLmFwcGx5KGNhbGwsIGFyZ3VtZW50cyk7XG59O1xuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcblxudmFyIEZ1bmN0aW9uUHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyIGdldERlc2NyaXB0b3IgPSBERVNDUklQVE9SUyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG52YXIgRVhJU1RTID0gaGFzT3duKEZ1bmN0aW9uUHJvdG90eXBlLCAnbmFtZScpO1xuLy8gYWRkaXRpb25hbCBwcm90ZWN0aW9uIGZyb20gbWluaWZpZWQgLyBtYW5nbGVkIC8gZHJvcHBlZCBmdW5jdGlvbiBuYW1lc1xudmFyIFBST1BFUiA9IEVYSVNUUyAmJiAoZnVuY3Rpb24gc29tZXRoaW5nKCkgeyAvKiBlbXB0eSAqLyB9KS5uYW1lID09PSAnc29tZXRoaW5nJztcbnZhciBDT05GSUdVUkFCTEUgPSBFWElTVFMgJiYgKCFERVNDUklQVE9SUyB8fCAoREVTQ1JJUFRPUlMgJiYgZ2V0RGVzY3JpcHRvcihGdW5jdGlvblByb3RvdHlwZSwgJ25hbWUnKS5jb25maWd1cmFibGUpKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEVYSVNUUzogRVhJU1RTLFxuICBQUk9QRVI6IFBST1BFUixcbiAgQ09ORklHVVJBQkxFOiBDT05GSUdVUkFCTEVcbn07XG4iLCJ2YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgYUNhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2EtY2FsbGFibGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBrZXksIG1ldGhvZCkge1xuICB0cnkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbiAgICByZXR1cm4gdW5jdXJyeVRoaXMoYUNhbGxhYmxlKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBrZXkpW21ldGhvZF0pKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxufTtcbiIsInZhciBjbGFzc29mUmF3ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3Jyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuKSB7XG4gIC8vIE5hc2hvcm4gYnVnOlxuICAvLyAgIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xMTI4XG4gIC8vICAgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzExMzBcbiAgaWYgKGNsYXNzb2ZSYXcoZm4pID09PSAnRnVuY3Rpb24nKSByZXR1cm4gdW5jdXJyeVRoaXMoZm4pO1xufTtcbiIsInZhciBOQVRJVkVfQklORCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLW5hdGl2ZScpO1xuXG52YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgY2FsbCA9IEZ1bmN0aW9uUHJvdG90eXBlLmNhbGw7XG52YXIgdW5jdXJyeVRoaXNXaXRoQmluZCA9IE5BVElWRV9CSU5EICYmIEZ1bmN0aW9uUHJvdG90eXBlLmJpbmQuYmluZChjYWxsLCBjYWxsKTtcblxubW9kdWxlLmV4cG9ydHMgPSBOQVRJVkVfQklORCA/IHVuY3VycnlUaGlzV2l0aEJpbmQgOiBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2FsbC5hcHBseShmbiwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcblxudmFyIGFGdW5jdGlvbiA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gaXNDYWxsYWJsZShhcmd1bWVudCkgPyBhcmd1bWVudCA6IHVuZGVmaW5lZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgbWV0aG9kKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGFGdW5jdGlvbihnbG9iYWxbbmFtZXNwYWNlXSkgOiBnbG9iYWxbbmFtZXNwYWNlXSAmJiBnbG9iYWxbbmFtZXNwYWNlXVttZXRob2RdO1xufTtcbiIsInZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWFycmF5Jyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcbnZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1zdHJpbmcnKTtcblxudmFyIHB1c2ggPSB1bmN1cnJ5VGhpcyhbXS5wdXNoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocmVwbGFjZXIpIHtcbiAgaWYgKGlzQ2FsbGFibGUocmVwbGFjZXIpKSByZXR1cm4gcmVwbGFjZXI7XG4gIGlmICghaXNBcnJheShyZXBsYWNlcikpIHJldHVybjtcbiAgdmFyIHJhd0xlbmd0aCA9IHJlcGxhY2VyLmxlbmd0aDtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXdMZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGVtZW50ID0gcmVwbGFjZXJbaV07XG4gICAgaWYgKHR5cGVvZiBlbGVtZW50ID09ICdzdHJpbmcnKSBwdXNoKGtleXMsIGVsZW1lbnQpO1xuICAgIGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50ID09ICdudW1iZXInIHx8IGNsYXNzb2YoZWxlbWVudCkgPT0gJ051bWJlcicgfHwgY2xhc3NvZihlbGVtZW50KSA9PSAnU3RyaW5nJykgcHVzaChrZXlzLCB0b1N0cmluZyhlbGVtZW50KSk7XG4gIH1cbiAgdmFyIGtleXNMZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIHJvb3QgPSB0cnVlO1xuICByZXR1cm4gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICBpZiAocm9vdCkge1xuICAgICAgcm9vdCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoaXNBcnJheSh0aGlzKSkgcmV0dXJuIHZhbHVlO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwga2V5c0xlbmd0aDsgaisrKSBpZiAoa2V5c1tqXSA9PT0ga2V5KSByZXR1cm4gdmFsdWU7XG4gIH07XG59O1xuIiwidmFyIGFDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLWNhbGxhYmxlJyk7XG52YXIgaXNOdWxsT3JVbmRlZmluZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtbnVsbC1vci11bmRlZmluZWQnKTtcblxuLy8gYEdldE1ldGhvZGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldG1ldGhvZFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoViwgUCkge1xuICB2YXIgZnVuYyA9IFZbUF07XG4gIHJldHVybiBpc051bGxPclVuZGVmaW5lZChmdW5jKSA/IHVuZGVmaW5lZCA6IGFDYWxsYWJsZShmdW5jKTtcbn07XG4iLCJ2YXIgY2hlY2sgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICYmIGl0Lk1hdGggPT0gTWF0aCAmJiBpdDtcbn07XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG5tb2R1bGUuZXhwb3J0cyA9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1nbG9iYWwtdGhpcyAtLSBzYWZlXG4gIGNoZWNrKHR5cGVvZiBnbG9iYWxUaGlzID09ICdvYmplY3QnICYmIGdsb2JhbFRoaXMpIHx8XG4gIGNoZWNrKHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93KSB8fFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzIC0tIHNhZmVcbiAgY2hlY2sodHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZikgfHxcbiAgY2hlY2sodHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwpIHx8XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuYyAtLSBmYWxsYmFja1xuICAoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSkoKSB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuIiwidmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSB1bmN1cnJ5VGhpcyh7fS5oYXNPd25Qcm9wZXJ0eSk7XG5cbi8vIGBIYXNPd25Qcm9wZXJ0eWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWhhc293bnByb3BlcnR5XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWhhc293biAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5oYXNPd24gfHwgZnVuY3Rpb24gaGFzT3duKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5KHRvT2JqZWN0KGl0KSwga2V5KTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuIiwidmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QnVpbHRJbignZG9jdW1lbnQnLCAnZG9jdW1lbnRFbGVtZW50Jyk7XG4iLCJ2YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGNyZWF0ZUVsZW1lbnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQnKTtcblxuLy8gVGhhbmtzIHRvIElFOCBmb3IgaXRzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFERVNDUklQVE9SUyAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3JlYXRlRWxlbWVudCgnZGl2JyksICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfVxuICB9KS5hICE9IDc7XG59KTtcbiIsInZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcblxudmFyICRPYmplY3QgPSBPYmplY3Q7XG52YXIgc3BsaXQgPSB1bmN1cnJ5VGhpcygnJy5zcGxpdCk7XG5cbi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG5tb2R1bGUuZXhwb3J0cyA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gdGhyb3dzIGFuIGVycm9yIGluIHJoaW5vLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvcmhpbm8vaXNzdWVzLzM0NlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcbiAgcmV0dXJuICEkT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCk7XG59KSA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY2xhc3NvZihpdCkgPT0gJ1N0cmluZycgPyBzcGxpdChpdCwgJycpIDogJE9iamVjdChpdCk7XG59IDogJE9iamVjdDtcbiIsInZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YnKTtcblxuLy8gbWFrZXMgc3ViY2xhc3Npbmcgd29yayBjb3JyZWN0IGZvciB3cmFwcGVkIGJ1aWx0LWluc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoJHRoaXMsIGR1bW15LCBXcmFwcGVyKSB7XG4gIHZhciBOZXdUYXJnZXQsIE5ld1RhcmdldFByb3RvdHlwZTtcbiAgaWYgKFxuICAgIC8vIGl0IGNhbiB3b3JrIG9ubHkgd2l0aCBuYXRpdmUgYHNldFByb3RvdHlwZU9mYFxuICAgIHNldFByb3RvdHlwZU9mICYmXG4gICAgLy8gd2UgaGF2ZW4ndCBjb21wbGV0ZWx5IGNvcnJlY3QgcHJlLUVTNiB3YXkgZm9yIGdldHRpbmcgYG5ldy50YXJnZXRgLCBzbyB1c2UgdGhpc1xuICAgIGlzQ2FsbGFibGUoTmV3VGFyZ2V0ID0gZHVtbXkuY29uc3RydWN0b3IpICYmXG4gICAgTmV3VGFyZ2V0ICE9PSBXcmFwcGVyICYmXG4gICAgaXNPYmplY3QoTmV3VGFyZ2V0UHJvdG90eXBlID0gTmV3VGFyZ2V0LnByb3RvdHlwZSkgJiZcbiAgICBOZXdUYXJnZXRQcm90b3R5cGUgIT09IFdyYXBwZXIucHJvdG90eXBlXG4gICkgc2V0UHJvdG90eXBlT2YoJHRoaXMsIE5ld1RhcmdldFByb3RvdHlwZSk7XG4gIHJldHVybiAkdGhpcztcbn07XG4iLCJ2YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIHN0b3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZC1zdG9yZScpO1xuXG52YXIgZnVuY3Rpb25Ub1N0cmluZyA9IHVuY3VycnlUaGlzKEZ1bmN0aW9uLnRvU3RyaW5nKTtcblxuLy8gdGhpcyBoZWxwZXIgYnJva2VuIGluIGBjb3JlLWpzQDMuNC4xLTMuNC40YCwgc28gd2UgY2FuJ3QgdXNlIGBzaGFyZWRgIGhlbHBlclxuaWYgKCFpc0NhbGxhYmxlKHN0b3JlLmluc3BlY3RTb3VyY2UpKSB7XG4gIHN0b3JlLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb25Ub1N0cmluZyhpdCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RvcmUuaW5zcGVjdFNvdXJjZTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG5cbi8vIGBJbnN0YWxsRXJyb3JDYXVzZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvcHJvcG9zYWwtZXJyb3ItY2F1c2UvI3NlYy1lcnJvcm9iamVjdHMtaW5zdGFsbC1lcnJvci1jYXVzZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywgb3B0aW9ucykge1xuICBpZiAoaXNPYmplY3Qob3B0aW9ucykgJiYgJ2NhdXNlJyBpbiBvcHRpb25zKSB7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KE8sICdjYXVzZScsIG9wdGlvbnMuY2F1c2UpO1xuICB9XG59O1xuIiwidmFyIE5BVElWRV9XRUFLX01BUCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWFrLW1hcC1iYXNpYy1kZXRlY3Rpb24nKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eScpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZC1zdG9yZScpO1xudmFyIHNoYXJlZEtleSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQta2V5Jyk7XG52YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oaWRkZW4ta2V5cycpO1xuXG52YXIgT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQgPSAnT2JqZWN0IGFscmVhZHkgaW5pdGlhbGl6ZWQnO1xudmFyIFR5cGVFcnJvciA9IGdsb2JhbC5UeXBlRXJyb3I7XG52YXIgV2Vha01hcCA9IGdsb2JhbC5XZWFrTWFwO1xudmFyIHNldCwgZ2V0LCBoYXM7XG5cbnZhciBlbmZvcmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBoYXMoaXQpID8gZ2V0KGl0KSA6IHNldChpdCwge30pO1xufTtcblxudmFyIGdldHRlckZvciA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaXQpIHtcbiAgICB2YXIgc3RhdGU7XG4gICAgaWYgKCFpc09iamVjdChpdCkgfHwgKHN0YXRlID0gZ2V0KGl0KSkudHlwZSAhPT0gVFlQRSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdJbmNvbXBhdGlibGUgcmVjZWl2ZXIsICcgKyBUWVBFICsgJyByZXF1aXJlZCcpO1xuICAgIH0gcmV0dXJuIHN0YXRlO1xuICB9O1xufTtcblxuaWYgKE5BVElWRV9XRUFLX01BUCB8fCBzaGFyZWQuc3RhdGUpIHtcbiAgdmFyIHN0b3JlID0gc2hhcmVkLnN0YXRlIHx8IChzaGFyZWQuc3RhdGUgPSBuZXcgV2Vha01hcCgpKTtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tc2VsZi1hc3NpZ24gLS0gcHJvdG90eXBlIG1ldGhvZHMgcHJvdGVjdGlvbiAqL1xuICBzdG9yZS5nZXQgPSBzdG9yZS5nZXQ7XG4gIHN0b3JlLmhhcyA9IHN0b3JlLmhhcztcbiAgc3RvcmUuc2V0ID0gc3RvcmUuc2V0O1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNlbGYtYXNzaWduIC0tIHByb3RvdHlwZSBtZXRob2RzIHByb3RlY3Rpb24gKi9cbiAgc2V0ID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIGlmIChzdG9yZS5oYXMoaXQpKSB0aHJvdyBUeXBlRXJyb3IoT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQpO1xuICAgIG1ldGFkYXRhLmZhY2FkZSA9IGl0O1xuICAgIHN0b3JlLnNldChpdCwgbWV0YWRhdGEpO1xuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfTtcbiAgZ2V0ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHN0b3JlLmdldChpdCkgfHwge307XG4gIH07XG4gIGhhcyA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBzdG9yZS5oYXMoaXQpO1xuICB9O1xufSBlbHNlIHtcbiAgdmFyIFNUQVRFID0gc2hhcmVkS2V5KCdzdGF0ZScpO1xuICBoaWRkZW5LZXlzW1NUQVRFXSA9IHRydWU7XG4gIHNldCA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICBpZiAoaGFzT3duKGl0LCBTVEFURSkpIHRocm93IFR5cGVFcnJvcihPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KGl0LCBTVEFURSwgbWV0YWRhdGEpO1xuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfTtcbiAgZ2V0ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGhhc093bihpdCwgU1RBVEUpID8gaXRbU1RBVEVdIDoge307XG4gIH07XG4gIGhhcyA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBoYXNPd24oaXQsIFNUQVRFKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogc2V0LFxuICBnZXQ6IGdldCxcbiAgaGFzOiBoYXMsXG4gIGVuZm9yY2U6IGVuZm9yY2UsXG4gIGdldHRlckZvcjogZ2V0dGVyRm9yXG59O1xuIiwidmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcblxuLy8gYElzQXJyYXlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc2FycmF5XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tYXJyYXktaXNhcnJheSAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmd1bWVudCkge1xuICByZXR1cm4gY2xhc3NvZihhcmd1bWVudCkgPT0gJ0FycmF5Jztcbn07XG4iLCJ2YXIgJGRvY3VtZW50QWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RvY3VtZW50LWFsbCcpO1xuXG52YXIgZG9jdW1lbnRBbGwgPSAkZG9jdW1lbnRBbGwuYWxsO1xuXG4vLyBgSXNDYWxsYWJsZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzY2FsbGFibGVcbm1vZHVsZS5leHBvcnRzID0gJGRvY3VtZW50QWxsLklTX0hUTUxEREEgPyBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmd1bWVudCA9PSAnZnVuY3Rpb24nIHx8IGFyZ3VtZW50ID09PSBkb2N1bWVudEFsbDtcbn0gOiBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmd1bWVudCA9PSAnZnVuY3Rpb24nO1xufTtcbiIsInZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YnKTtcbnZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIGluc3BlY3RTb3VyY2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5zcGVjdC1zb3VyY2UnKTtcblxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgZW1wdHkgPSBbXTtcbnZhciBjb25zdHJ1Y3QgPSBnZXRCdWlsdEluKCdSZWZsZWN0JywgJ2NvbnN0cnVjdCcpO1xudmFyIGNvbnN0cnVjdG9yUmVnRXhwID0gL15cXHMqKD86Y2xhc3N8ZnVuY3Rpb24pXFxiLztcbnZhciBleGVjID0gdW5jdXJyeVRoaXMoY29uc3RydWN0b3JSZWdFeHAuZXhlYyk7XG52YXIgSU5DT1JSRUNUX1RPX1NUUklORyA9ICFjb25zdHJ1Y3RvclJlZ0V4cC5leGVjKG5vb3ApO1xuXG52YXIgaXNDb25zdHJ1Y3Rvck1vZGVybiA9IGZ1bmN0aW9uIGlzQ29uc3RydWN0b3IoYXJndW1lbnQpIHtcbiAgaWYgKCFpc0NhbGxhYmxlKGFyZ3VtZW50KSkgcmV0dXJuIGZhbHNlO1xuICB0cnkge1xuICAgIGNvbnN0cnVjdChub29wLCBlbXB0eSwgYXJndW1lbnQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxudmFyIGlzQ29uc3RydWN0b3JMZWdhY3kgPSBmdW5jdGlvbiBpc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSB7XG4gIGlmICghaXNDYWxsYWJsZShhcmd1bWVudCkpIHJldHVybiBmYWxzZTtcbiAgc3dpdGNoIChjbGFzc29mKGFyZ3VtZW50KSkge1xuICAgIGNhc2UgJ0FzeW5jRnVuY3Rpb24nOlxuICAgIGNhc2UgJ0dlbmVyYXRvckZ1bmN0aW9uJzpcbiAgICBjYXNlICdBc3luY0dlbmVyYXRvckZ1bmN0aW9uJzogcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gd2UgY2FuJ3QgY2hlY2sgLnByb3RvdHlwZSBzaW5jZSBjb25zdHJ1Y3RvcnMgcHJvZHVjZWQgYnkgLmJpbmQgaGF2ZW4ndCBpdFxuICAgIC8vIGBGdW5jdGlvbiN0b1N0cmluZ2AgdGhyb3dzIG9uIHNvbWUgYnVpbHQtaXQgZnVuY3Rpb24gaW4gc29tZSBsZWdhY3kgZW5naW5lc1xuICAgIC8vIChmb3IgZXhhbXBsZSwgYERPTVF1YWRgIGFuZCBzaW1pbGFyIGluIEZGNDEtKVxuICAgIHJldHVybiBJTkNPUlJFQ1RfVE9fU1RSSU5HIHx8ICEhZXhlYyhjb25zdHJ1Y3RvclJlZ0V4cCwgaW5zcGVjdFNvdXJjZShhcmd1bWVudCkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5pc0NvbnN0cnVjdG9yTGVnYWN5LnNoYW0gPSB0cnVlO1xuXG4vLyBgSXNDb25zdHJ1Y3RvcmAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzY29uc3RydWN0b3Jcbm1vZHVsZS5leHBvcnRzID0gIWNvbnN0cnVjdCB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBjYWxsZWQ7XG4gIHJldHVybiBpc0NvbnN0cnVjdG9yTW9kZXJuKGlzQ29uc3RydWN0b3JNb2Rlcm4uY2FsbClcbiAgICB8fCAhaXNDb25zdHJ1Y3Rvck1vZGVybihPYmplY3QpXG4gICAgfHwgIWlzQ29uc3RydWN0b3JNb2Rlcm4oZnVuY3Rpb24gKCkgeyBjYWxsZWQgPSB0cnVlOyB9KVxuICAgIHx8IGNhbGxlZDtcbn0pID8gaXNDb25zdHJ1Y3RvckxlZ2FjeSA6IGlzQ29uc3RydWN0b3JNb2Rlcm47XG4iLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG5cbnZhciByZXBsYWNlbWVudCA9IC8jfFxcLnByb3RvdHlwZVxcLi87XG5cbnZhciBpc0ZvcmNlZCA9IGZ1bmN0aW9uIChmZWF0dXJlLCBkZXRlY3Rpb24pIHtcbiAgdmFyIHZhbHVlID0gZGF0YVtub3JtYWxpemUoZmVhdHVyZSldO1xuICByZXR1cm4gdmFsdWUgPT0gUE9MWUZJTEwgPyB0cnVlXG4gICAgOiB2YWx1ZSA9PSBOQVRJVkUgPyBmYWxzZVxuICAgIDogaXNDYWxsYWJsZShkZXRlY3Rpb24pID8gZmFpbHMoZGV0ZWN0aW9uKVxuICAgIDogISFkZXRlY3Rpb247XG59O1xuXG52YXIgbm9ybWFsaXplID0gaXNGb3JjZWQubm9ybWFsaXplID0gZnVuY3Rpb24gKHN0cmluZykge1xuICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZShyZXBsYWNlbWVudCwgJy4nKS50b0xvd2VyQ2FzZSgpO1xufTtcblxudmFyIGRhdGEgPSBpc0ZvcmNlZC5kYXRhID0ge307XG52YXIgTkFUSVZFID0gaXNGb3JjZWQuTkFUSVZFID0gJ04nO1xudmFyIFBPTFlGSUxMID0gaXNGb3JjZWQuUE9MWUZJTEwgPSAnUCc7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGb3JjZWQ7XG4iLCIvLyB3ZSBjYW4ndCB1c2UganVzdCBgaXQgPT0gbnVsbGAgc2luY2Ugb2YgYGRvY3VtZW50LmFsbGAgc3BlY2lhbCBjYXNlXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLUlzSFRNTEREQS1pbnRlcm5hbC1zbG90LWFlY1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ID09PSBudWxsIHx8IGl0ID09PSB1bmRlZmluZWQ7XG59O1xuIiwidmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciAkZG9jdW1lbnRBbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZG9jdW1lbnQtYWxsJyk7XG5cbnZhciBkb2N1bWVudEFsbCA9ICRkb2N1bWVudEFsbC5hbGw7XG5cbm1vZHVsZS5leHBvcnRzID0gJGRvY3VtZW50QWxsLklTX0hUTUxEREEgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogaXNDYWxsYWJsZShpdCkgfHwgaXQgPT09IGRvY3VtZW50QWxsO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiBpc0NhbGxhYmxlKGl0KTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xuIiwidmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluJyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIGlzUHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWlzLXByb3RvdHlwZS1vZicpO1xudmFyIFVTRV9TWU1CT0xfQVNfVUlEID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3VzZS1zeW1ib2wtYXMtdWlkJyk7XG5cbnZhciAkT2JqZWN0ID0gT2JqZWN0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVTRV9TWU1CT0xfQVNfVUlEID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gIHZhciAkU3ltYm9sID0gZ2V0QnVpbHRJbignU3ltYm9sJyk7XG4gIHJldHVybiBpc0NhbGxhYmxlKCRTeW1ib2wpICYmIGlzUHJvdG90eXBlT2YoJFN5bWJvbC5wcm90b3R5cGUsICRPYmplY3QoaXQpKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0b3JzLWNvcmUnKS5JdGVyYXRvclByb3RvdHlwZTtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZScpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvcicpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycycpO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEl0ZXJhdG9yQ29uc3RydWN0b3IsIE5BTUUsIG5leHQsIEVOVU1FUkFCTEVfTkVYVCkge1xuICB2YXIgVE9fU1RSSU5HX1RBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgSXRlcmF0b3JDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHsgbmV4dDogY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKCshRU5VTUVSQUJMRV9ORVhULCBuZXh0KSB9KTtcbiAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JDb25zdHJ1Y3RvciwgVE9fU1RSSU5HX1RBRywgZmFsc2UsIHRydWUpO1xuICBJdGVyYXRvcnNbVE9fU1RSSU5HX1RBR10gPSByZXR1cm5UaGlzO1xuICByZXR1cm4gSXRlcmF0b3JDb25zdHJ1Y3Rvcjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwnKTtcbnZhciBJU19QVVJFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXB1cmUnKTtcbnZhciBGdW5jdGlvbk5hbWUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tbmFtZScpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9yLWNyZWF0ZS1jb25zdHJ1Y3RvcicpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mJyk7XG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcbnZhciBkZWZpbmVCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbicpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMnKTtcbnZhciBJdGVyYXRvcnNDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlJyk7XG5cbnZhciBQUk9QRVJfRlVOQ1RJT05fTkFNRSA9IEZ1bmN0aW9uTmFtZS5QUk9QRVI7XG52YXIgQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUgPSBGdW5jdGlvbk5hbWUuQ09ORklHVVJBQkxFO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0gSXRlcmF0b3JzQ29yZS5JdGVyYXRvclByb3RvdHlwZTtcbnZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gSXRlcmF0b3JzQ29yZS5CVUdHWV9TQUZBUklfSVRFUkFUT1JTO1xudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xudmFyIEtFWVMgPSAna2V5cyc7XG52YXIgVkFMVUVTID0gJ3ZhbHVlcyc7XG52YXIgRU5UUklFUyA9ICdlbnRyaWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJdGVyYWJsZSwgTkFNRSwgSXRlcmF0b3JDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpIHtcbiAgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvcihJdGVyYXRvckNvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcblxuICB2YXIgZ2V0SXRlcmF0aW9uTWV0aG9kID0gZnVuY3Rpb24gKEtJTkQpIHtcbiAgICBpZiAoS0lORCA9PT0gREVGQVVMVCAmJiBkZWZhdWx0SXRlcmF0b3IpIHJldHVybiBkZWZhdWx0SXRlcmF0b3I7XG4gICAgaWYgKCFCVUdHWV9TQUZBUklfSVRFUkFUT1JTICYmIEtJTkQgaW4gSXRlcmFibGVQcm90b3R5cGUpIHJldHVybiBJdGVyYWJsZVByb3RvdHlwZVtLSU5EXTtcbiAgICBzd2l0Y2ggKEtJTkQpIHtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG4gICAgICBjYXNlIEVOVFJJRVM6IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcyk7IH07XG4gIH07XG5cbiAgdmFyIFRPX1NUUklOR19UQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgPSBmYWxzZTtcbiAgdmFyIEl0ZXJhYmxlUHJvdG90eXBlID0gSXRlcmFibGUucHJvdG90eXBlO1xuICB2YXIgbmF0aXZlSXRlcmF0b3IgPSBJdGVyYWJsZVByb3RvdHlwZVtJVEVSQVRPUl1cbiAgICB8fCBJdGVyYWJsZVByb3RvdHlwZVsnQEBpdGVyYXRvciddXG4gICAgfHwgREVGQVVMVCAmJiBJdGVyYWJsZVByb3RvdHlwZVtERUZBVUxUXTtcbiAgdmFyIGRlZmF1bHRJdGVyYXRvciA9ICFCVUdHWV9TQUZBUklfSVRFUkFUT1JTICYmIG5hdGl2ZUl0ZXJhdG9yIHx8IGdldEl0ZXJhdGlvbk1ldGhvZChERUZBVUxUKTtcbiAgdmFyIGFueU5hdGl2ZUl0ZXJhdG9yID0gTkFNRSA9PSAnQXJyYXknID8gSXRlcmFibGVQcm90b3R5cGUuZW50cmllcyB8fCBuYXRpdmVJdGVyYXRvciA6IG5hdGl2ZUl0ZXJhdG9yO1xuICB2YXIgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBtZXRob2RzLCBLRVk7XG5cbiAgLy8gZml4IG5hdGl2ZVxuICBpZiAoYW55TmF0aXZlSXRlcmF0b3IpIHtcbiAgICBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZihhbnlOYXRpdmVJdGVyYXRvci5jYWxsKG5ldyBJdGVyYWJsZSgpKSk7XG4gICAgaWYgKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuICAgICAgaWYgKCFJU19QVVJFICYmIGdldFByb3RvdHlwZU9mKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSkgIT09IEl0ZXJhdG9yUHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChzZXRQcm90b3R5cGVPZikge1xuICAgICAgICAgIHNldFByb3RvdHlwZU9mKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgSXRlcmF0b3JQcm90b3R5cGUpO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc0NhbGxhYmxlKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZVtJVEVSQVRPUl0pKSB7XG4gICAgICAgICAgZGVmaW5lQnVpbHRJbihDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWcoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBUT19TVFJJTkdfVEFHLCB0cnVlLCB0cnVlKTtcbiAgICAgIGlmIChJU19QVVJFKSBJdGVyYXRvcnNbVE9fU1RSSU5HX1RBR10gPSByZXR1cm5UaGlzO1xuICAgIH1cbiAgfVxuXG4gIC8vIGZpeCBBcnJheS5wcm90b3R5cGUueyB2YWx1ZXMsIEBAaXRlcmF0b3IgfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKFBST1BFUl9GVU5DVElPTl9OQU1FICYmIERFRkFVTFQgPT0gVkFMVUVTICYmIG5hdGl2ZUl0ZXJhdG9yICYmIG5hdGl2ZUl0ZXJhdG9yLm5hbWUgIT09IFZBTFVFUykge1xuICAgIGlmICghSVNfUFVSRSAmJiBDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KEl0ZXJhYmxlUHJvdG90eXBlLCAnbmFtZScsIFZBTFVFUyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIElOQ09SUkVDVF9WQUxVRVNfTkFNRSA9IHRydWU7XG4gICAgICBkZWZhdWx0SXRlcmF0b3IgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBjYWxsKG5hdGl2ZUl0ZXJhdG9yLCB0aGlzKTsgfTtcbiAgICB9XG4gIH1cblxuICAvLyBleHBvcnQgYWRkaXRpb25hbCBtZXRob2RzXG4gIGlmIChERUZBVUxUKSB7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogZ2V0SXRlcmF0aW9uTWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiBJU19TRVQgPyBkZWZhdWx0SXRlcmF0b3IgOiBnZXRJdGVyYXRpb25NZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiBnZXRJdGVyYXRpb25NZXRob2QoRU5UUklFUylcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoS0VZIGluIG1ldGhvZHMpIHtcbiAgICAgIGlmIChCVUdHWV9TQUZBUklfSVRFUkFUT1JTIHx8IElOQ09SUkVDVF9WQUxVRVNfTkFNRSB8fCAhKEtFWSBpbiBJdGVyYWJsZVByb3RvdHlwZSkpIHtcbiAgICAgICAgZGVmaW5lQnVpbHRJbihJdGVyYWJsZVByb3RvdHlwZSwgS0VZLCBtZXRob2RzW0tFWV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSAkKHsgdGFyZ2V0OiBOQU1FLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTIHx8IElOQ09SUkVDVF9WQUxVRVNfTkFNRSB9LCBtZXRob2RzKTtcbiAgfVxuXG4gIC8vIGRlZmluZSBpdGVyYXRvclxuICBpZiAoKCFJU19QVVJFIHx8IEZPUkNFRCkgJiYgSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1JdICE9PSBkZWZhdWx0SXRlcmF0b3IpIHtcbiAgICBkZWZpbmVCdWlsdEluKEl0ZXJhYmxlUHJvdG90eXBlLCBJVEVSQVRPUiwgZGVmYXVsdEl0ZXJhdG9yLCB7IG5hbWU6IERFRkFVTFQgfSk7XG4gIH1cbiAgSXRlcmF0b3JzW05BTUVdID0gZGVmYXVsdEl0ZXJhdG9yO1xuXG4gIHJldHVybiBtZXRob2RzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZScpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mJyk7XG52YXIgZGVmaW5lQnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4nKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBJU19QVVJFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXB1cmUnKTtcblxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xudmFyIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgPSBmYWxzZTtcblxuLy8gYCVJdGVyYXRvclByb3RvdHlwZSVgIG9iamVjdFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0laXRlcmF0b3Jwcm90b3R5cGUlLW9iamVjdFxudmFyIEl0ZXJhdG9yUHJvdG90eXBlLCBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUsIGFycmF5SXRlcmF0b3I7XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzL25vLWFycmF5LXByb3RvdHlwZS1rZXlzIC0tIHNhZmUgKi9cbmlmIChbXS5rZXlzKSB7XG4gIGFycmF5SXRlcmF0b3IgPSBbXS5rZXlzKCk7XG4gIC8vIFNhZmFyaSA4IGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxuICBpZiAoISgnbmV4dCcgaW4gYXJyYXlJdGVyYXRvcikpIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgPSB0cnVlO1xuICBlbHNlIHtcbiAgICBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZihnZXRQcm90b3R5cGVPZihhcnJheUl0ZXJhdG9yKSk7XG4gICAgaWYgKFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSkgSXRlcmF0b3JQcm90b3R5cGUgPSBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cbn1cblxudmFyIE5FV19JVEVSQVRPUl9QUk9UT1RZUEUgPSAhaXNPYmplY3QoSXRlcmF0b3JQcm90b3R5cGUpIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRlc3QgPSB7fTtcbiAgLy8gRkY0NC0gbGVnYWN5IGl0ZXJhdG9ycyBjYXNlXG4gIHJldHVybiBJdGVyYXRvclByb3RvdHlwZVtJVEVSQVRPUl0uY2FsbCh0ZXN0KSAhPT0gdGVzdDtcbn0pO1xuXG5pZiAoTkVXX0lURVJBVE9SX1BST1RPVFlQRSkgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbmVsc2UgaWYgKElTX1BVUkUpIEl0ZXJhdG9yUHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcblxuLy8gYCVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVpdGVyYXRvcnByb3RvdHlwZSUtQEBpdGVyYXRvclxuaWYgKCFpc0NhbGxhYmxlKEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXSkpIHtcbiAgZGVmaW5lQnVpbHRJbihJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBJdGVyYXRvclByb3RvdHlwZTogSXRlcmF0b3JQcm90b3R5cGUsXG4gIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlM6IEJVR0dZX1NBRkFSSV9JVEVSQVRPUlNcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuIiwidmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xuXG4vLyBgTGVuZ3RoT2ZBcnJheUxpa2VgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1sZW5ndGhvZmFycmF5bGlrZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0b0xlbmd0aChvYmoubGVuZ3RoKTtcbn07XG4iLCJ2YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIENPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLW5hbWUnKS5DT05GSUdVUkFCTEU7XG52YXIgaW5zcGVjdFNvdXJjZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnNwZWN0LXNvdXJjZScpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUnKTtcblxudmFyIGVuZm9yY2VJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5lbmZvcmNlO1xudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldDtcbnZhciAkU3RyaW5nID0gU3RyaW5nO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgc3RyaW5nU2xpY2UgPSB1bmN1cnJ5VGhpcygnJy5zbGljZSk7XG52YXIgcmVwbGFjZSA9IHVuY3VycnlUaGlzKCcnLnJlcGxhY2UpO1xudmFyIGpvaW4gPSB1bmN1cnJ5VGhpcyhbXS5qb2luKTtcblxudmFyIENPTkZJR1VSQUJMRV9MRU5HVEggPSBERVNDUklQVE9SUyAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHkoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCAnbGVuZ3RoJywgeyB2YWx1ZTogOCB9KS5sZW5ndGggIT09IDg7XG59KTtcblxudmFyIFRFTVBMQVRFID0gU3RyaW5nKFN0cmluZykuc3BsaXQoJ1N0cmluZycpO1xuXG52YXIgbWFrZUJ1aWx0SW4gPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSwgb3B0aW9ucykge1xuICBpZiAoc3RyaW5nU2xpY2UoJFN0cmluZyhuYW1lKSwgMCwgNykgPT09ICdTeW1ib2woJykge1xuICAgIG5hbWUgPSAnWycgKyByZXBsYWNlKCRTdHJpbmcobmFtZSksIC9eU3ltYm9sXFwoKFteKV0qKVxcKS8sICckMScpICsgJ10nO1xuICB9XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZ2V0dGVyKSBuYW1lID0gJ2dldCAnICsgbmFtZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zZXR0ZXIpIG5hbWUgPSAnc2V0ICcgKyBuYW1lO1xuICBpZiAoIWhhc093bih2YWx1ZSwgJ25hbWUnKSB8fCAoQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUgJiYgdmFsdWUubmFtZSAhPT0gbmFtZSkpIHtcbiAgICBpZiAoREVTQ1JJUFRPUlMpIGRlZmluZVByb3BlcnR5KHZhbHVlLCAnbmFtZScsIHsgdmFsdWU6IG5hbWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgICBlbHNlIHZhbHVlLm5hbWUgPSBuYW1lO1xuICB9XG4gIGlmIChDT05GSUdVUkFCTEVfTEVOR1RIICYmIG9wdGlvbnMgJiYgaGFzT3duKG9wdGlvbnMsICdhcml0eScpICYmIHZhbHVlLmxlbmd0aCAhPT0gb3B0aW9ucy5hcml0eSkge1xuICAgIGRlZmluZVByb3BlcnR5KHZhbHVlLCAnbGVuZ3RoJywgeyB2YWx1ZTogb3B0aW9ucy5hcml0eSB9KTtcbiAgfVxuICB0cnkge1xuICAgIGlmIChvcHRpb25zICYmIGhhc093bihvcHRpb25zLCAnY29uc3RydWN0b3InKSAmJiBvcHRpb25zLmNvbnN0cnVjdG9yKSB7XG4gICAgICBpZiAoREVTQ1JJUFRPUlMpIGRlZmluZVByb3BlcnR5KHZhbHVlLCAncHJvdG90eXBlJywgeyB3cml0YWJsZTogZmFsc2UgfSk7XG4gICAgLy8gaW4gVjggfiBDaHJvbWUgNTMsIHByb3RvdHlwZXMgb2Ygc29tZSBtZXRob2RzLCBsaWtlIGBBcnJheS5wcm90b3R5cGUudmFsdWVzYCwgYXJlIG5vbi13cml0YWJsZVxuICAgIH0gZWxzZSBpZiAodmFsdWUucHJvdG90eXBlKSB2YWx1ZS5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgdmFyIHN0YXRlID0gZW5mb3JjZUludGVybmFsU3RhdGUodmFsdWUpO1xuICBpZiAoIWhhc093bihzdGF0ZSwgJ3NvdXJjZScpKSB7XG4gICAgc3RhdGUuc291cmNlID0gam9pbihURU1QTEFURSwgdHlwZW9mIG5hbWUgPT0gJ3N0cmluZycgPyBuYW1lIDogJycpO1xuICB9IHJldHVybiB2YWx1ZTtcbn07XG5cbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dGVuZC1uYXRpdmUgLS0gcmVxdWlyZWRcbkZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IG1ha2VCdWlsdEluKGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gaXNDYWxsYWJsZSh0aGlzKSAmJiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLnNvdXJjZSB8fCBpbnNwZWN0U291cmNlKHRoaXMpO1xufSwgJ3RvU3RyaW5nJyk7XG4iLCJ2YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cbi8vIGBNYXRoLnRydW5jYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWF0aC50cnVuY1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW1hdGgtdHJ1bmMgLS0gc2FmZVxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLnRydW5jIHx8IGZ1bmN0aW9uIHRydW5jKHgpIHtcbiAgdmFyIG4gPSAreDtcbiAgcmV0dXJuIChuID4gMCA/IGZsb29yIDogY2VpbCkobik7XG59O1xuIiwidmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXN0cmluZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCwgJGRlZmF1bHQpIHtcbiAgcmV0dXJuIGFyZ3VtZW50ID09PSB1bmRlZmluZWQgPyBhcmd1bWVudHMubGVuZ3RoIDwgMiA/ICcnIDogJGRlZmF1bHQgOiB0b1N0cmluZyhhcmd1bWVudCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBvYmplY3RLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMnKTtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZScpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIEluZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QnKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1hc3NpZ24gLS0gc2FmZVxudmFyICRhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIGNvbmNhdCA9IHVuY3VycnlUaGlzKFtdLmNvbmNhdCk7XG5cbi8vIGBPYmplY3QuYXNzaWduYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmFzc2lnblxubW9kdWxlLmV4cG9ydHMgPSAhJGFzc2lnbiB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIHNob3VsZCBoYXZlIGNvcnJlY3Qgb3JkZXIgb2Ygb3BlcmF0aW9ucyAoRWRnZSBidWcpXG4gIGlmIChERVNDUklQVE9SUyAmJiAkYXNzaWduKHsgYjogMSB9LCAkYXNzaWduKGRlZmluZVByb3BlcnR5KHt9LCAnYScsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgZGVmaW5lUHJvcGVydHkodGhpcywgJ2InLCB7XG4gICAgICAgIHZhbHVlOiAzLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9KSwgeyBiOiAyIH0pKS5iICE9PSAxKSByZXR1cm4gdHJ1ZTtcbiAgLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG4gIHZhciBBID0ge307XG4gIHZhciBCID0ge307XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1zeW1ib2wgLS0gc2FmZVxuICB2YXIgc3ltYm9sID0gU3ltYm9sKCk7XG4gIHZhciBhbHBoYWJldCA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbc3ltYm9sXSA9IDc7XG4gIGFscGhhYmV0LnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChjaHIpIHsgQltjaHJdID0gY2hyOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW3N5bWJvbF0gIT0gNyB8fCBvYmplY3RLZXlzKCRhc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBhbHBoYWJldDtcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIGAubGVuZ3RoYFxuICB2YXIgVCA9IHRvT2JqZWN0KHRhcmdldCk7XG4gIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAxO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmY7XG4gIHZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmY7XG4gIHdoaWxlIChhcmd1bWVudHNMZW5ndGggPiBpbmRleCkge1xuICAgIHZhciBTID0gSW5kZXhlZE9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gY29uY2F0KG9iamVjdEtleXMoUyksIGdldE93blByb3BlcnR5U3ltYm9scyhTKSkgOiBvYmplY3RLZXlzKFMpO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaikge1xuICAgICAga2V5ID0ga2V5c1tqKytdO1xuICAgICAgaWYgKCFERVNDUklQVE9SUyB8fCBjYWxsKHByb3BlcnR5SXNFbnVtZXJhYmxlLCBTLCBrZXkpKSBUW2tleV0gPSBTW2tleV07XG4gICAgfVxuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247XG4iLCIvKiBnbG9iYWwgQWN0aXZlWE9iamVjdCAtLSBvbGQgSUUsIFdTSCAqL1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGRlZmluZVByb3BlcnRpZXNNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0aWVzJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW51bS1idWcta2V5cycpO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMnKTtcbnZhciBodG1sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2h0bWwnKTtcbnZhciBkb2N1bWVudENyZWF0ZUVsZW1lbnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQnKTtcbnZhciBzaGFyZWRLZXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLWtleScpO1xuXG52YXIgR1QgPSAnPic7XG52YXIgTFQgPSAnPCc7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgU0NSSVBUID0gJ3NjcmlwdCc7XG52YXIgSUVfUFJPVE8gPSBzaGFyZWRLZXkoJ0lFX1BST1RPJyk7XG5cbnZhciBFbXB0eUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xuXG52YXIgc2NyaXB0VGFnID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgcmV0dXJuIExUICsgU0NSSVBUICsgR1QgKyBjb250ZW50ICsgTFQgKyAnLycgKyBTQ1JJUFQgKyBHVDtcbn07XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBBY3RpdmVYIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWCA9IGZ1bmN0aW9uIChhY3RpdmVYRG9jdW1lbnQpIHtcbiAgYWN0aXZlWERvY3VtZW50LndyaXRlKHNjcmlwdFRhZygnJykpO1xuICBhY3RpdmVYRG9jdW1lbnQuY2xvc2UoKTtcbiAgdmFyIHRlbXAgPSBhY3RpdmVYRG9jdW1lbnQucGFyZW50V2luZG93Lk9iamVjdDtcbiAgYWN0aXZlWERvY3VtZW50ID0gbnVsbDsgLy8gYXZvaWQgbWVtb3J5IGxlYWtcbiAgcmV0dXJuIHRlbXA7XG59O1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgTnVsbFByb3RvT2JqZWN0VmlhSUZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgdmFyIEpTID0gJ2phdmEnICsgU0NSSVBUICsgJzonO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBodG1sLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy80NzVcbiAgaWZyYW1lLnNyYyA9IFN0cmluZyhKUyk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUoc2NyaXB0VGFnKCdkb2N1bWVudC5GPU9iamVjdCcpKTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgcmV0dXJuIGlmcmFtZURvY3VtZW50LkY7XG59O1xuXG4vLyBDaGVjayBmb3IgZG9jdW1lbnQuZG9tYWluIGFuZCBhY3RpdmUgeCBzdXBwb3J0XG4vLyBObyBuZWVkIHRvIHVzZSBhY3RpdmUgeCBhcHByb2FjaCB3aGVuIGRvY3VtZW50LmRvbWFpbiBpcyBub3Qgc2V0XG4vLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3Vlcy8xNTBcbi8vIHZhcmlhdGlvbiBvZiBodHRwczovL2dpdGh1Yi5jb20va2l0Y2FtYnJpZGdlL2VzNS1zaGltL2NvbW1pdC80ZjczOGFjMDY2MzQ2XG4vLyBhdm9pZCBJRSBHQyBidWdcbnZhciBhY3RpdmVYRG9jdW1lbnQ7XG52YXIgTnVsbFByb3RvT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIGFjdGl2ZVhEb2N1bWVudCA9IG5ldyBBY3RpdmVYT2JqZWN0KCdodG1sZmlsZScpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBpZ25vcmUgKi8gfVxuICBOdWxsUHJvdG9PYmplY3QgPSB0eXBlb2YgZG9jdW1lbnQgIT0gJ3VuZGVmaW5lZCdcbiAgICA/IGRvY3VtZW50LmRvbWFpbiAmJiBhY3RpdmVYRG9jdW1lbnRcbiAgICAgID8gTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWChhY3RpdmVYRG9jdW1lbnQpIC8vIG9sZCBJRVxuICAgICAgOiBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUoKVxuICAgIDogTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWChhY3RpdmVYRG9jdW1lbnQpOyAvLyBXU0hcbiAgdmFyIGxlbmd0aCA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSBkZWxldGUgTnVsbFByb3RvT2JqZWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbbGVuZ3RoXV07XG4gIHJldHVybiBOdWxsUHJvdG9PYmplY3QoKTtcbn07XG5cbmhpZGRlbktleXNbSUVfUFJPVE9dID0gdHJ1ZTtcblxuLy8gYE9iamVjdC5jcmVhdGVgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuY3JlYXRlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWNyZWF0ZSAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eUNvbnN0cnVjdG9yW1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHlDb25zdHJ1Y3RvcigpO1xuICAgIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gTnVsbFByb3RvT2JqZWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkZWZpbmVQcm9wZXJ0aWVzTW9kdWxlLmYocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG4iLCJ2YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy92OC1wcm90b3R5cGUtZGVmaW5lLWJ1ZycpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciBvYmplY3RLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzJyk7XG5cbi8vIGBPYmplY3QuZGVmaW5lUHJvcGVydGllc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0aWVzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnRpZXMgLS0gc2FmZVxuZXhwb3J0cy5mID0gREVTQ1JJUFRPUlMgJiYgIVY4X1BST1RPVFlQRV9ERUZJTkVfQlVHID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBwcm9wcyA9IHRvSW5kZXhlZE9iamVjdChQcm9wZXJ0aWVzKTtcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFByb3BlcnRpZXMpO1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChsZW5ndGggPiBpbmRleCkgZGVmaW5lUHJvcGVydHlNb2R1bGUuZihPLCBrZXkgPSBrZXlzW2luZGV4KytdLCBwcm9wc1trZXldKTtcbiAgcmV0dXJuIE87XG59O1xuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUnKTtcbnZhciBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy92OC1wcm90b3R5cGUtZGVmaW5lLWJ1ZycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIHRvUHJvcGVydHlLZXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tcHJvcGVydHkta2V5Jyk7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG52YXIgJGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIEVOVU1FUkFCTEUgPSAnZW51bWVyYWJsZSc7XG52YXIgQ09ORklHVVJBQkxFID0gJ2NvbmZpZ3VyYWJsZSc7XG52YXIgV1JJVEFCTEUgPSAnd3JpdGFibGUnO1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnR5XG5leHBvcnRzLmYgPSBERVNDUklQVE9SUyA/IFY4X1BST1RPVFlQRV9ERUZJTkVfQlVHID8gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJvcGVydHlLZXkoUCk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAodHlwZW9mIE8gPT09ICdmdW5jdGlvbicgJiYgUCA9PT0gJ3Byb3RvdHlwZScgJiYgJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzICYmIFdSSVRBQkxFIGluIEF0dHJpYnV0ZXMgJiYgIUF0dHJpYnV0ZXNbV1JJVEFCTEVdKSB7XG4gICAgdmFyIGN1cnJlbnQgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApO1xuICAgIGlmIChjdXJyZW50ICYmIGN1cnJlbnRbV1JJVEFCTEVdKSB7XG4gICAgICBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgICAgIEF0dHJpYnV0ZXMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogQ09ORklHVVJBQkxFIGluIEF0dHJpYnV0ZXMgPyBBdHRyaWJ1dGVzW0NPTkZJR1VSQUJMRV0gOiBjdXJyZW50W0NPTkZJR1VSQUJMRV0sXG4gICAgICAgIGVudW1lcmFibGU6IEVOVU1FUkFCTEUgaW4gQXR0cmlidXRlcyA/IEF0dHJpYnV0ZXNbRU5VTUVSQUJMRV0gOiBjdXJyZW50W0VOVU1FUkFCTEVdLFxuICAgICAgICB3cml0YWJsZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICB9IHJldHVybiAkZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG59IDogJGRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJvcGVydHlLZXkoUCk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuICRkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyAkVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCcpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsJyk7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciB0b1Byb3BlcnR5S2V5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXByb3BlcnR5LWtleScpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUnKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTID8gJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0luZGV4ZWRPYmplY3QoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5KFApO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhc093bihPLCBQKSkgcmV0dXJuIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcighY2FsbChwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mLCBPLCBQKSwgT1tQXSk7XG59O1xuIiwiLyogZXNsaW50LWRpc2FibGUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5bmFtZXMgLS0gc2FmZSAqL1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcycpLmY7XG52YXIgYXJyYXlTbGljZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1zbGljZS1zaW1wbGUnKTtcblxudmFyIHdpbmRvd05hbWVzID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNcbiAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpIDogW107XG5cbnZhciBnZXRXaW5kb3dOYW1lcyA9IGZ1bmN0aW9uIChpdCkge1xuICB0cnkge1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlOYW1lcyhpdCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGFycmF5U2xpY2Uod2luZG93TmFtZXMpO1xuICB9XG59O1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICByZXR1cm4gd2luZG93TmFtZXMgJiYgY2xhc3NvZihpdCkgPT0gJ1dpbmRvdydcbiAgICA/IGdldFdpbmRvd05hbWVzKGl0KVxuICAgIDogJGdldE93blByb3BlcnR5TmFtZXModG9JbmRleGVkT2JqZWN0KGl0KSk7XG59O1xuIiwidmFyIGludGVybmFsT2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VudW0tYnVnLWtleXMnKTtcblxudmFyIGhpZGRlbktleXMgPSBlbnVtQnVnS2V5cy5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5bmFtZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHluYW1lcyAtLSBzYWZlXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG4iLCIvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5c3ltYm9scyAtLSBzYWZlXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuIiwidmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIHNoYXJlZEtleSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQta2V5Jyk7XG52YXIgQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NvcnJlY3QtcHJvdG90eXBlLWdldHRlcicpO1xuXG52YXIgSUVfUFJPVE8gPSBzaGFyZWRLZXkoJ0lFX1BST1RPJyk7XG52YXIgJE9iamVjdCA9IE9iamVjdDtcbnZhciBPYmplY3RQcm90b3R5cGUgPSAkT2JqZWN0LnByb3RvdHlwZTtcblxuLy8gYE9iamVjdC5nZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRwcm90b3R5cGVvZlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRwcm90b3R5cGVvZiAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiA/ICRPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiAoTykge1xuICB2YXIgb2JqZWN0ID0gdG9PYmplY3QoTyk7XG4gIGlmIChoYXNPd24ob2JqZWN0LCBJRV9QUk9UTykpIHJldHVybiBvYmplY3RbSUVfUFJPVE9dO1xuICB2YXIgY29uc3RydWN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gIGlmIChpc0NhbGxhYmxlKGNvbnN0cnVjdG9yKSAmJiBvYmplY3QgaW5zdGFuY2VvZiBjb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBjb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mICRPYmplY3QgPyBPYmplY3RQcm90b3R5cGUgOiBudWxsO1xufTtcbiIsInZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB1bmN1cnJ5VGhpcyh7fS5pc1Byb3RvdHlwZU9mKTtcbiIsInZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eScpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIGluZGV4T2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXMnKS5pbmRleE9mO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMnKTtcblxudmFyIHB1c2ggPSB1bmN1cnJ5VGhpcyhbXS5wdXNoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgIWhhc093bihoaWRkZW5LZXlzLCBrZXkpICYmIGhhc093bihPLCBrZXkpICYmIHB1c2gocmVzdWx0LCBrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzT3duKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHB1c2gocmVzdWx0LCBrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwidmFyIGludGVybmFsT2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VudW0tYnVnLWtleXMnKTtcblxuLy8gYE9iamVjdC5rZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmtleXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3Qta2V5cyAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gTmFzaG9ybiB+IEpESzggYnVnXG52YXIgTkFTSE9STl9CVUcgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiYgISRwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHsgMTogMiB9LCAxKTtcblxuLy8gYE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGVgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnByb3BlcnR5aXNlbnVtZXJhYmxlXG5leHBvcnRzLmYgPSBOQVNIT1JOX0JVRyA/IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKFYpIHtcbiAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGhpcywgVik7XG4gIHJldHVybiAhIWRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlO1xufSA6ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvIC0tIHNhZmUgKi9cbnZhciB1bmN1cnJ5VGhpc0FjY2Vzc29yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy1hY2Nlc3NvcicpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGFQb3NzaWJsZVByb3RvdHlwZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLXBvc3NpYmxlLXByb3RvdHlwZScpO1xuXG4vLyBgT2JqZWN0LnNldFByb3RvdHlwZU9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnNldHByb3RvdHlwZW9mXG4vLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3Qtc2V0cHJvdG90eXBlb2YgLS0gc2FmZVxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gZnVuY3Rpb24gKCkge1xuICB2YXIgQ09SUkVDVF9TRVRURVIgPSBmYWxzZTtcbiAgdmFyIHRlc3QgPSB7fTtcbiAgdmFyIHNldHRlcjtcbiAgdHJ5IHtcbiAgICBzZXR0ZXIgPSB1bmN1cnJ5VGhpc0FjY2Vzc29yKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nLCAnc2V0Jyk7XG4gICAgc2V0dGVyKHRlc3QsIFtdKTtcbiAgICBDT1JSRUNUX1NFVFRFUiA9IHRlc3QgaW5zdGFuY2VvZiBBcnJheTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcbiAgICBhbk9iamVjdChPKTtcbiAgICBhUG9zc2libGVQcm90b3R5cGUocHJvdG8pO1xuICAgIGlmIChDT1JSRUNUX1NFVFRFUikgc2V0dGVyKE8sIHByb3RvKTtcbiAgICBlbHNlIE8uX19wcm90b19fID0gcHJvdG87XG4gICAgcmV0dXJuIE87XG4gIH07XG59KCkgOiB1bmRlZmluZWQpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIFRPX1NUUklOR19UQUdfU1VQUE9SVCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1zdHJpbmctdGFnLXN1cHBvcnQnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YnKTtcblxuLy8gYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IFRPX1NUUklOR19UQUdfU1VQUE9SVCA/IHt9LnRvU3RyaW5nIDogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiAnW29iamVjdCAnICsgY2xhc3NvZih0aGlzKSArICddJztcbn07XG4iLCJ2YXIgY2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsJyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxuLy8gYE9yZGluYXJ5VG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vcmRpbmFyeXRvcHJpbWl0aXZlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbnB1dCwgcHJlZikge1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKHByZWYgPT09ICdzdHJpbmcnICYmIGlzQ2FsbGFibGUoZm4gPSBpbnB1dC50b1N0cmluZykgJiYgIWlzT2JqZWN0KHZhbCA9IGNhbGwoZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gIGlmIChpc0NhbGxhYmxlKGZuID0gaW5wdXQudmFsdWVPZikgJiYgIWlzT2JqZWN0KHZhbCA9IGNhbGwoZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gIGlmIChwcmVmICE9PSAnc3RyaW5nJyAmJiBpc0NhbGxhYmxlKGZuID0gaW5wdXQudG9TdHJpbmcpICYmICFpc09iamVjdCh2YWwgPSBjYWxsKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyAkVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcbiIsInZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktc3ltYm9scycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xuXG52YXIgY29uY2F0ID0gdW5jdXJyeVRoaXMoW10uY29uY2F0KTtcblxuLy8gYWxsIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBub24tZW51bWVyYWJsZSBhbmQgc3ltYm9sc1xubW9kdWxlLmV4cG9ydHMgPSBnZXRCdWlsdEluKCdSZWZsZWN0JywgJ293bktleXMnKSB8fCBmdW5jdGlvbiBvd25LZXlzKGl0KSB7XG4gIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZS5mKGFuT2JqZWN0KGl0KSk7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZjtcbiAgcmV0dXJuIGdldE93blByb3BlcnR5U3ltYm9scyA/IGNvbmNhdChrZXlzLCBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpKSA6IGtleXM7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWw7XG4iLCJ2YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpLmY7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRhcmdldCwgU291cmNlLCBrZXkpIHtcbiAga2V5IGluIFRhcmdldCB8fCBkZWZpbmVQcm9wZXJ0eShUYXJnZXQsIGtleSwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFNvdXJjZVtrZXldOyB9LFxuICAgIHNldDogZnVuY3Rpb24gKGl0KSB7IFNvdXJjZVtrZXldID0gaXQ7IH1cbiAgfSk7XG59O1xuIiwidmFyIGlzTnVsbE9yVW5kZWZpbmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW51bGwtb3ItdW5kZWZpbmVkJyk7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG4vLyBgUmVxdWlyZU9iamVjdENvZXJjaWJsZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlcXVpcmVvYmplY3Rjb2VyY2libGVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpc051bGxPclVuZGVmaW5lZChpdCkpIHRocm93ICRUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsInZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5JykuZjtcbnZhciBoYXNPd24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eScpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBUQUcsIFNUQVRJQykge1xuICBpZiAodGFyZ2V0ICYmICFTVEFUSUMpIHRhcmdldCA9IHRhcmdldC5wcm90b3R5cGU7XG4gIGlmICh0YXJnZXQgJiYgIWhhc093bih0YXJnZXQsIFRPX1NUUklOR19UQUcpKSB7XG4gICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBUT19TVFJJTkdfVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IFRBRyB9KTtcbiAgfVxufTtcbiIsInZhciBzaGFyZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3VpZCcpO1xuXG52YXIga2V5cyA9IHNoYXJlZCgna2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIGtleXNba2V5XSB8fCAoa2V5c1trZXldID0gdWlkKGtleSkpO1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgZGVmaW5lR2xvYmFsUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWdsb2JhbC1wcm9wZXJ0eScpO1xuXG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUgPSBnbG9iYWxbU0hBUkVEXSB8fCBkZWZpbmVHbG9iYWxQcm9wZXJ0eShTSEFSRUQsIHt9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdG9yZTtcbiIsInZhciBJU19QVVJFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXB1cmUnKTtcbnZhciBzdG9yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQtc3RvcmUnKTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XG59KSgndmVyc2lvbnMnLCBbXSkucHVzaCh7XG4gIHZlcnNpb246ICczLjMwLjEnLFxuICBtb2RlOiBJU19QVVJFID8gJ3B1cmUnIDogJ2dsb2JhbCcsXG4gIGNvcHlyaWdodDogJ8KpIDIwMTQtMjAyMyBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KScsXG4gIGxpY2Vuc2U6ICdodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9ibG9iL3YzLjMwLjEvTElDRU5TRScsXG4gIHNvdXJjZTogJ2h0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzJ1xufSk7XG4iLCJ2YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbnRlZ2VyLW9yLWluZmluaXR5Jyk7XG52YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tc3RyaW5nJyk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcblxudmFyIGNoYXJBdCA9IHVuY3VycnlUaGlzKCcnLmNoYXJBdCk7XG52YXIgY2hhckNvZGVBdCA9IHVuY3VycnlUaGlzKCcnLmNoYXJDb2RlQXQpO1xudmFyIHN0cmluZ1NsaWNlID0gdW5jdXJyeVRoaXMoJycuc2xpY2UpO1xuXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKENPTlZFUlRfVE9fU1RSSU5HKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIHBvcykge1xuICAgIHZhciBTID0gdG9TdHJpbmcocmVxdWlyZU9iamVjdENvZXJjaWJsZSgkdGhpcykpO1xuICAgIHZhciBwb3NpdGlvbiA9IHRvSW50ZWdlck9ySW5maW5pdHkocG9zKTtcbiAgICB2YXIgc2l6ZSA9IFMubGVuZ3RoO1xuICAgIHZhciBmaXJzdCwgc2Vjb25kO1xuICAgIGlmIChwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPj0gc2l6ZSkgcmV0dXJuIENPTlZFUlRfVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgZmlyc3QgPSBjaGFyQ29kZUF0KFMsIHBvc2l0aW9uKTtcbiAgICByZXR1cm4gZmlyc3QgPCAweEQ4MDAgfHwgZmlyc3QgPiAweERCRkYgfHwgcG9zaXRpb24gKyAxID09PSBzaXplXG4gICAgICB8fCAoc2Vjb25kID0gY2hhckNvZGVBdChTLCBwb3NpdGlvbiArIDEpKSA8IDB4REMwMCB8fCBzZWNvbmQgPiAweERGRkZcbiAgICAgICAgPyBDT05WRVJUX1RPX1NUUklOR1xuICAgICAgICAgID8gY2hhckF0KFMsIHBvc2l0aW9uKVxuICAgICAgICAgIDogZmlyc3RcbiAgICAgICAgOiBDT05WRVJUX1RPX1NUUklOR1xuICAgICAgICAgID8gc3RyaW5nU2xpY2UoUywgcG9zaXRpb24sIHBvc2l0aW9uICsgMilcbiAgICAgICAgICA6IChmaXJzdCAtIDB4RDgwMCA8PCAxMCkgKyAoc2Vjb25kIC0gMHhEQzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuY29kZXBvaW50YXRcbiAgY29kZUF0OiBjcmVhdGVNZXRob2QoZmFsc2UpLFxuICAvLyBgU3RyaW5nLnByb3RvdHlwZS5hdGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL1N0cmluZy5wcm90b3R5cGUuYXRcbiAgY2hhckF0OiBjcmVhdGVNZXRob2QodHJ1ZSlcbn07XG4iLCJ2YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcbnZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1zdHJpbmcnKTtcbnZhciB3aGl0ZXNwYWNlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93aGl0ZXNwYWNlcycpO1xuXG52YXIgcmVwbGFjZSA9IHVuY3VycnlUaGlzKCcnLnJlcGxhY2UpO1xudmFyIGx0cmltID0gUmVnRXhwKCdeWycgKyB3aGl0ZXNwYWNlcyArICddKycpO1xudmFyIHJ0cmltID0gUmVnRXhwKCcoXnxbXicgKyB3aGl0ZXNwYWNlcyArICddKVsnICsgd2hpdGVzcGFjZXMgKyAnXSskJyk7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLnsgdHJpbSwgdHJpbVN0YXJ0LCB0cmltRW5kLCB0cmltTGVmdCwgdHJpbVJpZ2h0IH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoVFlQRSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzKSB7XG4gICAgdmFyIHN0cmluZyA9IHRvU3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUoJHRoaXMpKTtcbiAgICBpZiAoVFlQRSAmIDEpIHN0cmluZyA9IHJlcGxhY2Uoc3RyaW5nLCBsdHJpbSwgJycpO1xuICAgIGlmIChUWVBFICYgMikgc3RyaW5nID0gcmVwbGFjZShzdHJpbmcsIHJ0cmltLCAnJDEnKTtcbiAgICByZXR1cm4gc3RyaW5nO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLnsgdHJpbUxlZnQsIHRyaW1TdGFydCB9YCBtZXRob2RzXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS50cmltc3RhcnRcbiAgc3RhcnQ6IGNyZWF0ZU1ldGhvZCgxKSxcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUueyB0cmltUmlnaHQsIHRyaW1FbmQgfWAgbWV0aG9kc1xuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUudHJpbWVuZFxuICBlbmQ6IGNyZWF0ZU1ldGhvZCgyKSxcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUudHJpbWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS50cmltXG4gIHRyaW06IGNyZWF0ZU1ldGhvZCgzKVxufTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIGVzL25vLXN5bWJvbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xudmFyIFY4X1ZFUlNJT04gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLXY4LXZlcnNpb24nKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5c3ltYm9scyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xubW9kdWxlLmV4cG9ydHMgPSAhIU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN5bWJvbCA9IFN5bWJvbCgpO1xuICAvLyBDaHJvbWUgMzggU3ltYm9sIGhhcyBpbmNvcnJlY3QgdG9TdHJpbmcgY29udmVyc2lvblxuICAvLyBgZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzYCBwb2x5ZmlsbCBzeW1ib2xzIGNvbnZlcnRlZCB0byBvYmplY3QgYXJlIG5vdCBTeW1ib2wgaW5zdGFuY2VzXG4gIHJldHVybiAhU3RyaW5nKHN5bWJvbCkgfHwgIShPYmplY3Qoc3ltYm9sKSBpbnN0YW5jZW9mIFN5bWJvbCkgfHxcbiAgICAvLyBDaHJvbWUgMzgtNDAgc3ltYm9scyBhcmUgbm90IGluaGVyaXRlZCBmcm9tIERPTSBjb2xsZWN0aW9ucyBwcm90b3R5cGVzIHRvIGluc3RhbmNlc1xuICAgICFTeW1ib2wuc2hhbSAmJiBWOF9WRVJTSU9OICYmIFY4X1ZFUlNJT04gPCA0MTtcbn0pO1xuIiwidmFyIGNhbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbCcpO1xudmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgZGVmaW5lQnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBTeW1ib2wgPSBnZXRCdWlsdEluKCdTeW1ib2wnKTtcbiAgdmFyIFN5bWJvbFByb3RvdHlwZSA9IFN5bWJvbCAmJiBTeW1ib2wucHJvdG90eXBlO1xuICB2YXIgdmFsdWVPZiA9IFN5bWJvbFByb3RvdHlwZSAmJiBTeW1ib2xQcm90b3R5cGUudmFsdWVPZjtcbiAgdmFyIFRPX1BSSU1JVElWRSA9IHdlbGxLbm93blN5bWJvbCgndG9QcmltaXRpdmUnKTtcblxuICBpZiAoU3ltYm9sUHJvdG90eXBlICYmICFTeW1ib2xQcm90b3R5cGVbVE9fUFJJTUlUSVZFXSkge1xuICAgIC8vIGBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5wcm90b3R5cGUtQEB0b3ByaW1pdGl2ZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgLmxlbmd0aFxuICAgIGRlZmluZUJ1aWx0SW4oU3ltYm9sUHJvdG90eXBlLCBUT19QUklNSVRJVkUsIGZ1bmN0aW9uIChoaW50KSB7XG4gICAgICByZXR1cm4gY2FsbCh2YWx1ZU9mLCB0aGlzKTtcbiAgICB9LCB7IGFyaXR5OiAxIH0pO1xuICB9XG59O1xuIiwidmFyIE5BVElWRV9TWU1CT0wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3ltYm9sLWNvbnN0cnVjdG9yLWRldGVjdGlvbicpO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy9uby1zeW1ib2wgLS0gc2FmZSAqL1xubW9kdWxlLmV4cG9ydHMgPSBOQVRJVkVfU1lNQk9MICYmICEhU3ltYm9sWydmb3InXSAmJiAhIVN5bWJvbC5rZXlGb3I7XG4iLCJ2YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG5cbi8vIGB0aGlzTnVtYmVyVmFsdWVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10aGlzbnVtYmVydmFsdWVcbm1vZHVsZS5leHBvcnRzID0gdW5jdXJyeVRoaXMoMS4wLnZhbHVlT2YpO1xuIiwidmFyIHRvSW50ZWdlck9ySW5maW5pdHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW50ZWdlci1vci1pbmZpbml0eScpO1xuXG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5cbi8vIEhlbHBlciBmb3IgYSBwb3B1bGFyIHJlcGVhdGluZyBjYXNlIG9mIHRoZSBzcGVjOlxuLy8gTGV0IGludGVnZXIgYmUgPyBUb0ludGVnZXIoaW5kZXgpLlxuLy8gSWYgaW50ZWdlciA8IDAsIGxldCByZXN1bHQgYmUgbWF4KChsZW5ndGggKyBpbnRlZ2VyKSwgMCk7IGVsc2UgbGV0IHJlc3VsdCBiZSBtaW4oaW50ZWdlciwgbGVuZ3RoKS5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgdmFyIGludGVnZXIgPSB0b0ludGVnZXJPckluZmluaXR5KGluZGV4KTtcbiAgcmV0dXJuIGludGVnZXIgPCAwID8gbWF4KGludGVnZXIgKyBsZW5ndGgsIDApIDogbWluKGludGVnZXIsIGxlbmd0aCk7XG59O1xuIiwiLy8gdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0Jyk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEluZGV4ZWRPYmplY3QocmVxdWlyZU9iamVjdENvZXJjaWJsZShpdCkpO1xufTtcbiIsInZhciB0cnVuYyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9tYXRoLXRydW5jJyk7XG5cbi8vIGBUb0ludGVnZXJPckluZmluaXR5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9pbnRlZ2Vyb3JpbmZpbml0eVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdmFyIG51bWJlciA9ICthcmd1bWVudDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgcmV0dXJuIG51bWJlciAhPT0gbnVtYmVyIHx8IG51bWJlciA9PT0gMCA/IDAgOiB0cnVuYyhudW1iZXIpO1xufTtcbiIsInZhciB0b0ludGVnZXJPckluZmluaXR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWludGVnZXItb3ItaW5maW5pdHknKTtcblxudmFyIG1pbiA9IE1hdGgubWluO1xuXG4vLyBgVG9MZW5ndGhgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2xlbmd0aFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGFyZ3VtZW50ID4gMCA/IG1pbih0b0ludGVnZXJPckluZmluaXR5KGFyZ3VtZW50KSwgMHgxRkZGRkZGRkZGRkZGRikgOiAwOyAvLyAyICoqIDUzIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuIiwidmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG5cbnZhciAkT2JqZWN0ID0gT2JqZWN0O1xuXG4vLyBgVG9PYmplY3RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b29iamVjdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuICRPYmplY3QocmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudCkpO1xufTtcbiIsInZhciBjYWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBpc1N5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1zeW1ib2wnKTtcbnZhciBnZXRNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LW1ldGhvZCcpO1xudmFyIG9yZGluYXJ5VG9QcmltaXRpdmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb3JkaW5hcnktdG8tcHJpbWl0aXZlJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xudmFyIFRPX1BSSU1JVElWRSA9IHdlbGxLbm93blN5bWJvbCgndG9QcmltaXRpdmUnKTtcblxuLy8gYFRvUHJpbWl0aXZlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9wcmltaXRpdmVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGlucHV0LCBwcmVmKSB7XG4gIGlmICghaXNPYmplY3QoaW5wdXQpIHx8IGlzU3ltYm9sKGlucHV0KSkgcmV0dXJuIGlucHV0O1xuICB2YXIgZXhvdGljVG9QcmltID0gZ2V0TWV0aG9kKGlucHV0LCBUT19QUklNSVRJVkUpO1xuICB2YXIgcmVzdWx0O1xuICBpZiAoZXhvdGljVG9QcmltKSB7XG4gICAgaWYgKHByZWYgPT09IHVuZGVmaW5lZCkgcHJlZiA9ICdkZWZhdWx0JztcbiAgICByZXN1bHQgPSBjYWxsKGV4b3RpY1RvUHJpbSwgaW5wdXQsIHByZWYpO1xuICAgIGlmICghaXNPYmplY3QocmVzdWx0KSB8fCBpc1N5bWJvbChyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgIHRocm93ICRUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG4gIH1cbiAgaWYgKHByZWYgPT09IHVuZGVmaW5lZCkgcHJlZiA9ICdudW1iZXInO1xuICByZXR1cm4gb3JkaW5hcnlUb1ByaW1pdGl2ZShpbnB1dCwgcHJlZik7XG59O1xuIiwidmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXByaW1pdGl2ZScpO1xudmFyIGlzU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXN5bWJvbCcpO1xuXG4vLyBgVG9Qcm9wZXJ0eUtleWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvcHJvcGVydHlrZXlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBrZXkgPSB0b1ByaW1pdGl2ZShhcmd1bWVudCwgJ3N0cmluZycpO1xuICByZXR1cm4gaXNTeW1ib2woa2V5KSA/IGtleSA6IGtleSArICcnO1xufTtcbiIsInZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG52YXIgdGVzdCA9IHt9O1xuXG50ZXN0W1RPX1NUUklOR19UQUddID0gJ3onO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmluZyh0ZXN0KSA9PT0gJ1tvYmplY3Qgel0nO1xuIiwidmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZicpO1xuXG52YXIgJFN0cmluZyA9IFN0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGNsYXNzb2YoYXJndW1lbnQpID09PSAnU3ltYm9sJykgdGhyb3cgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCBhIFN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZycpO1xuICByZXR1cm4gJFN0cmluZyhhcmd1bWVudCk7XG59O1xuIiwidmFyICRTdHJpbmcgPSBTdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICRTdHJpbmcoYXJndW1lbnQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiAnT2JqZWN0JztcbiAgfVxufTtcbiIsInZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcblxudmFyIGlkID0gMDtcbnZhciBwb3N0Zml4ID0gTWF0aC5yYW5kb20oKTtcbnZhciB0b1N0cmluZyA9IHVuY3VycnlUaGlzKDEuMC50b1N0cmluZyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnICsgKGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXkpICsgJylfJyArIHRvU3RyaW5nKCsraWQgKyBwb3N0Zml4LCAzNik7XG59O1xuIiwiLyogZXNsaW50LWRpc2FibGUgZXMvbm8tc3ltYm9sIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG52YXIgTkFUSVZFX1NZTUJPTCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zeW1ib2wtY29uc3RydWN0b3ItZGV0ZWN0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTkFUSVZFX1NZTUJPTFxuICAmJiAhU3ltYm9sLnNoYW1cbiAgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJztcbiIsInZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbi8vIFY4IH4gQ2hyb21lIDM2LVxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzMzNFxubW9kdWxlLmV4cG9ydHMgPSBERVNDUklQVE9SUyAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0sICdwcm90b3R5cGUnLCB7XG4gICAgdmFsdWU6IDQyLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KS5wcm90b3R5cGUgIT0gNDI7XG59KTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xuXG52YXIgV2Vha01hcCA9IGdsb2JhbC5XZWFrTWFwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQ2FsbGFibGUoV2Vha01hcCkgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KFN0cmluZyhXZWFrTWFwKSk7XG4iLCJ2YXIgcGF0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9wYXRoJyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcbnZhciB3cmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLXdyYXBwZWQnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5JykuZjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTkFNRSkge1xuICB2YXIgU3ltYm9sID0gcGF0aC5TeW1ib2wgfHwgKHBhdGguU3ltYm9sID0ge30pO1xuICBpZiAoIWhhc093bihTeW1ib2wsIE5BTUUpKSBkZWZpbmVQcm9wZXJ0eShTeW1ib2wsIE5BTUUsIHtcbiAgICB2YWx1ZTogd3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZS5mKE5BTUUpXG4gIH0pO1xufTtcbiIsInZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxuZXhwb3J0cy5mID0gd2VsbEtub3duU3ltYm9sO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkJyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdWlkJyk7XG52YXIgTkFUSVZFX1NZTUJPTCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zeW1ib2wtY29uc3RydWN0b3ItZGV0ZWN0aW9uJyk7XG52YXIgVVNFX1NZTUJPTF9BU19VSUQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdXNlLXN5bWJvbC1hcy11aWQnKTtcblxudmFyIFN5bWJvbCA9IGdsb2JhbC5TeW1ib2w7XG52YXIgV2VsbEtub3duU3ltYm9sc1N0b3JlID0gc2hhcmVkKCd3a3MnKTtcbnZhciBjcmVhdGVXZWxsS25vd25TeW1ib2wgPSBVU0VfU1lNQk9MX0FTX1VJRCA/IFN5bWJvbFsnZm9yJ10gfHwgU3ltYm9sIDogU3ltYm9sICYmIFN5bWJvbC53aXRob3V0U2V0dGVyIHx8IHVpZDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICBpZiAoIWhhc093bihXZWxsS25vd25TeW1ib2xzU3RvcmUsIG5hbWUpKSB7XG4gICAgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gTkFUSVZFX1NZTUJPTCAmJiBoYXNPd24oU3ltYm9sLCBuYW1lKVxuICAgICAgPyBTeW1ib2xbbmFtZV1cbiAgICAgIDogY3JlYXRlV2VsbEtub3duU3ltYm9sKCdTeW1ib2wuJyArIG5hbWUpO1xuICB9IHJldHVybiBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV07XG59O1xuIiwiLy8gYSBzdHJpbmcgb2YgYWxsIHZhbGlkIHVuaWNvZGUgd2hpdGVzcGFjZXNcbm1vZHVsZS5leHBvcnRzID0gJ1xcdTAwMDlcXHUwMDBBXFx1MDAwQlxcdTAwMENcXHUwMDBEXFx1MDAyMFxcdTAwQTBcXHUxNjgwXFx1MjAwMFxcdTIwMDFcXHUyMDAyJyArXG4gICdcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjhcXHUyMDI5XFx1RkVGRic7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2V0QnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4nKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eScpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcbnZhciBpc1Byb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1pcy1wcm90b3R5cGUtb2YnKTtcbnZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qtc2V0LXByb3RvdHlwZS1vZicpO1xudmFyIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY29weS1jb25zdHJ1Y3Rvci1wcm9wZXJ0aWVzJyk7XG52YXIgcHJveHlBY2Nlc3NvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9wcm94eS1hY2Nlc3NvcicpO1xudmFyIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luaGVyaXQtaWYtcmVxdWlyZWQnKTtcbnZhciBub3JtYWxpemVTdHJpbmdBcmd1bWVudCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9ub3JtYWxpemUtc3RyaW5nLWFyZ3VtZW50Jyk7XG52YXIgaW5zdGFsbEVycm9yQ2F1c2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5zdGFsbC1lcnJvci1jYXVzZScpO1xudmFyIGluc3RhbGxFcnJvclN0YWNrID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Vycm9yLXN0YWNrLWluc3RhbGwnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIElTX1BVUkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcHVyZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChGVUxMX05BTUUsIHdyYXBwZXIsIEZPUkNFRCwgSVNfQUdHUkVHQVRFX0VSUk9SKSB7XG4gIHZhciBTVEFDS19UUkFDRV9MSU1JVCA9ICdzdGFja1RyYWNlTGltaXQnO1xuICB2YXIgT1BUSU9OU19QT1NJVElPTiA9IElTX0FHR1JFR0FURV9FUlJPUiA/IDIgOiAxO1xuICB2YXIgcGF0aCA9IEZVTExfTkFNRS5zcGxpdCgnLicpO1xuICB2YXIgRVJST1JfTkFNRSA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgdmFyIE9yaWdpbmFsRXJyb3IgPSBnZXRCdWlsdEluLmFwcGx5KG51bGwsIHBhdGgpO1xuXG4gIGlmICghT3JpZ2luYWxFcnJvcikgcmV0dXJuO1xuXG4gIHZhciBPcmlnaW5hbEVycm9yUHJvdG90eXBlID0gT3JpZ2luYWxFcnJvci5wcm90b3R5cGU7XG5cbiAgLy8gVjggOS4zLSBidWcgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MTIwMDZcbiAgaWYgKCFJU19QVVJFICYmIGhhc093bihPcmlnaW5hbEVycm9yUHJvdG90eXBlLCAnY2F1c2UnKSkgZGVsZXRlIE9yaWdpbmFsRXJyb3JQcm90b3R5cGUuY2F1c2U7XG5cbiAgaWYgKCFGT1JDRUQpIHJldHVybiBPcmlnaW5hbEVycm9yO1xuXG4gIHZhciBCYXNlRXJyb3IgPSBnZXRCdWlsdEluKCdFcnJvcicpO1xuXG4gIHZhciBXcmFwcGVkRXJyb3IgPSB3cmFwcGVyKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBub3JtYWxpemVTdHJpbmdBcmd1bWVudChJU19BR0dSRUdBVEVfRVJST1IgPyBiIDogYSwgdW5kZWZpbmVkKTtcbiAgICB2YXIgcmVzdWx0ID0gSVNfQUdHUkVHQVRFX0VSUk9SID8gbmV3IE9yaWdpbmFsRXJyb3IoYSkgOiBuZXcgT3JpZ2luYWxFcnJvcigpO1xuICAgIGlmIChtZXNzYWdlICE9PSB1bmRlZmluZWQpIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShyZXN1bHQsICdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgaW5zdGFsbEVycm9yU3RhY2socmVzdWx0LCBXcmFwcGVkRXJyb3IsIHJlc3VsdC5zdGFjaywgMik7XG4gICAgaWYgKHRoaXMgJiYgaXNQcm90b3R5cGVPZihPcmlnaW5hbEVycm9yUHJvdG90eXBlLCB0aGlzKSkgaW5oZXJpdElmUmVxdWlyZWQocmVzdWx0LCB0aGlzLCBXcmFwcGVkRXJyb3IpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gT1BUSU9OU19QT1NJVElPTikgaW5zdGFsbEVycm9yQ2F1c2UocmVzdWx0LCBhcmd1bWVudHNbT1BUSU9OU19QT1NJVElPTl0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xuXG4gIFdyYXBwZWRFcnJvci5wcm90b3R5cGUgPSBPcmlnaW5hbEVycm9yUHJvdG90eXBlO1xuXG4gIGlmIChFUlJPUl9OQU1FICE9PSAnRXJyb3InKSB7XG4gICAgaWYgKHNldFByb3RvdHlwZU9mKSBzZXRQcm90b3R5cGVPZihXcmFwcGVkRXJyb3IsIEJhc2VFcnJvcik7XG4gICAgZWxzZSBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzKFdyYXBwZWRFcnJvciwgQmFzZUVycm9yLCB7IG5hbWU6IHRydWUgfSk7XG4gIH0gZWxzZSBpZiAoREVTQ1JJUFRPUlMgJiYgU1RBQ0tfVFJBQ0VfTElNSVQgaW4gT3JpZ2luYWxFcnJvcikge1xuICAgIHByb3h5QWNjZXNzb3IoV3JhcHBlZEVycm9yLCBPcmlnaW5hbEVycm9yLCBTVEFDS19UUkFDRV9MSU1JVCk7XG4gICAgcHJveHlBY2Nlc3NvcihXcmFwcGVkRXJyb3IsIE9yaWdpbmFsRXJyb3IsICdwcmVwYXJlU3RhY2tUcmFjZScpO1xuICB9XG5cbiAgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyhXcmFwcGVkRXJyb3IsIE9yaWdpbmFsRXJyb3IpO1xuXG4gIGlmICghSVNfUFVSRSkgdHJ5IHtcbiAgICAvLyBTYWZhcmkgMTMtIGJ1ZzogV2ViQXNzZW1ibHkgZXJyb3JzIGRvZXMgbm90IGhhdmUgYSBwcm9wZXIgYC5uYW1lYFxuICAgIGlmIChPcmlnaW5hbEVycm9yUHJvdG90eXBlLm5hbWUgIT09IEVSUk9SX05BTUUpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShPcmlnaW5hbEVycm9yUHJvdG90eXBlLCAnbmFtZScsIEVSUk9SX05BTUUpO1xuICAgIH1cbiAgICBPcmlnaW5hbEVycm9yUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gV3JhcHBlZEVycm9yO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG5cbiAgcmV0dXJuIFdyYXBwZWRFcnJvcjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hZGQtdG8tdW5zY29wYWJsZXMnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0b3JzJyk7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZScpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKS5mO1xudmFyIGRlZmluZUl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9yLWRlZmluZScpO1xudmFyIGNyZWF0ZUl0ZXJSZXN1bHRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLWl0ZXItcmVzdWx0LW9iamVjdCcpO1xudmFyIElTX1BVUkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcHVyZScpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG5cbnZhciBBUlJBWV9JVEVSQVRPUiA9ICdBcnJheSBJdGVyYXRvcic7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcihBUlJBWV9JVEVSQVRPUik7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZW50cmllc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5lbnRyaWVzXG4vLyBgQXJyYXkucHJvdG90eXBlLmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUua2V5c1xuLy8gYEFycmF5LnByb3RvdHlwZS52YWx1ZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUudmFsdWVzXG4vLyBgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAaXRlcmF0b3Jcbi8vIGBDcmVhdGVBcnJheUl0ZXJhdG9yYCBpbnRlcm5hbCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtY3JlYXRlYXJyYXlpdGVyYXRvclxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVJdGVyYXRvcihBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gIHNldEludGVybmFsU3RhdGUodGhpcywge1xuICAgIHR5cGU6IEFSUkFZX0lURVJBVE9SLFxuICAgIHRhcmdldDogdG9JbmRleGVkT2JqZWN0KGl0ZXJhdGVkKSwgLy8gdGFyZ2V0XG4gICAgaW5kZXg6IDAsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gICAga2luZDoga2luZCAgICAgICAgICAgICAgICAgICAgICAgICAvLyBraW5kXG4gIH0pO1xuLy8gYCVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWFycmF5aXRlcmF0b3Jwcm90b3R5cGUlLm5leHRcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgdmFyIHRhcmdldCA9IHN0YXRlLnRhcmdldDtcbiAgdmFyIGtpbmQgPSBzdGF0ZS5raW5kO1xuICB2YXIgaW5kZXggPSBzdGF0ZS5pbmRleCsrO1xuICBpZiAoIXRhcmdldCB8fCBpbmRleCA+PSB0YXJnZXQubGVuZ3RoKSB7XG4gICAgc3RhdGUudGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0KHVuZGVmaW5lZCwgdHJ1ZSk7XG4gIH1cbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gY3JlYXRlSXRlclJlc3VsdE9iamVjdChpbmRleCwgZmFsc2UpO1xuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIGNyZWF0ZUl0ZXJSZXN1bHRPYmplY3QodGFyZ2V0W2luZGV4XSwgZmFsc2UpO1xuICByZXR1cm4gY3JlYXRlSXRlclJlc3VsdE9iamVjdChbaW5kZXgsIHRhcmdldFtpbmRleF1dLCBmYWxzZSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJVxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1jcmVhdGV1bm1hcHBlZGFyZ3VtZW50c29iamVjdFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1jcmVhdGVtYXBwZWRhcmd1bWVudHNvYmplY3RcbnZhciB2YWx1ZXMgPSBJdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5O1xuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5hZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTtcblxuLy8gVjggfiBDaHJvbWUgNDUtIGJ1Z1xuaWYgKCFJU19QVVJFICYmIERFU0NSSVBUT1JTICYmIHZhbHVlcy5uYW1lICE9PSAndmFsdWVzJykgdHJ5IHtcbiAgZGVmaW5lUHJvcGVydHkodmFsdWVzLCAnbmFtZScsIHsgdmFsdWU6ICd2YWx1ZXMnIH0pO1xufSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuIiwidmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgZGVmaW5lQnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4nKTtcbnZhciBkYXRlVG9QcmltaXRpdmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGF0ZS10by1wcmltaXRpdmUnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIFRPX1BSSU1JVElWRSA9IHdlbGxLbm93blN5bWJvbCgndG9QcmltaXRpdmUnKTtcbnZhciBEYXRlUHJvdG90eXBlID0gRGF0ZS5wcm90b3R5cGU7XG5cbi8vIGBEYXRlLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWRhdGUucHJvdG90eXBlLUBAdG9wcmltaXRpdmVcbmlmICghaGFzT3duKERhdGVQcm90b3R5cGUsIFRPX1BSSU1JVElWRSkpIHtcbiAgZGVmaW5lQnVpbHRJbihEYXRlUHJvdG90eXBlLCBUT19QUklNSVRJVkUsIGRhdGVUb1ByaW1pdGl2ZSk7XG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgZnVuY3Rpb25zIGAubGVuZ3RoYCAqL1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGFwcGx5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWFwcGx5Jyk7XG52YXIgd3JhcEVycm9yQ29uc3RydWN0b3JXaXRoQ2F1c2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd3JhcC1lcnJvci1jb25zdHJ1Y3Rvci13aXRoLWNhdXNlJyk7XG5cbnZhciBXRUJfQVNTRU1CTFkgPSAnV2ViQXNzZW1ibHknO1xudmFyIFdlYkFzc2VtYmx5ID0gZ2xvYmFsW1dFQl9BU1NFTUJMWV07XG5cbnZhciBGT1JDRUQgPSBFcnJvcignZScsIHsgY2F1c2U6IDcgfSkuY2F1c2UgIT09IDc7XG5cbnZhciBleHBvcnRHbG9iYWxFcnJvckNhdXNlV3JhcHBlciA9IGZ1bmN0aW9uIChFUlJPUl9OQU1FLCB3cmFwcGVyKSB7XG4gIHZhciBPID0ge307XG4gIE9bRVJST1JfTkFNRV0gPSB3cmFwRXJyb3JDb25zdHJ1Y3RvcldpdGhDYXVzZShFUlJPUl9OQU1FLCB3cmFwcGVyLCBGT1JDRUQpO1xuICAkKHsgZ2xvYmFsOiB0cnVlLCBjb25zdHJ1Y3RvcjogdHJ1ZSwgYXJpdHk6IDEsIGZvcmNlZDogRk9SQ0VEIH0sIE8pO1xufTtcblxudmFyIGV4cG9ydFdlYkFzc2VtYmx5RXJyb3JDYXVzZVdyYXBwZXIgPSBmdW5jdGlvbiAoRVJST1JfTkFNRSwgd3JhcHBlcikge1xuICBpZiAoV2ViQXNzZW1ibHkgJiYgV2ViQXNzZW1ibHlbRVJST1JfTkFNRV0pIHtcbiAgICB2YXIgTyA9IHt9O1xuICAgIE9bRVJST1JfTkFNRV0gPSB3cmFwRXJyb3JDb25zdHJ1Y3RvcldpdGhDYXVzZShXRUJfQVNTRU1CTFkgKyAnLicgKyBFUlJPUl9OQU1FLCB3cmFwcGVyLCBGT1JDRUQpO1xuICAgICQoeyB0YXJnZXQ6IFdFQl9BU1NFTUJMWSwgc3RhdDogdHJ1ZSwgY29uc3RydWN0b3I6IHRydWUsIGFyaXR5OiAxLCBmb3JjZWQ6IEZPUkNFRCB9LCBPKTtcbiAgfVxufTtcblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1uYXRpdmVlcnJvclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtZXJyb3ItY2F1c2VcbmV4cG9ydEdsb2JhbEVycm9yQ2F1c2VXcmFwcGVyKCdFcnJvcicsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBFcnJvcihtZXNzYWdlKSB7IHJldHVybiBhcHBseShpbml0LCB0aGlzLCBhcmd1bWVudHMpOyB9O1xufSk7XG5leHBvcnRHbG9iYWxFcnJvckNhdXNlV3JhcHBlcignRXZhbEVycm9yJywgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEV2YWxFcnJvcihtZXNzYWdlKSB7IHJldHVybiBhcHBseShpbml0LCB0aGlzLCBhcmd1bWVudHMpOyB9O1xufSk7XG5leHBvcnRHbG9iYWxFcnJvckNhdXNlV3JhcHBlcignUmFuZ2VFcnJvcicsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBSYW5nZUVycm9yKG1lc3NhZ2UpIHsgcmV0dXJuIGFwcGx5KGluaXQsIHRoaXMsIGFyZ3VtZW50cyk7IH07XG59KTtcbmV4cG9ydEdsb2JhbEVycm9yQ2F1c2VXcmFwcGVyKCdSZWZlcmVuY2VFcnJvcicsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBSZWZlcmVuY2VFcnJvcihtZXNzYWdlKSB7IHJldHVybiBhcHBseShpbml0LCB0aGlzLCBhcmd1bWVudHMpOyB9O1xufSk7XG5leHBvcnRHbG9iYWxFcnJvckNhdXNlV3JhcHBlcignU3ludGF4RXJyb3InLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gU3ludGF4RXJyb3IobWVzc2FnZSkgeyByZXR1cm4gYXBwbHkoaW5pdCwgdGhpcywgYXJndW1lbnRzKTsgfTtcbn0pO1xuZXhwb3J0R2xvYmFsRXJyb3JDYXVzZVdyYXBwZXIoJ1R5cGVFcnJvcicsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBUeXBlRXJyb3IobWVzc2FnZSkgeyByZXR1cm4gYXBwbHkoaW5pdCwgdGhpcywgYXJndW1lbnRzKTsgfTtcbn0pO1xuZXhwb3J0R2xvYmFsRXJyb3JDYXVzZVdyYXBwZXIoJ1VSSUVycm9yJywgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVSSUVycm9yKG1lc3NhZ2UpIHsgcmV0dXJuIGFwcGx5KGluaXQsIHRoaXMsIGFyZ3VtZW50cyk7IH07XG59KTtcbmV4cG9ydFdlYkFzc2VtYmx5RXJyb3JDYXVzZVdyYXBwZXIoJ0NvbXBpbGVFcnJvcicsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBDb21waWxlRXJyb3IobWVzc2FnZSkgeyByZXR1cm4gYXBwbHkoaW5pdCwgdGhpcywgYXJndW1lbnRzKTsgfTtcbn0pO1xuZXhwb3J0V2ViQXNzZW1ibHlFcnJvckNhdXNlV3JhcHBlcignTGlua0Vycm9yJywgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIExpbmtFcnJvcihtZXNzYWdlKSB7IHJldHVybiBhcHBseShpbml0LCB0aGlzLCBhcmd1bWVudHMpOyB9O1xufSk7XG5leHBvcnRXZWJBc3NlbWJseUVycm9yQ2F1c2VXcmFwcGVyKCdSdW50aW1lRXJyb3InLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gUnVudGltZUVycm9yKG1lc3NhZ2UpIHsgcmV0dXJuIGFwcGx5KGluaXQsIHRoaXMsIGFyZ3VtZW50cyk7IH07XG59KTtcbiIsInZhciBkZWZpbmVCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbicpO1xudmFyIGVycm9yVG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXJyb3ItdG8tc3RyaW5nJyk7XG5cbnZhciBFcnJvclByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuLy8gYEVycm9yLnByb3RvdHlwZS50b1N0cmluZ2AgbWV0aG9kIGZpeFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1lcnJvci5wcm90b3R5cGUudG9zdHJpbmdcbmlmIChFcnJvclByb3RvdHlwZS50b1N0cmluZyAhPT0gZXJyb3JUb1N0cmluZykge1xuICBkZWZpbmVCdWlsdEluKEVycm9yUHJvdG90eXBlLCAndG9TdHJpbmcnLCBlcnJvclRvU3RyaW5nKTtcbn1cbiIsIi8vIFRPRE86IFJlbW92ZSBmcm9tIGBjb3JlLWpzQDRgXG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQnKTtcblxuLy8gYEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZnVuY3Rpb24ucHJvdG90eXBlLmJpbmRcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1mdW5jdGlvbi1wcm90b3R5cGUtYmluZCAtLSBkZXRlY3Rpb25cbiQoeyB0YXJnZXQ6ICdGdW5jdGlvbicsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEZ1bmN0aW9uLmJpbmQgIT09IGJpbmQgfSwge1xuICBiaW5kOiBiaW5kXG59KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluJyk7XG52YXIgYXBwbHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYXBwbHknKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwnKTtcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBpc1N5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1zeW1ib2wnKTtcbnZhciBhcnJheVNsaWNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LXNsaWNlJyk7XG52YXIgZ2V0UmVwbGFjZXJGdW5jdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtanNvbi1yZXBsYWNlci1mdW5jdGlvbicpO1xudmFyIE5BVElWRV9TWU1CT0wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3ltYm9sLWNvbnN0cnVjdG9yLWRldGVjdGlvbicpO1xuXG52YXIgJFN0cmluZyA9IFN0cmluZztcbnZhciAkc3RyaW5naWZ5ID0gZ2V0QnVpbHRJbignSlNPTicsICdzdHJpbmdpZnknKTtcbnZhciBleGVjID0gdW5jdXJyeVRoaXMoLy4vLmV4ZWMpO1xudmFyIGNoYXJBdCA9IHVuY3VycnlUaGlzKCcnLmNoYXJBdCk7XG52YXIgY2hhckNvZGVBdCA9IHVuY3VycnlUaGlzKCcnLmNoYXJDb2RlQXQpO1xudmFyIHJlcGxhY2UgPSB1bmN1cnJ5VGhpcygnJy5yZXBsYWNlKTtcbnZhciBudW1iZXJUb1N0cmluZyA9IHVuY3VycnlUaGlzKDEuMC50b1N0cmluZyk7XG5cbnZhciB0ZXN0ZXIgPSAvW1xcdUQ4MDAtXFx1REZGRl0vZztcbnZhciBsb3cgPSAvXltcXHVEODAwLVxcdURCRkZdJC87XG52YXIgaGkgPSAvXltcXHVEQzAwLVxcdURGRkZdJC87XG5cbnZhciBXUk9OR19TWU1CT0xTX0NPTlZFUlNJT04gPSAhTkFUSVZFX1NZTUJPTCB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBzeW1ib2wgPSBnZXRCdWlsdEluKCdTeW1ib2wnKSgpO1xuICAvLyBNUyBFZGdlIGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyB7fVxuICByZXR1cm4gJHN0cmluZ2lmeShbc3ltYm9sXSkgIT0gJ1tudWxsXSdcbiAgICAvLyBXZWJLaXQgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIG51bGxcbiAgICB8fCAkc3RyaW5naWZ5KHsgYTogc3ltYm9sIH0pICE9ICd7fSdcbiAgICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICAgIHx8ICRzdHJpbmdpZnkoT2JqZWN0KHN5bWJvbCkpICE9ICd7fSc7XG59KTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtd2VsbC1mb3JtZWQtc3RyaW5naWZ5XG52YXIgSUxMX0ZPUk1FRF9VTklDT0RFID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJHN0cmluZ2lmeSgnXFx1REYwNlxcdUQ4MzQnKSAhPT0gJ1wiXFxcXHVkZjA2XFxcXHVkODM0XCInXG4gICAgfHwgJHN0cmluZ2lmeSgnXFx1REVBRCcpICE9PSAnXCJcXFxcdWRlYWRcIic7XG59KTtcblxudmFyIHN0cmluZ2lmeVdpdGhTeW1ib2xzRml4ID0gZnVuY3Rpb24gKGl0LCByZXBsYWNlcikge1xuICB2YXIgYXJncyA9IGFycmF5U2xpY2UoYXJndW1lbnRzKTtcbiAgdmFyICRyZXBsYWNlciA9IGdldFJlcGxhY2VyRnVuY3Rpb24ocmVwbGFjZXIpO1xuICBpZiAoIWlzQ2FsbGFibGUoJHJlcGxhY2VyKSAmJiAoaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpKSByZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcbiAgYXJnc1sxXSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgLy8gc29tZSBvbGQgaW1wbGVtZW50YXRpb25zIChsaWtlIFdlYktpdCkgY291bGQgcGFzcyBudW1iZXJzIGFzIGtleXNcbiAgICBpZiAoaXNDYWxsYWJsZSgkcmVwbGFjZXIpKSB2YWx1ZSA9IGNhbGwoJHJlcGxhY2VyLCB0aGlzLCAkU3RyaW5nKGtleSksIHZhbHVlKTtcbiAgICBpZiAoIWlzU3ltYm9sKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICB9O1xuICByZXR1cm4gYXBwbHkoJHN0cmluZ2lmeSwgbnVsbCwgYXJncyk7XG59O1xuXG52YXIgZml4SWxsRm9ybWVkID0gZnVuY3Rpb24gKG1hdGNoLCBvZmZzZXQsIHN0cmluZykge1xuICB2YXIgcHJldiA9IGNoYXJBdChzdHJpbmcsIG9mZnNldCAtIDEpO1xuICB2YXIgbmV4dCA9IGNoYXJBdChzdHJpbmcsIG9mZnNldCArIDEpO1xuICBpZiAoKGV4ZWMobG93LCBtYXRjaCkgJiYgIWV4ZWMoaGksIG5leHQpKSB8fCAoZXhlYyhoaSwgbWF0Y2gpICYmICFleGVjKGxvdywgcHJldikpKSB7XG4gICAgcmV0dXJuICdcXFxcdScgKyBudW1iZXJUb1N0cmluZyhjaGFyQ29kZUF0KG1hdGNoLCAwKSwgMTYpO1xuICB9IHJldHVybiBtYXRjaDtcbn07XG5cbmlmICgkc3RyaW5naWZ5KSB7XG4gIC8vIGBKU09OLnN0cmluZ2lmeWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtanNvbi5zdHJpbmdpZnlcbiAgJCh7IHRhcmdldDogJ0pTT04nLCBzdGF0OiB0cnVlLCBhcml0eTogMywgZm9yY2VkOiBXUk9OR19TWU1CT0xTX0NPTlZFUlNJT04gfHwgSUxMX0ZPUk1FRF9VTklDT0RFIH0sIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIGAubGVuZ3RoYFxuICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0LCByZXBsYWNlciwgc3BhY2UpIHtcbiAgICAgIHZhciBhcmdzID0gYXJyYXlTbGljZShhcmd1bWVudHMpO1xuICAgICAgdmFyIHJlc3VsdCA9IGFwcGx5KFdST05HX1NZTUJPTFNfQ09OVkVSU0lPTiA/IHN0cmluZ2lmeVdpdGhTeW1ib2xzRml4IDogJHN0cmluZ2lmeSwgbnVsbCwgYXJncyk7XG4gICAgICByZXR1cm4gSUxMX0ZPUk1FRF9VTklDT0RFICYmIHR5cGVvZiByZXN1bHQgPT0gJ3N0cmluZycgPyByZXBsYWNlKHJlc3VsdCwgdGVzdGVyLCBmaXhJbGxGb3JtZWQpIDogcmVzdWx0O1xuICAgIH1cbiAgfSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBJU19QVVJFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXB1cmUnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3BhdGgnKTtcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBpc0ZvcmNlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1mb3JjZWQnKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eScpO1xudmFyIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luaGVyaXQtaWYtcmVxdWlyZWQnKTtcbnZhciBpc1Byb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1pcy1wcm90b3R5cGUtb2YnKTtcbnZhciBpc1N5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1zeW1ib2wnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1wcmltaXRpdmUnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGdldE93blByb3BlcnR5TmFtZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMnKS5mO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJykuZjtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5JykuZjtcbnZhciB0aGlzTnVtYmVyVmFsdWUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdGhpcy1udW1iZXItdmFsdWUnKTtcbnZhciB0cmltID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N0cmluZy10cmltJykudHJpbTtcblxudmFyIE5VTUJFUiA9ICdOdW1iZXInO1xudmFyIE5hdGl2ZU51bWJlciA9IGdsb2JhbFtOVU1CRVJdO1xudmFyIFB1cmVOdW1iZXJOYW1lc3BhY2UgPSBwYXRoW05VTUJFUl07XG52YXIgTnVtYmVyUHJvdG90eXBlID0gTmF0aXZlTnVtYmVyLnByb3RvdHlwZTtcbnZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xudmFyIHN0cmluZ1NsaWNlID0gdW5jdXJyeVRoaXMoJycuc2xpY2UpO1xudmFyIGNoYXJDb2RlQXQgPSB1bmN1cnJ5VGhpcygnJy5jaGFyQ29kZUF0KTtcblxuLy8gYFRvTnVtZXJpY2AgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvbnVtZXJpY1xudmFyIHRvTnVtZXJpYyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgcHJpbVZhbHVlID0gdG9QcmltaXRpdmUodmFsdWUsICdudW1iZXInKTtcbiAgcmV0dXJuIHR5cGVvZiBwcmltVmFsdWUgPT0gJ2JpZ2ludCcgPyBwcmltVmFsdWUgOiB0b051bWJlcihwcmltVmFsdWUpO1xufTtcblxuLy8gYFRvTnVtYmVyYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9udW1iZXJcbnZhciB0b051bWJlciA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIgaXQgPSB0b1ByaW1pdGl2ZShhcmd1bWVudCwgJ251bWJlcicpO1xuICB2YXIgZmlyc3QsIHRoaXJkLCByYWRpeCwgbWF4Q29kZSwgZGlnaXRzLCBsZW5ndGgsIGluZGV4LCBjb2RlO1xuICBpZiAoaXNTeW1ib2woaXQpKSB0aHJvdyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGEgU3ltYm9sIHZhbHVlIHRvIGEgbnVtYmVyJyk7XG4gIGlmICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgJiYgaXQubGVuZ3RoID4gMikge1xuICAgIGl0ID0gdHJpbShpdCk7XG4gICAgZmlyc3QgPSBjaGFyQ29kZUF0KGl0LCAwKTtcbiAgICBpZiAoZmlyc3QgPT09IDQzIHx8IGZpcnN0ID09PSA0NSkge1xuICAgICAgdGhpcmQgPSBjaGFyQ29kZUF0KGl0LCAyKTtcbiAgICAgIGlmICh0aGlyZCA9PT0gODggfHwgdGhpcmQgPT09IDEyMCkgcmV0dXJuIE5hTjsgLy8gTnVtYmVyKCcrMHgxJykgc2hvdWxkIGJlIE5hTiwgb2xkIFY4IGZpeFxuICAgIH0gZWxzZSBpZiAoZmlyc3QgPT09IDQ4KSB7XG4gICAgICBzd2l0Y2ggKGNoYXJDb2RlQXQoaXQsIDEpKSB7XG4gICAgICAgIGNhc2UgNjY6IGNhc2UgOTg6IHJhZGl4ID0gMjsgbWF4Q29kZSA9IDQ5OyBicmVhazsgLy8gZmFzdCBlcXVhbCBvZiAvXjBiWzAxXSskL2lcbiAgICAgICAgY2FzZSA3OTogY2FzZSAxMTE6IHJhZGl4ID0gODsgbWF4Q29kZSA9IDU1OyBicmVhazsgLy8gZmFzdCBlcXVhbCBvZiAvXjBvWzAtN10rJC9pXG4gICAgICAgIGRlZmF1bHQ6IHJldHVybiAraXQ7XG4gICAgICB9XG4gICAgICBkaWdpdHMgPSBzdHJpbmdTbGljZShpdCwgMik7XG4gICAgICBsZW5ndGggPSBkaWdpdHMubGVuZ3RoO1xuICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGNvZGUgPSBjaGFyQ29kZUF0KGRpZ2l0cywgaW5kZXgpO1xuICAgICAgICAvLyBwYXJzZUludCBwYXJzZXMgYSBzdHJpbmcgdG8gYSBmaXJzdCB1bmF2YWlsYWJsZSBzeW1ib2xcbiAgICAgICAgLy8gYnV0IFRvTnVtYmVyIHNob3VsZCByZXR1cm4gTmFOIGlmIGEgc3RyaW5nIGNvbnRhaW5zIHVuYXZhaWxhYmxlIHN5bWJvbHNcbiAgICAgICAgaWYgKGNvZGUgPCA0OCB8fCBjb2RlID4gbWF4Q29kZSkgcmV0dXJuIE5hTjtcbiAgICAgIH0gcmV0dXJuIHBhcnNlSW50KGRpZ2l0cywgcmFkaXgpO1xuICAgIH1cbiAgfSByZXR1cm4gK2l0O1xufTtcblxudmFyIEZPUkNFRCA9IGlzRm9yY2VkKE5VTUJFUiwgIU5hdGl2ZU51bWJlcignIDBvMScpIHx8ICFOYXRpdmVOdW1iZXIoJzBiMScpIHx8IE5hdGl2ZU51bWJlcignKzB4MScpKTtcblxudmFyIGNhbGxlZFdpdGhOZXcgPSBmdW5jdGlvbiAoZHVtbXkpIHtcbiAgLy8gaW5jbHVkZXMgY2hlY2sgb24gMS4uY29uc3RydWN0b3IoZm9vKSBjYXNlXG4gIHJldHVybiBpc1Byb3RvdHlwZU9mKE51bWJlclByb3RvdHlwZSwgZHVtbXkpICYmIGZhaWxzKGZ1bmN0aW9uICgpIHsgdGhpc051bWJlclZhbHVlKGR1bW15KTsgfSk7XG59O1xuXG4vLyBgTnVtYmVyYCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1udW1iZXItY29uc3RydWN0b3JcbnZhciBOdW1iZXJXcmFwcGVyID0gZnVuY3Rpb24gTnVtYmVyKHZhbHVlKSB7XG4gIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aCA8IDEgPyAwIDogTmF0aXZlTnVtYmVyKHRvTnVtZXJpYyh2YWx1ZSkpO1xuICByZXR1cm4gY2FsbGVkV2l0aE5ldyh0aGlzKSA/IGluaGVyaXRJZlJlcXVpcmVkKE9iamVjdChuKSwgdGhpcywgTnVtYmVyV3JhcHBlcikgOiBuO1xufTtcblxuTnVtYmVyV3JhcHBlci5wcm90b3R5cGUgPSBOdW1iZXJQcm90b3R5cGU7XG5pZiAoRk9SQ0VEICYmICFJU19QVVJFKSBOdW1iZXJQcm90b3R5cGUuY29uc3RydWN0b3IgPSBOdW1iZXJXcmFwcGVyO1xuXG4kKHsgZ2xvYmFsOiB0cnVlLCBjb25zdHJ1Y3RvcjogdHJ1ZSwgd3JhcDogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQgfSwge1xuICBOdW1iZXI6IE51bWJlcldyYXBwZXJcbn0pO1xuXG4vLyBVc2UgYGludGVybmFsL2NvcHktY29uc3RydWN0b3ItcHJvcGVydGllc2AgaGVscGVyIGluIGBjb3JlLWpzQDRgXG52YXIgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuICBmb3IgKHZhciBrZXlzID0gREVTQ1JJUFRPUlMgPyBnZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZSkgOiAoXG4gICAgLy8gRVMzOlxuICAgICdNQVhfVkFMVUUsTUlOX1ZBTFVFLE5hTixORUdBVElWRV9JTkZJTklUWSxQT1NJVElWRV9JTkZJTklUWSwnICtcbiAgICAvLyBFUzIwMTUgKGluIGNhc2UsIGlmIG1vZHVsZXMgd2l0aCBFUzIwMTUgTnVtYmVyIHN0YXRpY3MgcmVxdWlyZWQgYmVmb3JlKTpcbiAgICAnRVBTSUxPTixNQVhfU0FGRV9JTlRFR0VSLE1JTl9TQUZFX0lOVEVHRVIsaXNGaW5pdGUsaXNJbnRlZ2VyLGlzTmFOLGlzU2FmZUludGVnZXIscGFyc2VGbG9hdCxwYXJzZUludCwnICtcbiAgICAvLyBFU05leHRcbiAgICAnZnJvbVN0cmluZyxyYW5nZSdcbiAgKS5zcGxpdCgnLCcpLCBqID0gMCwga2V5OyBrZXlzLmxlbmd0aCA+IGo7IGorKykge1xuICAgIGlmIChoYXNPd24oc291cmNlLCBrZXkgPSBrZXlzW2pdKSAmJiAhaGFzT3duKHRhcmdldCwga2V5KSkge1xuICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgIH1cbiAgfVxufTtcblxuaWYgKElTX1BVUkUgJiYgUHVyZU51bWJlck5hbWVzcGFjZSkgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyhwYXRoW05VTUJFUl0sIFB1cmVOdW1iZXJOYW1lc3BhY2UpO1xuaWYgKEZPUkNFRCB8fCBJU19QVVJFKSBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzKHBhdGhbTlVNQkVSXSwgTmF0aXZlTnVtYmVyKTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtYXNzaWduJyk7XG5cbi8vIGBPYmplY3QuYXNzaWduYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmFzc2lnblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1hc3NpZ24gLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBhcml0eTogMiwgZm9yY2VkOiBPYmplY3QuYXNzaWduICE9PSBhc3NpZ24gfSwge1xuICBhc3NpZ246IGFzc2lnblxufSk7XG4iLCIvLyBUT0RPOiBSZW1vdmUgZnJvbSBgY29yZS1qc0A0YFxudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZScpO1xuXG4vLyBgT2JqZWN0LmNyZWF0ZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5jcmVhdGVcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBzaGFtOiAhREVTQ1JJUFRPUlMgfSwge1xuICBjcmVhdGU6IGNyZWF0ZVxufSk7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKS5mO1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnR5XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAhPT0gZGVmaW5lUHJvcGVydHksIHNoYW06ICFERVNDUklQVE9SUyB9LCB7XG4gIGRlZmluZVByb3BlcnR5OiBkZWZpbmVQcm9wZXJ0eVxufSk7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBOQVRJVkVfU1lNQk9MID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N5bWJvbC1jb25zdHJ1Y3Rvci1kZXRlY3Rpb24nKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG5cbi8vIFY4IH4gQ2hyb21lIDM4IGFuZCAzOSBgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc2AgZmFpbHMgb24gcHJpbWl0aXZlc1xuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzQ0M1xudmFyIEZPUkNFRCA9ICFOQVRJVkVfU1lNQk9MIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHsgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmYoMSk7IH0pO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eXN5bWJvbHNcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gIGdldE93blByb3BlcnR5U3ltYm9sczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSB7XG4gICAgdmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZjtcbiAgICByZXR1cm4gJGdldE93blByb3BlcnR5U3ltYm9scyA/ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHModG9PYmplY3QoaXQpKSA6IFtdO1xuICB9XG59KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgbmF0aXZlR2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YnKTtcbnZhciBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY29ycmVjdC1wcm90b3R5cGUtZ2V0dGVyJyk7XG5cbnZhciBGQUlMU19PTl9QUklNSVRJVkVTID0gZmFpbHMoZnVuY3Rpb24gKCkgeyBuYXRpdmVHZXRQcm90b3R5cGVPZigxKTsgfSk7XG5cbi8vIGBPYmplY3QuZ2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0cHJvdG90eXBlb2ZcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZBSUxTX09OX1BSSU1JVElWRVMsIHNoYW06ICFDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgfSwge1xuICBnZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YoaXQpIHtcbiAgICByZXR1cm4gbmF0aXZlR2V0UHJvdG90eXBlT2YodG9PYmplY3QoaXQpKTtcbiAgfVxufSk7XG5cbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mJyk7XG5cbi8vIGBPYmplY3Quc2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3Quc2V0cHJvdG90eXBlb2ZcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlIH0sIHtcbiAgc2V0UHJvdG90eXBlT2Y6IHNldFByb3RvdHlwZU9mXG59KTtcbiIsInZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tc3RyaW5nLXRhZy1zdXBwb3J0Jyk7XG52YXIgZGVmaW5lQnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4nKTtcbnZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtdG8tc3RyaW5nJyk7XG5cbi8vIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZ1xuaWYgKCFUT19TVFJJTkdfVEFHX1NVUFBPUlQpIHtcbiAgZGVmaW5lQnVpbHRJbihPYmplY3QucHJvdG90eXBlLCAndG9TdHJpbmcnLCB0b1N0cmluZywgeyB1bnNhZmU6IHRydWUgfSk7XG59XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIGFwcGx5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWFwcGx5Jyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1iaW5kJyk7XG52YXIgYUNvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2EtY29uc3RydWN0b3InKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZScpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbnZhciBuYXRpdmVDb25zdHJ1Y3QgPSBnZXRCdWlsdEluKCdSZWZsZWN0JywgJ2NvbnN0cnVjdCcpO1xudmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgcHVzaCA9IFtdLnB1c2g7XG5cbi8vIGBSZWZsZWN0LmNvbnN0cnVjdGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZmxlY3QuY29uc3RydWN0XG4vLyBNUyBFZGdlIHN1cHBvcnRzIG9ubHkgMiBhcmd1bWVudHMgYW5kIGFyZ3VtZW50c0xpc3QgYXJndW1lbnQgaXMgb3B0aW9uYWxcbi8vIEZGIE5pZ2h0bHkgc2V0cyB0aGlyZCBhcmd1bWVudCBhcyBgbmV3LnRhcmdldGAsIGJ1dCBkb2VzIG5vdCBjcmVhdGUgYHRoaXNgIGZyb20gaXRcbnZhciBORVdfVEFSR0VUX0JVRyA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRigpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gIShuYXRpdmVDb25zdHJ1Y3QoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCBbXSwgRikgaW5zdGFuY2VvZiBGKTtcbn0pO1xuXG52YXIgQVJHU19CVUcgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICBuYXRpdmVDb25zdHJ1Y3QoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KTtcbn0pO1xuXG52YXIgRk9SQ0VEID0gTkVXX1RBUkdFVF9CVUcgfHwgQVJHU19CVUc7XG5cbiQoeyB0YXJnZXQ6ICdSZWZsZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQsIHNoYW06IEZPUkNFRCB9LCB7XG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gY29uc3RydWN0KFRhcmdldCwgYXJncyAvKiAsIG5ld1RhcmdldCAqLykge1xuICAgIGFDb25zdHJ1Y3RvcihUYXJnZXQpO1xuICAgIGFuT2JqZWN0KGFyZ3MpO1xuICAgIHZhciBuZXdUYXJnZXQgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IFRhcmdldCA6IGFDb25zdHJ1Y3Rvcihhcmd1bWVudHNbMl0pO1xuICAgIGlmIChBUkdTX0JVRyAmJiAhTkVXX1RBUkdFVF9CVUcpIHJldHVybiBuYXRpdmVDb25zdHJ1Y3QoVGFyZ2V0LCBhcmdzLCBuZXdUYXJnZXQpO1xuICAgIGlmIChUYXJnZXQgPT0gbmV3VGFyZ2V0KSB7XG4gICAgICAvLyB3L28gYWx0ZXJlZCBuZXdUYXJnZXQsIG9wdGltaXphdGlvbiBmb3IgMC00IGFyZ3VtZW50c1xuICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgVGFyZ2V0KCk7XG4gICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSk7XG4gICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgIGNhc2UgMzogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgIGNhc2UgNDogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gICAgICB9XG4gICAgICAvLyB3L28gYWx0ZXJlZCBuZXdUYXJnZXQsIGxvdCBvZiBhcmd1bWVudHMgY2FzZVxuICAgICAgdmFyICRhcmdzID0gW251bGxdO1xuICAgICAgYXBwbHkocHVzaCwgJGFyZ3MsIGFyZ3MpO1xuICAgICAgcmV0dXJuIG5ldyAoYXBwbHkoYmluZCwgVGFyZ2V0LCAkYXJncykpKCk7XG4gICAgfVxuICAgIC8vIHdpdGggYWx0ZXJlZCBuZXdUYXJnZXQsIG5vdCBzdXBwb3J0IGJ1aWx0LWluIGNvbnN0cnVjdG9yc1xuICAgIHZhciBwcm90byA9IG5ld1RhcmdldC5wcm90b3R5cGU7XG4gICAgdmFyIGluc3RhbmNlID0gY3JlYXRlKGlzT2JqZWN0KHByb3RvKSA/IHByb3RvIDogT2JqZWN0UHJvdG90eXBlKTtcbiAgICB2YXIgcmVzdWx0ID0gYXBwbHkoVGFyZ2V0LCBpbnN0YW5jZSwgYXJncyk7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiBpbnN0YW5jZTtcbiAgfVxufSk7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcnKTtcblxuJCh7IGdsb2JhbDogdHJ1ZSB9LCB7IFJlZmxlY3Q6IHt9IH0pO1xuXG4vLyBSZWZsZWN0W0BAdG9TdHJpbmdUYWddIHByb3BlcnR5XG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZmxlY3QtQEB0b3N0cmluZ3RhZ1xuc2V0VG9TdHJpbmdUYWcoZ2xvYmFsLlJlZmxlY3QsICdSZWZsZWN0JywgdHJ1ZSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY2hhckF0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N0cmluZy1tdWx0aWJ5dGUnKS5jaGFyQXQ7XG52YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tc3RyaW5nJyk7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZScpO1xudmFyIGRlZmluZUl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9yLWRlZmluZScpO1xudmFyIGNyZWF0ZUl0ZXJSZXN1bHRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLWl0ZXItcmVzdWx0LW9iamVjdCcpO1xuXG52YXIgU1RSSU5HX0lURVJBVE9SID0gJ1N0cmluZyBJdGVyYXRvcic7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcihTVFJJTkdfSVRFUkFUT1IpO1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUtQEBpdGVyYXRvclxuZGVmaW5lSXRlcmF0b3IoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHNldEludGVybmFsU3RhdGUodGhpcywge1xuICAgIHR5cGU6IFNUUklOR19JVEVSQVRPUixcbiAgICBzdHJpbmc6IHRvU3RyaW5nKGl0ZXJhdGVkKSxcbiAgICBpbmRleDogMFxuICB9KTtcbi8vIGAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0lc3RyaW5naXRlcmF0b3Jwcm90b3R5cGUlLm5leHRcbn0sIGZ1bmN0aW9uIG5leHQoKSB7XG4gIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XG4gIHZhciBzdHJpbmcgPSBzdGF0ZS5zdHJpbmc7XG4gIHZhciBpbmRleCA9IHN0YXRlLmluZGV4O1xuICB2YXIgcG9pbnQ7XG4gIGlmIChpbmRleCA+PSBzdHJpbmcubGVuZ3RoKSByZXR1cm4gY3JlYXRlSXRlclJlc3VsdE9iamVjdCh1bmRlZmluZWQsIHRydWUpO1xuICBwb2ludCA9IGNoYXJBdChzdHJpbmcsIGluZGV4KTtcbiAgc3RhdGUuaW5kZXggKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4gY3JlYXRlSXRlclJlc3VsdE9iamVjdChwb2ludCwgZmFsc2UpO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsJyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgSVNfUFVSRSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1wdXJlJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBOQVRJVkVfU1lNQk9MID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N5bWJvbC1jb25zdHJ1Y3Rvci1kZXRlY3Rpb24nKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgaXNQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtaXMtcHJvdG90eXBlLW9mJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgdG9Qcm9wZXJ0eUtleSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1wcm9wZXJ0eS1rZXknKTtcbnZhciAkdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tc3RyaW5nJyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG52YXIgbmF0aXZlT2JqZWN0Q3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUnKTtcbnZhciBvYmplY3RLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcycpO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy1leHRlcm5hbCcpO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgZGVmaW5lUHJvcGVydGllc01vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnRpZXMnKTtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZScpO1xudmFyIGRlZmluZUJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluJyk7XG52YXIgZGVmaW5lQnVpbHRJbkFjY2Vzc29yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbi1hY2Nlc3NvcicpO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQnKTtcbnZhciBzaGFyZWRLZXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLWtleScpO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdWlkJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgd3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC13cmFwcGVkJyk7XG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLWRlZmluZScpO1xudmFyIGRlZmluZVN5bWJvbFRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N5bWJvbC1kZWZpbmUtdG8tcHJpbWl0aXZlJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG52YXIgJGZvckVhY2ggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uJykuZm9yRWFjaDtcblxudmFyIEhJRERFTiA9IHNoYXJlZEtleSgnaGlkZGVuJyk7XG52YXIgU1lNQk9MID0gJ1N5bWJvbCc7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yKFNZTUJPTCk7XG5cbnZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3RbUFJPVE9UWVBFXTtcbnZhciAkU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciBTeW1ib2xQcm90b3R5cGUgPSAkU3ltYm9sICYmICRTeW1ib2xbUFJPVE9UWVBFXTtcbnZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xudmFyIFFPYmplY3QgPSBnbG9iYWwuUU9iamVjdDtcbnZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZjtcbnZhciBuYXRpdmVEZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XG52YXIgbmF0aXZlR2V0T3duUHJvcGVydHlOYW1lcyA9IGdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbC5mO1xudmFyIG5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlID0gcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZjtcbnZhciBwdXNoID0gdW5jdXJyeVRoaXMoW10ucHVzaCk7XG5cbnZhciBBbGxTeW1ib2xzID0gc2hhcmVkKCdzeW1ib2xzJyk7XG52YXIgT2JqZWN0UHJvdG90eXBlU3ltYm9scyA9IHNoYXJlZCgnb3Atc3ltYm9scycpO1xudmFyIFdlbGxLbm93blN5bWJvbHNTdG9yZSA9IHNoYXJlZCgnd2tzJyk7XG5cbi8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xudmFyIFVTRV9TRVRURVIgPSAhUU9iamVjdCB8fCAhUU9iamVjdFtQUk9UT1RZUEVdIHx8ICFRT2JqZWN0W1BST1RPVFlQRV0uZmluZENoaWxkO1xuXG4vLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcbnZhciBzZXRTeW1ib2xEZXNjcmlwdG9yID0gREVTQ1JJUFRPUlMgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0Q3JlYXRlKG5hdGl2ZURlZmluZVByb3BlcnR5KHt9LCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5hdGl2ZURlZmluZVByb3BlcnR5KHRoaXMsICdhJywgeyB2YWx1ZTogNyB9KS5hOyB9XG4gIH0pKS5hICE9IDc7XG59KSA/IGZ1bmN0aW9uIChPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIHZhciBPYmplY3RQcm90b3R5cGVEZXNjcmlwdG9yID0gbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdFByb3RvdHlwZSwgUCk7XG4gIGlmIChPYmplY3RQcm90b3R5cGVEZXNjcmlwdG9yKSBkZWxldGUgT2JqZWN0UHJvdG90eXBlW1BdO1xuICBuYXRpdmVEZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgaWYgKE9iamVjdFByb3RvdHlwZURlc2NyaXB0b3IgJiYgTyAhPT0gT2JqZWN0UHJvdG90eXBlKSB7XG4gICAgbmF0aXZlRGVmaW5lUHJvcGVydHkoT2JqZWN0UHJvdG90eXBlLCBQLCBPYmplY3RQcm90b3R5cGVEZXNjcmlwdG9yKTtcbiAgfVxufSA6IG5hdGl2ZURlZmluZVByb3BlcnR5O1xuXG52YXIgd3JhcCA9IGZ1bmN0aW9uICh0YWcsIGRlc2NyaXB0aW9uKSB7XG4gIHZhciBzeW1ib2wgPSBBbGxTeW1ib2xzW3RhZ10gPSBuYXRpdmVPYmplY3RDcmVhdGUoU3ltYm9sUHJvdG90eXBlKTtcbiAgc2V0SW50ZXJuYWxTdGF0ZShzeW1ib2wsIHtcbiAgICB0eXBlOiBTWU1CT0wsXG4gICAgdGFnOiB0YWcsXG4gICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uXG4gIH0pO1xuICBpZiAoIURFU0NSSVBUT1JTKSBzeW1ib2wuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgcmV0dXJuIHN5bWJvbDtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGlmIChPID09PSBPYmplY3RQcm90b3R5cGUpICRkZWZpbmVQcm9wZXJ0eShPYmplY3RQcm90b3R5cGVTeW1ib2xzLCBQLCBBdHRyaWJ1dGVzKTtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXkgPSB0b1Byb3BlcnR5S2V5KFApO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKGhhc093bihBbGxTeW1ib2xzLCBrZXkpKSB7XG4gICAgaWYgKCFBdHRyaWJ1dGVzLmVudW1lcmFibGUpIHtcbiAgICAgIGlmICghaGFzT3duKE8sIEhJRERFTikpIG5hdGl2ZURlZmluZVByb3BlcnR5KE8sIEhJRERFTiwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIHt9KSk7XG4gICAgICBPW0hJRERFTl1ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChoYXNPd24oTywgSElEREVOKSAmJiBPW0hJRERFTl1ba2V5XSkgT1tISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEF0dHJpYnV0ZXMgPSBuYXRpdmVPYmplY3RDcmVhdGUoQXR0cmlidXRlcywgeyBlbnVtZXJhYmxlOiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMCwgZmFsc2UpIH0pO1xuICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2NyaXB0b3IoTywga2V5LCBBdHRyaWJ1dGVzKTtcbiAgfSByZXR1cm4gbmF0aXZlRGVmaW5lUHJvcGVydHkoTywga2V5LCBBdHRyaWJ1dGVzKTtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdChPKTtcbiAgdmFyIHByb3BlcnRpZXMgPSB0b0luZGV4ZWRPYmplY3QoUHJvcGVydGllcyk7XG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhwcm9wZXJ0aWVzKS5jb25jYXQoJGdldE93blByb3BlcnR5U3ltYm9scyhwcm9wZXJ0aWVzKSk7XG4gICRmb3JFYWNoKGtleXMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoIURFU0NSSVBUT1JTIHx8IGNhbGwoJHByb3BlcnR5SXNFbnVtZXJhYmxlLCBwcm9wZXJ0aWVzLCBrZXkpKSAkZGVmaW5lUHJvcGVydHkoTywga2V5LCBwcm9wZXJ0aWVzW2tleV0pO1xuICB9KTtcbiAgcmV0dXJuIE87XG59O1xuXG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyBuYXRpdmVPYmplY3RDcmVhdGUoTykgOiAkZGVmaW5lUHJvcGVydGllcyhuYXRpdmVPYmplY3RDcmVhdGUoTyksIFByb3BlcnRpZXMpO1xufTtcblxudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKFYpIHtcbiAgdmFyIFAgPSB0b1Byb3BlcnR5S2V5KFYpO1xuICB2YXIgZW51bWVyYWJsZSA9IGNhbGwobmF0aXZlUHJvcGVydHlJc0VudW1lcmFibGUsIHRoaXMsIFApO1xuICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG90eXBlICYmIGhhc093bihBbGxTeW1ib2xzLCBQKSAmJiAhaGFzT3duKE9iamVjdFByb3RvdHlwZVN5bWJvbHMsIFApKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBlbnVtZXJhYmxlIHx8ICFoYXNPd24odGhpcywgUCkgfHwgIWhhc093bihBbGxTeW1ib2xzLCBQKSB8fCBoYXNPd24odGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1bUF1cbiAgICA/IGVudW1lcmFibGUgOiB0cnVlO1xufTtcblxudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICB2YXIgaXQgPSB0b0luZGV4ZWRPYmplY3QoTyk7XG4gIHZhciBrZXkgPSB0b1Byb3BlcnR5S2V5KFApO1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvdHlwZSAmJiBoYXNPd24oQWxsU3ltYm9scywga2V5KSAmJiAhaGFzT3duKE9iamVjdFByb3RvdHlwZVN5bWJvbHMsIGtleSkpIHJldHVybjtcbiAgdmFyIGRlc2NyaXB0b3IgPSBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSk7XG4gIGlmIChkZXNjcmlwdG9yICYmIGhhc093bihBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzT3duKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpIHtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSB0cnVlO1xuICB9XG4gIHJldHVybiBkZXNjcmlwdG9yO1xufTtcblxudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHZhciBuYW1lcyA9IG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXModG9JbmRleGVkT2JqZWN0KE8pKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICAkZm9yRWFjaChuYW1lcywgZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICghaGFzT3duKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhc093bihoaWRkZW5LZXlzLCBrZXkpKSBwdXNoKHJlc3VsdCwga2V5KTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIChPKSB7XG4gIHZhciBJU19PQkpFQ1RfUFJPVE9UWVBFID0gTyA9PT0gT2JqZWN0UHJvdG90eXBlO1xuICB2YXIgbmFtZXMgPSBuYXRpdmVHZXRPd25Qcm9wZXJ0eU5hbWVzKElTX09CSkVDVF9QUk9UT1RZUEUgPyBPYmplY3RQcm90b3R5cGVTeW1ib2xzIDogdG9JbmRleGVkT2JqZWN0KE8pKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICAkZm9yRWFjaChuYW1lcywgZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChoYXNPd24oQWxsU3ltYm9scywga2V5KSAmJiAoIUlTX09CSkVDVF9QUk9UT1RZUEUgfHwgaGFzT3duKE9iamVjdFByb3RvdHlwZSwga2V5KSkpIHtcbiAgICAgIHB1c2gocmVzdWx0LCBBbGxTeW1ib2xzW2tleV0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBgU3ltYm9sYCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wtY29uc3RydWN0b3JcbmlmICghTkFUSVZFX1NZTUJPTCkge1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCkge1xuICAgIGlmIChpc1Byb3RvdHlwZU9mKFN5bWJvbFByb3RvdHlwZSwgdGhpcykpIHRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yJyk7XG4gICAgdmFyIGRlc2NyaXB0aW9uID0gIWFyZ3VtZW50cy5sZW5ndGggfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiAkdG9TdHJpbmcoYXJndW1lbnRzWzBdKTtcbiAgICB2YXIgdGFnID0gdWlkKGRlc2NyaXB0aW9uKTtcbiAgICB2YXIgc2V0dGVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG90eXBlKSBjYWxsKHNldHRlciwgT2JqZWN0UHJvdG90eXBlU3ltYm9scywgdmFsdWUpO1xuICAgICAgaWYgKGhhc093bih0aGlzLCBISURERU4pICYmIGhhc093bih0aGlzW0hJRERFTl0sIHRhZykpIHRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjcmlwdG9yKHRoaXMsIHRhZywgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIHZhbHVlKSk7XG4gICAgfTtcbiAgICBpZiAoREVTQ1JJUFRPUlMgJiYgVVNFX1NFVFRFUikgc2V0U3ltYm9sRGVzY3JpcHRvcihPYmplY3RQcm90b3R5cGUsIHRhZywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogc2V0dGVyIH0pO1xuICAgIHJldHVybiB3cmFwKHRhZywgZGVzY3JpcHRpb24pO1xuICB9O1xuXG4gIFN5bWJvbFByb3RvdHlwZSA9ICRTeW1ib2xbUFJPVE9UWVBFXTtcblxuICBkZWZpbmVCdWlsdEluKFN5bWJvbFByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGdldEludGVybmFsU3RhdGUodGhpcykudGFnO1xuICB9KTtcblxuICBkZWZpbmVCdWlsdEluKCRTeW1ib2wsICd3aXRob3V0U2V0dGVyJywgZnVuY3Rpb24gKGRlc2NyaXB0aW9uKSB7XG4gICAgcmV0dXJuIHdyYXAodWlkKGRlc2NyaXB0aW9uKSwgZGVzY3JpcHRpb24pO1xuICB9KTtcblxuICBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mID0gJGRlZmluZVByb3BlcnR5O1xuICBkZWZpbmVQcm9wZXJ0aWVzTW9kdWxlLmYgPSAkZGVmaW5lUHJvcGVydGllcztcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmYgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWwuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgd3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZS5mID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gd3JhcCh3ZWxsS25vd25TeW1ib2wobmFtZSksIG5hbWUpO1xuICB9O1xuXG4gIGlmIChERVNDUklQVE9SUykge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLVN5bWJvbC1kZXNjcmlwdGlvblxuICAgIGRlZmluZUJ1aWx0SW5BY2Nlc3NvcihTeW1ib2xQcm90b3R5cGUsICdkZXNjcmlwdGlvbicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZGVzY3JpcHRpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLmRlc2NyaXB0aW9uO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghSVNfUFVSRSkge1xuICAgICAgZGVmaW5lQnVpbHRJbihPYmplY3RQcm90b3R5cGUsICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgeyB1bnNhZmU6IHRydWUgfSk7XG4gICAgfVxuICB9XG59XG5cbiQoeyBnbG9iYWw6IHRydWUsIGNvbnN0cnVjdG9yOiB0cnVlLCB3cmFwOiB0cnVlLCBmb3JjZWQ6ICFOQVRJVkVfU1lNQk9MLCBzaGFtOiAhTkFUSVZFX1NZTUJPTCB9LCB7XG4gIFN5bWJvbDogJFN5bWJvbFxufSk7XG5cbiRmb3JFYWNoKG9iamVjdEtleXMoV2VsbEtub3duU3ltYm9sc1N0b3JlKSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgZGVmaW5lV2VsbEtub3duU3ltYm9sKG5hbWUpO1xufSk7XG5cbiQoeyB0YXJnZXQ6IFNZTUJPTCwgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTCB9LCB7XG4gIHVzZVNldHRlcjogZnVuY3Rpb24gKCkgeyBVU0VfU0VUVEVSID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbiAoKSB7IFVTRV9TRVRURVIgPSBmYWxzZTsgfVxufSk7XG5cbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6ICFOQVRJVkVfU1lNQk9MLCBzaGFtOiAhREVTQ1JJUFRPUlMgfSwge1xuICAvLyBgT2JqZWN0LmNyZWF0ZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmNyZWF0ZVxuICBjcmVhdGU6ICRjcmVhdGUsXG4gIC8vIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyBgT2JqZWN0LmRlZmluZVByb3BlcnRpZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0aWVzXG4gIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxuICAvLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvcnNcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yXG59KTtcblxuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogIU5BVElWRV9TWU1CT0wgfSwge1xuICAvLyBgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eW5hbWVzXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzXG59KTtcblxuLy8gYFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV1gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wucHJvdG90eXBlLUBAdG9wcmltaXRpdmVcbmRlZmluZVN5bWJvbFRvUHJpbWl0aXZlKCk7XG5cbi8vIGBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddYCBwcm9wZXJ0eVxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wucHJvdG90eXBlLUBAdG9zdHJpbmd0YWdcbnNldFRvU3RyaW5nVGFnKCRTeW1ib2wsIFNZTUJPTCk7XG5cbmhpZGRlbktleXNbSElEREVOXSA9IHRydWU7XG4iLCIvLyBgU3ltYm9sLnByb3RvdHlwZS5kZXNjcmlwdGlvbmAgZ2V0dGVyXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5wcm90b3R5cGUuZGVzY3JpcHRpb25cbid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIGlzUHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWlzLXByb3RvdHlwZS1vZicpO1xudmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXN0cmluZycpO1xudmFyIGRlZmluZUJ1aWx0SW5BY2Nlc3NvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4tYWNjZXNzb3InKTtcbnZhciBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NvcHktY29uc3RydWN0b3ItcHJvcGVydGllcycpO1xuXG52YXIgTmF0aXZlU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciBTeW1ib2xQcm90b3R5cGUgPSBOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLnByb3RvdHlwZTtcblxuaWYgKERFU0NSSVBUT1JTICYmIGlzQ2FsbGFibGUoTmF0aXZlU3ltYm9sKSAmJiAoISgnZGVzY3JpcHRpb24nIGluIFN5bWJvbFByb3RvdHlwZSkgfHxcbiAgLy8gU2FmYXJpIDEyIGJ1Z1xuICBOYXRpdmVTeW1ib2woKS5kZXNjcmlwdGlvbiAhPT0gdW5kZWZpbmVkXG4pKSB7XG4gIHZhciBFbXB0eVN0cmluZ0Rlc2NyaXB0aW9uU3RvcmUgPSB7fTtcbiAgLy8gd3JhcCBTeW1ib2wgY29uc3RydWN0b3IgZm9yIGNvcnJlY3Qgd29yayB3aXRoIHVuZGVmaW5lZCBkZXNjcmlwdGlvblxuICB2YXIgU3ltYm9sV3JhcHBlciA9IGZ1bmN0aW9uIFN5bWJvbCgpIHtcbiAgICB2YXIgZGVzY3JpcHRpb24gPSBhcmd1bWVudHMubGVuZ3RoIDwgMSB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHRvU3RyaW5nKGFyZ3VtZW50c1swXSk7XG4gICAgdmFyIHJlc3VsdCA9IGlzUHJvdG90eXBlT2YoU3ltYm9sUHJvdG90eXBlLCB0aGlzKVxuICAgICAgPyBuZXcgTmF0aXZlU3ltYm9sKGRlc2NyaXB0aW9uKVxuICAgICAgLy8gaW4gRWRnZSAxMywgU3RyaW5nKFN5bWJvbCh1bmRlZmluZWQpKSA9PT0gJ1N5bWJvbCh1bmRlZmluZWQpJ1xuICAgICAgOiBkZXNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkID8gTmF0aXZlU3ltYm9sKCkgOiBOYXRpdmVTeW1ib2woZGVzY3JpcHRpb24pO1xuICAgIGlmIChkZXNjcmlwdGlvbiA9PT0gJycpIEVtcHR5U3RyaW5nRGVzY3JpcHRpb25TdG9yZVtyZXN1bHRdID0gdHJ1ZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMoU3ltYm9sV3JhcHBlciwgTmF0aXZlU3ltYm9sKTtcbiAgU3ltYm9sV3JhcHBlci5wcm90b3R5cGUgPSBTeW1ib2xQcm90b3R5cGU7XG4gIFN5bWJvbFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN5bWJvbFdyYXBwZXI7XG5cbiAgdmFyIE5BVElWRV9TWU1CT0wgPSBTdHJpbmcoTmF0aXZlU3ltYm9sKCd0ZXN0JykpID09ICdTeW1ib2wodGVzdCknO1xuICB2YXIgdGhpc1N5bWJvbFZhbHVlID0gdW5jdXJyeVRoaXMoU3ltYm9sUHJvdG90eXBlLnZhbHVlT2YpO1xuICB2YXIgc3ltYm9sRGVzY3JpcHRpdmVTdHJpbmcgPSB1bmN1cnJ5VGhpcyhTeW1ib2xQcm90b3R5cGUudG9TdHJpbmcpO1xuICB2YXIgcmVnZXhwID0gL15TeW1ib2xcXCgoLiopXFwpW14pXSskLztcbiAgdmFyIHJlcGxhY2UgPSB1bmN1cnJ5VGhpcygnJy5yZXBsYWNlKTtcbiAgdmFyIHN0cmluZ1NsaWNlID0gdW5jdXJyeVRoaXMoJycuc2xpY2UpO1xuXG4gIGRlZmluZUJ1aWx0SW5BY2Nlc3NvcihTeW1ib2xQcm90b3R5cGUsICdkZXNjcmlwdGlvbicsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBkZXNjcmlwdGlvbigpIHtcbiAgICAgIHZhciBzeW1ib2wgPSB0aGlzU3ltYm9sVmFsdWUodGhpcyk7XG4gICAgICBpZiAoaGFzT3duKEVtcHR5U3RyaW5nRGVzY3JpcHRpb25TdG9yZSwgc3ltYm9sKSkgcmV0dXJuICcnO1xuICAgICAgdmFyIHN0cmluZyA9IHN5bWJvbERlc2NyaXB0aXZlU3RyaW5nKHN5bWJvbCk7XG4gICAgICB2YXIgZGVzYyA9IE5BVElWRV9TWU1CT0wgPyBzdHJpbmdTbGljZShzdHJpbmcsIDcsIC0xKSA6IHJlcGxhY2Uoc3RyaW5nLCByZWdleHAsICckMScpO1xuICAgICAgcmV0dXJuIGRlc2MgPT09ICcnID8gdW5kZWZpbmVkIDogZGVzYztcbiAgICB9XG4gIH0pO1xuXG4gICQoeyBnbG9iYWw6IHRydWUsIGNvbnN0cnVjdG9yOiB0cnVlLCBmb3JjZWQ6IHRydWUgfSwge1xuICAgIFN5bWJvbDogU3ltYm9sV3JhcHBlclxuICB9KTtcbn1cbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluJyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcbnZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1zdHJpbmcnKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkJyk7XG52YXIgTkFUSVZFX1NZTUJPTF9SRUdJU1RSWSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zeW1ib2wtcmVnaXN0cnktZGV0ZWN0aW9uJyk7XG5cbnZhciBTdHJpbmdUb1N5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzdHJpbmctdG8tc3ltYm9sLXJlZ2lzdHJ5Jyk7XG52YXIgU3ltYm9sVG9TdHJpbmdSZWdpc3RyeSA9IHNoYXJlZCgnc3ltYm9sLXRvLXN0cmluZy1yZWdpc3RyeScpO1xuXG4vLyBgU3ltYm9sLmZvcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5mb3JcbiQoeyB0YXJnZXQ6ICdTeW1ib2wnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6ICFOQVRJVkVfU1lNQk9MX1JFR0lTVFJZIH0sIHtcbiAgJ2Zvcic6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgc3RyaW5nID0gdG9TdHJpbmcoa2V5KTtcbiAgICBpZiAoaGFzT3duKFN0cmluZ1RvU3ltYm9sUmVnaXN0cnksIHN0cmluZykpIHJldHVybiBTdHJpbmdUb1N5bWJvbFJlZ2lzdHJ5W3N0cmluZ107XG4gICAgdmFyIHN5bWJvbCA9IGdldEJ1aWx0SW4oJ1N5bWJvbCcpKHN0cmluZyk7XG4gICAgU3RyaW5nVG9TeW1ib2xSZWdpc3RyeVtzdHJpbmddID0gc3ltYm9sO1xuICAgIFN5bWJvbFRvU3RyaW5nUmVnaXN0cnlbc3ltYm9sXSA9IHN0cmluZztcbiAgICByZXR1cm4gc3ltYm9sO1xuICB9XG59KTtcbiIsInZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wtZGVmaW5lJyk7XG5cbi8vIGBTeW1ib2wuaXRlcmF0b3JgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5pdGVyYXRvclxuZGVmaW5lV2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xuIiwiLy8gVE9ETzogUmVtb3ZlIHRoaXMgbW9kdWxlIGZyb20gYGNvcmUtanNANGAgc2luY2UgaXQncyBzcGxpdCB0byBtb2R1bGVzIGxpc3RlZCBiZWxvd1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5zeW1ib2wuY29uc3RydWN0b3InKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuc3ltYm9sLmZvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5zeW1ib2wua2V5LWZvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5qc29uLnN0cmluZ2lmeScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzJyk7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eScpO1xudmFyIGlzU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXN5bWJvbCcpO1xudmFyIHRyeVRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RyeS10by1zdHJpbmcnKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkJyk7XG52YXIgTkFUSVZFX1NZTUJPTF9SRUdJU1RSWSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zeW1ib2wtcmVnaXN0cnktZGV0ZWN0aW9uJyk7XG5cbnZhciBTeW1ib2xUb1N0cmluZ1JlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtdG8tc3RyaW5nLXJlZ2lzdHJ5Jyk7XG5cbi8vIGBTeW1ib2wua2V5Rm9yYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLmtleWZvclxuJCh7IHRhcmdldDogJ1N5bWJvbCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogIU5BVElWRV9TWU1CT0xfUkVHSVNUUlkgfSwge1xuICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihzeW0pIHtcbiAgICBpZiAoIWlzU3ltYm9sKHN5bSkpIHRocm93IFR5cGVFcnJvcih0cnlUb1N0cmluZyhzeW0pICsgJyBpcyBub3QgYSBzeW1ib2wnKTtcbiAgICBpZiAoaGFzT3duKFN5bWJvbFRvU3RyaW5nUmVnaXN0cnksIHN5bSkpIHJldHVybiBTeW1ib2xUb1N0cmluZ1JlZ2lzdHJ5W3N5bV07XG4gIH1cbn0pO1xuIiwidmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC1kZWZpbmUnKTtcbnZhciBkZWZpbmVTeW1ib2xUb1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zeW1ib2wtZGVmaW5lLXRvLXByaW1pdGl2ZScpO1xuXG4vLyBgU3ltYm9sLnRvUHJpbWl0aXZlYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wudG9wcmltaXRpdmVcbmRlZmluZVdlbGxLbm93blN5bWJvbCgndG9QcmltaXRpdmUnKTtcblxuLy8gYFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV1gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wucHJvdG90eXBlLUBAdG9wcmltaXRpdmVcbmRlZmluZVN5bWJvbFRvUHJpbWl0aXZlKCk7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIERPTUl0ZXJhYmxlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kb20taXRlcmFibGVzJyk7XG52YXIgRE9NVG9rZW5MaXN0UHJvdG90eXBlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RvbS10b2tlbi1saXN0LXByb3RvdHlwZScpO1xudmFyIEFycmF5SXRlcmF0b3JNZXRob2RzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvcicpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG52YXIgQXJyYXlWYWx1ZXMgPSBBcnJheUl0ZXJhdG9yTWV0aG9kcy52YWx1ZXM7XG5cbnZhciBoYW5kbGVQcm90b3R5cGUgPSBmdW5jdGlvbiAoQ29sbGVjdGlvblByb3RvdHlwZSwgQ09MTEVDVElPTl9OQU1FKSB7XG4gIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlKSB7XG4gICAgLy8gc29tZSBDaHJvbWUgdmVyc2lvbnMgaGF2ZSBub24tY29uZmlndXJhYmxlIG1ldGhvZHMgb24gRE9NVG9rZW5MaXN0XG4gICAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGVbSVRFUkFUT1JdICE9PSBBcnJheVZhbHVlcykgdHJ5IHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShDb2xsZWN0aW9uUHJvdG90eXBlLCBJVEVSQVRPUiwgQXJyYXlWYWx1ZXMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBDb2xsZWN0aW9uUHJvdG90eXBlW0lURVJBVE9SXSA9IEFycmF5VmFsdWVzO1xuICAgIH1cbiAgICBpZiAoIUNvbGxlY3Rpb25Qcm90b3R5cGVbVE9fU1RSSU5HX1RBR10pIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShDb2xsZWN0aW9uUHJvdG90eXBlLCBUT19TVFJJTkdfVEFHLCBDT0xMRUNUSU9OX05BTUUpO1xuICAgIH1cbiAgICBpZiAoRE9NSXRlcmFibGVzW0NPTExFQ1RJT05fTkFNRV0pIGZvciAodmFyIE1FVEhPRF9OQU1FIGluIEFycmF5SXRlcmF0b3JNZXRob2RzKSB7XG4gICAgICAvLyBzb21lIENocm9tZSB2ZXJzaW9ucyBoYXZlIG5vbi1jb25maWd1cmFibGUgbWV0aG9kcyBvbiBET01Ub2tlbkxpc3RcbiAgICAgIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlW01FVEhPRF9OQU1FXSAhPT0gQXJyYXlJdGVyYXRvck1ldGhvZHNbTUVUSE9EX05BTUVdKSB0cnkge1xuICAgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQ29sbGVjdGlvblByb3RvdHlwZSwgTUVUSE9EX05BTUUsIEFycmF5SXRlcmF0b3JNZXRob2RzW01FVEhPRF9OQU1FXSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBDb2xsZWN0aW9uUHJvdG90eXBlW01FVEhPRF9OQU1FXSA9IEFycmF5SXRlcmF0b3JNZXRob2RzW01FVEhPRF9OQU1FXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZvciAodmFyIENPTExFQ1RJT05fTkFNRSBpbiBET01JdGVyYWJsZXMpIHtcbiAgaGFuZGxlUHJvdG90eXBlKGdsb2JhbFtDT0xMRUNUSU9OX05BTUVdICYmIGdsb2JhbFtDT0xMRUNUSU9OX05BTUVdLnByb3RvdHlwZSwgQ09MTEVDVElPTl9OQU1FKTtcbn1cblxuaGFuZGxlUHJvdG90eXBlKERPTVRva2VuTGlzdFByb3RvdHlwZSwgJ0RPTVRva2VuTGlzdCcpO1xuIiwiLyoqXG4gKiBUaW55TUNFIHZlcnNpb24gNi40LjIgKDIwMjMtMDQtMjYpXG4gKi9cblxuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgdHlwZU9mJDEgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgaWYgKHggPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgIH1cbiAgICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICAgICAgfVxuICAgICAgdmFyIHQgPSB0eXBlb2YgeDtcbiAgICAgIGlmICh0ID09PSAnb2JqZWN0JyAmJiAoQXJyYXkucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoeCkgfHwgeC5jb25zdHJ1Y3RvciAmJiB4LmNvbnN0cnVjdG9yLm5hbWUgPT09ICdBcnJheScpKSB7XG4gICAgICAgIHJldHVybiAnYXJyYXknO1xuICAgICAgfVxuICAgICAgaWYgKHQgPT09ICdvYmplY3QnICYmIChTdHJpbmcucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoeCkgfHwgeC5jb25zdHJ1Y3RvciAmJiB4LmNvbnN0cnVjdG9yLm5hbWUgPT09ICdTdHJpbmcnKSkge1xuICAgICAgICByZXR1cm4gJ3N0cmluZyc7XG4gICAgICB9XG4gICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHZhciBpc0VxdWF0YWJsZVR5cGUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgJ3VuZGVmaW5lZCcsXG4gICAgICAgICdib29sZWFuJyxcbiAgICAgICAgJ251bWJlcicsXG4gICAgICAgICdzdHJpbmcnLFxuICAgICAgICAnZnVuY3Rpb24nLFxuICAgICAgICAneG1sJyxcbiAgICAgICAgJ251bGwnXG4gICAgICBdLmluZGV4T2YoeCkgIT09IC0xO1xuICAgIH07XG5cbiAgICB2YXIgc29ydCQxID0gZnVuY3Rpb24gKHhzLCBjb21wYXJlRm4pIHtcbiAgICAgIHZhciBjbG9uZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHhzKTtcbiAgICAgIHJldHVybiBjbG9uZS5zb3J0KGNvbXBhcmVGbik7XG4gICAgfTtcblxuICAgIHZhciBjb250cmFtYXAgPSBmdW5jdGlvbiAoZXFhLCBmKSB7XG4gICAgICByZXR1cm4gZXEkMihmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICByZXR1cm4gZXFhLmVxKGYoeCksIGYoeSkpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgZXEkMiA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICByZXR1cm4geyBlcTogZiB9O1xuICAgIH07XG4gICAgdmFyIHRyaXBsZUVxID0gZXEkMihmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHggPT09IHk7XG4gICAgfSk7XG4gICAgdmFyIGVxU3RyaW5nID0gdHJpcGxlRXE7XG4gICAgdmFyIGVxQXJyYXkgPSBmdW5jdGlvbiAoZXFhKSB7XG4gICAgICByZXR1cm4gZXEkMihmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICBpZiAoeC5sZW5ndGggIT09IHkubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZW4gPSB4Lmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmICghZXFhLmVxKHhbaV0sIHlbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgZXFTb3J0ZWRBcnJheSA9IGZ1bmN0aW9uIChlcWEsIGNvbXBhcmVGbikge1xuICAgICAgcmV0dXJuIGNvbnRyYW1hcChlcUFycmF5KGVxYSksIGZ1bmN0aW9uICh4cykge1xuICAgICAgICByZXR1cm4gc29ydCQxKHhzLCBjb21wYXJlRm4pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgZXFSZWNvcmQgPSBmdW5jdGlvbiAoZXFhKSB7XG4gICAgICByZXR1cm4gZXEkMihmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIga3ggPSBPYmplY3Qua2V5cyh4KTtcbiAgICAgICAgdmFyIGt5ID0gT2JqZWN0LmtleXMoeSk7XG4gICAgICAgIGlmICghZXFTb3J0ZWRBcnJheShlcVN0cmluZykuZXEoa3gsIGt5KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuID0ga3gubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIHEgPSBreFtpXTtcbiAgICAgICAgICBpZiAoIWVxYS5lcSh4W3FdLCB5W3FdKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdmFyIGVxQW55ID0gZXEkMihmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgaWYgKHggPT09IHkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgdHggPSB0eXBlT2YkMSh4KTtcbiAgICAgIHZhciB0eSA9IHR5cGVPZiQxKHkpO1xuICAgICAgaWYgKHR4ICE9PSB0eSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNFcXVhdGFibGVUeXBlKHR4KSkge1xuICAgICAgICByZXR1cm4geCA9PT0geTtcbiAgICAgIH0gZWxzZSBpZiAodHggPT09ICdhcnJheScpIHtcbiAgICAgICAgcmV0dXJuIGVxQXJyYXkoZXFBbnkpLmVxKHgsIHkpO1xuICAgICAgfSBlbHNlIGlmICh0eCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGVxUmVjb3JkKGVxQW55KS5lcSh4LCB5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGdldFByb3RvdHlwZU9mJDIgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gICAgY29uc3QgaGFzUHJvdG8gPSAodiwgY29uc3RydWN0b3IsIHByZWRpY2F0ZSkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKHByZWRpY2F0ZSh2LCBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICgoX2EgPSB2LmNvbnN0cnVjdG9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmFtZSkgPT09IGNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB0eXBlT2YgPSB4ID0+IHtcbiAgICAgIGNvbnN0IHQgPSB0eXBlb2YgeDtcbiAgICAgIGlmICh4ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKHQgPT09ICdvYmplY3QnICYmIEFycmF5LmlzQXJyYXkoeCkpIHtcbiAgICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHQgPT09ICdvYmplY3QnICYmIGhhc1Byb3RvKHgsIFN0cmluZywgKG8sIHByb3RvKSA9PiBwcm90by5pc1Byb3RvdHlwZU9mKG8pKSkge1xuICAgICAgICByZXR1cm4gJ3N0cmluZyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGlzVHlwZSQxID0gdHlwZSA9PiB2YWx1ZSA9PiB0eXBlT2YodmFsdWUpID09PSB0eXBlO1xuICAgIGNvbnN0IGlzU2ltcGxlVHlwZSA9IHR5cGUgPT4gdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSB0eXBlO1xuICAgIGNvbnN0IGVxJDEgPSB0ID0+IGEgPT4gdCA9PT0gYTtcbiAgICBjb25zdCBpcyQ0ID0gKHZhbHVlLCBjb25zdHJ1Y3RvcikgPT4gaXNPYmplY3QodmFsdWUpICYmIGhhc1Byb3RvKHZhbHVlLCBjb25zdHJ1Y3RvciwgKG8sIHByb3RvKSA9PiBnZXRQcm90b3R5cGVPZiQyKG8pID09PSBwcm90byk7XG4gICAgY29uc3QgaXNTdHJpbmcgPSBpc1R5cGUkMSgnc3RyaW5nJyk7XG4gICAgY29uc3QgaXNPYmplY3QgPSBpc1R5cGUkMSgnb2JqZWN0Jyk7XG4gICAgY29uc3QgaXNQbGFpbk9iamVjdCA9IHZhbHVlID0+IGlzJDQodmFsdWUsIE9iamVjdCk7XG4gICAgY29uc3QgaXNBcnJheSQxID0gaXNUeXBlJDEoJ2FycmF5Jyk7XG4gICAgY29uc3QgaXNOdWxsID0gZXEkMShudWxsKTtcbiAgICBjb25zdCBpc0Jvb2xlYW4gPSBpc1NpbXBsZVR5cGUoJ2Jvb2xlYW4nKTtcbiAgICBjb25zdCBpc1VuZGVmaW5lZCA9IGVxJDEodW5kZWZpbmVkKTtcbiAgICBjb25zdCBpc051bGxhYmxlID0gYSA9PiBhID09PSBudWxsIHx8IGEgPT09IHVuZGVmaW5lZDtcbiAgICBjb25zdCBpc05vbk51bGxhYmxlID0gYSA9PiAhaXNOdWxsYWJsZShhKTtcbiAgICBjb25zdCBpc0Z1bmN0aW9uID0gaXNTaW1wbGVUeXBlKCdmdW5jdGlvbicpO1xuICAgIGNvbnN0IGlzTnVtYmVyID0gaXNTaW1wbGVUeXBlKCdudW1iZXInKTtcbiAgICBjb25zdCBpc0FycmF5T2YgPSAodmFsdWUsIHByZWQpID0+IHtcbiAgICAgIGlmIChpc0FycmF5JDEodmFsdWUpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB2YWx1ZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgIGlmICghcHJlZCh2YWx1ZVtpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIGNvbnN0IG5vb3AgPSAoKSA9PiB7XG4gICAgfTtcbiAgICBjb25zdCBjb21wb3NlID0gKGZhLCBmYikgPT4ge1xuICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgIHJldHVybiBmYShmYi5hcHBseShudWxsLCBhcmdzKSk7XG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgY29tcG9zZTEgPSAoZmJjLCBmYWIpID0+IGEgPT4gZmJjKGZhYihhKSk7XG4gICAgY29uc3QgY29uc3RhbnQgPSB2YWx1ZSA9PiB7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgaWRlbnRpdHkgPSB4ID0+IHtcbiAgICAgIHJldHVybiB4O1xuICAgIH07XG4gICAgY29uc3QgdHJpcGxlRXF1YWxzID0gKGEsIGIpID0+IHtcbiAgICAgIHJldHVybiBhID09PSBiO1xuICAgIH07XG4gICAgZnVuY3Rpb24gY3VycnkoZm4sIC4uLmluaXRpYWxBcmdzKSB7XG4gICAgICByZXR1cm4gKC4uLnJlc3RBcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IGFsbCA9IGluaXRpYWxBcmdzLmNvbmNhdChyZXN0QXJncyk7XG4gICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBhbGwpO1xuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgbm90ID0gZiA9PiB0ID0+ICFmKHQpO1xuICAgIGNvbnN0IGRpZSA9IG1zZyA9PiB7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBhcHBseSQxID0gZiA9PiB7XG4gICAgICByZXR1cm4gZigpO1xuICAgIH07XG4gICAgY29uc3QgY2FsbCA9IGYgPT4ge1xuICAgICAgZigpO1xuICAgIH07XG4gICAgY29uc3QgbmV2ZXIgPSBjb25zdGFudChmYWxzZSk7XG4gICAgY29uc3QgYWx3YXlzID0gY29uc3RhbnQodHJ1ZSk7XG5cbiAgICBjbGFzcyBPcHRpb25hbCB7XG4gICAgICBjb25zdHJ1Y3Rvcih0YWcsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBzdGF0aWMgc29tZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IE9wdGlvbmFsKHRydWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHN0YXRpYyBub25lKCkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuc2luZ2xldG9uTm9uZTtcbiAgICAgIH1cbiAgICAgIGZvbGQob25Ob25lLCBvblNvbWUpIHtcbiAgICAgICAgaWYgKHRoaXMudGFnKSB7XG4gICAgICAgICAgcmV0dXJuIG9uU29tZSh0aGlzLnZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gb25Ob25lKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlzU29tZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFnO1xuICAgICAgfVxuICAgICAgaXNOb25lKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMudGFnO1xuICAgICAgfVxuICAgICAgbWFwKG1hcHBlcikge1xuICAgICAgICBpZiAodGhpcy50YWcpIHtcbiAgICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShtYXBwZXIodGhpcy52YWx1ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJpbmQoYmluZGVyKSB7XG4gICAgICAgIGlmICh0aGlzLnRhZykge1xuICAgICAgICAgIHJldHVybiBiaW5kZXIodGhpcy52YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZXhpc3RzKHByZWRpY2F0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50YWcgJiYgcHJlZGljYXRlKHRoaXMudmFsdWUpO1xuICAgICAgfVxuICAgICAgZm9yYWxsKHByZWRpY2F0ZSkge1xuICAgICAgICByZXR1cm4gIXRoaXMudGFnIHx8IHByZWRpY2F0ZSh0aGlzLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGZpbHRlcihwcmVkaWNhdGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRhZyB8fCBwcmVkaWNhdGUodGhpcy52YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBnZXRPcihyZXBsYWNlbWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YWcgPyB0aGlzLnZhbHVlIDogcmVwbGFjZW1lbnQ7XG4gICAgICB9XG4gICAgICBvcihyZXBsYWNlbWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YWcgPyB0aGlzIDogcmVwbGFjZW1lbnQ7XG4gICAgICB9XG4gICAgICBnZXRPclRodW5rKHRodW5rKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhZyA/IHRoaXMudmFsdWUgOiB0aHVuaygpO1xuICAgICAgfVxuICAgICAgb3JUaHVuayh0aHVuaykge1xuICAgICAgICByZXR1cm4gdGhpcy50YWcgPyB0aGlzIDogdGh1bmsoKTtcbiAgICAgIH1cbiAgICAgIGdldE9yRGllKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRhZykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiAnQ2FsbGVkIGdldE9yRGllIG9uIE5vbmUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhdGljIGZyb20odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzTm9uTnVsbGFibGUodmFsdWUpID8gT3B0aW9uYWwuc29tZSh2YWx1ZSkgOiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9XG4gICAgICBnZXRPck51bGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhZyA/IHRoaXMudmFsdWUgOiBudWxsO1xuICAgICAgfVxuICAgICAgZ2V0T3JVbmRlZmluZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgICAgfVxuICAgICAgZWFjaCh3b3JrZXIpIHtcbiAgICAgICAgaWYgKHRoaXMudGFnKSB7XG4gICAgICAgICAgd29ya2VyKHRoaXMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0b0FycmF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YWcgPyBbdGhpcy52YWx1ZV0gOiBbXTtcbiAgICAgIH1cbiAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YWcgPyBgc29tZSgkeyB0aGlzLnZhbHVlIH0pYCA6ICdub25lKCknO1xuICAgICAgfVxuICAgIH1cbiAgICBPcHRpb25hbC5zaW5nbGV0b25Ob25lID0gbmV3IE9wdGlvbmFsKGZhbHNlKTtcblxuICAgIGNvbnN0IG5hdGl2ZVNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuICAgIGNvbnN0IG5hdGl2ZUluZGV4T2YgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZjtcbiAgICBjb25zdCBuYXRpdmVQdXNoID0gQXJyYXkucHJvdG90eXBlLnB1c2g7XG4gICAgY29uc3QgcmF3SW5kZXhPZiA9ICh0cywgdCkgPT4gbmF0aXZlSW5kZXhPZi5jYWxsKHRzLCB0KTtcbiAgICBjb25zdCBpbmRleE9mJDEgPSAoeHMsIHgpID0+IHtcbiAgICAgIGNvbnN0IHIgPSByYXdJbmRleE9mKHhzLCB4KTtcbiAgICAgIHJldHVybiByID09PSAtMSA/IE9wdGlvbmFsLm5vbmUoKSA6IE9wdGlvbmFsLnNvbWUocik7XG4gICAgfTtcbiAgICBjb25zdCBjb250YWlucyQyID0gKHhzLCB4KSA9PiByYXdJbmRleE9mKHhzLCB4KSA+IC0xO1xuICAgIGNvbnN0IGV4aXN0cyA9ICh4cywgcHJlZCkgPT4ge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHhzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHggPSB4c1tpXTtcbiAgICAgICAgaWYgKHByZWQoeCwgaSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgY29uc3QgbWFwJDMgPSAoeHMsIGYpID0+IHtcbiAgICAgIGNvbnN0IGxlbiA9IHhzLmxlbmd0aDtcbiAgICAgIGNvbnN0IHIgPSBuZXcgQXJyYXkobGVuKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgeCA9IHhzW2ldO1xuICAgICAgICByW2ldID0gZih4LCBpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgY29uc3QgZWFjaCRlID0gKHhzLCBmKSA9PiB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0geHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgeCA9IHhzW2ldO1xuICAgICAgICBmKHgsIGkpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZWFjaHIgPSAoeHMsIGYpID0+IHtcbiAgICAgIGZvciAobGV0IGkgPSB4cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCB4ID0geHNbaV07XG4gICAgICAgIGYoeCwgaSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBwYXJ0aXRpb24kMiA9ICh4cywgcHJlZCkgPT4ge1xuICAgICAgY29uc3QgcGFzcyA9IFtdO1xuICAgICAgY29uc3QgZmFpbCA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHhzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHggPSB4c1tpXTtcbiAgICAgICAgY29uc3QgYXJyID0gcHJlZCh4LCBpKSA/IHBhc3MgOiBmYWlsO1xuICAgICAgICBhcnIucHVzaCh4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhc3MsXG4gICAgICAgIGZhaWxcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBmaWx0ZXIkNSA9ICh4cywgcHJlZCkgPT4ge1xuICAgICAgY29uc3QgciA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHhzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHggPSB4c1tpXTtcbiAgICAgICAgaWYgKHByZWQoeCwgaSkpIHtcbiAgICAgICAgICByLnB1c2goeCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgY29uc3QgZm9sZHIgPSAoeHMsIGYsIGFjYykgPT4ge1xuICAgICAgZWFjaHIoeHMsICh4LCBpKSA9PiB7XG4gICAgICAgIGFjYyA9IGYoYWNjLCB4LCBpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9O1xuICAgIGNvbnN0IGZvbGRsID0gKHhzLCBmLCBhY2MpID0+IHtcbiAgICAgIGVhY2gkZSh4cywgKHgsIGkpID0+IHtcbiAgICAgICAgYWNjID0gZihhY2MsIHgsIGkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH07XG4gICAgY29uc3QgZmluZFVudGlsJDEgPSAoeHMsIHByZWQsIHVudGlsKSA9PiB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0geHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgeCA9IHhzW2ldO1xuICAgICAgICBpZiAocHJlZCh4LCBpKSkge1xuICAgICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKHgpO1xuICAgICAgICB9IGVsc2UgaWYgKHVudGlsKHgsIGkpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgfTtcbiAgICBjb25zdCBmaW5kJDIgPSAoeHMsIHByZWQpID0+IHtcbiAgICAgIHJldHVybiBmaW5kVW50aWwkMSh4cywgcHJlZCwgbmV2ZXIpO1xuICAgIH07XG4gICAgY29uc3QgZmluZEluZGV4JDIgPSAoeHMsIHByZWQpID0+IHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB4cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCB4ID0geHNbaV07XG4gICAgICAgIGlmIChwcmVkKHgsIGkpKSB7XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgfTtcbiAgICBjb25zdCBmbGF0dGVuID0geHMgPT4ge1xuICAgICAgY29uc3QgciA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHhzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGlmICghaXNBcnJheSQxKHhzW2ldKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXJyLmZsYXR0ZW4gaXRlbSAnICsgaSArICcgd2FzIG5vdCBhbiBhcnJheSwgaW5wdXQ6ICcgKyB4cyk7XG4gICAgICAgIH1cbiAgICAgICAgbmF0aXZlUHVzaC5hcHBseShyLCB4c1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIGNvbnN0IGJpbmQkMyA9ICh4cywgZikgPT4gZmxhdHRlbihtYXAkMyh4cywgZikpO1xuICAgIGNvbnN0IGZvcmFsbCA9ICh4cywgcHJlZCkgPT4ge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHhzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGNvbnN0IHggPSB4c1tpXTtcbiAgICAgICAgaWYgKHByZWQoeCwgaSkgIT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgY29uc3QgcmV2ZXJzZSA9IHhzID0+IHtcbiAgICAgIGNvbnN0IHIgPSBuYXRpdmVTbGljZS5jYWxsKHhzLCAwKTtcbiAgICAgIHIucmV2ZXJzZSgpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICBjb25zdCBkaWZmZXJlbmNlID0gKGExLCBhMikgPT4gZmlsdGVyJDUoYTEsIHggPT4gIWNvbnRhaW5zJDIoYTIsIHgpKTtcbiAgICBjb25zdCBtYXBUb09iamVjdCA9ICh4cywgZikgPT4ge1xuICAgICAgY29uc3QgciA9IHt9O1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHhzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHggPSB4c1tpXTtcbiAgICAgICAgcltTdHJpbmcoeCldID0gZih4LCBpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgY29uc3Qgc29ydCA9ICh4cywgY29tcGFyYXRvcikgPT4ge1xuICAgICAgY29uc3QgY29weSA9IG5hdGl2ZVNsaWNlLmNhbGwoeHMsIDApO1xuICAgICAgY29weS5zb3J0KGNvbXBhcmF0b3IpO1xuICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfTtcbiAgICBjb25zdCBnZXQkYiA9ICh4cywgaSkgPT4gaSA+PSAwICYmIGkgPCB4cy5sZW5ndGggPyBPcHRpb25hbC5zb21lKHhzW2ldKSA6IE9wdGlvbmFsLm5vbmUoKTtcbiAgICBjb25zdCBoZWFkID0geHMgPT4gZ2V0JGIoeHMsIDApO1xuICAgIGNvbnN0IGxhc3QkMyA9IHhzID0+IGdldCRiKHhzLCB4cy5sZW5ndGggLSAxKTtcbiAgICBjb25zdCBmcm9tID0gaXNGdW5jdGlvbihBcnJheS5mcm9tKSA/IEFycmF5LmZyb20gOiB4ID0+IG5hdGl2ZVNsaWNlLmNhbGwoeCk7XG4gICAgY29uc3QgZmluZE1hcCA9IChhcnIsIGYpID0+IHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHIgPSBmKGFycltpXSwgaSk7XG4gICAgICAgIGlmIChyLmlzU29tZSgpKSB7XG4gICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgfTtcbiAgICBjb25zdCB1bmlxdWUkMSA9ICh4cywgY29tcGFyYXRvcikgPT4ge1xuICAgICAgY29uc3QgciA9IFtdO1xuICAgICAgY29uc3QgaXNEdXBsaWNhdGVkID0gaXNGdW5jdGlvbihjb21wYXJhdG9yKSA/IHggPT4gZXhpc3RzKHIsIGkgPT4gY29tcGFyYXRvcihpLCB4KSkgOiB4ID0+IGNvbnRhaW5zJDIociwgeCk7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0geHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgeCA9IHhzW2ldO1xuICAgICAgICBpZiAoIWlzRHVwbGljYXRlZCh4KSkge1xuICAgICAgICAgIHIucHVzaCh4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfTtcblxuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cztcbiAgICBjb25zdCBoYXNPd25Qcm9wZXJ0eSQyID0gT2JqZWN0Lmhhc093blByb3BlcnR5O1xuICAgIGNvbnN0IGVhY2gkZCA9IChvYmosIGYpID0+IHtcbiAgICAgIGNvbnN0IHByb3BzID0ga2V5cyhvYmopO1xuICAgICAgZm9yIChsZXQgayA9IDAsIGxlbiA9IHByb3BzLmxlbmd0aDsgayA8IGxlbjsgaysrKSB7XG4gICAgICAgIGNvbnN0IGkgPSBwcm9wc1trXTtcbiAgICAgICAgY29uc3QgeCA9IG9ialtpXTtcbiAgICAgICAgZih4LCBpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG1hcCQyID0gKG9iaiwgZikgPT4ge1xuICAgICAgcmV0dXJuIHR1cGxlTWFwKG9iaiwgKHgsIGkpID0+ICh7XG4gICAgICAgIGs6IGksXG4gICAgICAgIHY6IGYoeCwgaSlcbiAgICAgIH0pKTtcbiAgICB9O1xuICAgIGNvbnN0IHR1cGxlTWFwID0gKG9iaiwgZikgPT4ge1xuICAgICAgY29uc3QgciA9IHt9O1xuICAgICAgZWFjaCRkKG9iaiwgKHgsIGkpID0+IHtcbiAgICAgICAgY29uc3QgdHVwbGUgPSBmKHgsIGkpO1xuICAgICAgICByW3R1cGxlLmtdID0gdHVwbGUudjtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICBjb25zdCBvYmpBY2MgPSByID0+ICh4LCBpKSA9PiB7XG4gICAgICByW2ldID0geDtcbiAgICB9O1xuICAgIGNvbnN0IGludGVybmFsRmlsdGVyID0gKG9iaiwgcHJlZCwgb25UcnVlLCBvbkZhbHNlKSA9PiB7XG4gICAgICBlYWNoJGQob2JqLCAoeCwgaSkgPT4ge1xuICAgICAgICAocHJlZCh4LCBpKSA/IG9uVHJ1ZSA6IG9uRmFsc2UpKHgsIGkpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBiaWZpbHRlciA9IChvYmosIHByZWQpID0+IHtcbiAgICAgIGNvbnN0IHQgPSB7fTtcbiAgICAgIGNvbnN0IGYgPSB7fTtcbiAgICAgIGludGVybmFsRmlsdGVyKG9iaiwgcHJlZCwgb2JqQWNjKHQpLCBvYmpBY2MoZikpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdCxcbiAgICAgICAgZlxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGZpbHRlciQ0ID0gKG9iaiwgcHJlZCkgPT4ge1xuICAgICAgY29uc3QgdCA9IHt9O1xuICAgICAgaW50ZXJuYWxGaWx0ZXIob2JqLCBwcmVkLCBvYmpBY2ModCksIG5vb3ApO1xuICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICBjb25zdCBtYXBUb0FycmF5ID0gKG9iaiwgZikgPT4ge1xuICAgICAgY29uc3QgciA9IFtdO1xuICAgICAgZWFjaCRkKG9iaiwgKHZhbHVlLCBuYW1lKSA9PiB7XG4gICAgICAgIHIucHVzaChmKHZhbHVlLCBuYW1lKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgY29uc3QgdmFsdWVzID0gb2JqID0+IHtcbiAgICAgIHJldHVybiBtYXBUb0FycmF5KG9iaiwgaWRlbnRpdHkpO1xuICAgIH07XG4gICAgY29uc3QgZ2V0JGEgPSAob2JqLCBrZXkpID0+IHtcbiAgICAgIHJldHVybiBoYXMkMihvYmosIGtleSkgPyBPcHRpb25hbC5mcm9tKG9ialtrZXldKSA6IE9wdGlvbmFsLm5vbmUoKTtcbiAgICB9O1xuICAgIGNvbnN0IGhhcyQyID0gKG9iaiwga2V5KSA9PiBoYXNPd25Qcm9wZXJ0eSQyLmNhbGwob2JqLCBrZXkpO1xuICAgIGNvbnN0IGhhc05vbk51bGxhYmxlS2V5ID0gKG9iaiwga2V5KSA9PiBoYXMkMihvYmosIGtleSkgJiYgb2JqW2tleV0gIT09IHVuZGVmaW5lZCAmJiBvYmpba2V5XSAhPT0gbnVsbDtcbiAgICBjb25zdCBlcXVhbCQxID0gKGExLCBhMiwgZXEgPSBlcUFueSkgPT4gZXFSZWNvcmQoZXEpLmVxKGExLCBhMik7XG5cbiAgICBjb25zdCBzdHJpbmdBcnJheSA9IGEgPT4ge1xuICAgICAgY29uc3QgYWxsID0ge307XG4gICAgICBlYWNoJGUoYSwga2V5ID0+IHtcbiAgICAgICAgYWxsW2tleV0gPSB7fTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGtleXMoYWxsKTtcbiAgICB9O1xuXG4gICAgY29uc3QgaXNBcnJheUxpa2UgPSBvID0+IG8ubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG4gICAgY29uc3QgdG9BcnJheSQxID0gb2JqID0+IHtcbiAgICAgIGlmICghaXNBcnJheShvYmopKSB7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGFycmF5W2ldID0gb2JqW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBlYWNoJGMgPSAobywgY2IsIHMpID0+IHtcbiAgICAgIGlmICghbykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBzID0gcyB8fCBvO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlKG8pKSB7XG4gICAgICAgIGZvciAobGV0IG4gPSAwLCBsID0gby5sZW5ndGg7IG4gPCBsOyBuKyspIHtcbiAgICAgICAgICBpZiAoY2IuY2FsbChzLCBvW25dLCBuLCBvKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3QgbiBpbiBvKSB7XG4gICAgICAgICAgaWYgKGhhcyQyKG8sIG4pKSB7XG4gICAgICAgICAgICBpZiAoY2IuY2FsbChzLCBvW25dLCBuLCBvKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBjb25zdCBtYXAkMSA9IChhcnJheSwgY2FsbGJhY2spID0+IHtcbiAgICAgIGNvbnN0IG91dCA9IFtdO1xuICAgICAgZWFjaCRjKGFycmF5LCAoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgb3V0LnB1c2goY2FsbGJhY2soaXRlbSwgaW5kZXgsIGFycmF5KSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICBjb25zdCBmaWx0ZXIkMyA9IChhLCBmKSA9PiB7XG4gICAgICBjb25zdCBvID0gW107XG4gICAgICBlYWNoJGMoYSwgKHYsIGluZGV4KSA9PiB7XG4gICAgICAgIGlmICghZiB8fCBmKHYsIGluZGV4LCBhKSkge1xuICAgICAgICAgIG8ucHVzaCh2KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIGNvbnN0IGluZGV4T2YgPSAoYSwgdikgPT4ge1xuICAgICAgaWYgKGEpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGlmIChhW2ldID09PSB2KSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICAgIGNvbnN0IHJlZHVjZSA9IChjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIHRoaXNBcmcpID0+IHtcbiAgICAgIGxldCBhY2MgPSBpc1VuZGVmaW5lZChhY2N1bXVsYXRvcikgPyBjb2xsZWN0aW9uWzBdIDogYWNjdW11bGF0b3I7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbGxlY3Rpb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYWNjID0gaXRlcmF0ZWUuY2FsbCh0aGlzQXJnLCBhY2MsIGNvbGxlY3Rpb25baV0sIGkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9O1xuICAgIGNvbnN0IGZpbmRJbmRleCQxID0gKGFycmF5LCBwcmVkaWNhdGUsIHRoaXNBcmcpID0+IHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUuY2FsbCh0aGlzQXJnLCBhcnJheVtpXSwgaSwgYXJyYXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICAgIGNvbnN0IGxhc3QkMiA9IGNvbGxlY3Rpb24gPT4gY29sbGVjdGlvbltjb2xsZWN0aW9uLmxlbmd0aCAtIDFdO1xuXG4gICAgY29uc3QgY2FjaGVkID0gZiA9PiB7XG4gICAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gICAgICBsZXQgcjtcbiAgICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgciA9IGYuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBEZXZpY2VUeXBlID0gKG9zLCBicm93c2VyLCB1c2VyQWdlbnQsIG1lZGlhTWF0Y2gpID0+IHtcbiAgICAgIGNvbnN0IGlzaVBhZCA9IG9zLmlzaU9TKCkgJiYgL2lwYWQvaS50ZXN0KHVzZXJBZ2VudCkgPT09IHRydWU7XG4gICAgICBjb25zdCBpc2lQaG9uZSA9IG9zLmlzaU9TKCkgJiYgIWlzaVBhZDtcbiAgICAgIGNvbnN0IGlzTW9iaWxlID0gb3MuaXNpT1MoKSB8fCBvcy5pc0FuZHJvaWQoKTtcbiAgICAgIGNvbnN0IGlzVG91Y2ggPSBpc01vYmlsZSB8fCBtZWRpYU1hdGNoKCcocG9pbnRlcjpjb2Fyc2UpJyk7XG4gICAgICBjb25zdCBpc1RhYmxldCA9IGlzaVBhZCB8fCAhaXNpUGhvbmUgJiYgaXNNb2JpbGUgJiYgbWVkaWFNYXRjaCgnKG1pbi1kZXZpY2Utd2lkdGg6NzY4cHgpJyk7XG4gICAgICBjb25zdCBpc1Bob25lID0gaXNpUGhvbmUgfHwgaXNNb2JpbGUgJiYgIWlzVGFibGV0O1xuICAgICAgY29uc3QgaU9Td2VidmlldyA9IGJyb3dzZXIuaXNTYWZhcmkoKSAmJiBvcy5pc2lPUygpICYmIC9zYWZhcmkvaS50ZXN0KHVzZXJBZ2VudCkgPT09IGZhbHNlO1xuICAgICAgY29uc3QgaXNEZXNrdG9wID0gIWlzUGhvbmUgJiYgIWlzVGFibGV0ICYmICFpT1N3ZWJ2aWV3O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNpUGFkOiBjb25zdGFudChpc2lQYWQpLFxuICAgICAgICBpc2lQaG9uZTogY29uc3RhbnQoaXNpUGhvbmUpLFxuICAgICAgICBpc1RhYmxldDogY29uc3RhbnQoaXNUYWJsZXQpLFxuICAgICAgICBpc1Bob25lOiBjb25zdGFudChpc1Bob25lKSxcbiAgICAgICAgaXNUb3VjaDogY29uc3RhbnQoaXNUb3VjaCksXG4gICAgICAgIGlzQW5kcm9pZDogb3MuaXNBbmRyb2lkLFxuICAgICAgICBpc2lPUzogb3MuaXNpT1MsXG4gICAgICAgIGlzV2ViVmlldzogY29uc3RhbnQoaU9Td2VidmlldyksXG4gICAgICAgIGlzRGVza3RvcDogY29uc3RhbnQoaXNEZXNrdG9wKVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgZmlyc3RNYXRjaCA9IChyZWdleGVzLCBzKSA9PiB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlZ2V4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgeCA9IHJlZ2V4ZXNbaV07XG4gICAgICAgIGlmICh4LnRlc3QocykpIHtcbiAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIGNvbnN0IGZpbmQkMSA9IChyZWdleGVzLCBhZ2VudCkgPT4ge1xuICAgICAgY29uc3QgciA9IGZpcnN0TWF0Y2gocmVnZXhlcywgYWdlbnQpO1xuICAgICAgaWYgKCFyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWFqb3I6IDAsXG4gICAgICAgICAgbWlub3I6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGdyb3VwID0gaSA9PiB7XG4gICAgICAgIHJldHVybiBOdW1iZXIoYWdlbnQucmVwbGFjZShyLCAnJCcgKyBpKSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIG51JDMoZ3JvdXAoMSksIGdyb3VwKDIpKTtcbiAgICB9O1xuICAgIGNvbnN0IGRldGVjdCQ1ID0gKHZlcnNpb25SZWdleGVzLCBhZ2VudCkgPT4ge1xuICAgICAgY29uc3QgY2xlYW5lZEFnZW50ID0gU3RyaW5nKGFnZW50KS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKHZlcnNpb25SZWdleGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdW5rbm93biQyKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmluZCQxKHZlcnNpb25SZWdleGVzLCBjbGVhbmVkQWdlbnQpO1xuICAgIH07XG4gICAgY29uc3QgdW5rbm93biQyID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIG51JDMoMCwgMCk7XG4gICAgfTtcbiAgICBjb25zdCBudSQzID0gKG1ham9yLCBtaW5vcikgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWFqb3IsXG4gICAgICAgIG1pbm9yXG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgVmVyc2lvbiA9IHtcbiAgICAgIG51OiBudSQzLFxuICAgICAgZGV0ZWN0OiBkZXRlY3QkNSxcbiAgICAgIHVua25vd246IHVua25vd24kMlxuICAgIH07XG5cbiAgICBjb25zdCBkZXRlY3RCcm93c2VyJDEgPSAoYnJvd3NlcnMsIHVzZXJBZ2VudERhdGEpID0+IHtcbiAgICAgIHJldHVybiBmaW5kTWFwKHVzZXJBZ2VudERhdGEuYnJhbmRzLCB1YUJyYW5kID0+IHtcbiAgICAgICAgY29uc3QgbGNCcmFuZCA9IHVhQnJhbmQuYnJhbmQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIGZpbmQkMihicm93c2VycywgYnJvd3NlciA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIHJldHVybiBsY0JyYW5kID09PSAoKF9hID0gYnJvd3Nlci5icmFuZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICB9KS5tYXAoaW5mbyA9PiAoe1xuICAgICAgICAgIGN1cnJlbnQ6IGluZm8ubmFtZSxcbiAgICAgICAgICB2ZXJzaW9uOiBWZXJzaW9uLm51KHBhcnNlSW50KHVhQnJhbmQudmVyc2lvbiwgMTApLCAwKVxuICAgICAgICB9KSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgZGV0ZWN0JDQgPSAoY2FuZGlkYXRlcywgdXNlckFnZW50KSA9PiB7XG4gICAgICBjb25zdCBhZ2VudCA9IFN0cmluZyh1c2VyQWdlbnQpLnRvTG93ZXJDYXNlKCk7XG4gICAgICByZXR1cm4gZmluZCQyKGNhbmRpZGF0ZXMsIGNhbmRpZGF0ZSA9PiB7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUuc2VhcmNoKGFnZW50KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgZGV0ZWN0QnJvd3NlciA9IChicm93c2VycywgdXNlckFnZW50KSA9PiB7XG4gICAgICByZXR1cm4gZGV0ZWN0JDQoYnJvd3NlcnMsIHVzZXJBZ2VudCkubWFwKGJyb3dzZXIgPT4ge1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gVmVyc2lvbi5kZXRlY3QoYnJvd3Nlci52ZXJzaW9uUmVnZXhlcywgdXNlckFnZW50KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjdXJyZW50OiBicm93c2VyLm5hbWUsXG4gICAgICAgICAgdmVyc2lvblxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBkZXRlY3RPcyA9IChvc2VzLCB1c2VyQWdlbnQpID0+IHtcbiAgICAgIHJldHVybiBkZXRlY3QkNChvc2VzLCB1c2VyQWdlbnQpLm1hcChvcyA9PiB7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSBWZXJzaW9uLmRldGVjdChvcy52ZXJzaW9uUmVnZXhlcywgdXNlckFnZW50KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjdXJyZW50OiBvcy5uYW1lLFxuICAgICAgICAgIHZlcnNpb25cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCByZW1vdmVGcm9tU3RhcnQgPSAoc3RyLCBudW1DaGFycykgPT4ge1xuICAgICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcobnVtQ2hhcnMpO1xuICAgIH07XG5cbiAgICBjb25zdCBjaGVja1JhbmdlID0gKHN0ciwgc3Vic3RyLCBzdGFydCkgPT4gc3Vic3RyID09PSAnJyB8fCBzdHIubGVuZ3RoID49IHN1YnN0ci5sZW5ndGggJiYgc3RyLnN1YnN0cihzdGFydCwgc3RhcnQgKyBzdWJzdHIubGVuZ3RoKSA9PT0gc3Vic3RyO1xuICAgIGNvbnN0IHJlbW92ZUxlYWRpbmcgPSAoc3RyLCBwcmVmaXgpID0+IHtcbiAgICAgIHJldHVybiBzdGFydHNXaXRoKHN0ciwgcHJlZml4KSA/IHJlbW92ZUZyb21TdGFydChzdHIsIHByZWZpeC5sZW5ndGgpIDogc3RyO1xuICAgIH07XG4gICAgY29uc3QgY29udGFpbnMkMSA9IChzdHIsIHN1YnN0ciwgc3RhcnQgPSAwLCBlbmQpID0+IHtcbiAgICAgIGNvbnN0IGlkeCA9IHN0ci5pbmRleE9mKHN1YnN0ciwgc3RhcnQpO1xuICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGlzVW5kZWZpbmVkKGVuZCkgPyB0cnVlIDogaWR4ICsgc3Vic3RyLmxlbmd0aCA8PSBlbmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzdGFydHNXaXRoID0gKHN0ciwgcHJlZml4KSA9PiB7XG4gICAgICByZXR1cm4gY2hlY2tSYW5nZShzdHIsIHByZWZpeCwgMCk7XG4gICAgfTtcbiAgICBjb25zdCBlbmRzV2l0aCA9IChzdHIsIHN1ZmZpeCkgPT4ge1xuICAgICAgcmV0dXJuIGNoZWNrUmFuZ2Uoc3RyLCBzdWZmaXgsIHN0ci5sZW5ndGggLSBzdWZmaXgubGVuZ3RoKTtcbiAgICB9O1xuICAgIGNvbnN0IGJsYW5rID0gciA9PiBzID0+IHMucmVwbGFjZShyLCAnJyk7XG4gICAgY29uc3QgdHJpbSQzID0gYmxhbmsoL15cXHMrfFxccyskL2cpO1xuICAgIGNvbnN0IGxUcmltID0gYmxhbmsoL15cXHMrL2cpO1xuICAgIGNvbnN0IHJUcmltID0gYmxhbmsoL1xccyskL2cpO1xuICAgIGNvbnN0IGlzTm90RW1wdHkgPSBzID0+IHMubGVuZ3RoID4gMDtcbiAgICBjb25zdCBpc0VtcHR5JDMgPSBzID0+ICFpc05vdEVtcHR5KHMpO1xuICAgIGNvbnN0IHJlcGVhdCA9IChzLCBjb3VudCkgPT4gY291bnQgPD0gMCA/ICcnIDogbmV3IEFycmF5KGNvdW50ICsgMSkuam9pbihzKTtcbiAgICBjb25zdCB0b0ludCA9ICh2YWx1ZSwgcmFkaXggPSAxMCkgPT4ge1xuICAgICAgY29uc3QgbnVtID0gcGFyc2VJbnQodmFsdWUsIHJhZGl4KTtcbiAgICAgIHJldHVybiBpc05hTihudW0pID8gT3B0aW9uYWwubm9uZSgpIDogT3B0aW9uYWwuc29tZShudW0pO1xuICAgIH07XG5cbiAgICBjb25zdCBub3JtYWxWZXJzaW9uUmVnZXggPSAvLio/dmVyc2lvblxcL1xcID8oWzAtOV0rKVxcLihbMC05XSspLiovO1xuICAgIGNvbnN0IGNoZWNrQ29udGFpbnMgPSB0YXJnZXQgPT4ge1xuICAgICAgcmV0dXJuIHVhc3RyaW5nID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5zJDEodWFzdHJpbmcsIHRhcmdldCk7XG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgYnJvd3NlcnMgPSBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdFZGdlJyxcbiAgICAgICAgdmVyc2lvblJlZ2V4ZXM6IFsvLio/ZWRnZVxcLyA/KFswLTldKylcXC4oWzAtOV0rKSQvXSxcbiAgICAgICAgc2VhcmNoOiB1YXN0cmluZyA9PiB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRhaW5zJDEodWFzdHJpbmcsICdlZGdlLycpICYmIGNvbnRhaW5zJDEodWFzdHJpbmcsICdjaHJvbWUnKSAmJiBjb250YWlucyQxKHVhc3RyaW5nLCAnc2FmYXJpJykgJiYgY29udGFpbnMkMSh1YXN0cmluZywgJ2FwcGxld2Via2l0Jyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdDaHJvbWl1bScsXG4gICAgICAgIGJyYW5kOiAnQ2hyb21pdW0nLFxuICAgICAgICB2ZXJzaW9uUmVnZXhlczogW1xuICAgICAgICAgIC8uKj9jaHJvbWVcXC8oWzAtOV0rKVxcLihbMC05XSspLiovLFxuICAgICAgICAgIG5vcm1hbFZlcnNpb25SZWdleFxuICAgICAgICBdLFxuICAgICAgICBzZWFyY2g6IHVhc3RyaW5nID0+IHtcbiAgICAgICAgICByZXR1cm4gY29udGFpbnMkMSh1YXN0cmluZywgJ2Nocm9tZScpICYmICFjb250YWlucyQxKHVhc3RyaW5nLCAnY2hyb21lZnJhbWUnKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ0lFJyxcbiAgICAgICAgdmVyc2lvblJlZ2V4ZXM6IFtcbiAgICAgICAgICAvLio/bXNpZVxcID8oWzAtOV0rKVxcLihbMC05XSspLiovLFxuICAgICAgICAgIC8uKj9ydjooWzAtOV0rKVxcLihbMC05XSspLiovXG4gICAgICAgIF0sXG4gICAgICAgIHNlYXJjaDogdWFzdHJpbmcgPT4ge1xuICAgICAgICAgIHJldHVybiBjb250YWlucyQxKHVhc3RyaW5nLCAnbXNpZScpIHx8IGNvbnRhaW5zJDEodWFzdHJpbmcsICd0cmlkZW50Jyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdPcGVyYScsXG4gICAgICAgIHZlcnNpb25SZWdleGVzOiBbXG4gICAgICAgICAgbm9ybWFsVmVyc2lvblJlZ2V4LFxuICAgICAgICAgIC8uKj9vcGVyYVxcLyhbMC05XSspXFwuKFswLTldKykuKi9cbiAgICAgICAgXSxcbiAgICAgICAgc2VhcmNoOiBjaGVja0NvbnRhaW5zKCdvcGVyYScpXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAnRmlyZWZveCcsXG4gICAgICAgIHZlcnNpb25SZWdleGVzOiBbLy4qP2ZpcmVmb3hcXC9cXCA/KFswLTldKylcXC4oWzAtOV0rKS4qL10sXG4gICAgICAgIHNlYXJjaDogY2hlY2tDb250YWlucygnZmlyZWZveCcpXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAnU2FmYXJpJyxcbiAgICAgICAgdmVyc2lvblJlZ2V4ZXM6IFtcbiAgICAgICAgICBub3JtYWxWZXJzaW9uUmVnZXgsXG4gICAgICAgICAgLy4qP2NwdSBvcyAoWzAtOV0rKV8oWzAtOV0rKS4qL1xuICAgICAgICBdLFxuICAgICAgICBzZWFyY2g6IHVhc3RyaW5nID0+IHtcbiAgICAgICAgICByZXR1cm4gKGNvbnRhaW5zJDEodWFzdHJpbmcsICdzYWZhcmknKSB8fCBjb250YWlucyQxKHVhc3RyaW5nLCAnbW9iaWxlLycpKSAmJiBjb250YWlucyQxKHVhc3RyaW5nLCAnYXBwbGV3ZWJraXQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF07XG4gICAgY29uc3Qgb3NlcyA9IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ1dpbmRvd3MnLFxuICAgICAgICBzZWFyY2g6IGNoZWNrQ29udGFpbnMoJ3dpbicpLFxuICAgICAgICB2ZXJzaW9uUmVnZXhlczogWy8uKj93aW5kb3dzXFwgbnRcXCA/KFswLTldKylcXC4oWzAtOV0rKS4qL11cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdpT1MnLFxuICAgICAgICBzZWFyY2g6IHVhc3RyaW5nID0+IHtcbiAgICAgICAgICByZXR1cm4gY29udGFpbnMkMSh1YXN0cmluZywgJ2lwaG9uZScpIHx8IGNvbnRhaW5zJDEodWFzdHJpbmcsICdpcGFkJyk7XG4gICAgICAgIH0sXG4gICAgICAgIHZlcnNpb25SZWdleGVzOiBbXG4gICAgICAgICAgLy4qP3ZlcnNpb25cXC9cXCA/KFswLTldKylcXC4oWzAtOV0rKS4qLyxcbiAgICAgICAgICAvLipjcHUgb3MgKFswLTldKylfKFswLTldKykuKi8sXG4gICAgICAgICAgLy4qY3B1IGlwaG9uZSBvcyAoWzAtOV0rKV8oWzAtOV0rKS4qL1xuICAgICAgICBdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAnQW5kcm9pZCcsXG4gICAgICAgIHNlYXJjaDogY2hlY2tDb250YWlucygnYW5kcm9pZCcpLFxuICAgICAgICB2ZXJzaW9uUmVnZXhlczogWy8uKj9hbmRyb2lkXFwgPyhbMC05XSspXFwuKFswLTldKykuKi9dXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAnbWFjT1MnLFxuICAgICAgICBzZWFyY2g6IGNoZWNrQ29udGFpbnMoJ21hYyBvcyB4JyksXG4gICAgICAgIHZlcnNpb25SZWdleGVzOiBbLy4qP21hY1xcIG9zXFwgeFxcID8oWzAtOV0rKV8oWzAtOV0rKS4qL11cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdMaW51eCcsXG4gICAgICAgIHNlYXJjaDogY2hlY2tDb250YWlucygnbGludXgnKSxcbiAgICAgICAgdmVyc2lvblJlZ2V4ZXM6IFtdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAnU29sYXJpcycsXG4gICAgICAgIHNlYXJjaDogY2hlY2tDb250YWlucygnc3Vub3MnKSxcbiAgICAgICAgdmVyc2lvblJlZ2V4ZXM6IFtdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAnRnJlZUJTRCcsXG4gICAgICAgIHNlYXJjaDogY2hlY2tDb250YWlucygnZnJlZWJzZCcpLFxuICAgICAgICB2ZXJzaW9uUmVnZXhlczogW11cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdDaHJvbWVPUycsXG4gICAgICAgIHNlYXJjaDogY2hlY2tDb250YWlucygnY3JvcycpLFxuICAgICAgICB2ZXJzaW9uUmVnZXhlczogWy8uKj9jaHJvbWVcXC8oWzAtOV0rKVxcLihbMC05XSspLiovXVxuICAgICAgfVxuICAgIF07XG4gICAgY29uc3QgUGxhdGZvcm1JbmZvID0ge1xuICAgICAgYnJvd3NlcnM6IGNvbnN0YW50KGJyb3dzZXJzKSxcbiAgICAgIG9zZXM6IGNvbnN0YW50KG9zZXMpXG4gICAgfTtcblxuICAgIGNvbnN0IGVkZ2UgPSAnRWRnZSc7XG4gICAgY29uc3QgY2hyb21pdW0gPSAnQ2hyb21pdW0nO1xuICAgIGNvbnN0IGllID0gJ0lFJztcbiAgICBjb25zdCBvcGVyYSA9ICdPcGVyYSc7XG4gICAgY29uc3QgZmlyZWZveCA9ICdGaXJlZm94JztcbiAgICBjb25zdCBzYWZhcmkgPSAnU2FmYXJpJztcbiAgICBjb25zdCB1bmtub3duJDEgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gbnUkMih7XG4gICAgICAgIGN1cnJlbnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgdmVyc2lvbjogVmVyc2lvbi51bmtub3duKClcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgbnUkMiA9IGluZm8gPT4ge1xuICAgICAgY29uc3QgY3VycmVudCA9IGluZm8uY3VycmVudDtcbiAgICAgIGNvbnN0IHZlcnNpb24gPSBpbmZvLnZlcnNpb247XG4gICAgICBjb25zdCBpc0Jyb3dzZXIgPSBuYW1lID0+ICgpID0+IGN1cnJlbnQgPT09IG5hbWU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjdXJyZW50LFxuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICBpc0VkZ2U6IGlzQnJvd3NlcihlZGdlKSxcbiAgICAgICAgaXNDaHJvbWl1bTogaXNCcm93c2VyKGNocm9taXVtKSxcbiAgICAgICAgaXNJRTogaXNCcm93c2VyKGllKSxcbiAgICAgICAgaXNPcGVyYTogaXNCcm93c2VyKG9wZXJhKSxcbiAgICAgICAgaXNGaXJlZm94OiBpc0Jyb3dzZXIoZmlyZWZveCksXG4gICAgICAgIGlzU2FmYXJpOiBpc0Jyb3dzZXIoc2FmYXJpKVxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IEJyb3dzZXIgPSB7XG4gICAgICB1bmtub3duOiB1bmtub3duJDEsXG4gICAgICBudTogbnUkMixcbiAgICAgIGVkZ2U6IGNvbnN0YW50KGVkZ2UpLFxuICAgICAgY2hyb21pdW06IGNvbnN0YW50KGNocm9taXVtKSxcbiAgICAgIGllOiBjb25zdGFudChpZSksXG4gICAgICBvcGVyYTogY29uc3RhbnQob3BlcmEpLFxuICAgICAgZmlyZWZveDogY29uc3RhbnQoZmlyZWZveCksXG4gICAgICBzYWZhcmk6IGNvbnN0YW50KHNhZmFyaSlcbiAgICB9O1xuXG4gICAgY29uc3Qgd2luZG93cyA9ICdXaW5kb3dzJztcbiAgICBjb25zdCBpb3MgPSAnaU9TJztcbiAgICBjb25zdCBhbmRyb2lkID0gJ0FuZHJvaWQnO1xuICAgIGNvbnN0IGxpbnV4ID0gJ0xpbnV4JztcbiAgICBjb25zdCBtYWNvcyA9ICdtYWNPUyc7XG4gICAgY29uc3Qgc29sYXJpcyA9ICdTb2xhcmlzJztcbiAgICBjb25zdCBmcmVlYnNkID0gJ0ZyZWVCU0QnO1xuICAgIGNvbnN0IGNocm9tZW9zID0gJ0Nocm9tZU9TJztcbiAgICBjb25zdCB1bmtub3duID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIG51JDEoe1xuICAgICAgICBjdXJyZW50OiB1bmRlZmluZWQsXG4gICAgICAgIHZlcnNpb246IFZlcnNpb24udW5rbm93bigpXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IG51JDEgPSBpbmZvID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSBpbmZvLmN1cnJlbnQ7XG4gICAgICBjb25zdCB2ZXJzaW9uID0gaW5mby52ZXJzaW9uO1xuICAgICAgY29uc3QgaXNPUyA9IG5hbWUgPT4gKCkgPT4gY3VycmVudCA9PT0gbmFtZTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGN1cnJlbnQsXG4gICAgICAgIHZlcnNpb24sXG4gICAgICAgIGlzV2luZG93czogaXNPUyh3aW5kb3dzKSxcbiAgICAgICAgaXNpT1M6IGlzT1MoaW9zKSxcbiAgICAgICAgaXNBbmRyb2lkOiBpc09TKGFuZHJvaWQpLFxuICAgICAgICBpc01hY09TOiBpc09TKG1hY29zKSxcbiAgICAgICAgaXNMaW51eDogaXNPUyhsaW51eCksXG4gICAgICAgIGlzU29sYXJpczogaXNPUyhzb2xhcmlzKSxcbiAgICAgICAgaXNGcmVlQlNEOiBpc09TKGZyZWVic2QpLFxuICAgICAgICBpc0Nocm9tZU9TOiBpc09TKGNocm9tZW9zKVxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IE9wZXJhdGluZ1N5c3RlbSA9IHtcbiAgICAgIHVua25vd24sXG4gICAgICBudTogbnUkMSxcbiAgICAgIHdpbmRvd3M6IGNvbnN0YW50KHdpbmRvd3MpLFxuICAgICAgaW9zOiBjb25zdGFudChpb3MpLFxuICAgICAgYW5kcm9pZDogY29uc3RhbnQoYW5kcm9pZCksXG4gICAgICBsaW51eDogY29uc3RhbnQobGludXgpLFxuICAgICAgbWFjb3M6IGNvbnN0YW50KG1hY29zKSxcbiAgICAgIHNvbGFyaXM6IGNvbnN0YW50KHNvbGFyaXMpLFxuICAgICAgZnJlZWJzZDogY29uc3RhbnQoZnJlZWJzZCksXG4gICAgICBjaHJvbWVvczogY29uc3RhbnQoY2hyb21lb3MpXG4gICAgfTtcblxuICAgIGNvbnN0IGRldGVjdCQzID0gKHVzZXJBZ2VudCwgdXNlckFnZW50RGF0YU9wdCwgbWVkaWFNYXRjaCkgPT4ge1xuICAgICAgY29uc3QgYnJvd3NlcnMgPSBQbGF0Zm9ybUluZm8uYnJvd3NlcnMoKTtcbiAgICAgIGNvbnN0IG9zZXMgPSBQbGF0Zm9ybUluZm8ub3NlcygpO1xuICAgICAgY29uc3QgYnJvd3NlciA9IHVzZXJBZ2VudERhdGFPcHQuYmluZCh1c2VyQWdlbnREYXRhID0+IGRldGVjdEJyb3dzZXIkMShicm93c2VycywgdXNlckFnZW50RGF0YSkpLm9yVGh1bmsoKCkgPT4gZGV0ZWN0QnJvd3Nlcihicm93c2VycywgdXNlckFnZW50KSkuZm9sZChCcm93c2VyLnVua25vd24sIEJyb3dzZXIubnUpO1xuICAgICAgY29uc3Qgb3MgPSBkZXRlY3RPcyhvc2VzLCB1c2VyQWdlbnQpLmZvbGQoT3BlcmF0aW5nU3lzdGVtLnVua25vd24sIE9wZXJhdGluZ1N5c3RlbS5udSk7XG4gICAgICBjb25zdCBkZXZpY2VUeXBlID0gRGV2aWNlVHlwZShvcywgYnJvd3NlciwgdXNlckFnZW50LCBtZWRpYU1hdGNoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJyb3dzZXIsXG4gICAgICAgIG9zLFxuICAgICAgICBkZXZpY2VUeXBlXG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgUGxhdGZvcm1EZXRlY3Rpb24gPSB7IGRldGVjdDogZGV0ZWN0JDMgfTtcblxuICAgIGNvbnN0IG1lZGlhTWF0Y2ggPSBxdWVyeSA9PiB3aW5kb3cubWF0Y2hNZWRpYShxdWVyeSkubWF0Y2hlcztcbiAgICBsZXQgcGxhdGZvcm0kMiA9IGNhY2hlZCgoKSA9PiBQbGF0Zm9ybURldGVjdGlvbi5kZXRlY3QobmF2aWdhdG9yLnVzZXJBZ2VudCwgT3B0aW9uYWwuZnJvbShuYXZpZ2F0b3IudXNlckFnZW50RGF0YSksIG1lZGlhTWF0Y2gpKTtcbiAgICBjb25zdCBkZXRlY3QkMiA9ICgpID0+IHBsYXRmb3JtJDIoKTtcblxuICAgIGNvbnN0IHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gICAgY29uc3QgcGxhdGZvcm0kMSA9IGRldGVjdCQyKCk7XG4gICAgY29uc3QgYnJvd3NlciQxID0gcGxhdGZvcm0kMS5icm93c2VyO1xuICAgIGNvbnN0IG9zID0gcGxhdGZvcm0kMS5vcztcbiAgICBjb25zdCBkZXZpY2VUeXBlID0gcGxhdGZvcm0kMS5kZXZpY2VUeXBlO1xuICAgIGNvbnN0IHdpbmRvd3NQaG9uZSA9IHVzZXJBZ2VudC5pbmRleE9mKCdXaW5kb3dzIFBob25lJykgIT09IC0xO1xuICAgIGNvbnN0IEVudiA9IHtcbiAgICAgIHRyYW5zcGFyZW50U3JjOiAnZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFJQUFBQUFBQVAvLy95SDVCQUVBQUFBQUxBQUFBQUFCQUFFQUFBSUJSQUE3JyxcbiAgICAgIGRvY3VtZW50TW9kZTogYnJvd3NlciQxLmlzSUUoKSA/IGRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCA3IDogMTAsXG4gICAgICBjYWNoZVN1ZmZpeDogbnVsbCxcbiAgICAgIGNvbnRhaW5lcjogbnVsbCxcbiAgICAgIGNhbkhhdmVDU1A6ICFicm93c2VyJDEuaXNJRSgpLFxuICAgICAgd2luZG93c1Bob25lLFxuICAgICAgYnJvd3Nlcjoge1xuICAgICAgICBjdXJyZW50OiBicm93c2VyJDEuY3VycmVudCxcbiAgICAgICAgdmVyc2lvbjogYnJvd3NlciQxLnZlcnNpb24sXG4gICAgICAgIGlzQ2hyb21pdW06IGJyb3dzZXIkMS5pc0Nocm9taXVtLFxuICAgICAgICBpc0VkZ2U6IGJyb3dzZXIkMS5pc0VkZ2UsXG4gICAgICAgIGlzRmlyZWZveDogYnJvd3NlciQxLmlzRmlyZWZveCxcbiAgICAgICAgaXNJRTogYnJvd3NlciQxLmlzSUUsXG4gICAgICAgIGlzT3BlcmE6IGJyb3dzZXIkMS5pc09wZXJhLFxuICAgICAgICBpc1NhZmFyaTogYnJvd3NlciQxLmlzU2FmYXJpXG4gICAgICB9LFxuICAgICAgb3M6IHtcbiAgICAgICAgY3VycmVudDogb3MuY3VycmVudCxcbiAgICAgICAgdmVyc2lvbjogb3MudmVyc2lvbixcbiAgICAgICAgaXNBbmRyb2lkOiBvcy5pc0FuZHJvaWQsXG4gICAgICAgIGlzQ2hyb21lT1M6IG9zLmlzQ2hyb21lT1MsXG4gICAgICAgIGlzRnJlZUJTRDogb3MuaXNGcmVlQlNELFxuICAgICAgICBpc2lPUzogb3MuaXNpT1MsXG4gICAgICAgIGlzTGludXg6IG9zLmlzTGludXgsXG4gICAgICAgIGlzTWFjT1M6IG9zLmlzTWFjT1MsXG4gICAgICAgIGlzU29sYXJpczogb3MuaXNTb2xhcmlzLFxuICAgICAgICBpc1dpbmRvd3M6IG9zLmlzV2luZG93c1xuICAgICAgfSxcbiAgICAgIGRldmljZVR5cGU6IHtcbiAgICAgICAgaXNEZXNrdG9wOiBkZXZpY2VUeXBlLmlzRGVza3RvcCxcbiAgICAgICAgaXNpUGFkOiBkZXZpY2VUeXBlLmlzaVBhZCxcbiAgICAgICAgaXNpUGhvbmU6IGRldmljZVR5cGUuaXNpUGhvbmUsXG4gICAgICAgIGlzUGhvbmU6IGRldmljZVR5cGUuaXNQaG9uZSxcbiAgICAgICAgaXNUYWJsZXQ6IGRldmljZVR5cGUuaXNUYWJsZXQsXG4gICAgICAgIGlzVG91Y2g6IGRldmljZVR5cGUuaXNUb3VjaCxcbiAgICAgICAgaXNXZWJWaWV3OiBkZXZpY2VUeXBlLmlzV2ViVmlld1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCB3aGl0ZVNwYWNlUmVnRXhwJDEgPSAvXlxccyp8XFxzKiQvZztcbiAgICBjb25zdCB0cmltJDIgPSBzdHIgPT4ge1xuICAgICAgcmV0dXJuIGlzTnVsbGFibGUoc3RyKSA/ICcnIDogKCcnICsgc3RyKS5yZXBsYWNlKHdoaXRlU3BhY2VSZWdFeHAkMSwgJycpO1xuICAgIH07XG4gICAgY29uc3QgaXMkMyA9IChvYmosIHR5cGUpID0+IHtcbiAgICAgIGlmICghdHlwZSkge1xuICAgICAgICByZXR1cm4gb2JqICE9PSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gJ2FycmF5JyAmJiBpc0FycmF5KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gdHlwZTtcbiAgICB9O1xuICAgIGNvbnN0IG1ha2VNYXAkNCA9IChpdGVtcywgZGVsaW0sIG1hcCA9IHt9KSA9PiB7XG4gICAgICBjb25zdCByZXNvbHZlZEl0ZW1zID0gaXNTdHJpbmcoaXRlbXMpID8gaXRlbXMuc3BsaXQoZGVsaW0gfHwgJywnKSA6IGl0ZW1zIHx8IFtdO1xuICAgICAgbGV0IGkgPSByZXNvbHZlZEl0ZW1zLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgbWFwW3Jlc29sdmVkSXRlbXNbaV1dID0ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFwO1xuICAgIH07XG4gICAgY29uc3QgaGFzT3duUHJvcGVydHkkMSA9IGhhcyQyO1xuICAgIGNvbnN0IGV4dGVuZCQzID0gKG9iaiwgLi4uZXh0cykgPT4ge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGV4dCA9IGV4dHNbaV07XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBleHQpIHtcbiAgICAgICAgICBpZiAoaGFzJDIoZXh0LCBuYW1lKSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBleHRbbmFtZV07XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBvYmpbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgICBjb25zdCB3YWxrJDQgPSBmdW5jdGlvbiAobywgZiwgbiwgcykge1xuICAgICAgcyA9IHMgfHwgdGhpcztcbiAgICAgIGlmIChvKSB7XG4gICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgbyA9IG9bbl07XG4gICAgICAgIH1cbiAgICAgICAgZWFjaCRjKG8sIChvLCBpKSA9PiB7XG4gICAgICAgICAgaWYgKGYuY2FsbChzLCBvLCBpLCBuKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2FsayQ0KG8sIGYsIG4sIHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlc29sdmUkMyA9IChuLCBvID0gd2luZG93KSA9PiB7XG4gICAgICBjb25zdCBwYXRoID0gbi5zcGxpdCgnLicpO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBwYXRoLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBvID0gb1twYXRoW2ldXTtcbiAgICAgICAgaWYgKCFvKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgY29uc3QgZXhwbG9kZSQzID0gKHMsIGQpID0+IHtcbiAgICAgIGlmIChpc0FycmF5JDEocykpIHtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgICB9IGVsc2UgaWYgKHMgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBtYXAkMShzLnNwbGl0KGQgfHwgJywnKSwgdHJpbSQyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IF9hZGRDYWNoZVN1ZmZpeCA9IHVybCA9PiB7XG4gICAgICBjb25zdCBjYWNoZVN1ZmZpeCA9IEVudi5jYWNoZVN1ZmZpeDtcbiAgICAgIGlmIChjYWNoZVN1ZmZpeCkge1xuICAgICAgICB1cmwgKz0gKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIGNhY2hlU3VmZml4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVybDtcbiAgICB9O1xuICAgIGNvbnN0IFRvb2xzID0ge1xuICAgICAgdHJpbTogdHJpbSQyLFxuICAgICAgaXNBcnJheTogaXNBcnJheSxcbiAgICAgIGlzOiBpcyQzLFxuICAgICAgdG9BcnJheTogdG9BcnJheSQxLFxuICAgICAgbWFrZU1hcDogbWFrZU1hcCQ0LFxuICAgICAgZWFjaDogZWFjaCRjLFxuICAgICAgbWFwOiBtYXAkMSxcbiAgICAgIGdyZXA6IGZpbHRlciQzLFxuICAgICAgaW5BcnJheTogaW5kZXhPZixcbiAgICAgIGhhc093bjogaGFzT3duUHJvcGVydHkkMSxcbiAgICAgIGV4dGVuZDogZXh0ZW5kJDMsXG4gICAgICB3YWxrOiB3YWxrJDQsXG4gICAgICByZXNvbHZlOiByZXNvbHZlJDMsXG4gICAgICBleHBsb2RlOiBleHBsb2RlJDMsXG4gICAgICBfYWRkQ2FjaGVTdWZmaXhcbiAgICB9O1xuXG4gICAgY29uc3QgaXMkMiA9IChsaHMsIHJocywgY29tcGFyYXRvciA9IHRyaXBsZUVxdWFscykgPT4gbGhzLmV4aXN0cyhsZWZ0ID0+IGNvbXBhcmF0b3IobGVmdCwgcmhzKSk7XG4gICAgY29uc3QgY2F0ID0gYXJyID0+IHtcbiAgICAgIGNvbnN0IHIgPSBbXTtcbiAgICAgIGNvbnN0IHB1c2ggPSB4ID0+IHtcbiAgICAgICAgci5wdXNoKHgpO1xuICAgICAgfTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycltpXS5lYWNoKHB1c2gpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICBjb25zdCBsaWZ0MiA9IChvYSwgb2IsIGYpID0+IG9hLmlzU29tZSgpICYmIG9iLmlzU29tZSgpID8gT3B0aW9uYWwuc29tZShmKG9hLmdldE9yRGllKCksIG9iLmdldE9yRGllKCkpKSA6IE9wdGlvbmFsLm5vbmUoKTtcbiAgICBjb25zdCBsaWZ0MyA9IChvYSwgb2IsIG9jLCBmKSA9PiBvYS5pc1NvbWUoKSAmJiBvYi5pc1NvbWUoKSAmJiBvYy5pc1NvbWUoKSA/IE9wdGlvbmFsLnNvbWUoZihvYS5nZXRPckRpZSgpLCBvYi5nZXRPckRpZSgpLCBvYy5nZXRPckRpZSgpKSkgOiBPcHRpb25hbC5ub25lKCk7XG4gICAgY29uc3Qgc29tZUlmID0gKGIsIGEpID0+IGIgPyBPcHRpb25hbC5zb21lKGEpIDogT3B0aW9uYWwubm9uZSgpO1xuXG4gICAgY29uc3QgR2xvYmFsID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBGdW5jdGlvbigncmV0dXJuIHRoaXM7JykoKTtcblxuICAgIGNvbnN0IHBhdGggPSAocGFydHMsIHNjb3BlKSA9PiB7XG4gICAgICBsZXQgbyA9IHNjb3BlICE9PSB1bmRlZmluZWQgJiYgc2NvcGUgIT09IG51bGwgPyBzY29wZSA6IEdsb2JhbDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoICYmIG8gIT09IHVuZGVmaW5lZCAmJiBvICE9PSBudWxsOyArK2kpIHtcbiAgICAgICAgbyA9IG9bcGFydHNbaV1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICBjb25zdCByZXNvbHZlJDIgPSAocCwgc2NvcGUpID0+IHtcbiAgICAgIGNvbnN0IHBhcnRzID0gcC5zcGxpdCgnLicpO1xuICAgICAgcmV0dXJuIHBhdGgocGFydHMsIHNjb3BlKTtcbiAgICB9O1xuXG4gICAgY29uc3QgdW5zYWZlID0gKG5hbWUsIHNjb3BlKSA9PiB7XG4gICAgICByZXR1cm4gcmVzb2x2ZSQyKG5hbWUsIHNjb3BlKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldE9yRGllID0gKG5hbWUsIHNjb3BlKSA9PiB7XG4gICAgICBjb25zdCBhY3R1YWwgPSB1bnNhZmUobmFtZSwgc2NvcGUpO1xuICAgICAgaWYgKGFjdHVhbCA9PT0gdW5kZWZpbmVkIHx8IGFjdHVhbCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobmFtZSArICcgbm90IGF2YWlsYWJsZSBvbiB0aGlzIGJyb3dzZXInKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3R1YWw7XG4gICAgfTtcblxuICAgIGNvbnN0IGdldFByb3RvdHlwZU9mJDEgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gICAgY29uc3Qgc2FuZEhUTUxFbGVtZW50ID0gc2NvcGUgPT4ge1xuICAgICAgcmV0dXJuIGdldE9yRGllKCdIVE1MRWxlbWVudCcsIHNjb3BlKTtcbiAgICB9O1xuICAgIGNvbnN0IGlzUHJvdG90eXBlT2YgPSB4ID0+IHtcbiAgICAgIGNvbnN0IHNjb3BlID0gcmVzb2x2ZSQyKCdvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3JywgeCk7XG4gICAgICByZXR1cm4gaXNPYmplY3QoeCkgJiYgKHNhbmRIVE1MRWxlbWVudChzY29wZSkucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoeCkgfHwgL15IVE1MXFx3KkVsZW1lbnQkLy50ZXN0KGdldFByb3RvdHlwZU9mJDEoeCkuY29uc3RydWN0b3IubmFtZSkpO1xuICAgIH07XG5cbiAgICBjb25zdCBDT01NRU5UID0gODtcbiAgICBjb25zdCBET0NVTUVOVCA9IDk7XG4gICAgY29uc3QgRE9DVU1FTlRfRlJBR01FTlQgPSAxMTtcbiAgICBjb25zdCBFTEVNRU5UID0gMTtcbiAgICBjb25zdCBURVhUID0gMztcblxuICAgIGNvbnN0IG5hbWUgPSBlbGVtZW50ID0+IHtcbiAgICAgIGNvbnN0IHIgPSBlbGVtZW50LmRvbS5ub2RlTmFtZTtcbiAgICAgIHJldHVybiByLnRvTG93ZXJDYXNlKCk7XG4gICAgfTtcbiAgICBjb25zdCB0eXBlJDEgPSBlbGVtZW50ID0+IGVsZW1lbnQuZG9tLm5vZGVUeXBlO1xuICAgIGNvbnN0IGlzVHlwZSA9IHQgPT4gZWxlbWVudCA9PiB0eXBlJDEoZWxlbWVudCkgPT09IHQ7XG4gICAgY29uc3QgaXNDb21tZW50JDEgPSBlbGVtZW50ID0+IHR5cGUkMShlbGVtZW50KSA9PT0gQ09NTUVOVCB8fCBuYW1lKGVsZW1lbnQpID09PSAnI2NvbW1lbnQnO1xuICAgIGNvbnN0IGlzSFRNTEVsZW1lbnQgPSBlbGVtZW50ID0+IGlzRWxlbWVudCQ3KGVsZW1lbnQpICYmIGlzUHJvdG90eXBlT2YoZWxlbWVudC5kb20pO1xuICAgIGNvbnN0IGlzRWxlbWVudCQ3ID0gaXNUeXBlKEVMRU1FTlQpO1xuICAgIGNvbnN0IGlzVGV4dCRiID0gaXNUeXBlKFRFWFQpO1xuICAgIGNvbnN0IGlzRG9jdW1lbnQkMiA9IGlzVHlwZShET0NVTUVOVCk7XG4gICAgY29uc3QgaXNEb2N1bWVudEZyYWdtZW50JDEgPSBpc1R5cGUoRE9DVU1FTlRfRlJBR01FTlQpO1xuICAgIGNvbnN0IGlzVGFnID0gdGFnID0+IGUgPT4gaXNFbGVtZW50JDcoZSkgJiYgbmFtZShlKSA9PT0gdGFnO1xuXG4gICAgY29uc3QgcmF3U2V0ID0gKGRvbSwga2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgaWYgKGlzU3RyaW5nKHZhbHVlKSB8fCBpc0Jvb2xlYW4odmFsdWUpIHx8IGlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICBkb20uc2V0QXR0cmlidXRlKGtleSwgdmFsdWUgKyAnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIGNhbGwgdG8gQXR0cmlidXRlLnNldC4gS2V5ICcsIGtleSwgJzo6IFZhbHVlICcsIHZhbHVlLCAnOjogRWxlbWVudCAnLCBkb20pO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dHJpYnV0ZSB2YWx1ZSB3YXMgbm90IHNpbXBsZScpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc2V0JDMgPSAoZWxlbWVudCwga2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgcmF3U2V0KGVsZW1lbnQuZG9tLCBrZXksIHZhbHVlKTtcbiAgICB9O1xuICAgIGNvbnN0IHNldEFsbCQxID0gKGVsZW1lbnQsIGF0dHJzKSA9PiB7XG4gICAgICBjb25zdCBkb20gPSBlbGVtZW50LmRvbTtcbiAgICAgIGVhY2gkZChhdHRycywgKHYsIGspID0+IHtcbiAgICAgICAgcmF3U2V0KGRvbSwgaywgdik7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGdldCQ5ID0gKGVsZW1lbnQsIGtleSkgPT4ge1xuICAgICAgY29uc3QgdiA9IGVsZW1lbnQuZG9tLmdldEF0dHJpYnV0ZShrZXkpO1xuICAgICAgcmV0dXJuIHYgPT09IG51bGwgPyB1bmRlZmluZWQgOiB2O1xuICAgIH07XG4gICAgY29uc3QgZ2V0T3B0ID0gKGVsZW1lbnQsIGtleSkgPT4gT3B0aW9uYWwuZnJvbShnZXQkOShlbGVtZW50LCBrZXkpKTtcbiAgICBjb25zdCBoYXMkMSA9IChlbGVtZW50LCBrZXkpID0+IHtcbiAgICAgIGNvbnN0IGRvbSA9IGVsZW1lbnQuZG9tO1xuICAgICAgcmV0dXJuIGRvbSAmJiBkb20uaGFzQXR0cmlidXRlID8gZG9tLmhhc0F0dHJpYnV0ZShrZXkpIDogZmFsc2U7XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmUkYiA9IChlbGVtZW50LCBrZXkpID0+IHtcbiAgICAgIGVsZW1lbnQuZG9tLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH07XG4gICAgY29uc3QgaGFzTm9uZSA9IGVsZW1lbnQgPT4ge1xuICAgICAgY29uc3QgYXR0cnMgPSBlbGVtZW50LmRvbS5hdHRyaWJ1dGVzO1xuICAgICAgcmV0dXJuIGF0dHJzID09PSB1bmRlZmluZWQgfHwgYXR0cnMgPT09IG51bGwgfHwgYXR0cnMubGVuZ3RoID09PSAwO1xuICAgIH07XG4gICAgY29uc3QgY2xvbmUkNCA9IGVsZW1lbnQgPT4gZm9sZGwoZWxlbWVudC5kb20uYXR0cmlidXRlcywgKGFjYywgYXR0cikgPT4ge1xuICAgICAgYWNjW2F0dHIubmFtZV0gPSBhdHRyLnZhbHVlO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG5cbiAgICBjb25zdCByZWFkJDQgPSAoZWxlbWVudCwgYXR0cikgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBnZXQkOShlbGVtZW50LCBhdHRyKTtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSAnJyA/IFtdIDogdmFsdWUuc3BsaXQoJyAnKTtcbiAgICB9O1xuICAgIGNvbnN0IGFkZCQ0ID0gKGVsZW1lbnQsIGF0dHIsIGlkKSA9PiB7XG4gICAgICBjb25zdCBvbGQgPSByZWFkJDQoZWxlbWVudCwgYXR0cik7XG4gICAgICBjb25zdCBudSA9IG9sZC5jb25jYXQoW2lkXSk7XG4gICAgICBzZXQkMyhlbGVtZW50LCBhdHRyLCBudS5qb2luKCcgJykpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmUkYSA9IChlbGVtZW50LCBhdHRyLCBpZCkgPT4ge1xuICAgICAgY29uc3QgbnUgPSBmaWx0ZXIkNShyZWFkJDQoZWxlbWVudCwgYXR0ciksIHYgPT4gdiAhPT0gaWQpO1xuICAgICAgaWYgKG51Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgc2V0JDMoZWxlbWVudCwgYXR0ciwgbnUuam9pbignICcpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZSRiKGVsZW1lbnQsIGF0dHIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBjb25zdCBzdXBwb3J0cyA9IGVsZW1lbnQgPT4gZWxlbWVudC5kb20uY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQ7XG4gICAgY29uc3QgZ2V0JDggPSBlbGVtZW50ID0+IHJlYWQkNChlbGVtZW50LCAnY2xhc3MnKTtcbiAgICBjb25zdCBhZGQkMyA9IChlbGVtZW50LCBjbGF6eikgPT4gYWRkJDQoZWxlbWVudCwgJ2NsYXNzJywgY2xhenopO1xuICAgIGNvbnN0IHJlbW92ZSQ5ID0gKGVsZW1lbnQsIGNsYXp6KSA9PiByZW1vdmUkYShlbGVtZW50LCAnY2xhc3MnLCBjbGF6eik7XG4gICAgY29uc3QgdG9nZ2xlJDIgPSAoZWxlbWVudCwgY2xhenopID0+IHtcbiAgICAgIGlmIChjb250YWlucyQyKGdldCQ4KGVsZW1lbnQpLCBjbGF6eikpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZSQ5KGVsZW1lbnQsIGNsYXp6KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhZGQkMyhlbGVtZW50LCBjbGF6eik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGFkZCQyID0gKGVsZW1lbnQsIGNsYXp6KSA9PiB7XG4gICAgICBpZiAoc3VwcG9ydHMoZWxlbWVudCkpIHtcbiAgICAgICAgZWxlbWVudC5kb20uY2xhc3NMaXN0LmFkZChjbGF6eik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGQkMyhlbGVtZW50LCBjbGF6eik7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBjbGVhbkNsYXNzID0gZWxlbWVudCA9PiB7XG4gICAgICBjb25zdCBjbGFzc0xpc3QgPSBzdXBwb3J0cyhlbGVtZW50KSA/IGVsZW1lbnQuZG9tLmNsYXNzTGlzdCA6IGdldCQ4KGVsZW1lbnQpO1xuICAgICAgaWYgKGNsYXNzTGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmVtb3ZlJGIoZWxlbWVudCwgJ2NsYXNzJyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmUkOCA9IChlbGVtZW50LCBjbGF6eikgPT4ge1xuICAgICAgaWYgKHN1cHBvcnRzKGVsZW1lbnQpKSB7XG4gICAgICAgIGNvbnN0IGNsYXNzTGlzdCA9IGVsZW1lbnQuZG9tLmNsYXNzTGlzdDtcbiAgICAgICAgY2xhc3NMaXN0LnJlbW92ZShjbGF6eik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1vdmUkOShlbGVtZW50LCBjbGF6eik7XG4gICAgICB9XG4gICAgICBjbGVhbkNsYXNzKGVsZW1lbnQpO1xuICAgIH07XG4gICAgY29uc3QgdG9nZ2xlJDEgPSAoZWxlbWVudCwgY2xhenopID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHN1cHBvcnRzKGVsZW1lbnQpID8gZWxlbWVudC5kb20uY2xhc3NMaXN0LnRvZ2dsZShjbGF6eikgOiB0b2dnbGUkMihlbGVtZW50LCBjbGF6eik7XG4gICAgICBjbGVhbkNsYXNzKGVsZW1lbnQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIGNvbnN0IGhhcyA9IChlbGVtZW50LCBjbGF6eikgPT4gc3VwcG9ydHMoZWxlbWVudCkgJiYgZWxlbWVudC5kb20uY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXp6KTtcblxuICAgIGNvbnN0IGZyb21IdG1sJDEgPSAoaHRtbCwgc2NvcGUpID0+IHtcbiAgICAgIGNvbnN0IGRvYyA9IHNjb3BlIHx8IGRvY3VtZW50O1xuICAgICAgY29uc3QgZGl2ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZGl2LmlubmVySFRNTCA9IGh0bWw7XG4gICAgICBpZiAoIWRpdi5oYXNDaGlsZE5vZGVzKCkgfHwgZGl2LmNoaWxkTm9kZXMubGVuZ3RoID4gMSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0hUTUwgZG9lcyBub3QgaGF2ZSBhIHNpbmdsZSByb290IG5vZGUnO1xuICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UsIGh0bWwpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbURvbSQyKGRpdi5jaGlsZE5vZGVzWzBdKTtcbiAgICB9O1xuICAgIGNvbnN0IGZyb21UYWcgPSAodGFnLCBzY29wZSkgPT4ge1xuICAgICAgY29uc3QgZG9jID0gc2NvcGUgfHwgZG9jdW1lbnQ7XG4gICAgICBjb25zdCBub2RlID0gZG9jLmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgIHJldHVybiBmcm9tRG9tJDIobm9kZSk7XG4gICAgfTtcbiAgICBjb25zdCBmcm9tVGV4dCA9ICh0ZXh0LCBzY29wZSkgPT4ge1xuICAgICAgY29uc3QgZG9jID0gc2NvcGUgfHwgZG9jdW1lbnQ7XG4gICAgICBjb25zdCBub2RlID0gZG9jLmNyZWF0ZVRleHROb2RlKHRleHQpO1xuICAgICAgcmV0dXJuIGZyb21Eb20kMihub2RlKTtcbiAgICB9O1xuICAgIGNvbnN0IGZyb21Eb20kMiA9IG5vZGUgPT4ge1xuICAgICAgaWYgKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm9kZSBjYW5ub3QgYmUgbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGRvbTogbm9kZSB9O1xuICAgIH07XG4gICAgY29uc3QgZnJvbVBvaW50JDIgPSAoZG9jRWxtLCB4LCB5KSA9PiBPcHRpb25hbC5mcm9tKGRvY0VsbS5kb20uZWxlbWVudEZyb21Qb2ludCh4LCB5KSkubWFwKGZyb21Eb20kMik7XG4gICAgY29uc3QgU3VnYXJFbGVtZW50ID0ge1xuICAgICAgZnJvbUh0bWw6IGZyb21IdG1sJDEsXG4gICAgICBmcm9tVGFnLFxuICAgICAgZnJvbVRleHQsXG4gICAgICBmcm9tRG9tOiBmcm9tRG9tJDIsXG4gICAgICBmcm9tUG9pbnQ6IGZyb21Qb2ludCQyXG4gICAgfTtcblxuICAgIGNvbnN0IHRvQXJyYXkgPSAodGFyZ2V0LCBmKSA9PiB7XG4gICAgICBjb25zdCByID0gW107XG4gICAgICBjb25zdCByZWN1cnNlID0gZSA9PiB7XG4gICAgICAgIHIucHVzaChlKTtcbiAgICAgICAgcmV0dXJuIGYoZSk7XG4gICAgICB9O1xuICAgICAgbGV0IGN1ciA9IGYodGFyZ2V0KTtcbiAgICAgIGRvIHtcbiAgICAgICAgY3VyID0gY3VyLmJpbmQocmVjdXJzZSk7XG4gICAgICB9IHdoaWxlIChjdXIuaXNTb21lKCkpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfTtcblxuICAgIGNvbnN0IGlzJDEgPSAoZWxlbWVudCwgc2VsZWN0b3IpID0+IHtcbiAgICAgIGNvbnN0IGRvbSA9IGVsZW1lbnQuZG9tO1xuICAgICAgaWYgKGRvbS5ub2RlVHlwZSAhPT0gRUxFTUVOVCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBlbGVtID0gZG9tO1xuICAgICAgICBpZiAoZWxlbS5tYXRjaGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gZWxlbS5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtLm1zTWF0Y2hlc1NlbGVjdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gZWxlbS5tc01hdGNoZXNTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBlbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBlbGVtLm1vek1hdGNoZXNTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCcm93c2VyIGxhY2tzIG5hdGl2ZSBzZWxlY3RvcnMnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgYnlwYXNzU2VsZWN0b3IgPSBkb20gPT4gZG9tLm5vZGVUeXBlICE9PSBFTEVNRU5UICYmIGRvbS5ub2RlVHlwZSAhPT0gRE9DVU1FTlQgJiYgZG9tLm5vZGVUeXBlICE9PSBET0NVTUVOVF9GUkFHTUVOVCB8fCBkb20uY2hpbGRFbGVtZW50Q291bnQgPT09IDA7XG4gICAgY29uc3QgYWxsID0gKHNlbGVjdG9yLCBzY29wZSkgPT4ge1xuICAgICAgY29uc3QgYmFzZSA9IHNjb3BlID09PSB1bmRlZmluZWQgPyBkb2N1bWVudCA6IHNjb3BlLmRvbTtcbiAgICAgIHJldHVybiBieXBhc3NTZWxlY3RvcihiYXNlKSA/IFtdIDogbWFwJDMoYmFzZS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSwgU3VnYXJFbGVtZW50LmZyb21Eb20pO1xuICAgIH07XG4gICAgY29uc3Qgb25lID0gKHNlbGVjdG9yLCBzY29wZSkgPT4ge1xuICAgICAgY29uc3QgYmFzZSA9IHNjb3BlID09PSB1bmRlZmluZWQgPyBkb2N1bWVudCA6IHNjb3BlLmRvbTtcbiAgICAgIHJldHVybiBieXBhc3NTZWxlY3RvcihiYXNlKSA/IE9wdGlvbmFsLm5vbmUoKSA6IE9wdGlvbmFsLmZyb20oYmFzZS5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSkubWFwKFN1Z2FyRWxlbWVudC5mcm9tRG9tKTtcbiAgICB9O1xuXG4gICAgY29uc3QgZXEgPSAoZTEsIGUyKSA9PiBlMS5kb20gPT09IGUyLmRvbTtcbiAgICBjb25zdCBjb250YWlucyA9IChlMSwgZTIpID0+IHtcbiAgICAgIGNvbnN0IGQxID0gZTEuZG9tO1xuICAgICAgY29uc3QgZDIgPSBlMi5kb207XG4gICAgICByZXR1cm4gZDEgPT09IGQyID8gZmFsc2UgOiBkMS5jb250YWlucyhkMik7XG4gICAgfTtcblxuICAgIGNvbnN0IG93bmVyJDEgPSBlbGVtZW50ID0+IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVsZW1lbnQuZG9tLm93bmVyRG9jdW1lbnQpO1xuICAgIGNvbnN0IGRvY3VtZW50T3JPd25lciA9IGRvcyA9PiBpc0RvY3VtZW50JDIoZG9zKSA/IGRvcyA6IG93bmVyJDEoZG9zKTtcbiAgICBjb25zdCBkb2N1bWVudEVsZW1lbnQgPSBlbGVtZW50ID0+IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGRvY3VtZW50T3JPd25lcihlbGVtZW50KS5kb20uZG9jdW1lbnRFbGVtZW50KTtcbiAgICBjb25zdCBkZWZhdWx0VmlldyA9IGVsZW1lbnQgPT4gU3VnYXJFbGVtZW50LmZyb21Eb20oZG9jdW1lbnRPck93bmVyKGVsZW1lbnQpLmRvbS5kZWZhdWx0Vmlldyk7XG4gICAgY29uc3QgcGFyZW50ID0gZWxlbWVudCA9PiBPcHRpb25hbC5mcm9tKGVsZW1lbnQuZG9tLnBhcmVudE5vZGUpLm1hcChTdWdhckVsZW1lbnQuZnJvbURvbSk7XG4gICAgY29uc3QgcGFyZW50RWxlbWVudCA9IGVsZW1lbnQgPT4gT3B0aW9uYWwuZnJvbShlbGVtZW50LmRvbS5wYXJlbnRFbGVtZW50KS5tYXAoU3VnYXJFbGVtZW50LmZyb21Eb20pO1xuICAgIGNvbnN0IHBhcmVudHMkMSA9IChlbGVtZW50LCBpc1Jvb3QpID0+IHtcbiAgICAgIGNvbnN0IHN0b3AgPSBpc0Z1bmN0aW9uKGlzUm9vdCkgPyBpc1Jvb3QgOiBuZXZlcjtcbiAgICAgIGxldCBkb20gPSBlbGVtZW50LmRvbTtcbiAgICAgIGNvbnN0IHJldCA9IFtdO1xuICAgICAgd2hpbGUgKGRvbS5wYXJlbnROb2RlICE9PSBudWxsICYmIGRvbS5wYXJlbnROb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgcmF3UGFyZW50ID0gZG9tLnBhcmVudE5vZGU7XG4gICAgICAgIGNvbnN0IHAgPSBTdWdhckVsZW1lbnQuZnJvbURvbShyYXdQYXJlbnQpO1xuICAgICAgICByZXQucHVzaChwKTtcbiAgICAgICAgaWYgKHN0b3AocCkgPT09IHRydWUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb20gPSByYXdQYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBjb25zdCBzaWJsaW5ncyA9IGVsZW1lbnQgPT4ge1xuICAgICAgY29uc3QgZmlsdGVyU2VsZiA9IGVsZW1lbnRzID0+IGZpbHRlciQ1KGVsZW1lbnRzLCB4ID0+ICFlcShlbGVtZW50LCB4KSk7XG4gICAgICByZXR1cm4gcGFyZW50KGVsZW1lbnQpLm1hcChjaGlsZHJlbiQxKS5tYXAoZmlsdGVyU2VsZikuZ2V0T3IoW10pO1xuICAgIH07XG4gICAgY29uc3QgcHJldlNpYmxpbmcgPSBlbGVtZW50ID0+IE9wdGlvbmFsLmZyb20oZWxlbWVudC5kb20ucHJldmlvdXNTaWJsaW5nKS5tYXAoU3VnYXJFbGVtZW50LmZyb21Eb20pO1xuICAgIGNvbnN0IG5leHRTaWJsaW5nID0gZWxlbWVudCA9PiBPcHRpb25hbC5mcm9tKGVsZW1lbnQuZG9tLm5leHRTaWJsaW5nKS5tYXAoU3VnYXJFbGVtZW50LmZyb21Eb20pO1xuICAgIGNvbnN0IHByZXZTaWJsaW5ncyA9IGVsZW1lbnQgPT4gcmV2ZXJzZSh0b0FycmF5KGVsZW1lbnQsIHByZXZTaWJsaW5nKSk7XG4gICAgY29uc3QgbmV4dFNpYmxpbmdzID0gZWxlbWVudCA9PiB0b0FycmF5KGVsZW1lbnQsIG5leHRTaWJsaW5nKTtcbiAgICBjb25zdCBjaGlsZHJlbiQxID0gZWxlbWVudCA9PiBtYXAkMyhlbGVtZW50LmRvbS5jaGlsZE5vZGVzLCBTdWdhckVsZW1lbnQuZnJvbURvbSk7XG4gICAgY29uc3QgY2hpbGQkMSA9IChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgY3MgPSBlbGVtZW50LmRvbS5jaGlsZE5vZGVzO1xuICAgICAgcmV0dXJuIE9wdGlvbmFsLmZyb20oY3NbaW5kZXhdKS5tYXAoU3VnYXJFbGVtZW50LmZyb21Eb20pO1xuICAgIH07XG4gICAgY29uc3QgZmlyc3RDaGlsZCA9IGVsZW1lbnQgPT4gY2hpbGQkMShlbGVtZW50LCAwKTtcbiAgICBjb25zdCBsYXN0Q2hpbGQgPSBlbGVtZW50ID0+IGNoaWxkJDEoZWxlbWVudCwgZWxlbWVudC5kb20uY2hpbGROb2Rlcy5sZW5ndGggLSAxKTtcbiAgICBjb25zdCBjaGlsZE5vZGVzQ291bnQgPSBlbGVtZW50ID0+IGVsZW1lbnQuZG9tLmNoaWxkTm9kZXMubGVuZ3RoO1xuXG4gICAgY29uc3QgZ2V0SGVhZCA9IGRvYyA9PiB7XG4gICAgICBjb25zdCBiID0gZG9jLmRvbS5oZWFkO1xuICAgICAgaWYgKGIgPT09IG51bGwgfHwgYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGVhZCBpcyBub3QgYXZhaWxhYmxlIHlldCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFN1Z2FyRWxlbWVudC5mcm9tRG9tKGIpO1xuICAgIH07XG5cbiAgICBjb25zdCBpc1NoYWRvd1Jvb3QgPSBkb3MgPT4gaXNEb2N1bWVudEZyYWdtZW50JDEoZG9zKSAmJiBpc05vbk51bGxhYmxlKGRvcy5kb20uaG9zdCk7XG4gICAgY29uc3Qgc3VwcG9ydGVkID0gaXNGdW5jdGlvbihFbGVtZW50LnByb3RvdHlwZS5hdHRhY2hTaGFkb3cpICYmIGlzRnVuY3Rpb24oTm9kZS5wcm90b3R5cGUuZ2V0Um9vdE5vZGUpO1xuICAgIGNvbnN0IGlzU3VwcG9ydGVkJDEgPSBjb25zdGFudChzdXBwb3J0ZWQpO1xuICAgIGNvbnN0IGdldFJvb3ROb2RlID0gc3VwcG9ydGVkID8gZSA9PiBTdWdhckVsZW1lbnQuZnJvbURvbShlLmRvbS5nZXRSb290Tm9kZSgpKSA6IGRvY3VtZW50T3JPd25lcjtcbiAgICBjb25zdCBnZXRTdHlsZUNvbnRhaW5lciA9IGRvcyA9PiBpc1NoYWRvd1Jvb3QoZG9zKSA/IGRvcyA6IGdldEhlYWQoZG9jdW1lbnRPck93bmVyKGRvcykpO1xuICAgIGNvbnN0IGdldENvbnRlbnRDb250YWluZXIgPSBkb3MgPT4gaXNTaGFkb3dSb290KGRvcykgPyBkb3MgOiBTdWdhckVsZW1lbnQuZnJvbURvbShkb2N1bWVudE9yT3duZXIoZG9zKS5kb20uYm9keSk7XG4gICAgY29uc3QgZ2V0U2hhZG93Um9vdCA9IGUgPT4ge1xuICAgICAgY29uc3QgciA9IGdldFJvb3ROb2RlKGUpO1xuICAgICAgcmV0dXJuIGlzU2hhZG93Um9vdChyKSA/IE9wdGlvbmFsLnNvbWUocikgOiBPcHRpb25hbC5ub25lKCk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRTaGFkb3dIb3N0ID0gZSA9PiBTdWdhckVsZW1lbnQuZnJvbURvbShlLmRvbS5ob3N0KTtcbiAgICBjb25zdCBnZXRPcmlnaW5hbEV2ZW50VGFyZ2V0ID0gZXZlbnQgPT4ge1xuICAgICAgaWYgKGlzU3VwcG9ydGVkJDEoKSAmJiBpc05vbk51bGxhYmxlKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgY29uc3QgZWwgPSBTdWdhckVsZW1lbnQuZnJvbURvbShldmVudC50YXJnZXQpO1xuICAgICAgICBpZiAoaXNFbGVtZW50JDcoZWwpICYmIGlzT3BlblNoYWRvd0hvc3QoZWwpKSB7XG4gICAgICAgICAgaWYgKGV2ZW50LmNvbXBvc2VkICYmIGV2ZW50LmNvbXBvc2VkUGF0aCkge1xuICAgICAgICAgICAgY29uc3QgY29tcG9zZWRQYXRoID0gZXZlbnQuY29tcG9zZWRQYXRoKCk7XG4gICAgICAgICAgICBpZiAoY29tcG9zZWRQYXRoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoZWFkKGNvbXBvc2VkUGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gT3B0aW9uYWwuZnJvbShldmVudC50YXJnZXQpO1xuICAgIH07XG4gICAgY29uc3QgaXNPcGVuU2hhZG93SG9zdCA9IGVsZW1lbnQgPT4gaXNOb25OdWxsYWJsZShlbGVtZW50LmRvbS5zaGFkb3dSb290KTtcblxuICAgIGNvbnN0IGluQm9keSA9IGVsZW1lbnQgPT4ge1xuICAgICAgY29uc3QgZG9tID0gaXNUZXh0JGIoZWxlbWVudCkgPyBlbGVtZW50LmRvbS5wYXJlbnROb2RlIDogZWxlbWVudC5kb207XG4gICAgICBpZiAoZG9tID09PSB1bmRlZmluZWQgfHwgZG9tID09PSBudWxsIHx8IGRvbS5vd25lckRvY3VtZW50ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRvYyA9IGRvbS5vd25lckRvY3VtZW50O1xuICAgICAgcmV0dXJuIGdldFNoYWRvd1Jvb3QoU3VnYXJFbGVtZW50LmZyb21Eb20oZG9tKSkuZm9sZCgoKSA9PiBkb2MuYm9keS5jb250YWlucyhkb20pLCBjb21wb3NlMShpbkJvZHksIGdldFNoYWRvd0hvc3QpKTtcbiAgICB9O1xuXG4gICAgdmFyIENsb3Nlc3RPckFuY2VzdG9yID0gKGlzLCBhbmNlc3Rvciwgc2NvcGUsIGEsIGlzUm9vdCkgPT4ge1xuICAgICAgaWYgKGlzKHNjb3BlLCBhKSkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShzY29wZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24oaXNSb290KSAmJiBpc1Jvb3Qoc2NvcGUpKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYW5jZXN0b3Ioc2NvcGUsIGEsIGlzUm9vdCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGFuY2VzdG9yJDQgPSAoc2NvcGUsIHByZWRpY2F0ZSwgaXNSb290KSA9PiB7XG4gICAgICBsZXQgZWxlbWVudCA9IHNjb3BlLmRvbTtcbiAgICAgIGNvbnN0IHN0b3AgPSBpc0Z1bmN0aW9uKGlzUm9vdCkgPyBpc1Jvb3QgOiBuZXZlcjtcbiAgICAgIHdoaWxlIChlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgY29uc3QgZWwgPSBTdWdhckVsZW1lbnQuZnJvbURvbShlbGVtZW50KTtcbiAgICAgICAgaWYgKHByZWRpY2F0ZShlbCkpIHtcbiAgICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShlbCk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RvcChlbCkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICB9O1xuICAgIGNvbnN0IGNsb3Nlc3QkNCA9IChzY29wZSwgcHJlZGljYXRlLCBpc1Jvb3QpID0+IHtcbiAgICAgIGNvbnN0IGlzID0gKHMsIHRlc3QpID0+IHRlc3Qocyk7XG4gICAgICByZXR1cm4gQ2xvc2VzdE9yQW5jZXN0b3IoaXMsIGFuY2VzdG9yJDQsIHNjb3BlLCBwcmVkaWNhdGUsIGlzUm9vdCk7XG4gICAgfTtcbiAgICBjb25zdCBzaWJsaW5nJDEgPSAoc2NvcGUsIHByZWRpY2F0ZSkgPT4ge1xuICAgICAgY29uc3QgZWxlbWVudCA9IHNjb3BlLmRvbTtcbiAgICAgIGlmICghZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2hpbGQoU3VnYXJFbGVtZW50LmZyb21Eb20oZWxlbWVudC5wYXJlbnROb2RlKSwgeCA9PiAhZXEoc2NvcGUsIHgpICYmIHByZWRpY2F0ZSh4KSk7XG4gICAgfTtcbiAgICBjb25zdCBjaGlsZCA9IChzY29wZSwgcHJlZGljYXRlKSA9PiB7XG4gICAgICBjb25zdCBwcmVkID0gbm9kZSA9PiBwcmVkaWNhdGUoU3VnYXJFbGVtZW50LmZyb21Eb20obm9kZSkpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gZmluZCQyKHNjb3BlLmRvbS5jaGlsZE5vZGVzLCBwcmVkKTtcbiAgICAgIHJldHVybiByZXN1bHQubWFwKFN1Z2FyRWxlbWVudC5mcm9tRG9tKTtcbiAgICB9O1xuICAgIGNvbnN0IGRlc2NlbmRhbnQkMSA9IChzY29wZSwgcHJlZGljYXRlKSA9PiB7XG4gICAgICBjb25zdCBkZXNjZW5kID0gbm9kZSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgY2hpbGQgPSBTdWdhckVsZW1lbnQuZnJvbURvbShub2RlLmNoaWxkTm9kZXNbaV0pO1xuICAgICAgICAgIGlmIChwcmVkaWNhdGUoY2hpbGQpKSB7XG4gICAgICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShjaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHJlcyA9IGRlc2NlbmQobm9kZS5jaGlsZE5vZGVzW2ldKTtcbiAgICAgICAgICBpZiAocmVzLmlzU29tZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBkZXNjZW5kKHNjb3BlLmRvbSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGFuY2VzdG9yJDMgPSAoc2NvcGUsIHNlbGVjdG9yLCBpc1Jvb3QpID0+IGFuY2VzdG9yJDQoc2NvcGUsIGUgPT4gaXMkMShlLCBzZWxlY3RvciksIGlzUm9vdCk7XG4gICAgY29uc3QgZGVzY2VuZGFudCA9IChzY29wZSwgc2VsZWN0b3IpID0+IG9uZShzZWxlY3Rvciwgc2NvcGUpO1xuICAgIGNvbnN0IGNsb3Nlc3QkMyA9IChzY29wZSwgc2VsZWN0b3IsIGlzUm9vdCkgPT4ge1xuICAgICAgY29uc3QgaXMgPSAoZWxlbWVudCwgc2VsZWN0b3IpID0+IGlzJDEoZWxlbWVudCwgc2VsZWN0b3IpO1xuICAgICAgcmV0dXJuIENsb3Nlc3RPckFuY2VzdG9yKGlzLCBhbmNlc3RvciQzLCBzY29wZSwgc2VsZWN0b3IsIGlzUm9vdCk7XG4gICAgfTtcblxuICAgIGNvbnN0IGNsb3Nlc3QkMiA9IHRhcmdldCA9PiBjbG9zZXN0JDModGFyZ2V0LCAnW2NvbnRlbnRlZGl0YWJsZV0nKTtcbiAgICBjb25zdCBpc0VkaXRhYmxlJDMgPSAoZWxlbWVudCwgYXNzdW1lRWRpdGFibGUgPSBmYWxzZSkgPT4ge1xuICAgICAgaWYgKGluQm9keShlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gZWxlbWVudC5kb20uaXNDb250ZW50RWRpdGFibGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY2xvc2VzdCQyKGVsZW1lbnQpLmZvbGQoY29uc3RhbnQoYXNzdW1lRWRpdGFibGUpLCBlZGl0YWJsZSA9PiBnZXRSYXckMShlZGl0YWJsZSkgPT09ICd0cnVlJyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBnZXRSYXckMSA9IGVsZW1lbnQgPT4gZWxlbWVudC5kb20uY29udGVudEVkaXRhYmxlO1xuXG4gICAgY29uc3QgaXNTdXBwb3J0ZWQgPSBkb20gPT4gZG9tLnN0eWxlICE9PSB1bmRlZmluZWQgJiYgaXNGdW5jdGlvbihkb20uc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSk7XG5cbiAgICBjb25zdCBpbnRlcm5hbFNldCA9IChkb20sIHByb3BlcnR5LCB2YWx1ZSkgPT4ge1xuICAgICAgaWYgKCFpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCBjYWxsIHRvIENTUy5zZXQuIFByb3BlcnR5ICcsIHByb3BlcnR5LCAnOjogVmFsdWUgJywgdmFsdWUsICc6OiBFbGVtZW50ICcsIGRvbSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ1NTIHZhbHVlIG11c3QgYmUgYSBzdHJpbmc6ICcgKyB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNTdXBwb3J0ZWQoZG9tKSkge1xuICAgICAgICBkb20uc3R5bGUuc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGludGVybmFsUmVtb3ZlID0gKGRvbSwgcHJvcGVydHkpID0+IHtcbiAgICAgIGlmIChpc1N1cHBvcnRlZChkb20pKSB7XG4gICAgICAgIGRvbS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzZXQkMiA9IChlbGVtZW50LCBwcm9wZXJ0eSwgdmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IGRvbSA9IGVsZW1lbnQuZG9tO1xuICAgICAgaW50ZXJuYWxTZXQoZG9tLCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgIH07XG4gICAgY29uc3Qgc2V0QWxsID0gKGVsZW1lbnQsIGNzcykgPT4ge1xuICAgICAgY29uc3QgZG9tID0gZWxlbWVudC5kb207XG4gICAgICBlYWNoJGQoY3NzLCAodiwgaykgPT4ge1xuICAgICAgICBpbnRlcm5hbFNldChkb20sIGssIHYpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBnZXQkNyA9IChlbGVtZW50LCBwcm9wZXJ0eSkgPT4ge1xuICAgICAgY29uc3QgZG9tID0gZWxlbWVudC5kb207XG4gICAgICBjb25zdCBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb20pO1xuICAgICAgY29uc3QgciA9IHN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcbiAgICAgIHJldHVybiByID09PSAnJyAmJiAhaW5Cb2R5KGVsZW1lbnQpID8gZ2V0VW5zYWZlUHJvcGVydHkoZG9tLCBwcm9wZXJ0eSkgOiByO1xuICAgIH07XG4gICAgY29uc3QgZ2V0VW5zYWZlUHJvcGVydHkgPSAoZG9tLCBwcm9wZXJ0eSkgPT4gaXNTdXBwb3J0ZWQoZG9tKSA/IGRvbS5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KSA6ICcnO1xuICAgIGNvbnN0IGdldFJhdyA9IChlbGVtZW50LCBwcm9wZXJ0eSkgPT4ge1xuICAgICAgY29uc3QgZG9tID0gZWxlbWVudC5kb207XG4gICAgICBjb25zdCByYXcgPSBnZXRVbnNhZmVQcm9wZXJ0eShkb20sIHByb3BlcnR5KTtcbiAgICAgIHJldHVybiBPcHRpb25hbC5mcm9tKHJhdykuZmlsdGVyKHIgPT4gci5sZW5ndGggPiAwKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldEFsbFJhdyA9IGVsZW1lbnQgPT4ge1xuICAgICAgY29uc3QgY3NzID0ge307XG4gICAgICBjb25zdCBkb20gPSBlbGVtZW50LmRvbTtcbiAgICAgIGlmIChpc1N1cHBvcnRlZChkb20pKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZG9tLnN0eWxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgcnVsZU5hbWUgPSBkb20uc3R5bGUuaXRlbShpKTtcbiAgICAgICAgICBjc3NbcnVsZU5hbWVdID0gZG9tLnN0eWxlW3J1bGVOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNzcztcbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZSQ3ID0gKGVsZW1lbnQsIHByb3BlcnR5KSA9PiB7XG4gICAgICBjb25zdCBkb20gPSBlbGVtZW50LmRvbTtcbiAgICAgIGludGVybmFsUmVtb3ZlKGRvbSwgcHJvcGVydHkpO1xuICAgICAgaWYgKGlzJDIoZ2V0T3B0KGVsZW1lbnQsICdzdHlsZScpLm1hcCh0cmltJDMpLCAnJykpIHtcbiAgICAgICAgcmVtb3ZlJGIoZWxlbWVudCwgJ3N0eWxlJyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZWZsb3cgPSBlID0+IGUuZG9tLm9mZnNldFdpZHRoO1xuXG4gICAgY29uc3QgYmVmb3JlJDMgPSAobWFya2VyLCBlbGVtZW50KSA9PiB7XG4gICAgICBjb25zdCBwYXJlbnQkMSA9IHBhcmVudChtYXJrZXIpO1xuICAgICAgcGFyZW50JDEuZWFjaCh2ID0+IHtcbiAgICAgICAgdi5kb20uaW5zZXJ0QmVmb3JlKGVsZW1lbnQuZG9tLCBtYXJrZXIuZG9tKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgYWZ0ZXIkNCA9IChtYXJrZXIsIGVsZW1lbnQpID0+IHtcbiAgICAgIGNvbnN0IHNpYmxpbmcgPSBuZXh0U2libGluZyhtYXJrZXIpO1xuICAgICAgc2libGluZy5mb2xkKCgpID0+IHtcbiAgICAgICAgY29uc3QgcGFyZW50JDEgPSBwYXJlbnQobWFya2VyKTtcbiAgICAgICAgcGFyZW50JDEuZWFjaCh2ID0+IHtcbiAgICAgICAgICBhcHBlbmQkMSh2LCBlbGVtZW50KTtcbiAgICAgICAgfSk7XG4gICAgICB9LCB2ID0+IHtcbiAgICAgICAgYmVmb3JlJDModiwgZWxlbWVudCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHByZXBlbmQgPSAocGFyZW50LCBlbGVtZW50KSA9PiB7XG4gICAgICBjb25zdCBmaXJzdENoaWxkJDEgPSBmaXJzdENoaWxkKHBhcmVudCk7XG4gICAgICBmaXJzdENoaWxkJDEuZm9sZCgoKSA9PiB7XG4gICAgICAgIGFwcGVuZCQxKHBhcmVudCwgZWxlbWVudCk7XG4gICAgICB9LCB2ID0+IHtcbiAgICAgICAgcGFyZW50LmRvbS5pbnNlcnRCZWZvcmUoZWxlbWVudC5kb20sIHYuZG9tKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgYXBwZW5kJDEgPSAocGFyZW50LCBlbGVtZW50KSA9PiB7XG4gICAgICBwYXJlbnQuZG9tLmFwcGVuZENoaWxkKGVsZW1lbnQuZG9tKTtcbiAgICB9O1xuICAgIGNvbnN0IHdyYXAkMiA9IChlbGVtZW50LCB3cmFwcGVyKSA9PiB7XG4gICAgICBiZWZvcmUkMyhlbGVtZW50LCB3cmFwcGVyKTtcbiAgICAgIGFwcGVuZCQxKHdyYXBwZXIsIGVsZW1lbnQpO1xuICAgIH07XG5cbiAgICBjb25zdCBhZnRlciQzID0gKG1hcmtlciwgZWxlbWVudHMpID0+IHtcbiAgICAgIGVhY2gkZShlbGVtZW50cywgKHgsIGkpID0+IHtcbiAgICAgICAgY29uc3QgZSA9IGkgPT09IDAgPyBtYXJrZXIgOiBlbGVtZW50c1tpIC0gMV07XG4gICAgICAgIGFmdGVyJDQoZSwgeCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGFwcGVuZCA9IChwYXJlbnQsIGVsZW1lbnRzKSA9PiB7XG4gICAgICBlYWNoJGUoZWxlbWVudHMsIHggPT4ge1xuICAgICAgICBhcHBlbmQkMShwYXJlbnQsIHgpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGVtcHR5ID0gZWxlbWVudCA9PiB7XG4gICAgICBlbGVtZW50LmRvbS50ZXh0Q29udGVudCA9ICcnO1xuICAgICAgZWFjaCRlKGNoaWxkcmVuJDEoZWxlbWVudCksIHJvZ3VlID0+IHtcbiAgICAgICAgcmVtb3ZlJDYocm9ndWUpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmUkNiA9IGVsZW1lbnQgPT4ge1xuICAgICAgY29uc3QgZG9tID0gZWxlbWVudC5kb207XG4gICAgICBpZiAoZG9tLnBhcmVudE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgZG9tLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZG9tKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHVud3JhcCA9IHdyYXBwZXIgPT4ge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBjaGlsZHJlbiQxKHdyYXBwZXIpO1xuICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYWZ0ZXIkMyh3cmFwcGVyLCBjaGlsZHJlbik7XG4gICAgICB9XG4gICAgICByZW1vdmUkNih3cmFwcGVyKTtcbiAgICB9O1xuXG4gICAgY29uc3QgZnJvbUh0bWwgPSAoaHRtbCwgc2NvcGUpID0+IHtcbiAgICAgIGNvbnN0IGRvYyA9IHNjb3BlIHx8IGRvY3VtZW50O1xuICAgICAgY29uc3QgZGl2ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZGl2LmlubmVySFRNTCA9IGh0bWw7XG4gICAgICByZXR1cm4gY2hpbGRyZW4kMShTdWdhckVsZW1lbnQuZnJvbURvbShkaXYpKTtcbiAgICB9O1xuICAgIGNvbnN0IGZyb21Eb20kMSA9IG5vZGVzID0+IG1hcCQzKG5vZGVzLCBTdWdhckVsZW1lbnQuZnJvbURvbSk7XG5cbiAgICBjb25zdCBnZXQkNiA9IGVsZW1lbnQgPT4gZWxlbWVudC5kb20uaW5uZXJIVE1MO1xuICAgIGNvbnN0IHNldCQxID0gKGVsZW1lbnQsIGNvbnRlbnQpID0+IHtcbiAgICAgIGNvbnN0IG93bmVyID0gb3duZXIkMShlbGVtZW50KTtcbiAgICAgIGNvbnN0IGRvY0RvbSA9IG93bmVyLmRvbTtcbiAgICAgIGNvbnN0IGZyYWdtZW50ID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZG9jRG9tLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSk7XG4gICAgICBjb25zdCBjb250ZW50RWxlbWVudHMgPSBmcm9tSHRtbChjb250ZW50LCBkb2NEb20pO1xuICAgICAgYXBwZW5kKGZyYWdtZW50LCBjb250ZW50RWxlbWVudHMpO1xuICAgICAgZW1wdHkoZWxlbWVudCk7XG4gICAgICBhcHBlbmQkMShlbGVtZW50LCBmcmFnbWVudCk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRPdXRlciA9IGVsZW1lbnQgPT4ge1xuICAgICAgY29uc3QgY29udGFpbmVyID0gU3VnYXJFbGVtZW50LmZyb21UYWcoJ2RpdicpO1xuICAgICAgY29uc3QgY2xvbmUgPSBTdWdhckVsZW1lbnQuZnJvbURvbShlbGVtZW50LmRvbS5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgICAgYXBwZW5kJDEoY29udGFpbmVyLCBjbG9uZSk7XG4gICAgICByZXR1cm4gZ2V0JDYoY29udGFpbmVyKTtcbiAgICB9O1xuXG4gICAgY29uc3QgbWtFdmVudCA9ICh0YXJnZXQsIHgsIHksIHN0b3AsIHByZXZlbnQsIGtpbGwsIHJhdykgPT4gKHtcbiAgICAgIHRhcmdldCxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgc3RvcCxcbiAgICAgIHByZXZlbnQsXG4gICAgICBraWxsLFxuICAgICAgcmF3XG4gICAgfSk7XG4gICAgY29uc3QgZnJvbVJhd0V2ZW50ID0gcmF3RXZlbnQgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZ2V0T3JpZ2luYWxFdmVudFRhcmdldChyYXdFdmVudCkuZ2V0T3IocmF3RXZlbnQudGFyZ2V0KSk7XG4gICAgICBjb25zdCBzdG9wID0gKCkgPT4gcmF3RXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBjb25zdCBwcmV2ZW50ID0gKCkgPT4gcmF3RXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNvbnN0IGtpbGwgPSBjb21wb3NlKHByZXZlbnQsIHN0b3ApO1xuICAgICAgcmV0dXJuIG1rRXZlbnQodGFyZ2V0LCByYXdFdmVudC5jbGllbnRYLCByYXdFdmVudC5jbGllbnRZLCBzdG9wLCBwcmV2ZW50LCBraWxsLCByYXdFdmVudCk7XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGUkMSA9IChmaWx0ZXIsIGhhbmRsZXIpID0+IHJhd0V2ZW50ID0+IHtcbiAgICAgIGlmIChmaWx0ZXIocmF3RXZlbnQpKSB7XG4gICAgICAgIGhhbmRsZXIoZnJvbVJhd0V2ZW50KHJhd0V2ZW50KSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBiaW5kZXIgPSAoZWxlbWVudCwgZXZlbnQsIGZpbHRlciwgaGFuZGxlciwgdXNlQ2FwdHVyZSkgPT4ge1xuICAgICAgY29uc3Qgd3JhcHBlZCA9IGhhbmRsZSQxKGZpbHRlciwgaGFuZGxlcik7XG4gICAgICBlbGVtZW50LmRvbS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCB3cmFwcGVkLCB1c2VDYXB0dXJlKTtcbiAgICAgIHJldHVybiB7IHVuYmluZDogY3VycnkodW5iaW5kLCBlbGVtZW50LCBldmVudCwgd3JhcHBlZCwgdXNlQ2FwdHVyZSkgfTtcbiAgICB9O1xuICAgIGNvbnN0IGJpbmQkMiA9IChlbGVtZW50LCBldmVudCwgZmlsdGVyLCBoYW5kbGVyKSA9PiBiaW5kZXIoZWxlbWVudCwgZXZlbnQsIGZpbHRlciwgaGFuZGxlciwgZmFsc2UpO1xuICAgIGNvbnN0IHVuYmluZCA9IChlbGVtZW50LCBldmVudCwgaGFuZGxlciwgdXNlQ2FwdHVyZSkgPT4ge1xuICAgICAgZWxlbWVudC5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgdXNlQ2FwdHVyZSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHIgPSAobGVmdCwgdG9wKSA9PiB7XG4gICAgICBjb25zdCB0cmFuc2xhdGUgPSAoeCwgeSkgPT4gcihsZWZ0ICsgeCwgdG9wICsgeSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0LFxuICAgICAgICB0b3AsXG4gICAgICAgIHRyYW5zbGF0ZVxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IFN1Z2FyUG9zaXRpb24gPSByO1xuXG4gICAgY29uc3QgYm94UG9zaXRpb24gPSBkb20gPT4ge1xuICAgICAgY29uc3QgYm94ID0gZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgcmV0dXJuIFN1Z2FyUG9zaXRpb24oYm94LmxlZnQsIGJveC50b3ApO1xuICAgIH07XG4gICAgY29uc3QgZmlyc3REZWZpbmVkT3JaZXJvID0gKGEsIGIpID0+IHtcbiAgICAgIGlmIChhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYiAhPT0gdW5kZWZpbmVkID8gYiA6IDA7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBhYnNvbHV0ZSA9IGVsZW1lbnQgPT4ge1xuICAgICAgY29uc3QgZG9jID0gZWxlbWVudC5kb20ub3duZXJEb2N1bWVudDtcbiAgICAgIGNvbnN0IGJvZHkgPSBkb2MuYm9keTtcbiAgICAgIGNvbnN0IHdpbiA9IGRvYy5kZWZhdWx0VmlldztcbiAgICAgIGNvbnN0IGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgaWYgKGJvZHkgPT09IGVsZW1lbnQuZG9tKSB7XG4gICAgICAgIHJldHVybiBTdWdhclBvc2l0aW9uKGJvZHkub2Zmc2V0TGVmdCwgYm9keS5vZmZzZXRUb3ApO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2Nyb2xsVG9wID0gZmlyc3REZWZpbmVkT3JaZXJvKHdpbiA9PT0gbnVsbCB8fCB3aW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbi5wYWdlWU9mZnNldCwgaHRtbC5zY3JvbGxUb3ApO1xuICAgICAgY29uc3Qgc2Nyb2xsTGVmdCA9IGZpcnN0RGVmaW5lZE9yWmVybyh3aW4gPT09IG51bGwgfHwgd2luID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aW4ucGFnZVhPZmZzZXQsIGh0bWwuc2Nyb2xsTGVmdCk7XG4gICAgICBjb25zdCBjbGllbnRUb3AgPSBmaXJzdERlZmluZWRPclplcm8oaHRtbC5jbGllbnRUb3AsIGJvZHkuY2xpZW50VG9wKTtcbiAgICAgIGNvbnN0IGNsaWVudExlZnQgPSBmaXJzdERlZmluZWRPclplcm8oaHRtbC5jbGllbnRMZWZ0LCBib2R5LmNsaWVudExlZnQpO1xuICAgICAgcmV0dXJuIHZpZXdwb3J0KGVsZW1lbnQpLnRyYW5zbGF0ZShzY3JvbGxMZWZ0IC0gY2xpZW50TGVmdCwgc2Nyb2xsVG9wIC0gY2xpZW50VG9wKTtcbiAgICB9O1xuICAgIGNvbnN0IHZpZXdwb3J0ID0gZWxlbWVudCA9PiB7XG4gICAgICBjb25zdCBkb20gPSBlbGVtZW50LmRvbTtcbiAgICAgIGNvbnN0IGRvYyA9IGRvbS5vd25lckRvY3VtZW50O1xuICAgICAgY29uc3QgYm9keSA9IGRvYy5ib2R5O1xuICAgICAgaWYgKGJvZHkgPT09IGRvbSkge1xuICAgICAgICByZXR1cm4gU3VnYXJQb3NpdGlvbihib2R5Lm9mZnNldExlZnQsIGJvZHkub2Zmc2V0VG9wKTtcbiAgICAgIH1cbiAgICAgIGlmICghaW5Cb2R5KGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBTdWdhclBvc2l0aW9uKDAsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJveFBvc2l0aW9uKGRvbSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGdldCQ1ID0gX0RPQyA9PiB7XG4gICAgICBjb25zdCBkb2MgPSBfRE9DICE9PSB1bmRlZmluZWQgPyBfRE9DLmRvbSA6IGRvY3VtZW50O1xuICAgICAgY29uc3QgeCA9IGRvYy5ib2R5LnNjcm9sbExlZnQgfHwgZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0O1xuICAgICAgY29uc3QgeSA9IGRvYy5ib2R5LnNjcm9sbFRvcCB8fCBkb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgIHJldHVybiBTdWdhclBvc2l0aW9uKHgsIHkpO1xuICAgIH07XG4gICAgY29uc3QgaW50b1ZpZXcgPSAoZWxlbWVudCwgYWxpZ25Ub1RvcCkgPT4ge1xuICAgICAgY29uc3QgaXNTYWZhcmkgPSBkZXRlY3QkMigpLmJyb3dzZXIuaXNTYWZhcmkoKTtcbiAgICAgIGlmIChpc1NhZmFyaSAmJiBpc0Z1bmN0aW9uKGVsZW1lbnQuZG9tLnNjcm9sbEludG9WaWV3SWZOZWVkZWQpKSB7XG4gICAgICAgIGVsZW1lbnQuZG9tLnNjcm9sbEludG9WaWV3SWZOZWVkZWQoZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5kb20uc2Nyb2xsSW50b1ZpZXcoYWxpZ25Ub1RvcCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGdldCQ0ID0gX3dpbiA9PiB7XG4gICAgICBjb25zdCB3aW4gPSBfd2luID09PSB1bmRlZmluZWQgPyB3aW5kb3cgOiBfd2luO1xuICAgICAgaWYgKGRldGVjdCQyKCkuYnJvd3Nlci5pc0ZpcmVmb3goKSkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLmZyb20od2luLnZpc3VhbFZpZXdwb3J0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGJvdW5kcyA9ICh4LCB5LCB3aWR0aCwgaGVpZ2h0KSA9PiAoe1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHJpZ2h0OiB4ICsgd2lkdGgsXG4gICAgICBib3R0b206IHkgKyBoZWlnaHRcbiAgICB9KTtcbiAgICBjb25zdCBnZXRCb3VuZHMgPSBfd2luID0+IHtcbiAgICAgIGNvbnN0IHdpbiA9IF93aW4gPT09IHVuZGVmaW5lZCA/IHdpbmRvdyA6IF93aW47XG4gICAgICBjb25zdCBkb2MgPSB3aW4uZG9jdW1lbnQ7XG4gICAgICBjb25zdCBzY3JvbGwgPSBnZXQkNShTdWdhckVsZW1lbnQuZnJvbURvbShkb2MpKTtcbiAgICAgIHJldHVybiBnZXQkNCh3aW4pLmZvbGQoKCkgPT4ge1xuICAgICAgICBjb25zdCBodG1sID0gd2luLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBodG1sLmNsaWVudFdpZHRoO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBodG1sLmNsaWVudEhlaWdodDtcbiAgICAgICAgcmV0dXJuIGJvdW5kcyhzY3JvbGwubGVmdCwgc2Nyb2xsLnRvcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9LCB2aXN1YWxWaWV3cG9ydCA9PiBib3VuZHMoTWF0aC5tYXgodmlzdWFsVmlld3BvcnQucGFnZUxlZnQsIHNjcm9sbC5sZWZ0KSwgTWF0aC5tYXgodmlzdWFsVmlld3BvcnQucGFnZVRvcCwgc2Nyb2xsLnRvcCksIHZpc3VhbFZpZXdwb3J0LndpZHRoLCB2aXN1YWxWaWV3cG9ydC5oZWlnaHQpKTtcbiAgICB9O1xuXG4gICAgY29uc3QgY2hpbGRyZW4gPSAoc2NvcGUsIHByZWRpY2F0ZSkgPT4gZmlsdGVyJDUoY2hpbGRyZW4kMShzY29wZSksIHByZWRpY2F0ZSk7XG4gICAgY29uc3QgZGVzY2VuZGFudHMkMSA9IChzY29wZSwgcHJlZGljYXRlKSA9PiB7XG4gICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICBlYWNoJGUoY2hpbGRyZW4kMShzY29wZSksIHggPT4ge1xuICAgICAgICBpZiAocHJlZGljYXRlKHgpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChbeF0pO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoZGVzY2VuZGFudHMkMSh4LCBwcmVkaWNhdGUpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgY29uc3QgZGVzY2VuZGFudHMgPSAoc2NvcGUsIHNlbGVjdG9yKSA9PiBhbGwoc2VsZWN0b3IsIHNjb3BlKTtcblxuICAgIGNvbnN0IGFuY2VzdG9yJDIgPSAoc2NvcGUsIHNlbGVjdG9yLCBpc1Jvb3QpID0+IGFuY2VzdG9yJDMoc2NvcGUsIHNlbGVjdG9yLCBpc1Jvb3QpLmlzU29tZSgpO1xuXG4gICAgY2xhc3MgRG9tVHJlZVdhbGtlciB7XG4gICAgICBjb25zdHJ1Y3RvcihzdGFydE5vZGUsIHJvb3ROb2RlKSB7XG4gICAgICAgIHRoaXMubm9kZSA9IHN0YXJ0Tm9kZTtcbiAgICAgICAgdGhpcy5yb290Tm9kZSA9IHJvb3ROb2RlO1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLmN1cnJlbnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5uZXh0ID0gdGhpcy5uZXh0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucHJldiA9IHRoaXMucHJldi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnByZXYyID0gdGhpcy5wcmV2Mi5iaW5kKHRoaXMpO1xuICAgICAgfVxuICAgICAgY3VycmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZTtcbiAgICAgIH1cbiAgICAgIG5leHQoc2hhbGxvdykge1xuICAgICAgICB0aGlzLm5vZGUgPSB0aGlzLmZpbmRTaWJsaW5nKHRoaXMubm9kZSwgJ2ZpcnN0Q2hpbGQnLCAnbmV4dFNpYmxpbmcnLCBzaGFsbG93KTtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZTtcbiAgICAgIH1cbiAgICAgIHByZXYoc2hhbGxvdykge1xuICAgICAgICB0aGlzLm5vZGUgPSB0aGlzLmZpbmRTaWJsaW5nKHRoaXMubm9kZSwgJ2xhc3RDaGlsZCcsICdwcmV2aW91c1NpYmxpbmcnLCBzaGFsbG93KTtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZTtcbiAgICAgIH1cbiAgICAgIHByZXYyKHNoYWxsb3cpIHtcbiAgICAgICAgdGhpcy5ub2RlID0gdGhpcy5maW5kUHJldmlvdXNOb2RlKHRoaXMubm9kZSwgc2hhbGxvdyk7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGU7XG4gICAgICB9XG4gICAgICBmaW5kU2libGluZyhub2RlLCBzdGFydE5hbWUsIHNpYmxpbmdOYW1lLCBzaGFsbG93KSB7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgaWYgKCFzaGFsbG93ICYmIG5vZGVbc3RhcnROYW1lXSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGVbc3RhcnROYW1lXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5vZGUgIT09IHRoaXMucm9vdE5vZGUpIHtcbiAgICAgICAgICAgIGxldCBzaWJsaW5nID0gbm9kZVtzaWJsaW5nTmFtZV07XG4gICAgICAgICAgICBpZiAoc2libGluZykge1xuICAgICAgICAgICAgICByZXR1cm4gc2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTsgcGFyZW50ICYmIHBhcmVudCAhPT0gdGhpcy5yb290Tm9kZTsgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgc2libGluZyA9IHBhcmVudFtzaWJsaW5nTmFtZV07XG4gICAgICAgICAgICAgIGlmIChzaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGZpbmRQcmV2aW91c05vZGUobm9kZSwgc2hhbGxvdykge1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICBpZiAodGhpcy5yb290Tm9kZSAmJiBzaWJsaW5nID09PSB0aGlzLnJvb3ROb2RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzaWJsaW5nKSB7XG4gICAgICAgICAgICBpZiAoIXNoYWxsb3cpIHtcbiAgICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgPSBzaWJsaW5nLmxhc3RDaGlsZDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubGFzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGlsZC5sYXN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzaWJsaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQgIT09IHRoaXMucm9vdE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaXNOb2RlVHlwZSA9IHR5cGUgPT4ge1xuICAgICAgcmV0dXJuIG5vZGUgPT4ge1xuICAgICAgICByZXR1cm4gISFub2RlICYmIG5vZGUubm9kZVR5cGUgPT09IHR5cGU7XG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgaXNSZXN0cmljdGVkTm9kZSA9IG5vZGUgPT4gISFub2RlICYmICFPYmplY3QuZ2V0UHJvdG90eXBlT2Yobm9kZSk7XG4gICAgY29uc3QgaXNFbGVtZW50JDYgPSBpc05vZGVUeXBlKDEpO1xuICAgIGNvbnN0IG1hdGNoTm9kZU5hbWUgPSBuYW1lID0+IHtcbiAgICAgIGNvbnN0IGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgcmV0dXJuIG5vZGUgPT4gaXNOb25OdWxsYWJsZShub2RlKSAmJiBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IGxvd2VyQ2FzZWROYW1lO1xuICAgIH07XG4gICAgY29uc3QgbWF0Y2hOb2RlTmFtZXMgPSBuYW1lcyA9PiB7XG4gICAgICBjb25zdCBsb3dlckNhc2VkTmFtZXMgPSBuYW1lcy5tYXAocyA9PiBzLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgcmV0dXJuIG5vZGUgPT4ge1xuICAgICAgICBpZiAobm9kZSAmJiBub2RlLm5vZGVOYW1lKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZU5hbWUgPSBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgcmV0dXJuIGNvbnRhaW5zJDIobG93ZXJDYXNlZE5hbWVzLCBub2RlTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IG1hdGNoU3R5bGVWYWx1ZXMgPSAobmFtZSwgdmFsdWVzKSA9PiB7XG4gICAgICBjb25zdCBpdGVtcyA9IHZhbHVlcy50b0xvd2VyQ2FzZSgpLnNwbGl0KCcgJyk7XG4gICAgICByZXR1cm4gbm9kZSA9PiB7XG4gICAgICAgIGlmIChpc0VsZW1lbnQkNihub2RlKSkge1xuICAgICAgICAgIGNvbnN0IHdpbiA9IG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICAgICAgICBpZiAod2luKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNvbXB1dGVkID0gd2luLmdldENvbXB1dGVkU3R5bGUobm9kZSwgbnVsbCk7XG4gICAgICAgICAgICAgIGNvbnN0IGNzc1ZhbHVlID0gY29tcHV0ZWQgPyBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpIDogbnVsbDtcbiAgICAgICAgICAgICAgaWYgKGNzc1ZhbHVlID09PSBpdGVtc1tpXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBoYXNBdHRyaWJ1dGUgPSBhdHRyTmFtZSA9PiB7XG4gICAgICByZXR1cm4gbm9kZSA9PiB7XG4gICAgICAgIHJldHVybiBpc0VsZW1lbnQkNihub2RlKSAmJiBub2RlLmhhc0F0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgaGFzQXR0cmlidXRlVmFsdWUgPSAoYXR0ck5hbWUsIGF0dHJWYWx1ZSkgPT4ge1xuICAgICAgcmV0dXJuIG5vZGUgPT4ge1xuICAgICAgICByZXR1cm4gaXNFbGVtZW50JDYobm9kZSkgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpID09PSBhdHRyVmFsdWU7XG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgaXNCb2d1cyQyID0gbm9kZSA9PiBpc0VsZW1lbnQkNihub2RlKSAmJiBub2RlLmhhc0F0dHJpYnV0ZSgnZGF0YS1tY2UtYm9ndXMnKTtcbiAgICBjb25zdCBpc0JvZ3VzQWxsJDEgPSBub2RlID0+IGlzRWxlbWVudCQ2KG5vZGUpICYmIG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLW1jZS1ib2d1cycpID09PSAnYWxsJztcbiAgICBjb25zdCBpc1RhYmxlJDIgPSBub2RlID0+IGlzRWxlbWVudCQ2KG5vZGUpICYmIG5vZGUudGFnTmFtZSA9PT0gJ1RBQkxFJztcbiAgICBjb25zdCBoYXNDb250ZW50RWRpdGFibGVTdGF0ZSA9IHZhbHVlID0+IHtcbiAgICAgIHJldHVybiBub2RlID0+IHtcbiAgICAgICAgaWYgKGlzRWxlbWVudCQ2KG5vZGUpKSB7XG4gICAgICAgICAgaWYgKG5vZGUuY29udGVudEVkaXRhYmxlID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChub2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1tY2UtY29udGVudGVkaXRhYmxlJykgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGlzVGV4dGFyZWFPcklucHV0ID0gbWF0Y2hOb2RlTmFtZXMoW1xuICAgICAgJ3RleHRhcmVhJyxcbiAgICAgICdpbnB1dCdcbiAgICBdKTtcbiAgICBjb25zdCBpc1RleHQkYSA9IGlzTm9kZVR5cGUoMyk7XG4gICAgY29uc3QgaXNDRGF0YSA9IGlzTm9kZVR5cGUoNCk7XG4gICAgY29uc3QgaXNQaSA9IGlzTm9kZVR5cGUoNyk7XG4gICAgY29uc3QgaXNDb21tZW50ID0gaXNOb2RlVHlwZSg4KTtcbiAgICBjb25zdCBpc0RvY3VtZW50JDEgPSBpc05vZGVUeXBlKDkpO1xuICAgIGNvbnN0IGlzRG9jdW1lbnRGcmFnbWVudCA9IGlzTm9kZVR5cGUoMTEpO1xuICAgIGNvbnN0IGlzQnIkNiA9IG1hdGNoTm9kZU5hbWUoJ2JyJyk7XG4gICAgY29uc3QgaXNJbWcgPSBtYXRjaE5vZGVOYW1lKCdpbWcnKTtcbiAgICBjb25zdCBpc0NvbnRlbnRFZGl0YWJsZVRydWUkMyA9IGhhc0NvbnRlbnRFZGl0YWJsZVN0YXRlKCd0cnVlJyk7XG4gICAgY29uc3QgaXNDb250ZW50RWRpdGFibGVGYWxzZSRiID0gaGFzQ29udGVudEVkaXRhYmxlU3RhdGUoJ2ZhbHNlJyk7XG4gICAgY29uc3QgaXNUYWJsZUNlbGwkMyA9IG1hdGNoTm9kZU5hbWVzKFtcbiAgICAgICd0ZCcsXG4gICAgICAndGgnXG4gICAgXSk7XG4gICAgY29uc3QgaXNUYWJsZUNlbGxPckNhcHRpb24gPSBtYXRjaE5vZGVOYW1lcyhbXG4gICAgICAndGQnLFxuICAgICAgJ3RoJyxcbiAgICAgICdjYXB0aW9uJ1xuICAgIF0pO1xuICAgIGNvbnN0IGlzTWVkaWEkMiA9IG1hdGNoTm9kZU5hbWVzKFtcbiAgICAgICd2aWRlbycsXG4gICAgICAnYXVkaW8nLFxuICAgICAgJ29iamVjdCcsXG4gICAgICAnZW1iZWQnXG4gICAgXSk7XG4gICAgY29uc3QgaXNMaXN0SXRlbSQyID0gbWF0Y2hOb2RlTmFtZSgnbGknKTtcblxuICAgIGNvbnN0IHplcm9XaWR0aCA9ICdcXHVGRUZGJztcbiAgICBjb25zdCBuYnNwID0gJ1xceEEwJztcbiAgICBjb25zdCBpc1p3c3AkMSA9IGNoYXIgPT4gY2hhciA9PT0gemVyb1dpZHRoO1xuICAgIGNvbnN0IHJlbW92ZVp3c3AgPSBzID0+IHMucmVwbGFjZSgvXFx1RkVGRi9nLCAnJyk7XG5cbiAgICBjb25zdCBOb2RlVmFsdWUgPSAoaXMsIG5hbWUpID0+IHtcbiAgICAgIGNvbnN0IGdldCA9IGVsZW1lbnQgPT4ge1xuICAgICAgICBpZiAoIWlzKGVsZW1lbnQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gb25seSBnZXQgJyArIG5hbWUgKyAnIHZhbHVlIG9mIGEgJyArIG5hbWUgKyAnIG5vZGUnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0T3B0aW9uKGVsZW1lbnQpLmdldE9yKCcnKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBnZXRPcHRpb24gPSBlbGVtZW50ID0+IGlzKGVsZW1lbnQpID8gT3B0aW9uYWwuZnJvbShlbGVtZW50LmRvbS5ub2RlVmFsdWUpIDogT3B0aW9uYWwubm9uZSgpO1xuICAgICAgY29uc3Qgc2V0ID0gKGVsZW1lbnQsIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICghaXMoZWxlbWVudCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBvbmx5IHNldCByYXcgJyArIG5hbWUgKyAnIHZhbHVlIG9mIGEgJyArIG5hbWUgKyAnIG5vZGUnKTtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50LmRvbS5ub2RlVmFsdWUgPSB2YWx1ZTtcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBnZXQsXG4gICAgICAgIGdldE9wdGlvbixcbiAgICAgICAgc2V0XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBhcGkkMSA9IE5vZGVWYWx1ZShpc1RleHQkYiwgJ3RleHQnKTtcbiAgICBjb25zdCBnZXQkMyA9IGVsZW1lbnQgPT4gYXBpJDEuZ2V0KGVsZW1lbnQpO1xuICAgIGNvbnN0IGdldE9wdGlvbiA9IGVsZW1lbnQgPT4gYXBpJDEuZ2V0T3B0aW9uKGVsZW1lbnQpO1xuICAgIGNvbnN0IHNldCA9IChlbGVtZW50LCB2YWx1ZSkgPT4gYXBpJDEuc2V0KGVsZW1lbnQsIHZhbHVlKTtcblxuICAgIGNvbnN0IGJsb2NrcyA9IFtcbiAgICAgICdhcnRpY2xlJyxcbiAgICAgICdhc2lkZScsXG4gICAgICAnZGV0YWlscycsXG4gICAgICAnZGl2JyxcbiAgICAgICdkdCcsXG4gICAgICAnZmlnY2FwdGlvbicsXG4gICAgICAnZm9vdGVyJyxcbiAgICAgICdmb3JtJyxcbiAgICAgICdmaWVsZHNldCcsXG4gICAgICAnaGVhZGVyJyxcbiAgICAgICdoZ3JvdXAnLFxuICAgICAgJ2h0bWwnLFxuICAgICAgJ21haW4nLFxuICAgICAgJ25hdicsXG4gICAgICAnc2VjdGlvbicsXG4gICAgICAnc3VtbWFyeScsXG4gICAgICAnYm9keScsXG4gICAgICAncCcsXG4gICAgICAnZGwnLFxuICAgICAgJ211bHRpY29sJyxcbiAgICAgICdkZCcsXG4gICAgICAnZmlndXJlJyxcbiAgICAgICdhZGRyZXNzJyxcbiAgICAgICdjZW50ZXInLFxuICAgICAgJ2Jsb2NrcXVvdGUnLFxuICAgICAgJ2gxJyxcbiAgICAgICdoMicsXG4gICAgICAnaDMnLFxuICAgICAgJ2g0JyxcbiAgICAgICdoNScsXG4gICAgICAnaDYnLFxuICAgICAgJ2xpc3RpbmcnLFxuICAgICAgJ3htcCcsXG4gICAgICAncHJlJyxcbiAgICAgICdwbGFpbnRleHQnLFxuICAgICAgJ21lbnUnLFxuICAgICAgJ2RpcicsXG4gICAgICAndWwnLFxuICAgICAgJ29sJyxcbiAgICAgICdsaScsXG4gICAgICAnaHInLFxuICAgICAgJ3RhYmxlJyxcbiAgICAgICd0Ym9keScsXG4gICAgICAndGhlYWQnLFxuICAgICAgJ3Rmb290JyxcbiAgICAgICd0aCcsXG4gICAgICAndHInLFxuICAgICAgJ3RkJyxcbiAgICAgICdjYXB0aW9uJ1xuICAgIF07XG4gICAgY29uc3QgdGFibGVDZWxscyA9IFtcbiAgICAgICd0ZCcsXG4gICAgICAndGgnXG4gICAgXTtcbiAgICBjb25zdCB0YWJsZVNlY3Rpb25zID0gW1xuICAgICAgJ3RoZWFkJyxcbiAgICAgICd0Ym9keScsXG4gICAgICAndGZvb3QnXG4gICAgXTtcbiAgICBjb25zdCB0ZXh0QmxvY2tzID0gW1xuICAgICAgJ2gxJyxcbiAgICAgICdoMicsXG4gICAgICAnaDMnLFxuICAgICAgJ2g0JyxcbiAgICAgICdoNScsXG4gICAgICAnaDYnLFxuICAgICAgJ3AnLFxuICAgICAgJ2RpdicsXG4gICAgICAnYWRkcmVzcycsXG4gICAgICAncHJlJyxcbiAgICAgICdmb3JtJyxcbiAgICAgICdibG9ja3F1b3RlJyxcbiAgICAgICdjZW50ZXInLFxuICAgICAgJ2RpcicsXG4gICAgICAnZmllbGRzZXQnLFxuICAgICAgJ2hlYWRlcicsXG4gICAgICAnZm9vdGVyJyxcbiAgICAgICdhcnRpY2xlJyxcbiAgICAgICdzZWN0aW9uJyxcbiAgICAgICdoZ3JvdXAnLFxuICAgICAgJ2FzaWRlJyxcbiAgICAgICduYXYnLFxuICAgICAgJ2ZpZ3VyZSdcbiAgICBdO1xuICAgIGNvbnN0IGhlYWRpbmdzID0gW1xuICAgICAgJ2gxJyxcbiAgICAgICdoMicsXG4gICAgICAnaDMnLFxuICAgICAgJ2g0JyxcbiAgICAgICdoNScsXG4gICAgICAnaDYnXG4gICAgXTtcbiAgICBjb25zdCBsaXN0SXRlbXMkMSA9IFtcbiAgICAgICdsaScsXG4gICAgICAnZGQnLFxuICAgICAgJ2R0J1xuICAgIF07XG4gICAgY29uc3QgbGlzdHMgPSBbXG4gICAgICAndWwnLFxuICAgICAgJ29sJyxcbiAgICAgICdkbCdcbiAgICBdO1xuICAgIGNvbnN0IHdzRWxlbWVudHMgPSBbXG4gICAgICAncHJlJyxcbiAgICAgICdzY3JpcHQnLFxuICAgICAgJ3RleHRhcmVhJyxcbiAgICAgICdzdHlsZSdcbiAgICBdO1xuICAgIGNvbnN0IHdyYXBCbG9ja0VsZW1lbnRzID0gWydwcmUnXS5jb25jYXQoaGVhZGluZ3MpO1xuICAgIGNvbnN0IGxhenlMb29rdXAgPSBpdGVtcyA9PiB7XG4gICAgICBsZXQgbG9va3VwO1xuICAgICAgcmV0dXJuIG5vZGUgPT4ge1xuICAgICAgICBsb29rdXAgPSBsb29rdXAgPyBsb29rdXAgOiBtYXBUb09iamVjdChpdGVtcywgYWx3YXlzKTtcbiAgICAgICAgcmV0dXJuIGhhcyQyKGxvb2t1cCwgbmFtZShub2RlKSk7XG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgaXNCbG9jayQyID0gbGF6eUxvb2t1cChibG9ja3MpO1xuICAgIGNvbnN0IGlzVGFibGUkMSA9IG5vZGUgPT4gbmFtZShub2RlKSA9PT0gJ3RhYmxlJztcbiAgICBjb25zdCBpc0lubGluZSQxID0gbm9kZSA9PiBpc0VsZW1lbnQkNyhub2RlKSAmJiAhaXNCbG9jayQyKG5vZGUpO1xuICAgIGNvbnN0IGlzQnIkNSA9IG5vZGUgPT4gaXNFbGVtZW50JDcobm9kZSkgJiYgbmFtZShub2RlKSA9PT0gJ2JyJztcbiAgICBjb25zdCBpc1RleHRCbG9jayQyID0gbGF6eUxvb2t1cCh0ZXh0QmxvY2tzKTtcbiAgICBjb25zdCBpc0xpc3QgPSBsYXp5TG9va3VwKGxpc3RzKTtcbiAgICBjb25zdCBpc0xpc3RJdGVtJDEgPSBsYXp5TG9va3VwKGxpc3RJdGVtcyQxKTtcbiAgICBjb25zdCBpc1RhYmxlU2VjdGlvbiA9IGxhenlMb29rdXAodGFibGVTZWN0aW9ucyk7XG4gICAgY29uc3QgaXNUYWJsZUNlbGwkMiA9IGxhenlMb29rdXAodGFibGVDZWxscyk7XG4gICAgY29uc3QgaXNXc1ByZXNlcnZlRWxlbWVudCA9IGxhenlMb29rdXAod3NFbGVtZW50cyk7XG4gICAgY29uc3QgaXNXcmFwQmxvY2tFbGVtZW50ID0gbGF6eUxvb2t1cCh3cmFwQmxvY2tFbGVtZW50cyk7XG4gICAgY29uc3QgaXNXcmFwRWxlbWVudCA9IG5vZGUgPT4gaXNXcmFwQmxvY2tFbGVtZW50KG5vZGUpIHx8IGlzSW5saW5lJDEobm9kZSk7XG5cbiAgICBjb25zdCBnZXRMYXN0Q2hpbGRyZW4kMSA9IGVsbSA9PiB7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuICAgICAgbGV0IHJhd05vZGUgPSBlbG0uZG9tO1xuICAgICAgd2hpbGUgKHJhd05vZGUpIHtcbiAgICAgICAgY2hpbGRyZW4ucHVzaChTdWdhckVsZW1lbnQuZnJvbURvbShyYXdOb2RlKSk7XG4gICAgICAgIHJhd05vZGUgPSByYXdOb2RlLmxhc3RDaGlsZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZVRyYWlsaW5nQnIgPSBlbG0gPT4ge1xuICAgICAgY29uc3QgYWxsQnJzID0gZGVzY2VuZGFudHMoZWxtLCAnYnInKTtcbiAgICAgIGNvbnN0IGJycyA9IGZpbHRlciQ1KGdldExhc3RDaGlsZHJlbiQxKGVsbSkuc2xpY2UoLTEpLCBpc0JyJDUpO1xuICAgICAgaWYgKGFsbEJycy5sZW5ndGggPT09IGJycy5sZW5ndGgpIHtcbiAgICAgICAgZWFjaCRlKGJycywgcmVtb3ZlJDYpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgY3JlYXRlUGFkZGluZ0JyID0gKCkgPT4ge1xuICAgICAgY29uc3QgYnIgPSBTdWdhckVsZW1lbnQuZnJvbVRhZygnYnInKTtcbiAgICAgIHNldCQzKGJyLCAnZGF0YS1tY2UtYm9ndXMnLCAnMScpO1xuICAgICAgcmV0dXJuIGJyO1xuICAgIH07XG4gICAgY29uc3QgZmlsbFdpdGhQYWRkaW5nQnIgPSBlbG0gPT4ge1xuICAgICAgZW1wdHkoZWxtKTtcbiAgICAgIGFwcGVuZCQxKGVsbSwgY3JlYXRlUGFkZGluZ0JyKCkpO1xuICAgIH07XG4gICAgY29uc3QgdHJpbUJsb2NrVHJhaWxpbmdCciA9IGVsbSA9PiB7XG4gICAgICBsYXN0Q2hpbGQoZWxtKS5lYWNoKGxhc3RDaGlsZCA9PiB7XG4gICAgICAgIHByZXZTaWJsaW5nKGxhc3RDaGlsZCkuZWFjaChsYXN0Q2hpbGRQcmV2U2libGluZyA9PiB7XG4gICAgICAgICAgaWYgKGlzQmxvY2skMihlbG0pICYmIGlzQnIkNShsYXN0Q2hpbGQpICYmIGlzQmxvY2skMihsYXN0Q2hpbGRQcmV2U2libGluZykpIHtcbiAgICAgICAgICAgIHJlbW92ZSQ2KGxhc3RDaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBaV1NQJDEgPSB6ZXJvV2lkdGg7XG4gICAgY29uc3QgaXNad3NwID0gaXNad3NwJDE7XG4gICAgY29uc3QgdHJpbSQxID0gcmVtb3ZlWndzcDtcblxuICAgIGNvbnN0IGlzRWxlbWVudCQ1ID0gaXNFbGVtZW50JDY7XG4gICAgY29uc3QgaXNUZXh0JDkgPSBpc1RleHQkYTtcbiAgICBjb25zdCBpc0NhcmV0Q29udGFpbmVyQmxvY2skMSA9IG5vZGUgPT4ge1xuICAgICAgaWYgKGlzVGV4dCQ5KG5vZGUpKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNFbGVtZW50JDUobm9kZSkgJiYgbm9kZS5oYXNBdHRyaWJ1dGUoJ2RhdGEtbWNlLWNhcmV0Jyk7XG4gICAgfTtcbiAgICBjb25zdCBpc0NhcmV0Q29udGFpbmVySW5saW5lID0gbm9kZSA9PiBpc1RleHQkOShub2RlKSAmJiBpc1p3c3Aobm9kZS5kYXRhKTtcbiAgICBjb25zdCBpc0NhcmV0Q29udGFpbmVyJDIgPSBub2RlID0+IGlzQ2FyZXRDb250YWluZXJCbG9jayQxKG5vZGUpIHx8IGlzQ2FyZXRDb250YWluZXJJbmxpbmUobm9kZSk7XG4gICAgY29uc3QgaGFzQ29udGVudCA9IG5vZGUgPT4gbm9kZS5maXJzdENoaWxkICE9PSBub2RlLmxhc3RDaGlsZCB8fCAhaXNCciQ2KG5vZGUuZmlyc3RDaGlsZCk7XG4gICAgY29uc3QgaW5zZXJ0SW5saW5lJDEgPSAobm9kZSwgYmVmb3JlKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBkb2MgPSAoX2EgPSBub2RlLm93bmVyRG9jdW1lbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRvY3VtZW50O1xuICAgICAgY29uc3QgdGV4dE5vZGUgPSBkb2MuY3JlYXRlVGV4dE5vZGUoWldTUCQxKTtcbiAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICBpZiAoIWJlZm9yZSkge1xuICAgICAgICBjb25zdCBzaWJsaW5nID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgaWYgKGlzVGV4dCQ5KHNpYmxpbmcpKSB7XG4gICAgICAgICAgaWYgKGlzQ2FyZXRDb250YWluZXIkMihzaWJsaW5nKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGFydHNXaXRoQ2FyZXRDb250YWluZXIkMShzaWJsaW5nKSkge1xuICAgICAgICAgICAgc2libGluZy5zcGxpdFRleHQoMSk7XG4gICAgICAgICAgICByZXR1cm4gc2libGluZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICBwYXJlbnROb2RlID09PSBudWxsIHx8IHBhcmVudE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRleHROb2RlLCBub2RlLm5leHRTaWJsaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJlbnROb2RlID09PSBudWxsIHx8IHBhcmVudE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGV4dE5vZGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzaWJsaW5nID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIGlmIChpc1RleHQkOShzaWJsaW5nKSkge1xuICAgICAgICAgIGlmIChpc0NhcmV0Q29udGFpbmVyJDIoc2libGluZykpIHtcbiAgICAgICAgICAgIHJldHVybiBzaWJsaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZW5kc1dpdGhDYXJldENvbnRhaW5lciQxKHNpYmxpbmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2libGluZy5zcGxpdFRleHQoc2libGluZy5kYXRhLmxlbmd0aCAtIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwYXJlbnROb2RlID09PSBudWxsIHx8IHBhcmVudE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRleHROb2RlLCBub2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ZXh0Tm9kZTtcbiAgICB9O1xuICAgIGNvbnN0IGlzQmVmb3JlSW5saW5lID0gcG9zID0+IHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHBvcy5jb250YWluZXIoKTtcbiAgICAgIGlmICghaXNUZXh0JGEoY29udGFpbmVyKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udGFpbmVyLmRhdGEuY2hhckF0KHBvcy5vZmZzZXQoKSkgPT09IFpXU1AkMSB8fCBwb3MuaXNBdFN0YXJ0KCkgJiYgaXNDYXJldENvbnRhaW5lcklubGluZShjb250YWluZXIucHJldmlvdXNTaWJsaW5nKTtcbiAgICB9O1xuICAgIGNvbnN0IGlzQWZ0ZXJJbmxpbmUgPSBwb3MgPT4ge1xuICAgICAgY29uc3QgY29udGFpbmVyID0gcG9zLmNvbnRhaW5lcigpO1xuICAgICAgaWYgKCFpc1RleHQkYShjb250YWluZXIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250YWluZXIuZGF0YS5jaGFyQXQocG9zLm9mZnNldCgpIC0gMSkgPT09IFpXU1AkMSB8fCBwb3MuaXNBdEVuZCgpICYmIGlzQ2FyZXRDb250YWluZXJJbmxpbmUoY29udGFpbmVyLm5leHRTaWJsaW5nKTtcbiAgICB9O1xuICAgIGNvbnN0IGluc2VydEJsb2NrID0gKGJsb2NrTmFtZSwgbm9kZSwgYmVmb3JlKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBkb2MgPSAoX2EgPSBub2RlLm93bmVyRG9jdW1lbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRvY3VtZW50O1xuICAgICAgY29uc3QgYmxvY2tOb2RlID0gZG9jLmNyZWF0ZUVsZW1lbnQoYmxvY2tOYW1lKTtcbiAgICAgIGJsb2NrTm9kZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtbWNlLWNhcmV0JywgYmVmb3JlID8gJ2JlZm9yZScgOiAnYWZ0ZXInKTtcbiAgICAgIGJsb2NrTm9kZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtbWNlLWJvZ3VzJywgJ2FsbCcpO1xuICAgICAgYmxvY2tOb2RlLmFwcGVuZENoaWxkKGNyZWF0ZVBhZGRpbmdCcigpLmRvbSk7XG4gICAgICBjb25zdCBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgaWYgKCFiZWZvcmUpIHtcbiAgICAgICAgaWYgKG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICBwYXJlbnROb2RlID09PSBudWxsIHx8IHBhcmVudE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGJsb2NrTm9kZSwgbm9kZS5uZXh0U2libGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyZW50Tm9kZSA9PT0gbnVsbCB8fCBwYXJlbnROb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnROb2RlLmFwcGVuZENoaWxkKGJsb2NrTm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmVudE5vZGUgPT09IG51bGwgfHwgcGFyZW50Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYmxvY2tOb2RlLCBub2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBibG9ja05vZGU7XG4gICAgfTtcbiAgICBjb25zdCBzdGFydHNXaXRoQ2FyZXRDb250YWluZXIkMSA9IG5vZGUgPT4gaXNUZXh0JDkobm9kZSkgJiYgbm9kZS5kYXRhWzBdID09PSBaV1NQJDE7XG4gICAgY29uc3QgZW5kc1dpdGhDYXJldENvbnRhaW5lciQxID0gbm9kZSA9PiBpc1RleHQkOShub2RlKSAmJiBub2RlLmRhdGFbbm9kZS5kYXRhLmxlbmd0aCAtIDFdID09PSBaV1NQJDE7XG4gICAgY29uc3QgdHJpbUJvZ3VzQnIgPSBlbG0gPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgYnJzID0gZWxtLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdicicpO1xuICAgICAgY29uc3QgbGFzdEJyID0gYnJzW2Jycy5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChpc0JvZ3VzJDIobGFzdEJyKSkge1xuICAgICAgICAoX2EgPSBsYXN0QnIucGFyZW50Tm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZUNoaWxkKGxhc3RCcik7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzaG93Q2FyZXRDb250YWluZXJCbG9jayA9IGNhcmV0Q29udGFpbmVyID0+IHtcbiAgICAgIGlmIChjYXJldENvbnRhaW5lciAmJiBjYXJldENvbnRhaW5lci5oYXNBdHRyaWJ1dGUoJ2RhdGEtbWNlLWNhcmV0JykpIHtcbiAgICAgICAgdHJpbUJvZ3VzQnIoY2FyZXRDb250YWluZXIpO1xuICAgICAgICBjYXJldENvbnRhaW5lci5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtbWNlLWNhcmV0Jyk7XG4gICAgICAgIGNhcmV0Q29udGFpbmVyLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1tY2UtYm9ndXMnKTtcbiAgICAgICAgY2FyZXRDb250YWluZXIucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgICBjYXJldENvbnRhaW5lci5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtbWNlLXN0eWxlJyk7XG4gICAgICAgIGNhcmV0Q29udGFpbmVyLnJlbW92ZUF0dHJpYnV0ZSgnX21vel9hYnNwb3MnKTtcbiAgICAgICAgcmV0dXJuIGNhcmV0Q29udGFpbmVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBjb25zdCBpc1JhbmdlSW5DYXJldENvbnRhaW5lckJsb2NrID0gcmFuZ2UgPT4gaXNDYXJldENvbnRhaW5lckJsb2NrJDEocmFuZ2Uuc3RhcnRDb250YWluZXIpO1xuXG4gICAgY29uc3QgaXNDb250ZW50RWRpdGFibGVUcnVlJDIgPSBpc0NvbnRlbnRFZGl0YWJsZVRydWUkMztcbiAgICBjb25zdCBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJGEgPSBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJGI7XG4gICAgY29uc3QgaXNCciQ0ID0gaXNCciQ2O1xuICAgIGNvbnN0IGlzVGV4dCQ4ID0gaXNUZXh0JGE7XG4gICAgY29uc3QgaXNJbnZhbGlkVGV4dEVsZW1lbnQgPSBtYXRjaE5vZGVOYW1lcyhbXG4gICAgICAnc2NyaXB0JyxcbiAgICAgICdzdHlsZScsXG4gICAgICAndGV4dGFyZWEnXG4gICAgXSk7XG4gICAgY29uc3QgaXNBdG9taWNJbmxpbmUgPSBtYXRjaE5vZGVOYW1lcyhbXG4gICAgICAnaW1nJyxcbiAgICAgICdpbnB1dCcsXG4gICAgICAndGV4dGFyZWEnLFxuICAgICAgJ2hyJyxcbiAgICAgICdpZnJhbWUnLFxuICAgICAgJ3ZpZGVvJyxcbiAgICAgICdhdWRpbycsXG4gICAgICAnb2JqZWN0JyxcbiAgICAgICdlbWJlZCdcbiAgICBdKTtcbiAgICBjb25zdCBpc1RhYmxlID0gbWF0Y2hOb2RlTmFtZXMoWyd0YWJsZSddKTtcbiAgICBjb25zdCBpc0NhcmV0Q29udGFpbmVyJDEgPSBpc0NhcmV0Q29udGFpbmVyJDI7XG4gICAgY29uc3QgaXNDYXJldENhbmRpZGF0ZSQzID0gbm9kZSA9PiB7XG4gICAgICBpZiAoaXNDYXJldENvbnRhaW5lciQxKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1RleHQkOChub2RlKSkge1xuICAgICAgICByZXR1cm4gIWlzSW52YWxpZFRleHRFbGVtZW50KG5vZGUucGFyZW50Tm9kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNBdG9taWNJbmxpbmUobm9kZSkgfHwgaXNCciQ0KG5vZGUpIHx8IGlzVGFibGUobm9kZSkgfHwgaXNOb25VaUNvbnRlbnRFZGl0YWJsZUZhbHNlKG5vZGUpO1xuICAgIH07XG4gICAgY29uc3QgaXNVbnNlbGVjdGFibGUgPSBub2RlID0+IGlzRWxlbWVudCQ2KG5vZGUpICYmIG5vZGUuZ2V0QXR0cmlidXRlKCd1bnNlbGVjdGFibGUnKSA9PT0gJ3RydWUnO1xuICAgIGNvbnN0IGlzTm9uVWlDb250ZW50RWRpdGFibGVGYWxzZSA9IG5vZGUgPT4gIWlzVW5zZWxlY3RhYmxlKG5vZGUpICYmIGlzQ29udGVudEVkaXRhYmxlRmFsc2UkYShub2RlKTtcbiAgICBjb25zdCBpc0luRWRpdGFibGUgPSAobm9kZSwgcm9vdCkgPT4ge1xuICAgICAgZm9yIChsZXQgdGVtcE5vZGUgPSBub2RlLnBhcmVudE5vZGU7IHRlbXBOb2RlICYmIHRlbXBOb2RlICE9PSByb290OyB0ZW1wTm9kZSA9IHRlbXBOb2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgaWYgKGlzTm9uVWlDb250ZW50RWRpdGFibGVGYWxzZSh0ZW1wTm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ29udGVudEVkaXRhYmxlVHJ1ZSQyKHRlbXBOb2RlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIGNvbnN0IGlzQXRvbWljQ29udGVudEVkaXRhYmxlRmFsc2UgPSBub2RlID0+IHtcbiAgICAgIGlmICghaXNOb25VaUNvbnRlbnRFZGl0YWJsZUZhbHNlKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhZm9sZGwoZnJvbShub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCcqJykpLCAocmVzdWx0LCBlbG0pID0+IHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCBpc0NvbnRlbnRFZGl0YWJsZVRydWUkMihlbG0pO1xuICAgICAgfSwgZmFsc2UpO1xuICAgIH07XG4gICAgY29uc3QgaXNBdG9taWMkMSA9IG5vZGUgPT4gaXNBdG9taWNJbmxpbmUobm9kZSkgfHwgaXNBdG9taWNDb250ZW50RWRpdGFibGVGYWxzZShub2RlKTtcbiAgICBjb25zdCBpc0VkaXRhYmxlQ2FyZXRDYW5kaWRhdGUkMSA9IChub2RlLCByb290KSA9PiBpc0NhcmV0Q2FuZGlkYXRlJDMobm9kZSkgJiYgaXNJbkVkaXRhYmxlKG5vZGUsIHJvb3QpO1xuXG4gICAgY29uc3Qgd2hpdGVTcGFjZVJlZ0V4cCA9IC9eWyBcXHRcXHJcXG5dKiQvO1xuICAgIGNvbnN0IGlzV2hpdGVzcGFjZVRleHQgPSB0ZXh0ID0+IHdoaXRlU3BhY2VSZWdFeHAudGVzdCh0ZXh0KTtcbiAgICBjb25zdCBpc0NvbGxhcHNpYmxlV2hpdGVzcGFjZSQxID0gYyA9PiAnIFxcZlxcdFxceDBCJy5pbmRleE9mKGMpICE9PSAtMTtcbiAgICBjb25zdCBpc05ld0xpbmVDaGFyID0gYyA9PiBjID09PSAnXFxuJyB8fCBjID09PSAnXFxyJztcbiAgICBjb25zdCBpc05ld2xpbmUgPSAodGV4dCwgaWR4KSA9PiBpZHggPCB0ZXh0Lmxlbmd0aCAmJiBpZHggPj0gMCA/IGlzTmV3TGluZUNoYXIodGV4dFtpZHhdKSA6IGZhbHNlO1xuICAgIGNvbnN0IG5vcm1hbGl6ZSQ0ID0gKHRleHQsIHRhYlNwYWNlcyA9IDQsIGlzU3RhcnRPZkNvbnRlbnQgPSB0cnVlLCBpc0VuZE9mQ29udGVudCA9IHRydWUpID0+IHtcbiAgICAgIGNvbnN0IHRhYlNwYWNlID0gcmVwZWF0KCcgJywgdGFiU3BhY2VzKTtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRUZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHQvZywgdGFiU3BhY2UpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gZm9sZGwobm9ybWFsaXplZFRleHQsIChhY2MsIGMpID0+IHtcbiAgICAgICAgaWYgKGlzQ29sbGFwc2libGVXaGl0ZXNwYWNlJDEoYykgfHwgYyA9PT0gbmJzcCkge1xuICAgICAgICAgIGlmIChhY2MucGNJc1NwYWNlIHx8IGFjYy5zdHIgPT09ICcnICYmIGlzU3RhcnRPZkNvbnRlbnQgfHwgYWNjLnN0ci5sZW5ndGggPT09IG5vcm1hbGl6ZWRUZXh0Lmxlbmd0aCAtIDEgJiYgaXNFbmRPZkNvbnRlbnQgfHwgaXNOZXdsaW5lKG5vcm1hbGl6ZWRUZXh0LCBhY2Muc3RyLmxlbmd0aCArIDEpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBwY0lzU3BhY2U6IGZhbHNlLFxuICAgICAgICAgICAgICBzdHI6IGFjYy5zdHIgKyBuYnNwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBwY0lzU3BhY2U6IHRydWUsXG4gICAgICAgICAgICAgIHN0cjogYWNjLnN0ciArICcgJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBjSXNTcGFjZTogaXNOZXdMaW5lQ2hhcihjKSxcbiAgICAgICAgICAgIHN0cjogYWNjLnN0ciArIGNcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIHBjSXNTcGFjZTogZmFsc2UsXG4gICAgICAgIHN0cjogJydcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdC5zdHI7XG4gICAgfTtcblxuICAgIGNvbnN0IGhhc1doaXRlc3BhY2VQcmVzZXJ2ZVBhcmVudCA9IChub2RlLCByb290Tm9kZSkgPT4ge1xuICAgICAgY29uc3Qgcm9vdEVsZW1lbnQgPSBTdWdhckVsZW1lbnQuZnJvbURvbShyb290Tm9kZSk7XG4gICAgICBjb25zdCBzdGFydE5vZGUgPSBTdWdhckVsZW1lbnQuZnJvbURvbShub2RlKTtcbiAgICAgIHJldHVybiBhbmNlc3RvciQyKHN0YXJ0Tm9kZSwgJ3ByZSxjb2RlJywgY3VycnkoZXEsIHJvb3RFbGVtZW50KSk7XG4gICAgfTtcbiAgICBjb25zdCBpc1doaXRlc3BhY2UkMSA9IChub2RlLCByb290Tm9kZSkgPT4ge1xuICAgICAgcmV0dXJuIGlzVGV4dCRhKG5vZGUpICYmIGlzV2hpdGVzcGFjZVRleHQobm9kZS5kYXRhKSAmJiAhaGFzV2hpdGVzcGFjZVByZXNlcnZlUGFyZW50KG5vZGUsIHJvb3ROb2RlKTtcbiAgICB9O1xuICAgIGNvbnN0IGlzTmFtZWRBbmNob3IgPSBub2RlID0+IHtcbiAgICAgIHJldHVybiBpc0VsZW1lbnQkNihub2RlKSAmJiBub2RlLm5vZGVOYW1lID09PSAnQScgJiYgIW5vZGUuaGFzQXR0cmlidXRlKCdocmVmJykgJiYgKG5vZGUuaGFzQXR0cmlidXRlKCduYW1lJykgfHwgbm9kZS5oYXNBdHRyaWJ1dGUoJ2lkJykpO1xuICAgIH07XG4gICAgY29uc3QgaXNDb250ZW50JDEgPSAobm9kZSwgcm9vdE5vZGUpID0+IHtcbiAgICAgIHJldHVybiBpc0NhcmV0Q2FuZGlkYXRlJDMobm9kZSkgJiYgIWlzV2hpdGVzcGFjZSQxKG5vZGUsIHJvb3ROb2RlKSB8fCBpc05hbWVkQW5jaG9yKG5vZGUpIHx8IGlzQm9va21hcmsobm9kZSk7XG4gICAgfTtcbiAgICBjb25zdCBpc0Jvb2ttYXJrID0gaGFzQXR0cmlidXRlKCdkYXRhLW1jZS1ib29rbWFyaycpO1xuICAgIGNvbnN0IGlzQm9ndXMkMSA9IGhhc0F0dHJpYnV0ZSgnZGF0YS1tY2UtYm9ndXMnKTtcbiAgICBjb25zdCBpc0JvZ3VzQWxsID0gaGFzQXR0cmlidXRlVmFsdWUoJ2RhdGEtbWNlLWJvZ3VzJywgJ2FsbCcpO1xuICAgIGNvbnN0IGlzRW1wdHlOb2RlID0gKHRhcmdldE5vZGUsIHNraXBCb2d1cykgPT4ge1xuICAgICAgbGV0IGJyQ291bnQgPSAwO1xuICAgICAgaWYgKGlzQ29udGVudCQxKHRhcmdldE5vZGUsIHRhcmdldE5vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBub2RlID0gdGFyZ2V0Tm9kZS5maXJzdENoaWxkO1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3YWxrZXIgPSBuZXcgRG9tVHJlZVdhbGtlcihub2RlLCB0YXJnZXROb2RlKTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGlmIChza2lwQm9ndXMpIHtcbiAgICAgICAgICAgIGlmIChpc0JvZ3VzQWxsKG5vZGUpKSB7XG4gICAgICAgICAgICAgIG5vZGUgPSB3YWxrZXIubmV4dCh0cnVlKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNCb2d1cyQxKG5vZGUpKSB7XG4gICAgICAgICAgICAgIG5vZGUgPSB3YWxrZXIubmV4dCgpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQnIkNihub2RlKSkge1xuICAgICAgICAgICAgYnJDb3VudCsrO1xuICAgICAgICAgICAgbm9kZSA9IHdhbGtlci5uZXh0KCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQ29udGVudCQxKG5vZGUsIHRhcmdldE5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUgPSB3YWxrZXIubmV4dCgpO1xuICAgICAgICB9IHdoaWxlIChub2RlKTtcbiAgICAgICAgcmV0dXJuIGJyQ291bnQgPD0gMTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGlzRW1wdHkkMiA9IChlbG0sIHNraXBCb2d1cyA9IHRydWUpID0+IGlzRW1wdHlOb2RlKGVsbS5kb20sIHNraXBCb2d1cyk7XG5cbiAgICBjb25zdCB0cmFuc3BhcmVudEJsb2NrQXR0ciA9ICdkYXRhLW1jZS1ibG9jayc7XG4gICAgY29uc3QgZWxlbWVudE5hbWVzID0gbWFwID0+IGZpbHRlciQ1KGtleXMobWFwKSwga2V5ID0+ICEvW0EtWl0vLnRlc3Qoa2V5KSk7XG4gICAgY29uc3QgbWFrZVNlbGVjdG9yRnJvbVNjaGVtYU1hcCA9IG1hcCA9PiBlbGVtZW50TmFtZXMobWFwKS5qb2luKCcsJyk7XG4gICAgY29uc3QgdXBkYXRlVHJhbnNwYXJlbnQgPSAoYmxvY2tzU2VsZWN0b3IsIHRyYW5zcGFyZW50KSA9PiB7XG4gICAgICBpZiAoaXNOb25OdWxsYWJsZSh0cmFuc3BhcmVudC5xdWVyeVNlbGVjdG9yKGJsb2Nrc1NlbGVjdG9yKSkpIHtcbiAgICAgICAgdHJhbnNwYXJlbnQuc2V0QXR0cmlidXRlKHRyYW5zcGFyZW50QmxvY2tBdHRyLCAndHJ1ZScpO1xuICAgICAgICBpZiAodHJhbnNwYXJlbnQuZ2V0QXR0cmlidXRlKCdkYXRhLW1jZS1zZWxlY3RlZCcpID09PSAnaW5saW5lLWJvdW5kYXJ5Jykge1xuICAgICAgICAgIHRyYW5zcGFyZW50LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1tY2Utc2VsZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zcGFyZW50LnJlbW92ZUF0dHJpYnV0ZSh0cmFuc3BhcmVudEJsb2NrQXR0cik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHVwZGF0ZUJsb2NrU3RhdGVPbkNoaWxkcmVuID0gKHNjaGVtYSwgc2NvcGUpID0+IHtcbiAgICAgIGNvbnN0IHRyYW5zcGFyZW50U2VsZWN0b3IgPSBtYWtlU2VsZWN0b3JGcm9tU2NoZW1hTWFwKHNjaGVtYS5nZXRUcmFuc3BhcmVudEVsZW1lbnRzKCkpO1xuICAgICAgY29uc3QgYmxvY2tzU2VsZWN0b3IgPSBtYWtlU2VsZWN0b3JGcm9tU2NoZW1hTWFwKHNjaGVtYS5nZXRCbG9ja0VsZW1lbnRzKCkpO1xuICAgICAgcmV0dXJuIGZpbHRlciQ1KHNjb3BlLnF1ZXJ5U2VsZWN0b3JBbGwodHJhbnNwYXJlbnRTZWxlY3RvciksIHRyYW5zcGFyZW50ID0+IHVwZGF0ZVRyYW5zcGFyZW50KGJsb2Nrc1NlbGVjdG9yLCB0cmFuc3BhcmVudCkpO1xuICAgIH07XG4gICAgY29uc3QgdHJpbUVkZ2UgPSAoZWwsIGxlZnRTaWRlKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBjaGlsZFByb3BlcnR5TmFtZSA9IGxlZnRTaWRlID8gJ2xhc3RDaGlsZCcgOiAnZmlyc3RDaGlsZCc7XG4gICAgICBmb3IgKGxldCBjaGlsZCA9IGVsW2NoaWxkUHJvcGVydHlOYW1lXTsgY2hpbGQ7IGNoaWxkID0gY2hpbGRbY2hpbGRQcm9wZXJ0eU5hbWVdKSB7XG4gICAgICAgIGlmIChpc0VtcHR5JDIoU3VnYXJFbGVtZW50LmZyb21Eb20oY2hpbGQpKSkge1xuICAgICAgICAgIChfYSA9IGNoaWxkLnBhcmVudE5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzcGxpdCQyID0gKHBhcmVudEVsbSwgc3BsaXRFbG0pID0+IHtcbiAgICAgIGNvbnN0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBwYXJlbnRFbG0ucGFyZW50Tm9kZTtcbiAgICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICAgIHJhbmdlLnNldFN0YXJ0QmVmb3JlKHBhcmVudEVsbSk7XG4gICAgICAgIHJhbmdlLnNldEVuZEJlZm9yZShzcGxpdEVsbSk7XG4gICAgICAgIGNvbnN0IGJlZm9yZUZyYWdtZW50ID0gcmFuZ2UuZXh0cmFjdENvbnRlbnRzKCk7XG4gICAgICAgIHRyaW1FZGdlKGJlZm9yZUZyYWdtZW50LCB0cnVlKTtcbiAgICAgICAgcmFuZ2Uuc2V0U3RhcnRBZnRlcihzcGxpdEVsbSk7XG4gICAgICAgIHJhbmdlLnNldEVuZEFmdGVyKHBhcmVudEVsbSk7XG4gICAgICAgIGNvbnN0IGFmdGVyRnJhZ21lbnQgPSByYW5nZS5leHRyYWN0Q29udGVudHMoKTtcbiAgICAgICAgdHJpbUVkZ2UoYWZ0ZXJGcmFnbWVudCwgZmFsc2UpO1xuICAgICAgICBpZiAoIWlzRW1wdHkkMihTdWdhckVsZW1lbnQuZnJvbURvbShiZWZvcmVGcmFnbWVudCkpKSB7XG4gICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYmVmb3JlRnJhZ21lbnQsIHBhcmVudEVsbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0VtcHR5JDIoU3VnYXJFbGVtZW50LmZyb21Eb20oc3BsaXRFbG0pKSkge1xuICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNwbGl0RWxtLCBwYXJlbnRFbG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNFbXB0eSQyKFN1Z2FyRWxlbWVudC5mcm9tRG9tKGFmdGVyRnJhZ21lbnQpKSkge1xuICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGFmdGVyRnJhZ21lbnQsIHBhcmVudEVsbSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwYXJlbnRFbG0pO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc3BsaXRJbnZhbGlkQ2hpbGRyZW4gPSAoc2NoZW1hLCBzY29wZSwgdHJhbnNwYXJlbnRCbG9ja3MpID0+IHtcbiAgICAgIGNvbnN0IGJsb2Nrc0VsZW1lbnRzID0gc2NoZW1hLmdldEJsb2NrRWxlbWVudHMoKTtcbiAgICAgIGNvbnN0IHJvb3ROb2RlID0gU3VnYXJFbGVtZW50LmZyb21Eb20oc2NvcGUpO1xuICAgICAgY29uc3QgaXNCbG9jayA9IGVsID0+IG5hbWUoZWwpIGluIGJsb2Nrc0VsZW1lbnRzO1xuICAgICAgY29uc3QgaXNSb290ID0gZWwgPT4gZXEoZWwsIHJvb3ROb2RlKTtcbiAgICAgIGVhY2gkZShmcm9tRG9tJDEodHJhbnNwYXJlbnRCbG9ja3MpLCB0cmFuc3BhcmVudEJsb2NrID0+IHtcbiAgICAgICAgYW5jZXN0b3IkNCh0cmFuc3BhcmVudEJsb2NrLCBpc0Jsb2NrLCBpc1Jvb3QpLmVhY2gocGFyZW50QmxvY2sgPT4ge1xuICAgICAgICAgIGNvbnN0IGludmFsaWRDaGlsZHJlbiA9IGNoaWxkcmVuKHRyYW5zcGFyZW50QmxvY2ssIGVsID0+IGlzQmxvY2soZWwpICYmICFzY2hlbWEuaXNWYWxpZENoaWxkKG5hbWUocGFyZW50QmxvY2spLCBuYW1lKGVsKSkpO1xuICAgICAgICAgIGlmIChpbnZhbGlkQ2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGVTY29wZSA9IHBhcmVudEVsZW1lbnQocGFyZW50QmxvY2spO1xuICAgICAgICAgICAgZWFjaCRlKGludmFsaWRDaGlsZHJlbiwgY2hpbGQgPT4ge1xuICAgICAgICAgICAgICBhbmNlc3RvciQ0KGNoaWxkLCBpc0Jsb2NrLCBpc1Jvb3QpLmVhY2gocGFyZW50QmxvY2sgPT4ge1xuICAgICAgICAgICAgICAgIHNwbGl0JDIocGFyZW50QmxvY2suZG9tLCBjaGlsZC5kb20pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RhdGVTY29wZS5lYWNoKHNjb3BlID0+IHVwZGF0ZUJsb2NrU3RhdGVPbkNoaWxkcmVuKHNjaGVtYSwgc2NvcGUuZG9tKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgdW53cmFwSW52YWxpZENoaWxkcmVuID0gKHNjaGVtYSwgc2NvcGUsIHRyYW5zcGFyZW50QmxvY2tzKSA9PiB7XG4gICAgICBlYWNoJGUoW1xuICAgICAgICAuLi50cmFuc3BhcmVudEJsb2NrcyxcbiAgICAgICAgLi4uaXNUcmFuc3BhcmVudEJsb2NrKHNjaGVtYSwgc2NvcGUpID8gW3Njb3BlXSA6IFtdXG4gICAgICBdLCBibG9jayA9PiBlYWNoJGUoZGVzY2VuZGFudHMoU3VnYXJFbGVtZW50LmZyb21Eb20oYmxvY2spLCBibG9jay5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSwgZWxtID0+IHtcbiAgICAgICAgaWYgKGlzVHJhbnNwYXJlbnRJbmxpbmUoc2NoZW1hLCBlbG0uZG9tKSkge1xuICAgICAgICAgIHVud3JhcChlbG0pO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfTtcbiAgICBjb25zdCB1cGRhdGVDaGlsZHJlbiA9IChzY2hlbWEsIHNjb3BlKSA9PiB7XG4gICAgICBjb25zdCB0cmFuc3BhcmVudEJsb2NrcyA9IHVwZGF0ZUJsb2NrU3RhdGVPbkNoaWxkcmVuKHNjaGVtYSwgc2NvcGUpO1xuICAgICAgc3BsaXRJbnZhbGlkQ2hpbGRyZW4oc2NoZW1hLCBzY29wZSwgdHJhbnNwYXJlbnRCbG9ja3MpO1xuICAgICAgdW53cmFwSW52YWxpZENoaWxkcmVuKHNjaGVtYSwgc2NvcGUsIHRyYW5zcGFyZW50QmxvY2tzKTtcbiAgICB9O1xuICAgIGNvbnN0IHVwZGF0ZUVsZW1lbnQgPSAoc2NoZW1hLCB0YXJnZXQpID0+IHtcbiAgICAgIGlmIChpc1RyYW5zcGFyZW50RWxlbWVudChzY2hlbWEsIHRhcmdldCkpIHtcbiAgICAgICAgY29uc3QgYmxvY2tzU2VsZWN0b3IgPSBtYWtlU2VsZWN0b3JGcm9tU2NoZW1hTWFwKHNjaGVtYS5nZXRCbG9ja0VsZW1lbnRzKCkpO1xuICAgICAgICB1cGRhdGVUcmFuc3BhcmVudChibG9ja3NTZWxlY3RvciwgdGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHVwZGF0ZUNhcmV0ID0gKHNjaGVtYSwgcm9vdCwgY2FyZXRQYXJlbnQpID0+IHtcbiAgICAgIGNvbnN0IGlzUm9vdCA9IGVsID0+IGVxKGVsLCBTdWdhckVsZW1lbnQuZnJvbURvbShyb290KSk7XG4gICAgICBjb25zdCBwYXJlbnRzID0gcGFyZW50cyQxKFN1Z2FyRWxlbWVudC5mcm9tRG9tKGNhcmV0UGFyZW50KSwgaXNSb290KTtcbiAgICAgIGdldCRiKHBhcmVudHMsIHBhcmVudHMubGVuZ3RoIC0gMikuZmlsdGVyKGlzRWxlbWVudCQ3KS5mb2xkKCgpID0+IHVwZGF0ZUNoaWxkcmVuKHNjaGVtYSwgcm9vdCksIHNjb3BlID0+IHVwZGF0ZUNoaWxkcmVuKHNjaGVtYSwgc2NvcGUuZG9tKSk7XG4gICAgfTtcbiAgICBjb25zdCBoYXNCbG9ja0F0dHIgPSBlbCA9PiBlbC5oYXNBdHRyaWJ1dGUodHJhbnNwYXJlbnRCbG9ja0F0dHIpO1xuICAgIGNvbnN0IGlzVHJhbnNwYXJlbnRFbGVtZW50TmFtZSA9IChzY2hlbWEsIG5hbWUpID0+IGhhcyQyKHNjaGVtYS5nZXRUcmFuc3BhcmVudEVsZW1lbnRzKCksIG5hbWUpO1xuICAgIGNvbnN0IGlzVHJhbnNwYXJlbnRFbGVtZW50ID0gKHNjaGVtYSwgbm9kZSkgPT4gaXNFbGVtZW50JDYobm9kZSkgJiYgaXNUcmFuc3BhcmVudEVsZW1lbnROYW1lKHNjaGVtYSwgbm9kZS5ub2RlTmFtZSk7XG4gICAgY29uc3QgaXNUcmFuc3BhcmVudEJsb2NrID0gKHNjaGVtYSwgbm9kZSkgPT4gaXNUcmFuc3BhcmVudEVsZW1lbnQoc2NoZW1hLCBub2RlKSAmJiBoYXNCbG9ja0F0dHIobm9kZSk7XG4gICAgY29uc3QgaXNUcmFuc3BhcmVudElubGluZSA9IChzY2hlbWEsIG5vZGUpID0+IGlzVHJhbnNwYXJlbnRFbGVtZW50KHNjaGVtYSwgbm9kZSkgJiYgIWhhc0Jsb2NrQXR0cihub2RlKTtcbiAgICBjb25zdCBpc1RyYW5zcGFyZW50QXN0QmxvY2sgPSAoc2NoZW1hLCBub2RlKSA9PiBub2RlLnR5cGUgPT09IDEgJiYgaXNUcmFuc3BhcmVudEVsZW1lbnROYW1lKHNjaGVtYSwgbm9kZS5uYW1lKSAmJiBpc1N0cmluZyhub2RlLmF0dHIodHJhbnNwYXJlbnRCbG9ja0F0dHIpKTtcbiAgICBjb25zdCBpc1RyYW5zcGFyZW50QXN0SW5saW5lID0gKHNjaGVtYSwgbm9kZSkgPT4gbm9kZS50eXBlID09PSAxICYmIGlzVHJhbnNwYXJlbnRFbGVtZW50TmFtZShzY2hlbWEsIG5vZGUubmFtZSkgJiYgaXNVbmRlZmluZWQobm9kZS5hdHRyKHRyYW5zcGFyZW50QmxvY2tBdHRyKSk7XG5cbiAgICBjb25zdCBicm93c2VyID0gZGV0ZWN0JDIoKS5icm93c2VyO1xuICAgIGNvbnN0IGZpcnN0RWxlbWVudCA9IG5vZGVzID0+IGZpbmQkMihub2RlcywgaXNFbGVtZW50JDcpO1xuICAgIGNvbnN0IGdldFRhYmxlQ2FwdGlvbkRlbHRhWSA9IGVsbSA9PiB7XG4gICAgICBpZiAoYnJvd3Nlci5pc0ZpcmVmb3goKSAmJiBuYW1lKGVsbSkgPT09ICd0YWJsZScpIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0RWxlbWVudChjaGlsZHJlbiQxKGVsbSkpLmZpbHRlcihlbG0gPT4ge1xuICAgICAgICAgIHJldHVybiBuYW1lKGVsbSkgPT09ICdjYXB0aW9uJztcbiAgICAgICAgfSkuYmluZChjYXB0aW9uID0+IHtcbiAgICAgICAgICByZXR1cm4gZmlyc3RFbGVtZW50KG5leHRTaWJsaW5ncyhjYXB0aW9uKSkubWFwKGJvZHkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYm9keVRvcCA9IGJvZHkuZG9tLm9mZnNldFRvcDtcbiAgICAgICAgICAgIGNvbnN0IGNhcHRpb25Ub3AgPSBjYXB0aW9uLmRvbS5vZmZzZXRUb3A7XG4gICAgICAgICAgICBjb25zdCBjYXB0aW9uSGVpZ2h0ID0gY2FwdGlvbi5kb20ub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgcmV0dXJuIGJvZHlUb3AgPD0gY2FwdGlvblRvcCA/IC1jYXB0aW9uSGVpZ2h0IDogMDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkuZ2V0T3IoMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGhhc0NoaWxkID0gKGVsbSwgY2hpbGQpID0+IGVsbS5jaGlsZHJlbiAmJiBjb250YWlucyQyKGVsbS5jaGlsZHJlbiwgY2hpbGQpO1xuICAgIGNvbnN0IGdldFBvcyA9IChib2R5LCBlbG0sIHJvb3RFbG0pID0+IHtcbiAgICAgIGxldCB4ID0gMCwgeSA9IDA7XG4gICAgICBjb25zdCBkb2MgPSBib2R5Lm93bmVyRG9jdW1lbnQ7XG4gICAgICByb290RWxtID0gcm9vdEVsbSA/IHJvb3RFbG0gOiBib2R5O1xuICAgICAgaWYgKGVsbSkge1xuICAgICAgICBpZiAocm9vdEVsbSA9PT0gYm9keSAmJiBlbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICYmIGdldCQ3KFN1Z2FyRWxlbWVudC5mcm9tRG9tKGJvZHkpLCAncG9zaXRpb24nKSA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgICBjb25zdCBwb3MgPSBlbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgeCA9IHBvcy5sZWZ0ICsgKGRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCBib2R5LnNjcm9sbExlZnQpIC0gZG9jLmRvY3VtZW50RWxlbWVudC5jbGllbnRMZWZ0O1xuICAgICAgICAgIHkgPSBwb3MudG9wICsgKGRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGJvZHkuc2Nyb2xsVG9wKSAtIGRvYy5kb2N1bWVudEVsZW1lbnQuY2xpZW50VG9wO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgeVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9mZnNldFBhcmVudCA9IGVsbTtcbiAgICAgICAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBvZmZzZXRQYXJlbnQgIT09IHJvb3RFbG0gJiYgb2Zmc2V0UGFyZW50Lm5vZGVUeXBlICYmICFoYXNDaGlsZChvZmZzZXRQYXJlbnQsIHJvb3RFbG0pKSB7XG4gICAgICAgICAgY29uc3QgY2FzdE9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudDtcbiAgICAgICAgICB4ICs9IGNhc3RPZmZzZXRQYXJlbnQub2Zmc2V0TGVmdCB8fCAwO1xuICAgICAgICAgIHkgKz0gY2FzdE9mZnNldFBhcmVudC5vZmZzZXRUb3AgfHwgMDtcbiAgICAgICAgICBvZmZzZXRQYXJlbnQgPSBjYXN0T2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXRQYXJlbnQgPSBlbG0ucGFyZW50Tm9kZTtcbiAgICAgICAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBvZmZzZXRQYXJlbnQgIT09IHJvb3RFbG0gJiYgb2Zmc2V0UGFyZW50Lm5vZGVUeXBlICYmICFoYXNDaGlsZChvZmZzZXRQYXJlbnQsIHJvb3RFbG0pKSB7XG4gICAgICAgICAgeCAtPSBvZmZzZXRQYXJlbnQuc2Nyb2xsTGVmdCB8fCAwO1xuICAgICAgICAgIHkgLT0gb2Zmc2V0UGFyZW50LnNjcm9sbFRvcCB8fCAwO1xuICAgICAgICAgIG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIHkgKz0gZ2V0VGFibGVDYXB0aW9uRGVsdGFZKFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVsbSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgU3R5bGVTaGVldExvYWRlciA9IChkb2N1bWVudE9yU2hhZG93Um9vdCwgc2V0dGluZ3MgPSB7fSkgPT4ge1xuICAgICAgbGV0IGlkQ291bnQgPSAwO1xuICAgICAgY29uc3QgbG9hZGVkU3RhdGVzID0ge307XG4gICAgICBjb25zdCBlZG9zID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZG9jdW1lbnRPclNoYWRvd1Jvb3QpO1xuICAgICAgY29uc3QgZG9jID0gZG9jdW1lbnRPck93bmVyKGVkb3MpO1xuICAgICAgY29uc3QgX3NldFJlZmVycmVyUG9saWN5ID0gcmVmZXJyZXJQb2xpY3kgPT4ge1xuICAgICAgICBzZXR0aW5ncy5yZWZlcnJlclBvbGljeSA9IHJlZmVycmVyUG9saWN5O1xuICAgICAgfTtcbiAgICAgIGNvbnN0IF9zZXRDb250ZW50Q3NzQ29ycyA9IGNvbnRlbnRDc3NDb3JzID0+IHtcbiAgICAgICAgc2V0dGluZ3MuY29udGVudENzc0NvcnMgPSBjb250ZW50Q3NzQ29ycztcbiAgICAgIH07XG4gICAgICBjb25zdCBhZGRTdHlsZSA9IGVsZW1lbnQgPT4ge1xuICAgICAgICBhcHBlbmQkMShnZXRTdHlsZUNvbnRhaW5lcihlZG9zKSwgZWxlbWVudCk7XG4gICAgICB9O1xuICAgICAgY29uc3QgcmVtb3ZlU3R5bGUgPSBpZCA9PiB7XG4gICAgICAgIGNvbnN0IHN0eWxlQ29udGFpbmVyID0gZ2V0U3R5bGVDb250YWluZXIoZWRvcyk7XG4gICAgICAgIGRlc2NlbmRhbnQoc3R5bGVDb250YWluZXIsICcjJyArIGlkKS5lYWNoKHJlbW92ZSQ2KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBnZXRPckNyZWF0ZVN0YXRlID0gdXJsID0+IGdldCRhKGxvYWRlZFN0YXRlcywgdXJsKS5nZXRPclRodW5rKCgpID0+ICh7XG4gICAgICAgIGlkOiAnbWNlLXUnICsgaWRDb3VudCsrLFxuICAgICAgICBwYXNzZWQ6IFtdLFxuICAgICAgICBmYWlsZWQ6IFtdLFxuICAgICAgICBjb3VudDogMFxuICAgICAgfSkpO1xuICAgICAgY29uc3QgbG9hZCA9IHVybCA9PiBuZXcgUHJvbWlzZSgoc3VjY2VzcywgZmFpbHVyZSkgPT4ge1xuICAgICAgICBsZXQgbGluaztcbiAgICAgICAgY29uc3QgdXJsV2l0aFN1ZmZpeCA9IFRvb2xzLl9hZGRDYWNoZVN1ZmZpeCh1cmwpO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGdldE9yQ3JlYXRlU3RhdGUodXJsV2l0aFN1ZmZpeCk7XG4gICAgICAgIGxvYWRlZFN0YXRlc1t1cmxXaXRoU3VmZml4XSA9IHN0YXRlO1xuICAgICAgICBzdGF0ZS5jb3VudCsrO1xuICAgICAgICBjb25zdCByZXNvbHZlID0gKGNhbGxiYWNrcywgc3RhdHVzKSA9PiB7XG4gICAgICAgICAgZWFjaCRlKGNhbGxiYWNrcywgY2FsbCk7XG4gICAgICAgICAgc3RhdGUuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICAgIHN0YXRlLnBhc3NlZCA9IFtdO1xuICAgICAgICAgIHN0YXRlLmZhaWxlZCA9IFtdO1xuICAgICAgICAgIGlmIChsaW5rKSB7XG4gICAgICAgICAgICBsaW5rLm9ubG9hZCA9IG51bGw7XG4gICAgICAgICAgICBsaW5rLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgbGluayA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwYXNzZWQgPSAoKSA9PiByZXNvbHZlKHN0YXRlLnBhc3NlZCwgMik7XG4gICAgICAgIGNvbnN0IGZhaWxlZCA9ICgpID0+IHJlc29sdmUoc3RhdGUuZmFpbGVkLCAzKTtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICBzdGF0ZS5wYXNzZWQucHVzaChzdWNjZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmFpbHVyZSkge1xuICAgICAgICAgIHN0YXRlLmZhaWxlZC5wdXNoKGZhaWx1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5zdGF0dXMgPT09IDEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLnN0YXR1cyA9PT0gMikge1xuICAgICAgICAgIHBhc3NlZCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuc3RhdHVzID09PSAzKSB7XG4gICAgICAgICAgZmFpbGVkKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnN0YXR1cyA9IDE7XG4gICAgICAgIGNvbnN0IGxpbmtFbGVtID0gU3VnYXJFbGVtZW50LmZyb21UYWcoJ2xpbmsnLCBkb2MuZG9tKTtcbiAgICAgICAgc2V0QWxsJDEobGlua0VsZW0sIHtcbiAgICAgICAgICByZWw6ICdzdHlsZXNoZWV0JyxcbiAgICAgICAgICB0eXBlOiAndGV4dC9jc3MnLFxuICAgICAgICAgIGlkOiBzdGF0ZS5pZFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHNldHRpbmdzLmNvbnRlbnRDc3NDb3JzKSB7XG4gICAgICAgICAgc2V0JDMobGlua0VsZW0sICdjcm9zc09yaWdpbicsICdhbm9ueW1vdXMnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0dGluZ3MucmVmZXJyZXJQb2xpY3kpIHtcbiAgICAgICAgICBzZXQkMyhsaW5rRWxlbSwgJ3JlZmVycmVycG9saWN5Jywgc2V0dGluZ3MucmVmZXJyZXJQb2xpY3kpO1xuICAgICAgICB9XG4gICAgICAgIGxpbmsgPSBsaW5rRWxlbS5kb207XG4gICAgICAgIGxpbmsub25sb2FkID0gcGFzc2VkO1xuICAgICAgICBsaW5rLm9uZXJyb3IgPSBmYWlsZWQ7XG4gICAgICAgIGFkZFN0eWxlKGxpbmtFbGVtKTtcbiAgICAgICAgc2V0JDMobGlua0VsZW0sICdocmVmJywgdXJsV2l0aFN1ZmZpeCk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGxvYWRBbGwgPSB1cmxzID0+IHtcbiAgICAgICAgY29uc3QgbG9hZGVkVXJscyA9IFByb21pc2UuYWxsU2V0dGxlZChtYXAkMyh1cmxzLCB1cmwgPT4gbG9hZCh1cmwpLnRoZW4oY29uc3RhbnQodXJsKSkpKTtcbiAgICAgICAgcmV0dXJuIGxvYWRlZFVybHMudGhlbihyZXN1bHRzID0+IHtcbiAgICAgICAgICBjb25zdCBwYXJ0cyA9IHBhcnRpdGlvbiQyKHJlc3VsdHMsIHIgPT4gci5zdGF0dXMgPT09ICdmdWxmaWxsZWQnKTtcbiAgICAgICAgICBpZiAocGFydHMuZmFpbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobWFwJDMocGFydHMuZmFpbCwgcmVzdWx0ID0+IHJlc3VsdC5yZWFzb24pKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1hcCQzKHBhcnRzLnBhc3MsIHJlc3VsdCA9PiByZXN1bHQudmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgdW5sb2FkID0gdXJsID0+IHtcbiAgICAgICAgY29uc3QgdXJsV2l0aFN1ZmZpeCA9IFRvb2xzLl9hZGRDYWNoZVN1ZmZpeCh1cmwpO1xuICAgICAgICBnZXQkYShsb2FkZWRTdGF0ZXMsIHVybFdpdGhTdWZmaXgpLmVhY2goc3RhdGUgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvdW50ID0gLS1zdGF0ZS5jb3VudDtcbiAgICAgICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSBsb2FkZWRTdGF0ZXNbdXJsV2l0aFN1ZmZpeF07XG4gICAgICAgICAgICByZW1vdmVTdHlsZShzdGF0ZS5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCB1bmxvYWRBbGwgPSB1cmxzID0+IHtcbiAgICAgICAgZWFjaCRlKHVybHMsIHVybCA9PiB7XG4gICAgICAgICAgdW5sb2FkKHVybCk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxvYWQsXG4gICAgICAgIGxvYWRBbGwsXG4gICAgICAgIHVubG9hZCxcbiAgICAgICAgdW5sb2FkQWxsLFxuICAgICAgICBfc2V0UmVmZXJyZXJQb2xpY3ksXG4gICAgICAgIF9zZXRDb250ZW50Q3NzQ29yc1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgY3JlYXRlJGQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBtYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgY29uc3QgZm9yRWxlbWVudCA9IChyZWZlcmVuY2VFbGVtZW50LCBzZXR0aW5ncykgPT4ge1xuICAgICAgICBjb25zdCByb290ID0gZ2V0Um9vdE5vZGUocmVmZXJlbmNlRWxlbWVudCk7XG4gICAgICAgIGNvbnN0IHJvb3REb20gPSByb290LmRvbTtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLmZyb20obWFwLmdldChyb290RG9tKSkuZ2V0T3JUaHVuaygoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc2wgPSBTdHlsZVNoZWV0TG9hZGVyKHJvb3REb20sIHNldHRpbmdzKTtcbiAgICAgICAgICBtYXAuc2V0KHJvb3REb20sIHNsKTtcbiAgICAgICAgICByZXR1cm4gc2w7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHJldHVybiB7IGZvckVsZW1lbnQgfTtcbiAgICB9O1xuICAgIGNvbnN0IGluc3RhbmNlID0gY3JlYXRlJGQoKTtcblxuICAgIGNvbnN0IGlzU3BhbiA9IG5vZGUgPT4gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc3Bhbic7XG4gICAgY29uc3QgaXNJbmxpbmVDb250ZW50ID0gKG5vZGUsIHJvb3QpID0+IGlzTm9uTnVsbGFibGUobm9kZSkgJiYgKGlzQ29udGVudCQxKG5vZGUsIHJvb3QpIHx8IGlzSW5saW5lJDEoU3VnYXJFbGVtZW50LmZyb21Eb20obm9kZSkpKTtcbiAgICBjb25zdCBzdXJyb3VuZGVkQnlJbmxpbmVDb250ZW50ID0gKG5vZGUsIHJvb3QpID0+IHtcbiAgICAgIGNvbnN0IHByZXYgPSBuZXcgRG9tVHJlZVdhbGtlcihub2RlLCByb290KS5wcmV2KGZhbHNlKTtcbiAgICAgIGNvbnN0IG5leHQgPSBuZXcgRG9tVHJlZVdhbGtlcihub2RlLCByb290KS5uZXh0KGZhbHNlKTtcbiAgICAgIGNvbnN0IHByZXZJc0lubGluZSA9IGlzVW5kZWZpbmVkKHByZXYpIHx8IGlzSW5saW5lQ29udGVudChwcmV2LCByb290KTtcbiAgICAgIGNvbnN0IG5leHRJc0lubGluZSA9IGlzVW5kZWZpbmVkKG5leHQpIHx8IGlzSW5saW5lQ29udGVudChuZXh0LCByb290KTtcbiAgICAgIHJldHVybiBwcmV2SXNJbmxpbmUgJiYgbmV4dElzSW5saW5lO1xuICAgIH07XG4gICAgY29uc3QgaXNCb29rbWFya05vZGUkMiA9IG5vZGUgPT4gaXNTcGFuKG5vZGUpICYmIG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLW1jZS10eXBlJykgPT09ICdib29rbWFyayc7XG4gICAgY29uc3QgaXNLZWVwVGV4dE5vZGUgPSAobm9kZSwgcm9vdCkgPT4gaXNUZXh0JGEobm9kZSkgJiYgbm9kZS5kYXRhLmxlbmd0aCA+IDAgJiYgc3Vycm91bmRlZEJ5SW5saW5lQ29udGVudChub2RlLCByb290KTtcbiAgICBjb25zdCBpc0tlZXBFbGVtZW50ID0gbm9kZSA9PiBpc0VsZW1lbnQkNihub2RlKSA/IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPiAwIDogZmFsc2U7XG4gICAgY29uc3QgaXNEb2N1bWVudCA9IG5vZGUgPT4gaXNEb2N1bWVudEZyYWdtZW50KG5vZGUpIHx8IGlzRG9jdW1lbnQkMShub2RlKTtcbiAgICBjb25zdCB0cmltTm9kZSA9IChkb20sIG5vZGUsIHJvb3QpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IHJvb3ROb2RlID0gcm9vdCB8fCBub2RlO1xuICAgICAgaWYgKGlzRWxlbWVudCQ2KG5vZGUpICYmIGlzQm9va21hcmtOb2RlJDIobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGROb2RlcztcbiAgICAgIGZvciAobGV0IGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB0cmltTm9kZShkb20sIGNoaWxkcmVuW2ldLCByb290Tm9kZSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNFbGVtZW50JDYobm9kZSkpIHtcbiAgICAgICAgY29uc3QgY3VycmVudENoaWxkcmVuID0gbm9kZS5jaGlsZE5vZGVzO1xuICAgICAgICBpZiAoY3VycmVudENoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBpc0Jvb2ttYXJrTm9kZSQyKGN1cnJlbnRDaGlsZHJlblswXSkpIHtcbiAgICAgICAgICAoX2EgPSBub2RlLnBhcmVudE5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbnNlcnRCZWZvcmUoY3VycmVudENoaWxkcmVuWzBdLCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFpc0RvY3VtZW50KG5vZGUpICYmICFpc0NvbnRlbnQkMShub2RlLCByb290Tm9kZSkgJiYgIWlzS2VlcEVsZW1lbnQobm9kZSkgJiYgIWlzS2VlcFRleHROb2RlKG5vZGUsIHJvb3ROb2RlKSkge1xuICAgICAgICBkb20ucmVtb3ZlKG5vZGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcblxuICAgIGNvbnN0IG1ha2VNYXAkMyA9IFRvb2xzLm1ha2VNYXA7XG4gICAgY29uc3QgYXR0cnNDaGFyc1JlZ0V4cCA9IC9bJjw+XFxcIlxcdTAwNjBcXHUwMDdFLVxcdUQ3RkZcXHVFMDAwLVxcdUZGRUZdfFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0vZztcbiAgICBjb25zdCB0ZXh0Q2hhcnNSZWdFeHAgPSAvWzw+JlxcdTAwN0UtXFx1RDdGRlxcdUUwMDAtXFx1RkZFRl18W1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXS9nO1xuICAgIGNvbnN0IHJhd0NoYXJzUmVnRXhwID0gL1s8PiZcXFwiXFwnXS9nO1xuICAgIGNvbnN0IGVudGl0eVJlZ0V4cCA9IC8mIyhbYS16MC05XSspOz98JihbYS16MC05XSspOy9naTtcbiAgICBjb25zdCBhc2NpaU1hcCA9IHtcbiAgICAgIDEyODogJ1xcdTIwQUMnLFxuICAgICAgMTMwOiAnXFx1MjAxQScsXG4gICAgICAxMzE6ICdcXHUwMTkyJyxcbiAgICAgIDEzMjogJ1xcdTIwMUUnLFxuICAgICAgMTMzOiAnXFx1MjAyNicsXG4gICAgICAxMzQ6ICdcXHUyMDIwJyxcbiAgICAgIDEzNTogJ1xcdTIwMjEnLFxuICAgICAgMTM2OiAnXFx1MDJjNicsXG4gICAgICAxMzc6ICdcXHUyMDMwJyxcbiAgICAgIDEzODogJ1xcdTAxNjAnLFxuICAgICAgMTM5OiAnXFx1MjAzOScsXG4gICAgICAxNDA6ICdcXHUwMTUyJyxcbiAgICAgIDE0MjogJ1xcdTAxN2QnLFxuICAgICAgMTQ1OiAnXFx1MjAxOCcsXG4gICAgICAxNDY6ICdcXHUyMDE5JyxcbiAgICAgIDE0NzogJ1xcdTIwMUMnLFxuICAgICAgMTQ4OiAnXFx1MjAxRCcsXG4gICAgICAxNDk6ICdcXHUyMDIyJyxcbiAgICAgIDE1MDogJ1xcdTIwMTMnLFxuICAgICAgMTUxOiAnXFx1MjAxNCcsXG4gICAgICAxNTI6ICdcXHUwMkRDJyxcbiAgICAgIDE1MzogJ1xcdTIxMjInLFxuICAgICAgMTU0OiAnXFx1MDE2MScsXG4gICAgICAxNTU6ICdcXHUyMDNBJyxcbiAgICAgIDE1NjogJ1xcdTAxNTMnLFxuICAgICAgMTU4OiAnXFx1MDE3ZScsXG4gICAgICAxNTk6ICdcXHUwMTc4J1xuICAgIH07XG4gICAgY29uc3QgYmFzZUVudGl0aWVzID0ge1xuICAgICAgJ1wiJzogJyZxdW90OycsXG4gICAgICAnXFwnJzogJyYjMzk7JyxcbiAgICAgICc8JzogJyZsdDsnLFxuICAgICAgJz4nOiAnJmd0OycsXG4gICAgICAnJic6ICcmYW1wOycsXG4gICAgICAnYCc6ICcmIzk2OydcbiAgICB9O1xuICAgIGNvbnN0IHJldmVyc2VFbnRpdGllcyA9IHtcbiAgICAgICcmbHQ7JzogJzwnLFxuICAgICAgJyZndDsnOiAnPicsXG4gICAgICAnJmFtcDsnOiAnJicsXG4gICAgICAnJnF1b3Q7JzogJ1wiJyxcbiAgICAgICcmYXBvczsnOiBgJ2BcbiAgICB9O1xuICAgIGNvbnN0IG5hdGl2ZURlY29kZSA9IHRleHQgPT4ge1xuICAgICAgY29uc3QgZWxtID0gU3VnYXJFbGVtZW50LmZyb21UYWcoJ2RpdicpLmRvbTtcbiAgICAgIGVsbS5pbm5lckhUTUwgPSB0ZXh0O1xuICAgICAgcmV0dXJuIGVsbS50ZXh0Q29udGVudCB8fCBlbG0uaW5uZXJUZXh0IHx8IHRleHQ7XG4gICAgfTtcbiAgICBjb25zdCBidWlsZEVudGl0aWVzTG9va3VwID0gKGl0ZW1zLCByYWRpeCkgPT4ge1xuICAgICAgY29uc3QgbG9va3VwID0ge307XG4gICAgICBpZiAoaXRlbXMpIHtcbiAgICAgICAgY29uc3QgaXRlbUxpc3QgPSBpdGVtcy5zcGxpdCgnLCcpO1xuICAgICAgICByYWRpeCA9IHJhZGl4IHx8IDEwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1MaXN0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgY29uc3QgY2hyID0gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChpdGVtTGlzdFtpXSwgcmFkaXgpKTtcbiAgICAgICAgICBpZiAoIWJhc2VFbnRpdGllc1tjaHJdKSB7XG4gICAgICAgICAgICBjb25zdCBlbnRpdHkgPSAnJicgKyBpdGVtTGlzdFtpICsgMV0gKyAnOyc7XG4gICAgICAgICAgICBsb29rdXBbY2hyXSA9IGVudGl0eTtcbiAgICAgICAgICAgIGxvb2t1cFtlbnRpdHldID0gY2hyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9va3VwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG5hbWVkRW50aXRpZXMgPSBidWlsZEVudGl0aWVzTG9va3VwKCc1MCxuYnNwLDUxLGlleGNsLDUyLGNlbnQsNTMscG91bmQsNTQsY3VycmVuLDU1LHllbiw1NixicnZiYXIsNTcsc2VjdCw1OCx1bWwsNTksY29weSwnICsgJzVhLG9yZGYsNWIsbGFxdW8sNWMsbm90LDVkLHNoeSw1ZSxyZWcsNWYsbWFjciw1ZyxkZWcsNWgscGx1c21uLDVpLHN1cDIsNWosc3VwMyw1ayxhY3V0ZSwnICsgJzVsLG1pY3JvLDVtLHBhcmEsNW4sbWlkZG90LDVvLGNlZGlsLDVwLHN1cDEsNXEsb3JkbSw1cixyYXF1byw1cyxmcmFjMTQsNXQsZnJhYzEyLDV1LGZyYWMzNCwnICsgJzV2LGlxdWVzdCw2MCxBZ3JhdmUsNjEsQWFjdXRlLDYyLEFjaXJjLDYzLEF0aWxkZSw2NCxBdW1sLDY1LEFyaW5nLDY2LEFFbGlnLDY3LENjZWRpbCwnICsgJzY4LEVncmF2ZSw2OSxFYWN1dGUsNmEsRWNpcmMsNmIsRXVtbCw2YyxJZ3JhdmUsNmQsSWFjdXRlLDZlLEljaXJjLDZmLEl1bWwsNmcsRVRILDZoLE50aWxkZSwnICsgJzZpLE9ncmF2ZSw2aixPYWN1dGUsNmssT2NpcmMsNmwsT3RpbGRlLDZtLE91bWwsNm4sdGltZXMsNm8sT3NsYXNoLDZwLFVncmF2ZSw2cSxVYWN1dGUsJyArICc2cixVY2lyYyw2cyxVdW1sLDZ0LFlhY3V0ZSw2dSxUSE9STiw2dixzemxpZyw3MCxhZ3JhdmUsNzEsYWFjdXRlLDcyLGFjaXJjLDczLGF0aWxkZSw3NCxhdW1sLCcgKyAnNzUsYXJpbmcsNzYsYWVsaWcsNzcsY2NlZGlsLDc4LGVncmF2ZSw3OSxlYWN1dGUsN2EsZWNpcmMsN2IsZXVtbCw3YyxpZ3JhdmUsN2QsaWFjdXRlLDdlLGljaXJjLCcgKyAnN2YsaXVtbCw3ZyxldGgsN2gsbnRpbGRlLDdpLG9ncmF2ZSw3aixvYWN1dGUsN2ssb2NpcmMsN2wsb3RpbGRlLDdtLG91bWwsN24sZGl2aWRlLDdvLG9zbGFzaCwnICsgJzdwLHVncmF2ZSw3cSx1YWN1dGUsN3IsdWNpcmMsN3MsdXVtbCw3dCx5YWN1dGUsN3UsdGhvcm4sN3YseXVtbCxjaSxmbm9mLHNoLEFscGhhLHNpLEJldGEsJyArICdzaixHYW1tYSxzayxEZWx0YSxzbCxFcHNpbG9uLHNtLFpldGEsc24sRXRhLHNvLFRoZXRhLHNwLElvdGEsc3EsS2FwcGEsc3IsTGFtYmRhLHNzLE11LCcgKyAnc3QsTnUsc3UsWGksc3YsT21pY3Jvbix0MCxQaSx0MSxSaG8sdDMsU2lnbWEsdDQsVGF1LHQ1LFVwc2lsb24sdDYsUGhpLHQ3LENoaSx0OCxQc2ksJyArICd0OSxPbWVnYSx0aCxhbHBoYSx0aSxiZXRhLHRqLGdhbW1hLHRrLGRlbHRhLHRsLGVwc2lsb24sdG0semV0YSx0bixldGEsdG8sdGhldGEsdHAsaW90YSwnICsgJ3RxLGthcHBhLHRyLGxhbWJkYSx0cyxtdSx0dCxudSx0dSx4aSx0dixvbWljcm9uLHUwLHBpLHUxLHJobyx1MixzaWdtYWYsdTMsc2lnbWEsdTQsdGF1LCcgKyAndTUsdXBzaWxvbix1NixwaGksdTcsY2hpLHU4LHBzaSx1OSxvbWVnYSx1aCx0aGV0YXN5bSx1aSx1cHNpaCx1bSxwaXYsODEyLGJ1bGwsODE2LGhlbGxpcCwnICsgJzgxaSxwcmltZSw4MWosUHJpbWUsODF1LG9saW5lLDgyNCxmcmFzbCw4OG8sd2VpZXJwLDg4aCxpbWFnZSw4OHMscmVhbCw4OTIsdHJhZGUsODlsLGFsZWZzeW0sJyArICc4Y2csbGFyciw4Y2gsdWFyciw4Y2kscmFyciw4Y2osZGFyciw4Y2ssaGFyciw4ZGwsY3JhcnIsOGVnLGxBcnIsOGVoLHVBcnIsOGVpLHJBcnIsOGVqLGRBcnIsJyArICc4ZWssaEFyciw4ZzAsZm9yYWxsLDhnMixwYXJ0LDhnMyxleGlzdCw4ZzUsZW1wdHksOGc3LG5hYmxhLDhnOCxpc2luLDhnOSxub3Rpbiw4Z2IsbmksOGdmLHByb2QsJyArICc4Z2gsc3VtLDhnaSxtaW51cyw4Z24sbG93YXN0LDhncSxyYWRpYyw4Z3QscHJvcCw4Z3UsaW5maW4sOGgwLGFuZyw4aDcsYW5kLDhoOCxvciw4aDksY2FwLDhoYSxjdXAsJyArICc4aGIsaW50LDhoayx0aGVyZTQsOGhzLHNpbSw4aTUsY29uZyw4aTgsYXN5bXAsOGowLG5lLDhqMSxlcXVpdiw4ajQsbGUsOGo1LGdlLDhrMixzdWIsOGszLHN1cCw4azQsJyArICduc3ViLDhrNixzdWJlLDhrNyxzdXBlLDhrbCxvcGx1cyw4a24sb3RpbWVzLDhsNSxwZXJwLDhtNSxzZG90LDhvOCxsY2VpbCw4bzkscmNlaWwsOG9hLGxmbG9vciw4b2IsJyArICdyZmxvb3IsOHA5LGxhbmcsOHBhLHJhbmcsOWVhLGxveiw5ajAsc3BhZGVzLDlqMyxjbHVicyw5ajUsaGVhcnRzLDlqNixkaWFtcyxhaSxPRWxpZyxhaixvZWxpZyxiMCwnICsgJ1NjYXJvbixiMSxzY2Fyb24sYm8sWXVtbCxtNixjaXJjLG1zLHRpbGRlLDgwMixlbnNwLDgwMyxlbXNwLDgwOSx0aGluc3AsODBjLHp3bmosODBkLHp3aiw4MGUsbHJtLCcgKyAnODBmLHJsbSw4MGosbmRhc2gsODBrLG1kYXNoLDgwbyxsc3F1byw4MHAscnNxdW8sODBxLHNicXVvLDgwcyxsZHF1byw4MHQscmRxdW8sODB1LGJkcXVvLDgxMCxkYWdnZXIsJyArICc4MTEsRGFnZ2VyLDgxZyxwZXJtaWwsODFwLGxzYXF1byw4MXEscnNhcXVvLDg1YyxldXJvJywgMzIpO1xuICAgIGNvbnN0IGVuY29kZVJhdyA9ICh0ZXh0LCBhdHRyKSA9PiB0ZXh0LnJlcGxhY2UoYXR0ciA/IGF0dHJzQ2hhcnNSZWdFeHAgOiB0ZXh0Q2hhcnNSZWdFeHAsIGNociA9PiB7XG4gICAgICByZXR1cm4gYmFzZUVudGl0aWVzW2Nocl0gfHwgY2hyO1xuICAgIH0pO1xuICAgIGNvbnN0IGVuY29kZUFsbFJhdyA9IHRleHQgPT4gKCcnICsgdGV4dCkucmVwbGFjZShyYXdDaGFyc1JlZ0V4cCwgY2hyID0+IHtcbiAgICAgIHJldHVybiBiYXNlRW50aXRpZXNbY2hyXSB8fCBjaHI7XG4gICAgfSk7XG4gICAgY29uc3QgZW5jb2RlTnVtZXJpYyA9ICh0ZXh0LCBhdHRyKSA9PiB0ZXh0LnJlcGxhY2UoYXR0ciA/IGF0dHJzQ2hhcnNSZWdFeHAgOiB0ZXh0Q2hhcnNSZWdFeHAsIGNociA9PiB7XG4gICAgICBpZiAoY2hyLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmV0dXJuICcmIycgKyAoKGNoci5jaGFyQ29kZUF0KDApIC0gNTUyOTYpICogMTAyNCArIChjaHIuY2hhckNvZGVBdCgxKSAtIDU2MzIwKSArIDY1NTM2KSArICc7JztcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRW50aXRpZXNbY2hyXSB8fCAnJiMnICsgY2hyLmNoYXJDb2RlQXQoMCkgKyAnOyc7XG4gICAgfSk7XG4gICAgY29uc3QgZW5jb2RlTmFtZWQgPSAodGV4dCwgYXR0ciwgZW50aXRpZXMpID0+IHtcbiAgICAgIGNvbnN0IHJlc29sdmVFbnRpdGllcyA9IGVudGl0aWVzIHx8IG5hbWVkRW50aXRpZXM7XG4gICAgICByZXR1cm4gdGV4dC5yZXBsYWNlKGF0dHIgPyBhdHRyc0NoYXJzUmVnRXhwIDogdGV4dENoYXJzUmVnRXhwLCBjaHIgPT4ge1xuICAgICAgICByZXR1cm4gYmFzZUVudGl0aWVzW2Nocl0gfHwgcmVzb2x2ZUVudGl0aWVzW2Nocl0gfHwgY2hyO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRFbmNvZGVGdW5jID0gKG5hbWUsIGVudGl0aWVzKSA9PiB7XG4gICAgICBjb25zdCBlbnRpdGllc01hcCA9IGJ1aWxkRW50aXRpZXNMb29rdXAoZW50aXRpZXMpIHx8IG5hbWVkRW50aXRpZXM7XG4gICAgICBjb25zdCBlbmNvZGVOYW1lZEFuZE51bWVyaWMgPSAodGV4dCwgYXR0cikgPT4gdGV4dC5yZXBsYWNlKGF0dHIgPyBhdHRyc0NoYXJzUmVnRXhwIDogdGV4dENoYXJzUmVnRXhwLCBjaHIgPT4ge1xuICAgICAgICBpZiAoYmFzZUVudGl0aWVzW2Nocl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBiYXNlRW50aXRpZXNbY2hyXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW50aXRpZXNNYXBbY2hyXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGVudGl0aWVzTWFwW2Nocl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoci5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuICcmIycgKyAoKGNoci5jaGFyQ29kZUF0KDApIC0gNTUyOTYpICogMTAyNCArIChjaHIuY2hhckNvZGVBdCgxKSAtIDU2MzIwKSArIDY1NTM2KSArICc7JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyYjJyArIGNoci5jaGFyQ29kZUF0KDApICsgJzsnO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBlbmNvZGVDdXN0b21OYW1lZCA9ICh0ZXh0LCBhdHRyKSA9PiB7XG4gICAgICAgIHJldHVybiBlbmNvZGVOYW1lZCh0ZXh0LCBhdHRyLCBlbnRpdGllc01hcCk7XG4gICAgICB9O1xuICAgICAgY29uc3QgbmFtZU1hcCA9IG1ha2VNYXAkMyhuYW1lLnJlcGxhY2UoL1xcKy9nLCAnLCcpKTtcbiAgICAgIGlmIChuYW1lTWFwLm5hbWVkICYmIG5hbWVNYXAubnVtZXJpYykge1xuICAgICAgICByZXR1cm4gZW5jb2RlTmFtZWRBbmROdW1lcmljO1xuICAgICAgfVxuICAgICAgaWYgKG5hbWVNYXAubmFtZWQpIHtcbiAgICAgICAgaWYgKGVudGl0aWVzKSB7XG4gICAgICAgICAgcmV0dXJuIGVuY29kZUN1c3RvbU5hbWVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmNvZGVOYW1lZDtcbiAgICAgIH1cbiAgICAgIGlmIChuYW1lTWFwLm51bWVyaWMpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZU51bWVyaWM7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW5jb2RlUmF3O1xuICAgIH07XG4gICAgY29uc3QgZGVjb2RlID0gdGV4dCA9PiB0ZXh0LnJlcGxhY2UoZW50aXR5UmVnRXhwLCAoYWxsLCBudW1lcmljKSA9PiB7XG4gICAgICBpZiAobnVtZXJpYykge1xuICAgICAgICBpZiAobnVtZXJpYy5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSA9PT0gJ3gnKSB7XG4gICAgICAgICAgbnVtZXJpYyA9IHBhcnNlSW50KG51bWVyaWMuc3Vic3RyKDEpLCAxNik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbnVtZXJpYyA9IHBhcnNlSW50KG51bWVyaWMsIDEwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtZXJpYyA+IDY1NTM1KSB7XG4gICAgICAgICAgbnVtZXJpYyAtPSA2NTUzNjtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NiArIChudW1lcmljID4+IDEwKSwgNTYzMjAgKyAobnVtZXJpYyAmIDEwMjMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXNjaWlNYXBbbnVtZXJpY10gfHwgU3RyaW5nLmZyb21DaGFyQ29kZShudW1lcmljKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXZlcnNlRW50aXRpZXNbYWxsXSB8fCBuYW1lZEVudGl0aWVzW2FsbF0gfHwgbmF0aXZlRGVjb2RlKGFsbCk7XG4gICAgfSk7XG4gICAgY29uc3QgRW50aXRpZXMgPSB7XG4gICAgICBlbmNvZGVSYXcsXG4gICAgICBlbmNvZGVBbGxSYXcsXG4gICAgICBlbmNvZGVOdW1lcmljLFxuICAgICAgZW5jb2RlTmFtZWQsXG4gICAgICBnZXRFbmNvZGVGdW5jLFxuICAgICAgZGVjb2RlXG4gICAgfTtcblxuICAgIGNvbnN0IGxvb2t1cENhY2hlID0ge307XG4gICAgY29uc3QgbWFwQ2FjaGUgPSB7fTtcbiAgICBjb25zdCBkdW1teU9iaiA9IHt9O1xuICAgIGNvbnN0IG1ha2VNYXAkMiA9IFRvb2xzLm1ha2VNYXAsIGVhY2gkYiA9IFRvb2xzLmVhY2gsIGV4dGVuZCQyID0gVG9vbHMuZXh0ZW5kLCBleHBsb2RlJDIgPSBUb29scy5leHBsb2RlLCBpbkFycmF5ID0gVG9vbHMuaW5BcnJheTtcbiAgICBjb25zdCBzcGxpdCQxID0gKGl0ZW1zLCBkZWxpbSkgPT4ge1xuICAgICAgaXRlbXMgPSBUb29scy50cmltKGl0ZW1zKTtcbiAgICAgIHJldHVybiBpdGVtcyA/IGl0ZW1zLnNwbGl0KGRlbGltIHx8ICcgJykgOiBbXTtcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZU1hcCA9IChkZWZhdWx0VmFsdWUsIGV4dGVuZFdpdGggPSB7fSkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBtYWtlTWFwJDIoZGVmYXVsdFZhbHVlLCAnICcsIG1ha2VNYXAkMihkZWZhdWx0VmFsdWUudG9VcHBlckNhc2UoKSwgJyAnKSk7XG4gICAgICByZXR1cm4gZXh0ZW5kJDIodmFsdWUsIGV4dGVuZFdpdGgpO1xuICAgIH07XG4gICAgY29uc3QgZ2V0VGV4dFJvb3RCbG9ja0VsZW1lbnRzID0gc2NoZW1hID0+IGNyZWF0ZU1hcCgndGQgdGggbGkgZHQgZGQgZmlnY2FwdGlvbiBjYXB0aW9uIGRldGFpbHMgc3VtbWFyeScsIHNjaGVtYS5nZXRUZXh0QmxvY2tFbGVtZW50cygpKTtcbiAgICBjb25zdCBjb21waWxlU2NoZW1hID0gdHlwZSA9PiB7XG4gICAgICBjb25zdCBzY2hlbWEgPSB7fTtcbiAgICAgIGxldCBnbG9iYWxBdHRyaWJ1dGVzLCBibG9ja0NvbnRlbnQ7XG4gICAgICBsZXQgcGhyYXNpbmdDb250ZW50LCBmbG93Q29udGVudDtcbiAgICAgIGNvbnN0IGFkZCA9IChuYW1lLCBhdHRyaWJ1dGVzID0gJycsIGNoaWxkcmVuID0gJycpID0+IHtcbiAgICAgICAgY29uc3QgY2hpbGROYW1lcyA9IHNwbGl0JDEoY2hpbGRyZW4pO1xuICAgICAgICBjb25zdCBuYW1lcyA9IHNwbGl0JDEobmFtZSk7XG4gICAgICAgIGxldCBuaSA9IG5hbWVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKG5pLS0pIHtcbiAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzT3JkZXIgPSBzcGxpdCQxKFtcbiAgICAgICAgICAgIGdsb2JhbEF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzXG4gICAgICAgICAgXS5qb2luKCcgJykpO1xuICAgICAgICAgIHNjaGVtYVtuYW1lc1tuaV1dID0ge1xuICAgICAgICAgICAgYXR0cmlidXRlczogbWFwVG9PYmplY3QoYXR0cmlidXRlc09yZGVyLCAoKSA9PiAoe30pKSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNPcmRlcixcbiAgICAgICAgICAgIGNoaWxkcmVuOiBtYXBUb09iamVjdChjaGlsZE5hbWVzLCBjb25zdGFudChkdW1teU9iaikpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGFkZEF0dHJzID0gKG5hbWUsIGF0dHJpYnV0ZXMpID0+IHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSBzcGxpdCQxKG5hbWUpO1xuICAgICAgICBjb25zdCBhdHRycyA9IHNwbGl0JDEoYXR0cmlidXRlcyk7XG4gICAgICAgIGxldCBuaSA9IG5hbWVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKG5pLS0pIHtcbiAgICAgICAgICBjb25zdCBzY2hlbWFJdGVtID0gc2NoZW1hW25hbWVzW25pXV07XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBhdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHNjaGVtYUl0ZW0uYXR0cmlidXRlc1thdHRyc1tpXV0gPSB7fTtcbiAgICAgICAgICAgIHNjaGVtYUl0ZW0uYXR0cmlidXRlc09yZGVyLnB1c2goYXR0cnNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChsb29rdXBDYWNoZVt0eXBlXSkge1xuICAgICAgICByZXR1cm4gbG9va3VwQ2FjaGVbdHlwZV07XG4gICAgICB9XG4gICAgICBnbG9iYWxBdHRyaWJ1dGVzID0gJ2lkIGFjY2Vzc2tleSBjbGFzcyBkaXIgbGFuZyBzdHlsZSB0YWJpbmRleCB0aXRsZSByb2xlJztcbiAgICAgIGJsb2NrQ29udGVudCA9ICdhZGRyZXNzIGJsb2NrcXVvdGUgZGl2IGRsIGZpZWxkc2V0IGZvcm0gaDEgaDIgaDMgaDQgaDUgaDYgaHIgbWVudSBvbCBwIHByZSB0YWJsZSB1bCc7XG4gICAgICBwaHJhc2luZ0NvbnRlbnQgPSAnYSBhYmJyIGIgYmRvIGJyIGJ1dHRvbiBjaXRlIGNvZGUgZGVsIGRmbiBlbSBlbWJlZCBpIGlmcmFtZSBpbWcgaW5wdXQgaW5zIGtiZCAnICsgJ2xhYmVsIG1hcCBub3NjcmlwdCBvYmplY3QgcSBzIHNhbXAgc2NyaXB0IHNlbGVjdCBzbWFsbCBzcGFuIHN0cm9uZyBzdWIgc3VwICcgKyAndGV4dGFyZWEgdSB2YXIgI3RleHQgI2NvbW1lbnQnO1xuICAgICAgaWYgKHR5cGUgIT09ICdodG1sNCcpIHtcbiAgICAgICAgY29uc3QgdHJhbnNwYXJlbnRDb250ZW50ID0gJ2EgaW5zIGRlbCBjYW52YXMgbWFwJztcbiAgICAgICAgZ2xvYmFsQXR0cmlidXRlcyArPSAnIGNvbnRlbnRlZGl0YWJsZSBjb250ZXh0bWVudSBkcmFnZ2FibGUgZHJvcHpvbmUgJyArICdoaWRkZW4gc3BlbGxjaGVjayB0cmFuc2xhdGUnO1xuICAgICAgICBibG9ja0NvbnRlbnQgKz0gJyBhcnRpY2xlIGFzaWRlIGRldGFpbHMgZGlhbG9nIGZpZ3VyZSBtYWluIGhlYWRlciBmb290ZXIgaGdyb3VwIHNlY3Rpb24gbmF2ICcgKyB0cmFuc3BhcmVudENvbnRlbnQ7XG4gICAgICAgIHBocmFzaW5nQ29udGVudCArPSAnIGF1ZGlvIGNhbnZhcyBjb21tYW5kIGRhdGFsaXN0IG1hcmsgbWV0ZXIgb3V0cHV0IHBpY3R1cmUgJyArICdwcm9ncmVzcyB0aW1lIHdiciB2aWRlbyBydWJ5IGJkaSBrZXlnZW4nO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgIT09ICdodG1sNS1zdHJpY3QnKSB7XG4gICAgICAgIGdsb2JhbEF0dHJpYnV0ZXMgKz0gJyB4bWw6bGFuZyc7XG4gICAgICAgIGNvbnN0IGh0bWw0UGhyYXNpbmdDb250ZW50ID0gJ2Fjcm9ueW0gYXBwbGV0IGJhc2Vmb250IGJpZyBmb250IHN0cmlrZSB0dCc7XG4gICAgICAgIHBocmFzaW5nQ29udGVudCA9IFtcbiAgICAgICAgICBwaHJhc2luZ0NvbnRlbnQsXG4gICAgICAgICAgaHRtbDRQaHJhc2luZ0NvbnRlbnRcbiAgICAgICAgXS5qb2luKCcgJyk7XG4gICAgICAgIGVhY2gkYihzcGxpdCQxKGh0bWw0UGhyYXNpbmdDb250ZW50KSwgbmFtZSA9PiB7XG4gICAgICAgICAgYWRkKG5hbWUsICcnLCBwaHJhc2luZ0NvbnRlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaHRtbDRCbG9ja0NvbnRlbnQgPSAnY2VudGVyIGRpciBpc2luZGV4IG5vZnJhbWVzJztcbiAgICAgICAgYmxvY2tDb250ZW50ID0gW1xuICAgICAgICAgIGJsb2NrQ29udGVudCxcbiAgICAgICAgICBodG1sNEJsb2NrQ29udGVudFxuICAgICAgICBdLmpvaW4oJyAnKTtcbiAgICAgICAgZmxvd0NvbnRlbnQgPSBbXG4gICAgICAgICAgYmxvY2tDb250ZW50LFxuICAgICAgICAgIHBocmFzaW5nQ29udGVudFxuICAgICAgICBdLmpvaW4oJyAnKTtcbiAgICAgICAgZWFjaCRiKHNwbGl0JDEoaHRtbDRCbG9ja0NvbnRlbnQpLCBuYW1lID0+IHtcbiAgICAgICAgICBhZGQobmFtZSwgJycsIGZsb3dDb250ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBmbG93Q29udGVudCA9IGZsb3dDb250ZW50IHx8IFtcbiAgICAgICAgYmxvY2tDb250ZW50LFxuICAgICAgICBwaHJhc2luZ0NvbnRlbnRcbiAgICAgIF0uam9pbignICcpO1xuICAgICAgYWRkKCdodG1sJywgJ21hbmlmZXN0JywgJ2hlYWQgYm9keScpO1xuICAgICAgYWRkKCdoZWFkJywgJycsICdiYXNlIGNvbW1hbmQgbGluayBtZXRhIG5vc2NyaXB0IHNjcmlwdCBzdHlsZSB0aXRsZScpO1xuICAgICAgYWRkKCd0aXRsZSBociBub3NjcmlwdCBicicpO1xuICAgICAgYWRkKCdiYXNlJywgJ2hyZWYgdGFyZ2V0Jyk7XG4gICAgICBhZGQoJ2xpbmsnLCAnaHJlZiByZWwgbWVkaWEgaHJlZmxhbmcgdHlwZSBzaXplcyBocmVmbGFuZycpO1xuICAgICAgYWRkKCdtZXRhJywgJ25hbWUgaHR0cC1lcXVpdiBjb250ZW50IGNoYXJzZXQnKTtcbiAgICAgIGFkZCgnc3R5bGUnLCAnbWVkaWEgdHlwZSBzY29wZWQnKTtcbiAgICAgIGFkZCgnc2NyaXB0JywgJ3NyYyBhc3luYyBkZWZlciB0eXBlIGNoYXJzZXQnKTtcbiAgICAgIGFkZCgnYm9keScsICdvbmFmdGVycHJpbnQgb25iZWZvcmVwcmludCBvbmJlZm9yZXVubG9hZCBvbmJsdXIgb25lcnJvciBvbmZvY3VzICcgKyAnb25oYXNoY2hhbmdlIG9ubG9hZCBvbm1lc3NhZ2Ugb25vZmZsaW5lIG9ub25saW5lIG9ucGFnZWhpZGUgb25wYWdlc2hvdyAnICsgJ29ucG9wc3RhdGUgb25yZXNpemUgb25zY3JvbGwgb25zdG9yYWdlIG9udW5sb2FkJywgZmxvd0NvbnRlbnQpO1xuICAgICAgYWRkKCdhZGRyZXNzIGR0IGRkIGRpdiBjYXB0aW9uJywgJycsIGZsb3dDb250ZW50KTtcbiAgICAgIGFkZCgnaDEgaDIgaDMgaDQgaDUgaDYgcHJlIHAgYWJiciBjb2RlIHZhciBzYW1wIGtiZCBzdWIgc3VwIGkgYiB1IGJkbyBzcGFuIGxlZ2VuZCBlbSBzdHJvbmcgc21hbGwgcyBjaXRlIGRmbicsICcnLCBwaHJhc2luZ0NvbnRlbnQpO1xuICAgICAgYWRkKCdibG9ja3F1b3RlJywgJ2NpdGUnLCBmbG93Q29udGVudCk7XG4gICAgICBhZGQoJ29sJywgJ3JldmVyc2VkIHN0YXJ0IHR5cGUnLCAnbGknKTtcbiAgICAgIGFkZCgndWwnLCAnJywgJ2xpJyk7XG4gICAgICBhZGQoJ2xpJywgJ3ZhbHVlJywgZmxvd0NvbnRlbnQpO1xuICAgICAgYWRkKCdkbCcsICcnLCAnZHQgZGQnKTtcbiAgICAgIGFkZCgnYScsICdocmVmIHRhcmdldCByZWwgbWVkaWEgaHJlZmxhbmcgdHlwZScsIGZsb3dDb250ZW50KTtcbiAgICAgIGFkZCgncScsICdjaXRlJywgcGhyYXNpbmdDb250ZW50KTtcbiAgICAgIGFkZCgnaW5zIGRlbCcsICdjaXRlIGRhdGV0aW1lJywgZmxvd0NvbnRlbnQpO1xuICAgICAgYWRkKCdpbWcnLCAnc3JjIHNpemVzIHNyY3NldCBhbHQgdXNlbWFwIGlzbWFwIHdpZHRoIGhlaWdodCcpO1xuICAgICAgYWRkKCdpZnJhbWUnLCAnc3JjIG5hbWUgd2lkdGggaGVpZ2h0JywgZmxvd0NvbnRlbnQpO1xuICAgICAgYWRkKCdlbWJlZCcsICdzcmMgdHlwZSB3aWR0aCBoZWlnaHQnKTtcbiAgICAgIGFkZCgnb2JqZWN0JywgJ2RhdGEgdHlwZSB0eXBlbXVzdG1hdGNoIG5hbWUgdXNlbWFwIGZvcm0gd2lkdGggaGVpZ2h0JywgW1xuICAgICAgICBmbG93Q29udGVudCxcbiAgICAgICAgJ3BhcmFtJ1xuICAgICAgXS5qb2luKCcgJykpO1xuICAgICAgYWRkKCdwYXJhbScsICduYW1lIHZhbHVlJyk7XG4gICAgICBhZGQoJ21hcCcsICduYW1lJywgW1xuICAgICAgICBmbG93Q29udGVudCxcbiAgICAgICAgJ2FyZWEnXG4gICAgICBdLmpvaW4oJyAnKSk7XG4gICAgICBhZGQoJ2FyZWEnLCAnYWx0IGNvb3JkcyBzaGFwZSBocmVmIHRhcmdldCByZWwgbWVkaWEgaHJlZmxhbmcgdHlwZScpO1xuICAgICAgYWRkKCd0YWJsZScsICdib3JkZXInLCAnY2FwdGlvbiBjb2xncm91cCB0aGVhZCB0Zm9vdCB0Ym9keSB0cicgKyAodHlwZSA9PT0gJ2h0bWw0JyA/ICcgY29sJyA6ICcnKSk7XG4gICAgICBhZGQoJ2NvbGdyb3VwJywgJ3NwYW4nLCAnY29sJyk7XG4gICAgICBhZGQoJ2NvbCcsICdzcGFuJyk7XG4gICAgICBhZGQoJ3Rib2R5IHRoZWFkIHRmb290JywgJycsICd0cicpO1xuICAgICAgYWRkKCd0cicsICcnLCAndGQgdGgnKTtcbiAgICAgIGFkZCgndGQnLCAnY29sc3BhbiByb3dzcGFuIGhlYWRlcnMnLCBmbG93Q29udGVudCk7XG4gICAgICBhZGQoJ3RoJywgJ2NvbHNwYW4gcm93c3BhbiBoZWFkZXJzIHNjb3BlIGFiYnInLCBmbG93Q29udGVudCk7XG4gICAgICBhZGQoJ2Zvcm0nLCAnYWNjZXB0LWNoYXJzZXQgYWN0aW9uIGF1dG9jb21wbGV0ZSBlbmN0eXBlIG1ldGhvZCBuYW1lIG5vdmFsaWRhdGUgdGFyZ2V0JywgZmxvd0NvbnRlbnQpO1xuICAgICAgYWRkKCdmaWVsZHNldCcsICdkaXNhYmxlZCBmb3JtIG5hbWUnLCBbXG4gICAgICAgIGZsb3dDb250ZW50LFxuICAgICAgICAnbGVnZW5kJ1xuICAgICAgXS5qb2luKCcgJykpO1xuICAgICAgYWRkKCdsYWJlbCcsICdmb3JtIGZvcicsIHBocmFzaW5nQ29udGVudCk7XG4gICAgICBhZGQoJ2lucHV0JywgJ2FjY2VwdCBhbHQgYXV0b2NvbXBsZXRlIGNoZWNrZWQgZGlybmFtZSBkaXNhYmxlZCBmb3JtIGZvcm1hY3Rpb24gZm9ybWVuY3R5cGUgZm9ybW1ldGhvZCBmb3Jtbm92YWxpZGF0ZSAnICsgJ2Zvcm10YXJnZXQgaGVpZ2h0IGxpc3QgbWF4IG1heGxlbmd0aCBtaW4gbXVsdGlwbGUgbmFtZSBwYXR0ZXJuIHJlYWRvbmx5IHJlcXVpcmVkIHNpemUgc3JjIHN0ZXAgdHlwZSB2YWx1ZSB3aWR0aCcpO1xuICAgICAgYWRkKCdidXR0b24nLCAnZGlzYWJsZWQgZm9ybSBmb3JtYWN0aW9uIGZvcm1lbmN0eXBlIGZvcm1tZXRob2QgZm9ybW5vdmFsaWRhdGUgZm9ybXRhcmdldCBuYW1lIHR5cGUgdmFsdWUnLCB0eXBlID09PSAnaHRtbDQnID8gZmxvd0NvbnRlbnQgOiBwaHJhc2luZ0NvbnRlbnQpO1xuICAgICAgYWRkKCdzZWxlY3QnLCAnZGlzYWJsZWQgZm9ybSBtdWx0aXBsZSBuYW1lIHJlcXVpcmVkIHNpemUnLCAnb3B0aW9uIG9wdGdyb3VwJyk7XG4gICAgICBhZGQoJ29wdGdyb3VwJywgJ2Rpc2FibGVkIGxhYmVsJywgJ29wdGlvbicpO1xuICAgICAgYWRkKCdvcHRpb24nLCAnZGlzYWJsZWQgbGFiZWwgc2VsZWN0ZWQgdmFsdWUnKTtcbiAgICAgIGFkZCgndGV4dGFyZWEnLCAnY29scyBkaXJuYW1lIGRpc2FibGVkIGZvcm0gbWF4bGVuZ3RoIG5hbWUgcmVhZG9ubHkgcmVxdWlyZWQgcm93cyB3cmFwJyk7XG4gICAgICBhZGQoJ21lbnUnLCAndHlwZSBsYWJlbCcsIFtcbiAgICAgICAgZmxvd0NvbnRlbnQsXG4gICAgICAgICdsaSdcbiAgICAgIF0uam9pbignICcpKTtcbiAgICAgIGFkZCgnbm9zY3JpcHQnLCAnJywgZmxvd0NvbnRlbnQpO1xuICAgICAgaWYgKHR5cGUgIT09ICdodG1sNCcpIHtcbiAgICAgICAgYWRkKCd3YnInKTtcbiAgICAgICAgYWRkKCdydWJ5JywgJycsIFtcbiAgICAgICAgICBwaHJhc2luZ0NvbnRlbnQsXG4gICAgICAgICAgJ3J0IHJwJ1xuICAgICAgICBdLmpvaW4oJyAnKSk7XG4gICAgICAgIGFkZCgnZmlnY2FwdGlvbicsICcnLCBmbG93Q29udGVudCk7XG4gICAgICAgIGFkZCgnbWFyayBydCBycCBzdW1tYXJ5IGJkaScsICcnLCBwaHJhc2luZ0NvbnRlbnQpO1xuICAgICAgICBhZGQoJ2NhbnZhcycsICd3aWR0aCBoZWlnaHQnLCBmbG93Q29udGVudCk7XG4gICAgICAgIGFkZCgndmlkZW8nLCAnc3JjIGNyb3Nzb3JpZ2luIHBvc3RlciBwcmVsb2FkIGF1dG9wbGF5IG1lZGlhZ3JvdXAgbG9vcCAnICsgJ211dGVkIGNvbnRyb2xzIHdpZHRoIGhlaWdodCBidWZmZXJlZCcsIFtcbiAgICAgICAgICBmbG93Q29udGVudCxcbiAgICAgICAgICAndHJhY2sgc291cmNlJ1xuICAgICAgICBdLmpvaW4oJyAnKSk7XG4gICAgICAgIGFkZCgnYXVkaW8nLCAnc3JjIGNyb3Nzb3JpZ2luIHByZWxvYWQgYXV0b3BsYXkgbWVkaWFncm91cCBsb29wIG11dGVkIGNvbnRyb2xzICcgKyAnYnVmZmVyZWQgdm9sdW1lJywgW1xuICAgICAgICAgIGZsb3dDb250ZW50LFxuICAgICAgICAgICd0cmFjayBzb3VyY2UnXG4gICAgICAgIF0uam9pbignICcpKTtcbiAgICAgICAgYWRkKCdwaWN0dXJlJywgJycsICdpbWcgc291cmNlJyk7XG4gICAgICAgIGFkZCgnc291cmNlJywgJ3NyYyBzcmNzZXQgdHlwZSBtZWRpYSBzaXplcycpO1xuICAgICAgICBhZGQoJ3RyYWNrJywgJ2tpbmQgc3JjIHNyY2xhbmcgbGFiZWwgZGVmYXVsdCcpO1xuICAgICAgICBhZGQoJ2RhdGFsaXN0JywgJycsIFtcbiAgICAgICAgICBwaHJhc2luZ0NvbnRlbnQsXG4gICAgICAgICAgJ29wdGlvbidcbiAgICAgICAgXS5qb2luKCcgJykpO1xuICAgICAgICBhZGQoJ2FydGljbGUgc2VjdGlvbiBuYXYgYXNpZGUgbWFpbiBoZWFkZXIgZm9vdGVyJywgJycsIGZsb3dDb250ZW50KTtcbiAgICAgICAgYWRkKCdoZ3JvdXAnLCAnJywgJ2gxIGgyIGgzIGg0IGg1IGg2Jyk7XG4gICAgICAgIGFkZCgnZmlndXJlJywgJycsIFtcbiAgICAgICAgICBmbG93Q29udGVudCxcbiAgICAgICAgICAnZmlnY2FwdGlvbidcbiAgICAgICAgXS5qb2luKCcgJykpO1xuICAgICAgICBhZGQoJ3RpbWUnLCAnZGF0ZXRpbWUnLCBwaHJhc2luZ0NvbnRlbnQpO1xuICAgICAgICBhZGQoJ2RpYWxvZycsICdvcGVuJywgZmxvd0NvbnRlbnQpO1xuICAgICAgICBhZGQoJ2NvbW1hbmQnLCAndHlwZSBsYWJlbCBpY29uIGRpc2FibGVkIGNoZWNrZWQgcmFkaW9ncm91cCBjb21tYW5kJyk7XG4gICAgICAgIGFkZCgnb3V0cHV0JywgJ2ZvciBmb3JtIG5hbWUnLCBwaHJhc2luZ0NvbnRlbnQpO1xuICAgICAgICBhZGQoJ3Byb2dyZXNzJywgJ3ZhbHVlIG1heCcsIHBocmFzaW5nQ29udGVudCk7XG4gICAgICAgIGFkZCgnbWV0ZXInLCAndmFsdWUgbWluIG1heCBsb3cgaGlnaCBvcHRpbXVtJywgcGhyYXNpbmdDb250ZW50KTtcbiAgICAgICAgYWRkKCdkZXRhaWxzJywgJ29wZW4nLCBbXG4gICAgICAgICAgZmxvd0NvbnRlbnQsXG4gICAgICAgICAgJ3N1bW1hcnknXG4gICAgICAgIF0uam9pbignICcpKTtcbiAgICAgICAgYWRkKCdrZXlnZW4nLCAnYXV0b2ZvY3VzIGNoYWxsZW5nZSBkaXNhYmxlZCBmb3JtIGtleXR5cGUgbmFtZScpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgIT09ICdodG1sNS1zdHJpY3QnKSB7XG4gICAgICAgIGFkZEF0dHJzKCdzY3JpcHQnLCAnbGFuZ3VhZ2UgeG1sOnNwYWNlJyk7XG4gICAgICAgIGFkZEF0dHJzKCdzdHlsZScsICd4bWw6c3BhY2UnKTtcbiAgICAgICAgYWRkQXR0cnMoJ29iamVjdCcsICdkZWNsYXJlIGNsYXNzaWQgY29kZSBjb2RlYmFzZSBjb2RldHlwZSBhcmNoaXZlIHN0YW5kYnkgYWxpZ24gYm9yZGVyIGhzcGFjZSB2c3BhY2UnKTtcbiAgICAgICAgYWRkQXR0cnMoJ2VtYmVkJywgJ2FsaWduIG5hbWUgaHNwYWNlIHZzcGFjZScpO1xuICAgICAgICBhZGRBdHRycygncGFyYW0nLCAndmFsdWV0eXBlIHR5cGUnKTtcbiAgICAgICAgYWRkQXR0cnMoJ2EnLCAnY2hhcnNldCBuYW1lIHJldiBzaGFwZSBjb29yZHMnKTtcbiAgICAgICAgYWRkQXR0cnMoJ2JyJywgJ2NsZWFyJyk7XG4gICAgICAgIGFkZEF0dHJzKCdhcHBsZXQnLCAnY29kZWJhc2UgYXJjaGl2ZSBjb2RlIG9iamVjdCBhbHQgbmFtZSB3aWR0aCBoZWlnaHQgYWxpZ24gaHNwYWNlIHZzcGFjZScpO1xuICAgICAgICBhZGRBdHRycygnaW1nJywgJ25hbWUgbG9uZ2Rlc2MgYWxpZ24gYm9yZGVyIGhzcGFjZSB2c3BhY2UnKTtcbiAgICAgICAgYWRkQXR0cnMoJ2lmcmFtZScsICdsb25nZGVzYyBmcmFtZWJvcmRlciBtYXJnaW53aWR0aCBtYXJnaW5oZWlnaHQgc2Nyb2xsaW5nIGFsaWduJyk7XG4gICAgICAgIGFkZEF0dHJzKCdmb250IGJhc2Vmb250JywgJ3NpemUgY29sb3IgZmFjZScpO1xuICAgICAgICBhZGRBdHRycygnaW5wdXQnLCAndXNlbWFwIGFsaWduJyk7XG4gICAgICAgIGFkZEF0dHJzKCdzZWxlY3QnKTtcbiAgICAgICAgYWRkQXR0cnMoJ3RleHRhcmVhJyk7XG4gICAgICAgIGFkZEF0dHJzKCdoMSBoMiBoMyBoNCBoNSBoNiBkaXYgcCBsZWdlbmQgY2FwdGlvbicsICdhbGlnbicpO1xuICAgICAgICBhZGRBdHRycygndWwnLCAndHlwZSBjb21wYWN0Jyk7XG4gICAgICAgIGFkZEF0dHJzKCdsaScsICd0eXBlJyk7XG4gICAgICAgIGFkZEF0dHJzKCdvbCBkbCBtZW51IGRpcicsICdjb21wYWN0Jyk7XG4gICAgICAgIGFkZEF0dHJzKCdwcmUnLCAnd2lkdGggeG1sOnNwYWNlJyk7XG4gICAgICAgIGFkZEF0dHJzKCdocicsICdhbGlnbiBub3NoYWRlIHNpemUgd2lkdGgnKTtcbiAgICAgICAgYWRkQXR0cnMoJ2lzaW5kZXgnLCAncHJvbXB0Jyk7XG4gICAgICAgIGFkZEF0dHJzKCd0YWJsZScsICdzdW1tYXJ5IHdpZHRoIGZyYW1lIHJ1bGVzIGNlbGxzcGFjaW5nIGNlbGxwYWRkaW5nIGFsaWduIGJnY29sb3InKTtcbiAgICAgICAgYWRkQXR0cnMoJ2NvbCcsICd3aWR0aCBhbGlnbiBjaGFyIGNoYXJvZmYgdmFsaWduJyk7XG4gICAgICAgIGFkZEF0dHJzKCdjb2xncm91cCcsICd3aWR0aCBhbGlnbiBjaGFyIGNoYXJvZmYgdmFsaWduJyk7XG4gICAgICAgIGFkZEF0dHJzKCd0aGVhZCcsICdhbGlnbiBjaGFyIGNoYXJvZmYgdmFsaWduJyk7XG4gICAgICAgIGFkZEF0dHJzKCd0cicsICdhbGlnbiBjaGFyIGNoYXJvZmYgdmFsaWduIGJnY29sb3InKTtcbiAgICAgICAgYWRkQXR0cnMoJ3RoJywgJ2F4aXMgYWxpZ24gY2hhciBjaGFyb2ZmIHZhbGlnbiBub3dyYXAgYmdjb2xvciB3aWR0aCBoZWlnaHQnKTtcbiAgICAgICAgYWRkQXR0cnMoJ2Zvcm0nLCAnYWNjZXB0Jyk7XG4gICAgICAgIGFkZEF0dHJzKCd0ZCcsICdhYmJyIGF4aXMgc2NvcGUgYWxpZ24gY2hhciBjaGFyb2ZmIHZhbGlnbiBub3dyYXAgYmdjb2xvciB3aWR0aCBoZWlnaHQnKTtcbiAgICAgICAgYWRkQXR0cnMoJ3Rmb290JywgJ2FsaWduIGNoYXIgY2hhcm9mZiB2YWxpZ24nKTtcbiAgICAgICAgYWRkQXR0cnMoJ3Rib2R5JywgJ2FsaWduIGNoYXIgY2hhcm9mZiB2YWxpZ24nKTtcbiAgICAgICAgYWRkQXR0cnMoJ2FyZWEnLCAnbm9ocmVmJyk7XG4gICAgICAgIGFkZEF0dHJzKCdib2R5JywgJ2JhY2tncm91bmQgYmdjb2xvciB0ZXh0IGxpbmsgdmxpbmsgYWxpbmsnKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlICE9PSAnaHRtbDQnKSB7XG4gICAgICAgIGFkZEF0dHJzKCdpbnB1dCBidXR0b24gc2VsZWN0IHRleHRhcmVhJywgJ2F1dG9mb2N1cycpO1xuICAgICAgICBhZGRBdHRycygnaW5wdXQgdGV4dGFyZWEnLCAncGxhY2Vob2xkZXInKTtcbiAgICAgICAgYWRkQXR0cnMoJ2EnLCAnZG93bmxvYWQnKTtcbiAgICAgICAgYWRkQXR0cnMoJ2xpbmsgc2NyaXB0IGltZycsICdjcm9zc29yaWdpbicpO1xuICAgICAgICBhZGRBdHRycygnaW1nJywgJ2xvYWRpbmcnKTtcbiAgICAgICAgYWRkQXR0cnMoJ2lmcmFtZScsICdzYW5kYm94IHNlYW1sZXNzIGFsbG93IGFsbG93ZnVsbHNjcmVlbiBsb2FkaW5nJyk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSAhPT0gJ2h0bWw0Jykge1xuICAgICAgICBlYWNoJGUoW1xuICAgICAgICAgIHNjaGVtYS52aWRlbyxcbiAgICAgICAgICBzY2hlbWEuYXVkaW9cbiAgICAgICAgXSwgaXRlbSA9PiB7XG4gICAgICAgICAgZGVsZXRlIGl0ZW0uY2hpbGRyZW4uYXVkaW87XG4gICAgICAgICAgZGVsZXRlIGl0ZW0uY2hpbGRyZW4udmlkZW87XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZWFjaCRiKHNwbGl0JDEoJ2EgZm9ybSBtZXRlciBwcm9ncmVzcyBkZm4nKSwgbmFtZSA9PiB7XG4gICAgICAgIGlmIChzY2hlbWFbbmFtZV0pIHtcbiAgICAgICAgICBkZWxldGUgc2NoZW1hW25hbWVdLmNoaWxkcmVuW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGRlbGV0ZSBzY2hlbWEuY2FwdGlvbi5jaGlsZHJlbi50YWJsZTtcbiAgICAgIGRlbGV0ZSBzY2hlbWEuc2NyaXB0O1xuICAgICAgbG9va3VwQ2FjaGVbdHlwZV0gPSBzY2hlbWE7XG4gICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH07XG4gICAgY29uc3QgY29tcGlsZUVsZW1lbnRNYXAgPSAodmFsdWUsIG1vZGUpID0+IHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBjb25zdCBzdHlsZXMgPSB7fTtcbiAgICAgICAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlID0geyAnKic6IHZhbHVlIH07XG4gICAgICAgIH1cbiAgICAgICAgZWFjaCRiKHZhbHVlLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgIHN0eWxlc1trZXldID0gc3R5bGVzW2tleS50b1VwcGVyQ2FzZSgpXSA9IG1vZGUgPT09ICdtYXAnID8gbWFrZU1hcCQyKHZhbHVlLCAvWywgXS8pIDogZXhwbG9kZSQyKHZhbHVlLCAvWywgXS8pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHN0eWxlcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBTY2hlbWEgPSAoc2V0dGluZ3MgPSB7fSkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgZWxlbWVudHMgPSB7fTtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0ge307XG4gICAgICBsZXQgcGF0dGVybkVsZW1lbnRzID0gW107XG4gICAgICBjb25zdCBjdXN0b21FbGVtZW50c01hcCA9IHt9O1xuICAgICAgY29uc3Qgc3BlY2lhbEVsZW1lbnRzID0ge307XG4gICAgICBjb25zdCBjcmVhdGVMb29rdXBUYWJsZSA9IChvcHRpb24sIGRlZmF1bHRWYWx1ZSwgZXh0ZW5kV2l0aCkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHNldHRpbmdzW29wdGlvbl07XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICBsZXQgbmV3VmFsdWUgPSBtYXBDYWNoZVtvcHRpb25dO1xuICAgICAgICAgIGlmICghbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gY3JlYXRlTWFwKGRlZmF1bHRWYWx1ZSwgZXh0ZW5kV2l0aCk7XG4gICAgICAgICAgICBtYXBDYWNoZVtvcHRpb25dID0gbmV3VmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXdWYWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbWFrZU1hcCQyKHZhbHVlLCAvWywgXS8sIG1ha2VNYXAkMih2YWx1ZS50b1VwcGVyQ2FzZSgpLCAvWywgXS8pKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNjaGVtYVR5cGUgPSAoX2EgPSBzZXR0aW5ncy5zY2hlbWEpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICdodG1sNSc7XG4gICAgICBjb25zdCBzY2hlbWFJdGVtcyA9IGNvbXBpbGVTY2hlbWEoc2NoZW1hVHlwZSk7XG4gICAgICBpZiAoc2V0dGluZ3MudmVyaWZ5X2h0bWwgPT09IGZhbHNlKSB7XG4gICAgICAgIHNldHRpbmdzLnZhbGlkX2VsZW1lbnRzID0gJypbKl0nO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsaWRTdHlsZXMgPSBjb21waWxlRWxlbWVudE1hcChzZXR0aW5ncy52YWxpZF9zdHlsZXMpO1xuICAgICAgY29uc3QgaW52YWxpZFN0eWxlcyA9IGNvbXBpbGVFbGVtZW50TWFwKHNldHRpbmdzLmludmFsaWRfc3R5bGVzLCAnbWFwJyk7XG4gICAgICBjb25zdCB2YWxpZENsYXNzZXMgPSBjb21waWxlRWxlbWVudE1hcChzZXR0aW5ncy52YWxpZF9jbGFzc2VzLCAnbWFwJyk7XG4gICAgICBjb25zdCB3aGl0ZXNwYWNlRWxlbWVudHNNYXAgPSBjcmVhdGVMb29rdXBUYWJsZSgnd2hpdGVzcGFjZV9lbGVtZW50cycsICdwcmUgc2NyaXB0IG5vc2NyaXB0IHN0eWxlIHRleHRhcmVhIHZpZGVvIGF1ZGlvIGlmcmFtZSBvYmplY3QgY29kZScpO1xuICAgICAgY29uc3Qgc2VsZkNsb3NpbmdFbGVtZW50c01hcCA9IGNyZWF0ZUxvb2t1cFRhYmxlKCdzZWxmX2Nsb3NpbmdfZWxlbWVudHMnLCAnY29sZ3JvdXAgZGQgZHQgbGkgb3B0aW9uIHAgdGQgdGZvb3QgdGggdGhlYWQgdHInKTtcbiAgICAgIGNvbnN0IHZvaWRFbGVtZW50c01hcCA9IGNyZWF0ZUxvb2t1cFRhYmxlKCd2b2lkX2VsZW1lbnRzJywgJ2FyZWEgYmFzZSBiYXNlZm9udCBiciBjb2wgZnJhbWUgaHIgaW1nIGlucHV0IGlzaW5kZXggbGluayAnICsgJ21ldGEgcGFyYW0gZW1iZWQgc291cmNlIHdiciB0cmFjaycpO1xuICAgICAgY29uc3QgYm9vbEF0dHJNYXAgPSBjcmVhdGVMb29rdXBUYWJsZSgnYm9vbGVhbl9hdHRyaWJ1dGVzJywgJ2NoZWNrZWQgY29tcGFjdCBkZWNsYXJlIGRlZmVyIGRpc2FibGVkIGlzbWFwIG11bHRpcGxlIG5vaHJlZiBub3Jlc2l6ZSAnICsgJ25vc2hhZGUgbm93cmFwIHJlYWRvbmx5IHNlbGVjdGVkIGF1dG9wbGF5IGxvb3AgY29udHJvbHMgYWxsb3dmdWxsc2NyZWVuJyk7XG4gICAgICBjb25zdCBub25FbXB0eU9yTW92ZUNhcmV0QmVmb3JlT25FbnRlciA9ICd0ZCB0aCBpZnJhbWUgdmlkZW8gYXVkaW8gb2JqZWN0IHNjcmlwdCBjb2RlJztcbiAgICAgIGNvbnN0IG5vbkVtcHR5RWxlbWVudHNNYXAgPSBjcmVhdGVMb29rdXBUYWJsZSgnbm9uX2VtcHR5X2VsZW1lbnRzJywgbm9uRW1wdHlPck1vdmVDYXJldEJlZm9yZU9uRW50ZXIgKyAnIHByZScsIHZvaWRFbGVtZW50c01hcCk7XG4gICAgICBjb25zdCBtb3ZlQ2FyZXRCZWZvcmVPbkVudGVyRWxlbWVudHNNYXAgPSBjcmVhdGVMb29rdXBUYWJsZSgnbW92ZV9jYXJldF9iZWZvcmVfb25fZW50ZXJfZWxlbWVudHMnLCBub25FbXB0eU9yTW92ZUNhcmV0QmVmb3JlT25FbnRlciArICcgdGFibGUnLCB2b2lkRWxlbWVudHNNYXApO1xuICAgICAgY29uc3QgdGV4dEJsb2NrRWxlbWVudHNNYXAgPSBjcmVhdGVMb29rdXBUYWJsZSgndGV4dF9ibG9ja19lbGVtZW50cycsICdoMSBoMiBoMyBoNCBoNSBoNiBwIGRpdiBhZGRyZXNzIHByZSBmb3JtICcgKyAnYmxvY2txdW90ZSBjZW50ZXIgZGlyIGZpZWxkc2V0IGhlYWRlciBmb290ZXIgYXJ0aWNsZSBzZWN0aW9uIGhncm91cCBhc2lkZSBtYWluIG5hdiBmaWd1cmUnKTtcbiAgICAgIGNvbnN0IGJsb2NrRWxlbWVudHNNYXAgPSBjcmVhdGVMb29rdXBUYWJsZSgnYmxvY2tfZWxlbWVudHMnLCAnaHIgdGFibGUgdGJvZHkgdGhlYWQgdGZvb3QgJyArICd0aCB0ciB0ZCBsaSBvbCB1bCBjYXB0aW9uIGRsIGR0IGRkIG5vc2NyaXB0IG1lbnUgaXNpbmRleCBvcHRpb24gJyArICdkYXRhbGlzdCBzZWxlY3Qgb3B0Z3JvdXAgZmlnY2FwdGlvbiBkZXRhaWxzIHN1bW1hcnknLCB0ZXh0QmxvY2tFbGVtZW50c01hcCk7XG4gICAgICBjb25zdCB0ZXh0SW5saW5lRWxlbWVudHNNYXAgPSBjcmVhdGVMb29rdXBUYWJsZSgndGV4dF9pbmxpbmVfZWxlbWVudHMnLCAnc3BhbiBzdHJvbmcgYiBlbSBpIGZvbnQgcyBzdHJpa2UgdSB2YXIgY2l0ZSAnICsgJ2RmbiBjb2RlIG1hcmsgcSBzdXAgc3ViIHNhbXAnKTtcbiAgICAgIGNvbnN0IHRyYW5zcGFyZW50RWxlbWVudHNNYXAgPSBjcmVhdGVMb29rdXBUYWJsZSgndHJhbnNwYXJlbnRfZWxlbWVudHMnLCAnYSBpbnMgZGVsIGNhbnZhcyBtYXAnKTtcbiAgICAgIGVhY2gkYignc2NyaXB0IG5vc2NyaXB0IGlmcmFtZSBub2ZyYW1lcyBub2VtYmVkIHRpdGxlIHN0eWxlIHRleHRhcmVhIHhtcCBwbGFpbnRleHQnLnNwbGl0KCcgJyksIG5hbWUgPT4ge1xuICAgICAgICBzcGVjaWFsRWxlbWVudHNbbmFtZV0gPSBuZXcgUmVnRXhwKCc8LycgKyBuYW1lICsgJ1tePl0qPicsICdnaScpO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBwYXR0ZXJuVG9SZWdFeHAgPSBzdHIgPT4gbmV3IFJlZ0V4cCgnXicgKyBzdHIucmVwbGFjZSgvKFs/KypdKS9nLCAnLiQxJykgKyAnJCcpO1xuICAgICAgY29uc3QgYWRkVmFsaWRFbGVtZW50cyA9IHZhbGlkRWxlbWVudHMgPT4ge1xuICAgICAgICBjb25zdCBlbGVtZW50UnVsZVJlZ0V4cCA9IC9eKFsjK1xcLV0pPyhbXlxcWyFcXC9dKykoPzpcXC8oW15cXFshXSspKT8oPzooIT8pXFxbKFteXFxdXSspXSk/JC87XG4gICAgICAgIGNvbnN0IGF0dHJSdWxlUmVnRXhwID0gL14oWyFcXC1dKT8oXFx3K1tcXFxcOl06XFx3K3xbXj1+PF0rKT8oPzooWz1+PF0pKC4qKSk/JC87XG4gICAgICAgIGNvbnN0IGhhc1BhdHRlcm5zUmVnRXhwID0gL1sqPytdLztcbiAgICAgICAgaWYgKHZhbGlkRWxlbWVudHMpIHtcbiAgICAgICAgICBjb25zdCB2YWxpZEVsZW1lbnRzQXJyID0gc3BsaXQkMSh2YWxpZEVsZW1lbnRzLCAnLCcpO1xuICAgICAgICAgIGxldCBnbG9iYWxBdHRyaWJ1dGVzO1xuICAgICAgICAgIGxldCBnbG9iYWxBdHRyaWJ1dGVzT3JkZXI7XG4gICAgICAgICAgaWYgKGVsZW1lbnRzWydAJ10pIHtcbiAgICAgICAgICAgIGdsb2JhbEF0dHJpYnV0ZXMgPSBlbGVtZW50c1snQCddLmF0dHJpYnV0ZXM7XG4gICAgICAgICAgICBnbG9iYWxBdHRyaWJ1dGVzT3JkZXIgPSBlbGVtZW50c1snQCddLmF0dHJpYnV0ZXNPcmRlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChsZXQgZWkgPSAwLCBlbCA9IHZhbGlkRWxlbWVudHNBcnIubGVuZ3RoOyBlaSA8IGVsOyBlaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWF0Y2hlcyA9IGVsZW1lbnRSdWxlUmVnRXhwLmV4ZWModmFsaWRFbGVtZW50c0FycltlaV0pO1xuICAgICAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gbWF0Y2hlc1sxXTtcbiAgICAgICAgICAgICAgY29uc3QgZWxlbWVudE5hbWUgPSBtYXRjaGVzWzJdO1xuICAgICAgICAgICAgICBjb25zdCBvdXRwdXROYW1lID0gbWF0Y2hlc1szXTtcbiAgICAgICAgICAgICAgY29uc3QgYXR0ckRhdGEgPSBtYXRjaGVzWzVdO1xuICAgICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0ge307XG4gICAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXNPcmRlciA9IFtdO1xuICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0ge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlc09yZGVyXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGlmIChwcmVmaXggPT09ICcjJykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQucGFkZEVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocHJlZml4ID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobWF0Y2hlc1s0XSA9PT0gJyEnKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVFbXB0eUF0dHJzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZ2xvYmFsQXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgIGVhY2gkZChnbG9iYWxBdHRyaWJ1dGVzLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGdsb2JhbEF0dHJpYnV0ZXNPcmRlcikge1xuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc09yZGVyLnB1c2goLi4uZ2xvYmFsQXR0cmlidXRlc09yZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGF0dHJEYXRhKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXR0ckRhdGFzID0gc3BsaXQkMShhdHRyRGF0YSwgJ3wnKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBhaSA9IDAsIGFsID0gYXR0ckRhdGFzLmxlbmd0aDsgYWkgPCBhbDsgYWkrKykge1xuICAgICAgICAgICAgICAgICAgbWF0Y2hlcyA9IGF0dHJSdWxlUmVnRXhwLmV4ZWMoYXR0ckRhdGFzW2FpXSk7XG4gICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRyID0ge307XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJUeXBlID0gbWF0Y2hlc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0ck5hbWUgPSBtYXRjaGVzWzJdLnJlcGxhY2UoL1tcXFxcOl06L2csICc6Jyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJQcmVmaXggPSBtYXRjaGVzWzNdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG1hdGNoZXNbNF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRyVHlwZSA9PT0gJyEnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hdHRyaWJ1dGVzUmVxdWlyZWQgPSBlbGVtZW50LmF0dHJpYnV0ZXNSZXF1aXJlZCB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmF0dHJpYnV0ZXNSZXF1aXJlZC5wdXNoKGF0dHJOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICBhdHRyLnJlcXVpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0clR5cGUgPT09ICctJykge1xuICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzW2F0dHJOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzT3JkZXIuc3BsaWNlKGluQXJyYXkoYXR0cmlidXRlc09yZGVyLCBhdHRyTmFtZSksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRyUHJlZml4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJQcmVmaXggPT09ICc9Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hdHRyaWJ1dGVzRGVmYXVsdCA9IGVsZW1lbnQuYXR0cmlidXRlc0RlZmF1bHQgfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmF0dHJpYnV0ZXNEZWZhdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBhdHRyTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0ci5kZWZhdWx0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJQcmVmaXggPT09ICd+Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hdHRyaWJ1dGVzRm9yY2VkID0gZWxlbWVudC5hdHRyaWJ1dGVzRm9yY2VkIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hdHRyaWJ1dGVzRm9yY2VkLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBhdHRyTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0ci5mb3JjZWRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0clByZWZpeCA9PT0gJzwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyLnZhbGlkVmFsdWVzID0gbWFrZU1hcCQyKHZhbHVlLCAnPycpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzUGF0dGVybnNSZWdFeHAudGVzdChhdHRyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRyUGF0dGVybiA9IGF0dHI7XG4gICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hdHRyaWJ1dGVQYXR0ZXJucyA9IGVsZW1lbnQuYXR0cmlidXRlUGF0dGVybnMgfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgYXR0clBhdHRlcm4ucGF0dGVybiA9IHBhdHRlcm5Ub1JlZ0V4cChhdHRyTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hdHRyaWJ1dGVQYXR0ZXJucy5wdXNoKGF0dHJQYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIWF0dHJpYnV0ZXNbYXR0ck5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzT3JkZXIucHVzaChhdHRyTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNbYXR0ck5hbWVdID0gYXR0cjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWdsb2JhbEF0dHJpYnV0ZXMgJiYgZWxlbWVudE5hbWUgPT09ICdAJykge1xuICAgICAgICAgICAgICAgIGdsb2JhbEF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgICAgICAgICAgICAgIGdsb2JhbEF0dHJpYnV0ZXNPcmRlciA9IGF0dHJpYnV0ZXNPcmRlcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAob3V0cHV0TmFtZSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQub3V0cHV0TmFtZSA9IGVsZW1lbnROYW1lO1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzW291dHB1dE5hbWVdID0gZWxlbWVudDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaGFzUGF0dGVybnNSZWdFeHAudGVzdChlbGVtZW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXR0ZXJuRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgcGF0dGVybkVsZW1lbnQucGF0dGVybiA9IHBhdHRlcm5Ub1JlZ0V4cChlbGVtZW50TmFtZSk7XG4gICAgICAgICAgICAgICAgcGF0dGVybkVsZW1lbnRzLnB1c2gocGF0dGVybkVsZW1lbnQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzW2VsZW1lbnROYW1lXSA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBzZXRWYWxpZEVsZW1lbnRzID0gdmFsaWRFbGVtZW50cyA9PiB7XG4gICAgICAgIHBhdHRlcm5FbGVtZW50cyA9IFtdO1xuICAgICAgICBlYWNoJGUoa2V5cyhlbGVtZW50cyksIG5hbWUgPT4ge1xuICAgICAgICAgIGRlbGV0ZSBlbGVtZW50c1tuYW1lXTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFkZFZhbGlkRWxlbWVudHModmFsaWRFbGVtZW50cyk7XG4gICAgICAgIGVhY2gkYihzY2hlbWFJdGVtcywgKGVsZW1lbnQsIG5hbWUpID0+IHtcbiAgICAgICAgICBjaGlsZHJlbltuYW1lXSA9IGVsZW1lbnQuY2hpbGRyZW47XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGFkZEN1c3RvbUVsZW1lbnRzID0gY3VzdG9tRWxlbWVudHMgPT4ge1xuICAgICAgICBjb25zdCBjdXN0b21FbGVtZW50UmVnRXhwID0gL14ofik/KC4rKSQvO1xuICAgICAgICBpZiAoY3VzdG9tRWxlbWVudHMpIHtcbiAgICAgICAgICBkZWxldGUgbWFwQ2FjaGUudGV4dF9ibG9ja19lbGVtZW50cztcbiAgICAgICAgICBkZWxldGUgbWFwQ2FjaGUuYmxvY2tfZWxlbWVudHM7XG4gICAgICAgICAgZWFjaCRiKHNwbGl0JDEoY3VzdG9tRWxlbWVudHMsICcsJyksIHJ1bGUgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IGN1c3RvbUVsZW1lbnRSZWdFeHAuZXhlYyhydWxlKTtcbiAgICAgICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGlubGluZSA9IG1hdGNoZXNbMV0gPT09ICd+JztcbiAgICAgICAgICAgICAgY29uc3QgY2xvbmVOYW1lID0gaW5saW5lID8gJ3NwYW4nIDogJ2Rpdic7XG4gICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBtYXRjaGVzWzJdO1xuICAgICAgICAgICAgICBjaGlsZHJlbltuYW1lXSA9IGNoaWxkcmVuW2Nsb25lTmFtZV07XG4gICAgICAgICAgICAgIGN1c3RvbUVsZW1lbnRzTWFwW25hbWVdID0gY2xvbmVOYW1lO1xuICAgICAgICAgICAgICBub25FbXB0eUVsZW1lbnRzTWFwW25hbWUudG9VcHBlckNhc2UoKV0gPSB7fTtcbiAgICAgICAgICAgICAgbm9uRW1wdHlFbGVtZW50c01hcFtuYW1lXSA9IHt9O1xuICAgICAgICAgICAgICBpZiAoIWlubGluZSkge1xuICAgICAgICAgICAgICAgIGJsb2NrRWxlbWVudHNNYXBbbmFtZS50b1VwcGVyQ2FzZSgpXSA9IHt9O1xuICAgICAgICAgICAgICAgIGJsb2NrRWxlbWVudHNNYXBbbmFtZV0gPSB7fTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWVsZW1lbnRzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgbGV0IGN1c3RvbVJ1bGUgPSBlbGVtZW50c1tjbG9uZU5hbWVdO1xuICAgICAgICAgICAgICAgIGN1c3RvbVJ1bGUgPSBleHRlbmQkMih7fSwgY3VzdG9tUnVsZSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGN1c3RvbVJ1bGUucmVtb3ZlRW1wdHlBdHRycztcbiAgICAgICAgICAgICAgICBkZWxldGUgY3VzdG9tUnVsZS5yZW1vdmVFbXB0eTtcbiAgICAgICAgICAgICAgICBlbGVtZW50c1tuYW1lXSA9IGN1c3RvbVJ1bGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWFjaCRiKGNoaWxkcmVuLCAoZWxlbWVudCwgZWxtTmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50W2Nsb25lTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2VsbU5hbWVdID0gZWxlbWVudCA9IGV4dGVuZCQyKHt9LCBjaGlsZHJlbltlbG1OYW1lXSk7XG4gICAgICAgICAgICAgICAgICBlbGVtZW50W25hbWVdID0gZWxlbWVudFtjbG9uZU5hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBhZGRWYWxpZENoaWxkcmVuID0gdmFsaWRDaGlsZHJlbiA9PiB7XG4gICAgICAgIGNvbnN0IGNoaWxkUnVsZVJlZ0V4cCA9IC9eKFsrXFwtXT8pKFtBLVphLXowLTlfXFwtLlxcdTAwYjdcXHUwMGMwLVxcdTAwZDZcXHUwMGQ4LVxcdTAwZjZcXHUwMGY4LVxcdTAzN2RcXHUwMzdmLVxcdTFmZmZcXHUyMDBjLVxcdTIwMGRcXHUyMDNmLVxcdTIwNDBcXHUyMDcwLVxcdTIxOGZcXHUyYzAwLVxcdTJmZWZcXHUzMDAxLVxcdWQ3ZmZcXHVmOTAwLVxcdWZkY2ZcXHVmZGYwLVxcdWZmZmRdKylcXFsoW15cXF1dKyldJC87XG4gICAgICAgIGRlbGV0ZSBsb29rdXBDYWNoZVtzY2hlbWFUeXBlXTtcbiAgICAgICAgaWYgKHZhbGlkQ2hpbGRyZW4pIHtcbiAgICAgICAgICBlYWNoJGIoc3BsaXQkMSh2YWxpZENoaWxkcmVuLCAnLCcpLCBydWxlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSBjaGlsZFJ1bGVSZWdFeHAuZXhlYyhydWxlKTtcbiAgICAgICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHByZWZpeCA9IG1hdGNoZXNbMV07XG4gICAgICAgICAgICAgIGxldCBwYXJlbnQ7XG4gICAgICAgICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBjaGlsZHJlblttYXRjaGVzWzJdXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBjaGlsZHJlblttYXRjaGVzWzJdXSA9IHsgJyNjb21tZW50Jzoge30gfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwYXJlbnQgPSBjaGlsZHJlblttYXRjaGVzWzJdXTtcbiAgICAgICAgICAgICAgZWFjaCRiKHNwbGl0JDEobWF0Y2hlc1szXSwgJ3wnKSwgY2hpbGQgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwcmVmaXggPT09ICctJykge1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhcmVudFtjaGlsZF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHBhcmVudFtjaGlsZF0gPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0RWxlbWVudFJ1bGUgPSBuYW1lID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW25hbWVdO1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIGxldCBpID0gcGF0dGVybkVsZW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIGNvbnN0IHBhdHRlcm5FbGVtZW50ID0gcGF0dGVybkVsZW1lbnRzW2ldO1xuICAgICAgICAgIGlmIChwYXR0ZXJuRWxlbWVudC5wYXR0ZXJuLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXR0ZXJuRWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH07XG4gICAgICBpZiAoIXNldHRpbmdzLnZhbGlkX2VsZW1lbnRzKSB7XG4gICAgICAgIGVhY2gkYihzY2hlbWFJdGVtcywgKGVsZW1lbnQsIG5hbWUpID0+IHtcbiAgICAgICAgICBlbGVtZW50c1tuYW1lXSA9IHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IGVsZW1lbnQuYXR0cmlidXRlcyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNPcmRlcjogZWxlbWVudC5hdHRyaWJ1dGVzT3JkZXJcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNoaWxkcmVuW25hbWVdID0gZWxlbWVudC5jaGlsZHJlbjtcbiAgICAgICAgfSk7XG4gICAgICAgIGVhY2gkYihzcGxpdCQxKCdzdHJvbmcvYiBlbS9pJyksIGl0ZW0gPT4ge1xuICAgICAgICAgIGNvbnN0IGl0ZW1zID0gc3BsaXQkMShpdGVtLCAnLycpO1xuICAgICAgICAgIGVsZW1lbnRzW2l0ZW1zWzFdXS5vdXRwdXROYW1lID0gaXRlbXNbMF07XG4gICAgICAgIH0pO1xuICAgICAgICBlYWNoJGIodGV4dElubGluZUVsZW1lbnRzTWFwLCAoX3ZhbCwgbmFtZSkgPT4ge1xuICAgICAgICAgIGlmIChlbGVtZW50c1tuYW1lXSkge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLnBhZGRfZW1wdHlfYmxvY2tfaW5saW5lX2NoaWxkcmVuKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnRzW25hbWVdLnBhZGRJbkVtcHR5QmxvY2sgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbWVudHNbbmFtZV0ucmVtb3ZlRW1wdHkgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGVhY2gkYihzcGxpdCQxKCdvbCB1bCBibG9ja3F1b3RlIGEgdGFibGUgdGJvZHknKSwgbmFtZSA9PiB7XG4gICAgICAgICAgaWYgKGVsZW1lbnRzW25hbWVdKSB7XG4gICAgICAgICAgICBlbGVtZW50c1tuYW1lXS5yZW1vdmVFbXB0eSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZWFjaCRiKHNwbGl0JDEoJ3AgaDEgaDIgaDMgaDQgaDUgaDYgdGggdGQgcHJlIGRpdiBhZGRyZXNzIGNhcHRpb24gbGknKSwgbmFtZSA9PiB7XG4gICAgICAgICAgZWxlbWVudHNbbmFtZV0ucGFkZEVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVhY2gkYihzcGxpdCQxKCdzcGFuJyksIG5hbWUgPT4ge1xuICAgICAgICAgIGVsZW1lbnRzW25hbWVdLnJlbW92ZUVtcHR5QXR0cnMgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFZhbGlkRWxlbWVudHMoc2V0dGluZ3MudmFsaWRfZWxlbWVudHMpO1xuICAgICAgfVxuICAgICAgYWRkQ3VzdG9tRWxlbWVudHMoc2V0dGluZ3MuY3VzdG9tX2VsZW1lbnRzKTtcbiAgICAgIGFkZFZhbGlkQ2hpbGRyZW4oc2V0dGluZ3MudmFsaWRfY2hpbGRyZW4pO1xuICAgICAgYWRkVmFsaWRFbGVtZW50cyhzZXR0aW5ncy5leHRlbmRlZF92YWxpZF9lbGVtZW50cyk7XG4gICAgICBhZGRWYWxpZENoaWxkcmVuKCcrb2xbdWx8b2xdLCt1bFt1bHxvbF0nKTtcbiAgICAgIGVhY2gkYih7XG4gICAgICAgIGRkOiAnZGwnLFxuICAgICAgICBkdDogJ2RsJyxcbiAgICAgICAgbGk6ICd1bCBvbCcsXG4gICAgICAgIHRkOiAndHInLFxuICAgICAgICB0aDogJ3RyJyxcbiAgICAgICAgdHI6ICd0Ym9keSB0aGVhZCB0Zm9vdCcsXG4gICAgICAgIHRib2R5OiAndGFibGUnLFxuICAgICAgICB0aGVhZDogJ3RhYmxlJyxcbiAgICAgICAgdGZvb3Q6ICd0YWJsZScsXG4gICAgICAgIGxlZ2VuZDogJ2ZpZWxkc2V0JyxcbiAgICAgICAgYXJlYTogJ21hcCcsXG4gICAgICAgIHBhcmFtOiAndmlkZW8gYXVkaW8gb2JqZWN0J1xuICAgICAgfSwgKHBhcmVudHMsIGl0ZW0pID0+IHtcbiAgICAgICAgaWYgKGVsZW1lbnRzW2l0ZW1dKSB7XG4gICAgICAgICAgZWxlbWVudHNbaXRlbV0ucGFyZW50c1JlcXVpcmVkID0gc3BsaXQkMShwYXJlbnRzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoc2V0dGluZ3MuaW52YWxpZF9lbGVtZW50cykge1xuICAgICAgICBlYWNoJGIoZXhwbG9kZSQyKHNldHRpbmdzLmludmFsaWRfZWxlbWVudHMpLCBpdGVtID0+IHtcbiAgICAgICAgICBpZiAoZWxlbWVudHNbaXRlbV0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSBlbGVtZW50c1tpdGVtXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCFnZXRFbGVtZW50UnVsZSgnc3BhbicpKSB7XG4gICAgICAgIGFkZFZhbGlkRWxlbWVudHMoJ3NwYW5bIWRhdGEtbWNlLXR5cGV8Kl0nKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGdldFZhbGlkU3R5bGVzID0gY29uc3RhbnQodmFsaWRTdHlsZXMpO1xuICAgICAgY29uc3QgZ2V0SW52YWxpZFN0eWxlcyA9IGNvbnN0YW50KGludmFsaWRTdHlsZXMpO1xuICAgICAgY29uc3QgZ2V0VmFsaWRDbGFzc2VzID0gY29uc3RhbnQodmFsaWRDbGFzc2VzKTtcbiAgICAgIGNvbnN0IGdldEJvb2xBdHRycyA9IGNvbnN0YW50KGJvb2xBdHRyTWFwKTtcbiAgICAgIGNvbnN0IGdldEJsb2NrRWxlbWVudHMgPSBjb25zdGFudChibG9ja0VsZW1lbnRzTWFwKTtcbiAgICAgIGNvbnN0IGdldFRleHRCbG9ja0VsZW1lbnRzID0gY29uc3RhbnQodGV4dEJsb2NrRWxlbWVudHNNYXApO1xuICAgICAgY29uc3QgZ2V0VGV4dElubGluZUVsZW1lbnRzID0gY29uc3RhbnQodGV4dElubGluZUVsZW1lbnRzTWFwKTtcbiAgICAgIGNvbnN0IGdldFZvaWRFbGVtZW50cyA9IGNvbnN0YW50KE9iamVjdC5zZWFsKHZvaWRFbGVtZW50c01hcCkpO1xuICAgICAgY29uc3QgZ2V0U2VsZkNsb3NpbmdFbGVtZW50cyA9IGNvbnN0YW50KHNlbGZDbG9zaW5nRWxlbWVudHNNYXApO1xuICAgICAgY29uc3QgZ2V0Tm9uRW1wdHlFbGVtZW50cyA9IGNvbnN0YW50KG5vbkVtcHR5RWxlbWVudHNNYXApO1xuICAgICAgY29uc3QgZ2V0TW92ZUNhcmV0QmVmb3JlT25FbnRlckVsZW1lbnRzID0gY29uc3RhbnQobW92ZUNhcmV0QmVmb3JlT25FbnRlckVsZW1lbnRzTWFwKTtcbiAgICAgIGNvbnN0IGdldFdoaXRlc3BhY2VFbGVtZW50cyA9IGNvbnN0YW50KHdoaXRlc3BhY2VFbGVtZW50c01hcCk7XG4gICAgICBjb25zdCBnZXRUcmFuc3BhcmVudEVsZW1lbnRzID0gY29uc3RhbnQodHJhbnNwYXJlbnRFbGVtZW50c01hcCk7XG4gICAgICBjb25zdCBnZXRTcGVjaWFsRWxlbWVudHMgPSBjb25zdGFudChPYmplY3Quc2VhbChzcGVjaWFsRWxlbWVudHMpKTtcbiAgICAgIGNvbnN0IGlzVmFsaWRDaGlsZCA9IChuYW1lLCBjaGlsZCkgPT4ge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBjaGlsZHJlbltuYW1lLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICByZXR1cm4gISEocGFyZW50ICYmIHBhcmVudFtjaGlsZC50b0xvd2VyQ2FzZSgpXSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgaXNWYWxpZCA9IChuYW1lLCBhdHRyKSA9PiB7XG4gICAgICAgIGNvbnN0IHJ1bGUgPSBnZXRFbGVtZW50UnVsZShuYW1lKTtcbiAgICAgICAgaWYgKHJ1bGUpIHtcbiAgICAgICAgICBpZiAoYXR0cikge1xuICAgICAgICAgICAgaWYgKHJ1bGUuYXR0cmlidXRlc1thdHRyXSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGF0dHJQYXR0ZXJucyA9IHJ1bGUuYXR0cmlidXRlUGF0dGVybnM7XG4gICAgICAgICAgICBpZiAoYXR0clBhdHRlcm5zKSB7XG4gICAgICAgICAgICAgIGxldCBpID0gYXR0clBhdHRlcm5zLmxlbmd0aDtcbiAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgIGlmIChhdHRyUGF0dGVybnNbaV0ucGF0dGVybi50ZXN0KGF0dHIpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgICBjb25zdCBnZXRDdXN0b21FbGVtZW50cyA9IGNvbnN0YW50KGN1c3RvbUVsZW1lbnRzTWFwKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHNjaGVtYVR5cGUsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBlbGVtZW50cyxcbiAgICAgICAgZ2V0VmFsaWRTdHlsZXMsXG4gICAgICAgIGdldFZhbGlkQ2xhc3NlcyxcbiAgICAgICAgZ2V0QmxvY2tFbGVtZW50cyxcbiAgICAgICAgZ2V0SW52YWxpZFN0eWxlcyxcbiAgICAgICAgZ2V0Vm9pZEVsZW1lbnRzLFxuICAgICAgICBnZXRUZXh0QmxvY2tFbGVtZW50cyxcbiAgICAgICAgZ2V0VGV4dElubGluZUVsZW1lbnRzLFxuICAgICAgICBnZXRCb29sQXR0cnMsXG4gICAgICAgIGdldEVsZW1lbnRSdWxlLFxuICAgICAgICBnZXRTZWxmQ2xvc2luZ0VsZW1lbnRzLFxuICAgICAgICBnZXROb25FbXB0eUVsZW1lbnRzLFxuICAgICAgICBnZXRNb3ZlQ2FyZXRCZWZvcmVPbkVudGVyRWxlbWVudHMsXG4gICAgICAgIGdldFdoaXRlc3BhY2VFbGVtZW50cyxcbiAgICAgICAgZ2V0VHJhbnNwYXJlbnRFbGVtZW50cyxcbiAgICAgICAgZ2V0U3BlY2lhbEVsZW1lbnRzLFxuICAgICAgICBpc1ZhbGlkQ2hpbGQsXG4gICAgICAgIGlzVmFsaWQsXG4gICAgICAgIGdldEN1c3RvbUVsZW1lbnRzLFxuICAgICAgICBhZGRWYWxpZEVsZW1lbnRzLFxuICAgICAgICBzZXRWYWxpZEVsZW1lbnRzLFxuICAgICAgICBhZGRDdXN0b21FbGVtZW50cyxcbiAgICAgICAgYWRkVmFsaWRDaGlsZHJlblxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgU3R5bGVzID0gKHNldHRpbmdzID0ge30sIHNjaGVtYSkgPT4ge1xuICAgICAgY29uc3QgdXJsT3JTdHJSZWdFeHAgPSAvKD86dXJsKD86KD86XFwoXFxzKlxcXCIoW15cXFwiXSspXFxcIlxccypcXCkpfCg/OlxcKFxccypcXCcoW15cXCddKylcXCdcXHMqXFwpKXwoPzpcXChcXHMqKFteKVxcc10rKVxccypcXCkpKSl8KD86XFwnKFteXFwnXSspXFwnKXwoPzpcXFwiKFteXFxcIl0rKVxcXCIpL2dpO1xuICAgICAgY29uc3Qgc3R5bGVSZWdFeHAgPSAvXFxzKihbXjpdKyk6XFxzKihbXjtdKyk7Py9nO1xuICAgICAgY29uc3QgdHJpbVJpZ2h0UmVnRXhwID0gL1xccyskLztcbiAgICAgIGNvbnN0IGVuY29kaW5nTG9va3VwID0ge307XG4gICAgICBsZXQgdmFsaWRTdHlsZXM7XG4gICAgICBsZXQgaW52YWxpZFN0eWxlcztcbiAgICAgIGNvbnN0IGludmlzaWJsZUNoYXIgPSB6ZXJvV2lkdGg7XG4gICAgICBpZiAoc2NoZW1hKSB7XG4gICAgICAgIHZhbGlkU3R5bGVzID0gc2NoZW1hLmdldFZhbGlkU3R5bGVzKCk7XG4gICAgICAgIGludmFsaWRTdHlsZXMgPSBzY2hlbWEuZ2V0SW52YWxpZFN0eWxlcygpO1xuICAgICAgfVxuICAgICAgY29uc3QgZW5jb2RpbmdJdGVtcyA9IChgXFxcXFwiIFxcXFwnIFxcXFw7IFxcXFw6IDsgOiBgICsgaW52aXNpYmxlQ2hhcikuc3BsaXQoJyAnKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW5jb2RpbmdJdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBlbmNvZGluZ0xvb2t1cFtlbmNvZGluZ0l0ZW1zW2ldXSA9IGludmlzaWJsZUNoYXIgKyBpO1xuICAgICAgICBlbmNvZGluZ0xvb2t1cFtpbnZpc2libGVDaGFyICsgaV0gPSBlbmNvZGluZ0l0ZW1zW2ldO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2VsZiA9IHtcbiAgICAgICAgcGFyc2U6IGNzcyA9PiB7XG4gICAgICAgICAgY29uc3Qgc3R5bGVzID0ge307XG4gICAgICAgICAgbGV0IGlzRW5jb2RlZCA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IHVybENvbnZlcnRlciA9IHNldHRpbmdzLnVybF9jb252ZXJ0ZXI7XG4gICAgICAgICAgY29uc3QgdXJsQ29udmVydGVyU2NvcGUgPSBzZXR0aW5ncy51cmxfY29udmVydGVyX3Njb3BlIHx8IHNlbGY7XG4gICAgICAgICAgY29uc3QgY29tcHJlc3MgPSAocHJlZml4LCBzdWZmaXgsIG5vSm9pbikgPT4ge1xuICAgICAgICAgICAgY29uc3QgdG9wID0gc3R5bGVzW3ByZWZpeCArICctdG9wJyArIHN1ZmZpeF07XG4gICAgICAgICAgICBpZiAoIXRvcCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHN0eWxlc1twcmVmaXggKyAnLXJpZ2h0JyArIHN1ZmZpeF07XG4gICAgICAgICAgICBpZiAoIXJpZ2h0KSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJvdHRvbSA9IHN0eWxlc1twcmVmaXggKyAnLWJvdHRvbScgKyBzdWZmaXhdO1xuICAgICAgICAgICAgaWYgKCFib3R0b20pIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGVmdCA9IHN0eWxlc1twcmVmaXggKyAnLWxlZnQnICsgc3VmZml4XTtcbiAgICAgICAgICAgIGlmICghbGVmdCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBib3ggPSBbXG4gICAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICAgIGJvdHRvbSxcbiAgICAgICAgICAgICAgbGVmdFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGxldCBpID0gYm94Lmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgIGlmIChib3hbaV0gIT09IGJveFtpICsgMV0pIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPiAtMSAmJiBub0pvaW4pIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3R5bGVzW3ByZWZpeCArIHN1ZmZpeF0gPSBpID09PSAtMSA/IGJveFswXSA6IGJveC5qb2luKCcgJyk7XG4gICAgICAgICAgICBkZWxldGUgc3R5bGVzW3ByZWZpeCArICctdG9wJyArIHN1ZmZpeF07XG4gICAgICAgICAgICBkZWxldGUgc3R5bGVzW3ByZWZpeCArICctcmlnaHQnICsgc3VmZml4XTtcbiAgICAgICAgICAgIGRlbGV0ZSBzdHlsZXNbcHJlZml4ICsgJy1ib3R0b20nICsgc3VmZml4XTtcbiAgICAgICAgICAgIGRlbGV0ZSBzdHlsZXNbcHJlZml4ICsgJy1sZWZ0JyArIHN1ZmZpeF07XG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25zdCBjYW5Db21wcmVzcyA9IGtleSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHN0eWxlc1trZXldO1xuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSB2YWx1ZS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgbGV0IGkgPSB2YWx1ZXMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICBpZiAodmFsdWVzW2ldICE9PSB2YWx1ZXNbMF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0eWxlc1trZXldID0gdmFsdWVzWzBdO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25zdCBjb21wcmVzczIgPSAodGFyZ2V0LCBhLCBiLCBjKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWNhbkNvbXByZXNzKGEpKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY2FuQ29tcHJlc3MoYikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjYW5Db21wcmVzcyhjKSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHlsZXNbdGFyZ2V0XSA9IHN0eWxlc1thXSArICcgJyArIHN0eWxlc1tiXSArICcgJyArIHN0eWxlc1tjXTtcbiAgICAgICAgICAgIGRlbGV0ZSBzdHlsZXNbYV07XG4gICAgICAgICAgICBkZWxldGUgc3R5bGVzW2JdO1xuICAgICAgICAgICAgZGVsZXRlIHN0eWxlc1tjXTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IGVuY29kZSA9IHN0ciA9PiB7XG4gICAgICAgICAgICBpc0VuY29kZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kaW5nTG9va3VwW3N0cl07XG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25zdCBkZWNvZGUgPSAoc3RyLCBrZWVwU2xhc2hlcykgPT4ge1xuICAgICAgICAgICAgaWYgKGlzRW5jb2RlZCkge1xuICAgICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvXFx1RkVGRlswLTldL2csIHN0ciA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuY29kaW5nTG9va3VwW3N0cl07XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFrZWVwU2xhc2hlcykge1xuICAgICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvXFxcXChbXFwnXFxcIjs6XSkvZywgJyQxJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgZGVjb2RlU2luZ2xlSGV4U2VxdWVuY2UgPSBlc2NTZXEgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoZXNjU2VxLnNsaWNlKDEpLCAxNikpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgZGVjb2RlSGV4U2VxdWVuY2VzID0gdmFsdWUgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1xcXFxbMC05YS1mXSsvZ2ksIGRlY29kZVNpbmdsZUhleFNlcXVlbmNlKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IHByb2Nlc3NVcmwgPSAobWF0Y2gsIHVybCwgdXJsMiwgdXJsMywgc3RyLCBzdHIyKSA9PiB7XG4gICAgICAgICAgICBzdHIgPSBzdHIgfHwgc3RyMjtcbiAgICAgICAgICAgIGlmIChzdHIpIHtcbiAgICAgICAgICAgICAgc3RyID0gZGVjb2RlKHN0cik7XG4gICAgICAgICAgICAgIHJldHVybiBgJ2AgKyBzdHIucmVwbGFjZSgvXFwnL2csIGBcXFxcJ2ApICsgYCdgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXJsID0gZGVjb2RlKHVybCB8fCB1cmwyIHx8IHVybDMgfHwgJycpO1xuICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5hbGxvd19zY3JpcHRfdXJscykge1xuICAgICAgICAgICAgICBjb25zdCBzY3JpcHRVcmwgPSB1cmwucmVwbGFjZSgvW1xcc1xcclxcbl0rL2csICcnKTtcbiAgICAgICAgICAgICAgaWYgKC8oamF2YXx2YilzY3JpcHQ6L2kudGVzdChzY3JpcHRVcmwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghc2V0dGluZ3MuYWxsb3dfc3ZnX2RhdGFfdXJscyAmJiAvXmRhdGE6aW1hZ2VcXC9zdmcvaS50ZXN0KHNjcmlwdFVybCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1cmxDb252ZXJ0ZXIpIHtcbiAgICAgICAgICAgICAgdXJsID0gdXJsQ29udmVydGVyLmNhbGwodXJsQ29udmVydGVyU2NvcGUsIHVybCwgJ3N0eWxlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYHVybCgnYCArIHVybC5yZXBsYWNlKC9cXCcvZywgYFxcXFwnYCkgKyBgJylgO1xuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKGNzcykge1xuICAgICAgICAgICAgY3NzID0gY3NzLnJlcGxhY2UoL1tcXHUwMDAwLVxcdTAwMUZdL2csICcnKTtcbiAgICAgICAgICAgIGNzcyA9IGNzcy5yZXBsYWNlKC9cXFxcW1xcXCJcXCc7OlxcdUZFRkZdL2csIGVuY29kZSkucmVwbGFjZSgvXFxcIlteXFxcIl0rXFxcInxcXCdbXlxcJ10rXFwnL2csIHN0ciA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvWzs6XS9nLCBlbmNvZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgbWF0Y2hlcztcbiAgICAgICAgICAgIHdoaWxlIChtYXRjaGVzID0gc3R5bGVSZWdFeHAuZXhlYyhjc3MpKSB7XG4gICAgICAgICAgICAgIHN0eWxlUmVnRXhwLmxhc3RJbmRleCA9IG1hdGNoZXMuaW5kZXggKyBtYXRjaGVzWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgbGV0IG5hbWUgPSBtYXRjaGVzWzFdLnJlcGxhY2UodHJpbVJpZ2h0UmVnRXhwLCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgbGV0IHZhbHVlID0gbWF0Y2hlc1syXS5yZXBsYWNlKHRyaW1SaWdodFJlZ0V4cCwgJycpO1xuICAgICAgICAgICAgICBpZiAobmFtZSAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBkZWNvZGVIZXhTZXF1ZW5jZXMobmFtZSk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBkZWNvZGVIZXhTZXF1ZW5jZXModmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lLmluZGV4T2YoaW52aXNpYmxlQ2hhcikgIT09IC0xIHx8IG5hbWUuaW5kZXhPZignXCInKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXNldHRpbmdzLmFsbG93X3NjcmlwdF91cmxzICYmIChuYW1lID09PSAnYmVoYXZpb3InIHx8IC9leHByZXNzaW9uXFxzKlxcKHxcXC9cXCp8XFwqXFwvLy50ZXN0KHZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2ZvbnQtd2VpZ2h0JyAmJiB2YWx1ZSA9PT0gJzcwMCcpIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gJ2JvbGQnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2NvbG9yJyB8fCBuYW1lID09PSAnYmFja2dyb3VuZC1jb2xvcicpIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHVybE9yU3RyUmVnRXhwLCBwcm9jZXNzVXJsKTtcbiAgICAgICAgICAgICAgICBzdHlsZXNbbmFtZV0gPSBpc0VuY29kZWQgPyBkZWNvZGUodmFsdWUsIHRydWUpIDogdmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbXByZXNzKCdib3JkZXInLCAnJywgdHJ1ZSk7XG4gICAgICAgICAgICBjb21wcmVzcygnYm9yZGVyJywgJy13aWR0aCcpO1xuICAgICAgICAgICAgY29tcHJlc3MoJ2JvcmRlcicsICctY29sb3InKTtcbiAgICAgICAgICAgIGNvbXByZXNzKCdib3JkZXInLCAnLXN0eWxlJyk7XG4gICAgICAgICAgICBjb21wcmVzcygncGFkZGluZycsICcnKTtcbiAgICAgICAgICAgIGNvbXByZXNzKCdtYXJnaW4nLCAnJyk7XG4gICAgICAgICAgICBjb21wcmVzczIoJ2JvcmRlcicsICdib3JkZXItd2lkdGgnLCAnYm9yZGVyLXN0eWxlJywgJ2JvcmRlci1jb2xvcicpO1xuICAgICAgICAgICAgaWYgKHN0eWxlcy5ib3JkZXIgPT09ICdtZWRpdW0gbm9uZScpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIHN0eWxlcy5ib3JkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3R5bGVzWydib3JkZXItaW1hZ2UnXSA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBzdHlsZXNbJ2JvcmRlci1pbWFnZSddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3R5bGVzO1xuICAgICAgICB9LFxuICAgICAgICBzZXJpYWxpemU6IChzdHlsZXMsIGVsZW1lbnROYW1lKSA9PiB7XG4gICAgICAgICAgbGV0IGNzcyA9ICcnO1xuICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZVN0eWxlcyA9IChlbGVtTmFtZSwgdmFsaWRTdHlsZUxpc3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0eWxlTGlzdCA9IHZhbGlkU3R5bGVMaXN0W2VsZW1OYW1lXTtcbiAgICAgICAgICAgIGlmIChzdHlsZUxpc3QpIHtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBzdHlsZUxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IHN0eWxlTGlzdFtpXTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHN0eWxlc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIGNzcyArPSAoY3NzLmxlbmd0aCA+IDAgPyAnICcgOiAnJykgKyBuYW1lICsgJzogJyArIHZhbHVlICsgJzsnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgaXNWYWxpZCA9IChuYW1lLCBlbGVtTmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFpbnZhbGlkU3R5bGVzIHx8ICFlbGVtTmFtZSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzdHlsZU1hcCA9IGludmFsaWRTdHlsZXNbJyonXTtcbiAgICAgICAgICAgIGlmIChzdHlsZU1hcCAmJiBzdHlsZU1hcFtuYW1lXSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHlsZU1hcCA9IGludmFsaWRTdHlsZXNbZWxlbU5hbWVdO1xuICAgICAgICAgICAgcmV0dXJuICEoc3R5bGVNYXAgJiYgc3R5bGVNYXBbbmFtZV0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKGVsZW1lbnROYW1lICYmIHZhbGlkU3R5bGVzKSB7XG4gICAgICAgICAgICBzZXJpYWxpemVTdHlsZXMoJyonLCB2YWxpZFN0eWxlcyk7XG4gICAgICAgICAgICBzZXJpYWxpemVTdHlsZXMoZWxlbWVudE5hbWUsIHZhbGlkU3R5bGVzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWFjaCRkKHN0eWxlcywgKHZhbHVlLCBuYW1lKSA9PiB7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiBpc1ZhbGlkKG5hbWUsIGVsZW1lbnROYW1lKSkge1xuICAgICAgICAgICAgICAgIGNzcyArPSAoY3NzLmxlbmd0aCA+IDAgPyAnICcgOiAnJykgKyBuYW1lICsgJzogJyArIHZhbHVlICsgJzsnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNzcztcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICBjb25zdCBkZXByZWNhdGVkID0ge1xuICAgICAga2V5TG9jYXRpb246IHRydWUsXG4gICAgICBsYXllclg6IHRydWUsXG4gICAgICBsYXllclk6IHRydWUsXG4gICAgICByZXR1cm5WYWx1ZTogdHJ1ZSxcbiAgICAgIHdlYmtpdE1vdmVtZW50WDogdHJ1ZSxcbiAgICAgIHdlYmtpdE1vdmVtZW50WTogdHJ1ZSxcbiAgICAgIGtleUlkZW50aWZpZXI6IHRydWUsXG4gICAgICBtb3pQcmVzc3VyZTogdHJ1ZVxuICAgIH07XG4gICAgY29uc3QgaXNOYXRpdmVFdmVudCA9IGV2ZW50ID0+IGV2ZW50IGluc3RhbmNlb2YgRXZlbnQgfHwgaXNGdW5jdGlvbihldmVudC5pbml0RXZlbnQpO1xuICAgIGNvbnN0IGhhc0lzRGVmYXVsdFByZXZlbnRlZCA9IGV2ZW50ID0+IGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCA9PT0gYWx3YXlzIHx8IGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCA9PT0gbmV2ZXI7XG4gICAgY29uc3QgbmVlZHNOb3JtYWxpemluZyA9IGV2ZW50ID0+IGlzTnVsbGFibGUoZXZlbnQucHJldmVudERlZmF1bHQpIHx8IGlzTmF0aXZlRXZlbnQoZXZlbnQpO1xuICAgIGNvbnN0IGNsb25lJDMgPSAob3JpZ2luYWxFdmVudCwgZGF0YSkgPT4ge1xuICAgICAgY29uc3QgZXZlbnQgPSBkYXRhICE9PSBudWxsICYmIGRhdGEgIT09IHZvaWQgMCA/IGRhdGEgOiB7fTtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBvcmlnaW5hbEV2ZW50KSB7XG4gICAgICAgIGlmICghaGFzJDIoZGVwcmVjYXRlZCwgbmFtZSkpIHtcbiAgICAgICAgICBldmVudFtuYW1lXSA9IG9yaWdpbmFsRXZlbnRbbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc05vbk51bGxhYmxlKG9yaWdpbmFsRXZlbnQuY29tcG9zZWRQYXRoKSkge1xuICAgICAgICBldmVudC5jb21wb3NlZFBhdGggPSAoKSA9PiBvcmlnaW5hbEV2ZW50LmNvbXBvc2VkUGF0aCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH07XG4gICAgY29uc3Qgbm9ybWFsaXplJDMgPSAodHlwZSwgb3JpZ2luYWxFdmVudCwgZmFsbGJhY2tUYXJnZXQsIGRhdGEpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IGV2ZW50ID0gY2xvbmUkMyhvcmlnaW5hbEV2ZW50LCBkYXRhKTtcbiAgICAgIGV2ZW50LnR5cGUgPSB0eXBlO1xuICAgICAgaWYgKGlzTnVsbGFibGUoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICBldmVudC50YXJnZXQgPSAoX2EgPSBldmVudC5zcmNFbGVtZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxsYmFja1RhcmdldDtcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkc05vcm1hbGl6aW5nKG9yaWdpbmFsRXZlbnQpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0ID0gKCkgPT4ge1xuICAgICAgICAgIGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgICAgIGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCA9IGFsd2F5cztcbiAgICAgICAgICBpZiAoaXNGdW5jdGlvbihvcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0KSkge1xuICAgICAgICAgICAgb3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uID0gKCkgPT4ge1xuICAgICAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICAgICAgZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBhbHdheXM7XG4gICAgICAgICAgaWYgKGlzRnVuY3Rpb24ob3JpZ2luYWxFdmVudC5zdG9wUHJvcGFnYXRpb24pKSB7XG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uID0gKCkgPT4ge1xuICAgICAgICAgIGV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gYWx3YXlzO1xuICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoIWhhc0lzRGVmYXVsdFByZXZlbnRlZChldmVudCkpIHtcbiAgICAgICAgICBldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBldmVudC5kZWZhdWx0UHJldmVudGVkID09PSB0cnVlID8gYWx3YXlzIDogbmV2ZXI7XG4gICAgICAgICAgZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBldmVudC5jYW5jZWxCdWJibGUgPT09IHRydWUgPyBhbHdheXMgOiBuZXZlcjtcbiAgICAgICAgICBldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IG5ldmVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfTtcblxuICAgIGNvbnN0IGV2ZW50RXhwYW5kb1ByZWZpeCA9ICdtY2UtZGF0YS0nO1xuICAgIGNvbnN0IG1vdXNlRXZlbnRSZSA9IC9eKD86bW91c2V8Y29udGV4dG1lbnUpfGNsaWNrLztcbiAgICBjb25zdCBhZGRFdmVudCA9ICh0YXJnZXQsIG5hbWUsIGNhbGxiYWNrLCBjYXB0dXJlKSA9PiB7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBjYWxsYmFjaywgY2FwdHVyZSB8fCBmYWxzZSk7XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVFdmVudCA9ICh0YXJnZXQsIG5hbWUsIGNhbGxiYWNrLCBjYXB0dXJlKSA9PiB7XG4gICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBjYWxsYmFjaywgY2FwdHVyZSB8fCBmYWxzZSk7XG4gICAgfTtcbiAgICBjb25zdCBpc01vdXNlRXZlbnQgPSBldmVudCA9PiBpc05vbk51bGxhYmxlKGV2ZW50KSAmJiBtb3VzZUV2ZW50UmUudGVzdChldmVudC50eXBlKTtcbiAgICBjb25zdCBmaXggPSAob3JpZ2luYWxFdmVudCwgZGF0YSkgPT4ge1xuICAgICAgY29uc3QgZXZlbnQgPSBub3JtYWxpemUkMyhvcmlnaW5hbEV2ZW50LnR5cGUsIG9yaWdpbmFsRXZlbnQsIGRvY3VtZW50LCBkYXRhKTtcbiAgICAgIGlmIChpc01vdXNlRXZlbnQob3JpZ2luYWxFdmVudCkgJiYgaXNVbmRlZmluZWQob3JpZ2luYWxFdmVudC5wYWdlWCkgJiYgIWlzVW5kZWZpbmVkKG9yaWdpbmFsRXZlbnQuY2xpZW50WCkpIHtcbiAgICAgICAgY29uc3QgZXZlbnREb2MgPSBldmVudC50YXJnZXQub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudDtcbiAgICAgICAgY29uc3QgZG9jID0gZXZlbnREb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICBjb25zdCBib2R5ID0gZXZlbnREb2MuYm9keTtcbiAgICAgICAgY29uc3QgbW91c2VFdmVudCA9IGV2ZW50O1xuICAgICAgICBtb3VzZUV2ZW50LnBhZ2VYID0gb3JpZ2luYWxFdmVudC5jbGllbnRYICsgKGRvYyAmJiBkb2Muc2Nyb2xsTGVmdCB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsTGVmdCB8fCAwKSAtIChkb2MgJiYgZG9jLmNsaWVudExlZnQgfHwgYm9keSAmJiBib2R5LmNsaWVudExlZnQgfHwgMCk7XG4gICAgICAgIG1vdXNlRXZlbnQucGFnZVkgPSBvcmlnaW5hbEV2ZW50LmNsaWVudFkgKyAoZG9jICYmIGRvYy5zY3JvbGxUb3AgfHwgYm9keSAmJiBib2R5LnNjcm9sbFRvcCB8fCAwKSAtIChkb2MgJiYgZG9jLmNsaWVudFRvcCB8fCBib2R5ICYmIGJvZHkuY2xpZW50VG9wIHx8IDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH07XG4gICAgY29uc3QgYmluZE9uUmVhZHkgPSAod2luLCBjYWxsYmFjaywgZXZlbnRVdGlscykgPT4ge1xuICAgICAgY29uc3QgZG9jID0gd2luLmRvY3VtZW50LCBldmVudCA9IHsgdHlwZTogJ3JlYWR5JyB9O1xuICAgICAgaWYgKGV2ZW50VXRpbHMuZG9tTG9hZGVkKSB7XG4gICAgICAgIGNhbGxiYWNrKGV2ZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNEb2NSZWFkeSA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGRvYy5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnIHx8IGRvYy5yZWFkeVN0YXRlID09PSAnaW50ZXJhY3RpdmUnICYmIGRvYy5ib2R5O1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlYWR5SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgcmVtb3ZlRXZlbnQod2luLCAnRE9NQ29udGVudExvYWRlZCcsIHJlYWR5SGFuZGxlcik7XG4gICAgICAgIHJlbW92ZUV2ZW50KHdpbiwgJ2xvYWQnLCByZWFkeUhhbmRsZXIpO1xuICAgICAgICBpZiAoIWV2ZW50VXRpbHMuZG9tTG9hZGVkKSB7XG4gICAgICAgICAgZXZlbnRVdGlscy5kb21Mb2FkZWQgPSB0cnVlO1xuICAgICAgICAgIGNhbGxiYWNrKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICB3aW4gPSBudWxsO1xuICAgICAgfTtcbiAgICAgIGlmIChpc0RvY1JlYWR5KCkpIHtcbiAgICAgICAgcmVhZHlIYW5kbGVyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGRFdmVudCh3aW4sICdET01Db250ZW50TG9hZGVkJywgcmVhZHlIYW5kbGVyKTtcbiAgICAgIH1cbiAgICAgIGlmICghZXZlbnRVdGlscy5kb21Mb2FkZWQpIHtcbiAgICAgICAgYWRkRXZlbnQod2luLCAnbG9hZCcsIHJlYWR5SGFuZGxlcik7XG4gICAgICB9XG4gICAgfTtcbiAgICBjbGFzcyBFdmVudFV0aWxzIHtcbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmRvbUxvYWRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IHt9O1xuICAgICAgICB0aGlzLmNvdW50ID0gMTtcbiAgICAgICAgdGhpcy5leHBhbmRvID0gZXZlbnRFeHBhbmRvUHJlZml4ICsgKCtuZXcgRGF0ZSgpKS50b1N0cmluZygzMik7XG4gICAgICAgIHRoaXMuaGFzRm9jdXNJbiA9ICdvbmZvY3VzaW4nIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgdGhpcy5jb3VudCA9IDE7XG4gICAgICB9XG4gICAgICBiaW5kKHRhcmdldCwgbmFtZXMsIGNhbGxiYWNrLCBzY29wZSkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgbGV0IGNhbGxiYWNrTGlzdDtcbiAgICAgICAgY29uc3Qgd2luID0gd2luZG93O1xuICAgICAgICBjb25zdCBkZWZhdWx0TmF0aXZlSGFuZGxlciA9IGV2dCA9PiB7XG4gICAgICAgICAgc2VsZi5leGVjdXRlSGFuZGxlcnMoZml4KGV2dCB8fCB3aW4uZXZlbnQpLCBpZCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICghdGFyZ2V0IHx8IGlzVGV4dCRhKHRhcmdldCkgfHwgaXNDb21tZW50KHRhcmdldCkpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2s7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlkO1xuICAgICAgICBpZiAoIXRhcmdldFtzZWxmLmV4cGFuZG9dKSB7XG4gICAgICAgICAgaWQgPSBzZWxmLmNvdW50Kys7XG4gICAgICAgICAgdGFyZ2V0W3NlbGYuZXhwYW5kb10gPSBpZDtcbiAgICAgICAgICBzZWxmLmV2ZW50c1tpZF0gPSB7fTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZCA9IHRhcmdldFtzZWxmLmV4cGFuZG9dO1xuICAgICAgICB9XG4gICAgICAgIHNjb3BlID0gc2NvcGUgfHwgdGFyZ2V0O1xuICAgICAgICBjb25zdCBuYW1lc0xpc3QgPSBuYW1lcy5zcGxpdCgnICcpO1xuICAgICAgICBsZXQgaSA9IG5hbWVzTGlzdC5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICBsZXQgbmFtZSA9IG5hbWVzTGlzdFtpXTtcbiAgICAgICAgICBsZXQgbmF0aXZlSGFuZGxlciA9IGRlZmF1bHROYXRpdmVIYW5kbGVyO1xuICAgICAgICAgIGxldCBjYXB0dXJlID0gZmFsc2U7XG4gICAgICAgICAgbGV0IGZha2VOYW1lID0gZmFsc2U7XG4gICAgICAgICAgaWYgKG5hbWUgPT09ICdET01Db250ZW50TG9hZGVkJykge1xuICAgICAgICAgICAgbmFtZSA9ICdyZWFkeSc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzZWxmLmRvbUxvYWRlZCAmJiBuYW1lID09PSAncmVhZHknICYmIHRhcmdldC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKHNjb3BlLCBmaXgoeyB0eXBlOiBuYW1lIH0pKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXNlbGYuaGFzRm9jdXNJbiAmJiAobmFtZSA9PT0gJ2ZvY3VzaW4nIHx8IG5hbWUgPT09ICdmb2N1c291dCcpKSB7XG4gICAgICAgICAgICBjYXB0dXJlID0gdHJ1ZTtcbiAgICAgICAgICAgIGZha2VOYW1lID0gbmFtZSA9PT0gJ2ZvY3VzaW4nID8gJ2ZvY3VzJyA6ICdibHVyJztcbiAgICAgICAgICAgIG5hdGl2ZUhhbmRsZXIgPSBldnQgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBldmVudCA9IGZpeChldnQgfHwgd2luLmV2ZW50KTtcbiAgICAgICAgICAgICAgZXZlbnQudHlwZSA9IGV2ZW50LnR5cGUgPT09ICdmb2N1cycgPyAnZm9jdXNpbicgOiAnZm9jdXNvdXQnO1xuICAgICAgICAgICAgICBzZWxmLmV4ZWN1dGVIYW5kbGVycyhldmVudCwgaWQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FsbGJhY2tMaXN0ID0gc2VsZi5ldmVudHNbaWRdW25hbWVdO1xuICAgICAgICAgIGlmICghY2FsbGJhY2tMaXN0KSB7XG4gICAgICAgICAgICBzZWxmLmV2ZW50c1tpZF1bbmFtZV0gPSBjYWxsYmFja0xpc3QgPSBbe1xuICAgICAgICAgICAgICAgIGZ1bmM6IGNhbGxiYWNrLFxuICAgICAgICAgICAgICAgIHNjb3BlXG4gICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgY2FsbGJhY2tMaXN0LmZha2VOYW1lID0gZmFrZU5hbWU7XG4gICAgICAgICAgICBjYWxsYmFja0xpc3QuY2FwdHVyZSA9IGNhcHR1cmU7XG4gICAgICAgICAgICBjYWxsYmFja0xpc3QubmF0aXZlSGFuZGxlciA9IG5hdGl2ZUhhbmRsZXI7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ3JlYWR5Jykge1xuICAgICAgICAgICAgICBiaW5kT25SZWFkeSh0YXJnZXQsIG5hdGl2ZUhhbmRsZXIsIHNlbGYpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYWRkRXZlbnQodGFyZ2V0LCBmYWtlTmFtZSB8fCBuYW1lLCBuYXRpdmVIYW5kbGVyLCBjYXB0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdyZWFkeScgJiYgc2VsZi5kb21Mb2FkZWQpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soZml4KHsgdHlwZTogbmFtZSB9KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjYWxsYmFja0xpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgZnVuYzogY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgc2NvcGVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRhcmdldCA9IGNhbGxiYWNrTGlzdCA9IG51bGw7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaztcbiAgICAgIH1cbiAgICAgIHVuYmluZCh0YXJnZXQsIG5hbWVzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIXRhcmdldCB8fCBpc1RleHQkYSh0YXJnZXQpIHx8IGlzQ29tbWVudCh0YXJnZXQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWQgPSB0YXJnZXRbdGhpcy5leHBhbmRvXTtcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgbGV0IGV2ZW50TWFwID0gdGhpcy5ldmVudHNbaWRdO1xuICAgICAgICAgIGlmIChuYW1lcykge1xuICAgICAgICAgICAgY29uc3QgbmFtZXNMaXN0ID0gbmFtZXMuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIGxldCBpID0gbmFtZXNMaXN0Lmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IG5hbWVzTGlzdFtpXTtcbiAgICAgICAgICAgICAgY29uc3QgY2FsbGJhY2tMaXN0ID0gZXZlbnRNYXBbbmFtZV07XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFja0xpc3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgIGxldCBjaSA9IGNhbGxiYWNrTGlzdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoY2ktLSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2tMaXN0W2NpXS5mdW5jID09PSBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hdGl2ZUhhbmRsZXIgPSBjYWxsYmFja0xpc3QubmF0aXZlSGFuZGxlcjtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmYWtlTmFtZSA9IGNhbGxiYWNrTGlzdC5mYWtlTmFtZSwgY2FwdHVyZSA9IGNhbGxiYWNrTGlzdC5jYXB0dXJlO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0NhbGxiYWNrTGlzdCA9IGNhbGxiYWNrTGlzdC5zbGljZSgwLCBjaSkuY29uY2F0KGNhbGxiYWNrTGlzdC5zbGljZShjaSArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICBuZXdDYWxsYmFja0xpc3QubmF0aXZlSGFuZGxlciA9IG5hdGl2ZUhhbmRsZXI7XG4gICAgICAgICAgICAgICAgICAgICAgbmV3Q2FsbGJhY2tMaXN0LmZha2VOYW1lID0gZmFrZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgbmV3Q2FsbGJhY2tMaXN0LmNhcHR1cmUgPSBjYXB0dXJlO1xuICAgICAgICAgICAgICAgICAgICAgIGV2ZW50TWFwW25hbWVdID0gbmV3Q2FsbGJhY2tMaXN0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghY2FsbGJhY2sgfHwgY2FsbGJhY2tMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIGV2ZW50TWFwW25hbWVdO1xuICAgICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnQodGFyZ2V0LCBjYWxsYmFja0xpc3QuZmFrZU5hbWUgfHwgbmFtZSwgY2FsbGJhY2tMaXN0Lm5hdGl2ZUhhbmRsZXIsIGNhbGxiYWNrTGlzdC5jYXB0dXJlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWFjaCRkKGV2ZW50TWFwLCAoY2FsbGJhY2tMaXN0LCBuYW1lKSA9PiB7XG4gICAgICAgICAgICAgIHJlbW92ZUV2ZW50KHRhcmdldCwgY2FsbGJhY2tMaXN0LmZha2VOYW1lIHx8IG5hbWUsIGNhbGxiYWNrTGlzdC5uYXRpdmVIYW5kbGVyLCBjYWxsYmFja0xpc3QuY2FwdHVyZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV2ZW50TWFwID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBldmVudE1hcCkge1xuICAgICAgICAgICAgaWYgKGhhcyQyKGV2ZW50TWFwLCBuYW1lKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZGVsZXRlIHRoaXMuZXZlbnRzW2lkXTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVsZXRlIHRhcmdldFt0aGlzLmV4cGFuZG9dO1xuICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICB0YXJnZXRbdGhpcy5leHBhbmRvXSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgZmlyZSh0YXJnZXQsIG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2godGFyZ2V0LCBuYW1lLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIGRpc3BhdGNoKHRhcmdldCwgbmFtZSwgYXJncykge1xuICAgICAgICBpZiAoIXRhcmdldCB8fCBpc1RleHQkYSh0YXJnZXQpIHx8IGlzQ29tbWVudCh0YXJnZXQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXZlbnQgPSBmaXgoe1xuICAgICAgICAgIHR5cGU6IG5hbWUsXG4gICAgICAgICAgdGFyZ2V0XG4gICAgICAgIH0sIGFyZ3MpO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgY29uc3QgaWQgPSB0YXJnZXRbdGhpcy5leHBhbmRvXTtcbiAgICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIHRoaXMuZXhlY3V0ZUhhbmRsZXJzKGV2ZW50LCBpZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlIHx8IHRhcmdldC5vd25lckRvY3VtZW50IHx8IHRhcmdldC5kZWZhdWx0VmlldyB8fCB0YXJnZXQucGFyZW50V2luZG93O1xuICAgICAgICB9IHdoaWxlICh0YXJnZXQgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGNsZWFuKHRhcmdldCkge1xuICAgICAgICBpZiAoIXRhcmdldCB8fCBpc1RleHQkYSh0YXJnZXQpIHx8IGlzQ29tbWVudCh0YXJnZXQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldFt0aGlzLmV4cGFuZG9dKSB7XG4gICAgICAgICAgdGhpcy51bmJpbmQodGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRhcmdldC5nZXRFbGVtZW50c0J5VGFnTmFtZSkge1xuICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5kb2N1bWVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFyZ2V0ICYmIHRhcmdldC5nZXRFbGVtZW50c0J5VGFnTmFtZSkge1xuICAgICAgICAgIHRoaXMudW5iaW5kKHRhcmdldCk7XG4gICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0YXJnZXQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKTtcbiAgICAgICAgICBsZXQgaSA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmICh0YXJnZXRbdGhpcy5leHBhbmRvXSkge1xuICAgICAgICAgICAgICB0aGlzLnVuYmluZCh0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZXZlbnRzID0ge307XG4gICAgICB9XG4gICAgICBjYW5jZWwoZSkge1xuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGV4ZWN1dGVIYW5kbGVycyhldnQsIGlkKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuZXZlbnRzW2lkXTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tMaXN0ID0gY29udGFpbmVyICYmIGNvbnRhaW5lcltldnQudHlwZV07XG4gICAgICAgIGlmIChjYWxsYmFja0xpc3QpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGNhbGxiYWNrTGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gY2FsbGJhY2tMaXN0W2ldO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrICYmIGNhbGxiYWNrLmZ1bmMuY2FsbChjYWxsYmFjay5zY29wZSwgZXZ0KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXZ0LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBFdmVudFV0aWxzLkV2ZW50ID0gbmV3IEV2ZW50VXRpbHMoKTtcblxuICAgIGNvbnN0IGVhY2gkYSA9IFRvb2xzLmVhY2g7XG4gICAgY29uc3QgZ3JlcCA9IFRvb2xzLmdyZXA7XG4gICAgY29uc3QgaW50ZXJuYWxTdHlsZU5hbWUgPSAnZGF0YS1tY2Utc3R5bGUnO1xuICAgIGNvbnN0IG51bWVyaWNhbENzc01hcCA9IFRvb2xzLm1ha2VNYXAoJ2ZpbGwtb3BhY2l0eSBmb250LXdlaWdodCBsaW5lLWhlaWdodCBvcGFjaXR5IG9ycGhhbnMgd2lkb3dzIHotaW5kZXggem9vbScsICcgJyk7XG4gICAgY29uc3QgbGVnYWN5U2V0QXR0cmlidXRlID0gKGVsbSwgbmFtZSwgdmFsdWUpID0+IHtcbiAgICAgIGlmIChpc051bGxhYmxlKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgcmVtb3ZlJGIoZWxtLCBuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldCQzKGVsbSwgbmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgY2FtZWxDYXNlVG9IeXBoZW5zID0gbmFtZSA9PiBuYW1lLnJlcGxhY2UoL1tBLVpdL2csIHYgPT4gJy0nICsgdi50b0xvd2VyQ2FzZSgpKTtcbiAgICBjb25zdCBmaW5kTm9kZUluZGV4ID0gKG5vZGUsIG5vcm1hbGl6ZWQpID0+IHtcbiAgICAgIGxldCBpZHggPSAwO1xuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgZm9yIChsZXQgbGFzdE5vZGVUeXBlID0gbm9kZS5ub2RlVHlwZSwgdGVtcE5vZGUgPSBub2RlLnByZXZpb3VzU2libGluZzsgdGVtcE5vZGU7IHRlbXBOb2RlID0gdGVtcE5vZGUucHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZVR5cGUgPSB0ZW1wTm9kZS5ub2RlVHlwZTtcbiAgICAgICAgICBpZiAobm9ybWFsaXplZCAmJiBpc1RleHQkYSh0ZW1wTm9kZSkpIHtcbiAgICAgICAgICAgIGlmIChub2RlVHlwZSA9PT0gbGFzdE5vZGVUeXBlIHx8ICF0ZW1wTm9kZS5kYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWR4Kys7XG4gICAgICAgICAgbGFzdE5vZGVUeXBlID0gbm9kZVR5cGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpZHg7XG4gICAgfTtcbiAgICBjb25zdCB1cGRhdGVJbnRlcm5hbFN0eWxlQXR0ciA9IChzdHlsZXMsIGVsbSkgPT4ge1xuICAgICAgY29uc3QgcmF3VmFsdWUgPSBnZXQkOShlbG0sICdzdHlsZScpO1xuICAgICAgY29uc3QgdmFsdWUgPSBzdHlsZXMuc2VyaWFsaXplKHN0eWxlcy5wYXJzZShyYXdWYWx1ZSksIG5hbWUoZWxtKSk7XG4gICAgICBsZWdhY3lTZXRBdHRyaWJ1dGUoZWxtLCBpbnRlcm5hbFN0eWxlTmFtZSwgdmFsdWUpO1xuICAgIH07XG4gICAgY29uc3QgY29udmVydFN0eWxlVG9TdHJpbmcgPSAoY3NzVmFsdWUsIGNzc05hbWUpID0+IHtcbiAgICAgIGlmIChpc051bWJlcihjc3NWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGhhcyQyKG51bWVyaWNhbENzc01hcCwgY3NzTmFtZSkgPyBjc3NWYWx1ZSArICcnIDogY3NzVmFsdWUgKyAncHgnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNzc1ZhbHVlO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgYXBwbHlTdHlsZSQxID0gKCRlbG0sIGNzc05hbWUsIGNzc1ZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBub3JtYWxpemVkTmFtZSA9IGNhbWVsQ2FzZVRvSHlwaGVucyhjc3NOYW1lKTtcbiAgICAgIGlmIChpc051bGxhYmxlKGNzc1ZhbHVlKSB8fCBjc3NWYWx1ZSA9PT0gJycpIHtcbiAgICAgICAgcmVtb3ZlJDcoJGVsbSwgbm9ybWFsaXplZE5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0JDIoJGVsbSwgbm9ybWFsaXplZE5hbWUsIGNvbnZlcnRTdHlsZVRvU3RyaW5nKGNzc1ZhbHVlLCBub3JtYWxpemVkTmFtZSkpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc2V0dXBBdHRySG9va3MgPSAoc3R5bGVzLCBzZXR0aW5ncywgZ2V0Q29udGV4dCkgPT4ge1xuICAgICAgY29uc3Qga2VlcFZhbHVlcyA9IHNldHRpbmdzLmtlZXBfdmFsdWVzO1xuICAgICAgY29uc3Qga2VlcFVybEhvb2sgPSB7XG4gICAgICAgIHNldDogKGVsbSwgdmFsdWUsIG5hbWUpID0+IHtcbiAgICAgICAgICBjb25zdCBzdWdhckVsbSA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVsbSk7XG4gICAgICAgICAgaWYgKGlzRnVuY3Rpb24oc2V0dGluZ3MudXJsX2NvbnZlcnRlcikgJiYgaXNOb25OdWxsYWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gc2V0dGluZ3MudXJsX2NvbnZlcnRlci5jYWxsKHNldHRpbmdzLnVybF9jb252ZXJ0ZXJfc2NvcGUgfHwgZ2V0Q29udGV4dCgpLCBTdHJpbmcodmFsdWUpLCBuYW1lLCBlbG0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBpbnRlcm5hbE5hbWUgPSAnZGF0YS1tY2UtJyArIG5hbWU7XG4gICAgICAgICAgbGVnYWN5U2V0QXR0cmlidXRlKHN1Z2FyRWxtLCBpbnRlcm5hbE5hbWUsIHZhbHVlKTtcbiAgICAgICAgICBsZWdhY3lTZXRBdHRyaWJ1dGUoc3VnYXJFbG0sIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0OiAoZWxtLCBuYW1lKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3VnYXJFbG0gPSBTdWdhckVsZW1lbnQuZnJvbURvbShlbG0pO1xuICAgICAgICAgIHJldHVybiBnZXQkOShzdWdhckVsbSwgJ2RhdGEtbWNlLScgKyBuYW1lKSB8fCBnZXQkOShzdWdhckVsbSwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBhdHRySG9va3MgPSB7XG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgc2V0OiAoZWxtLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3VnYXJFbG0gPSBTdWdhckVsZW1lbnQuZnJvbURvbShlbG0pO1xuICAgICAgICAgICAgaWYgKGtlZXBWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgbGVnYWN5U2V0QXR0cmlidXRlKHN1Z2FyRWxtLCBpbnRlcm5hbFN0eWxlTmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVtb3ZlJGIoc3VnYXJFbG0sICdzdHlsZScpO1xuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgICBzZXRBbGwoc3VnYXJFbG0sIHN0eWxlcy5wYXJzZSh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0OiBlbG0gPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3VnYXJFbG0gPSBTdWdhckVsZW1lbnQuZnJvbURvbShlbG0pO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBnZXQkOShzdWdhckVsbSwgaW50ZXJuYWxTdHlsZU5hbWUpIHx8IGdldCQ5KHN1Z2FyRWxtLCAnc3R5bGUnKTtcbiAgICAgICAgICAgIHJldHVybiBzdHlsZXMuc2VyaWFsaXplKHN0eWxlcy5wYXJzZSh2YWx1ZSksIG5hbWUoc3VnYXJFbG0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoa2VlcFZhbHVlcykge1xuICAgICAgICBhdHRySG9va3MuaHJlZiA9IGF0dHJIb29rcy5zcmMgPSBrZWVwVXJsSG9vaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdHRySG9va3M7XG4gICAgfTtcbiAgICBjb25zdCBET01VdGlscyA9IChkb2MsIHNldHRpbmdzID0ge30pID0+IHtcbiAgICAgIGNvbnN0IGFkZGVkU3R5bGVzID0ge307XG4gICAgICBjb25zdCB3aW4gPSB3aW5kb3c7XG4gICAgICBjb25zdCBmaWxlcyA9IHt9O1xuICAgICAgbGV0IGNvdW50ZXIgPSAwO1xuICAgICAgY29uc3Qgc3RkTW9kZSA9IHRydWU7XG4gICAgICBjb25zdCBib3hNb2RlbCA9IHRydWU7XG4gICAgICBjb25zdCBzdHlsZVNoZWV0TG9hZGVyID0gaW5zdGFuY2UuZm9yRWxlbWVudChTdWdhckVsZW1lbnQuZnJvbURvbShkb2MpLCB7XG4gICAgICAgIGNvbnRlbnRDc3NDb3JzOiBzZXR0aW5ncy5jb250ZW50Q3NzQ29ycyxcbiAgICAgICAgcmVmZXJyZXJQb2xpY3k6IHNldHRpbmdzLnJlZmVycmVyUG9saWN5XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGJvdW5kRXZlbnRzID0gW107XG4gICAgICBjb25zdCBzY2hlbWEgPSBzZXR0aW5ncy5zY2hlbWEgPyBzZXR0aW5ncy5zY2hlbWEgOiBTY2hlbWEoe30pO1xuICAgICAgY29uc3Qgc3R5bGVzID0gU3R5bGVzKHtcbiAgICAgICAgdXJsX2NvbnZlcnRlcjogc2V0dGluZ3MudXJsX2NvbnZlcnRlcixcbiAgICAgICAgdXJsX2NvbnZlcnRlcl9zY29wZTogc2V0dGluZ3MudXJsX2NvbnZlcnRlcl9zY29wZVxuICAgICAgfSwgc2V0dGluZ3Muc2NoZW1hKTtcbiAgICAgIGNvbnN0IGV2ZW50cyA9IHNldHRpbmdzLm93bkV2ZW50cyA/IG5ldyBFdmVudFV0aWxzKCkgOiBFdmVudFV0aWxzLkV2ZW50O1xuICAgICAgY29uc3QgYmxvY2tFbGVtZW50c01hcCA9IHNjaGVtYS5nZXRCbG9ja0VsZW1lbnRzKCk7XG4gICAgICBjb25zdCBpc0Jsb2NrID0gbm9kZSA9PiB7XG4gICAgICAgIGlmIChpc1N0cmluZyhub2RlKSkge1xuICAgICAgICAgIHJldHVybiBoYXMkMihibG9ja0VsZW1lbnRzTWFwLCBub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gaXNFbGVtZW50JDYobm9kZSkgJiYgKGhhcyQyKGJsb2NrRWxlbWVudHNNYXAsIG5vZGUubm9kZU5hbWUpIHx8IGlzVHJhbnNwYXJlbnRCbG9jayhzY2hlbWEsIG5vZGUpKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldCA9IGVsbSA9PiBlbG0gJiYgZG9jICYmIGlzU3RyaW5nKGVsbSkgPyBkb2MuZ2V0RWxlbWVudEJ5SWQoZWxtKSA6IGVsbTtcbiAgICAgIGNvbnN0IF9nZXQgPSBlbG0gPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGdldChlbG0pO1xuICAgICAgICByZXR1cm4gaXNOb25OdWxsYWJsZSh2YWx1ZSkgPyBTdWdhckVsZW1lbnQuZnJvbURvbSh2YWx1ZSkgOiBudWxsO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldEF0dHJpYiA9IChlbG0sIG5hbWUsIGRlZmF1bHRWYWwgPSAnJykgPT4ge1xuICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgIGNvbnN0ICRlbG0gPSBfZ2V0KGVsbSk7XG4gICAgICAgIGlmIChpc05vbk51bGxhYmxlKCRlbG0pICYmIGlzRWxlbWVudCQ3KCRlbG0pKSB7XG4gICAgICAgICAgY29uc3QgaG9vayA9IGF0dHJIb29rc1tuYW1lXTtcbiAgICAgICAgICBpZiAoaG9vayAmJiBob29rLmdldCkge1xuICAgICAgICAgICAgdmFsdWUgPSBob29rLmdldCgkZWxtLmRvbSwgbmFtZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gZ2V0JDkoJGVsbSwgbmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc05vbk51bGxhYmxlKHZhbHVlKSA/IHZhbHVlIDogZGVmYXVsdFZhbDtcbiAgICAgIH07XG4gICAgICBjb25zdCBnZXRBdHRyaWJzID0gZWxtID0+IHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGdldChlbG0pO1xuICAgICAgICByZXR1cm4gaXNOdWxsYWJsZShub2RlKSA/IFtdIDogbm9kZS5hdHRyaWJ1dGVzO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHNldEF0dHJpYiA9IChlbG0sIG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgIHJ1bihlbG0sIGUgPT4ge1xuICAgICAgICAgIGlmIChpc0VsZW1lbnQkNihlKSkge1xuICAgICAgICAgICAgY29uc3QgJGVsbSA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGUpO1xuICAgICAgICAgICAgY29uc3QgdmFsID0gdmFsdWUgPT09ICcnID8gbnVsbCA6IHZhbHVlO1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxWYWx1ZSA9IGdldCQ5KCRlbG0sIG5hbWUpO1xuICAgICAgICAgICAgY29uc3QgaG9vayA9IGF0dHJIb29rc1tuYW1lXTtcbiAgICAgICAgICAgIGlmIChob29rICYmIGhvb2suc2V0KSB7XG4gICAgICAgICAgICAgIGhvb2suc2V0KCRlbG0uZG9tLCB2YWwsIG5hbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbGVnYWN5U2V0QXR0cmlidXRlKCRlbG0sIG5hbWUsIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3JpZ2luYWxWYWx1ZSAhPT0gdmFsICYmIHNldHRpbmdzLm9uU2V0QXR0cmliKSB7XG4gICAgICAgICAgICAgIHNldHRpbmdzLm9uU2V0QXR0cmliKHtcbiAgICAgICAgICAgICAgICBhdHRyRWxtOiAkZWxtLmRvbSxcbiAgICAgICAgICAgICAgICBhdHRyTmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICBhdHRyVmFsdWU6IHZhbFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGNsb25lID0gKG5vZGUsIGRlZXApID0+IHtcbiAgICAgICAgcmV0dXJuIG5vZGUuY2xvbmVOb2RlKGRlZXApO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldFJvb3QgPSAoKSA9PiBzZXR0aW5ncy5yb290X2VsZW1lbnQgfHwgZG9jLmJvZHk7XG4gICAgICBjb25zdCBnZXRWaWV3UG9ydCA9IGFyZ1dpbiA9PiB7XG4gICAgICAgIGNvbnN0IHZwID0gZ2V0Qm91bmRzKGFyZ1dpbik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogdnAueCxcbiAgICAgICAgICB5OiB2cC55LFxuICAgICAgICAgIHc6IHZwLndpZHRoLFxuICAgICAgICAgIGg6IHZwLmhlaWdodFxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldFBvcyQxID0gKGVsbSwgcm9vdEVsbSkgPT4gZ2V0UG9zKGRvYy5ib2R5LCBnZXQoZWxtKSwgcm9vdEVsbSk7XG4gICAgICBjb25zdCBzZXRTdHlsZSA9IChlbG0sIG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgIHJ1bihlbG0sIGUgPT4ge1xuICAgICAgICAgIGNvbnN0ICRlbG0gPSBTdWdhckVsZW1lbnQuZnJvbURvbShlKTtcbiAgICAgICAgICBhcHBseVN0eWxlJDEoJGVsbSwgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgIGlmIChzZXR0aW5ncy51cGRhdGVfc3R5bGVzKSB7XG4gICAgICAgICAgICB1cGRhdGVJbnRlcm5hbFN0eWxlQXR0cihzdHlsZXMsICRlbG0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2V0U3R5bGVzID0gKGVsbSwgc3R5bGVzQXJnKSA9PiB7XG4gICAgICAgIHJ1bihlbG0sIGUgPT4ge1xuICAgICAgICAgIGNvbnN0ICRlbG0gPSBTdWdhckVsZW1lbnQuZnJvbURvbShlKTtcbiAgICAgICAgICBlYWNoJGQoc3R5bGVzQXJnLCAodiwgbikgPT4ge1xuICAgICAgICAgICAgYXBwbHlTdHlsZSQxKCRlbG0sIG4sIHYpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChzZXR0aW5ncy51cGRhdGVfc3R5bGVzKSB7XG4gICAgICAgICAgICB1cGRhdGVJbnRlcm5hbFN0eWxlQXR0cihzdHlsZXMsICRlbG0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0U3R5bGUgPSAoZWxtLCBuYW1lLCBjb21wdXRlZCkgPT4ge1xuICAgICAgICBjb25zdCAkZWxtID0gZ2V0KGVsbSk7XG4gICAgICAgIGlmIChpc051bGxhYmxlKCRlbG0pIHx8ICFpc0VsZW1lbnQkNigkZWxtKSkge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXB1dGVkKSB7XG4gICAgICAgICAgcmV0dXJuIGdldCQ3KFN1Z2FyRWxlbWVudC5mcm9tRG9tKCRlbG0pLCBjYW1lbENhc2VUb0h5cGhlbnMobmFtZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLy0oXFxEKS9nLCAoYSwgYikgPT4gYi50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgICBpZiAobmFtZSA9PT0gJ2Zsb2F0Jykge1xuICAgICAgICAgICAgbmFtZSA9ICdjc3NGbG9hdCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAkZWxtLnN0eWxlID8gJGVsbS5zdHlsZVtuYW1lXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldFNpemUgPSBlbG0gPT4ge1xuICAgICAgICBjb25zdCAkZWxtID0gZ2V0KGVsbSk7XG4gICAgICAgIGlmICghJGVsbSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3OiAwLFxuICAgICAgICAgICAgaDogMFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHcgPSBnZXRTdHlsZSgkZWxtLCAnd2lkdGgnKTtcbiAgICAgICAgbGV0IGggPSBnZXRTdHlsZSgkZWxtLCAnaGVpZ2h0Jyk7XG4gICAgICAgIGlmICghdyB8fCB3LmluZGV4T2YoJ3B4JykgPT09IC0xKSB7XG4gICAgICAgICAgdyA9ICcwJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWggfHwgaC5pbmRleE9mKCdweCcpID09PSAtMSkge1xuICAgICAgICAgIGggPSAnMCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB3OiBwYXJzZUludCh3LCAxMCkgfHwgJGVsbS5vZmZzZXRXaWR0aCB8fCAkZWxtLmNsaWVudFdpZHRoLFxuICAgICAgICAgIGg6IHBhcnNlSW50KGgsIDEwKSB8fCAkZWxtLm9mZnNldEhlaWdodCB8fCAkZWxtLmNsaWVudEhlaWdodFxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldFJlY3QgPSBlbG0gPT4ge1xuICAgICAgICBjb25zdCAkZWxtID0gZ2V0KGVsbSk7XG4gICAgICAgIGNvbnN0IHBvcyA9IGdldFBvcyQxKCRlbG0pO1xuICAgICAgICBjb25zdCBzaXplID0gZ2V0U2l6ZSgkZWxtKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBwb3MueCxcbiAgICAgICAgICB5OiBwb3MueSxcbiAgICAgICAgICB3OiBzaXplLncsXG4gICAgICAgICAgaDogc2l6ZS5oXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgY29uc3QgaXMgPSAoZWxtLCBzZWxlY3RvcikgPT4ge1xuICAgICAgICBpZiAoIWVsbSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbG1zID0gaXNBcnJheSQxKGVsbSkgPyBlbG0gOiBbZWxtXTtcbiAgICAgICAgcmV0dXJuIGV4aXN0cyhlbG1zLCBlID0+IHtcbiAgICAgICAgICByZXR1cm4gaXMkMShTdWdhckVsZW1lbnQuZnJvbURvbShlKSwgc2VsZWN0b3IpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBnZXRQYXJlbnRzID0gKGVsbSwgc2VsZWN0b3IsIHJvb3QsIGNvbGxlY3QpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBub2RlID0gZ2V0KGVsbSk7XG4gICAgICAgIGNvbGxlY3QgPSBjb2xsZWN0ID09PSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkUm9vdCA9IHJvb3QgfHwgKGdldFJvb3QoKS5ub2RlTmFtZSAhPT0gJ0JPRFknID8gZ2V0Um9vdCgpLnBhcmVudE5vZGUgOiBudWxsKTtcbiAgICAgICAgaWYgKGlzU3RyaW5nKHNlbGVjdG9yKSkge1xuICAgICAgICAgIGlmIChzZWxlY3RvciA9PT0gJyonKSB7XG4gICAgICAgICAgICBzZWxlY3RvciA9IGlzRWxlbWVudCQ2O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RvclZhbCA9IHNlbGVjdG9yO1xuICAgICAgICAgICAgc2VsZWN0b3IgPSBub2RlID0+IGlzKG5vZGUsIHNlbGVjdG9yVmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICBpZiAobm9kZSA9PT0gcmVzb2x2ZWRSb290IHx8IGlzTnVsbGFibGUobm9kZS5ub2RlVHlwZSkgfHwgaXNEb2N1bWVudCQxKG5vZGUpIHx8IGlzRG9jdW1lbnRGcmFnbWVudChub2RlKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghc2VsZWN0b3IgfHwgc2VsZWN0b3Iobm9kZSkpIHtcbiAgICAgICAgICAgIGlmIChjb2xsZWN0KSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtub2RlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sbGVjdCA/IHJlc3VsdCA6IG51bGw7XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0UGFyZW50ID0gKG5vZGUsIHNlbGVjdG9yLCByb290KSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcmVudHMgPSBnZXRQYXJlbnRzKG5vZGUsIHNlbGVjdG9yLCByb290LCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBwYXJlbnRzICYmIHBhcmVudHMubGVuZ3RoID4gMCA/IHBhcmVudHNbMF0gOiBudWxsO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IF9maW5kU2liID0gKG5vZGUsIHNlbGVjdG9yLCBuYW1lKSA9PiB7XG4gICAgICAgIGxldCBmdW5jID0gc2VsZWN0b3I7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgaWYgKGlzU3RyaW5nKHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgZnVuYyA9IG5vZGUgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gaXMobm9kZSwgc2VsZWN0b3IpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChsZXQgdGVtcE5vZGUgPSBub2RlW25hbWVdOyB0ZW1wTm9kZTsgdGVtcE5vZGUgPSB0ZW1wTm9kZVtuYW1lXSkge1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oZnVuYykgJiYgZnVuYyh0ZW1wTm9kZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRlbXBOb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBjb25zdCBnZXROZXh0ID0gKG5vZGUsIHNlbGVjdG9yKSA9PiBfZmluZFNpYihub2RlLCBzZWxlY3RvciwgJ25leHRTaWJsaW5nJyk7XG4gICAgICBjb25zdCBnZXRQcmV2ID0gKG5vZGUsIHNlbGVjdG9yKSA9PiBfZmluZFNpYihub2RlLCBzZWxlY3RvciwgJ3ByZXZpb3VzU2libGluZycpO1xuICAgICAgY29uc3QgaXNQYXJlbnROb2RlID0gbm9kZSA9PiBpc0Z1bmN0aW9uKG5vZGUucXVlcnlTZWxlY3RvckFsbCk7XG4gICAgICBjb25zdCBzZWxlY3QgPSAoc2VsZWN0b3IsIHNjb3BlKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGVsbSA9IChfYiA9IChfYSA9IGdldChzY29wZSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHNldHRpbmdzLnJvb3RfZWxlbWVudCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZG9jO1xuICAgICAgICByZXR1cm4gaXNQYXJlbnROb2RlKGVsbSkgPyBmcm9tKGVsbS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSkgOiBbXTtcbiAgICAgIH07XG4gICAgICBjb25zdCBydW4gPSBmdW5jdGlvbiAoZWxtLCBmdW5jLCBzY29wZSkge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gc2NvcGUgIT09IG51bGwgJiYgc2NvcGUgIT09IHZvaWQgMCA/IHNjb3BlIDogdGhpcztcbiAgICAgICAgaWYgKGlzQXJyYXkkMShlbG0pKSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgZWFjaCRhKGVsbSwgKGUsIGkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBnZXQoZSk7XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICByZXN1bHQucHVzaChmdW5jLmNhbGwoY29udGV4dCwgbm9kZSwgaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IGdldChlbG0pO1xuICAgICAgICAgIHJldHVybiAhbm9kZSA/IGZhbHNlIDogZnVuYy5jYWxsKGNvbnRleHQsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2V0QXR0cmlicyA9IChlbG0sIGF0dHJzKSA9PiB7XG4gICAgICAgIHJ1bihlbG0sICRlbG0gPT4ge1xuICAgICAgICAgIGVhY2gkZChhdHRycywgKHZhbHVlLCBuYW1lKSA9PiB7XG4gICAgICAgICAgICBzZXRBdHRyaWIoJGVsbSwgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBzZXRIVE1MID0gKGVsbSwgaHRtbCkgPT4ge1xuICAgICAgICBydW4oZWxtLCBlID0+IHtcbiAgICAgICAgICBjb25zdCAkZWxtID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZSk7XG4gICAgICAgICAgc2V0JDEoJGVsbSwgaHRtbCk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGFkZCA9IChwYXJlbnRFbG0sIG5hbWUsIGF0dHJzLCBodG1sLCBjcmVhdGUpID0+IHJ1bihwYXJlbnRFbG0sIHBhcmVudEVsbSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld0VsbSA9IGlzU3RyaW5nKG5hbWUpID8gZG9jLmNyZWF0ZUVsZW1lbnQobmFtZSkgOiBuYW1lO1xuICAgICAgICBpZiAoaXNOb25OdWxsYWJsZShhdHRycykpIHtcbiAgICAgICAgICBzZXRBdHRyaWJzKG5ld0VsbSwgYXR0cnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChodG1sKSB7XG4gICAgICAgICAgaWYgKCFpc1N0cmluZyhodG1sKSAmJiBodG1sLm5vZGVUeXBlKSB7XG4gICAgICAgICAgICBuZXdFbG0uYXBwZW5kQ2hpbGQoaHRtbCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc1N0cmluZyhodG1sKSkge1xuICAgICAgICAgICAgc2V0SFRNTChuZXdFbG0sIGh0bWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIWNyZWF0ZSA/IHBhcmVudEVsbS5hcHBlbmRDaGlsZChuZXdFbG0pIDogbmV3RWxtO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBjcmVhdGUgPSAobmFtZSwgYXR0cnMsIGh0bWwpID0+IGFkZChkb2MuY3JlYXRlRWxlbWVudChuYW1lKSwgbmFtZSwgYXR0cnMsIGh0bWwsIHRydWUpO1xuICAgICAgY29uc3QgZGVjb2RlID0gRW50aXRpZXMuZGVjb2RlO1xuICAgICAgY29uc3QgZW5jb2RlID0gRW50aXRpZXMuZW5jb2RlQWxsUmF3O1xuICAgICAgY29uc3QgY3JlYXRlSFRNTCA9IChuYW1lLCBhdHRycywgaHRtbCA9ICcnKSA9PiB7XG4gICAgICAgIGxldCBvdXRIdG1sID0gJzwnICsgbmFtZTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgICBpZiAoaGFzTm9uTnVsbGFibGVLZXkoYXR0cnMsIGtleSkpIHtcbiAgICAgICAgICAgIG91dEh0bWwgKz0gJyAnICsga2V5ICsgJz1cIicgKyBlbmNvZGUoYXR0cnNba2V5XSkgKyAnXCInO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNFbXB0eSQzKGh0bWwpICYmIGhhcyQyKHNjaGVtYS5nZXRWb2lkRWxlbWVudHMoKSwgbmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4gb3V0SHRtbCArICcgLz4nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBvdXRIdG1sICsgJz4nICsgaHRtbCArICc8LycgKyBuYW1lICsgJz4nO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgY3JlYXRlRnJhZ21lbnQgPSBodG1sID0+IHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb25zdCBmcmFnID0gZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgZnJhZy5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgICAgICBpZiAoaHRtbCkge1xuICAgICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgICB9XG4gICAgICAgIGxldCBub2RlO1xuICAgICAgICB3aGlsZSAobm9kZSA9IGNvbnRhaW5lci5maXJzdENoaWxkKSB7XG4gICAgICAgICAgZnJhZy5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBmcmFnLnJlbW92ZUNoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgIHJldHVybiBmcmFnO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlbW92ZSA9IChub2RlLCBrZWVwQ2hpbGRyZW4pID0+IHtcbiAgICAgICAgcmV0dXJuIHJ1bihub2RlLCBuID0+IHtcbiAgICAgICAgICBjb25zdCAkbm9kZSA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKG4pO1xuICAgICAgICAgIGlmIChrZWVwQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGVhY2gkZShjaGlsZHJlbiQxKCRub2RlKSwgY2hpbGQgPT4ge1xuICAgICAgICAgICAgICBpZiAoaXNUZXh0JGIoY2hpbGQpICYmIGNoaWxkLmRvbS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZW1vdmUkNihjaGlsZCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYmVmb3JlJDMoJG5vZGUsIGNoaWxkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlbW92ZSQ2KCRub2RlKTtcbiAgICAgICAgICByZXR1cm4gJG5vZGUuZG9tO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCByZW1vdmVBbGxBdHRyaWJzID0gZSA9PiBydW4oZSwgZSA9PiB7XG4gICAgICAgIGNvbnN0IGF0dHJzID0gZS5hdHRyaWJ1dGVzO1xuICAgICAgICBmb3IgKGxldCBpID0gYXR0cnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBlLnJlbW92ZUF0dHJpYnV0ZU5vZGUoYXR0cnMuaXRlbShpKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3QgcGFyc2VTdHlsZSA9IGNzc1RleHQgPT4gc3R5bGVzLnBhcnNlKGNzc1RleHQpO1xuICAgICAgY29uc3Qgc2VyaWFsaXplU3R5bGUgPSAoc3R5bGVzQXJnLCBuYW1lKSA9PiBzdHlsZXMuc2VyaWFsaXplKHN0eWxlc0FyZywgbmFtZSk7XG4gICAgICBjb25zdCBhZGRTdHlsZSA9IGNzc1RleHQgPT4ge1xuICAgICAgICBpZiAoc2VsZiAhPT0gRE9NVXRpbHMuRE9NICYmIGRvYyA9PT0gZG9jdW1lbnQpIHtcbiAgICAgICAgICBpZiAoYWRkZWRTdHlsZXNbY3NzVGV4dF0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWRkZWRTdHlsZXNbY3NzVGV4dF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdHlsZUVsbSA9IGRvYy5nZXRFbGVtZW50QnlJZCgnbWNlRGVmYXVsdFN0eWxlcycpO1xuICAgICAgICBpZiAoIXN0eWxlRWxtKSB7XG4gICAgICAgICAgc3R5bGVFbG0gPSBkb2MuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgICBzdHlsZUVsbS5pZCA9ICdtY2VEZWZhdWx0U3R5bGVzJztcbiAgICAgICAgICBzdHlsZUVsbS50eXBlID0gJ3RleHQvY3NzJztcbiAgICAgICAgICBjb25zdCBoZWFkID0gZG9jLmhlYWQ7XG4gICAgICAgICAgaWYgKGhlYWQuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgaGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbG0sIGhlYWQuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbG0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3R5bGVFbG0uc3R5bGVTaGVldCkge1xuICAgICAgICAgIHN0eWxlRWxtLnN0eWxlU2hlZXQuY3NzVGV4dCArPSBjc3NUZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0eWxlRWxtLmFwcGVuZENoaWxkKGRvYy5jcmVhdGVUZXh0Tm9kZShjc3NUZXh0KSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBsb2FkQ1NTID0gdXJscyA9PiB7XG4gICAgICAgIGlmICghdXJscykge1xuICAgICAgICAgIHVybHMgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBlYWNoJGUodXJscy5zcGxpdCgnLCcpLCB1cmwgPT4ge1xuICAgICAgICAgIGZpbGVzW3VybF0gPSB0cnVlO1xuICAgICAgICAgIHN0eWxlU2hlZXRMb2FkZXIubG9hZCh1cmwpLmNhdGNoKG5vb3ApO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCB0b2dnbGVDbGFzcyA9IChlbG0sIGNscywgc3RhdGUpID0+IHtcbiAgICAgICAgcnVuKGVsbSwgZSA9PiB7XG4gICAgICAgICAgaWYgKGlzRWxlbWVudCQ2KGUpKSB7XG4gICAgICAgICAgICBjb25zdCAkZWxtID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZSk7XG4gICAgICAgICAgICBjb25zdCBjbGFzc2VzID0gY2xzLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICBlYWNoJGUoY2xhc3NlcywgYyA9PiB7XG4gICAgICAgICAgICAgIGlmIChpc05vbk51bGxhYmxlKHN0YXRlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZuID0gc3RhdGUgPyBhZGQkMiA6IHJlbW92ZSQ4O1xuICAgICAgICAgICAgICAgIGZuKCRlbG0sIGMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvZ2dsZSQxKCRlbG0sIGMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGFkZENsYXNzID0gKGVsbSwgY2xzKSA9PiB7XG4gICAgICAgIHRvZ2dsZUNsYXNzKGVsbSwgY2xzLCB0cnVlKTtcbiAgICAgIH07XG4gICAgICBjb25zdCByZW1vdmVDbGFzcyA9IChlbG0sIGNscykgPT4ge1xuICAgICAgICB0b2dnbGVDbGFzcyhlbG0sIGNscywgZmFsc2UpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGhhc0NsYXNzID0gKGVsbSwgY2xzKSA9PiB7XG4gICAgICAgIGNvbnN0ICRlbG0gPSBfZ2V0KGVsbSk7XG4gICAgICAgIGNvbnN0IGNsYXNzZXMgPSBjbHMuc3BsaXQoJyAnKTtcbiAgICAgICAgcmV0dXJuIGlzTm9uTnVsbGFibGUoJGVsbSkgJiYgZm9yYWxsKGNsYXNzZXMsIGMgPT4gaGFzKCRlbG0sIGMpKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBzaG93ID0gZWxtID0+IHtcbiAgICAgICAgcnVuKGVsbSwgZSA9PiByZW1vdmUkNyhTdWdhckVsZW1lbnQuZnJvbURvbShlKSwgJ2Rpc3BsYXknKSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgaGlkZSA9IGVsbSA9PiB7XG4gICAgICAgIHJ1bihlbG0sIGUgPT4gc2V0JDIoU3VnYXJFbGVtZW50LmZyb21Eb20oZSksICdkaXNwbGF5JywgJ25vbmUnKSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgaXNIaWRkZW4gPSBlbG0gPT4ge1xuICAgICAgICBjb25zdCAkZWxtID0gX2dldChlbG0pO1xuICAgICAgICByZXR1cm4gaXNOb25OdWxsYWJsZSgkZWxtKSAmJiBpcyQyKGdldFJhdygkZWxtLCAnZGlzcGxheScpLCAnbm9uZScpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHVuaXF1ZUlkID0gcHJlZml4ID0+ICghcHJlZml4ID8gJ21jZV8nIDogcHJlZml4KSArIGNvdW50ZXIrKztcbiAgICAgIGNvbnN0IGdldE91dGVySFRNTCA9IGVsbSA9PiB7XG4gICAgICAgIGNvbnN0ICRlbG0gPSBfZ2V0KGVsbSk7XG4gICAgICAgIGlmIChpc05vbk51bGxhYmxlKCRlbG0pKSB7XG4gICAgICAgICAgcmV0dXJuIGlzRWxlbWVudCQ2KCRlbG0uZG9tKSA/ICRlbG0uZG9tLm91dGVySFRNTCA6IGdldE91dGVyKCRlbG0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNldE91dGVySFRNTCA9IChlbG0sIGh0bWwpID0+IHtcbiAgICAgICAgcnVuKGVsbSwgJGVsbSA9PiB7XG4gICAgICAgICAgaWYgKGlzRWxlbWVudCQ2KCRlbG0pKSB7XG4gICAgICAgICAgICAkZWxtLm91dGVySFRNTCA9IGh0bWw7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBpbnNlcnRBZnRlciA9IChub2RlLCByZWZlcmVuY2UpID0+IHtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlTm9kZSA9IGdldChyZWZlcmVuY2UpO1xuICAgICAgICByZXR1cm4gcnVuKG5vZGUsIG5vZGUgPT4ge1xuICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHJlZmVyZW5jZU5vZGUgPT09IG51bGwgfHwgcmVmZXJlbmNlTm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmZXJlbmNlTm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgIGNvbnN0IG5leHRTaWJsaW5nID0gcmVmZXJlbmNlTm9kZSA9PT0gbnVsbCB8fCByZWZlcmVuY2VOb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWZlcmVuY2VOb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChuZXh0U2libGluZykge1xuICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIG5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlcGxhY2UgPSAobmV3RWxtLCBvbGRFbG0sIGtlZXBDaGlsZHJlbikgPT4gcnVuKG9sZEVsbSwgZWxtID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCByZXBsYWNlZSA9IGlzQXJyYXkkMShvbGRFbG0pID8gbmV3RWxtLmNsb25lTm9kZSh0cnVlKSA6IG5ld0VsbTtcbiAgICAgICAgaWYgKGtlZXBDaGlsZHJlbikge1xuICAgICAgICAgIGVhY2gkYShncmVwKGVsbS5jaGlsZE5vZGVzKSwgbm9kZSA9PiB7XG4gICAgICAgICAgICByZXBsYWNlZS5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAoX2EgPSBlbG0ucGFyZW50Tm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlcGxhY2VDaGlsZChyZXBsYWNlZSwgZWxtKTtcbiAgICAgICAgcmV0dXJuIGVsbTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcmVuYW1lID0gKGVsbSwgbmFtZSkgPT4ge1xuICAgICAgICBpZiAoZWxtLm5vZGVOYW1lICE9PSBuYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICBjb25zdCBuZXdFbG0gPSBjcmVhdGUobmFtZSk7XG4gICAgICAgICAgZWFjaCRhKGdldEF0dHJpYnMoZWxtKSwgYXR0ck5vZGUgPT4ge1xuICAgICAgICAgICAgc2V0QXR0cmliKG5ld0VsbSwgYXR0ck5vZGUubm9kZU5hbWUsIGdldEF0dHJpYihlbG0sIGF0dHJOb2RlLm5vZGVOYW1lKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVwbGFjZShuZXdFbG0sIGVsbSwgdHJ1ZSk7XG4gICAgICAgICAgcmV0dXJuIG5ld0VsbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZWxtO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgZmluZENvbW1vbkFuY2VzdG9yID0gKGEsIGIpID0+IHtcbiAgICAgICAgbGV0IHBzID0gYTtcbiAgICAgICAgd2hpbGUgKHBzKSB7XG4gICAgICAgICAgbGV0IHBlID0gYjtcbiAgICAgICAgICB3aGlsZSAocGUgJiYgcHMgIT09IHBlKSB7XG4gICAgICAgICAgICBwZSA9IHBlLnBhcmVudE5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcyA9PT0gcGUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwcyA9IHBzLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcyAmJiBhLm93bmVyRG9jdW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gYS5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcHM7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBpc05vbkVtcHR5RWxlbWVudCA9IG5vZGUgPT4ge1xuICAgICAgICBpZiAoaXNFbGVtZW50JDYobm9kZSkpIHtcbiAgICAgICAgICBjb25zdCBpc05hbWVkQW5jaG9yID0gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnYScgJiYgIWdldEF0dHJpYihub2RlLCAnaHJlZicpICYmIGdldEF0dHJpYihub2RlLCAnaWQnKTtcbiAgICAgICAgICBpZiAoZ2V0QXR0cmliKG5vZGUsICduYW1lJykgfHwgZ2V0QXR0cmliKG5vZGUsICdkYXRhLW1jZS1ib29rbWFyaycpIHx8IGlzTmFtZWRBbmNob3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgICAgY29uc3QgaXNFbXB0eSA9IChub2RlLCBlbGVtZW50cykgPT4ge1xuICAgICAgICBsZXQgYnJDb3VudCA9IDA7XG4gICAgICAgIGlmIChpc05vbkVtcHR5RWxlbWVudChub2RlKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaXJzdENoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICBpZiAoZmlyc3RDaGlsZCkge1xuICAgICAgICAgIGNvbnN0IHdhbGtlciA9IG5ldyBEb21UcmVlV2Fsa2VyKGZpcnN0Q2hpbGQsIG5vZGUpO1xuICAgICAgICAgIGNvbnN0IHdoaXRlc3BhY2VFbGVtZW50cyA9IHNjaGVtYSA/IHNjaGVtYS5nZXRXaGl0ZXNwYWNlRWxlbWVudHMoKSA6IHt9O1xuICAgICAgICAgIGNvbnN0IG5vbkVtcHR5RWxlbWVudHMgPSBlbGVtZW50cyB8fCAoc2NoZW1hID8gc2NoZW1hLmdldE5vbkVtcHR5RWxlbWVudHMoKSA6IG51bGwpO1xuICAgICAgICAgIGxldCB0ZW1wTm9kZSA9IGZpcnN0Q2hpbGQ7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGlzRWxlbWVudCQ2KHRlbXBOb2RlKSkge1xuICAgICAgICAgICAgICBjb25zdCBib2d1c1ZhbCA9IHRlbXBOb2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1tY2UtYm9ndXMnKTtcbiAgICAgICAgICAgICAgaWYgKGJvZ3VzVmFsKSB7XG4gICAgICAgICAgICAgICAgdGVtcE5vZGUgPSB3YWxrZXIubmV4dChib2d1c1ZhbCA9PT0gJ2FsbCcpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0ZW1wTm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICBpZiAobm9uRW1wdHlFbGVtZW50cyAmJiBub25FbXB0eUVsZW1lbnRzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdicicpIHtcbiAgICAgICAgICAgICAgICAgIGJyQ291bnQrKztcbiAgICAgICAgICAgICAgICAgIHRlbXBOb2RlID0gd2Fsa2VyLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGlzTm9uRW1wdHlFbGVtZW50KHRlbXBOb2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQ29tbWVudCh0ZW1wTm9kZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzVGV4dCRhKHRlbXBOb2RlKSAmJiAhaXNXaGl0ZXNwYWNlVGV4dCh0ZW1wTm9kZS5kYXRhKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNUZXh0JGEodGVtcE5vZGUpICYmIHRlbXBOb2RlLnBhcmVudE5vZGUgJiYgd2hpdGVzcGFjZUVsZW1lbnRzW3RlbXBOb2RlLnBhcmVudE5vZGUubm9kZU5hbWVdICYmIGlzV2hpdGVzcGFjZVRleHQodGVtcE5vZGUuZGF0YSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGVtcE5vZGUgPSB3YWxrZXIubmV4dCgpO1xuICAgICAgICAgIH0gd2hpbGUgKHRlbXBOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnJDb3VudCA8PSAxO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGNyZWF0ZVJuZyA9ICgpID0+IGRvYy5jcmVhdGVSYW5nZSgpO1xuICAgICAgY29uc3Qgc3BsaXQgPSAocGFyZW50RWxtLCBzcGxpdEVsbSwgcmVwbGFjZW1lbnRFbG0pID0+IHtcbiAgICAgICAgbGV0IHJhbmdlID0gY3JlYXRlUm5nKCk7XG4gICAgICAgIGxldCBiZWZvcmVGcmFnbWVudDtcbiAgICAgICAgbGV0IGFmdGVyRnJhZ21lbnQ7XG4gICAgICAgIGlmIChwYXJlbnRFbG0gJiYgc3BsaXRFbG0gJiYgcGFyZW50RWxtLnBhcmVudE5vZGUgJiYgc3BsaXRFbG0ucGFyZW50Tm9kZSkge1xuICAgICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBwYXJlbnRFbG0ucGFyZW50Tm9kZTtcbiAgICAgICAgICByYW5nZS5zZXRTdGFydChwYXJlbnROb2RlLCBmaW5kTm9kZUluZGV4KHBhcmVudEVsbSkpO1xuICAgICAgICAgIHJhbmdlLnNldEVuZChzcGxpdEVsbS5wYXJlbnROb2RlLCBmaW5kTm9kZUluZGV4KHNwbGl0RWxtKSk7XG4gICAgICAgICAgYmVmb3JlRnJhZ21lbnQgPSByYW5nZS5leHRyYWN0Q29udGVudHMoKTtcbiAgICAgICAgICByYW5nZSA9IGNyZWF0ZVJuZygpO1xuICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KHNwbGl0RWxtLnBhcmVudE5vZGUsIGZpbmROb2RlSW5kZXgoc3BsaXRFbG0pICsgMSk7XG4gICAgICAgICAgcmFuZ2Uuc2V0RW5kKHBhcmVudE5vZGUsIGZpbmROb2RlSW5kZXgocGFyZW50RWxtKSArIDEpO1xuICAgICAgICAgIGFmdGVyRnJhZ21lbnQgPSByYW5nZS5leHRyYWN0Q29udGVudHMoKTtcbiAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZSh0cmltTm9kZShzZWxmLCBiZWZvcmVGcmFnbWVudCksIHBhcmVudEVsbSk7XG4gICAgICAgICAgaWYgKHJlcGxhY2VtZW50RWxtKSB7XG4gICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShyZXBsYWNlbWVudEVsbSwgcGFyZW50RWxtKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc3BsaXRFbG0sIHBhcmVudEVsbSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRyaW1Ob2RlKHNlbGYsIGFmdGVyRnJhZ21lbnQpLCBwYXJlbnRFbG0pO1xuICAgICAgICAgIHJlbW92ZShwYXJlbnRFbG0pO1xuICAgICAgICAgIHJldHVybiByZXBsYWNlbWVudEVsbSB8fCBzcGxpdEVsbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgYmluZCA9ICh0YXJnZXQsIG5hbWUsIGZ1bmMsIHNjb3BlKSA9PiB7XG4gICAgICAgIGlmIChpc0FycmF5JDEodGFyZ2V0KSkge1xuICAgICAgICAgIGxldCBpID0gdGFyZ2V0Lmxlbmd0aDtcbiAgICAgICAgICBjb25zdCBydiA9IFtdO1xuICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIHJ2W2ldID0gYmluZCh0YXJnZXRbaV0sIG5hbWUsIGZ1bmMsIHNjb3BlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzZXR0aW5ncy5jb2xsZWN0ICYmICh0YXJnZXQgPT09IGRvYyB8fCB0YXJnZXQgPT09IHdpbikpIHtcbiAgICAgICAgICAgIGJvdW5kRXZlbnRzLnB1c2goW1xuICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIGZ1bmMsXG4gICAgICAgICAgICAgIHNjb3BlXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5iaW5kKHRhcmdldCwgbmFtZSwgZnVuYywgc2NvcGUgfHwgc2VsZik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCB1bmJpbmQgPSAodGFyZ2V0LCBuYW1lLCBmdW5jKSA9PiB7XG4gICAgICAgIGlmIChpc0FycmF5JDEodGFyZ2V0KSkge1xuICAgICAgICAgIGxldCBpID0gdGFyZ2V0Lmxlbmd0aDtcbiAgICAgICAgICBjb25zdCBydiA9IFtdO1xuICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIHJ2W2ldID0gdW5iaW5kKHRhcmdldFtpXSwgbmFtZSwgZnVuYyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoYm91bmRFdmVudHMubGVuZ3RoID4gMCAmJiAodGFyZ2V0ID09PSBkb2MgfHwgdGFyZ2V0ID09PSB3aW4pKSB7XG4gICAgICAgICAgICBsZXQgaSA9IGJvdW5kRXZlbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgY29uc3QgW2JvdW5kVGFyZ2V0LCBib3VuZE5hbWUsIGJvdW5kRnVuY10gPSBib3VuZEV2ZW50c1tpXTtcbiAgICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gYm91bmRUYXJnZXQgJiYgKCFuYW1lIHx8IG5hbWUgPT09IGJvdW5kTmFtZSkgJiYgKCFmdW5jIHx8IGZ1bmMgPT09IGJvdW5kRnVuYykpIHtcbiAgICAgICAgICAgICAgICBldmVudHMudW5iaW5kKGJvdW5kVGFyZ2V0LCBib3VuZE5hbWUsIGJvdW5kRnVuYyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy51bmJpbmQodGFyZ2V0LCBuYW1lLCBmdW5jKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGRpc3BhdGNoID0gKHRhcmdldCwgbmFtZSwgZXZ0KSA9PiBldmVudHMuZGlzcGF0Y2godGFyZ2V0LCBuYW1lLCBldnQpO1xuICAgICAgY29uc3QgZmlyZSA9ICh0YXJnZXQsIG5hbWUsIGV2dCkgPT4gZXZlbnRzLmRpc3BhdGNoKHRhcmdldCwgbmFtZSwgZXZ0KTtcbiAgICAgIGNvbnN0IGdldENvbnRlbnRFZGl0YWJsZSA9IG5vZGUgPT4ge1xuICAgICAgICBpZiAobm9kZSAmJiBpc0VsZW1lbnQkNihub2RlKSkge1xuICAgICAgICAgIGNvbnN0IGNvbnRlbnRFZGl0YWJsZSA9IG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLW1jZS1jb250ZW50ZWRpdGFibGUnKTtcbiAgICAgICAgICBpZiAoY29udGVudEVkaXRhYmxlICYmIGNvbnRlbnRFZGl0YWJsZSAhPT0gJ2luaGVyaXQnKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGVudEVkaXRhYmxlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbm9kZS5jb250ZW50RWRpdGFibGUgIT09ICdpbmhlcml0JyA/IG5vZGUuY29udGVudEVkaXRhYmxlIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldENvbnRlbnRFZGl0YWJsZVBhcmVudCA9IG5vZGUgPT4ge1xuICAgICAgICBjb25zdCByb290ID0gZ2V0Um9vdCgpO1xuICAgICAgICBsZXQgc3RhdGUgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCB0ZW1wTm9kZSA9IG5vZGU7IHRlbXBOb2RlICYmIHRlbXBOb2RlICE9PSByb290OyB0ZW1wTm9kZSA9IHRlbXBOb2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBzdGF0ZSA9IGdldENvbnRlbnRFZGl0YWJsZSh0ZW1wTm9kZSk7XG4gICAgICAgICAgaWYgKHN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzRWRpdGFibGUgPSBub2RlID0+IHtcbiAgICAgICAgaWYgKGlzTm9uTnVsbGFibGUobm9kZSkpIHtcbiAgICAgICAgICBjb25zdCBzY29wZSA9IGlzRWxlbWVudCQ2KG5vZGUpID8gbm9kZSA6IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICAgICAgICBjb25zdCBpc1Jvb3RFZGl0YWJsZSA9IGdldENvbnRlbnRFZGl0YWJsZShnZXRSb290KCkpID09PSAndHJ1ZSc7XG4gICAgICAgICAgcmV0dXJuIGlzTm9uTnVsbGFibGUoc2NvcGUpICYmIGlzRWRpdGFibGUkMyhTdWdhckVsZW1lbnQuZnJvbURvbShzY29wZSksIGlzUm9vdEVkaXRhYmxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBkZXN0cm95ID0gKCkgPT4ge1xuICAgICAgICBpZiAoYm91bmRFdmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGxldCBpID0gYm91bmRFdmVudHMubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IFtib3VuZFRhcmdldCwgYm91bmROYW1lLCBib3VuZEZ1bmNdID0gYm91bmRFdmVudHNbaV07XG4gICAgICAgICAgICBldmVudHMudW5iaW5kKGJvdW5kVGFyZ2V0LCBib3VuZE5hbWUsIGJvdW5kRnVuYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVhY2gkZChmaWxlcywgKF8sIHVybCkgPT4ge1xuICAgICAgICAgIHN0eWxlU2hlZXRMb2FkZXIudW5sb2FkKHVybCk7XG4gICAgICAgICAgZGVsZXRlIGZpbGVzW3VybF07XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzQ2hpbGRPZiA9IChub2RlLCBwYXJlbnQpID0+IHtcbiAgICAgICAgcmV0dXJuIG5vZGUgPT09IHBhcmVudCB8fCBwYXJlbnQuY29udGFpbnMobm9kZSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZHVtcFJuZyA9IHIgPT4gJ3N0YXJ0Q29udGFpbmVyOiAnICsgci5zdGFydENvbnRhaW5lci5ub2RlTmFtZSArICcsIHN0YXJ0T2Zmc2V0OiAnICsgci5zdGFydE9mZnNldCArICcsIGVuZENvbnRhaW5lcjogJyArIHIuZW5kQ29udGFpbmVyLm5vZGVOYW1lICsgJywgZW5kT2Zmc2V0OiAnICsgci5lbmRPZmZzZXQ7XG4gICAgICBjb25zdCBzZWxmID0ge1xuICAgICAgICBkb2MsXG4gICAgICAgIHNldHRpbmdzLFxuICAgICAgICB3aW4sXG4gICAgICAgIGZpbGVzLFxuICAgICAgICBzdGRNb2RlLFxuICAgICAgICBib3hNb2RlbCxcbiAgICAgICAgc3R5bGVTaGVldExvYWRlcixcbiAgICAgICAgYm91bmRFdmVudHMsXG4gICAgICAgIHN0eWxlcyxcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICBldmVudHMsXG4gICAgICAgIGlzQmxvY2s6IGlzQmxvY2ssXG4gICAgICAgIHJvb3Q6IG51bGwsXG4gICAgICAgIGNsb25lLFxuICAgICAgICBnZXRSb290LFxuICAgICAgICBnZXRWaWV3UG9ydCxcbiAgICAgICAgZ2V0UmVjdCxcbiAgICAgICAgZ2V0U2l6ZSxcbiAgICAgICAgZ2V0UGFyZW50LFxuICAgICAgICBnZXRQYXJlbnRzOiBnZXRQYXJlbnRzLFxuICAgICAgICBnZXQsXG4gICAgICAgIGdldE5leHQsXG4gICAgICAgIGdldFByZXYsXG4gICAgICAgIHNlbGVjdCxcbiAgICAgICAgaXMsXG4gICAgICAgIGFkZCxcbiAgICAgICAgY3JlYXRlLFxuICAgICAgICBjcmVhdGVIVE1MLFxuICAgICAgICBjcmVhdGVGcmFnbWVudCxcbiAgICAgICAgcmVtb3ZlLFxuICAgICAgICBzZXRTdHlsZSxcbiAgICAgICAgZ2V0U3R5bGU6IGdldFN0eWxlLFxuICAgICAgICBzZXRTdHlsZXMsXG4gICAgICAgIHJlbW92ZUFsbEF0dHJpYnMsXG4gICAgICAgIHNldEF0dHJpYixcbiAgICAgICAgc2V0QXR0cmlicyxcbiAgICAgICAgZ2V0QXR0cmliLFxuICAgICAgICBnZXRQb3M6IGdldFBvcyQxLFxuICAgICAgICBwYXJzZVN0eWxlLFxuICAgICAgICBzZXJpYWxpemVTdHlsZSxcbiAgICAgICAgYWRkU3R5bGUsXG4gICAgICAgIGxvYWRDU1MsXG4gICAgICAgIGFkZENsYXNzLFxuICAgICAgICByZW1vdmVDbGFzcyxcbiAgICAgICAgaGFzQ2xhc3MsXG4gICAgICAgIHRvZ2dsZUNsYXNzLFxuICAgICAgICBzaG93LFxuICAgICAgICBoaWRlLFxuICAgICAgICBpc0hpZGRlbixcbiAgICAgICAgdW5pcXVlSWQsXG4gICAgICAgIHNldEhUTUwsXG4gICAgICAgIGdldE91dGVySFRNTCxcbiAgICAgICAgc2V0T3V0ZXJIVE1MLFxuICAgICAgICBkZWNvZGUsXG4gICAgICAgIGVuY29kZSxcbiAgICAgICAgaW5zZXJ0QWZ0ZXIsXG4gICAgICAgIHJlcGxhY2UsXG4gICAgICAgIHJlbmFtZSxcbiAgICAgICAgZmluZENvbW1vbkFuY2VzdG9yLFxuICAgICAgICBydW4sXG4gICAgICAgIGdldEF0dHJpYnMsXG4gICAgICAgIGlzRW1wdHksXG4gICAgICAgIGNyZWF0ZVJuZyxcbiAgICAgICAgbm9kZUluZGV4OiBmaW5kTm9kZUluZGV4LFxuICAgICAgICBzcGxpdCxcbiAgICAgICAgYmluZDogYmluZCxcbiAgICAgICAgdW5iaW5kOiB1bmJpbmQsXG4gICAgICAgIGZpcmUsXG4gICAgICAgIGRpc3BhdGNoLFxuICAgICAgICBnZXRDb250ZW50RWRpdGFibGUsXG4gICAgICAgIGdldENvbnRlbnRFZGl0YWJsZVBhcmVudCxcbiAgICAgICAgaXNFZGl0YWJsZSxcbiAgICAgICAgZGVzdHJveSxcbiAgICAgICAgaXNDaGlsZE9mLFxuICAgICAgICBkdW1wUm5nXG4gICAgICB9O1xuICAgICAgY29uc3QgYXR0ckhvb2tzID0gc2V0dXBBdHRySG9va3Moc3R5bGVzLCBzZXR0aW5ncywgY29uc3RhbnQoc2VsZikpO1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBET01VdGlscy5ET00gPSBET01VdGlscyhkb2N1bWVudCk7XG4gICAgRE9NVXRpbHMubm9kZUluZGV4ID0gZmluZE5vZGVJbmRleDtcblxuICAgIGNvbnN0IERPTSRiID0gRE9NVXRpbHMuRE9NO1xuICAgIGNvbnN0IFFVRVVFRCA9IDA7XG4gICAgY29uc3QgTE9BRElORyA9IDE7XG4gICAgY29uc3QgTE9BREVEID0gMjtcbiAgICBjb25zdCBGQUlMRUQgPSAzO1xuICAgIGNsYXNzIFNjcmlwdExvYWRlciB7XG4gICAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncyA9IHt9KSB7XG4gICAgICAgIHRoaXMuc3RhdGVzID0ge307XG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5zY3JpcHRMb2FkZWRDYWxsYmFja3MgPSB7fTtcbiAgICAgICAgdGhpcy5xdWV1ZUxvYWRlZENhbGxiYWNrcyA9IFtdO1xuICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgICAgfVxuICAgICAgX3NldFJlZmVycmVyUG9saWN5KHJlZmVycmVyUG9saWN5KSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MucmVmZXJyZXJQb2xpY3kgPSByZWZlcnJlclBvbGljeTtcbiAgICAgIH1cbiAgICAgIGxvYWRTY3JpcHQodXJsKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgY29uc3QgZG9tID0gRE9NJGI7XG4gICAgICAgICAgbGV0IGVsbTtcbiAgICAgICAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgICAgICAgICAgZG9tLnJlbW92ZShpZCk7XG4gICAgICAgICAgICBpZiAoZWxtKSB7XG4gICAgICAgICAgICAgIGVsbS5vbmVycm9yID0gZWxtLm9ubG9hZCA9IGVsbSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25zdCBkb25lID0gKCkgPT4ge1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICByZWplY3QoJ0ZhaWxlZCB0byBsb2FkIHNjcmlwdDogJyArIHVybCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25zdCBpZCA9IGRvbS51bmlxdWVJZCgpO1xuICAgICAgICAgIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICAgIGVsbS5pZCA9IGlkO1xuICAgICAgICAgIGVsbS50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gICAgICAgICAgZWxtLnNyYyA9IFRvb2xzLl9hZGRDYWNoZVN1ZmZpeCh1cmwpO1xuICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnJlZmVycmVyUG9saWN5KSB7XG4gICAgICAgICAgICBkb20uc2V0QXR0cmliKGVsbSwgJ3JlZmVycmVycG9saWN5JywgdGhpcy5zZXR0aW5ncy5yZWZlcnJlclBvbGljeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsbS5vbmxvYWQgPSBkb25lO1xuICAgICAgICAgIGVsbS5vbmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgKGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0gfHwgZG9jdW1lbnQuYm9keSkuYXBwZW5kQ2hpbGQoZWxtKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpc0RvbmUodXJsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlc1t1cmxdID09PSBMT0FERUQ7XG4gICAgICB9XG4gICAgICBtYXJrRG9uZSh1cmwpIHtcbiAgICAgICAgdGhpcy5zdGF0ZXNbdXJsXSA9IExPQURFRDtcbiAgICAgIH1cbiAgICAgIGFkZCh1cmwpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIHNlbGYucXVldWUucHVzaCh1cmwpO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHNlbGYuc3RhdGVzW3VybF07XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc2VsZi5zdGF0ZXNbdXJsXSA9IFFVRVVFRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGlmICghc2VsZi5zY3JpcHRMb2FkZWRDYWxsYmFja3NbdXJsXSkge1xuICAgICAgICAgICAgc2VsZi5zY3JpcHRMb2FkZWRDYWxsYmFja3NbdXJsXSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLnNjcmlwdExvYWRlZENhbGxiYWNrc1t1cmxdLnB1c2goe1xuICAgICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICAgIHJlamVjdFxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGxvYWQodXJsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZCh1cmwpO1xuICAgICAgfVxuICAgICAgcmVtb3ZlKHVybCkge1xuICAgICAgICBkZWxldGUgdGhpcy5zdGF0ZXNbdXJsXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuc2NyaXB0TG9hZGVkQ2FsbGJhY2tzW3VybF07XG4gICAgICB9XG4gICAgICBsb2FkUXVldWUoKSB7XG4gICAgICAgIGNvbnN0IHF1ZXVlID0gdGhpcy5xdWV1ZTtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgICByZXR1cm4gdGhpcy5sb2FkU2NyaXB0cyhxdWV1ZSk7XG4gICAgICB9XG4gICAgICBsb2FkU2NyaXB0cyhzY3JpcHRzKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBjb25zdCBleGVjQ2FsbGJhY2tzID0gKG5hbWUsIHVybCkgPT4ge1xuICAgICAgICAgIGdldCRhKHNlbGYuc2NyaXB0TG9hZGVkQ2FsbGJhY2tzLCB1cmwpLmVhY2goY2FsbGJhY2tzID0+IHtcbiAgICAgICAgICAgIGVhY2gkZShjYWxsYmFja3MsIGNhbGxiYWNrID0+IGNhbGxiYWNrW25hbWVdKHVybCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGRlbGV0ZSBzZWxmLnNjcmlwdExvYWRlZENhbGxiYWNrc1t1cmxdO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwcm9jZXNzUmVzdWx0cyA9IHJlc3VsdHMgPT4ge1xuICAgICAgICAgIGNvbnN0IGZhaWx1cmVzID0gZmlsdGVyJDUocmVzdWx0cywgcmVzdWx0ID0+IHJlc3VsdC5zdGF0dXMgPT09ICdyZWplY3RlZCcpO1xuICAgICAgICAgIGlmIChmYWlsdXJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoYmluZCQzKGZhaWx1cmVzLCAoe3JlYXNvbn0pID0+IGlzQXJyYXkkMShyZWFzb24pID8gcmVhc29uIDogW3JlYXNvbl0pKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbG9hZCA9IHVybHMgPT4gUHJvbWlzZS5hbGxTZXR0bGVkKG1hcCQzKHVybHMsIHVybCA9PiB7XG4gICAgICAgICAgaWYgKHNlbGYuc3RhdGVzW3VybF0gPT09IExPQURFRCkge1xuICAgICAgICAgICAgZXhlY0NhbGxiYWNrcygncmVzb2x2ZScsIHVybCk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzZWxmLnN0YXRlc1t1cmxdID09PSBGQUlMRUQpIHtcbiAgICAgICAgICAgIGV4ZWNDYWxsYmFja3MoJ3JlamVjdCcsIHVybCk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QodXJsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5zdGF0ZXNbdXJsXSA9IExPQURJTkc7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5sb2FkU2NyaXB0KHVybCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgIHNlbGYuc3RhdGVzW3VybF0gPSBMT0FERUQ7XG4gICAgICAgICAgICAgIGV4ZWNDYWxsYmFja3MoJ3Jlc29sdmUnLCB1cmwpO1xuICAgICAgICAgICAgICBjb25zdCBxdWV1ZSA9IHNlbGYucXVldWU7XG4gICAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5xdWV1ZSA9IFtdO1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkKHF1ZXVlKS50aGVuKHByb2Nlc3NSZXN1bHRzKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sICgpID0+IHtcbiAgICAgICAgICAgICAgc2VsZi5zdGF0ZXNbdXJsXSA9IEZBSUxFRDtcbiAgICAgICAgICAgICAgZXhlY0NhbGxiYWNrcygncmVqZWN0JywgdXJsKTtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHVybCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgY29uc3QgcHJvY2Vzc1F1ZXVlID0gdXJscyA9PiB7XG4gICAgICAgICAgc2VsZi5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gbG9hZCh1cmxzKS50aGVuKHJlc3VsdHMgPT4ge1xuICAgICAgICAgICAgc2VsZi5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBuZXh0UXVldWVkSXRlbSA9IHNlbGYucXVldWVMb2FkZWRDYWxsYmFja3Muc2hpZnQoKTtcbiAgICAgICAgICAgIE9wdGlvbmFsLmZyb20obmV4dFF1ZXVlZEl0ZW0pLmVhY2goY2FsbCk7XG4gICAgICAgICAgICByZXR1cm4gcHJvY2Vzc1Jlc3VsdHMocmVzdWx0cyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHVuaXF1ZVNjcmlwdHMgPSBzdHJpbmdBcnJheShzY3JpcHRzKTtcbiAgICAgICAgaWYgKHNlbGYubG9hZGluZykge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBzZWxmLnF1ZXVlTG9hZGVkQ2FsbGJhY2tzLnB1c2goKCkgPT4gcHJvY2Vzc1F1ZXVlKHVuaXF1ZVNjcmlwdHMpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHByb2Nlc3NRdWV1ZSh1bmlxdWVTY3JpcHRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBTY3JpcHRMb2FkZXIuU2NyaXB0TG9hZGVyID0gbmV3IFNjcmlwdExvYWRlcigpO1xuXG4gICAgY29uc3QgQ2VsbCA9IGluaXRpYWwgPT4ge1xuICAgICAgbGV0IHZhbHVlID0gaW5pdGlhbDtcbiAgICAgIGNvbnN0IGdldCA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHNldCA9IHYgPT4ge1xuICAgICAgICB2YWx1ZSA9IHY7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0LFxuICAgICAgICBzZXRcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IGlzUmF3ID0gc3RyID0+IGlzT2JqZWN0KHN0cikgJiYgaGFzJDIoc3RyLCAncmF3Jyk7XG4gICAgY29uc3QgaXNUb2tlbmlzZWQgPSBzdHIgPT4gaXNBcnJheSQxKHN0cikgJiYgc3RyLmxlbmd0aCA+IDE7XG4gICAgY29uc3QgZGF0YSA9IHt9O1xuICAgIGNvbnN0IGN1cnJlbnRDb2RlID0gQ2VsbCgnZW4nKTtcbiAgICBjb25zdCBnZXRMYW5ndWFnZURhdGEgPSAoKSA9PiBnZXQkYShkYXRhLCBjdXJyZW50Q29kZS5nZXQoKSk7XG4gICAgY29uc3QgZ2V0RGF0YSQxID0gKCkgPT4gbWFwJDIoZGF0YSwgdmFsdWUgPT4gKHsgLi4udmFsdWUgfSkpO1xuICAgIGNvbnN0IHNldENvZGUgPSBuZXdDb2RlID0+IHtcbiAgICAgIGlmIChuZXdDb2RlKSB7XG4gICAgICAgIGN1cnJlbnRDb2RlLnNldChuZXdDb2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGdldENvZGUgPSAoKSA9PiBjdXJyZW50Q29kZS5nZXQoKTtcbiAgICBjb25zdCBhZGQkMSA9IChjb2RlLCBpdGVtcykgPT4ge1xuICAgICAgbGV0IGxhbmdEYXRhID0gZGF0YVtjb2RlXTtcbiAgICAgIGlmICghbGFuZ0RhdGEpIHtcbiAgICAgICAgZGF0YVtjb2RlXSA9IGxhbmdEYXRhID0ge307XG4gICAgICB9XG4gICAgICBlYWNoJGQoaXRlbXMsICh0cmFuc2xhdGlvbiwgbmFtZSkgPT4ge1xuICAgICAgICBsYW5nRGF0YVtuYW1lLnRvTG93ZXJDYXNlKCldID0gdHJhbnNsYXRpb247XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHRyYW5zbGF0ZSA9IHRleHQgPT4ge1xuICAgICAgY29uc3QgbGFuZ0RhdGEgPSBnZXRMYW5ndWFnZURhdGEoKS5nZXRPcih7fSk7XG4gICAgICBjb25zdCB0b1N0cmluZyA9IG9iaiA9PiB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKG9iaikpIHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFpc0VtcHR5KG9iaikgPyAnJyArIG9iaiA6ICcnO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzRW1wdHkgPSB0ZXh0ID0+IHRleHQgPT09ICcnIHx8IHRleHQgPT09IG51bGwgfHwgdGV4dCA9PT0gdW5kZWZpbmVkO1xuICAgICAgY29uc3QgZ2V0TGFuZ0RhdGEgPSB0ZXh0ID0+IHtcbiAgICAgICAgY29uc3QgdGV4dHN0ciA9IHRvU3RyaW5nKHRleHQpO1xuICAgICAgICByZXR1cm4gZ2V0JGEobGFuZ0RhdGEsIHRleHRzdHIudG9Mb3dlckNhc2UoKSkubWFwKHRvU3RyaW5nKS5nZXRPcih0ZXh0c3RyKTtcbiAgICAgIH07XG4gICAgICBjb25zdCByZW1vdmVDb250ZXh0ID0gc3RyID0+IHN0ci5yZXBsYWNlKC97Y29udGV4dDpcXHcrfSQvLCAnJyk7XG4gICAgICBpZiAoaXNFbXB0eSh0ZXh0KSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICBpZiAoaXNSYXcodGV4dCkpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nKHRleHQucmF3KTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1Rva2VuaXNlZCh0ZXh0KSkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSB0ZXh0LnNsaWNlKDEpO1xuICAgICAgICBjb25zdCBzdWJzdGl0dWVkID0gZ2V0TGFuZ0RhdGEodGV4dFswXSkucmVwbGFjZSgvXFx7KFswLTldKylcXH0vZywgKCQxLCAkMikgPT4gaGFzJDIodmFsdWVzLCAkMikgPyB0b1N0cmluZyh2YWx1ZXNbJDJdKSA6ICQxKTtcbiAgICAgICAgcmV0dXJuIHJlbW92ZUNvbnRleHQoc3Vic3RpdHVlZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVtb3ZlQ29udGV4dChnZXRMYW5nRGF0YSh0ZXh0KSk7XG4gICAgfTtcbiAgICBjb25zdCBpc1J0bCQxID0gKCkgPT4gZ2V0TGFuZ3VhZ2VEYXRhKCkuYmluZChpdGVtcyA9PiBnZXQkYShpdGVtcywgJ19kaXInKSkuZXhpc3RzKGRpciA9PiBkaXIgPT09ICdydGwnKTtcbiAgICBjb25zdCBoYXNDb2RlID0gY29kZSA9PiBoYXMkMihkYXRhLCBjb2RlKTtcbiAgICBjb25zdCBJMThuID0ge1xuICAgICAgZ2V0RGF0YTogZ2V0RGF0YSQxLFxuICAgICAgc2V0Q29kZSxcbiAgICAgIGdldENvZGUsXG4gICAgICBhZGQ6IGFkZCQxLFxuICAgICAgdHJhbnNsYXRlLFxuICAgICAgaXNSdGw6IGlzUnRsJDEsXG4gICAgICBoYXNDb2RlXG4gICAgfTtcblxuICAgIGNvbnN0IEFkZE9uTWFuYWdlciA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgICBjb25zdCB1cmxzID0ge307XG4gICAgICBjb25zdCBsb29rdXAgPSB7fTtcbiAgICAgIGNvbnN0IF9saXN0ZW5lcnMgPSBbXTtcbiAgICAgIGNvbnN0IHJ1bkxpc3RlbmVycyA9IChuYW1lLCBzdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCBtYXRjaGVkTGlzdGVuZXJzID0gZmlsdGVyJDUoX2xpc3RlbmVycywgbGlzdGVuZXIgPT4gbGlzdGVuZXIubmFtZSA9PT0gbmFtZSAmJiBsaXN0ZW5lci5zdGF0ZSA9PT0gc3RhdGUpO1xuICAgICAgICBlYWNoJGUobWF0Y2hlZExpc3RlbmVycywgbGlzdGVuZXIgPT4gbGlzdGVuZXIucmVzb2x2ZSgpKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBpc0xvYWRlZCA9IG5hbWUgPT4gaGFzJDIodXJscywgbmFtZSk7XG4gICAgICBjb25zdCBpc0FkZGVkID0gbmFtZSA9PiBoYXMkMihsb29rdXAsIG5hbWUpO1xuICAgICAgY29uc3QgZ2V0ID0gbmFtZSA9PiB7XG4gICAgICAgIGlmIChsb29rdXBbbmFtZV0pIHtcbiAgICAgICAgICByZXR1cm4gbG9va3VwW25hbWVdLmluc3RhbmNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9O1xuICAgICAgY29uc3QgbG9hZExhbmd1YWdlUGFjayA9IChuYW1lLCBsYW5ndWFnZXMpID0+IHtcbiAgICAgICAgY29uc3QgbGFuZ3VhZ2UgPSBJMThuLmdldENvZGUoKTtcbiAgICAgICAgY29uc3Qgd3JhcHBlZExhbmd1YWdlcyA9ICcsJyArIChsYW5ndWFnZXMgfHwgJycpICsgJywnO1xuICAgICAgICBpZiAoIWxhbmd1YWdlIHx8IGxhbmd1YWdlcyAmJiB3cmFwcGVkTGFuZ3VhZ2VzLmluZGV4T2YoJywnICsgbGFuZ3VhZ2UgKyAnLCcpID09PSAtMSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBTY3JpcHRMb2FkZXIuU2NyaXB0TG9hZGVyLmFkZCh1cmxzW25hbWVdICsgJy9sYW5ncy8nICsgbGFuZ3VhZ2UgKyAnLmpzJyk7XG4gICAgICB9O1xuICAgICAgY29uc3QgcmVxdWlyZUxhbmdQYWNrID0gKG5hbWUsIGxhbmd1YWdlcykgPT4ge1xuICAgICAgICBpZiAoQWRkT25NYW5hZ2VyLmxhbmd1YWdlTG9hZCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBpZiAoaXNMb2FkZWQobmFtZSkpIHtcbiAgICAgICAgICAgIGxvYWRMYW5ndWFnZVBhY2sobmFtZSwgbGFuZ3VhZ2VzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2FpdEZvcihuYW1lLCAnbG9hZGVkJykudGhlbigoKSA9PiBsb2FkTGFuZ3VhZ2VQYWNrKG5hbWUsIGxhbmd1YWdlcykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGFkZCA9IChpZCwgYWRkT24pID0+IHtcbiAgICAgICAgaXRlbXMucHVzaChhZGRPbik7XG4gICAgICAgIGxvb2t1cFtpZF0gPSB7IGluc3RhbmNlOiBhZGRPbiB9O1xuICAgICAgICBydW5MaXN0ZW5lcnMoaWQsICdhZGRlZCcpO1xuICAgICAgICByZXR1cm4gYWRkT247XG4gICAgICB9O1xuICAgICAgY29uc3QgcmVtb3ZlID0gbmFtZSA9PiB7XG4gICAgICAgIGRlbGV0ZSB1cmxzW25hbWVdO1xuICAgICAgICBkZWxldGUgbG9va3VwW25hbWVdO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGNyZWF0ZVVybCA9IChiYXNlVXJsLCBkZXApID0+IHtcbiAgICAgICAgaWYgKGlzU3RyaW5nKGRlcCkpIHtcbiAgICAgICAgICByZXR1cm4gaXNTdHJpbmcoYmFzZVVybCkgPyB7XG4gICAgICAgICAgICBwcmVmaXg6ICcnLFxuICAgICAgICAgICAgcmVzb3VyY2U6IGRlcCxcbiAgICAgICAgICAgIHN1ZmZpeDogJydcbiAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgcHJlZml4OiBiYXNlVXJsLnByZWZpeCxcbiAgICAgICAgICAgIHJlc291cmNlOiBkZXAsXG4gICAgICAgICAgICBzdWZmaXg6IGJhc2VVcmwuc3VmZml4XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZGVwO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgbG9hZCA9IChuYW1lLCBhZGRPblVybCkgPT4ge1xuICAgICAgICBpZiAodXJsc1tuYW1lXSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdXJsU3RyaW5nID0gaXNTdHJpbmcoYWRkT25VcmwpID8gYWRkT25VcmwgOiBhZGRPblVybC5wcmVmaXggKyBhZGRPblVybC5yZXNvdXJjZSArIGFkZE9uVXJsLnN1ZmZpeDtcbiAgICAgICAgaWYgKHVybFN0cmluZy5pbmRleE9mKCcvJykgIT09IDAgJiYgdXJsU3RyaW5nLmluZGV4T2YoJzovLycpID09PSAtMSkge1xuICAgICAgICAgIHVybFN0cmluZyA9IEFkZE9uTWFuYWdlci5iYXNlVVJMICsgJy8nICsgdXJsU3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIHVybHNbbmFtZV0gPSB1cmxTdHJpbmcuc3Vic3RyaW5nKDAsIHVybFN0cmluZy5sYXN0SW5kZXhPZignLycpKTtcbiAgICAgICAgY29uc3QgZG9uZSA9ICgpID0+IHtcbiAgICAgICAgICBydW5MaXN0ZW5lcnMobmFtZSwgJ2xvYWRlZCcpO1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGxvb2t1cFtuYW1lXSkge1xuICAgICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFNjcmlwdExvYWRlci5TY3JpcHRMb2FkZXIuYWRkKHVybFN0cmluZykudGhlbihkb25lKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHdhaXRGb3IgPSAobmFtZSwgc3RhdGUgPSAnYWRkZWQnKSA9PiB7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2FkZGVkJyAmJiBpc0FkZGVkKG5hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSAnbG9hZGVkJyAmJiBpc0xvYWRlZChuYW1lKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBfbGlzdGVuZXJzLnB1c2goe1xuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgcmVzb2x2ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpdGVtcyxcbiAgICAgICAgdXJscyxcbiAgICAgICAgbG9va3VwLFxuICAgICAgICBnZXQsXG4gICAgICAgIHJlcXVpcmVMYW5nUGFjayxcbiAgICAgICAgYWRkLFxuICAgICAgICByZW1vdmUsXG4gICAgICAgIGNyZWF0ZVVybCxcbiAgICAgICAgbG9hZCxcbiAgICAgICAgd2FpdEZvclxuICAgICAgfTtcbiAgICB9O1xuICAgIEFkZE9uTWFuYWdlci5sYW5ndWFnZUxvYWQgPSB0cnVlO1xuICAgIEFkZE9uTWFuYWdlci5iYXNlVVJMID0gJyc7XG4gICAgQWRkT25NYW5hZ2VyLlBsdWdpbk1hbmFnZXIgPSBBZGRPbk1hbmFnZXIoKTtcbiAgICBBZGRPbk1hbmFnZXIuVGhlbWVNYW5hZ2VyID0gQWRkT25NYW5hZ2VyKCk7XG4gICAgQWRkT25NYW5hZ2VyLk1vZGVsTWFuYWdlciA9IEFkZE9uTWFuYWdlcigpO1xuXG4gICAgY29uc3Qgc2luZ2xldG9uID0gZG9SZXZva2UgPT4ge1xuICAgICAgY29uc3Qgc3ViamVjdCA9IENlbGwoT3B0aW9uYWwubm9uZSgpKTtcbiAgICAgIGNvbnN0IHJldm9rZSA9ICgpID0+IHN1YmplY3QuZ2V0KCkuZWFjaChkb1Jldm9rZSk7XG4gICAgICBjb25zdCBjbGVhciA9ICgpID0+IHtcbiAgICAgICAgcmV2b2tlKCk7XG4gICAgICAgIHN1YmplY3Quc2V0KE9wdGlvbmFsLm5vbmUoKSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgaXNTZXQgPSAoKSA9PiBzdWJqZWN0LmdldCgpLmlzU29tZSgpO1xuICAgICAgY29uc3QgZ2V0ID0gKCkgPT4gc3ViamVjdC5nZXQoKTtcbiAgICAgIGNvbnN0IHNldCA9IHMgPT4ge1xuICAgICAgICByZXZva2UoKTtcbiAgICAgICAgc3ViamVjdC5zZXQoT3B0aW9uYWwuc29tZShzKSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2xlYXIsXG4gICAgICAgIGlzU2V0LFxuICAgICAgICBnZXQsXG4gICAgICAgIHNldFxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IHJlcGVhdGFibGUgPSBkZWxheSA9PiB7XG4gICAgICBjb25zdCBpbnRlcnZhbElkID0gQ2VsbChPcHRpb25hbC5ub25lKCkpO1xuICAgICAgY29uc3QgcmV2b2tlID0gKCkgPT4gaW50ZXJ2YWxJZC5nZXQoKS5lYWNoKGlkID0+IGNsZWFySW50ZXJ2YWwoaWQpKTtcbiAgICAgIGNvbnN0IGNsZWFyID0gKCkgPT4ge1xuICAgICAgICByZXZva2UoKTtcbiAgICAgICAgaW50ZXJ2YWxJZC5zZXQoT3B0aW9uYWwubm9uZSgpKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBpc1NldCA9ICgpID0+IGludGVydmFsSWQuZ2V0KCkuaXNTb21lKCk7XG4gICAgICBjb25zdCBnZXQgPSAoKSA9PiBpbnRlcnZhbElkLmdldCgpO1xuICAgICAgY29uc3Qgc2V0ID0gZnVuY3Rpb25Ub1JlcGVhdCA9PiB7XG4gICAgICAgIHJldm9rZSgpO1xuICAgICAgICBpbnRlcnZhbElkLnNldChPcHRpb25hbC5zb21lKHNldEludGVydmFsKGZ1bmN0aW9uVG9SZXBlYXQsIGRlbGF5KSkpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNsZWFyLFxuICAgICAgICBpc1NldCxcbiAgICAgICAgZ2V0LFxuICAgICAgICBzZXRcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCB2YWx1ZSQyID0gKCkgPT4ge1xuICAgICAgY29uc3Qgc3ViamVjdCA9IHNpbmdsZXRvbihub29wKTtcbiAgICAgIGNvbnN0IG9uID0gZiA9PiBzdWJqZWN0LmdldCgpLmVhY2goZik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdWJqZWN0LFxuICAgICAgICBvblxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgZmlyc3QkMSA9IChmbiwgcmF0ZSkgPT4ge1xuICAgICAgbGV0IHRpbWVyID0gbnVsbDtcbiAgICAgIGNvbnN0IGNhbmNlbCA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFpc051bGwodGltZXIpKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCB0aHJvdHRsZSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGlmIChpc051bGwodGltZXIpKSB7XG4gICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgIH0sIHJhdGUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2FuY2VsLFxuICAgICAgICB0aHJvdHRsZVxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGxhc3QkMSA9IChmbiwgcmF0ZSkgPT4ge1xuICAgICAgbGV0IHRpbWVyID0gbnVsbDtcbiAgICAgIGNvbnN0IGNhbmNlbCA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFpc051bGwodGltZXIpKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCB0aHJvdHRsZSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfSwgcmF0ZSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2FuY2VsLFxuICAgICAgICB0aHJvdHRsZVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgYW5ub3RhdGlvbiA9IGNvbnN0YW50KCdtY2UtYW5ub3RhdGlvbicpO1xuICAgIGNvbnN0IGRhdGFBbm5vdGF0aW9uID0gY29uc3RhbnQoJ2RhdGEtbWNlLWFubm90YXRpb24nKTtcbiAgICBjb25zdCBkYXRhQW5ub3RhdGlvbklkID0gY29uc3RhbnQoJ2RhdGEtbWNlLWFubm90YXRpb24tdWlkJyk7XG4gICAgY29uc3QgZGF0YUFubm90YXRpb25BY3RpdmUgPSBjb25zdGFudCgnZGF0YS1tY2UtYW5ub3RhdGlvbi1hY3RpdmUnKTtcbiAgICBjb25zdCBkYXRhQW5ub3RhdGlvbkNsYXNzZXMgPSBjb25zdGFudCgnZGF0YS1tY2UtYW5ub3RhdGlvbi1jbGFzc2VzJyk7XG4gICAgY29uc3QgZGF0YUFubm90YXRpb25BdHRyaWJ1dGVzID0gY29uc3RhbnQoJ2RhdGEtbWNlLWFubm90YXRpb24tYXR0cnMnKTtcblxuICAgIGNvbnN0IGlzUm9vdCQxID0gcm9vdCA9PiBub2RlID0+IGVxKG5vZGUsIHJvb3QpO1xuICAgIGNvbnN0IGlkZW50aWZ5ID0gKGVkaXRvciwgYW5ub3RhdGlvbk5hbWUpID0+IHtcbiAgICAgIGNvbnN0IHJuZyA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICBjb25zdCBzdGFydCA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKHJuZy5zdGFydENvbnRhaW5lcik7XG4gICAgICBjb25zdCByb290ID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZWRpdG9yLmdldEJvZHkoKSk7XG4gICAgICBjb25zdCBzZWxlY3RvciA9IGFubm90YXRpb25OYW1lLmZvbGQoKCkgPT4gJy4nICsgYW5ub3RhdGlvbigpLCBhbiA9PiBgWyR7IGRhdGFBbm5vdGF0aW9uKCkgfT1cIiR7IGFuIH1cIl1gKTtcbiAgICAgIGNvbnN0IG5ld1N0YXJ0ID0gY2hpbGQkMShzdGFydCwgcm5nLnN0YXJ0T2Zmc2V0KS5nZXRPcihzdGFydCk7XG4gICAgICBjb25zdCBjbG9zZXN0ID0gY2xvc2VzdCQzKG5ld1N0YXJ0LCBzZWxlY3RvciwgaXNSb290JDEocm9vdCkpO1xuICAgICAgcmV0dXJuIGNsb3Nlc3QuYmluZChjID0+IGdldE9wdChjLCBgJHsgZGF0YUFubm90YXRpb25JZCgpIH1gKS5iaW5kKHVpZCA9PiBnZXRPcHQoYywgYCR7IGRhdGFBbm5vdGF0aW9uKCkgfWApLm1hcChuYW1lID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBmaW5kTWFya2VycyhlZGl0b3IsIHVpZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdWlkLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgZWxlbWVudHNcbiAgICAgICAgfTtcbiAgICAgIH0pKSk7XG4gICAgfTtcbiAgICBjb25zdCBpc0Fubm90YXRpb24gPSBlbGVtID0+IGlzRWxlbWVudCQ3KGVsZW0pICYmIGhhcyhlbGVtLCBhbm5vdGF0aW9uKCkpO1xuICAgIGNvbnN0IGlzQm9ndXNFbGVtZW50ID0gKGVsZW0sIHJvb3QpID0+IGhhcyQxKGVsZW0sICdkYXRhLW1jZS1ib2d1cycpIHx8IGFuY2VzdG9yJDIoZWxlbSwgJ1tkYXRhLW1jZS1ib2d1cz1cImFsbFwiXScsIGlzUm9vdCQxKHJvb3QpKTtcbiAgICBjb25zdCBmaW5kTWFya2VycyA9IChlZGl0b3IsIHVpZCkgPT4ge1xuICAgICAgY29uc3QgYm9keSA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRCb2R5KCkpO1xuICAgICAgY29uc3QgZGVzY2VuZGFudHMkMSA9IGRlc2NlbmRhbnRzKGJvZHksIGBbJHsgZGF0YUFubm90YXRpb25JZCgpIH09XCIkeyB1aWQgfVwiXWApO1xuICAgICAgcmV0dXJuIGZpbHRlciQ1KGRlc2NlbmRhbnRzJDEsIGRlc2NlbmRhbnQgPT4gIWlzQm9ndXNFbGVtZW50KGRlc2NlbmRhbnQsIGJvZHkpKTtcbiAgICB9O1xuICAgIGNvbnN0IGZpbmRBbGwgPSAoZWRpdG9yLCBuYW1lKSA9PiB7XG4gICAgICBjb25zdCBib2R5ID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZWRpdG9yLmdldEJvZHkoKSk7XG4gICAgICBjb25zdCBtYXJrZXJzID0gZGVzY2VuZGFudHMoYm9keSwgYFskeyBkYXRhQW5ub3RhdGlvbigpIH09XCIkeyBuYW1lIH1cIl1gKTtcbiAgICAgIGNvbnN0IGRpcmVjdG9yeSA9IHt9O1xuICAgICAgZWFjaCRlKG1hcmtlcnMsIG0gPT4ge1xuICAgICAgICBpZiAoIWlzQm9ndXNFbGVtZW50KG0sIGJvZHkpKSB7XG4gICAgICAgICAgY29uc3QgdWlkID0gZ2V0JDkobSwgZGF0YUFubm90YXRpb25JZCgpKTtcbiAgICAgICAgICBjb25zdCBub2Rlc0FscmVhZHkgPSBnZXQkYShkaXJlY3RvcnksIHVpZCkuZ2V0T3IoW10pO1xuICAgICAgICAgIGRpcmVjdG9yeVt1aWRdID0gbm9kZXNBbHJlYWR5LmNvbmNhdChbbV0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkaXJlY3Rvcnk7XG4gICAgfTtcblxuICAgIGNvbnN0IHNldHVwJHggPSAoZWRpdG9yLCByZWdpc3RyeSkgPT4ge1xuICAgICAgY29uc3QgY2hhbmdlQ2FsbGJhY2tzID0gQ2VsbCh7fSk7XG4gICAgICBjb25zdCBpbml0RGF0YSA9ICgpID0+ICh7XG4gICAgICAgIGxpc3RlbmVyczogW10sXG4gICAgICAgIHByZXZpb3VzOiB2YWx1ZSQyKClcbiAgICAgIH0pO1xuICAgICAgY29uc3Qgd2l0aENhbGxiYWNrcyA9IChuYW1lLCBmKSA9PiB7XG4gICAgICAgIHVwZGF0ZUNhbGxiYWNrcyhuYW1lLCBkYXRhID0+IHtcbiAgICAgICAgICBmKGRhdGEpO1xuICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCB1cGRhdGVDYWxsYmFja3MgPSAobmFtZSwgZikgPT4ge1xuICAgICAgICBjb25zdCBjYWxsYmFja01hcCA9IGNoYW5nZUNhbGxiYWNrcy5nZXQoKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGdldCRhKGNhbGxiYWNrTWFwLCBuYW1lKS5nZXRPclRodW5rKGluaXREYXRhKTtcbiAgICAgICAgY29uc3Qgb3V0cHV0RGF0YSA9IGYoZGF0YSk7XG4gICAgICAgIGNhbGxiYWNrTWFwW25hbWVdID0gb3V0cHV0RGF0YTtcbiAgICAgICAgY2hhbmdlQ2FsbGJhY2tzLnNldChjYWxsYmFja01hcCk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZmlyZUNhbGxiYWNrcyA9IChuYW1lLCB1aWQsIGVsZW1lbnRzKSA9PiB7XG4gICAgICAgIHdpdGhDYWxsYmFja3MobmFtZSwgZGF0YSA9PiB7XG4gICAgICAgICAgZWFjaCRlKGRhdGEubGlzdGVuZXJzLCBmID0+IGYodHJ1ZSwgbmFtZSwge1xuICAgICAgICAgICAgdWlkLFxuICAgICAgICAgICAgbm9kZXM6IG1hcCQzKGVsZW1lbnRzLCBlbGVtID0+IGVsZW0uZG9tKVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZmlyZU5vQW5ub3RhdGlvbiA9IG5hbWUgPT4ge1xuICAgICAgICB3aXRoQ2FsbGJhY2tzKG5hbWUsIGRhdGEgPT4ge1xuICAgICAgICAgIGVhY2gkZShkYXRhLmxpc3RlbmVycywgZiA9PiBmKGZhbHNlLCBuYW1lKSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHRvZ2dsZUFjdGl2ZUF0dHIgPSAodWlkLCBzdGF0ZSkgPT4ge1xuICAgICAgICBlYWNoJGUoZmluZE1hcmtlcnMoZWRpdG9yLCB1aWQpLCBlbGVtID0+IHtcbiAgICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAgIHNldCQzKGVsZW0sIGRhdGFBbm5vdGF0aW9uQWN0aXZlKCksICd0cnVlJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbW92ZSRiKGVsZW0sIGRhdGFBbm5vdGF0aW9uQWN0aXZlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgb25Ob2RlQ2hhbmdlID0gbGFzdCQxKCgpID0+IHtcbiAgICAgICAgY29uc3QgYW5ub3RhdGlvbnMgPSBzb3J0KHJlZ2lzdHJ5LmdldE5hbWVzKCkpO1xuICAgICAgICBlYWNoJGUoYW5ub3RhdGlvbnMsIG5hbWUgPT4ge1xuICAgICAgICAgIHVwZGF0ZUNhbGxiYWNrcyhuYW1lLCBkYXRhID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByZXYgPSBkYXRhLnByZXZpb3VzLmdldCgpO1xuICAgICAgICAgICAgaWRlbnRpZnkoZWRpdG9yLCBPcHRpb25hbC5zb21lKG5hbWUpKS5mb2xkKCgpID0+IHtcbiAgICAgICAgICAgICAgcHJldi5lYWNoKHVpZCA9PiB7XG4gICAgICAgICAgICAgICAgZmlyZU5vQW5ub3RhdGlvbihuYW1lKTtcbiAgICAgICAgICAgICAgICBkYXRhLnByZXZpb3VzLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgdG9nZ2xlQWN0aXZlQXR0cih1aWQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCAoe3VpZCwgbmFtZSwgZWxlbWVudHN9KSA9PiB7XG4gICAgICAgICAgICAgIGlmICghaXMkMihwcmV2LCB1aWQpKSB7XG4gICAgICAgICAgICAgICAgcHJldi5lYWNoKHVpZCA9PiB0b2dnbGVBY3RpdmVBdHRyKHVpZCwgZmFsc2UpKTtcbiAgICAgICAgICAgICAgICBmaXJlQ2FsbGJhY2tzKG5hbWUsIHVpZCwgZWxlbWVudHMpO1xuICAgICAgICAgICAgICAgIGRhdGEucHJldmlvdXMuc2V0KHVpZCk7XG4gICAgICAgICAgICAgICAgdG9nZ2xlQWN0aXZlQXR0cih1aWQsIHRydWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHByZXZpb3VzOiBkYXRhLnByZXZpb3VzLFxuICAgICAgICAgICAgICBsaXN0ZW5lcnM6IGRhdGEubGlzdGVuZXJzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0sIDMwKTtcbiAgICAgIGVkaXRvci5vbigncmVtb3ZlJywgKCkgPT4ge1xuICAgICAgICBvbk5vZGVDaGFuZ2UuY2FuY2VsKCk7XG4gICAgICB9KTtcbiAgICAgIGVkaXRvci5vbignTm9kZUNoYW5nZScsICgpID0+IHtcbiAgICAgICAgb25Ob2RlQ2hhbmdlLnRocm90dGxlKCk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGFkZExpc3RlbmVyID0gKG5hbWUsIGYpID0+IHtcbiAgICAgICAgdXBkYXRlQ2FsbGJhY2tzKG5hbWUsIGRhdGEgPT4gKHtcbiAgICAgICAgICBwcmV2aW91czogZGF0YS5wcmV2aW91cyxcbiAgICAgICAgICBsaXN0ZW5lcnM6IGRhdGEubGlzdGVuZXJzLmNvbmNhdChbZl0pXG4gICAgICAgIH0pKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4geyBhZGRMaXN0ZW5lciB9O1xuICAgIH07XG5cbiAgICBjb25zdCBzZXR1cCR3ID0gKGVkaXRvciwgcmVnaXN0cnkpID0+IHtcbiAgICAgIGNvbnN0IGRhdGFBbm5vdGF0aW9uJDEgPSBkYXRhQW5ub3RhdGlvbigpO1xuICAgICAgY29uc3QgaWRlbnRpZnlQYXJzZXJOb2RlID0gbm9kZSA9PiBPcHRpb25hbC5mcm9tKG5vZGUuYXR0cihkYXRhQW5ub3RhdGlvbiQxKSkuYmluZChyZWdpc3RyeS5sb29rdXApO1xuICAgICAgY29uc3QgcmVtb3ZlRGlyZWN0QW5ub3RhdGlvbiA9IG5vZGUgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBub2RlLmF0dHIoZGF0YUFubm90YXRpb25JZCgpLCBudWxsKTtcbiAgICAgICAgbm9kZS5hdHRyKGRhdGFBbm5vdGF0aW9uKCksIG51bGwpO1xuICAgICAgICBub2RlLmF0dHIoZGF0YUFubm90YXRpb25BY3RpdmUoKSwgbnVsbCk7XG4gICAgICAgIGNvbnN0IGN1c3RvbUF0dHJOYW1lcyA9IE9wdGlvbmFsLmZyb20obm9kZS5hdHRyKGRhdGFBbm5vdGF0aW9uQXR0cmlidXRlcygpKSkubWFwKG5hbWVzID0+IG5hbWVzLnNwbGl0KCcsJykpLmdldE9yKFtdKTtcbiAgICAgICAgY29uc3QgY3VzdG9tQ2xhc3NlcyA9IE9wdGlvbmFsLmZyb20obm9kZS5hdHRyKGRhdGFBbm5vdGF0aW9uQ2xhc3NlcygpKSkubWFwKG5hbWVzID0+IG5hbWVzLnNwbGl0KCcsJykpLmdldE9yKFtdKTtcbiAgICAgICAgZWFjaCRlKGN1c3RvbUF0dHJOYW1lcywgbmFtZSA9PiBub2RlLmF0dHIobmFtZSwgbnVsbCkpO1xuICAgICAgICBjb25zdCBjbGFzc0xpc3QgPSAoX2IgPSAoX2EgPSBub2RlLmF0dHIoJ2NsYXNzJykpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zcGxpdCgnICcpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXTtcbiAgICAgICAgY29uc3QgbmV3Q2xhc3NMaXN0ID0gZGlmZmVyZW5jZShjbGFzc0xpc3QsIFthbm5vdGF0aW9uKCldLmNvbmNhdChjdXN0b21DbGFzc2VzKSk7XG4gICAgICAgIG5vZGUuYXR0cignY2xhc3MnLCBuZXdDbGFzc0xpc3QubGVuZ3RoID4gMCA/IG5ld0NsYXNzTGlzdC5qb2luKCcgJykgOiBudWxsKTtcbiAgICAgICAgbm9kZS5hdHRyKGRhdGFBbm5vdGF0aW9uQ2xhc3NlcygpLCBudWxsKTtcbiAgICAgICAgbm9kZS5hdHRyKGRhdGFBbm5vdGF0aW9uQXR0cmlidXRlcygpLCBudWxsKTtcbiAgICAgIH07XG4gICAgICBlZGl0b3Iuc2VyaWFsaXplci5hZGRUZW1wQXR0cihkYXRhQW5ub3RhdGlvbkFjdGl2ZSgpKTtcbiAgICAgIGVkaXRvci5zZXJpYWxpemVyLmFkZEF0dHJpYnV0ZUZpbHRlcihkYXRhQW5ub3RhdGlvbiQxLCBub2RlcyA9PiB7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgICAgICAgIGlkZW50aWZ5UGFyc2VyTm9kZShub2RlKS5lYWNoKHNldHRpbmdzID0+IHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5wZXJzaXN0ZW50ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICBpZiAobm9kZS5uYW1lID09PSAnc3BhbicpIHtcbiAgICAgICAgICAgICAgICBub2RlLnVud3JhcCgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlbW92ZURpcmVjdEFubm90YXRpb24obm9kZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGNyZWF0ZSRjID0gKCkgPT4ge1xuICAgICAgY29uc3QgYW5ub3RhdGlvbnMgPSB7fTtcbiAgICAgIGNvbnN0IHJlZ2lzdGVyID0gKG5hbWUsIHNldHRpbmdzKSA9PiB7XG4gICAgICAgIGFubm90YXRpb25zW25hbWVdID0ge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgc2V0dGluZ3NcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICBjb25zdCBsb29rdXAgPSBuYW1lID0+IGdldCRhKGFubm90YXRpb25zLCBuYW1lKS5tYXAoYSA9PiBhLnNldHRpbmdzKTtcbiAgICAgIGNvbnN0IGdldE5hbWVzID0gKCkgPT4ga2V5cyhhbm5vdGF0aW9ucyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZWdpc3RlcixcbiAgICAgICAgbG9va3VwLFxuICAgICAgICBnZXROYW1lc1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgbGV0IHVuaXF1ZSA9IDA7XG4gICAgY29uc3QgZ2VuZXJhdGUkMSA9IHByZWZpeCA9PiB7XG4gICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoKTtcbiAgICAgIGNvbnN0IHRpbWUgPSBkYXRlLmdldFRpbWUoKTtcbiAgICAgIGNvbnN0IHJhbmRvbSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwMDApO1xuICAgICAgdW5pcXVlKys7XG4gICAgICByZXR1cm4gcHJlZml4ICsgJ18nICsgcmFuZG9tICsgdW5pcXVlICsgU3RyaW5nKHRpbWUpO1xuICAgIH07XG5cbiAgICBjb25zdCBhZGQgPSAoZWxlbWVudCwgY2xhc3NlcykgPT4ge1xuICAgICAgZWFjaCRlKGNsYXNzZXMsIHggPT4ge1xuICAgICAgICBhZGQkMihlbGVtZW50LCB4KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgcmVtb3ZlJDUgPSAoZWxlbWVudCwgY2xhc3NlcykgPT4ge1xuICAgICAgZWFjaCRlKGNsYXNzZXMsIHggPT4ge1xuICAgICAgICByZW1vdmUkOChlbGVtZW50LCB4KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBjbG9uZSQyID0gKG9yaWdpbmFsLCBpc0RlZXApID0+IFN1Z2FyRWxlbWVudC5mcm9tRG9tKG9yaWdpbmFsLmRvbS5jbG9uZU5vZGUoaXNEZWVwKSk7XG4gICAgY29uc3Qgc2hhbGxvdyQxID0gb3JpZ2luYWwgPT4gY2xvbmUkMihvcmlnaW5hbCwgZmFsc2UpO1xuICAgIGNvbnN0IGRlZXAkMSA9IG9yaWdpbmFsID0+IGNsb25lJDIob3JpZ2luYWwsIHRydWUpO1xuICAgIGNvbnN0IHNoYWxsb3dBcyA9IChvcmlnaW5hbCwgdGFnKSA9PiB7XG4gICAgICBjb25zdCBudSA9IFN1Z2FyRWxlbWVudC5mcm9tVGFnKHRhZyk7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gY2xvbmUkNChvcmlnaW5hbCk7XG4gICAgICBzZXRBbGwkMShudSwgYXR0cmlidXRlcyk7XG4gICAgICByZXR1cm4gbnU7XG4gICAgfTtcbiAgICBjb25zdCBtdXRhdGUgPSAob3JpZ2luYWwsIHRhZykgPT4ge1xuICAgICAgY29uc3QgbnUgPSBzaGFsbG93QXMob3JpZ2luYWwsIHRhZyk7XG4gICAgICBhZnRlciQ0KG9yaWdpbmFsLCBudSk7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGNoaWxkcmVuJDEob3JpZ2luYWwpO1xuICAgICAgYXBwZW5kKG51LCBjaGlsZHJlbik7XG4gICAgICByZW1vdmUkNihvcmlnaW5hbCk7XG4gICAgICByZXR1cm4gbnU7XG4gICAgfTtcblxuICAgIGNvbnN0IFRleHRXYWxrZXIgPSAoc3RhcnROb2RlLCByb290Tm9kZSwgaXNCb3VuZGFyeSA9IG5ldmVyKSA9PiB7XG4gICAgICBjb25zdCB3YWxrZXIgPSBuZXcgRG9tVHJlZVdhbGtlcihzdGFydE5vZGUsIHJvb3ROb2RlKTtcbiAgICAgIGNvbnN0IHdhbGsgPSBkaXJlY3Rpb24gPT4ge1xuICAgICAgICBsZXQgbmV4dDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIG5leHQgPSB3YWxrZXJbZGlyZWN0aW9uXSgpO1xuICAgICAgICB9IHdoaWxlIChuZXh0ICYmICFpc1RleHQkYShuZXh0KSAmJiAhaXNCb3VuZGFyeShuZXh0KSk7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5mcm9tKG5leHQpLmZpbHRlcihpc1RleHQkYSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY3VycmVudDogKCkgPT4gT3B0aW9uYWwuZnJvbSh3YWxrZXIuY3VycmVudCgpKS5maWx0ZXIoaXNUZXh0JGEpLFxuICAgICAgICBuZXh0OiAoKSA9PiB3YWxrKCduZXh0JyksXG4gICAgICAgIHByZXY6ICgpID0+IHdhbGsoJ3ByZXYnKSxcbiAgICAgICAgcHJldjI6ICgpID0+IHdhbGsoJ3ByZXYyJylcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IFRleHRTZWVrZXIgPSAoZG9tLCBpc0JvdW5kYXJ5KSA9PiB7XG4gICAgICBjb25zdCBpc0Jsb2NrQm91bmRhcnkgPSBpc0JvdW5kYXJ5ID8gaXNCb3VuZGFyeSA6IG5vZGUgPT4gZG9tLmlzQmxvY2sobm9kZSkgfHwgaXNCciQ2KG5vZGUpIHx8IGlzQ29udGVudEVkaXRhYmxlRmFsc2UkYihub2RlKTtcbiAgICAgIGNvbnN0IHdhbGsgPSAobm9kZSwgb2Zmc2V0LCB3YWxrZXIsIHByb2Nlc3MpID0+IHtcbiAgICAgICAgaWYgKGlzVGV4dCRhKG5vZGUpKSB7XG4gICAgICAgICAgY29uc3QgbmV3T2Zmc2V0ID0gcHJvY2Vzcyhub2RlLCBvZmZzZXQsIG5vZGUuZGF0YSk7XG4gICAgICAgICAgaWYgKG5ld09mZnNldCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKHtcbiAgICAgICAgICAgICAgY29udGFpbmVyOiBub2RlLFxuICAgICAgICAgICAgICBvZmZzZXQ6IG5ld09mZnNldFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3YWxrZXIoKS5iaW5kKG5leHQgPT4gd2FsayhuZXh0LmNvbnRhaW5lciwgbmV4dC5vZmZzZXQsIHdhbGtlciwgcHJvY2VzcykpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGJhY2t3YXJkcyA9IChub2RlLCBvZmZzZXQsIHByb2Nlc3MsIHJvb3QpID0+IHtcbiAgICAgICAgY29uc3Qgd2Fsa2VyID0gVGV4dFdhbGtlcihub2RlLCByb290ICE9PSBudWxsICYmIHJvb3QgIT09IHZvaWQgMCA/IHJvb3QgOiBkb20uZ2V0Um9vdCgpLCBpc0Jsb2NrQm91bmRhcnkpO1xuICAgICAgICByZXR1cm4gd2Fsayhub2RlLCBvZmZzZXQsICgpID0+IHdhbGtlci5wcmV2KCkubWFwKHByZXYgPT4gKHtcbiAgICAgICAgICBjb250YWluZXI6IHByZXYsXG4gICAgICAgICAgb2Zmc2V0OiBwcmV2Lmxlbmd0aFxuICAgICAgICB9KSksIHByb2Nlc3MpLmdldE9yTnVsbCgpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGZvcndhcmRzID0gKG5vZGUsIG9mZnNldCwgcHJvY2Vzcywgcm9vdCkgPT4ge1xuICAgICAgICBjb25zdCB3YWxrZXIgPSBUZXh0V2Fsa2VyKG5vZGUsIHJvb3QgIT09IG51bGwgJiYgcm9vdCAhPT0gdm9pZCAwID8gcm9vdCA6IGRvbS5nZXRSb290KCksIGlzQmxvY2tCb3VuZGFyeSk7XG4gICAgICAgIHJldHVybiB3YWxrKG5vZGUsIG9mZnNldCwgKCkgPT4gd2Fsa2VyLm5leHQoKS5tYXAobmV4dCA9PiAoe1xuICAgICAgICAgIGNvbnRhaW5lcjogbmV4dCxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfSkpLCBwcm9jZXNzKS5nZXRPck51bGwoKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiYWNrd2FyZHMsXG4gICAgICAgIGZvcndhcmRzXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCByb3VuZCQyID0gTWF0aC5yb3VuZDtcbiAgICBjb25zdCBjbG9uZSQxID0gcmVjdCA9PiB7XG4gICAgICBpZiAoIXJlY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICBib3R0b206IDAsXG4gICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiByb3VuZCQyKHJlY3QubGVmdCksXG4gICAgICAgIHRvcDogcm91bmQkMihyZWN0LnRvcCksXG4gICAgICAgIGJvdHRvbTogcm91bmQkMihyZWN0LmJvdHRvbSksXG4gICAgICAgIHJpZ2h0OiByb3VuZCQyKHJlY3QucmlnaHQpLFxuICAgICAgICB3aWR0aDogcm91bmQkMihyZWN0LndpZHRoKSxcbiAgICAgICAgaGVpZ2h0OiByb3VuZCQyKHJlY3QuaGVpZ2h0KVxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGNvbGxhcHNlID0gKHJlY3QsIHRvU3RhcnQpID0+IHtcbiAgICAgIHJlY3QgPSBjbG9uZSQxKHJlY3QpO1xuICAgICAgaWYgKHRvU3RhcnQpIHtcbiAgICAgICAgcmVjdC5yaWdodCA9IHJlY3QubGVmdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlY3QubGVmdCA9IHJlY3QubGVmdCArIHJlY3Qud2lkdGg7XG4gICAgICAgIHJlY3QucmlnaHQgPSByZWN0LmxlZnQ7XG4gICAgICB9XG4gICAgICByZWN0LndpZHRoID0gMDtcbiAgICAgIHJldHVybiByZWN0O1xuICAgIH07XG4gICAgY29uc3QgaXNFcXVhbCA9IChyZWN0MSwgcmVjdDIpID0+IHJlY3QxLmxlZnQgPT09IHJlY3QyLmxlZnQgJiYgcmVjdDEudG9wID09PSByZWN0Mi50b3AgJiYgcmVjdDEuYm90dG9tID09PSByZWN0Mi5ib3R0b20gJiYgcmVjdDEucmlnaHQgPT09IHJlY3QyLnJpZ2h0O1xuICAgIGNvbnN0IGlzVmFsaWRPdmVyZmxvdyA9IChvdmVyZmxvd1ksIHJlY3QxLCByZWN0MikgPT4gb3ZlcmZsb3dZID49IDAgJiYgb3ZlcmZsb3dZIDw9IE1hdGgubWluKHJlY3QxLmhlaWdodCwgcmVjdDIuaGVpZ2h0KSAvIDI7XG4gICAgY29uc3QgaXNBYm92ZSQxID0gKHJlY3QxLCByZWN0MikgPT4ge1xuICAgICAgY29uc3QgaGFsZkhlaWdodCA9IE1hdGgubWluKHJlY3QyLmhlaWdodCAvIDIsIHJlY3QxLmhlaWdodCAvIDIpO1xuICAgICAgaWYgKHJlY3QxLmJvdHRvbSAtIGhhbGZIZWlnaHQgPCByZWN0Mi50b3ApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocmVjdDEudG9wID4gcmVjdDIuYm90dG9tKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc1ZhbGlkT3ZlcmZsb3cocmVjdDIudG9wIC0gcmVjdDEuYm90dG9tLCByZWN0MSwgcmVjdDIpO1xuICAgIH07XG4gICAgY29uc3QgaXNCZWxvdyQxID0gKHJlY3QxLCByZWN0MikgPT4ge1xuICAgICAgaWYgKHJlY3QxLnRvcCA+IHJlY3QyLmJvdHRvbSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWN0MS5ib3R0b20gPCByZWN0Mi50b3ApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzVmFsaWRPdmVyZmxvdyhyZWN0Mi5ib3R0b20gLSByZWN0MS50b3AsIHJlY3QxLCByZWN0Mik7XG4gICAgfTtcbiAgICBjb25zdCBjb250YWluc1hZID0gKHJlY3QsIGNsaWVudFgsIGNsaWVudFkpID0+IGNsaWVudFggPj0gcmVjdC5sZWZ0ICYmIGNsaWVudFggPD0gcmVjdC5yaWdodCAmJiBjbGllbnRZID49IHJlY3QudG9wICYmIGNsaWVudFkgPD0gcmVjdC5ib3R0b207XG4gICAgY29uc3QgYm91bmRpbmdDbGllbnRSZWN0RnJvbVJlY3RzID0gcmVjdHMgPT4ge1xuICAgICAgcmV0dXJuIGZvbGRsKHJlY3RzLCAoYWNjLCByZWN0KSA9PiB7XG4gICAgICAgIHJldHVybiBhY2MuZm9sZCgoKSA9PiBPcHRpb25hbC5zb21lKHJlY3QpLCBwcmV2UmVjdCA9PiB7XG4gICAgICAgICAgY29uc3QgbGVmdCA9IE1hdGgubWluKHJlY3QubGVmdCwgcHJldlJlY3QubGVmdCk7XG4gICAgICAgICAgY29uc3QgdG9wID0gTWF0aC5taW4ocmVjdC50b3AsIHByZXZSZWN0LnRvcCk7XG4gICAgICAgICAgY29uc3QgcmlnaHQgPSBNYXRoLm1heChyZWN0LnJpZ2h0LCBwcmV2UmVjdC5yaWdodCk7XG4gICAgICAgICAgY29uc3QgYm90dG9tID0gTWF0aC5tYXgocmVjdC5ib3R0b20sIHByZXZSZWN0LmJvdHRvbSk7XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoe1xuICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICBib3R0b20sXG4gICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgd2lkdGg6IHJpZ2h0IC0gbGVmdCxcbiAgICAgICAgICAgIGhlaWdodDogYm90dG9tIC0gdG9wXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSwgT3B0aW9uYWwubm9uZSgpKTtcbiAgICB9O1xuICAgIGNvbnN0IGRpc3RhbmNlVG9SZWN0RWRnZUZyb21YWSA9IChyZWN0LCB4LCB5KSA9PiB7XG4gICAgICBjb25zdCBjeCA9IE1hdGgubWF4KE1hdGgubWluKHgsIHJlY3QubGVmdCArIHJlY3Qud2lkdGgpLCByZWN0LmxlZnQpO1xuICAgICAgY29uc3QgY3kgPSBNYXRoLm1heChNYXRoLm1pbih5LCByZWN0LnRvcCArIHJlY3QuaGVpZ2h0KSwgcmVjdC50b3ApO1xuICAgICAgcmV0dXJuIE1hdGguc3FydCgoeCAtIGN4KSAqICh4IC0gY3gpICsgKHkgLSBjeSkgKiAoeSAtIGN5KSk7XG4gICAgfTtcbiAgICBjb25zdCBvdmVybGFwWSA9IChyMSwgcjIpID0+IE1hdGgubWF4KDAsIE1hdGgubWluKHIxLmJvdHRvbSwgcjIuYm90dG9tKSAtIE1hdGgubWF4KHIxLnRvcCwgcjIudG9wKSk7XG5cbiAgICBjb25zdCBjbGFtcCQyID0gKHZhbHVlLCBtaW4sIG1heCkgPT4gTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIG1pbiksIG1heCk7XG5cbiAgICBjb25zdCBnZXRTZWxlY3RlZE5vZGUgPSByYW5nZSA9PiB7XG4gICAgICBjb25zdCBzdGFydENvbnRhaW5lciA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyLCBzdGFydE9mZnNldCA9IHJhbmdlLnN0YXJ0T2Zmc2V0O1xuICAgICAgaWYgKHN0YXJ0Q29udGFpbmVyID09PSByYW5nZS5lbmRDb250YWluZXIgJiYgc3RhcnRDb250YWluZXIuaGFzQ2hpbGROb2RlcygpICYmIHJhbmdlLmVuZE9mZnNldCA9PT0gc3RhcnRPZmZzZXQgKyAxKSB7XG4gICAgICAgIHJldHVybiBzdGFydENvbnRhaW5lci5jaGlsZE5vZGVzW3N0YXJ0T2Zmc2V0XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgY29uc3QgZ2V0Tm9kZSQxID0gKGNvbnRhaW5lciwgb2Zmc2V0KSA9PiB7XG4gICAgICBpZiAoaXNFbGVtZW50JDYoY29udGFpbmVyKSAmJiBjb250YWluZXIuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBjb250YWluZXIuY2hpbGROb2RlcztcbiAgICAgICAgY29uc3Qgc2FmZU9mZnNldCA9IGNsYW1wJDIob2Zmc2V0LCAwLCBjaGlsZE5vZGVzLmxlbmd0aCAtIDEpO1xuICAgICAgICByZXR1cm4gY2hpbGROb2Rlc1tzYWZlT2Zmc2V0XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBnZXROb2RlVW5zYWZlID0gKGNvbnRhaW5lciwgb2Zmc2V0KSA9PiB7XG4gICAgICBpZiAob2Zmc2V0IDwgMCAmJiBpc0VsZW1lbnQkNihjb250YWluZXIpICYmIGNvbnRhaW5lci5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBnZXROb2RlJDEoY29udGFpbmVyLCBvZmZzZXQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBleHRlbmRpbmdDaGFycyA9IG5ldyBSZWdFeHAoJ1tcXHUwMzAwLVxcdTAzNmZcXHUwNDgzLVxcdTA0ODdcXHUwNDg4LVxcdTA0ODlcXHUwNTkxLVxcdTA1YmRcXHUwNWJmXFx1MDVjMS1cXHUwNWMyXFx1MDVjNC1cXHUwNWM1XFx1MDVjN1xcdTA2MTAtXFx1MDYxYScgKyAnXFx1MDY0Yi1cXHUwNjVmXFx1MDY3MFxcdTA2ZDYtXFx1MDZkY1xcdTA2ZGYtXFx1MDZlNFxcdTA2ZTctXFx1MDZlOFxcdTA2ZWEtXFx1MDZlZFxcdTA3MTFcXHUwNzMwLVxcdTA3NGFcXHUwN2E2LVxcdTA3YjAnICsgJ1xcdTA3ZWItXFx1MDdmM1xcdTA4MTYtXFx1MDgxOVxcdTA4MWItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyZFxcdTA4NTktXFx1MDg1YlxcdTA4ZTMtXFx1MDkwMlxcdTA5M2FcXHUwOTNjJyArICdcXHUwOTQxLVxcdTA5NDhcXHUwOTRkXFx1MDk1MS1cXHUwOTU3XFx1MDk2Mi1cXHUwOTYzXFx1MDk4MVxcdTA5YmNcXHUwOWJlXFx1MDljMS1cXHUwOWM0XFx1MDljZFxcdTA5ZDdcXHUwOWUyLVxcdTA5ZTMnICsgJ1xcdTBhMDEtXFx1MGEwMlxcdTBhM2NcXHUwYTQxLVxcdTBhNDJcXHUwYTQ3LVxcdTBhNDhcXHUwYTRiLVxcdTBhNGRcXHUwYTUxXFx1MGE3MC1cXHUwYTcxXFx1MGE3NVxcdTBhODEtXFx1MGE4MlxcdTBhYmMnICsgJ1xcdTBhYzEtXFx1MGFjNVxcdTBhYzctXFx1MGFjOFxcdTBhY2RcXHUwYWUyLVxcdTBhZTNcXHUwYjAxXFx1MGIzY1xcdTBiM2VcXHUwYjNmXFx1MGI0MS1cXHUwYjQ0XFx1MGI0ZFxcdTBiNTZcXHUwYjU3JyArICdcXHUwYjYyLVxcdTBiNjNcXHUwYjgyXFx1MGJiZVxcdTBiYzBcXHUwYmNkXFx1MGJkN1xcdTBjMDBcXHUwYzNlLVxcdTBjNDBcXHUwYzQ2LVxcdTBjNDhcXHUwYzRhLVxcdTBjNGRcXHUwYzU1LVxcdTBjNTYnICsgJ1xcdTBjNjItXFx1MGM2M1xcdTBjODFcXHUwY2JjXFx1MGNiZlxcdTBjYzJcXHUwY2M2XFx1MGNjYy1cXHUwY2NkXFx1MGNkNS1cXHUwY2Q2XFx1MGNlMi1cXHUwY2UzXFx1MGQwMVxcdTBkM2VcXHUwZDQxLVxcdTBkNDQnICsgJ1xcdTBkNGRcXHUwZDU3XFx1MGQ2Mi1cXHUwZDYzXFx1MGRjYVxcdTBkY2ZcXHUwZGQyLVxcdTBkZDRcXHUwZGQ2XFx1MGRkZlxcdTBlMzFcXHUwZTM0LVxcdTBlM2FcXHUwZTQ3LVxcdTBlNGVcXHUwZWIxXFx1MGViNC1cXHUwZWI5JyArICdcXHUwZWJiLVxcdTBlYmNcXHUwZWM4LVxcdTBlY2RcXHUwZjE4LVxcdTBmMTlcXHUwZjM1XFx1MGYzN1xcdTBmMzlcXHUwZjcxLVxcdTBmN2VcXHUwZjgwLVxcdTBmODRcXHUwZjg2LVxcdTBmODdcXHUwZjhkLVxcdTBmOTcnICsgJ1xcdTBmOTktXFx1MGZiY1xcdTBmYzZcXHUxMDJkLVxcdTEwMzBcXHUxMDMyLVxcdTEwMzdcXHUxMDM5LVxcdTEwM2FcXHUxMDNkLVxcdTEwM2VcXHUxMDU4LVxcdTEwNTlcXHUxMDVlLVxcdTEwNjBcXHUxMDcxLVxcdTEwNzQnICsgJ1xcdTEwODJcXHUxMDg1LVxcdTEwODZcXHUxMDhkXFx1MTA5ZFxcdTEzNWQtXFx1MTM1ZlxcdTE3MTItXFx1MTcxNFxcdTE3MzItXFx1MTczNFxcdTE3NTItXFx1MTc1M1xcdTE3NzItXFx1MTc3M1xcdTE3YjQtXFx1MTdiNScgKyAnXFx1MTdiNy1cXHUxN2JkXFx1MTdjNlxcdTE3YzktXFx1MTdkM1xcdTE3ZGRcXHUxODBiLVxcdTE4MGRcXHUxOGE5XFx1MTkyMC1cXHUxOTIyXFx1MTkyNy1cXHUxOTI4XFx1MTkzMlxcdTE5MzktXFx1MTkzYlxcdTFhMTctXFx1MWExOCcgKyAnXFx1MWExYlxcdTFhNTZcXHUxYTU4LVxcdTFhNWVcXHUxYTYwXFx1MWE2MlxcdTFhNjUtXFx1MWE2Y1xcdTFhNzMtXFx1MWE3Y1xcdTFhN2ZcXHUxYWIwLVxcdTFhYmRcXHUxQUJFXFx1MWIwMC1cXHUxYjAzXFx1MWIzNCcgKyAnXFx1MWIzNi1cXHUxYjNhXFx1MWIzY1xcdTFiNDJcXHUxYjZiLVxcdTFiNzNcXHUxYjgwLVxcdTFiODFcXHUxYmEyLVxcdTFiYTVcXHUxYmE4LVxcdTFiYTlcXHUxYmFiLVxcdTFiYWRcXHUxYmU2XFx1MWJlOC1cXHUxYmU5JyArICdcXHUxYmVkXFx1MWJlZi1cXHUxYmYxXFx1MWMyYy1cXHUxYzMzXFx1MWMzNi1cXHUxYzM3XFx1MWNkMC1cXHUxY2QyXFx1MWNkNC1cXHUxY2UwXFx1MWNlMi1cXHUxY2U4XFx1MWNlZFxcdTFjZjRcXHUxY2Y4LVxcdTFjZjknICsgJ1xcdTFkYzAtXFx1MWRmNVxcdTFkZmMtXFx1MWRmZlxcdTIwMGMtXFx1MjAwZFxcdTIwZDAtXFx1MjBkY1xcdTIwREQtXFx1MjBFMFxcdTIwZTFcXHUyMEUyLVxcdTIwRTRcXHUyMGU1LVxcdTIwZjBcXHUyY2VmLVxcdTJjZjEnICsgJ1xcdTJkN2ZcXHUyZGUwLVxcdTJkZmZcXHUzMDJhLVxcdTMwMmRcXHUzMDJlLVxcdTMwMmZcXHUzMDk5LVxcdTMwOWFcXHVhNjZmXFx1QTY3MC1cXHVBNjcyXFx1YTY3NC1cXHVhNjdkXFx1YTY5ZS1cXHVhNjlmXFx1YTZmMC1cXHVhNmYxJyArICdcXHVhODAyXFx1YTgwNlxcdWE4MGJcXHVhODI1LVxcdWE4MjZcXHVhOGM0XFx1YThlMC1cXHVhOGYxXFx1YTkyNi1cXHVhOTJkXFx1YTk0Ny1cXHVhOTUxXFx1YTk4MC1cXHVhOTgyXFx1YTliM1xcdWE5YjYtXFx1YTliOVxcdWE5YmMnICsgJ1xcdWE5ZTVcXHVhYTI5LVxcdWFhMmVcXHVhYTMxLVxcdWFhMzJcXHVhYTM1LVxcdWFhMzZcXHVhYTQzXFx1YWE0Y1xcdWFhN2NcXHVhYWIwXFx1YWFiMi1cXHVhYWI0XFx1YWFiNy1cXHVhYWI4XFx1YWFiZS1cXHVhYWJmXFx1YWFjMScgKyAnXFx1YWFlYy1cXHVhYWVkXFx1YWFmNlxcdWFiZTVcXHVhYmU4XFx1YWJlZFxcdWZiMWVcXHVmZTAwLVxcdWZlMGZcXHVmZTIwLVxcdWZlMmZcXHVmZjllLVxcdWZmOWZdJyk7XG4gICAgY29uc3QgaXNFeHRlbmRpbmdDaGFyID0gY2ggPT4gaXNTdHJpbmcoY2gpICYmIGNoLmNoYXJDb2RlQXQoMCkgPj0gNzY4ICYmIGV4dGVuZGluZ0NoYXJzLnRlc3QoY2gpO1xuXG4gICAgY29uc3Qgb3IgPSAoLi4uYXJncykgPT4ge1xuICAgICAgcmV0dXJuIHggPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoYXJnc1tpXSh4KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBhbmQgPSAoLi4uYXJncykgPT4ge1xuICAgICAgcmV0dXJuIHggPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoIWFyZ3NbaV0oeCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBpc0VsZW1lbnQkNCA9IGlzRWxlbWVudCQ2O1xuICAgIGNvbnN0IGlzQ2FyZXRDYW5kaWRhdGUkMiA9IGlzQ2FyZXRDYW5kaWRhdGUkMztcbiAgICBjb25zdCBpc0Jsb2NrJDEgPSBtYXRjaFN0eWxlVmFsdWVzKCdkaXNwbGF5JywgJ2Jsb2NrIHRhYmxlJyk7XG4gICAgY29uc3QgaXNGbG9hdGVkID0gbWF0Y2hTdHlsZVZhbHVlcygnZmxvYXQnLCAnbGVmdCByaWdodCcpO1xuICAgIGNvbnN0IGlzVmFsaWRFbGVtZW50Q2FyZXRDYW5kaWRhdGUgPSBhbmQoaXNFbGVtZW50JDQsIGlzQ2FyZXRDYW5kaWRhdGUkMiwgbm90KGlzRmxvYXRlZCkpO1xuICAgIGNvbnN0IGlzTm90UHJlID0gbm90KG1hdGNoU3R5bGVWYWx1ZXMoJ3doaXRlLXNwYWNlJywgJ3ByZSBwcmUtbGluZSBwcmUtd3JhcCcpKTtcbiAgICBjb25zdCBpc1RleHQkNyA9IGlzVGV4dCRhO1xuICAgIGNvbnN0IGlzQnIkMyA9IGlzQnIkNjtcbiAgICBjb25zdCBub2RlSW5kZXgkMSA9IERPTVV0aWxzLm5vZGVJbmRleDtcbiAgICBjb25zdCByZXNvbHZlSW5kZXgkMSA9IGdldE5vZGVVbnNhZmU7XG4gICAgY29uc3QgY3JlYXRlUmFuZ2UkMSA9IGRvYyA9PiBkb2MgPyBkb2MuY3JlYXRlUmFuZ2UoKSA6IERPTVV0aWxzLkRPTS5jcmVhdGVSbmcoKTtcbiAgICBjb25zdCBpc1doaXRlU3BhY2UkMSA9IGNociA9PiBpc1N0cmluZyhjaHIpICYmIC9bXFxyXFxuXFx0IF0vLnRlc3QoY2hyKTtcbiAgICBjb25zdCBpc1JhbmdlID0gcm5nID0+ICEhcm5nLnNldFN0YXJ0ICYmICEhcm5nLnNldEVuZDtcbiAgICBjb25zdCBpc0hpZGRlbldoaXRlU3BhY2VSYW5nZSA9IHJhbmdlID0+IHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gcmFuZ2Uuc3RhcnRPZmZzZXQ7XG4gICAgICBpZiAoaXNXaGl0ZVNwYWNlJDEocmFuZ2UudG9TdHJpbmcoKSkgJiYgaXNOb3RQcmUoY29udGFpbmVyLnBhcmVudE5vZGUpICYmIGlzVGV4dCRhKGNvbnRhaW5lcikpIHtcbiAgICAgICAgY29uc3QgdGV4dCA9IGNvbnRhaW5lci5kYXRhO1xuICAgICAgICBpZiAoaXNXaGl0ZVNwYWNlJDEodGV4dFtvZmZzZXQgLSAxXSkgfHwgaXNXaGl0ZVNwYWNlJDEodGV4dFtvZmZzZXQgKyAxXSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgY29uc3QgZ2V0QnJDbGllbnRSZWN0ID0gYnJOb2RlID0+IHtcbiAgICAgIGNvbnN0IGRvYyA9IGJyTm9kZS5vd25lckRvY3VtZW50O1xuICAgICAgY29uc3Qgcm5nID0gY3JlYXRlUmFuZ2UkMShkb2MpO1xuICAgICAgY29uc3QgbmJzcCQxID0gZG9jLmNyZWF0ZVRleHROb2RlKG5ic3ApO1xuICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IGJyTm9kZS5wYXJlbnROb2RlO1xuICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmJzcCQxLCBick5vZGUpO1xuICAgICAgcm5nLnNldFN0YXJ0KG5ic3AkMSwgMCk7XG4gICAgICBybmcuc2V0RW5kKG5ic3AkMSwgMSk7XG4gICAgICBjb25zdCBjbGllbnRSZWN0ID0gY2xvbmUkMShybmcuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xuICAgICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChuYnNwJDEpO1xuICAgICAgcmV0dXJuIGNsaWVudFJlY3Q7XG4gICAgfTtcbiAgICBjb25zdCBnZXRCb3VuZGluZ0NsaWVudFJlY3RXZWJLaXRUZXh0ID0gcm5nID0+IHtcbiAgICAgIGNvbnN0IHNjID0gcm5nLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgY29uc3QgZWMgPSBybmcuZW5kQ29udGFpbmVyO1xuICAgICAgY29uc3Qgc28gPSBybmcuc3RhcnRPZmZzZXQ7XG4gICAgICBjb25zdCBlbyA9IHJuZy5lbmRPZmZzZXQ7XG4gICAgICBpZiAoc2MgPT09IGVjICYmIGlzVGV4dCRhKGVjKSAmJiBzbyA9PT0gMCAmJiBlbyA9PT0gMSkge1xuICAgICAgICBjb25zdCBuZXdSbmcgPSBybmcuY2xvbmVSYW5nZSgpO1xuICAgICAgICBuZXdSbmcuc2V0RW5kQWZ0ZXIoZWMpO1xuICAgICAgICByZXR1cm4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0JDEobmV3Um5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaXNaZXJvUmVjdCA9IHIgPT4gci5sZWZ0ID09PSAwICYmIHIucmlnaHQgPT09IDAgJiYgci50b3AgPT09IDAgJiYgci5ib3R0b20gPT09IDA7XG4gICAgY29uc3QgZ2V0Qm91bmRpbmdDbGllbnRSZWN0JDEgPSBpdGVtID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGxldCBjbGllbnRSZWN0O1xuICAgICAgY29uc3QgY2xpZW50UmVjdHMgPSBpdGVtLmdldENsaWVudFJlY3RzKCk7XG4gICAgICBpZiAoY2xpZW50UmVjdHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjbGllbnRSZWN0ID0gY2xvbmUkMShjbGllbnRSZWN0c1swXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbGllbnRSZWN0ID0gY2xvbmUkMShpdGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNSYW5nZShpdGVtKSAmJiBpc0JyJDMoaXRlbSkgJiYgaXNaZXJvUmVjdChjbGllbnRSZWN0KSkge1xuICAgICAgICByZXR1cm4gZ2V0QnJDbGllbnRSZWN0KGl0ZW0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzWmVyb1JlY3QoY2xpZW50UmVjdCkgJiYgaXNSYW5nZShpdGVtKSkge1xuICAgICAgICByZXR1cm4gKF9hID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0V2ViS2l0VGV4dChpdGVtKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50UmVjdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjbGllbnRSZWN0O1xuICAgIH07XG4gICAgY29uc3QgY29sbGFwc2VBbmRJbmZsYXRlV2lkdGggPSAoY2xpZW50UmVjdCwgdG9TdGFydCkgPT4ge1xuICAgICAgY29uc3QgbmV3Q2xpZW50UmVjdCA9IGNvbGxhcHNlKGNsaWVudFJlY3QsIHRvU3RhcnQpO1xuICAgICAgbmV3Q2xpZW50UmVjdC53aWR0aCA9IDE7XG4gICAgICBuZXdDbGllbnRSZWN0LnJpZ2h0ID0gbmV3Q2xpZW50UmVjdC5sZWZ0ICsgMTtcbiAgICAgIHJldHVybiBuZXdDbGllbnRSZWN0O1xuICAgIH07XG4gICAgY29uc3QgZ2V0Q2FyZXRQb3NpdGlvbkNsaWVudFJlY3RzID0gY2FyZXRQb3NpdGlvbiA9PiB7XG4gICAgICBjb25zdCBjbGllbnRSZWN0cyA9IFtdO1xuICAgICAgY29uc3QgYWRkVW5pcXVlQW5kVmFsaWRSZWN0ID0gY2xpZW50UmVjdCA9PiB7XG4gICAgICAgIGlmIChjbGllbnRSZWN0LmhlaWdodCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xpZW50UmVjdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGlmIChpc0VxdWFsKGNsaWVudFJlY3QsIGNsaWVudFJlY3RzW2NsaWVudFJlY3RzLmxlbmd0aCAtIDFdKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjbGllbnRSZWN0cy5wdXNoKGNsaWVudFJlY3QpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGFkZENoYXJhY3Rlck9mZnNldCA9IChjb250YWluZXIsIG9mZnNldCkgPT4ge1xuICAgICAgICBjb25zdCByYW5nZSA9IGNyZWF0ZVJhbmdlJDEoY29udGFpbmVyLm93bmVyRG9jdW1lbnQpO1xuICAgICAgICBpZiAob2Zmc2V0IDwgY29udGFpbmVyLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGlzRXh0ZW5kaW5nQ2hhcihjb250YWluZXIuZGF0YVtvZmZzZXRdKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNFeHRlbmRpbmdDaGFyKGNvbnRhaW5lci5kYXRhW29mZnNldCAtIDFdKSkge1xuICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoY29udGFpbmVyLCBvZmZzZXQpO1xuICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKGNvbnRhaW5lciwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICBpZiAoIWlzSGlkZGVuV2hpdGVTcGFjZVJhbmdlKHJhbmdlKSkge1xuICAgICAgICAgICAgICBhZGRVbmlxdWVBbmRWYWxpZFJlY3QoY29sbGFwc2VBbmRJbmZsYXRlV2lkdGgoZ2V0Qm91bmRpbmdDbGllbnRSZWN0JDEocmFuZ2UpLCBmYWxzZSkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXQgPiAwKSB7XG4gICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoY29udGFpbmVyLCBvZmZzZXQgLSAxKTtcbiAgICAgICAgICByYW5nZS5zZXRFbmQoY29udGFpbmVyLCBvZmZzZXQpO1xuICAgICAgICAgIGlmICghaXNIaWRkZW5XaGl0ZVNwYWNlUmFuZ2UocmFuZ2UpKSB7XG4gICAgICAgICAgICBhZGRVbmlxdWVBbmRWYWxpZFJlY3QoY29sbGFwc2VBbmRJbmZsYXRlV2lkdGgoZ2V0Qm91bmRpbmdDbGllbnRSZWN0JDEocmFuZ2UpLCBmYWxzZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob2Zmc2V0IDwgY29udGFpbmVyLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoY29udGFpbmVyLCBvZmZzZXQpO1xuICAgICAgICAgIHJhbmdlLnNldEVuZChjb250YWluZXIsIG9mZnNldCArIDEpO1xuICAgICAgICAgIGlmICghaXNIaWRkZW5XaGl0ZVNwYWNlUmFuZ2UocmFuZ2UpKSB7XG4gICAgICAgICAgICBhZGRVbmlxdWVBbmRWYWxpZFJlY3QoY29sbGFwc2VBbmRJbmZsYXRlV2lkdGgoZ2V0Qm91bmRpbmdDbGllbnRSZWN0JDEocmFuZ2UpLCB0cnVlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgY29udGFpbmVyID0gY2FyZXRQb3NpdGlvbi5jb250YWluZXIoKTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IGNhcmV0UG9zaXRpb24ub2Zmc2V0KCk7XG4gICAgICBpZiAoaXNUZXh0JDcoY29udGFpbmVyKSkge1xuICAgICAgICBhZGRDaGFyYWN0ZXJPZmZzZXQoY29udGFpbmVyLCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gY2xpZW50UmVjdHM7XG4gICAgICB9XG4gICAgICBpZiAoaXNFbGVtZW50JDQoY29udGFpbmVyKSkge1xuICAgICAgICBpZiAoY2FyZXRQb3NpdGlvbi5pc0F0RW5kKCkpIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gcmVzb2x2ZUluZGV4JDEoY29udGFpbmVyLCBvZmZzZXQpO1xuICAgICAgICAgIGlmIChpc1RleHQkNyhub2RlKSkge1xuICAgICAgICAgICAgYWRkQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIG5vZGUuZGF0YS5sZW5ndGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnRDYXJldENhbmRpZGF0ZShub2RlKSAmJiAhaXNCciQzKG5vZGUpKSB7XG4gICAgICAgICAgICBhZGRVbmlxdWVBbmRWYWxpZFJlY3QoY29sbGFwc2VBbmRJbmZsYXRlV2lkdGgoZ2V0Qm91bmRpbmdDbGllbnRSZWN0JDEobm9kZSksIGZhbHNlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSByZXNvbHZlSW5kZXgkMShjb250YWluZXIsIG9mZnNldCk7XG4gICAgICAgICAgaWYgKGlzVGV4dCQ3KG5vZGUpKSB7XG4gICAgICAgICAgICBhZGRDaGFyYWN0ZXJPZmZzZXQobm9kZSwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudENhcmV0Q2FuZGlkYXRlKG5vZGUpICYmIGNhcmV0UG9zaXRpb24uaXNBdEVuZCgpKSB7XG4gICAgICAgICAgICBhZGRVbmlxdWVBbmRWYWxpZFJlY3QoY29sbGFwc2VBbmRJbmZsYXRlV2lkdGgoZ2V0Qm91bmRpbmdDbGllbnRSZWN0JDEobm9kZSksIGZhbHNlKSk7XG4gICAgICAgICAgICByZXR1cm4gY2xpZW50UmVjdHM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGJlZm9yZU5vZGUgPSByZXNvbHZlSW5kZXgkMShjYXJldFBvc2l0aW9uLmNvbnRhaW5lcigpLCBjYXJldFBvc2l0aW9uLm9mZnNldCgpIC0gMSk7XG4gICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50Q2FyZXRDYW5kaWRhdGUoYmVmb3JlTm9kZSkgJiYgIWlzQnIkMyhiZWZvcmVOb2RlKSkge1xuICAgICAgICAgICAgaWYgKGlzQmxvY2skMShiZWZvcmVOb2RlKSB8fCBpc0Jsb2NrJDEobm9kZSkgfHwgIWlzVmFsaWRFbGVtZW50Q2FyZXRDYW5kaWRhdGUobm9kZSkpIHtcbiAgICAgICAgICAgICAgYWRkVW5pcXVlQW5kVmFsaWRSZWN0KGNvbGxhcHNlQW5kSW5mbGF0ZVdpZHRoKGdldEJvdW5kaW5nQ2xpZW50UmVjdCQxKGJlZm9yZU5vZGUpLCBmYWxzZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnRDYXJldENhbmRpZGF0ZShub2RlKSkge1xuICAgICAgICAgICAgYWRkVW5pcXVlQW5kVmFsaWRSZWN0KGNvbGxhcHNlQW5kSW5mbGF0ZVdpZHRoKGdldEJvdW5kaW5nQ2xpZW50UmVjdCQxKG5vZGUpLCB0cnVlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY2xpZW50UmVjdHM7XG4gICAgfTtcbiAgICBjb25zdCBDYXJldFBvc2l0aW9uID0gKGNvbnRhaW5lciwgb2Zmc2V0LCBjbGllbnRSZWN0cykgPT4ge1xuICAgICAgY29uc3QgaXNBdFN0YXJ0ID0gKCkgPT4ge1xuICAgICAgICBpZiAoaXNUZXh0JDcoY29udGFpbmVyKSkge1xuICAgICAgICAgIHJldHVybiBvZmZzZXQgPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9mZnNldCA9PT0gMDtcbiAgICAgIH07XG4gICAgICBjb25zdCBpc0F0RW5kID0gKCkgPT4ge1xuICAgICAgICBpZiAoaXNUZXh0JDcoY29udGFpbmVyKSkge1xuICAgICAgICAgIHJldHVybiBvZmZzZXQgPj0gY29udGFpbmVyLmRhdGEubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvZmZzZXQgPj0gY29udGFpbmVyLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHRvUmFuZ2UgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gY3JlYXRlUmFuZ2UkMShjb250YWluZXIub3duZXJEb2N1bWVudCk7XG4gICAgICAgIHJhbmdlLnNldFN0YXJ0KGNvbnRhaW5lciwgb2Zmc2V0KTtcbiAgICAgICAgcmFuZ2Uuc2V0RW5kKGNvbnRhaW5lciwgb2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldENsaWVudFJlY3RzID0gKCkgPT4ge1xuICAgICAgICBpZiAoIWNsaWVudFJlY3RzKSB7XG4gICAgICAgICAgY2xpZW50UmVjdHMgPSBnZXRDYXJldFBvc2l0aW9uQ2xpZW50UmVjdHMoQ2FyZXRQb3NpdGlvbihjb250YWluZXIsIG9mZnNldCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbGllbnRSZWN0cztcbiAgICAgIH07XG4gICAgICBjb25zdCBpc1Zpc2libGUgPSAoKSA9PiBnZXRDbGllbnRSZWN0cygpLmxlbmd0aCA+IDA7XG4gICAgICBjb25zdCBpc0VxdWFsID0gY2FyZXRQb3NpdGlvbiA9PiBjYXJldFBvc2l0aW9uICYmIGNvbnRhaW5lciA9PT0gY2FyZXRQb3NpdGlvbi5jb250YWluZXIoKSAmJiBvZmZzZXQgPT09IGNhcmV0UG9zaXRpb24ub2Zmc2V0KCk7XG4gICAgICBjb25zdCBnZXROb2RlID0gYmVmb3JlID0+IHJlc29sdmVJbmRleCQxKGNvbnRhaW5lciwgYmVmb3JlID8gb2Zmc2V0IC0gMSA6IG9mZnNldCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb250YWluZXI6IGNvbnN0YW50KGNvbnRhaW5lciksXG4gICAgICAgIG9mZnNldDogY29uc3RhbnQob2Zmc2V0KSxcbiAgICAgICAgdG9SYW5nZSxcbiAgICAgICAgZ2V0Q2xpZW50UmVjdHMsXG4gICAgICAgIGlzVmlzaWJsZSxcbiAgICAgICAgaXNBdFN0YXJ0LFxuICAgICAgICBpc0F0RW5kLFxuICAgICAgICBpc0VxdWFsLFxuICAgICAgICBnZXROb2RlXG4gICAgICB9O1xuICAgIH07XG4gICAgQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydCA9IHJhbmdlID0+IENhcmV0UG9zaXRpb24ocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0KTtcbiAgICBDYXJldFBvc2l0aW9uLmZyb21SYW5nZUVuZCA9IHJhbmdlID0+IENhcmV0UG9zaXRpb24ocmFuZ2UuZW5kQ29udGFpbmVyLCByYW5nZS5lbmRPZmZzZXQpO1xuICAgIENhcmV0UG9zaXRpb24uYWZ0ZXIgPSBub2RlID0+IENhcmV0UG9zaXRpb24obm9kZS5wYXJlbnROb2RlLCBub2RlSW5kZXgkMShub2RlKSArIDEpO1xuICAgIENhcmV0UG9zaXRpb24uYmVmb3JlID0gbm9kZSA9PiBDYXJldFBvc2l0aW9uKG5vZGUucGFyZW50Tm9kZSwgbm9kZUluZGV4JDEobm9kZSkpO1xuICAgIENhcmV0UG9zaXRpb24uaXNBYm92ZSA9IChwb3MxLCBwb3MyKSA9PiBsaWZ0MihoZWFkKHBvczIuZ2V0Q2xpZW50UmVjdHMoKSksIGxhc3QkMyhwb3MxLmdldENsaWVudFJlY3RzKCkpLCBpc0Fib3ZlJDEpLmdldE9yKGZhbHNlKTtcbiAgICBDYXJldFBvc2l0aW9uLmlzQmVsb3cgPSAocG9zMSwgcG9zMikgPT4gbGlmdDIobGFzdCQzKHBvczIuZ2V0Q2xpZW50UmVjdHMoKSksIGhlYWQocG9zMS5nZXRDbGllbnRSZWN0cygpKSwgaXNCZWxvdyQxKS5nZXRPcihmYWxzZSk7XG4gICAgQ2FyZXRQb3NpdGlvbi5pc0F0U3RhcnQgPSBwb3MgPT4gcG9zID8gcG9zLmlzQXRTdGFydCgpIDogZmFsc2U7XG4gICAgQ2FyZXRQb3NpdGlvbi5pc0F0RW5kID0gcG9zID0+IHBvcyA/IHBvcy5pc0F0RW5kKCkgOiBmYWxzZTtcbiAgICBDYXJldFBvc2l0aW9uLmlzVGV4dFBvc2l0aW9uID0gcG9zID0+IHBvcyA/IGlzVGV4dCRhKHBvcy5jb250YWluZXIoKSkgOiBmYWxzZTtcbiAgICBDYXJldFBvc2l0aW9uLmlzRWxlbWVudFBvc2l0aW9uID0gcG9zID0+ICFDYXJldFBvc2l0aW9uLmlzVGV4dFBvc2l0aW9uKHBvcyk7XG5cbiAgICBjb25zdCB0cmltRW1wdHlUZXh0Tm9kZSQxID0gKGRvbSwgbm9kZSkgPT4ge1xuICAgICAgaWYgKGlzVGV4dCRhKG5vZGUpICYmIG5vZGUuZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZG9tLnJlbW92ZShub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGluc2VydE5vZGUgPSAoZG9tLCBybmcsIG5vZGUpID0+IHtcbiAgICAgIHJuZy5pbnNlcnROb2RlKG5vZGUpO1xuICAgICAgdHJpbUVtcHR5VGV4dE5vZGUkMShkb20sIG5vZGUucHJldmlvdXNTaWJsaW5nKTtcbiAgICAgIHRyaW1FbXB0eVRleHROb2RlJDEoZG9tLCBub2RlLm5leHRTaWJsaW5nKTtcbiAgICB9O1xuICAgIGNvbnN0IGluc2VydEZyYWdtZW50ID0gKGRvbSwgcm5nLCBmcmFnKSA9PiB7XG4gICAgICBjb25zdCBmaXJzdENoaWxkID0gT3B0aW9uYWwuZnJvbShmcmFnLmZpcnN0Q2hpbGQpO1xuICAgICAgY29uc3QgbGFzdENoaWxkID0gT3B0aW9uYWwuZnJvbShmcmFnLmxhc3RDaGlsZCk7XG4gICAgICBybmcuaW5zZXJ0Tm9kZShmcmFnKTtcbiAgICAgIGZpcnN0Q2hpbGQuZWFjaChjaGlsZCA9PiB0cmltRW1wdHlUZXh0Tm9kZSQxKGRvbSwgY2hpbGQucHJldmlvdXNTaWJsaW5nKSk7XG4gICAgICBsYXN0Q2hpbGQuZWFjaChjaGlsZCA9PiB0cmltRW1wdHlUZXh0Tm9kZSQxKGRvbSwgY2hpbGQubmV4dFNpYmxpbmcpKTtcbiAgICB9O1xuICAgIGNvbnN0IHJhbmdlSW5zZXJ0Tm9kZSA9IChkb20sIHJuZywgbm9kZSkgPT4ge1xuICAgICAgaWYgKGlzRG9jdW1lbnRGcmFnbWVudChub2RlKSkge1xuICAgICAgICBpbnNlcnRGcmFnbWVudChkb20sIHJuZywgbm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnNlcnROb2RlKGRvbSwgcm5nLCBub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgaXNUZXh0JDYgPSBpc1RleHQkYTtcbiAgICBjb25zdCBpc0JvZ3VzID0gaXNCb2d1cyQyO1xuICAgIGNvbnN0IG5vZGVJbmRleCA9IERPTVV0aWxzLm5vZGVJbmRleDtcbiAgICBjb25zdCBub3JtYWxpemVkUGFyZW50ID0gbm9kZSA9PiB7XG4gICAgICBjb25zdCBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgaWYgKGlzQm9ndXMocGFyZW50Tm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRQYXJlbnQocGFyZW50Tm9kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyZW50Tm9kZTtcbiAgICB9O1xuICAgIGNvbnN0IGdldENoaWxkTm9kZXMgPSBub2RlID0+IHtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVkdWNlKG5vZGUuY2hpbGROb2RlcywgKHJlc3VsdCwgbm9kZSkgPT4ge1xuICAgICAgICBpZiAoaXNCb2d1cyhub2RlKSAmJiBub2RlLm5vZGVOYW1lICE9PSAnQlInKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChnZXRDaGlsZE5vZGVzKG5vZGUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSwgW10pO1xuICAgIH07XG4gICAgY29uc3Qgbm9ybWFsaXplZFRleHRPZmZzZXQgPSAobm9kZSwgb2Zmc2V0KSA9PiB7XG4gICAgICBsZXQgdGVtcE5vZGUgPSBub2RlO1xuICAgICAgd2hpbGUgKHRlbXBOb2RlID0gdGVtcE5vZGUucHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICAgIGlmICghaXNUZXh0JDYodGVtcE5vZGUpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ICs9IHRlbXBOb2RlLmRhdGEubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9O1xuICAgIGNvbnN0IGVxdWFsID0gYSA9PiBiID0+IGEgPT09IGI7XG4gICAgY29uc3Qgbm9ybWFsaXplZE5vZGVJbmRleCA9IG5vZGUgPT4ge1xuICAgICAgbGV0IG5vZGVzLCBpbmRleDtcbiAgICAgIG5vZGVzID0gZ2V0Q2hpbGROb2Rlcyhub3JtYWxpemVkUGFyZW50KG5vZGUpKTtcbiAgICAgIGluZGV4ID0gZmluZEluZGV4JDEobm9kZXMsIGVxdWFsKG5vZGUpLCBub2RlKTtcbiAgICAgIG5vZGVzID0gbm9kZXMuc2xpY2UoMCwgaW5kZXggKyAxKTtcbiAgICAgIGNvbnN0IG51bVRleHRGcmFnbWVudHMgPSByZWR1Y2Uobm9kZXMsIChyZXN1bHQsIG5vZGUsIGkpID0+IHtcbiAgICAgICAgaWYgKGlzVGV4dCQ2KG5vZGUpICYmIGlzVGV4dCQ2KG5vZGVzW2kgLSAxXSkpIHtcbiAgICAgICAgICByZXN1bHQrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSwgMCk7XG4gICAgICBub2RlcyA9IGZpbHRlciQzKG5vZGVzLCBtYXRjaE5vZGVOYW1lcyhbbm9kZS5ub2RlTmFtZV0pKTtcbiAgICAgIGluZGV4ID0gZmluZEluZGV4JDEobm9kZXMsIGVxdWFsKG5vZGUpLCBub2RlKTtcbiAgICAgIHJldHVybiBpbmRleCAtIG51bVRleHRGcmFnbWVudHM7XG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGVQYXRoSXRlbSA9IG5vZGUgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IGlzVGV4dCQ2KG5vZGUpID8gJ3RleHQoKScgOiBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICByZXR1cm4gbmFtZSArICdbJyArIG5vcm1hbGl6ZWROb2RlSW5kZXgobm9kZSkgKyAnXSc7XG4gICAgfTtcbiAgICBjb25zdCBwYXJlbnRzVW50aWwkMSA9IChyb290LCBub2RlLCBwcmVkaWNhdGUpID0+IHtcbiAgICAgIGNvbnN0IHBhcmVudHMgPSBbXTtcbiAgICAgIGZvciAobGV0IHRlbXBOb2RlID0gbm9kZS5wYXJlbnROb2RlOyB0ZW1wTm9kZSAmJiB0ZW1wTm9kZSAhPT0gcm9vdDsgdGVtcE5vZGUgPSB0ZW1wTm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUgJiYgcHJlZGljYXRlKHRlbXBOb2RlKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudHMucHVzaCh0ZW1wTm9kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyZW50cztcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZSRiID0gKHJvb3QsIGNhcmV0UG9zaXRpb24pID0+IHtcbiAgICAgIGxldCBwYXRoID0gW107XG4gICAgICBsZXQgY29udGFpbmVyID0gY2FyZXRQb3NpdGlvbi5jb250YWluZXIoKTtcbiAgICAgIGxldCBvZmZzZXQgPSBjYXJldFBvc2l0aW9uLm9mZnNldCgpO1xuICAgICAgbGV0IG91dHB1dE9mZnNldDtcbiAgICAgIGlmIChpc1RleHQkNihjb250YWluZXIpKSB7XG4gICAgICAgIG91dHB1dE9mZnNldCA9IG5vcm1hbGl6ZWRUZXh0T2Zmc2V0KGNvbnRhaW5lciwgb2Zmc2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBjb250YWluZXIuY2hpbGROb2RlcztcbiAgICAgICAgaWYgKG9mZnNldCA+PSBjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgIG91dHB1dE9mZnNldCA9ICdhZnRlcic7XG4gICAgICAgICAgb2Zmc2V0ID0gY2hpbGROb2Rlcy5sZW5ndGggLSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dHB1dE9mZnNldCA9ICdiZWZvcmUnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRhaW5lciA9IGNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgIH1cbiAgICAgIHBhdGgucHVzaChjcmVhdGVQYXRoSXRlbShjb250YWluZXIpKTtcbiAgICAgIGxldCBwYXJlbnRzID0gcGFyZW50c1VudGlsJDEocm9vdCwgY29udGFpbmVyKTtcbiAgICAgIHBhcmVudHMgPSBmaWx0ZXIkMyhwYXJlbnRzLCBub3QoaXNCb2d1cyQyKSk7XG4gICAgICBwYXRoID0gcGF0aC5jb25jYXQobWFwJDEocGFyZW50cywgbm9kZSA9PiB7XG4gICAgICAgIHJldHVybiBjcmVhdGVQYXRoSXRlbShub2RlKTtcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBwYXRoLnJldmVyc2UoKS5qb2luKCcvJykgKyAnLCcgKyBvdXRwdXRPZmZzZXQ7XG4gICAgfTtcbiAgICBjb25zdCByZXNvbHZlUGF0aEl0ZW0gPSAobm9kZSwgbmFtZSwgaW5kZXgpID0+IHtcbiAgICAgIGxldCBub2RlcyA9IGdldENoaWxkTm9kZXMobm9kZSk7XG4gICAgICBub2RlcyA9IGZpbHRlciQzKG5vZGVzLCAobm9kZSwgaW5kZXgpID0+IHtcbiAgICAgICAgcmV0dXJuICFpc1RleHQkNihub2RlKSB8fCAhaXNUZXh0JDYobm9kZXNbaW5kZXggLSAxXSk7XG4gICAgICB9KTtcbiAgICAgIG5vZGVzID0gZmlsdGVyJDMobm9kZXMsIG1hdGNoTm9kZU5hbWVzKFtuYW1lXSkpO1xuICAgICAgcmV0dXJuIG5vZGVzW2luZGV4XTtcbiAgICB9O1xuICAgIGNvbnN0IGZpbmRUZXh0UG9zaXRpb24gPSAoY29udGFpbmVyLCBvZmZzZXQpID0+IHtcbiAgICAgIGxldCBub2RlID0gY29udGFpbmVyO1xuICAgICAgbGV0IHRhcmdldE9mZnNldCA9IDA7XG4gICAgICB3aGlsZSAoaXNUZXh0JDYobm9kZSkpIHtcbiAgICAgICAgY29uc3QgZGF0YUxlbiA9IG5vZGUuZGF0YS5sZW5ndGg7XG4gICAgICAgIGlmIChvZmZzZXQgPj0gdGFyZ2V0T2Zmc2V0ICYmIG9mZnNldCA8PSB0YXJnZXRPZmZzZXQgKyBkYXRhTGVuKSB7XG4gICAgICAgICAgY29udGFpbmVyID0gbm9kZTtcbiAgICAgICAgICBvZmZzZXQgPSBvZmZzZXQgLSB0YXJnZXRPZmZzZXQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1RleHQkNihub2RlLm5leHRTaWJsaW5nKSkge1xuICAgICAgICAgIGNvbnRhaW5lciA9IG5vZGU7XG4gICAgICAgICAgb2Zmc2V0ID0gZGF0YUxlbjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXRPZmZzZXQgKz0gZGF0YUxlbjtcbiAgICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICB9XG4gICAgICBpZiAoaXNUZXh0JDYoY29udGFpbmVyKSAmJiBvZmZzZXQgPiBjb250YWluZXIuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgb2Zmc2V0ID0gY29udGFpbmVyLmRhdGEubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIENhcmV0UG9zaXRpb24oY29udGFpbmVyLCBvZmZzZXQpO1xuICAgIH07XG4gICAgY29uc3QgcmVzb2x2ZSQxID0gKHJvb3QsIHBhdGgpID0+IHtcbiAgICAgIGlmICghcGF0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcnRzID0gcGF0aC5zcGxpdCgnLCcpO1xuICAgICAgY29uc3QgcGF0aHMgPSBwYXJ0c1swXS5zcGxpdCgnLycpO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gcGFydHMubGVuZ3RoID4gMSA/IHBhcnRzWzFdIDogJ2JlZm9yZSc7XG4gICAgICBjb25zdCBjb250YWluZXIgPSByZWR1Y2UocGF0aHMsIChyZXN1bHQsIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gLyhbXFx3XFwtXFwoXFwpXSspXFxbKFswLTldKylcXF0vLmV4ZWModmFsdWUpO1xuICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoWzFdID09PSAndGV4dCgpJykge1xuICAgICAgICAgIG1hdGNoWzFdID0gJyN0ZXh0JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZVBhdGhJdGVtKHJlc3VsdCwgbWF0Y2hbMV0sIHBhcnNlSW50KG1hdGNoWzJdLCAxMCkpO1xuICAgICAgfSwgcm9vdCk7XG4gICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICghaXNUZXh0JDYoY29udGFpbmVyKSAmJiBjb250YWluZXIucGFyZW50Tm9kZSkge1xuICAgICAgICBsZXQgbm9kZU9mZnNldDtcbiAgICAgICAgaWYgKG9mZnNldCA9PT0gJ2FmdGVyJykge1xuICAgICAgICAgIG5vZGVPZmZzZXQgPSBub2RlSW5kZXgoY29udGFpbmVyKSArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZU9mZnNldCA9IG5vZGVJbmRleChjb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDYXJldFBvc2l0aW9uKGNvbnRhaW5lci5wYXJlbnROb2RlLCBub2RlT2Zmc2V0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmaW5kVGV4dFBvc2l0aW9uKGNvbnRhaW5lciwgcGFyc2VJbnQob2Zmc2V0LCAxMCkpO1xuICAgIH07XG5cbiAgICBjb25zdCBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJDkgPSBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJGI7XG4gICAgY29uc3QgZ2V0Tm9ybWFsaXplZFRleHRPZmZzZXQkMSA9ICh0cmltLCBjb250YWluZXIsIG9mZnNldCkgPT4ge1xuICAgICAgbGV0IHRyaW1tZWRPZmZzZXQgPSB0cmltKGNvbnRhaW5lci5kYXRhLnNsaWNlKDAsIG9mZnNldCkpLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IG5vZGUgPSBjb250YWluZXIucHJldmlvdXNTaWJsaW5nOyBub2RlICYmIGlzVGV4dCRhKG5vZGUpOyBub2RlID0gbm9kZS5wcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgICAgdHJpbW1lZE9mZnNldCArPSB0cmltKG5vZGUuZGF0YSkubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyaW1tZWRPZmZzZXQ7XG4gICAgfTtcbiAgICBjb25zdCBnZXRQb2ludCA9IChkb20sIHRyaW0sIG5vcm1hbGl6ZWQsIHJuZywgc3RhcnQpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHN0YXJ0ID8gcm5nLnN0YXJ0Q29udGFpbmVyIDogcm5nLmVuZENvbnRhaW5lcjtcbiAgICAgIGxldCBvZmZzZXQgPSBzdGFydCA/IHJuZy5zdGFydE9mZnNldCA6IHJuZy5lbmRPZmZzZXQ7XG4gICAgICBjb25zdCBwb2ludCA9IFtdO1xuICAgICAgY29uc3Qgcm9vdCA9IGRvbS5nZXRSb290KCk7XG4gICAgICBpZiAoaXNUZXh0JGEoY29udGFpbmVyKSkge1xuICAgICAgICBwb2ludC5wdXNoKG5vcm1hbGl6ZWQgPyBnZXROb3JtYWxpemVkVGV4dE9mZnNldCQxKHRyaW0sIGNvbnRhaW5lciwgb2Zmc2V0KSA6IG9mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgYWZ0ZXIgPSAwO1xuICAgICAgICBjb25zdCBjaGlsZE5vZGVzID0gY29udGFpbmVyLmNoaWxkTm9kZXM7XG4gICAgICAgIGlmIChvZmZzZXQgPj0gY2hpbGROb2Rlcy5sZW5ndGggJiYgY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICBhZnRlciA9IDE7XG4gICAgICAgICAgb2Zmc2V0ID0gTWF0aC5tYXgoMCwgY2hpbGROb2Rlcy5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBwb2ludC5wdXNoKGRvbS5ub2RlSW5kZXgoY2hpbGROb2Rlc1tvZmZzZXRdLCBub3JtYWxpemVkKSArIGFmdGVyKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IG5vZGUgPSBjb250YWluZXI7IG5vZGUgJiYgbm9kZSAhPT0gcm9vdDsgbm9kZSA9IG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICBwb2ludC5wdXNoKGRvbS5ub2RlSW5kZXgobm9kZSwgbm9ybWFsaXplZCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH07XG4gICAgY29uc3QgZ2V0TG9jYXRpb24gPSAodHJpbSwgc2VsZWN0aW9uLCBub3JtYWxpemVkLCBybmcpID0+IHtcbiAgICAgIGNvbnN0IGRvbSA9IHNlbGVjdGlvbi5kb207XG4gICAgICBjb25zdCBzdGFydCA9IGdldFBvaW50KGRvbSwgdHJpbSwgbm9ybWFsaXplZCwgcm5nLCB0cnVlKTtcbiAgICAgIGNvbnN0IGZvcndhcmQgPSBzZWxlY3Rpb24uaXNGb3J3YXJkKCk7XG4gICAgICBjb25zdCBmYWtlQ2FyZXQgPSBpc1JhbmdlSW5DYXJldENvbnRhaW5lckJsb2NrKHJuZykgPyB7IGlzRmFrZUNhcmV0OiB0cnVlIH0gOiB7fTtcbiAgICAgIGlmICghc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgY29uc3QgZW5kID0gZ2V0UG9pbnQoZG9tLCB0cmltLCBub3JtYWxpemVkLCBybmcsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGFydCxcbiAgICAgICAgICBlbmQsXG4gICAgICAgICAgZm9yd2FyZCxcbiAgICAgICAgICAuLi5mYWtlQ2FyZXRcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgZm9yd2FyZCxcbiAgICAgICAgICAuLi5mYWtlQ2FyZXRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGZpbmRJbmRleCA9IChkb20sIG5hbWUsIGVsZW1lbnQpID0+IHtcbiAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICBUb29scy5lYWNoKGRvbS5zZWxlY3QobmFtZSksIG5vZGUgPT4ge1xuICAgICAgICBpZiAobm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtbWNlLWJvZ3VzJykgPT09ICdhbGwnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUgPT09IGVsZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY291bnQrKztcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH07XG4gICAgY29uc3QgbW92ZUVuZFBvaW50JDEgPSAocm5nLCBzdGFydCkgPT4ge1xuICAgICAgbGV0IGNvbnRhaW5lciA9IHN0YXJ0ID8gcm5nLnN0YXJ0Q29udGFpbmVyIDogcm5nLmVuZENvbnRhaW5lcjtcbiAgICAgIGxldCBvZmZzZXQgPSBzdGFydCA/IHJuZy5zdGFydE9mZnNldCA6IHJuZy5lbmRPZmZzZXQ7XG4gICAgICBpZiAoaXNFbGVtZW50JDYoY29udGFpbmVyKSAmJiBjb250YWluZXIubm9kZU5hbWUgPT09ICdUUicpIHtcbiAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IGNvbnRhaW5lci5jaGlsZE5vZGVzO1xuICAgICAgICBjb250YWluZXIgPSBjaGlsZE5vZGVzW01hdGgubWluKHN0YXJ0ID8gb2Zmc2V0IDogb2Zmc2V0IC0gMSwgY2hpbGROb2Rlcy5sZW5ndGggLSAxKV07XG4gICAgICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgICBvZmZzZXQgPSBzdGFydCA/IDAgOiBjb250YWluZXIuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgICBybmcuc2V0U3RhcnQoY29udGFpbmVyLCBvZmZzZXQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBybmcuc2V0RW5kKGNvbnRhaW5lciwgb2Zmc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG5vcm1hbGl6ZVRhYmxlQ2VsbFNlbGVjdGlvbiA9IHJuZyA9PiB7XG4gICAgICBtb3ZlRW5kUG9pbnQkMShybmcsIHRydWUpO1xuICAgICAgbW92ZUVuZFBvaW50JDEocm5nLCBmYWxzZSk7XG4gICAgICByZXR1cm4gcm5nO1xuICAgIH07XG4gICAgY29uc3QgZmluZFNpYmxpbmcgPSAobm9kZSwgb2Zmc2V0KSA9PiB7XG4gICAgICBpZiAoaXNFbGVtZW50JDYobm9kZSkpIHtcbiAgICAgICAgbm9kZSA9IGdldE5vZGUkMShub2RlLCBvZmZzZXQpO1xuICAgICAgICBpZiAoaXNDb250ZW50RWRpdGFibGVGYWxzZSQ5KG5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0NhcmV0Q29udGFpbmVyJDIobm9kZSkpIHtcbiAgICAgICAgaWYgKGlzVGV4dCRhKG5vZGUpICYmIGlzQ2FyZXRDb250YWluZXJCbG9jayQxKG5vZGUpKSB7XG4gICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2libGluZyA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICBpZiAoaXNDb250ZW50RWRpdGFibGVGYWxzZSQ5KHNpYmxpbmcpKSB7XG4gICAgICAgICAgcmV0dXJuIHNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgc2libGluZyA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIGlmIChpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJDkoc2libGluZykpIHtcbiAgICAgICAgICByZXR1cm4gc2libGluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIGNvbnN0IGZpbmRBZGphY2VudENvbnRlbnRFZGl0YWJsZUZhbHNlRWxtID0gcm5nID0+IHtcbiAgICAgIHJldHVybiBmaW5kU2libGluZyhybmcuc3RhcnRDb250YWluZXIsIHJuZy5zdGFydE9mZnNldCkgfHwgZmluZFNpYmxpbmcocm5nLmVuZENvbnRhaW5lciwgcm5nLmVuZE9mZnNldCk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRPZmZzZXRCb29rbWFyayA9ICh0cmltLCBub3JtYWxpemVkLCBzZWxlY3Rpb24pID0+IHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBzZWxlY3Rpb24uZ2V0Tm9kZSgpO1xuICAgICAgY29uc3Qgcm5nID0gc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgaWYgKGVsZW1lbnQubm9kZU5hbWUgPT09ICdJTUcnIHx8IGlzQ29udGVudEVkaXRhYmxlRmFsc2UkOShlbGVtZW50KSkge1xuICAgICAgICBjb25zdCBuYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGluZGV4OiBmaW5kSW5kZXgoc2VsZWN0aW9uLmRvbSwgbmFtZSwgZWxlbWVudClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpYmxpbmcgPSBmaW5kQWRqYWNlbnRDb250ZW50RWRpdGFibGVGYWxzZUVsbShybmcpO1xuICAgICAgaWYgKHNpYmxpbmcpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHNpYmxpbmcudGFnTmFtZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGluZGV4OiBmaW5kSW5kZXgoc2VsZWN0aW9uLmRvbSwgbmFtZSwgc2libGluZylcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRMb2NhdGlvbih0cmltLCBzZWxlY3Rpb24sIG5vcm1hbGl6ZWQsIHJuZyk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRDYXJldEJvb2ttYXJrID0gc2VsZWN0aW9uID0+IHtcbiAgICAgIGNvbnN0IHJuZyA9IHNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBjcmVhdGUkYihzZWxlY3Rpb24uZG9tLmdldFJvb3QoKSwgQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChybmcpKSxcbiAgICAgICAgZW5kOiBjcmVhdGUkYihzZWxlY3Rpb24uZG9tLmdldFJvb3QoKSwgQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VFbmQocm5nKSksXG4gICAgICAgIGZvcndhcmQ6IHNlbGVjdGlvbi5pc0ZvcndhcmQoKVxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGdldFJhbmdlQm9va21hcmsgPSBzZWxlY3Rpb24gPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm5nOiBzZWxlY3Rpb24uZ2V0Um5nKCksXG4gICAgICAgIGZvcndhcmQ6IHNlbGVjdGlvbi5pc0ZvcndhcmQoKVxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZUJvb2ttYXJrU3BhbiA9IChkb20sIGlkLCBmaWxsZWQpID0+IHtcbiAgICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICAgICdkYXRhLW1jZS10eXBlJzogJ2Jvb2ttYXJrJyxcbiAgICAgICAgaWQsXG4gICAgICAgICdzdHlsZSc6ICdvdmVyZmxvdzpoaWRkZW47bGluZS1oZWlnaHQ6MHB4J1xuICAgICAgfTtcbiAgICAgIHJldHVybiBmaWxsZWQgPyBkb20uY3JlYXRlKCdzcGFuJywgYXJncywgJyYjeEZFRkY7JykgOiBkb20uY3JlYXRlKCdzcGFuJywgYXJncyk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRQZXJzaXN0ZW50Qm9va21hcmsgPSAoc2VsZWN0aW9uLCBmaWxsZWQpID0+IHtcbiAgICAgIGNvbnN0IGRvbSA9IHNlbGVjdGlvbi5kb207XG4gICAgICBsZXQgcm5nID0gc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgY29uc3QgaWQgPSBkb20udW5pcXVlSWQoKTtcbiAgICAgIGNvbnN0IGNvbGxhcHNlZCA9IHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpO1xuICAgICAgY29uc3QgZWxlbWVudCA9IHNlbGVjdGlvbi5nZXROb2RlKCk7XG4gICAgICBjb25zdCBuYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcbiAgICAgIGNvbnN0IGZvcndhcmQgPSBzZWxlY3Rpb24uaXNGb3J3YXJkKCk7XG4gICAgICBpZiAobmFtZSA9PT0gJ0lNRycpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGluZGV4OiBmaW5kSW5kZXgoZG9tLCBuYW1lLCBlbGVtZW50KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3Qgcm5nMiA9IG5vcm1hbGl6ZVRhYmxlQ2VsbFNlbGVjdGlvbihybmcuY2xvbmVSYW5nZSgpKTtcbiAgICAgIGlmICghY29sbGFwc2VkKSB7XG4gICAgICAgIHJuZzIuY29sbGFwc2UoZmFsc2UpO1xuICAgICAgICBjb25zdCBlbmRCb29rbWFya05vZGUgPSBjcmVhdGVCb29rbWFya1NwYW4oZG9tLCBpZCArICdfZW5kJywgZmlsbGVkKTtcbiAgICAgICAgcmFuZ2VJbnNlcnROb2RlKGRvbSwgcm5nMiwgZW5kQm9va21hcmtOb2RlKTtcbiAgICAgIH1cbiAgICAgIHJuZyA9IG5vcm1hbGl6ZVRhYmxlQ2VsbFNlbGVjdGlvbihybmcpO1xuICAgICAgcm5nLmNvbGxhcHNlKHRydWUpO1xuICAgICAgY29uc3Qgc3RhcnRCb29rbWFya05vZGUgPSBjcmVhdGVCb29rbWFya1NwYW4oZG9tLCBpZCArICdfc3RhcnQnLCBmaWxsZWQpO1xuICAgICAgcmFuZ2VJbnNlcnROb2RlKGRvbSwgcm5nLCBzdGFydEJvb2ttYXJrTm9kZSk7XG4gICAgICBzZWxlY3Rpb24ubW92ZVRvQm9va21hcmsoe1xuICAgICAgICBpZCxcbiAgICAgICAga2VlcDogdHJ1ZSxcbiAgICAgICAgZm9yd2FyZFxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZCxcbiAgICAgICAgZm9yd2FyZFxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGdldEJvb2ttYXJrJDIgPSAoc2VsZWN0aW9uLCB0eXBlLCBub3JtYWxpemVkID0gZmFsc2UpID0+IHtcbiAgICAgIGlmICh0eXBlID09PSAyKSB7XG4gICAgICAgIHJldHVybiBnZXRPZmZzZXRCb29rbWFyayh0cmltJDEsIG5vcm1hbGl6ZWQsIHNlbGVjdGlvbik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDMpIHtcbiAgICAgICAgcmV0dXJuIGdldENhcmV0Qm9va21hcmsoc2VsZWN0aW9uKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSkge1xuICAgICAgICByZXR1cm4gZ2V0UmFuZ2VCb29rbWFyayhzZWxlY3Rpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGdldFBlcnNpc3RlbnRCb29rbWFyayhzZWxlY3Rpb24sIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGdldFVuZG9Cb29rbWFyayA9IGN1cnJ5KGdldE9mZnNldEJvb2ttYXJrLCBpZGVudGl0eSwgdHJ1ZSk7XG5cbiAgICBjb25zdCB2YWx1ZSQxID0gdmFsdWUgPT4ge1xuICAgICAgY29uc3QgYXBwbHlIZWxwZXIgPSBmbiA9PiBmbih2YWx1ZSk7XG4gICAgICBjb25zdCBjb25zdEhlbHBlciA9IGNvbnN0YW50KHZhbHVlKTtcbiAgICAgIGNvbnN0IG91dHB1dEhlbHBlciA9ICgpID0+IG91dHB1dDtcbiAgICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgICAgdGFnOiB0cnVlLFxuICAgICAgICBpbm5lcjogdmFsdWUsXG4gICAgICAgIGZvbGQ6IChfb25FcnJvciwgb25WYWx1ZSkgPT4gb25WYWx1ZSh2YWx1ZSksXG4gICAgICAgIGlzVmFsdWU6IGFsd2F5cyxcbiAgICAgICAgaXNFcnJvcjogbmV2ZXIsXG4gICAgICAgIG1hcDogbWFwcGVyID0+IFJlc3VsdC52YWx1ZShtYXBwZXIodmFsdWUpKSxcbiAgICAgICAgbWFwRXJyb3I6IG91dHB1dEhlbHBlcixcbiAgICAgICAgYmluZDogYXBwbHlIZWxwZXIsXG4gICAgICAgIGV4aXN0czogYXBwbHlIZWxwZXIsXG4gICAgICAgIGZvcmFsbDogYXBwbHlIZWxwZXIsXG4gICAgICAgIGdldE9yOiBjb25zdEhlbHBlcixcbiAgICAgICAgb3I6IG91dHB1dEhlbHBlcixcbiAgICAgICAgZ2V0T3JUaHVuazogY29uc3RIZWxwZXIsXG4gICAgICAgIG9yVGh1bms6IG91dHB1dEhlbHBlcixcbiAgICAgICAgZ2V0T3JEaWU6IGNvbnN0SGVscGVyLFxuICAgICAgICBlYWNoOiBmbiA9PiB7XG4gICAgICAgICAgZm4odmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICB0b09wdGlvbmFsOiAoKSA9PiBPcHRpb25hbC5zb21lKHZhbHVlKVxuICAgICAgfTtcbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcbiAgICBjb25zdCBlcnJvciA9IGVycm9yID0+IHtcbiAgICAgIGNvbnN0IG91dHB1dEhlbHBlciA9ICgpID0+IG91dHB1dDtcbiAgICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgICAgdGFnOiBmYWxzZSxcbiAgICAgICAgaW5uZXI6IGVycm9yLFxuICAgICAgICBmb2xkOiAob25FcnJvciwgX29uVmFsdWUpID0+IG9uRXJyb3IoZXJyb3IpLFxuICAgICAgICBpc1ZhbHVlOiBuZXZlcixcbiAgICAgICAgaXNFcnJvcjogYWx3YXlzLFxuICAgICAgICBtYXA6IG91dHB1dEhlbHBlcixcbiAgICAgICAgbWFwRXJyb3I6IG1hcHBlciA9PiBSZXN1bHQuZXJyb3IobWFwcGVyKGVycm9yKSksXG4gICAgICAgIGJpbmQ6IG91dHB1dEhlbHBlcixcbiAgICAgICAgZXhpc3RzOiBuZXZlcixcbiAgICAgICAgZm9yYWxsOiBhbHdheXMsXG4gICAgICAgIGdldE9yOiBpZGVudGl0eSxcbiAgICAgICAgb3I6IGlkZW50aXR5LFxuICAgICAgICBnZXRPclRodW5rOiBhcHBseSQxLFxuICAgICAgICBvclRodW5rOiBhcHBseSQxLFxuICAgICAgICBnZXRPckRpZTogZGllKFN0cmluZyhlcnJvcikpLFxuICAgICAgICBlYWNoOiBub29wLFxuICAgICAgICB0b09wdGlvbmFsOiBPcHRpb25hbC5ub25lXG4gICAgICB9O1xuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xuICAgIGNvbnN0IGZyb21PcHRpb24gPSAob3B0aW9uYWwsIGVycikgPT4gb3B0aW9uYWwuZm9sZCgoKSA9PiBlcnJvcihlcnIpLCB2YWx1ZSQxKTtcbiAgICBjb25zdCBSZXN1bHQgPSB7XG4gICAgICB2YWx1ZTogdmFsdWUkMSxcbiAgICAgIGVycm9yLFxuICAgICAgZnJvbU9wdGlvblxuICAgIH07XG5cbiAgICBjb25zdCBnZW5lcmF0ZSA9IGNhc2VzID0+IHtcbiAgICAgIGlmICghaXNBcnJheSQxKGNhc2VzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhc2VzIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYXNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGVyZSBtdXN0IGJlIGF0IGxlYXN0IG9uZSBjYXNlJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBjb25zdHJ1Y3RvcnMgPSBbXTtcbiAgICAgIGNvbnN0IGFkdCA9IHt9O1xuICAgICAgZWFjaCRlKGNhc2VzLCAoYWNhc2UsIGNvdW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGtleXMkMSA9IGtleXMoYWNhc2UpO1xuICAgICAgICBpZiAoa2V5cyQxLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb25lIGFuZCBvbmx5IG9uZSBuYW1lIHBlciBjYXNlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5ID0ga2V5cyQxWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGFjYXNlW2tleV07XG4gICAgICAgIGlmIChhZHRba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkdXBsaWNhdGUga2V5IGRldGVjdGVkOicgKyBrZXkpO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2NhdGEnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgaGF2ZSBhIGNhc2UgbmFtZWQgY2F0YSAoc29ycnkpJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzQXJyYXkkMSh2YWx1ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhc2UgYXJndW1lbnRzIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdHJ1Y3RvcnMucHVzaChrZXkpO1xuICAgICAgICBhZHRba2V5XSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgY29uc3QgYXJnTGVuZ3RoID0gYXJncy5sZW5ndGg7XG4gICAgICAgICAgaWYgKGFyZ0xlbmd0aCAhPT0gdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgdG8gY2FzZSAnICsga2V5ICsgJy4gRXhwZWN0ZWQgJyArIHZhbHVlLmxlbmd0aCArICcgKCcgKyB2YWx1ZSArICcpLCBnb3QgJyArIGFyZ0xlbmd0aCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG1hdGNoID0gYnJhbmNoZXMgPT4ge1xuICAgICAgICAgICAgY29uc3QgYnJhbmNoS2V5cyA9IGtleXMoYnJhbmNoZXMpO1xuICAgICAgICAgICAgaWYgKGNvbnN0cnVjdG9ycy5sZW5ndGggIT09IGJyYW5jaEtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBtYXRjaC4gRXhwZWN0ZWQ6ICcgKyBjb25zdHJ1Y3RvcnMuam9pbignLCcpICsgJ1xcbkFjdHVhbDogJyArIGJyYW5jaEtleXMuam9pbignLCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFsbFJlcWQgPSBmb3JhbGwoY29uc3RydWN0b3JzLCByZXFLZXkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gY29udGFpbnMkMihicmFuY2hLZXlzLCByZXFLZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWFsbFJlcWQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYWxsIGJyYW5jaGVzIHdlcmUgc3BlY2lmaWVkIHdoZW4gdXNpbmcgbWF0Y2guIFNwZWNpZmllZDogJyArIGJyYW5jaEtleXMuam9pbignLCAnKSArICdcXG5SZXF1aXJlZDogJyArIGNvbnN0cnVjdG9ycy5qb2luKCcsICcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBicmFuY2hlc1trZXldLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZvbGQ6ICguLi5mb2xkQXJncykgPT4ge1xuICAgICAgICAgICAgICBpZiAoZm9sZEFyZ3MubGVuZ3RoICE9PSBjYXNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgdG8gZm9sZC4gRXhwZWN0ZWQgJyArIGNhc2VzLmxlbmd0aCArICcsIGdvdCAnICsgZm9sZEFyZ3MubGVuZ3RoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBmb2xkQXJnc1tjb3VudF07XG4gICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgICBsb2c6IGxhYmVsID0+IHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2cobGFiZWwsIHtcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvcnMsXG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3I6IGtleSxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IGFyZ3NcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFkdDtcbiAgICB9O1xuICAgIGNvbnN0IEFkdCA9IHsgZ2VuZXJhdGUgfTtcblxuICAgIEFkdC5nZW5lcmF0ZShbXG4gICAgICB7XG4gICAgICAgIGJvdGhFcnJvcnM6IFtcbiAgICAgICAgICAnZXJyb3IxJyxcbiAgICAgICAgICAnZXJyb3IyJ1xuICAgICAgICBdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBmaXJzdEVycm9yOiBbXG4gICAgICAgICAgJ2Vycm9yMScsXG4gICAgICAgICAgJ3ZhbHVlMidcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc2Vjb25kRXJyb3I6IFtcbiAgICAgICAgICAndmFsdWUxJyxcbiAgICAgICAgICAnZXJyb3IyJ1xuICAgICAgICBdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBib3RoVmFsdWVzOiBbXG4gICAgICAgICAgJ3ZhbHVlMScsXG4gICAgICAgICAgJ3ZhbHVlMidcbiAgICAgICAgXVxuICAgICAgfVxuICAgIF0pO1xuICAgIGNvbnN0IHBhcnRpdGlvbiQxID0gcmVzdWx0cyA9PiB7XG4gICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgICAgZWFjaCRlKHJlc3VsdHMsIHJlc3VsdCA9PiB7XG4gICAgICAgIHJlc3VsdC5mb2xkKGVyciA9PiB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgfSwgdmFsdWUgPT4ge1xuICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycm9ycyxcbiAgICAgICAgdmFsdWVzXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBpc0lubGluZVBhdHRlcm4gPSBwYXR0ZXJuID0+IHBhdHRlcm4udHlwZSA9PT0gJ2lubGluZS1jb21tYW5kJyB8fCBwYXR0ZXJuLnR5cGUgPT09ICdpbmxpbmUtZm9ybWF0JztcbiAgICBjb25zdCBpc0Jsb2NrUGF0dGVybiA9IHBhdHRlcm4gPT4gcGF0dGVybi50eXBlID09PSAnYmxvY2stY29tbWFuZCcgfHwgcGF0dGVybi50eXBlID09PSAnYmxvY2stZm9ybWF0JztcbiAgICBjb25zdCBub3JtYWxpemVQYXR0ZXJuID0gcGF0dGVybiA9PiB7XG4gICAgICBjb25zdCBlcnIgPSBtZXNzYWdlID0+IFJlc3VsdC5lcnJvcih7XG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHBhdHRlcm5cbiAgICAgIH0pO1xuICAgICAgY29uc3QgZm9ybWF0T3JDbWQgPSAobmFtZSwgb25Gb3JtYXQsIG9uQ29tbWFuZCkgPT4ge1xuICAgICAgICBpZiAocGF0dGVybi5mb3JtYXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGxldCBmb3JtYXRzO1xuICAgICAgICAgIGlmIChpc0FycmF5JDEocGF0dGVybi5mb3JtYXQpKSB7XG4gICAgICAgICAgICBpZiAoIWZvcmFsbChwYXR0ZXJuLmZvcm1hdCwgaXNTdHJpbmcpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBlcnIobmFtZSArICcgcGF0dGVybiBoYXMgbm9uLXN0cmluZyBpdGVtcyBpbiB0aGUgYGZvcm1hdGAgYXJyYXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvcm1hdHMgPSBwYXR0ZXJuLmZvcm1hdDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKHBhdHRlcm4uZm9ybWF0KSkge1xuICAgICAgICAgICAgZm9ybWF0cyA9IFtwYXR0ZXJuLmZvcm1hdF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBlcnIobmFtZSArICcgcGF0dGVybiBoYXMgbm9uLXN0cmluZyBgZm9ybWF0YCBwYXJhbWV0ZXInKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFJlc3VsdC52YWx1ZShvbkZvcm1hdChmb3JtYXRzKSk7XG4gICAgICAgIH0gZWxzZSBpZiAocGF0dGVybi5jbWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICghaXNTdHJpbmcocGF0dGVybi5jbWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyKG5hbWUgKyAnIHBhdHRlcm4gaGFzIG5vbi1zdHJpbmcgYGNtZGAgcGFyYW1ldGVyJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBSZXN1bHQudmFsdWUob25Db21tYW5kKHBhdHRlcm4uY21kLCBwYXR0ZXJuLnZhbHVlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGVycihuYW1lICsgJyBwYXR0ZXJuIGlzIG1pc3NpbmcgYm90aCBgZm9ybWF0YCBhbmQgYGNtZGAgcGFyYW1ldGVycycpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKCFpc09iamVjdChwYXR0ZXJuKSkge1xuICAgICAgICByZXR1cm4gZXJyKCdSYXcgcGF0dGVybiBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzU3RyaW5nKHBhdHRlcm4uc3RhcnQpKSB7XG4gICAgICAgIHJldHVybiBlcnIoJ1JhdyBwYXR0ZXJuIGlzIG1pc3NpbmcgYHN0YXJ0YCBwYXJhbWV0ZXInKTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXR0ZXJuLmVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghaXNTdHJpbmcocGF0dGVybi5lbmQpKSB7XG4gICAgICAgICAgcmV0dXJuIGVycignSW5saW5lIHBhdHRlcm4gaGFzIG5vbi1zdHJpbmcgYGVuZGAgcGFyYW1ldGVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdHRlcm4uc3RhcnQubGVuZ3RoID09PSAwICYmIHBhdHRlcm4uZW5kLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBlcnIoJ0lubGluZSBwYXR0ZXJuIGhhcyBlbXB0eSBgc3RhcnRgIGFuZCBgZW5kYCBwYXJhbWV0ZXJzJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0ID0gcGF0dGVybi5zdGFydDtcbiAgICAgICAgbGV0IGVuZCA9IHBhdHRlcm4uZW5kO1xuICAgICAgICBpZiAoZW5kLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICAgIHN0YXJ0ID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdE9yQ21kKCdJbmxpbmUnLCBmb3JtYXQgPT4gKHtcbiAgICAgICAgICB0eXBlOiAnaW5saW5lLWZvcm1hdCcsXG4gICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgZW5kLFxuICAgICAgICAgIGZvcm1hdFxuICAgICAgICB9KSwgKGNtZCwgdmFsdWUpID0+ICh7XG4gICAgICAgICAgdHlwZTogJ2lubGluZS1jb21tYW5kJyxcbiAgICAgICAgICBzdGFydCxcbiAgICAgICAgICBlbmQsXG4gICAgICAgICAgY21kLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSBpZiAocGF0dGVybi5yZXBsYWNlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghaXNTdHJpbmcocGF0dGVybi5yZXBsYWNlbWVudCkpIHtcbiAgICAgICAgICByZXR1cm4gZXJyKCdSZXBsYWNlbWVudCBwYXR0ZXJuIGhhcyBub24tc3RyaW5nIGByZXBsYWNlbWVudGAgcGFyYW1ldGVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdHRlcm4uc3RhcnQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGVycignUmVwbGFjZW1lbnQgcGF0dGVybiBoYXMgZW1wdHkgYHN0YXJ0YCBwYXJhbWV0ZXInKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUmVzdWx0LnZhbHVlKHtcbiAgICAgICAgICB0eXBlOiAnaW5saW5lLWNvbW1hbmQnLFxuICAgICAgICAgIHN0YXJ0OiAnJyxcbiAgICAgICAgICBlbmQ6IHBhdHRlcm4uc3RhcnQsXG4gICAgICAgICAgY21kOiAnbWNlSW5zZXJ0Q29udGVudCcsXG4gICAgICAgICAgdmFsdWU6IHBhdHRlcm4ucmVwbGFjZW1lbnRcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocGF0dGVybi5zdGFydC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gZXJyKCdCbG9jayBwYXR0ZXJuIGhhcyBlbXB0eSBgc3RhcnRgIHBhcmFtZXRlcicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXRPckNtZCgnQmxvY2snLCBmb3JtYXRzID0+ICh7XG4gICAgICAgICAgdHlwZTogJ2Jsb2NrLWZvcm1hdCcsXG4gICAgICAgICAgc3RhcnQ6IHBhdHRlcm4uc3RhcnQsXG4gICAgICAgICAgZm9ybWF0OiBmb3JtYXRzWzBdXG4gICAgICAgIH0pLCAoY29tbWFuZCwgY29tbWFuZFZhbHVlKSA9PiAoe1xuICAgICAgICAgIHR5cGU6ICdibG9jay1jb21tYW5kJyxcbiAgICAgICAgICBzdGFydDogcGF0dGVybi5zdGFydCxcbiAgICAgICAgICBjbWQ6IGNvbW1hbmQsXG4gICAgICAgICAgdmFsdWU6IGNvbW1hbmRWYWx1ZVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBnZXRCbG9ja1BhdHRlcm5zID0gcGF0dGVybnMgPT4gZmlsdGVyJDUocGF0dGVybnMsIGlzQmxvY2tQYXR0ZXJuKTtcbiAgICBjb25zdCBnZXRJbmxpbmVQYXR0ZXJucyA9IHBhdHRlcm5zID0+IGZpbHRlciQ1KHBhdHRlcm5zLCBpc0lubGluZVBhdHRlcm4pO1xuICAgIGNvbnN0IGNyZWF0ZVBhdHRlcm5TZXQgPSAocGF0dGVybnMsIGR5bmFtaWNQYXR0ZXJuc0xvb2t1cCkgPT4gKHtcbiAgICAgIGlubGluZVBhdHRlcm5zOiBnZXRJbmxpbmVQYXR0ZXJucyhwYXR0ZXJucyksXG4gICAgICBibG9ja1BhdHRlcm5zOiBnZXRCbG9ja1BhdHRlcm5zKHBhdHRlcm5zKSxcbiAgICAgIGR5bmFtaWNQYXR0ZXJuc0xvb2t1cFxuICAgIH0pO1xuICAgIGNvbnN0IGZyb21SYXdQYXR0ZXJucyA9IHBhdHRlcm5zID0+IHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBwYXJ0aXRpb24kMShtYXAkMyhwYXR0ZXJucywgbm9ybWFsaXplUGF0dGVybikpO1xuICAgICAgZWFjaCRlKG5vcm1hbGl6ZWQuZXJyb3JzLCBlcnIgPT4gY29uc29sZS5lcnJvcihlcnIubWVzc2FnZSwgZXJyLnBhdHRlcm4pKTtcbiAgICAgIHJldHVybiBub3JtYWxpemVkLnZhbHVlcztcbiAgICB9O1xuICAgIGNvbnN0IGZyb21SYXdQYXR0ZXJuc0xvb2t1cCA9IGxvb2t1cEZuID0+IHtcbiAgICAgIHJldHVybiBjdHggPT4ge1xuICAgICAgICBjb25zdCByYXdQYXR0ZXJucyA9IGxvb2t1cEZuKGN0eCk7XG4gICAgICAgIHJldHVybiBmcm9tUmF3UGF0dGVybnMocmF3UGF0dGVybnMpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgZGV2aWNlRGV0ZWN0aW9uJDEgPSBkZXRlY3QkMigpLmRldmljZVR5cGU7XG4gICAgY29uc3QgaXNUb3VjaCA9IGRldmljZURldGVjdGlvbiQxLmlzVG91Y2goKTtcbiAgICBjb25zdCBET00kYSA9IERPTVV0aWxzLkRPTTtcbiAgICBjb25zdCBnZXRIYXNoID0gdmFsdWUgPT4ge1xuICAgICAgY29uc3QgaXRlbXMgPSB2YWx1ZS5pbmRleE9mKCc9JykgPiAwID8gdmFsdWUuc3BsaXQoL1s7LF0oPyFbXj07LF0qKD86WzssXXwkKSkvKSA6IHZhbHVlLnNwbGl0KCcsJyk7XG4gICAgICByZXR1cm4gZm9sZGwoaXRlbXMsIChvdXRwdXQsIGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgYXJyID0gaXRlbS5zcGxpdCgnPScpO1xuICAgICAgICBjb25zdCBrZXkgPSBhcnJbMF07XG4gICAgICAgIGNvbnN0IHZhbCA9IGFyci5sZW5ndGggPiAxID8gYXJyWzFdIDoga2V5O1xuICAgICAgICBvdXRwdXRbdHJpbSQzKGtleSldID0gdHJpbSQzKHZhbCk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICB9LCB7fSk7XG4gICAgfTtcbiAgICBjb25zdCBpc1JlZ0V4cCA9IHggPT4gaXMkNCh4LCBSZWdFeHApO1xuICAgIGNvbnN0IG9wdGlvbiA9IG5hbWUgPT4gZWRpdG9yID0+IGVkaXRvci5vcHRpb25zLmdldChuYW1lKTtcbiAgICBjb25zdCBzdHJpbmdPck9iamVjdFByb2Nlc3NvciA9IHZhbHVlID0+IGlzU3RyaW5nKHZhbHVlKSB8fCBpc09iamVjdCh2YWx1ZSk7XG4gICAgY29uc3QgYm9keU9wdGlvblByb2Nlc3NvciA9IChlZGl0b3IsIGRlZmF1bHRWYWx1ZSA9ICcnKSA9PiB2YWx1ZSA9PiB7XG4gICAgICBjb25zdCB2YWxpZCA9IGlzU3RyaW5nKHZhbHVlKTtcbiAgICAgIGlmICh2YWxpZCkge1xuICAgICAgICBpZiAodmFsdWUuaW5kZXhPZignPScpICE9PSAtMSkge1xuICAgICAgICAgIGNvbnN0IGJvZHlPYmogPSBnZXRIYXNoKHZhbHVlKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IGdldCRhKGJvZHlPYmosIGVkaXRvci5pZCkuZ2V0T3IoZGVmYXVsdFZhbHVlKSxcbiAgICAgICAgICAgIHZhbGlkXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICB2YWxpZFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICAgIG1lc3NhZ2U6ICdNdXN0IGJlIGEgc3RyaW5nLidcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlZ2lzdGVyJDcgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgcmVnaXN0ZXJPcHRpb24gPSBlZGl0b3Iub3B0aW9ucy5yZWdpc3RlcjtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdpZCcsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnc3RyaW5nJyxcbiAgICAgICAgZGVmYXVsdDogZWRpdG9yLmlkXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdzZWxlY3RvcicsIHsgcHJvY2Vzc29yOiAnc3RyaW5nJyB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCd0YXJnZXQnLCB7IHByb2Nlc3NvcjogJ29iamVjdCcgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignc3VmZml4JywgeyBwcm9jZXNzb3I6ICdzdHJpbmcnIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2NhY2hlX3N1ZmZpeCcsIHsgcHJvY2Vzc29yOiAnc3RyaW5nJyB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdiYXNlX3VybCcsIHsgcHJvY2Vzc29yOiAnc3RyaW5nJyB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdyZWZlcnJlcl9wb2xpY3knLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ3N0cmluZycsXG4gICAgICAgIGRlZmF1bHQ6ICcnXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdsYW5ndWFnZV9sb2FkJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignaW5saW5lJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2lmcmFtZV9hdHRycycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnb2JqZWN0JyxcbiAgICAgICAgZGVmYXVsdDoge31cbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2RvY3R5cGUnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ3N0cmluZycsXG4gICAgICAgIGRlZmF1bHQ6ICc8IURPQ1RZUEUgaHRtbD4nXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdkb2N1bWVudF9iYXNlX3VybCcsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnc3RyaW5nJyxcbiAgICAgICAgZGVmYXVsdDogZWRpdG9yLmRvY3VtZW50QmFzZVVybFxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignYm9keV9pZCcsIHtcbiAgICAgICAgcHJvY2Vzc29yOiBib2R5T3B0aW9uUHJvY2Vzc29yKGVkaXRvciwgJ3RpbnltY2UnKSxcbiAgICAgICAgZGVmYXVsdDogJ3RpbnltY2UnXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdib2R5X2NsYXNzJywge1xuICAgICAgICBwcm9jZXNzb3I6IGJvZHlPcHRpb25Qcm9jZXNzb3IoZWRpdG9yKSxcbiAgICAgICAgZGVmYXVsdDogJydcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2NvbnRlbnRfc2VjdXJpdHlfcG9saWN5Jywge1xuICAgICAgICBwcm9jZXNzb3I6ICdzdHJpbmcnLFxuICAgICAgICBkZWZhdWx0OiAnJ1xuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignYnJfaW5fcHJlJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignZm9yY2VkX3Jvb3RfYmxvY2snLCB7XG4gICAgICAgIHByb2Nlc3NvcjogdmFsdWUgPT4ge1xuICAgICAgICAgIGNvbnN0IHZhbGlkID0gaXNTdHJpbmcodmFsdWUpICYmIGlzTm90RW1wdHkodmFsdWUpO1xuICAgICAgICAgIGlmICh2YWxpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIHZhbGlkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6ICdNdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZy4nXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGVmYXVsdDogJ3AnXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdmb3JjZWRfcm9vdF9ibG9ja19hdHRycycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnb2JqZWN0JyxcbiAgICAgICAgZGVmYXVsdDoge31cbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ25ld2xpbmVfYmVoYXZpb3InLCB7XG4gICAgICAgIHByb2Nlc3NvcjogdmFsdWUgPT4ge1xuICAgICAgICAgIGNvbnN0IHZhbGlkID0gY29udGFpbnMkMihbXG4gICAgICAgICAgICAnYmxvY2snLFxuICAgICAgICAgICAgJ2xpbmVicmVhaycsXG4gICAgICAgICAgICAnaW52ZXJ0JyxcbiAgICAgICAgICAgICdkZWZhdWx0J1xuICAgICAgICAgIF0sIHZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gdmFsaWQgPyB7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIHZhbGlkXG4gICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdNdXN0IGJlIG9uZSBvZjogYmxvY2ssIGxpbmVicmVhaywgaW52ZXJ0IG9yIGRlZmF1bHQuJ1xuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGRlZmF1bHQ6ICdkZWZhdWx0J1xuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignYnJfbmV3bGluZV9zZWxlY3RvcicsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnc3RyaW5nJyxcbiAgICAgICAgZGVmYXVsdDogJy5tY2UtdG9jIGgyLGZpZ2NhcHRpb24sY2FwdGlvbidcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ25vX25ld2xpbmVfc2VsZWN0b3InLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ3N0cmluZycsXG4gICAgICAgIGRlZmF1bHQ6ICcnXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdrZWVwX3N0eWxlcycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2VuZF9jb250YWluZXJfb25fZW1wdHlfYmxvY2snLCB7XG4gICAgICAgIHByb2Nlc3NvcjogdmFsdWUgPT4ge1xuICAgICAgICAgIGlmIChpc0Jvb2xlYW4odmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB2YWxpZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHZhbGlkOiB0cnVlLFxuICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAnTXVzdCBiZSBib29sZWFuIG9yIGEgc3RyaW5nJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRlZmF1bHQ6ICdibG9ja3F1b3RlJ1xuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignZm9udF9zaXplX3N0eWxlX3ZhbHVlcycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnc3RyaW5nJyxcbiAgICAgICAgZGVmYXVsdDogJ3h4LXNtYWxsLHgtc21hbGwsc21hbGwsbWVkaXVtLGxhcmdlLHgtbGFyZ2UseHgtbGFyZ2UnXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdmb250X3NpemVfbGVnYWN5X3ZhbHVlcycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnc3RyaW5nJyxcbiAgICAgICAgZGVmYXVsdDogJ3h4LXNtYWxsLHNtYWxsLG1lZGl1bSxsYXJnZSx4LWxhcmdlLHh4LWxhcmdlLDMwMCUnXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdmb250X3NpemVfY2xhc3NlcycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnc3RyaW5nJyxcbiAgICAgICAgZGVmYXVsdDogJydcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2F1dG9tYXRpY191cGxvYWRzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignaW1hZ2VzX3JldXNlX2ZpbGVuYW1lJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2ltYWdlc19yZXBsYWNlX2Jsb2JfdXJpcycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2ljb25zJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdzdHJpbmcnLFxuICAgICAgICBkZWZhdWx0OiAnJ1xuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignaWNvbnNfdXJsJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdzdHJpbmcnLFxuICAgICAgICBkZWZhdWx0OiAnJ1xuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignaW1hZ2VzX3VwbG9hZF91cmwnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ3N0cmluZycsXG4gICAgICAgIGRlZmF1bHQ6ICcnXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdpbWFnZXNfdXBsb2FkX2Jhc2VfcGF0aCcsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnc3RyaW5nJyxcbiAgICAgICAgZGVmYXVsdDogJydcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2ltYWdlc191cGxvYWRfY3JlZGVudGlhbHMnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignaW1hZ2VzX3VwbG9hZF9oYW5kbGVyJywgeyBwcm9jZXNzb3I6ICdmdW5jdGlvbicgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignbGFuZ3VhZ2UnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ3N0cmluZycsXG4gICAgICAgIGRlZmF1bHQ6ICdlbidcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2xhbmd1YWdlX3VybCcsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnc3RyaW5nJyxcbiAgICAgICAgZGVmYXVsdDogJydcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2VudGl0eV9lbmNvZGluZycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnc3RyaW5nJyxcbiAgICAgICAgZGVmYXVsdDogJ25hbWVkJ1xuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignaW5kZW50Jywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignaW5kZW50X2JlZm9yZScsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnc3RyaW5nJyxcbiAgICAgICAgZGVmYXVsdDogJ3AsaDEsaDIsaDMsaDQsaDUsaDYsYmxvY2txdW90ZSxkaXYsdGl0bGUsc3R5bGUscHJlLHNjcmlwdCx0ZCx0aCx1bCxvbCxsaSxkbCxkdCxkZCxhcmVhLHRhYmxlLHRoZWFkLCcgKyAndGZvb3QsdGJvZHksdHIsc2VjdGlvbixzdW1tYXJ5LGFydGljbGUsaGdyb3VwLGFzaWRlLGZpZ3VyZSxmaWdjYXB0aW9uLG9wdGlvbixvcHRncm91cCxkYXRhbGlzdCdcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2luZGVudF9hZnRlcicsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnc3RyaW5nJyxcbiAgICAgICAgZGVmYXVsdDogJ3AsaDEsaDIsaDMsaDQsaDUsaDYsYmxvY2txdW90ZSxkaXYsdGl0bGUsc3R5bGUscHJlLHNjcmlwdCx0ZCx0aCx1bCxvbCxsaSxkbCxkdCxkZCxhcmVhLHRhYmxlLHRoZWFkLCcgKyAndGZvb3QsdGJvZHksdHIsc2VjdGlvbixzdW1tYXJ5LGFydGljbGUsaGdyb3VwLGFzaWRlLGZpZ3VyZSxmaWdjYXB0aW9uLG9wdGlvbixvcHRncm91cCxkYXRhbGlzdCdcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2luZGVudF91c2VfbWFyZ2luJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2luZGVudGF0aW9uJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdzdHJpbmcnLFxuICAgICAgICBkZWZhdWx0OiAnNDBweCdcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2NvbnRlbnRfY3NzJywge1xuICAgICAgICBwcm9jZXNzb3I6IHZhbHVlID0+IHtcbiAgICAgICAgICBjb25zdCB2YWxpZCA9IHZhbHVlID09PSBmYWxzZSB8fCBpc1N0cmluZyh2YWx1ZSkgfHwgaXNBcnJheU9mKHZhbHVlLCBpc1N0cmluZyk7XG4gICAgICAgICAgaWYgKHZhbGlkKSB7XG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG1hcCQzKHZhbHVlLnNwbGl0KCcsJyksIHRyaW0kMyksXG4gICAgICAgICAgICAgICAgdmFsaWRcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSQxKHZhbHVlKSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIHZhbGlkXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBbXSxcbiAgICAgICAgICAgICAgICB2YWxpZFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB2YWxpZFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6ICdNdXN0IGJlIGZhbHNlLCBhIHN0cmluZyBvciBhbiBhcnJheSBvZiBzdHJpbmdzLidcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkZWZhdWx0OiBpc0lubGluZShlZGl0b3IpID8gW10gOiBbJ2RlZmF1bHQnXVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignY29udGVudF9zdHlsZScsIHsgcHJvY2Vzc29yOiAnc3RyaW5nJyB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdjb250ZW50X2Nzc19jb3JzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2ZvbnRfY3NzJywge1xuICAgICAgICBwcm9jZXNzb3I6IHZhbHVlID0+IHtcbiAgICAgICAgICBjb25zdCB2YWxpZCA9IGlzU3RyaW5nKHZhbHVlKSB8fCBpc0FycmF5T2YodmFsdWUsIGlzU3RyaW5nKTtcbiAgICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gaXNBcnJheSQxKHZhbHVlKSA/IHZhbHVlIDogbWFwJDModmFsdWUuc3BsaXQoJywnKSwgdHJpbSQzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICAgICAgdmFsaWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ011c3QgYmUgYSBzdHJpbmcgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy4nXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGVmYXVsdDogW11cbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2lubGluZV9ib3VuZGFyaWVzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignaW5saW5lX2JvdW5kYXJpZXNfc2VsZWN0b3InLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ3N0cmluZycsXG4gICAgICAgIGRlZmF1bHQ6ICdhW2hyZWZdLGNvZGUsc3Bhbi5tY2UtYW5ub3RhdGlvbidcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ29iamVjdF9yZXNpemluZycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiB2YWx1ZSA9PiB7XG4gICAgICAgICAgY29uc3QgdmFsaWQgPSBpc0Jvb2xlYW4odmFsdWUpIHx8IGlzU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UgfHwgZGV2aWNlRGV0ZWN0aW9uJDEuaXNpUGhvbmUoKSB8fCBkZXZpY2VEZXRlY3Rpb24kMS5pc2lQYWQoKSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiAnJyxcbiAgICAgICAgICAgICAgICB2YWxpZFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUgPT09IHRydWUgPyAndGFibGUsaW1nLGZpZ3VyZS5pbWFnZSxkaXYsdmlkZW8saWZyYW1lJyA6IHZhbHVlLFxuICAgICAgICAgICAgICAgIHZhbGlkXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ011c3QgYmUgYm9vbGVhbiBvciBhIHN0cmluZydcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkZWZhdWx0OiAhaXNUb3VjaFxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigncmVzaXplX2ltZ19wcm9wb3J0aW9uYWwnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdldmVudF9yb290JywgeyBwcm9jZXNzb3I6ICdvYmplY3QnIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3NlcnZpY2VfbWVzc2FnZScsIHsgcHJvY2Vzc29yOiAnc3RyaW5nJyB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCd0aGVtZScsIHtcbiAgICAgICAgcHJvY2Vzc29yOiB2YWx1ZSA9PiB2YWx1ZSA9PT0gZmFsc2UgfHwgaXNTdHJpbmcodmFsdWUpIHx8IGlzRnVuY3Rpb24odmFsdWUpLFxuICAgICAgICBkZWZhdWx0OiAnc2lsdmVyJ1xuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigndGhlbWVfdXJsJywgeyBwcm9jZXNzb3I6ICdzdHJpbmcnIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2Zvcm1hdHMnLCB7IHByb2Nlc3NvcjogJ29iamVjdCcgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignZm9ybWF0X2VtcHR5X2xpbmVzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2Zvcm1hdF9ub25lZGl0YWJsZV9zZWxlY3RvcicsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnc3RyaW5nJyxcbiAgICAgICAgZGVmYXVsdDogJydcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3ByZXZpZXdfc3R5bGVzJywge1xuICAgICAgICBwcm9jZXNzb3I6IHZhbHVlID0+IHtcbiAgICAgICAgICBjb25zdCB2YWxpZCA9IHZhbHVlID09PSBmYWxzZSB8fCBpc1N0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgaWYgKHZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUgPT09IGZhbHNlID8gJycgOiB2YWx1ZSxcbiAgICAgICAgICAgICAgdmFsaWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ011c3QgYmUgZmFsc2Ugb3IgYSBzdHJpbmcnXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGVmYXVsdDogJ2ZvbnQtZmFtaWx5IGZvbnQtc2l6ZSBmb250LXdlaWdodCBmb250LXN0eWxlIHRleHQtZGVjb3JhdGlvbiB0ZXh0LXRyYW5zZm9ybSBjb2xvciBiYWNrZ3JvdW5kLWNvbG9yIGJvcmRlciBib3JkZXItcmFkaXVzIG91dGxpbmUgdGV4dC1zaGFkb3cnXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdjdXN0b21fdWlfc2VsZWN0b3InLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ3N0cmluZycsXG4gICAgICAgIGRlZmF1bHQ6ICcnXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdoaWRkZW5faW5wdXQnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdzdWJtaXRfcGF0Y2gnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdlbmNvZGluZycsIHsgcHJvY2Vzc29yOiAnc3RyaW5nJyB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdhZGRfZm9ybV9zdWJtaXRfdHJpZ2dlcicsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2FkZF91bmxvYWRfdHJpZ2dlcicsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2N1c3RvbV91bmRvX3JlZG9fbGV2ZWxzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdudW1iZXInLFxuICAgICAgICBkZWZhdWx0OiAwXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdkaXNhYmxlX25vZGVjaGFuZ2UnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigncmVhZG9ubHknLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigncGx1Z2lucycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnc3RyaW5nW10nLFxuICAgICAgICBkZWZhdWx0OiBbXVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignZXh0ZXJuYWxfcGx1Z2lucycsIHsgcHJvY2Vzc29yOiAnb2JqZWN0JyB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdmb3JjZWRfcGx1Z2lucycsIHsgcHJvY2Vzc29yOiAnc3RyaW5nW10nIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ21vZGVsJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdzdHJpbmcnLFxuICAgICAgICBkZWZhdWx0OiBlZGl0b3IuaGFzUGx1Z2luKCdydGMnKSA/ICdwbHVnaW4nIDogJ2RvbSdcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ21vZGVsX3VybCcsIHsgcHJvY2Vzc29yOiAnc3RyaW5nJyB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdibG9ja191bnN1cHBvcnRlZF9kcm9wJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigndmlzdWFsJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigndmlzdWFsX3RhYmxlX2NsYXNzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdzdHJpbmcnLFxuICAgICAgICBkZWZhdWx0OiAnbWNlLWl0ZW0tdGFibGUnXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCd2aXN1YWxfYW5jaG9yX2NsYXNzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdzdHJpbmcnLFxuICAgICAgICBkZWZhdWx0OiAnbWNlLWl0ZW0tYW5jaG9yJ1xuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignaWZyYW1lX2FyaWFfdGV4dCcsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnc3RyaW5nJyxcbiAgICAgICAgZGVmYXVsdDogJ1JpY2ggVGV4dCBBcmVhLiBQcmVzcyBBTFQtMCBmb3IgaGVscC4nXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdzZXR1cCcsIHsgcHJvY2Vzc29yOiAnZnVuY3Rpb24nIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2luaXRfaW5zdGFuY2VfY2FsbGJhY2snLCB7IHByb2Nlc3NvcjogJ2Z1bmN0aW9uJyB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCd1cmxfY29udmVydGVyJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdmdW5jdGlvbicsXG4gICAgICAgIGRlZmF1bHQ6IGVkaXRvci5jb252ZXJ0VVJMXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCd1cmxfY29udmVydGVyX3Njb3BlJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdvYmplY3QnLFxuICAgICAgICBkZWZhdWx0OiBlZGl0b3JcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3VybGNvbnZlcnRlcl9jYWxsYmFjaycsIHsgcHJvY2Vzc29yOiAnZnVuY3Rpb24nIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2FsbG93X2NvbmRpdGlvbmFsX2NvbW1lbnRzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2FsbG93X2h0bWxfZGF0YV91cmxzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2FsbG93X3N2Z19kYXRhX3VybHMnLCB7IHByb2Nlc3NvcjogJ2Jvb2xlYW4nIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2FsbG93X2h0bWxfaW5fbmFtZWRfYW5jaG9yJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2FsbG93X3NjcmlwdF91cmxzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2FsbG93X3Vuc2FmZV9saW5rX3RhcmdldCcsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdjb252ZXJ0X2ZvbnRzX3RvX3NwYW5zJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgZGVwcmVjYXRlZDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignZml4X2xpc3RfZWxlbWVudHMnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigncHJlc2VydmVfY2RhdGEnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigncmVtb3ZlX3RyYWlsaW5nX2JycycsIHsgcHJvY2Vzc29yOiAnYm9vbGVhbicgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignaW5saW5lX3N0eWxlcycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICAgIGRlcHJlY2F0ZWQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2VsZW1lbnRfZm9ybWF0Jywge1xuICAgICAgICBwcm9jZXNzb3I6ICdzdHJpbmcnLFxuICAgICAgICBkZWZhdWx0OiAnaHRtbCdcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2VudGl0aWVzJywgeyBwcm9jZXNzb3I6ICdzdHJpbmcnIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3NjaGVtYScsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnc3RyaW5nJyxcbiAgICAgICAgZGVmYXVsdDogJ2h0bWw1J1xuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignY29udmVydF91cmxzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigncmVsYXRpdmVfdXJscycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3JlbW92ZV9zY3JpcHRfaG9zdCcsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2N1c3RvbV9lbGVtZW50cycsIHsgcHJvY2Vzc29yOiAnc3RyaW5nJyB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdleHRlbmRlZF92YWxpZF9lbGVtZW50cycsIHsgcHJvY2Vzc29yOiAnc3RyaW5nJyB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdpbnZhbGlkX2VsZW1lbnRzJywgeyBwcm9jZXNzb3I6ICdzdHJpbmcnIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2ludmFsaWRfc3R5bGVzJywgeyBwcm9jZXNzb3I6IHN0cmluZ09yT2JqZWN0UHJvY2Vzc29yIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3ZhbGlkX2NoaWxkcmVuJywgeyBwcm9jZXNzb3I6ICdzdHJpbmcnIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3ZhbGlkX2NsYXNzZXMnLCB7IHByb2Nlc3Nvcjogc3RyaW5nT3JPYmplY3RQcm9jZXNzb3IgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigndmFsaWRfZWxlbWVudHMnLCB7IHByb2Nlc3NvcjogJ3N0cmluZycgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigndmFsaWRfc3R5bGVzJywgeyBwcm9jZXNzb3I6IHN0cmluZ09yT2JqZWN0UHJvY2Vzc29yIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3ZlcmlmeV9odG1sJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignYXV0b19mb2N1cycsIHsgcHJvY2Vzc29yOiB2YWx1ZSA9PiBpc1N0cmluZyh2YWx1ZSkgfHwgdmFsdWUgPT09IHRydWUgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignYnJvd3Nlcl9zcGVsbGNoZWNrJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3Byb3RlY3QnLCB7IHByb2Nlc3NvcjogJ2FycmF5JyB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdpbWFnZXNfZmlsZV90eXBlcycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnc3RyaW5nJyxcbiAgICAgICAgZGVmYXVsdDogJ2pwZWcsanBnLGpwZSxqZmksamlmLGpmaWYscG5nLGdpZixibXAsd2VicCdcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2RlcHJlY2F0aW9uX3dhcm5pbmdzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignYTExeV9hZHZhbmNlZF9vcHRpb25zJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2FwaV9rZXknLCB7IHByb2Nlc3NvcjogJ3N0cmluZycgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigncGFzdGVfYmxvY2tfZHJvcCcsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdwYXN0ZV9kYXRhX2ltYWdlcycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3Bhc3RlX3ByZXByb2Nlc3MnLCB7IHByb2Nlc3NvcjogJ2Z1bmN0aW9uJyB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdwYXN0ZV9wb3N0cHJvY2VzcycsIHsgcHJvY2Vzc29yOiAnZnVuY3Rpb24nIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3Bhc3RlX3dlYmtpdF9zdHlsZXMnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ3N0cmluZycsXG4gICAgICAgIGRlZmF1bHQ6ICdub25lJ1xuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigncGFzdGVfcmVtb3ZlX3N0eWxlc19pZl93ZWJraXQnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdwYXN0ZV9tZXJnZV9mb3JtYXRzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignc21hcnRfcGFzdGUnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdwYXN0ZV9hc190ZXh0Jywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3Bhc3RlX3RhYl9zcGFjZXMnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ251bWJlcicsXG4gICAgICAgIGRlZmF1bHQ6IDRcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3RleHRfcGF0dGVybnMnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogdmFsdWUgPT4ge1xuICAgICAgICAgIGlmIChpc0FycmF5T2YodmFsdWUsIGlzT2JqZWN0KSB8fCB2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5zID0gdmFsdWUgPT09IGZhbHNlID8gW10gOiB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHZhbHVlOiBmcm9tUmF3UGF0dGVybnMocGF0dGVybnMpLFxuICAgICAgICAgICAgICB2YWxpZDogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAnTXVzdCBiZSBhbiBhcnJheSBvZiBvYmplY3RzIG9yIGZhbHNlLidcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkZWZhdWx0OiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgc3RhcnQ6ICcqJyxcbiAgICAgICAgICAgIGVuZDogJyonLFxuICAgICAgICAgICAgZm9ybWF0OiAnaXRhbGljJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgc3RhcnQ6ICcqKicsXG4gICAgICAgICAgICBlbmQ6ICcqKicsXG4gICAgICAgICAgICBmb3JtYXQ6ICdib2xkJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgc3RhcnQ6ICcjJyxcbiAgICAgICAgICAgIGZvcm1hdDogJ2gxJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgc3RhcnQ6ICcjIycsXG4gICAgICAgICAgICBmb3JtYXQ6ICdoMidcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN0YXJ0OiAnIyMjJyxcbiAgICAgICAgICAgIGZvcm1hdDogJ2gzJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgc3RhcnQ6ICcjIyMjJyxcbiAgICAgICAgICAgIGZvcm1hdDogJ2g0J1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgc3RhcnQ6ICcjIyMjIycsXG4gICAgICAgICAgICBmb3JtYXQ6ICdoNSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN0YXJ0OiAnIyMjIyMjJyxcbiAgICAgICAgICAgIGZvcm1hdDogJ2g2J1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgc3RhcnQ6ICcxLiAnLFxuICAgICAgICAgICAgY21kOiAnSW5zZXJ0T3JkZXJlZExpc3QnXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzdGFydDogJyogJyxcbiAgICAgICAgICAgIGNtZDogJ0luc2VydFVub3JkZXJlZExpc3QnXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzdGFydDogJy0gJyxcbiAgICAgICAgICAgIGNtZDogJ0luc2VydFVub3JkZXJlZExpc3QnXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCd0ZXh0X3BhdHRlcm5zX2xvb2t1cCcsIHtcbiAgICAgICAgcHJvY2Vzc29yOiB2YWx1ZSA9PiB7XG4gICAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB2YWx1ZTogZnJvbVJhd1BhdHRlcm5zTG9va3VwKHZhbHVlKSxcbiAgICAgICAgICAgICAgdmFsaWQ6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ011c3QgYmUgYSBzaW5nbGUgZnVuY3Rpb24nXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGVmYXVsdDogX2N0eCA9PiBbXVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignbm9uZWRpdGFibGVfY2xhc3MnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ3N0cmluZycsXG4gICAgICAgIGRlZmF1bHQ6ICdtY2VOb25FZGl0YWJsZSdcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2VkaXRhYmxlX2NsYXNzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdzdHJpbmcnLFxuICAgICAgICBkZWZhdWx0OiAnbWNlRWRpdGFibGUnXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdub25lZGl0YWJsZV9yZWdleHAnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogdmFsdWUgPT4ge1xuICAgICAgICAgIGlmIChpc0FycmF5T2YodmFsdWUsIGlzUmVnRXhwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIHZhbGlkOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB2YWx1ZTogW3ZhbHVlXSxcbiAgICAgICAgICAgICAgdmFsaWQ6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ011c3QgYmUgYSBSZWdFeHAgb3IgYW4gYXJyYXkgb2YgUmVnRXhwLidcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkZWZhdWx0OiBbXVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigndGFibGVfdGFiX25hdmlnYXRpb24nLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdoaWdobGlnaHRfb25fZm9jdXMnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigneHNzX3Nhbml0aXphdGlvbicsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm9uKCdTY3JpcHRzTG9hZGVkJywgKCkgPT4ge1xuICAgICAgICByZWdpc3Rlck9wdGlvbignZGlyZWN0aW9uYWxpdHknLCB7XG4gICAgICAgICAgcHJvY2Vzc29yOiAnc3RyaW5nJyxcbiAgICAgICAgICBkZWZhdWx0OiBJMThuLmlzUnRsKCkgPyAncnRsJyA6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICAgICAgcmVnaXN0ZXJPcHRpb24oJ3BsYWNlaG9sZGVyJywge1xuICAgICAgICAgIHByb2Nlc3NvcjogJ3N0cmluZycsXG4gICAgICAgICAgZGVmYXVsdDogRE9NJGEuZ2V0QXR0cmliKGVkaXRvci5nZXRFbGVtZW50KCksICdwbGFjZWhvbGRlcicpXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRJZnJhbWVBdHRycyA9IG9wdGlvbignaWZyYW1lX2F0dHJzJyk7XG4gICAgY29uc3QgZ2V0RG9jVHlwZSA9IG9wdGlvbignZG9jdHlwZScpO1xuICAgIGNvbnN0IGdldERvY3VtZW50QmFzZVVybCA9IG9wdGlvbignZG9jdW1lbnRfYmFzZV91cmwnKTtcbiAgICBjb25zdCBnZXRCb2R5SWQgPSBvcHRpb24oJ2JvZHlfaWQnKTtcbiAgICBjb25zdCBnZXRCb2R5Q2xhc3MgPSBvcHRpb24oJ2JvZHlfY2xhc3MnKTtcbiAgICBjb25zdCBnZXRDb250ZW50U2VjdXJpdHlQb2xpY3kgPSBvcHRpb24oJ2NvbnRlbnRfc2VjdXJpdHlfcG9saWN5Jyk7XG4gICAgY29uc3Qgc2hvdWxkUHV0QnJJblByZSQxID0gb3B0aW9uKCdicl9pbl9wcmUnKTtcbiAgICBjb25zdCBnZXRGb3JjZWRSb290QmxvY2sgPSBvcHRpb24oJ2ZvcmNlZF9yb290X2Jsb2NrJyk7XG4gICAgY29uc3QgZ2V0Rm9yY2VkUm9vdEJsb2NrQXR0cnMgPSBvcHRpb24oJ2ZvcmNlZF9yb290X2Jsb2NrX2F0dHJzJyk7XG4gICAgY29uc3QgZ2V0TmV3bGluZUJlaGF2aW9yID0gb3B0aW9uKCduZXdsaW5lX2JlaGF2aW9yJyk7XG4gICAgY29uc3QgZ2V0QnJOZXdMaW5lU2VsZWN0b3IgPSBvcHRpb24oJ2JyX25ld2xpbmVfc2VsZWN0b3InKTtcbiAgICBjb25zdCBnZXROb05ld0xpbmVTZWxlY3RvciA9IG9wdGlvbignbm9fbmV3bGluZV9zZWxlY3RvcicpO1xuICAgIGNvbnN0IHNob3VsZEtlZXBTdHlsZXMgPSBvcHRpb24oJ2tlZXBfc3R5bGVzJyk7XG4gICAgY29uc3Qgc2hvdWxkRW5kQ29udGFpbmVyT25FbXB0eUJsb2NrID0gb3B0aW9uKCdlbmRfY29udGFpbmVyX29uX2VtcHR5X2Jsb2NrJyk7XG4gICAgY29uc3QgaXNBdXRvbWF0aWNVcGxvYWRzRW5hYmxlZCA9IG9wdGlvbignYXV0b21hdGljX3VwbG9hZHMnKTtcbiAgICBjb25zdCBzaG91bGRSZXVzZUZpbGVOYW1lID0gb3B0aW9uKCdpbWFnZXNfcmV1c2VfZmlsZW5hbWUnKTtcbiAgICBjb25zdCBzaG91bGRSZXBsYWNlQmxvYlVyaXMgPSBvcHRpb24oJ2ltYWdlc19yZXBsYWNlX2Jsb2JfdXJpcycpO1xuICAgIGNvbnN0IGdldEljb25QYWNrTmFtZSA9IG9wdGlvbignaWNvbnMnKTtcbiAgICBjb25zdCBnZXRJY29uc1VybCA9IG9wdGlvbignaWNvbnNfdXJsJyk7XG4gICAgY29uc3QgZ2V0SW1hZ2VVcGxvYWRVcmwgPSBvcHRpb24oJ2ltYWdlc191cGxvYWRfdXJsJyk7XG4gICAgY29uc3QgZ2V0SW1hZ2VVcGxvYWRCYXNlUGF0aCA9IG9wdGlvbignaW1hZ2VzX3VwbG9hZF9iYXNlX3BhdGgnKTtcbiAgICBjb25zdCBnZXRJbWFnZXNVcGxvYWRDcmVkZW50aWFscyA9IG9wdGlvbignaW1hZ2VzX3VwbG9hZF9jcmVkZW50aWFscycpO1xuICAgIGNvbnN0IGdldEltYWdlc1VwbG9hZEhhbmRsZXIgPSBvcHRpb24oJ2ltYWdlc191cGxvYWRfaGFuZGxlcicpO1xuICAgIGNvbnN0IHNob3VsZFVzZUNvbnRlbnRDc3NDb3JzID0gb3B0aW9uKCdjb250ZW50X2Nzc19jb3JzJyk7XG4gICAgY29uc3QgZ2V0UmVmZXJyZXJQb2xpY3kgPSBvcHRpb24oJ3JlZmVycmVyX3BvbGljeScpO1xuICAgIGNvbnN0IGdldExhbmd1YWdlQ29kZSA9IG9wdGlvbignbGFuZ3VhZ2UnKTtcbiAgICBjb25zdCBnZXRMYW5ndWFnZVVybCA9IG9wdGlvbignbGFuZ3VhZ2VfdXJsJyk7XG4gICAgY29uc3Qgc2hvdWxkSW5kZW50VXNlTWFyZ2luID0gb3B0aW9uKCdpbmRlbnRfdXNlX21hcmdpbicpO1xuICAgIGNvbnN0IGdldEluZGVudGF0aW9uID0gb3B0aW9uKCdpbmRlbnRhdGlvbicpO1xuICAgIGNvbnN0IGdldENvbnRlbnRDc3MgPSBvcHRpb24oJ2NvbnRlbnRfY3NzJyk7XG4gICAgY29uc3QgZ2V0Q29udGVudFN0eWxlID0gb3B0aW9uKCdjb250ZW50X3N0eWxlJyk7XG4gICAgY29uc3QgZ2V0Rm9udENzcyA9IG9wdGlvbignZm9udF9jc3MnKTtcbiAgICBjb25zdCBnZXREaXJlY3Rpb25hbGl0eSA9IG9wdGlvbignZGlyZWN0aW9uYWxpdHknKTtcbiAgICBjb25zdCBnZXRJbmxpbmVCb3VuZGFyeVNlbGVjdG9yID0gb3B0aW9uKCdpbmxpbmVfYm91bmRhcmllc19zZWxlY3RvcicpO1xuICAgIGNvbnN0IGdldE9iamVjdFJlc2l6aW5nID0gb3B0aW9uKCdvYmplY3RfcmVzaXppbmcnKTtcbiAgICBjb25zdCBnZXRSZXNpemVJbWdQcm9wb3J0aW9uYWwgPSBvcHRpb24oJ3Jlc2l6ZV9pbWdfcHJvcG9ydGlvbmFsJyk7XG4gICAgY29uc3QgZ2V0UGxhY2Vob2xkZXIgPSBvcHRpb24oJ3BsYWNlaG9sZGVyJyk7XG4gICAgY29uc3QgZ2V0RXZlbnRSb290ID0gb3B0aW9uKCdldmVudF9yb290Jyk7XG4gICAgY29uc3QgZ2V0U2VydmljZU1lc3NhZ2UgPSBvcHRpb24oJ3NlcnZpY2VfbWVzc2FnZScpO1xuICAgIGNvbnN0IGdldFRoZW1lID0gb3B0aW9uKCd0aGVtZScpO1xuICAgIGNvbnN0IGdldFRoZW1lVXJsID0gb3B0aW9uKCd0aGVtZV91cmwnKTtcbiAgICBjb25zdCBnZXRNb2RlbCA9IG9wdGlvbignbW9kZWwnKTtcbiAgICBjb25zdCBnZXRNb2RlbFVybCA9IG9wdGlvbignbW9kZWxfdXJsJyk7XG4gICAgY29uc3QgaXNJbmxpbmVCb3VuZGFyaWVzRW5hYmxlZCA9IG9wdGlvbignaW5saW5lX2JvdW5kYXJpZXMnKTtcbiAgICBjb25zdCBnZXRGb3JtYXRzID0gb3B0aW9uKCdmb3JtYXRzJyk7XG4gICAgY29uc3QgZ2V0UHJldmlld1N0eWxlcyA9IG9wdGlvbigncHJldmlld19zdHlsZXMnKTtcbiAgICBjb25zdCBjYW5Gb3JtYXRFbXB0eUxpbmVzID0gb3B0aW9uKCdmb3JtYXRfZW1wdHlfbGluZXMnKTtcbiAgICBjb25zdCBnZXRGb3JtYXROb25lZGl0YWJsZVNlbGVjdG9yID0gb3B0aW9uKCdmb3JtYXRfbm9uZWRpdGFibGVfc2VsZWN0b3InKTtcbiAgICBjb25zdCBnZXRDdXN0b21VaVNlbGVjdG9yID0gb3B0aW9uKCdjdXN0b21fdWlfc2VsZWN0b3InKTtcbiAgICBjb25zdCBpc0lubGluZSA9IG9wdGlvbignaW5saW5lJyk7XG4gICAgY29uc3QgaGFzSGlkZGVuSW5wdXQgPSBvcHRpb24oJ2hpZGRlbl9pbnB1dCcpO1xuICAgIGNvbnN0IHNob3VsZFBhdGNoU3VibWl0ID0gb3B0aW9uKCdzdWJtaXRfcGF0Y2gnKTtcbiAgICBjb25zdCBzaG91bGRBZGRGb3JtU3VibWl0VHJpZ2dlciA9IG9wdGlvbignYWRkX2Zvcm1fc3VibWl0X3RyaWdnZXInKTtcbiAgICBjb25zdCBzaG91bGRBZGRVbmxvYWRUcmlnZ2VyID0gb3B0aW9uKCdhZGRfdW5sb2FkX3RyaWdnZXInKTtcbiAgICBjb25zdCBnZXRDdXN0b21VbmRvUmVkb0xldmVscyA9IG9wdGlvbignY3VzdG9tX3VuZG9fcmVkb19sZXZlbHMnKTtcbiAgICBjb25zdCBzaG91bGREaXNhYmxlTm9kZUNoYW5nZSA9IG9wdGlvbignZGlzYWJsZV9ub2RlY2hhbmdlJyk7XG4gICAgY29uc3QgaXNSZWFkT25seSQxID0gb3B0aW9uKCdyZWFkb25seScpO1xuICAgIGNvbnN0IGhhc0NvbnRlbnRDc3NDb3JzID0gb3B0aW9uKCdjb250ZW50X2Nzc19jb3JzJyk7XG4gICAgY29uc3QgZ2V0UGx1Z2lucyA9IG9wdGlvbigncGx1Z2lucycpO1xuICAgIGNvbnN0IGdldEV4dGVybmFsUGx1Z2lucyQxID0gb3B0aW9uKCdleHRlcm5hbF9wbHVnaW5zJyk7XG4gICAgY29uc3Qgc2hvdWxkQmxvY2tVbnN1cHBvcnRlZERyb3AgPSBvcHRpb24oJ2Jsb2NrX3Vuc3VwcG9ydGVkX2Ryb3AnKTtcbiAgICBjb25zdCBpc1Zpc3VhbEFpZHNFbmFibGVkID0gb3B0aW9uKCd2aXN1YWwnKTtcbiAgICBjb25zdCBnZXRWaXN1YWxBaWRzVGFibGVDbGFzcyA9IG9wdGlvbigndmlzdWFsX3RhYmxlX2NsYXNzJyk7XG4gICAgY29uc3QgZ2V0VmlzdWFsQWlkc0FuY2hvckNsYXNzID0gb3B0aW9uKCd2aXN1YWxfYW5jaG9yX2NsYXNzJyk7XG4gICAgY29uc3QgZ2V0SWZyYW1lQXJpYVRleHQgPSBvcHRpb24oJ2lmcmFtZV9hcmlhX3RleHQnKTtcbiAgICBjb25zdCBnZXRTZXR1cENhbGxiYWNrID0gb3B0aW9uKCdzZXR1cCcpO1xuICAgIGNvbnN0IGdldEluaXRJbnN0YW5jZUNhbGxiYWNrID0gb3B0aW9uKCdpbml0X2luc3RhbmNlX2NhbGxiYWNrJyk7XG4gICAgY29uc3QgZ2V0VXJsQ29udmVydGVyQ2FsbGJhY2sgPSBvcHRpb24oJ3VybGNvbnZlcnRlcl9jYWxsYmFjaycpO1xuICAgIGNvbnN0IGdldEF1dG9Gb2N1cyA9IG9wdGlvbignYXV0b19mb2N1cycpO1xuICAgIGNvbnN0IHNob3VsZEJyb3dzZXJTcGVsbGNoZWNrID0gb3B0aW9uKCdicm93c2VyX3NwZWxsY2hlY2snKTtcbiAgICBjb25zdCBnZXRQcm90ZWN0ID0gb3B0aW9uKCdwcm90ZWN0Jyk7XG4gICAgY29uc3Qgc2hvdWxkUGFzdGVCbG9ja0Ryb3AgPSBvcHRpb24oJ3Bhc3RlX2Jsb2NrX2Ryb3AnKTtcbiAgICBjb25zdCBzaG91bGRQYXN0ZURhdGFJbWFnZXMgPSBvcHRpb24oJ3Bhc3RlX2RhdGFfaW1hZ2VzJyk7XG4gICAgY29uc3QgZ2V0UGFzdGVQcmVQcm9jZXNzID0gb3B0aW9uKCdwYXN0ZV9wcmVwcm9jZXNzJyk7XG4gICAgY29uc3QgZ2V0UGFzdGVQb3N0UHJvY2VzcyA9IG9wdGlvbigncGFzdGVfcG9zdHByb2Nlc3MnKTtcbiAgICBjb25zdCBnZXRQYXN0ZVdlYmtpdFN0eWxlcyA9IG9wdGlvbigncGFzdGVfd2Via2l0X3N0eWxlcycpO1xuICAgIGNvbnN0IHNob3VsZFBhc3RlUmVtb3ZlV2ViS2l0U3R5bGVzID0gb3B0aW9uKCdwYXN0ZV9yZW1vdmVfc3R5bGVzX2lmX3dlYmtpdCcpO1xuICAgIGNvbnN0IHNob3VsZFBhc3RlTWVyZ2VGb3JtYXRzID0gb3B0aW9uKCdwYXN0ZV9tZXJnZV9mb3JtYXRzJyk7XG4gICAgY29uc3QgaXNTbWFydFBhc3RlRW5hYmxlZCA9IG9wdGlvbignc21hcnRfcGFzdGUnKTtcbiAgICBjb25zdCBpc1Bhc3RlQXNUZXh0RW5hYmxlZCA9IG9wdGlvbigncGFzdGVfYXNfdGV4dCcpO1xuICAgIGNvbnN0IGdldFBhc3RlVGFiU3BhY2VzID0gb3B0aW9uKCdwYXN0ZV90YWJfc3BhY2VzJyk7XG4gICAgY29uc3Qgc2hvdWxkQWxsb3dIdG1sRGF0YVVybHMgPSBvcHRpb24oJ2FsbG93X2h0bWxfZGF0YV91cmxzJyk7XG4gICAgY29uc3QgZ2V0VGV4dFBhdHRlcm5zID0gb3B0aW9uKCd0ZXh0X3BhdHRlcm5zJyk7XG4gICAgY29uc3QgZ2V0VGV4dFBhdHRlcm5zTG9va3VwID0gb3B0aW9uKCd0ZXh0X3BhdHRlcm5zX2xvb2t1cCcpO1xuICAgIGNvbnN0IGdldE5vbkVkaXRhYmxlQ2xhc3MgPSBvcHRpb24oJ25vbmVkaXRhYmxlX2NsYXNzJyk7XG4gICAgY29uc3QgZ2V0RWRpdGFibGVDbGFzcyA9IG9wdGlvbignZWRpdGFibGVfY2xhc3MnKTtcbiAgICBjb25zdCBnZXROb25FZGl0YWJsZVJlZ0V4cHMgPSBvcHRpb24oJ25vbmVkaXRhYmxlX3JlZ2V4cCcpO1xuICAgIGNvbnN0IHNob3VsZFByZXNlcnZlQ0RhdGEgPSBvcHRpb24oJ3ByZXNlcnZlX2NkYXRhJyk7XG4gICAgY29uc3Qgc2hvdWxkSGlnaGxpZ2h0T25Gb2N1cyA9IG9wdGlvbignaGlnaGxpZ2h0X29uX2ZvY3VzJyk7XG4gICAgY29uc3Qgc2hvdWxkU2FuaXRpemVYc3MgPSBvcHRpb24oJ3hzc19zYW5pdGl6YXRpb24nKTtcbiAgICBjb25zdCBoYXNUZXh0UGF0dGVybnNMb29rdXAgPSBlZGl0b3IgPT4gZWRpdG9yLm9wdGlvbnMuaXNTZXQoJ3RleHRfcGF0dGVybnNfbG9va3VwJyk7XG4gICAgY29uc3QgZ2V0Rm9udFN0eWxlVmFsdWVzID0gZWRpdG9yID0+IFRvb2xzLmV4cGxvZGUoZWRpdG9yLm9wdGlvbnMuZ2V0KCdmb250X3NpemVfc3R5bGVfdmFsdWVzJykpO1xuICAgIGNvbnN0IGdldEZvbnRTaXplQ2xhc3NlcyA9IGVkaXRvciA9PiBUb29scy5leHBsb2RlKGVkaXRvci5vcHRpb25zLmdldCgnZm9udF9zaXplX2NsYXNzZXMnKSk7XG4gICAgY29uc3QgaXNFbmNvZGluZ1htbCA9IGVkaXRvciA9PiBlZGl0b3Iub3B0aW9ucy5nZXQoJ2VuY29kaW5nJykgPT09ICd4bWwnO1xuICAgIGNvbnN0IGdldEFsbG93ZWRJbWFnZUZpbGVUeXBlcyA9IGVkaXRvciA9PiBUb29scy5leHBsb2RlKGVkaXRvci5vcHRpb25zLmdldCgnaW1hZ2VzX2ZpbGVfdHlwZXMnKSk7XG4gICAgY29uc3QgaGFzVGFibGVUYWJOYXZpZ2F0aW9uID0gb3B0aW9uKCd0YWJsZV90YWJfbmF2aWdhdGlvbicpO1xuXG4gICAgY29uc3QgaXNFbGVtZW50JDMgPSBpc0VsZW1lbnQkNjtcbiAgICBjb25zdCBpc1RleHQkNSA9IGlzVGV4dCRhO1xuICAgIGNvbnN0IHJlbW92ZU5vZGUkMSA9IG5vZGUgPT4ge1xuICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB0cmltQ291bnQgPSB0ZXh0ID0+IHtcbiAgICAgIGNvbnN0IHRyaW1tZWRUZXh0ID0gdHJpbSQxKHRleHQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY291bnQ6IHRleHQubGVuZ3RoIC0gdHJpbW1lZFRleHQubGVuZ3RoLFxuICAgICAgICB0ZXh0OiB0cmltbWVkVGV4dFxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGRlbGV0ZVp3c3BDaGFycyA9IGNhcmV0Q29udGFpbmVyID0+IHtcbiAgICAgIGxldCBpZHg7XG4gICAgICB3aGlsZSAoKGlkeCA9IGNhcmV0Q29udGFpbmVyLmRhdGEubGFzdEluZGV4T2YoWldTUCQxKSkgIT09IC0xKSB7XG4gICAgICAgIGNhcmV0Q29udGFpbmVyLmRlbGV0ZURhdGEoaWR4LCAxKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZVVuY2hhbmdlZCA9IChjYXJldENvbnRhaW5lciwgcG9zKSA9PiB7XG4gICAgICByZW1vdmUkNChjYXJldENvbnRhaW5lcik7XG4gICAgICByZXR1cm4gcG9zO1xuICAgIH07XG4gICAgY29uc3QgcmVtb3ZlVGV4dEFuZFJlcG9zaXRpb24gPSAoY2FyZXRDb250YWluZXIsIHBvcykgPT4ge1xuICAgICAgY29uc3QgYmVmb3JlID0gdHJpbUNvdW50KGNhcmV0Q29udGFpbmVyLmRhdGEuc3Vic3RyKDAsIHBvcy5vZmZzZXQoKSkpO1xuICAgICAgY29uc3QgYWZ0ZXIgPSB0cmltQ291bnQoY2FyZXRDb250YWluZXIuZGF0YS5zdWJzdHIocG9zLm9mZnNldCgpKSk7XG4gICAgICBjb25zdCB0ZXh0ID0gYmVmb3JlLnRleHQgKyBhZnRlci50ZXh0O1xuICAgICAgaWYgKHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICBkZWxldGVad3NwQ2hhcnMoY2FyZXRDb250YWluZXIpO1xuICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbihjYXJldENvbnRhaW5lciwgcG9zLm9mZnNldCgpIC0gYmVmb3JlLmNvdW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVFbGVtZW50QW5kUmVwb3NpdGlvbiA9IChjYXJldENvbnRhaW5lciwgcG9zKSA9PiB7XG4gICAgICBjb25zdCBwYXJlbnROb2RlID0gcG9zLmNvbnRhaW5lcigpO1xuICAgICAgY29uc3QgbmV3UG9zaXRpb24gPSBpbmRleE9mJDEoZnJvbShwYXJlbnROb2RlLmNoaWxkTm9kZXMpLCBjYXJldENvbnRhaW5lcikubWFwKGluZGV4ID0+IHtcbiAgICAgICAgcmV0dXJuIGluZGV4IDwgcG9zLm9mZnNldCgpID8gQ2FyZXRQb3NpdGlvbihwYXJlbnROb2RlLCBwb3Mub2Zmc2V0KCkgLSAxKSA6IHBvcztcbiAgICAgIH0pLmdldE9yKHBvcyk7XG4gICAgICByZW1vdmUkNChjYXJldENvbnRhaW5lcik7XG4gICAgICByZXR1cm4gbmV3UG9zaXRpb247XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVUZXh0Q2FyZXRDb250YWluZXIgPSAoY2FyZXRDb250YWluZXIsIHBvcykgPT4gaXNUZXh0JDUoY2FyZXRDb250YWluZXIpICYmIHBvcy5jb250YWluZXIoKSA9PT0gY2FyZXRDb250YWluZXIgPyByZW1vdmVUZXh0QW5kUmVwb3NpdGlvbihjYXJldENvbnRhaW5lciwgcG9zKSA6IHJlbW92ZVVuY2hhbmdlZChjYXJldENvbnRhaW5lciwgcG9zKTtcbiAgICBjb25zdCByZW1vdmVFbGVtZW50Q2FyZXRDb250YWluZXIgPSAoY2FyZXRDb250YWluZXIsIHBvcykgPT4gcG9zLmNvbnRhaW5lcigpID09PSBjYXJldENvbnRhaW5lci5wYXJlbnROb2RlID8gcmVtb3ZlRWxlbWVudEFuZFJlcG9zaXRpb24oY2FyZXRDb250YWluZXIsIHBvcykgOiByZW1vdmVVbmNoYW5nZWQoY2FyZXRDb250YWluZXIsIHBvcyk7XG4gICAgY29uc3QgcmVtb3ZlQW5kUmVwb3NpdGlvbiA9IChjb250YWluZXIsIHBvcykgPT4gQ2FyZXRQb3NpdGlvbi5pc1RleHRQb3NpdGlvbihwb3MpID8gcmVtb3ZlVGV4dENhcmV0Q29udGFpbmVyKGNvbnRhaW5lciwgcG9zKSA6IHJlbW92ZUVsZW1lbnRDYXJldENvbnRhaW5lcihjb250YWluZXIsIHBvcyk7XG4gICAgY29uc3QgcmVtb3ZlJDQgPSBjYXJldENvbnRhaW5lck5vZGUgPT4ge1xuICAgICAgaWYgKGlzRWxlbWVudCQzKGNhcmV0Q29udGFpbmVyTm9kZSkgJiYgaXNDYXJldENvbnRhaW5lciQyKGNhcmV0Q29udGFpbmVyTm9kZSkpIHtcbiAgICAgICAgaWYgKGhhc0NvbnRlbnQoY2FyZXRDb250YWluZXJOb2RlKSkge1xuICAgICAgICAgIGNhcmV0Q29udGFpbmVyTm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtbWNlLWNhcmV0Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlTm9kZSQxKGNhcmV0Q29udGFpbmVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc1RleHQkNShjYXJldENvbnRhaW5lck5vZGUpKSB7XG4gICAgICAgIGRlbGV0ZVp3c3BDaGFycyhjYXJldENvbnRhaW5lck5vZGUpO1xuICAgICAgICBpZiAoY2FyZXRDb250YWluZXJOb2RlLmRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmVtb3ZlTm9kZSQxKGNhcmV0Q29udGFpbmVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgaXNDb250ZW50RWRpdGFibGVGYWxzZSQ4ID0gaXNDb250ZW50RWRpdGFibGVGYWxzZSRiO1xuICAgIGNvbnN0IGlzTWVkaWEkMSA9IGlzTWVkaWEkMjtcbiAgICBjb25zdCBpc1RhYmxlQ2VsbCQxID0gaXNUYWJsZUNlbGwkMztcbiAgICBjb25zdCBpbmxpbmVGYWtlQ2FyZXRTZWxlY3RvciA9ICcqW2NvbnRlbnRFZGl0YWJsZT1mYWxzZV0sdmlkZW8sYXVkaW8sZW1iZWQsb2JqZWN0JztcbiAgICBjb25zdCBnZXRBYnNvbHV0ZUNsaWVudFJlY3QgPSAocm9vdCwgZWxlbWVudCwgYmVmb3JlKSA9PiB7XG4gICAgICBjb25zdCBjbGllbnRSZWN0ID0gY29sbGFwc2UoZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgYmVmb3JlKTtcbiAgICAgIGxldCBzY3JvbGxYO1xuICAgICAgbGV0IHNjcm9sbFk7XG4gICAgICBpZiAocm9vdC50YWdOYW1lID09PSAnQk9EWScpIHtcbiAgICAgICAgY29uc3QgZG9jRWxtID0gcm9vdC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgc2Nyb2xsWCA9IHJvb3Quc2Nyb2xsTGVmdCB8fCBkb2NFbG0uc2Nyb2xsTGVmdDtcbiAgICAgICAgc2Nyb2xsWSA9IHJvb3Quc2Nyb2xsVG9wIHx8IGRvY0VsbS5zY3JvbGxUb3A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCByb290UmVjdCA9IHJvb3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHNjcm9sbFggPSByb290LnNjcm9sbExlZnQgLSByb290UmVjdC5sZWZ0O1xuICAgICAgICBzY3JvbGxZID0gcm9vdC5zY3JvbGxUb3AgLSByb290UmVjdC50b3A7XG4gICAgICB9XG4gICAgICBjbGllbnRSZWN0LmxlZnQgKz0gc2Nyb2xsWDtcbiAgICAgIGNsaWVudFJlY3QucmlnaHQgKz0gc2Nyb2xsWDtcbiAgICAgIGNsaWVudFJlY3QudG9wICs9IHNjcm9sbFk7XG4gICAgICBjbGllbnRSZWN0LmJvdHRvbSArPSBzY3JvbGxZO1xuICAgICAgY2xpZW50UmVjdC53aWR0aCA9IDE7XG4gICAgICBsZXQgbWFyZ2luID0gZWxlbWVudC5vZmZzZXRXaWR0aCAtIGVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgICBpZiAobWFyZ2luID4gMCkge1xuICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgbWFyZ2luICo9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGNsaWVudFJlY3QubGVmdCArPSBtYXJnaW47XG4gICAgICAgIGNsaWVudFJlY3QucmlnaHQgKz0gbWFyZ2luO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNsaWVudFJlY3Q7XG4gICAgfTtcbiAgICBjb25zdCB0cmltSW5saW5lQ2FyZXRDb250YWluZXJzID0gcm9vdCA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgY29uc3QgZmFrZUNhcmV0VGFyZ2V0Tm9kZXMgPSBkZXNjZW5kYW50cyhTdWdhckVsZW1lbnQuZnJvbURvbShyb290KSwgaW5saW5lRmFrZUNhcmV0U2VsZWN0b3IpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmYWtlQ2FyZXRUYXJnZXROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBub2RlID0gZmFrZUNhcmV0VGFyZ2V0Tm9kZXNbaV0uZG9tO1xuICAgICAgICBsZXQgc2libGluZyA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICBpZiAoZW5kc1dpdGhDYXJldENvbnRhaW5lciQxKHNpYmxpbmcpKSB7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IHNpYmxpbmcuZGF0YTtcbiAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIChfYSA9IHNpYmxpbmcucGFyZW50Tm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZUNoaWxkKHNpYmxpbmcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaWJsaW5nLmRlbGV0ZURhdGEoZGF0YS5sZW5ndGggLSAxLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2libGluZyA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIGlmIChzdGFydHNXaXRoQ2FyZXRDb250YWluZXIkMShzaWJsaW5nKSkge1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBzaWJsaW5nLmRhdGE7XG4gICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAoX2IgPSBzaWJsaW5nLnBhcmVudE5vZGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZW1vdmVDaGlsZChzaWJsaW5nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2libGluZy5kZWxldGVEYXRhKDAsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgRmFrZUNhcmV0ID0gKGVkaXRvciwgcm9vdCwgaXNCbG9jaywgaGFzRm9jdXMpID0+IHtcbiAgICAgIGNvbnN0IGxhc3RWaXN1YWxDYXJldCA9IHZhbHVlJDIoKTtcbiAgICAgIGxldCBjdXJzb3JJbnRlcnZhbDtcbiAgICAgIGxldCBjYXJldENvbnRhaW5lck5vZGU7XG4gICAgICBjb25zdCBjYXJldEJsb2NrID0gZ2V0Rm9yY2VkUm9vdEJsb2NrKGVkaXRvcik7XG4gICAgICBjb25zdCBkb20gPSBlZGl0b3IuZG9tO1xuICAgICAgY29uc3Qgc2hvdyA9IChiZWZvcmUsIGVsZW1lbnQpID0+IHtcbiAgICAgICAgbGV0IHJuZztcbiAgICAgICAgaGlkZSgpO1xuICAgICAgICBpZiAoaXNUYWJsZUNlbGwkMShlbGVtZW50KSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Jsb2NrKGVsZW1lbnQpKSB7XG4gICAgICAgICAgY29uc3QgY2FyZXRDb250YWluZXIgPSBpbnNlcnRCbG9jayhjYXJldEJsb2NrLCBlbGVtZW50LCBiZWZvcmUpO1xuICAgICAgICAgIGNvbnN0IGNsaWVudFJlY3QgPSBnZXRBYnNvbHV0ZUNsaWVudFJlY3Qocm9vdCwgZWxlbWVudCwgYmVmb3JlKTtcbiAgICAgICAgICBkb20uc2V0U3R5bGUoY2FyZXRDb250YWluZXIsICd0b3AnLCBjbGllbnRSZWN0LnRvcCk7XG4gICAgICAgICAgY2FyZXRDb250YWluZXJOb2RlID0gY2FyZXRDb250YWluZXI7XG4gICAgICAgICAgY29uc3QgY2FyZXQgPSBkb20uY3JlYXRlKCdkaXYnLCB7XG4gICAgICAgICAgICAnY2xhc3MnOiAnbWNlLXZpc3VhbC1jYXJldCcsXG4gICAgICAgICAgICAnZGF0YS1tY2UtYm9ndXMnOiAnYWxsJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGRvbS5zZXRTdHlsZXMoY2FyZXQsIHsgLi4uY2xpZW50UmVjdCB9KTtcbiAgICAgICAgICBkb20uYWRkKHJvb3QsIGNhcmV0KTtcbiAgICAgICAgICBsYXN0VmlzdWFsQ2FyZXQuc2V0KHtcbiAgICAgICAgICAgIGNhcmV0LFxuICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgIGJlZm9yZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChiZWZvcmUpIHtcbiAgICAgICAgICAgIGRvbS5hZGRDbGFzcyhjYXJldCwgJ21jZS12aXN1YWwtY2FyZXQtYmVmb3JlJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXJ0QmxpbmsoKTtcbiAgICAgICAgICBybmcgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICBybmcuc2V0U3RhcnQoY2FyZXRDb250YWluZXIsIDApO1xuICAgICAgICAgIHJuZy5zZXRFbmQoY2FyZXRDb250YWluZXIsIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhcmV0Q29udGFpbmVyTm9kZSA9IGluc2VydElubGluZSQxKGVsZW1lbnQsIGJlZm9yZSk7XG4gICAgICAgICAgcm5nID0gZWxlbWVudC5vd25lckRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgaWYgKGlzSW5saW5lRmFrZUNhcmV0VGFyZ2V0KGNhcmV0Q29udGFpbmVyTm9kZS5uZXh0U2libGluZykpIHtcbiAgICAgICAgICAgIHJuZy5zZXRTdGFydChjYXJldENvbnRhaW5lck5vZGUsIDApO1xuICAgICAgICAgICAgcm5nLnNldEVuZChjYXJldENvbnRhaW5lck5vZGUsIDApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBybmcuc2V0U3RhcnQoY2FyZXRDb250YWluZXJOb2RlLCAxKTtcbiAgICAgICAgICAgIHJuZy5zZXRFbmQoY2FyZXRDb250YWluZXJOb2RlLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJuZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm5nO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGhpZGUgPSAoKSA9PiB7XG4gICAgICAgIHRyaW1JbmxpbmVDYXJldENvbnRhaW5lcnMocm9vdCk7XG4gICAgICAgIGlmIChjYXJldENvbnRhaW5lck5vZGUpIHtcbiAgICAgICAgICByZW1vdmUkNChjYXJldENvbnRhaW5lck5vZGUpO1xuICAgICAgICAgIGNhcmV0Q29udGFpbmVyTm9kZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFZpc3VhbENhcmV0Lm9uKGNhcmV0U3RhdGUgPT4ge1xuICAgICAgICAgIGRvbS5yZW1vdmUoY2FyZXRTdGF0ZS5jYXJldCk7XG4gICAgICAgICAgbGFzdFZpc3VhbENhcmV0LmNsZWFyKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY3Vyc29ySW50ZXJ2YWwpIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKGN1cnNvckludGVydmFsKTtcbiAgICAgICAgICBjdXJzb3JJbnRlcnZhbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHN0YXJ0QmxpbmsgPSAoKSA9PiB7XG4gICAgICAgIGN1cnNvckludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgIGxhc3RWaXN1YWxDYXJldC5vbihjYXJldFN0YXRlID0+IHtcbiAgICAgICAgICAgIGlmIChoYXNGb2N1cygpKSB7XG4gICAgICAgICAgICAgIGRvbS50b2dnbGVDbGFzcyhjYXJldFN0YXRlLmNhcmV0LCAnbWNlLXZpc3VhbC1jYXJldC1oaWRkZW4nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRvbS5hZGRDbGFzcyhjYXJldFN0YXRlLmNhcmV0LCAnbWNlLXZpc3VhbC1jYXJldC1oaWRkZW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgNTAwKTtcbiAgICAgIH07XG4gICAgICBjb25zdCByZXBvc2l0aW9uID0gKCkgPT4ge1xuICAgICAgICBsYXN0VmlzdWFsQ2FyZXQub24oY2FyZXRTdGF0ZSA9PiB7XG4gICAgICAgICAgY29uc3QgY2xpZW50UmVjdCA9IGdldEFic29sdXRlQ2xpZW50UmVjdChyb290LCBjYXJldFN0YXRlLmVsZW1lbnQsIGNhcmV0U3RhdGUuYmVmb3JlKTtcbiAgICAgICAgICBkb20uc2V0U3R5bGVzKGNhcmV0U3RhdGUuY2FyZXQsIHsgLi4uY2xpZW50UmVjdCB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZGVzdHJveSA9ICgpID0+IGNsZWFySW50ZXJ2YWwoY3Vyc29ySW50ZXJ2YWwpO1xuICAgICAgY29uc3QgZ2V0Q3NzID0gKCkgPT4gJy5tY2UtdmlzdWFsLWNhcmV0IHsnICsgJ3Bvc2l0aW9uOiBhYnNvbHV0ZTsnICsgJ2JhY2tncm91bmQtY29sb3I6IGJsYWNrOycgKyAnYmFja2dyb3VuZC1jb2xvcjogY3VycmVudGNvbG9yOycgKyAnfScgKyAnLm1jZS12aXN1YWwtY2FyZXQtaGlkZGVuIHsnICsgJ2Rpc3BsYXk6IG5vbmU7JyArICd9JyArICcqW2RhdGEtbWNlLWNhcmV0XSB7JyArICdwb3NpdGlvbjogYWJzb2x1dGU7JyArICdsZWZ0OiAtMTAwMHB4OycgKyAncmlnaHQ6IGF1dG87JyArICd0b3A6IDA7JyArICdtYXJnaW46IDA7JyArICdwYWRkaW5nOiAwOycgKyAnfSc7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzaG93LFxuICAgICAgICBoaWRlLFxuICAgICAgICBnZXRDc3MsXG4gICAgICAgIHJlcG9zaXRpb24sXG4gICAgICAgIGRlc3Ryb3lcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBpc0Zha2VDYXJldFRhYmxlQnJvd3NlciA9ICgpID0+IEVudi5icm93c2VyLmlzRmlyZWZveCgpO1xuICAgIGNvbnN0IGlzSW5saW5lRmFrZUNhcmV0VGFyZ2V0ID0gbm9kZSA9PiBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJDgobm9kZSkgfHwgaXNNZWRpYSQxKG5vZGUpO1xuICAgIGNvbnN0IGlzRmFrZUNhcmV0VGFyZ2V0ID0gbm9kZSA9PiB7XG4gICAgICBjb25zdCBpc1RhcmdldCA9IGlzSW5saW5lRmFrZUNhcmV0VGFyZ2V0KG5vZGUpIHx8IGlzVGFibGUkMihub2RlKSAmJiBpc0Zha2VDYXJldFRhYmxlQnJvd3NlcigpO1xuICAgICAgcmV0dXJuIGlzVGFyZ2V0ICYmIHBhcmVudEVsZW1lbnQoU3VnYXJFbGVtZW50LmZyb21Eb20obm9kZSkpLmV4aXN0cyhpc0VkaXRhYmxlJDMpO1xuICAgIH07XG5cbiAgICBjb25zdCBpc0NvbnRlbnRFZGl0YWJsZVRydWUkMSA9IGlzQ29udGVudEVkaXRhYmxlVHJ1ZSQzO1xuICAgIGNvbnN0IGlzQ29udGVudEVkaXRhYmxlRmFsc2UkNyA9IGlzQ29udGVudEVkaXRhYmxlRmFsc2UkYjtcbiAgICBjb25zdCBpc01lZGlhID0gaXNNZWRpYSQyO1xuICAgIGNvbnN0IGlzQmxvY2tMaWtlID0gbWF0Y2hTdHlsZVZhbHVlcygnZGlzcGxheScsICdibG9jayB0YWJsZSB0YWJsZS1jZWxsIHRhYmxlLWNhcHRpb24gbGlzdC1pdGVtJyk7XG4gICAgY29uc3QgaXNDYXJldENvbnRhaW5lciA9IGlzQ2FyZXRDb250YWluZXIkMjtcbiAgICBjb25zdCBpc0NhcmV0Q29udGFpbmVyQmxvY2sgPSBpc0NhcmV0Q29udGFpbmVyQmxvY2skMTtcbiAgICBjb25zdCBpc0VsZW1lbnQkMiA9IGlzRWxlbWVudCQ2O1xuICAgIGNvbnN0IGlzVGV4dCQ0ID0gaXNUZXh0JGE7XG4gICAgY29uc3QgaXNDYXJldENhbmRpZGF0ZSQxID0gaXNDYXJldENhbmRpZGF0ZSQzO1xuICAgIGNvbnN0IGlzRm9yd2FyZHMgPSBkaXJlY3Rpb24gPT4gZGlyZWN0aW9uID4gMDtcbiAgICBjb25zdCBpc0JhY2t3YXJkcyA9IGRpcmVjdGlvbiA9PiBkaXJlY3Rpb24gPCAwO1xuICAgIGNvbnN0IHNraXBDYXJldENvbnRhaW5lcnMgPSAod2Fsaywgc2hhbGxvdykgPT4ge1xuICAgICAgbGV0IG5vZGU7XG4gICAgICB3aGlsZSAobm9kZSA9IHdhbGsoc2hhbGxvdykpIHtcbiAgICAgICAgaWYgKCFpc0NhcmV0Q29udGFpbmVyQmxvY2sobm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBjb25zdCBmaW5kTm9kZSA9IChub2RlLCBkaXJlY3Rpb24sIHByZWRpY2F0ZUZuLCByb290Tm9kZSwgc2hhbGxvdykgPT4ge1xuICAgICAgY29uc3Qgd2Fsa2VyID0gbmV3IERvbVRyZWVXYWxrZXIobm9kZSwgcm9vdE5vZGUpO1xuICAgICAgY29uc3QgaXNDZWZPckNhcmV0Q29udGFpbmVyID0gaXNDb250ZW50RWRpdGFibGVGYWxzZSQ3KG5vZGUpIHx8IGlzQ2FyZXRDb250YWluZXJCbG9jayhub2RlKTtcbiAgICAgIGxldCB0ZW1wTm9kZTtcbiAgICAgIGlmIChpc0JhY2t3YXJkcyhkaXJlY3Rpb24pKSB7XG4gICAgICAgIGlmIChpc0NlZk9yQ2FyZXRDb250YWluZXIpIHtcbiAgICAgICAgICB0ZW1wTm9kZSA9IHNraXBDYXJldENvbnRhaW5lcnMod2Fsa2VyLnByZXYuYmluZCh3YWxrZXIpLCB0cnVlKTtcbiAgICAgICAgICBpZiAocHJlZGljYXRlRm4odGVtcE5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGVtcE5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0ZW1wTm9kZSA9IHNraXBDYXJldENvbnRhaW5lcnMod2Fsa2VyLnByZXYuYmluZCh3YWxrZXIpLCBzaGFsbG93KSkge1xuICAgICAgICAgIGlmIChwcmVkaWNhdGVGbih0ZW1wTm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZW1wTm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0ZvcndhcmRzKGRpcmVjdGlvbikpIHtcbiAgICAgICAgaWYgKGlzQ2VmT3JDYXJldENvbnRhaW5lcikge1xuICAgICAgICAgIHRlbXBOb2RlID0gc2tpcENhcmV0Q29udGFpbmVycyh3YWxrZXIubmV4dC5iaW5kKHdhbGtlciksIHRydWUpO1xuICAgICAgICAgIGlmIChwcmVkaWNhdGVGbih0ZW1wTm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZW1wTm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRlbXBOb2RlID0gc2tpcENhcmV0Q29udGFpbmVycyh3YWxrZXIubmV4dC5iaW5kKHdhbGtlciksIHNoYWxsb3cpKSB7XG4gICAgICAgICAgaWYgKHByZWRpY2F0ZUZuKHRlbXBOb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRlbXBOb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBjb25zdCBnZXRFZGl0aW5nSG9zdCA9IChub2RlLCByb290Tm9kZSkgPT4ge1xuICAgICAgY29uc3QgaXNDRVRydWUgPSBub2RlID0+IGlzQ29udGVudEVkaXRhYmxlVHJ1ZSQxKG5vZGUuZG9tKTtcbiAgICAgIGNvbnN0IGlzUm9vdCA9IG5vZGUgPT4gbm9kZS5kb20gPT09IHJvb3ROb2RlO1xuICAgICAgcmV0dXJuIGFuY2VzdG9yJDQoU3VnYXJFbGVtZW50LmZyb21Eb20obm9kZSksIGlzQ0VUcnVlLCBpc1Jvb3QpLm1hcChlbG0gPT4gZWxtLmRvbSkuZ2V0T3Iocm9vdE5vZGUpO1xuICAgIH07XG4gICAgY29uc3QgZ2V0UGFyZW50QmxvY2skMyA9IChub2RlLCByb290Tm9kZSkgPT4ge1xuICAgICAgd2hpbGUgKG5vZGUgJiYgbm9kZSAhPT0gcm9vdE5vZGUpIHtcbiAgICAgICAgaWYgKGlzQmxvY2tMaWtlKG5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgY29uc3QgaXNJblNhbWVCbG9jayA9IChjYXJldFBvc2l0aW9uMSwgY2FyZXRQb3NpdGlvbjIsIHJvb3ROb2RlKSA9PiBnZXRQYXJlbnRCbG9jayQzKGNhcmV0UG9zaXRpb24xLmNvbnRhaW5lcigpLCByb290Tm9kZSkgPT09IGdldFBhcmVudEJsb2NrJDMoY2FyZXRQb3NpdGlvbjIuY29udGFpbmVyKCksIHJvb3ROb2RlKTtcbiAgICBjb25zdCBnZXRDaGlsZE5vZGVBdFJlbGF0aXZlT2Zmc2V0ID0gKHJlbGF0aXZlT2Zmc2V0LCBjYXJldFBvc2l0aW9uKSA9PiB7XG4gICAgICBpZiAoIWNhcmV0UG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGNhcmV0UG9zaXRpb24uY29udGFpbmVyKCk7XG4gICAgICBjb25zdCBvZmZzZXQgPSBjYXJldFBvc2l0aW9uLm9mZnNldCgpO1xuICAgICAgaWYgKCFpc0VsZW1lbnQkMihjb250YWluZXIpKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gT3B0aW9uYWwuZnJvbShjb250YWluZXIuY2hpbGROb2Rlc1tvZmZzZXQgKyByZWxhdGl2ZU9mZnNldF0pO1xuICAgIH07XG4gICAgY29uc3QgYmVmb3JlQWZ0ZXIgPSAoYmVmb3JlLCBub2RlKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBkb2MgPSAoX2EgPSBub2RlLm93bmVyRG9jdW1lbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRvY3VtZW50O1xuICAgICAgY29uc3QgcmFuZ2UgPSBkb2MuY3JlYXRlUmFuZ2UoKTtcbiAgICAgIGlmIChiZWZvcmUpIHtcbiAgICAgICAgcmFuZ2Uuc2V0U3RhcnRCZWZvcmUobm9kZSk7XG4gICAgICAgIHJhbmdlLnNldEVuZEJlZm9yZShub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhbmdlLnNldFN0YXJ0QWZ0ZXIobm9kZSk7XG4gICAgICAgIHJhbmdlLnNldEVuZEFmdGVyKG5vZGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH07XG4gICAgY29uc3QgaXNOb2Rlc0luU2FtZUJsb2NrID0gKHJvb3QsIG5vZGUxLCBub2RlMikgPT4gZ2V0UGFyZW50QmxvY2skMyhub2RlMSwgcm9vdCkgPT09IGdldFBhcmVudEJsb2NrJDMobm9kZTIsIHJvb3QpO1xuICAgIGNvbnN0IGxlYW4gPSAobGVmdCwgcm9vdCwgbm9kZSkgPT4ge1xuICAgICAgY29uc3Qgc2libGluZ05hbWUgPSBsZWZ0ID8gJ3ByZXZpb3VzU2libGluZycgOiAnbmV4dFNpYmxpbmcnO1xuICAgICAgbGV0IHRlbXBOb2RlID0gbm9kZTtcbiAgICAgIHdoaWxlICh0ZW1wTm9kZSAmJiB0ZW1wTm9kZSAhPT0gcm9vdCkge1xuICAgICAgICBsZXQgc2libGluZyA9IHRlbXBOb2RlW3NpYmxpbmdOYW1lXTtcbiAgICAgICAgaWYgKHNpYmxpbmcgJiYgaXNDYXJldENvbnRhaW5lcihzaWJsaW5nKSkge1xuICAgICAgICAgIHNpYmxpbmcgPSBzaWJsaW5nW3NpYmxpbmdOYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDb250ZW50RWRpdGFibGVGYWxzZSQ3KHNpYmxpbmcpIHx8IGlzTWVkaWEoc2libGluZykpIHtcbiAgICAgICAgICBpZiAoaXNOb2Rlc0luU2FtZUJsb2NrKHJvb3QsIHNpYmxpbmcsIHRlbXBOb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NhcmV0Q2FuZGlkYXRlJDEoc2libGluZykpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0ZW1wTm9kZSA9IHRlbXBOb2RlLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIGNvbnN0IGJlZm9yZSQyID0gY3VycnkoYmVmb3JlQWZ0ZXIsIHRydWUpO1xuICAgIGNvbnN0IGFmdGVyJDIgPSBjdXJyeShiZWZvcmVBZnRlciwgZmFsc2UpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZVJhbmdlID0gKGRpcmVjdGlvbiwgcm9vdCwgcmFuZ2UpID0+IHtcbiAgICAgIGxldCBub2RlO1xuICAgICAgY29uc3QgbGVhbkxlZnQgPSBjdXJyeShsZWFuLCB0cnVlLCByb290KTtcbiAgICAgIGNvbnN0IGxlYW5SaWdodCA9IGN1cnJ5KGxlYW4sIGZhbHNlLCByb290KTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gcmFuZ2Uuc3RhcnRPZmZzZXQ7XG4gICAgICBpZiAoaXNDYXJldENvbnRhaW5lckJsb2NrJDEoY29udGFpbmVyKSkge1xuICAgICAgICBjb25zdCBibG9jayA9IGlzVGV4dCQ0KGNvbnRhaW5lcikgPyBjb250YWluZXIucGFyZW50Tm9kZSA6IGNvbnRhaW5lcjtcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSBibG9jay5nZXRBdHRyaWJ1dGUoJ2RhdGEtbWNlLWNhcmV0Jyk7XG4gICAgICAgIGlmIChsb2NhdGlvbiA9PT0gJ2JlZm9yZScpIHtcbiAgICAgICAgICBub2RlID0gYmxvY2submV4dFNpYmxpbmc7XG4gICAgICAgICAgaWYgKGlzRmFrZUNhcmV0VGFyZ2V0KG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gYmVmb3JlJDIobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhdGlvbiA9PT0gJ2FmdGVyJykge1xuICAgICAgICAgIG5vZGUgPSBibG9jay5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgaWYgKGlzRmFrZUNhcmV0VGFyZ2V0KG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gYWZ0ZXIkMihub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghcmFuZ2UuY29sbGFwc2VkKSB7XG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1RleHQkYShjb250YWluZXIpKSB7XG4gICAgICAgIGlmIChpc0NhcmV0Q29udGFpbmVyKGNvbnRhaW5lcikpIHtcbiAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAxKSB7XG4gICAgICAgICAgICBub2RlID0gbGVhblJpZ2h0KGNvbnRhaW5lcik7XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICByZXR1cm4gYmVmb3JlJDIobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbGVhbkxlZnQoY29udGFpbmVyKTtcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhZnRlciQyKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAtMSkge1xuICAgICAgICAgICAgbm9kZSA9IGxlYW5MZWZ0KGNvbnRhaW5lcik7XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICByZXR1cm4gYWZ0ZXIkMihub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBsZWFuUmlnaHQoY29udGFpbmVyKTtcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBiZWZvcmUkMihub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmRzV2l0aENhcmV0Q29udGFpbmVyJDEoY29udGFpbmVyKSAmJiBvZmZzZXQgPj0gY29udGFpbmVyLmRhdGEubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09IDEpIHtcbiAgICAgICAgICAgIG5vZGUgPSBsZWFuUmlnaHQoY29udGFpbmVyKTtcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBiZWZvcmUkMihub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydHNXaXRoQ2FyZXRDb250YWluZXIkMShjb250YWluZXIpICYmIG9mZnNldCA8PSAxKSB7XG4gICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gLTEpIHtcbiAgICAgICAgICAgIG5vZGUgPSBsZWFuTGVmdChjb250YWluZXIpO1xuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGFmdGVyJDIobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2Zmc2V0ID09PSBjb250YWluZXIuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICBub2RlID0gbGVhblJpZ2h0KGNvbnRhaW5lcik7XG4gICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBiZWZvcmUkMihub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXQgPT09IDApIHtcbiAgICAgICAgICBub2RlID0gbGVhbkxlZnQoY29udGFpbmVyKTtcbiAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFmdGVyJDIobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH07XG4gICAgY29uc3QgZ2V0UmVsYXRpdmVDZWZFbG0gPSAoZm9yd2FyZCwgY2FyZXRQb3NpdGlvbikgPT4gZ2V0Q2hpbGROb2RlQXRSZWxhdGl2ZU9mZnNldChmb3J3YXJkID8gMCA6IC0xLCBjYXJldFBvc2l0aW9uKS5maWx0ZXIoaXNDb250ZW50RWRpdGFibGVGYWxzZSQ3KTtcbiAgICBjb25zdCBnZXROb3JtYWxpemVkUmFuZ2VFbmRQb2ludCA9IChkaXJlY3Rpb24sIHJvb3QsIHJhbmdlKSA9PiB7XG4gICAgICBjb25zdCBub3JtYWxpemVkUmFuZ2UgPSBub3JtYWxpemVSYW5nZShkaXJlY3Rpb24sIHJvb3QsIHJhbmdlKTtcbiAgICAgIHJldHVybiBkaXJlY3Rpb24gPT09IC0xID8gQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChub3JtYWxpemVkUmFuZ2UpIDogQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VFbmQobm9ybWFsaXplZFJhbmdlKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldEVsZW1lbnRGcm9tUG9zaXRpb24gPSBwb3MgPT4gT3B0aW9uYWwuZnJvbShwb3MuZ2V0Tm9kZSgpKS5tYXAoU3VnYXJFbGVtZW50LmZyb21Eb20pO1xuICAgIGNvbnN0IGdldEVsZW1lbnRGcm9tUHJldlBvc2l0aW9uID0gcG9zID0+IE9wdGlvbmFsLmZyb20ocG9zLmdldE5vZGUodHJ1ZSkpLm1hcChTdWdhckVsZW1lbnQuZnJvbURvbSk7XG4gICAgY29uc3QgZ2V0VmlzdWFsQ2FyZXRQb3NpdGlvbiA9ICh3YWxrRm4sIGNhcmV0UG9zaXRpb24pID0+IHtcbiAgICAgIGxldCBwb3MgPSBjYXJldFBvc2l0aW9uO1xuICAgICAgd2hpbGUgKHBvcyA9IHdhbGtGbihwb3MpKSB7XG4gICAgICAgIGlmIChwb3MuaXNWaXNpYmxlKCkpIHtcbiAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcG9zO1xuICAgIH07XG4gICAgY29uc3QgaXNNb3ZlSW5zaWRlU2FtZUJsb2NrID0gKGZyb20sIHRvKSA9PiB7XG4gICAgICBjb25zdCBpblNhbWVCbG9jayA9IGlzSW5TYW1lQmxvY2soZnJvbSwgdG8pO1xuICAgICAgaWYgKCFpblNhbWVCbG9jayAmJiBpc0JyJDYoZnJvbS5nZXROb2RlKCkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluU2FtZUJsb2NrO1xuICAgIH07XG5cbiAgICB2YXIgSERpcmVjdGlvbjtcbiAgICAoZnVuY3Rpb24gKEhEaXJlY3Rpb24pIHtcbiAgICAgIEhEaXJlY3Rpb25bSERpcmVjdGlvblsnQmFja3dhcmRzJ10gPSAtMV0gPSAnQmFja3dhcmRzJztcbiAgICAgIEhEaXJlY3Rpb25bSERpcmVjdGlvblsnRm9yd2FyZHMnXSA9IDFdID0gJ0ZvcndhcmRzJztcbiAgICB9KEhEaXJlY3Rpb24gfHwgKEhEaXJlY3Rpb24gPSB7fSkpKTtcbiAgICBjb25zdCBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJDYgPSBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJGI7XG4gICAgY29uc3QgaXNUZXh0JDMgPSBpc1RleHQkYTtcbiAgICBjb25zdCBpc0VsZW1lbnQkMSA9IGlzRWxlbWVudCQ2O1xuICAgIGNvbnN0IGlzQnIkMiA9IGlzQnIkNjtcbiAgICBjb25zdCBpc0NhcmV0Q2FuZGlkYXRlID0gaXNDYXJldENhbmRpZGF0ZSQzO1xuICAgIGNvbnN0IGlzQXRvbWljID0gaXNBdG9taWMkMTtcbiAgICBjb25zdCBpc0VkaXRhYmxlQ2FyZXRDYW5kaWRhdGUgPSBpc0VkaXRhYmxlQ2FyZXRDYW5kaWRhdGUkMTtcbiAgICBjb25zdCBnZXRQYXJlbnRzJDMgPSAobm9kZSwgcm9vdCkgPT4ge1xuICAgICAgY29uc3QgcGFyZW50cyA9IFtdO1xuICAgICAgbGV0IHRlbXBOb2RlID0gbm9kZTtcbiAgICAgIHdoaWxlICh0ZW1wTm9kZSAmJiB0ZW1wTm9kZSAhPT0gcm9vdCkge1xuICAgICAgICBwYXJlbnRzLnB1c2godGVtcE5vZGUpO1xuICAgICAgICB0ZW1wTm9kZSA9IHRlbXBOb2RlLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyZW50cztcbiAgICB9O1xuICAgIGNvbnN0IG5vZGVBdEluZGV4ID0gKGNvbnRhaW5lciwgb2Zmc2V0KSA9PiB7XG4gICAgICBpZiAoY29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSAmJiBvZmZzZXQgPCBjb250YWluZXIuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIGNvbnN0IGdldENhcmV0Q2FuZGlkYXRlUG9zaXRpb24gPSAoZGlyZWN0aW9uLCBub2RlKSA9PiB7XG4gICAgICBpZiAoaXNGb3J3YXJkcyhkaXJlY3Rpb24pKSB7XG4gICAgICAgIGlmIChpc0NhcmV0Q2FuZGlkYXRlKG5vZGUucHJldmlvdXNTaWJsaW5nKSAmJiAhaXNUZXh0JDMobm9kZS5wcmV2aW91c1NpYmxpbmcpKSB7XG4gICAgICAgICAgcmV0dXJuIENhcmV0UG9zaXRpb24uYmVmb3JlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1RleHQkMyhub2RlKSkge1xuICAgICAgICAgIHJldHVybiBDYXJldFBvc2l0aW9uKG5vZGUsIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNCYWNrd2FyZHMoZGlyZWN0aW9uKSkge1xuICAgICAgICBpZiAoaXNDYXJldENhbmRpZGF0ZShub2RlLm5leHRTaWJsaW5nKSAmJiAhaXNUZXh0JDMobm9kZS5uZXh0U2libGluZykpIHtcbiAgICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbi5hZnRlcihub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNUZXh0JDMobm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbihub2RlLCBub2RlLmRhdGEubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzQmFja3dhcmRzKGRpcmVjdGlvbikpIHtcbiAgICAgICAgaWYgKGlzQnIkMihub2RlKSkge1xuICAgICAgICAgIHJldHVybiBDYXJldFBvc2l0aW9uLmJlZm9yZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbi5hZnRlcihub2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBDYXJldFBvc2l0aW9uLmJlZm9yZShub2RlKTtcbiAgICB9O1xuICAgIGNvbnN0IG1vdmVGb3J3YXJkRnJvbUJyID0gKHJvb3QsIG5leHROb2RlKSA9PiB7XG4gICAgICBjb25zdCBuZXh0U2libGluZyA9IG5leHROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgaWYgKG5leHRTaWJsaW5nICYmIGlzQ2FyZXRDYW5kaWRhdGUobmV4dFNpYmxpbmcpKSB7XG4gICAgICAgIGlmIChpc1RleHQkMyhuZXh0U2libGluZykpIHtcbiAgICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbihuZXh0U2libGluZywgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIENhcmV0UG9zaXRpb24uYmVmb3JlKG5leHRTaWJsaW5nKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZpbmRDYXJldFBvc2l0aW9uJDEoSERpcmVjdGlvbi5Gb3J3YXJkcywgQ2FyZXRQb3NpdGlvbi5hZnRlcihuZXh0Tm9kZSksIHJvb3QpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZmluZENhcmV0UG9zaXRpb24kMSA9IChkaXJlY3Rpb24sIHN0YXJ0UG9zLCByb290KSA9PiB7XG4gICAgICBsZXQgbm9kZTtcbiAgICAgIGxldCBuZXh0Tm9kZTtcbiAgICAgIGxldCBpbm5lck5vZGU7XG4gICAgICBsZXQgY2FyZXRQb3NpdGlvbjtcbiAgICAgIGlmICghaXNFbGVtZW50JDEocm9vdCkgfHwgIXN0YXJ0UG9zKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0UG9zLmlzRXF1YWwoQ2FyZXRQb3NpdGlvbi5hZnRlcihyb290KSkgJiYgcm9vdC5sYXN0Q2hpbGQpIHtcbiAgICAgICAgY2FyZXRQb3NpdGlvbiA9IENhcmV0UG9zaXRpb24uYWZ0ZXIocm9vdC5sYXN0Q2hpbGQpO1xuICAgICAgICBpZiAoaXNCYWNrd2FyZHMoZGlyZWN0aW9uKSAmJiBpc0NhcmV0Q2FuZGlkYXRlKHJvb3QubGFzdENoaWxkKSAmJiBpc0VsZW1lbnQkMShyb290Lmxhc3RDaGlsZCkpIHtcbiAgICAgICAgICByZXR1cm4gaXNCciQyKHJvb3QubGFzdENoaWxkKSA/IENhcmV0UG9zaXRpb24uYmVmb3JlKHJvb3QubGFzdENoaWxkKSA6IGNhcmV0UG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcmV0UG9zaXRpb24gPSBzdGFydFBvcztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGNhcmV0UG9zaXRpb24uY29udGFpbmVyKCk7XG4gICAgICBsZXQgb2Zmc2V0ID0gY2FyZXRQb3NpdGlvbi5vZmZzZXQoKTtcbiAgICAgIGlmIChpc1RleHQkMyhjb250YWluZXIpKSB7XG4gICAgICAgIGlmIChpc0JhY2t3YXJkcyhkaXJlY3Rpb24pICYmIG9mZnNldCA+IDApIHtcbiAgICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbihjb250YWluZXIsIC0tb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNGb3J3YXJkcyhkaXJlY3Rpb24pICYmIG9mZnNldCA8IGNvbnRhaW5lci5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbihjb250YWluZXIsICsrb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gY29udGFpbmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzQmFja3dhcmRzKGRpcmVjdGlvbikgJiYgb2Zmc2V0ID4gMCkge1xuICAgICAgICAgIG5leHROb2RlID0gbm9kZUF0SW5kZXgoY29udGFpbmVyLCBvZmZzZXQgLSAxKTtcbiAgICAgICAgICBpZiAoaXNDYXJldENhbmRpZGF0ZShuZXh0Tm9kZSkpIHtcbiAgICAgICAgICAgIGlmICghaXNBdG9taWMobmV4dE5vZGUpKSB7XG4gICAgICAgICAgICAgIGlubmVyTm9kZSA9IGZpbmROb2RlKG5leHROb2RlLCBkaXJlY3Rpb24sIGlzRWRpdGFibGVDYXJldENhbmRpZGF0ZSwgbmV4dE5vZGUpO1xuICAgICAgICAgICAgICBpZiAoaW5uZXJOb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzVGV4dCQzKGlubmVyTm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBDYXJldFBvc2l0aW9uKGlubmVyTm9kZSwgaW5uZXJOb2RlLmRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIENhcmV0UG9zaXRpb24uYWZ0ZXIoaW5uZXJOb2RlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzVGV4dCQzKG5leHROb2RlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbihuZXh0Tm9kZSwgbmV4dE5vZGUuZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIENhcmV0UG9zaXRpb24uYmVmb3JlKG5leHROb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRm9yd2FyZHMoZGlyZWN0aW9uKSAmJiBvZmZzZXQgPCBjb250YWluZXIuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IG5vZGVBdEluZGV4KGNvbnRhaW5lciwgb2Zmc2V0KTtcbiAgICAgICAgICBpZiAoaXNDYXJldENhbmRpZGF0ZShuZXh0Tm9kZSkpIHtcbiAgICAgICAgICAgIGlmIChpc0JyJDIobmV4dE5vZGUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBtb3ZlRm9yd2FyZEZyb21Ccihyb290LCBuZXh0Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzQXRvbWljKG5leHROb2RlKSkge1xuICAgICAgICAgICAgICBpbm5lck5vZGUgPSBmaW5kTm9kZShuZXh0Tm9kZSwgZGlyZWN0aW9uLCBpc0VkaXRhYmxlQ2FyZXRDYW5kaWRhdGUsIG5leHROb2RlKTtcbiAgICAgICAgICAgICAgaWYgKGlubmVyTm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChpc1RleHQkMyhpbm5lck5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbihpbm5lck5vZGUsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbi5iZWZvcmUoaW5uZXJOb2RlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzVGV4dCQzKG5leHROb2RlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbihuZXh0Tm9kZSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbi5hZnRlcihuZXh0Tm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBuZXh0Tm9kZSA/IG5leHROb2RlIDogY2FyZXRQb3NpdGlvbi5nZXROb2RlKCk7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSAmJiAoaXNGb3J3YXJkcyhkaXJlY3Rpb24pICYmIGNhcmV0UG9zaXRpb24uaXNBdEVuZCgpIHx8IGlzQmFja3dhcmRzKGRpcmVjdGlvbikgJiYgY2FyZXRQb3NpdGlvbi5pc0F0U3RhcnQoKSkpIHtcbiAgICAgICAgbm9kZSA9IGZpbmROb2RlKG5vZGUsIGRpcmVjdGlvbiwgYWx3YXlzLCByb290LCB0cnVlKTtcbiAgICAgICAgaWYgKGlzRWRpdGFibGVDYXJldENhbmRpZGF0ZShub2RlLCByb290KSkge1xuICAgICAgICAgIHJldHVybiBnZXRDYXJldENhbmRpZGF0ZVBvc2l0aW9uKGRpcmVjdGlvbiwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5leHROb2RlID0gbm9kZSA/IGZpbmROb2RlKG5vZGUsIGRpcmVjdGlvbiwgaXNFZGl0YWJsZUNhcmV0Q2FuZGlkYXRlLCByb290KSA6IG5vZGU7XG4gICAgICBjb25zdCByb290Q29udGVudEVkaXRhYmxlRmFsc2VFbG0gPSBsYXN0JDIoZmlsdGVyJDUoZ2V0UGFyZW50cyQzKGNvbnRhaW5lciwgcm9vdCksIGlzQ29udGVudEVkaXRhYmxlRmFsc2UkNikpO1xuICAgICAgaWYgKHJvb3RDb250ZW50RWRpdGFibGVGYWxzZUVsbSAmJiAoIW5leHROb2RlIHx8ICFyb290Q29udGVudEVkaXRhYmxlRmFsc2VFbG0uY29udGFpbnMobmV4dE5vZGUpKSkge1xuICAgICAgICBpZiAoaXNGb3J3YXJkcyhkaXJlY3Rpb24pKSB7XG4gICAgICAgICAgY2FyZXRQb3NpdGlvbiA9IENhcmV0UG9zaXRpb24uYWZ0ZXIocm9vdENvbnRlbnRFZGl0YWJsZUZhbHNlRWxtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYXJldFBvc2l0aW9uID0gQ2FyZXRQb3NpdGlvbi5iZWZvcmUocm9vdENvbnRlbnRFZGl0YWJsZUZhbHNlRWxtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FyZXRQb3NpdGlvbjtcbiAgICAgIH1cbiAgICAgIGlmIChuZXh0Tm9kZSkge1xuICAgICAgICByZXR1cm4gZ2V0Q2FyZXRDYW5kaWRhdGVQb3NpdGlvbihkaXJlY3Rpb24sIG5leHROb2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgY29uc3QgQ2FyZXRXYWxrZXIgPSByb290ID0+ICh7XG4gICAgICBuZXh0OiBjYXJldFBvc2l0aW9uID0+IHtcbiAgICAgICAgcmV0dXJuIGZpbmRDYXJldFBvc2l0aW9uJDEoSERpcmVjdGlvbi5Gb3J3YXJkcywgY2FyZXRQb3NpdGlvbiwgcm9vdCk7XG4gICAgICB9LFxuICAgICAgcHJldjogY2FyZXRQb3NpdGlvbiA9PiB7XG4gICAgICAgIHJldHVybiBmaW5kQ2FyZXRQb3NpdGlvbiQxKEhEaXJlY3Rpb24uQmFja3dhcmRzLCBjYXJldFBvc2l0aW9uLCByb290KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHdhbGtUb1Bvc2l0aW9uSW4gPSAoZm9yd2FyZCwgcm9vdCwgc3RhcnQpID0+IHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZm9yd2FyZCA/IENhcmV0UG9zaXRpb24uYmVmb3JlKHN0YXJ0KSA6IENhcmV0UG9zaXRpb24uYWZ0ZXIoc3RhcnQpO1xuICAgICAgcmV0dXJuIGZyb21Qb3NpdGlvbihmb3J3YXJkLCByb290LCBwb3NpdGlvbik7XG4gICAgfTtcbiAgICBjb25zdCBhZnRlckVsZW1lbnQgPSBub2RlID0+IGlzQnIkNihub2RlKSA/IENhcmV0UG9zaXRpb24uYmVmb3JlKG5vZGUpIDogQ2FyZXRQb3NpdGlvbi5hZnRlcihub2RlKTtcbiAgICBjb25zdCBpc0JlZm9yZU9yU3RhcnQgPSBwb3NpdGlvbiA9PiB7XG4gICAgICBpZiAoQ2FyZXRQb3NpdGlvbi5pc1RleHRQb3NpdGlvbihwb3NpdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uLm9mZnNldCgpID09PSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGlzQ2FyZXRDYW5kaWRhdGUkMyhwb3NpdGlvbi5nZXROb2RlKCkpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaXNBZnRlck9yRW5kID0gcG9zaXRpb24gPT4ge1xuICAgICAgaWYgKENhcmV0UG9zaXRpb24uaXNUZXh0UG9zaXRpb24ocG9zaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHBvc2l0aW9uLmNvbnRhaW5lcigpO1xuICAgICAgICByZXR1cm4gcG9zaXRpb24ub2Zmc2V0KCkgPT09IGNvbnRhaW5lci5kYXRhLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpc0NhcmV0Q2FuZGlkYXRlJDMocG9zaXRpb24uZ2V0Tm9kZSh0cnVlKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpc0JlZm9yZUFmdGVyU2FtZUVsZW1lbnQgPSAoZnJvbSwgdG8pID0+ICFDYXJldFBvc2l0aW9uLmlzVGV4dFBvc2l0aW9uKGZyb20pICYmICFDYXJldFBvc2l0aW9uLmlzVGV4dFBvc2l0aW9uKHRvKSAmJiBmcm9tLmdldE5vZGUoKSA9PT0gdG8uZ2V0Tm9kZSh0cnVlKTtcbiAgICBjb25zdCBpc0F0QnIgPSBwb3NpdGlvbiA9PiAhQ2FyZXRQb3NpdGlvbi5pc1RleHRQb3NpdGlvbihwb3NpdGlvbikgJiYgaXNCciQ2KHBvc2l0aW9uLmdldE5vZGUoKSk7XG4gICAgY29uc3Qgc2hvdWxkU2tpcFBvc2l0aW9uID0gKGZvcndhcmQsIGZyb20sIHRvKSA9PiB7XG4gICAgICBpZiAoZm9yd2FyZCkge1xuICAgICAgICByZXR1cm4gIWlzQmVmb3JlQWZ0ZXJTYW1lRWxlbWVudChmcm9tLCB0bykgJiYgIWlzQXRCcihmcm9tKSAmJiBpc0FmdGVyT3JFbmQoZnJvbSkgJiYgaXNCZWZvcmVPclN0YXJ0KHRvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAhaXNCZWZvcmVBZnRlclNhbWVFbGVtZW50KHRvLCBmcm9tKSAmJiBpc0JlZm9yZU9yU3RhcnQoZnJvbSkgJiYgaXNBZnRlck9yRW5kKHRvKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGZyb21Qb3NpdGlvbiA9IChmb3J3YXJkLCByb290LCBwb3MpID0+IHtcbiAgICAgIGNvbnN0IHdhbGtlciA9IENhcmV0V2Fsa2VyKHJvb3QpO1xuICAgICAgcmV0dXJuIE9wdGlvbmFsLmZyb20oZm9yd2FyZCA/IHdhbGtlci5uZXh0KHBvcykgOiB3YWxrZXIucHJldihwb3MpKTtcbiAgICB9O1xuICAgIGNvbnN0IG5hdmlnYXRlID0gKGZvcndhcmQsIHJvb3QsIGZyb20pID0+IGZyb21Qb3NpdGlvbihmb3J3YXJkLCByb290LCBmcm9tKS5iaW5kKHRvID0+IHtcbiAgICAgIGlmIChpc0luU2FtZUJsb2NrKGZyb20sIHRvLCByb290KSAmJiBzaG91bGRTa2lwUG9zaXRpb24oZm9yd2FyZCwgZnJvbSwgdG8pKSB7XG4gICAgICAgIHJldHVybiBmcm9tUG9zaXRpb24oZm9yd2FyZCwgcm9vdCwgdG8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUodG8pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IG5hdmlnYXRlSWdub3JlID0gKGZvcndhcmQsIHJvb3QsIGZyb20sIGlnbm9yZUZpbHRlcikgPT4gbmF2aWdhdGUoZm9yd2FyZCwgcm9vdCwgZnJvbSkuYmluZChwb3MgPT4gaWdub3JlRmlsdGVyKHBvcykgPyBuYXZpZ2F0ZUlnbm9yZShmb3J3YXJkLCByb290LCBwb3MsIGlnbm9yZUZpbHRlcikgOiBPcHRpb25hbC5zb21lKHBvcykpO1xuICAgIGNvbnN0IHBvc2l0aW9uSW4gPSAoZm9yd2FyZCwgZWxlbWVudCkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnROb2RlID0gZm9yd2FyZCA/IGVsZW1lbnQuZmlyc3RDaGlsZCA6IGVsZW1lbnQubGFzdENoaWxkO1xuICAgICAgaWYgKGlzVGV4dCRhKHN0YXJ0Tm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoQ2FyZXRQb3NpdGlvbihzdGFydE5vZGUsIGZvcndhcmQgPyAwIDogc3RhcnROb2RlLmRhdGEubGVuZ3RoKSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0Tm9kZSkge1xuICAgICAgICBpZiAoaXNDYXJldENhbmRpZGF0ZSQzKHN0YXJ0Tm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShmb3J3YXJkID8gQ2FyZXRQb3NpdGlvbi5iZWZvcmUoc3RhcnROb2RlKSA6IGFmdGVyRWxlbWVudChzdGFydE5vZGUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gd2Fsa1RvUG9zaXRpb25Jbihmb3J3YXJkLCBlbGVtZW50LCBzdGFydE5vZGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbmV4dFBvc2l0aW9uID0gY3VycnkoZnJvbVBvc2l0aW9uLCB0cnVlKTtcbiAgICBjb25zdCBwcmV2UG9zaXRpb24gPSBjdXJyeShmcm9tUG9zaXRpb24sIGZhbHNlKTtcbiAgICBjb25zdCBmaXJzdFBvc2l0aW9uSW4gPSBjdXJyeShwb3NpdGlvbkluLCB0cnVlKTtcbiAgICBjb25zdCBsYXN0UG9zaXRpb25JbiA9IGN1cnJ5KHBvc2l0aW9uSW4sIGZhbHNlKTtcblxuICAgIGNvbnN0IENBUkVUX0lEID0gJ19tY2VfY2FyZXQnO1xuICAgIGNvbnN0IGlzQ2FyZXROb2RlID0gbm9kZSA9PiBpc0VsZW1lbnQkNihub2RlKSAmJiBub2RlLmlkID09PSBDQVJFVF9JRDtcbiAgICBjb25zdCBnZXRQYXJlbnRDYXJldENvbnRhaW5lciA9IChib2R5LCBub2RlKSA9PiB7XG4gICAgICBsZXQgY3VycmVudE5vZGUgPSBub2RlO1xuICAgICAgd2hpbGUgKGN1cnJlbnROb2RlICYmIGN1cnJlbnROb2RlICE9PSBib2R5KSB7XG4gICAgICAgIGlmIChpc0NhcmV0Tm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIGNvbnN0IGlzU3RyaW5nUGF0aEJvb2ttYXJrID0gYm9va21hcmsgPT4gaXNTdHJpbmcoYm9va21hcmsuc3RhcnQpO1xuICAgIGNvbnN0IGlzUmFuZ2VCb29rbWFyayA9IGJvb2ttYXJrID0+IGhhcyQyKGJvb2ttYXJrLCAncm5nJyk7XG4gICAgY29uc3QgaXNJZEJvb2ttYXJrID0gYm9va21hcmsgPT4gaGFzJDIoYm9va21hcmssICdpZCcpO1xuICAgIGNvbnN0IGlzSW5kZXhCb29rbWFyayA9IGJvb2ttYXJrID0+IGhhcyQyKGJvb2ttYXJrLCAnbmFtZScpO1xuICAgIGNvbnN0IGlzUGF0aEJvb2ttYXJrID0gYm9va21hcmsgPT4gVG9vbHMuaXNBcnJheShib29rbWFyay5zdGFydCk7XG5cbiAgICBjb25zdCBpc0ZvcndhcmRCb29rbWFyayA9IGJvb2ttYXJrID0+ICFpc0luZGV4Qm9va21hcmsoYm9va21hcmspICYmIGlzQm9vbGVhbihib29rbWFyay5mb3J3YXJkKSA/IGJvb2ttYXJrLmZvcndhcmQgOiB0cnVlO1xuICAgIGNvbnN0IGFkZEJvZ3VzID0gKGRvbSwgbm9kZSkgPT4ge1xuICAgICAgaWYgKGlzRWxlbWVudCQ2KG5vZGUpICYmIGRvbS5pc0Jsb2NrKG5vZGUpICYmICFub2RlLmlubmVySFRNTCkge1xuICAgICAgICBub2RlLmlubmVySFRNTCA9ICc8YnIgZGF0YS1tY2UtYm9ndXM9XCIxXCIgLz4nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgICBjb25zdCByZXNvbHZlQ2FyZXRQb3NpdGlvbkJvb2ttYXJrID0gKGRvbSwgYm9va21hcmspID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0UG9zID0gT3B0aW9uYWwuZnJvbShyZXNvbHZlJDEoZG9tLmdldFJvb3QoKSwgYm9va21hcmsuc3RhcnQpKTtcbiAgICAgIGNvbnN0IGVuZFBvcyA9IE9wdGlvbmFsLmZyb20ocmVzb2x2ZSQxKGRvbS5nZXRSb290KCksIGJvb2ttYXJrLmVuZCkpO1xuICAgICAgcmV0dXJuIGxpZnQyKHN0YXJ0UG9zLCBlbmRQb3MsIChzdGFydCwgZW5kKSA9PiB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gZG9tLmNyZWF0ZVJuZygpO1xuICAgICAgICByYW5nZS5zZXRTdGFydChzdGFydC5jb250YWluZXIoKSwgc3RhcnQub2Zmc2V0KCkpO1xuICAgICAgICByYW5nZS5zZXRFbmQoZW5kLmNvbnRhaW5lcigpLCBlbmQub2Zmc2V0KCkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJhbmdlLFxuICAgICAgICAgIGZvcndhcmQ6IGlzRm9yd2FyZEJvb2ttYXJrKGJvb2ttYXJrKVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBpbnNlcnRad3NwID0gKG5vZGUsIHJuZykgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgZG9jID0gKF9hID0gbm9kZS5vd25lckRvY3VtZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkb2N1bWVudDtcbiAgICAgIGNvbnN0IHRleHROb2RlID0gZG9jLmNyZWF0ZVRleHROb2RlKFpXU1AkMSk7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKHRleHROb2RlKTtcbiAgICAgIHJuZy5zZXRTdGFydCh0ZXh0Tm9kZSwgMCk7XG4gICAgICBybmcuc2V0RW5kKHRleHROb2RlLCAwKTtcbiAgICB9O1xuICAgIGNvbnN0IGlzRW1wdHkkMSA9IG5vZGUgPT4gIW5vZGUuaGFzQ2hpbGROb2RlcygpO1xuICAgIGNvbnN0IHRyeUZpbmRSYW5nZVBvc2l0aW9uID0gKG5vZGUsIHJuZykgPT4gbGFzdFBvc2l0aW9uSW4obm9kZSkuZm9sZChuZXZlciwgcG9zID0+IHtcbiAgICAgIHJuZy5zZXRTdGFydChwb3MuY29udGFpbmVyKCksIHBvcy5vZmZzZXQoKSk7XG4gICAgICBybmcuc2V0RW5kKHBvcy5jb250YWluZXIoKSwgcG9zLm9mZnNldCgpKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIGNvbnN0IHBhZEVtcHR5Q2FyZXRDb250YWluZXIgPSAocm9vdCwgbm9kZSwgcm5nKSA9PiB7XG4gICAgICBpZiAoaXNFbXB0eSQxKG5vZGUpICYmIGdldFBhcmVudENhcmV0Q29udGFpbmVyKHJvb3QsIG5vZGUpKSB7XG4gICAgICAgIGluc2VydFp3c3Aobm9kZSwgcm5nKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzZXRFbmRQb2ludCA9IChkb20sIHN0YXJ0LCBib29rbWFyaywgcm5nKSA9PiB7XG4gICAgICBjb25zdCBwb2ludCA9IGJvb2ttYXJrW3N0YXJ0ID8gJ3N0YXJ0JyA6ICdlbmQnXTtcbiAgICAgIGNvbnN0IHJvb3QgPSBkb20uZ2V0Um9vdCgpO1xuICAgICAgaWYgKHBvaW50KSB7XG4gICAgICAgIGxldCBub2RlID0gcm9vdDtcbiAgICAgICAgbGV0IG9mZnNldCA9IHBvaW50WzBdO1xuICAgICAgICBmb3IgKGxldCBpID0gcG9pbnQubGVuZ3RoIC0gMTsgbm9kZSAmJiBpID49IDE7IGktLSkge1xuICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZE5vZGVzO1xuICAgICAgICAgIGlmIChwYWRFbXB0eUNhcmV0Q29udGFpbmVyKHJvb3QsIG5vZGUsIHJuZykpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocG9pbnRbaV0gPiBjaGlsZHJlbi5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBpZiAocGFkRW1wdHlDYXJldENvbnRhaW5lcihyb290LCBub2RlLCBybmcpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRyeUZpbmRSYW5nZVBvc2l0aW9uKG5vZGUsIHJuZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUgPSBjaGlsZHJlbltwb2ludFtpXV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVGV4dCRhKG5vZGUpKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gTWF0aC5taW4ocG9pbnRbMF0sIG5vZGUuZGF0YS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0VsZW1lbnQkNihub2RlKSkge1xuICAgICAgICAgIG9mZnNldCA9IE1hdGgubWluKHBvaW50WzBdLCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICBybmcuc2V0U3RhcnQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBybmcuc2V0RW5kKG5vZGUsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgY29uc3QgaXNWYWxpZFRleHROb2RlID0gbm9kZSA9PiBpc1RleHQkYShub2RlKSAmJiBub2RlLmRhdGEubGVuZ3RoID4gMDtcbiAgICBjb25zdCByZXN0b3JlRW5kUG9pbnQgPSAoZG9tLCBzdWZmaXgsIGJvb2ttYXJrKSA9PiB7XG4gICAgICBjb25zdCBtYXJrZXIgPSBkb20uZ2V0KGJvb2ttYXJrLmlkICsgJ18nICsgc3VmZml4KTtcbiAgICAgIGNvbnN0IG1hcmtlclBhcmVudCA9IG1hcmtlciA9PT0gbnVsbCB8fCBtYXJrZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcmtlci5wYXJlbnROb2RlO1xuICAgICAgY29uc3Qga2VlcCA9IGJvb2ttYXJrLmtlZXA7XG4gICAgICBpZiAobWFya2VyICYmIG1hcmtlclBhcmVudCkge1xuICAgICAgICBsZXQgY29udGFpbmVyO1xuICAgICAgICBsZXQgb2Zmc2V0O1xuICAgICAgICBpZiAoc3VmZml4ID09PSAnc3RhcnQnKSB7XG4gICAgICAgICAgaWYgKCFrZWVwKSB7XG4gICAgICAgICAgICBjb250YWluZXIgPSBtYXJrZXJQYXJlbnQ7XG4gICAgICAgICAgICBvZmZzZXQgPSBkb20ubm9kZUluZGV4KG1hcmtlcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChtYXJrZXIuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgICAgIGNvbnRhaW5lciA9IG1hcmtlci5maXJzdENoaWxkO1xuICAgICAgICAgICAgICBvZmZzZXQgPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1ZhbGlkVGV4dE5vZGUobWFya2VyLm5leHRTaWJsaW5nKSkge1xuICAgICAgICAgICAgICBjb250YWluZXIgPSBtYXJrZXIubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzVmFsaWRUZXh0Tm9kZShtYXJrZXIucHJldmlvdXNTaWJsaW5nKSkge1xuICAgICAgICAgICAgICBjb250YWluZXIgPSBtYXJrZXIucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICBvZmZzZXQgPSBtYXJrZXIucHJldmlvdXNTaWJsaW5nLmRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29udGFpbmVyID0gbWFya2VyUGFyZW50O1xuICAgICAgICAgICAgICBvZmZzZXQgPSBkb20ubm9kZUluZGV4KG1hcmtlcikgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIWtlZXApIHtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IG1hcmtlclBhcmVudDtcbiAgICAgICAgICAgIG9mZnNldCA9IGRvbS5ub2RlSW5kZXgobWFya2VyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG1hcmtlci5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICAgICAgY29udGFpbmVyID0gbWFya2VyLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgIG9mZnNldCA9IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzVmFsaWRUZXh0Tm9kZShtYXJrZXIucHJldmlvdXNTaWJsaW5nKSkge1xuICAgICAgICAgICAgICBjb250YWluZXIgPSBtYXJrZXIucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICBvZmZzZXQgPSBtYXJrZXIucHJldmlvdXNTaWJsaW5nLmRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29udGFpbmVyID0gbWFya2VyUGFyZW50O1xuICAgICAgICAgICAgICBvZmZzZXQgPSBkb20ubm9kZUluZGV4KG1hcmtlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgha2VlcCkge1xuICAgICAgICAgIGNvbnN0IHByZXYgPSBtYXJrZXIucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgIGNvbnN0IG5leHQgPSBtYXJrZXIubmV4dFNpYmxpbmc7XG4gICAgICAgICAgVG9vbHMuZWFjaChUb29scy5ncmVwKG1hcmtlci5jaGlsZE5vZGVzKSwgbm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNUZXh0JGEobm9kZSkpIHtcbiAgICAgICAgICAgICAgbm9kZS5kYXRhID0gbm9kZS5kYXRhLnJlcGxhY2UoL1xcdUZFRkYvZywgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxldCBvdGhlck1hcmtlcjtcbiAgICAgICAgICB3aGlsZSAob3RoZXJNYXJrZXIgPSBkb20uZ2V0KGJvb2ttYXJrLmlkICsgJ18nICsgc3VmZml4KSkge1xuICAgICAgICAgICAgZG9tLnJlbW92ZShvdGhlck1hcmtlciwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1RleHQkYShuZXh0KSAmJiBpc1RleHQkYShwcmV2KSAmJiAhRW52LmJyb3dzZXIuaXNPcGVyYSgpKSB7XG4gICAgICAgICAgICBjb25zdCBpZHggPSBwcmV2LmRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgcHJldi5hcHBlbmREYXRhKG5leHQuZGF0YSk7XG4gICAgICAgICAgICBkb20ucmVtb3ZlKG5leHQpO1xuICAgICAgICAgICAgY29udGFpbmVyID0gcHJldjtcbiAgICAgICAgICAgIG9mZnNldCA9IGlkeDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoQ2FyZXRQb3NpdGlvbihjb250YWluZXIsIG9mZnNldCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlc29sdmVQYXRocyA9IChkb20sIGJvb2ttYXJrKSA9PiB7XG4gICAgICBjb25zdCByYW5nZSA9IGRvbS5jcmVhdGVSbmcoKTtcbiAgICAgIGlmIChzZXRFbmRQb2ludChkb20sIHRydWUsIGJvb2ttYXJrLCByYW5nZSkgJiYgc2V0RW5kUG9pbnQoZG9tLCBmYWxzZSwgYm9va21hcmssIHJhbmdlKSkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZSh7XG4gICAgICAgICAgcmFuZ2UsXG4gICAgICAgICAgZm9yd2FyZDogaXNGb3J3YXJkQm9va21hcmsoYm9va21hcmspXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlc29sdmVJZCA9IChkb20sIGJvb2ttYXJrKSA9PiB7XG4gICAgICBjb25zdCBzdGFydFBvcyA9IHJlc3RvcmVFbmRQb2ludChkb20sICdzdGFydCcsIGJvb2ttYXJrKTtcbiAgICAgIGNvbnN0IGVuZFBvcyA9IHJlc3RvcmVFbmRQb2ludChkb20sICdlbmQnLCBib29rbWFyayk7XG4gICAgICByZXR1cm4gbGlmdDIoc3RhcnRQb3MsIGVuZFBvcy5vcihzdGFydFBvcyksIChzcG9zLCBlcG9zKSA9PiB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gZG9tLmNyZWF0ZVJuZygpO1xuICAgICAgICByYW5nZS5zZXRTdGFydChhZGRCb2d1cyhkb20sIHNwb3MuY29udGFpbmVyKCkpLCBzcG9zLm9mZnNldCgpKTtcbiAgICAgICAgcmFuZ2Uuc2V0RW5kKGFkZEJvZ3VzKGRvbSwgZXBvcy5jb250YWluZXIoKSksIGVwb3Mub2Zmc2V0KCkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJhbmdlLFxuICAgICAgICAgIGZvcndhcmQ6IGlzRm9yd2FyZEJvb2ttYXJrKGJvb2ttYXJrKVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCByZXNvbHZlSW5kZXggPSAoZG9tLCBib29rbWFyaykgPT4gT3B0aW9uYWwuZnJvbShkb20uc2VsZWN0KGJvb2ttYXJrLm5hbWUpW2Jvb2ttYXJrLmluZGV4XSkubWFwKGVsbSA9PiB7XG4gICAgICBjb25zdCByYW5nZSA9IGRvbS5jcmVhdGVSbmcoKTtcbiAgICAgIHJhbmdlLnNlbGVjdE5vZGUoZWxtKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJhbmdlLFxuICAgICAgICBmb3J3YXJkOiB0cnVlXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IHJlc29sdmUgPSAoc2VsZWN0aW9uLCBib29rbWFyaykgPT4ge1xuICAgICAgY29uc3QgZG9tID0gc2VsZWN0aW9uLmRvbTtcbiAgICAgIGlmIChib29rbWFyaykge1xuICAgICAgICBpZiAoaXNQYXRoQm9va21hcmsoYm9va21hcmspKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmVQYXRocyhkb20sIGJvb2ttYXJrKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1N0cmluZ1BhdGhCb29rbWFyayhib29rbWFyaykpIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZUNhcmV0UG9zaXRpb25Cb29rbWFyayhkb20sIGJvb2ttYXJrKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0lkQm9va21hcmsoYm9va21hcmspKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmVJZChkb20sIGJvb2ttYXJrKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0luZGV4Qm9va21hcmsoYm9va21hcmspKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmVJbmRleChkb20sIGJvb2ttYXJrKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1JhbmdlQm9va21hcmsoYm9va21hcmspKSB7XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoe1xuICAgICAgICAgICAgcmFuZ2U6IGJvb2ttYXJrLnJuZyxcbiAgICAgICAgICAgIGZvcndhcmQ6IGlzRm9yd2FyZEJvb2ttYXJrKGJvb2ttYXJrKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgIH07XG5cbiAgICBjb25zdCBnZXRCb29rbWFyayQxID0gKHNlbGVjdGlvbiwgdHlwZSwgbm9ybWFsaXplZCkgPT4ge1xuICAgICAgcmV0dXJuIGdldEJvb2ttYXJrJDIoc2VsZWN0aW9uLCB0eXBlLCBub3JtYWxpemVkKTtcbiAgICB9O1xuICAgIGNvbnN0IG1vdmVUb0Jvb2ttYXJrID0gKHNlbGVjdGlvbiwgYm9va21hcmspID0+IHtcbiAgICAgIHJlc29sdmUoc2VsZWN0aW9uLCBib29rbWFyaykuZWFjaCgoe3JhbmdlLCBmb3J3YXJkfSkgPT4ge1xuICAgICAgICBzZWxlY3Rpb24uc2V0Um5nKHJhbmdlLCBmb3J3YXJkKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgaXNCb29rbWFya05vZGUkMSA9IG5vZGUgPT4ge1xuICAgICAgcmV0dXJuIGlzRWxlbWVudCQ2KG5vZGUpICYmIG5vZGUudGFnTmFtZSA9PT0gJ1NQQU4nICYmIG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLW1jZS10eXBlJykgPT09ICdib29rbWFyayc7XG4gICAgfTtcblxuICAgIGNvbnN0IGlzID0gZXhwZWN0ZWQgPT4gYWN0dWFsID0+IGV4cGVjdGVkID09PSBhY3R1YWw7XG4gICAgY29uc3QgaXNOYnNwID0gaXMobmJzcCk7XG4gICAgY29uc3QgaXNXaGl0ZVNwYWNlID0gY2hyID0+IGNociAhPT0gJycgJiYgJyBcXGZcXG5cXHJcXHRcXHgwQicuaW5kZXhPZihjaHIpICE9PSAtMTtcbiAgICBjb25zdCBpc0NvbnRlbnQgPSBjaHIgPT4gIWlzV2hpdGVTcGFjZShjaHIpICYmICFpc05ic3AoY2hyKSAmJiAhaXNad3NwJDEoY2hyKTtcblxuICAgIGNvbnN0IGhleENvbG91ciA9IHZhbHVlID0+ICh7IHZhbHVlOiBub3JtYWxpemVIZXgodmFsdWUpIH0pO1xuICAgIGNvbnN0IG5vcm1hbGl6ZUhleCA9IGhleCA9PiByZW1vdmVMZWFkaW5nKGhleCwgJyMnKS50b1VwcGVyQ2FzZSgpO1xuICAgIGNvbnN0IHRvSGV4ID0gY29tcG9uZW50ID0+IHtcbiAgICAgIGNvbnN0IGhleCA9IGNvbXBvbmVudC50b1N0cmluZygxNik7XG4gICAgICByZXR1cm4gKGhleC5sZW5ndGggPT09IDEgPyAnMCcgKyBoZXggOiBoZXgpLnRvVXBwZXJDYXNlKCk7XG4gICAgfTtcbiAgICBjb25zdCBmcm9tUmdiYSA9IHJnYmFDb2xvdXIgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSB0b0hleChyZ2JhQ29sb3VyLnJlZCkgKyB0b0hleChyZ2JhQ29sb3VyLmdyZWVuKSArIHRvSGV4KHJnYmFDb2xvdXIuYmx1ZSk7XG4gICAgICByZXR1cm4gaGV4Q29sb3VyKHZhbHVlKTtcbiAgICB9O1xuXG4gICAgY29uc3QgcmdiUmVnZXggPSAvXlxccypyZ2JcXHMqXFwoXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccypcXClcXHMqJC9pO1xuICAgIGNvbnN0IHJnYmFSZWdleCA9IC9eXFxzKnJnYmFcXHMqXFwoXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccyosXFxzKihcXGQ/KD86XFwuXFxkKyk/KVxccypcXClcXHMqJC9pO1xuICAgIGNvbnN0IHJnYmFDb2xvdXIgPSAocmVkLCBncmVlbiwgYmx1ZSwgYWxwaGEpID0+ICh7XG4gICAgICByZWQsXG4gICAgICBncmVlbixcbiAgICAgIGJsdWUsXG4gICAgICBhbHBoYVxuICAgIH0pO1xuICAgIGNvbnN0IGZyb21TdHJpbmdWYWx1ZXMgPSAocmVkLCBncmVlbiwgYmx1ZSwgYWxwaGEpID0+IHtcbiAgICAgIGNvbnN0IHIgPSBwYXJzZUludChyZWQsIDEwKTtcbiAgICAgIGNvbnN0IGcgPSBwYXJzZUludChncmVlbiwgMTApO1xuICAgICAgY29uc3QgYiA9IHBhcnNlSW50KGJsdWUsIDEwKTtcbiAgICAgIGNvbnN0IGEgPSBwYXJzZUZsb2F0KGFscGhhKTtcbiAgICAgIHJldHVybiByZ2JhQ29sb3VyKHIsIGcsIGIsIGEpO1xuICAgIH07XG4gICAgY29uc3QgZnJvbVN0cmluZyA9IHJnYmFTdHJpbmcgPT4ge1xuICAgICAgaWYgKHJnYmFTdHJpbmcgPT09ICd0cmFuc3BhcmVudCcpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUocmdiYUNvbG91cigwLCAwLCAwLCAwKSk7XG4gICAgICB9XG4gICAgICBjb25zdCByZ2JNYXRjaCA9IHJnYlJlZ2V4LmV4ZWMocmdiYVN0cmluZyk7XG4gICAgICBpZiAocmdiTWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoZnJvbVN0cmluZ1ZhbHVlcyhyZ2JNYXRjaFsxXSwgcmdiTWF0Y2hbMl0sIHJnYk1hdGNoWzNdLCAnMScpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJnYmFNYXRjaCA9IHJnYmFSZWdleC5leGVjKHJnYmFTdHJpbmcpO1xuICAgICAgaWYgKHJnYmFNYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShmcm9tU3RyaW5nVmFsdWVzKHJnYmFNYXRjaFsxXSwgcmdiYU1hdGNoWzJdLCByZ2JhTWF0Y2hbM10sIHJnYmFNYXRjaFs0XSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgcmdiYVRvSGV4U3RyaW5nID0gY29sb3IgPT4gZnJvbVN0cmluZyhjb2xvcikubWFwKGZyb21SZ2JhKS5tYXAoaCA9PiAnIycgKyBoLnZhbHVlKS5nZXRPcihjb2xvcik7XG5cbiAgICBjb25zdCBnZXRSYW5nZXMkMSA9IHNlbGVjdGlvbiA9PiB7XG4gICAgICBjb25zdCByYW5nZXMgPSBbXTtcbiAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3Rpb24ucmFuZ2VDb3VudDsgaSsrKSB7XG4gICAgICAgICAgcmFuZ2VzLnB1c2goc2VsZWN0aW9uLmdldFJhbmdlQXQoaSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmFuZ2VzO1xuICAgIH07XG4gICAgY29uc3QgZ2V0U2VsZWN0ZWROb2RlcyA9IHJhbmdlcyA9PiB7XG4gICAgICByZXR1cm4gYmluZCQzKHJhbmdlcywgcmFuZ2UgPT4ge1xuICAgICAgICBjb25zdCBub2RlID0gZ2V0U2VsZWN0ZWROb2RlKHJhbmdlKTtcbiAgICAgICAgcmV0dXJuIG5vZGUgPyBbU3VnYXJFbGVtZW50LmZyb21Eb20obm9kZSldIDogW107XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGhhc011bHRpcGxlUmFuZ2VzID0gc2VsZWN0aW9uID0+IHtcbiAgICAgIHJldHVybiBnZXRSYW5nZXMkMShzZWxlY3Rpb24pLmxlbmd0aCA+IDE7XG4gICAgfTtcblxuICAgIGNvbnN0IGdldENlbGxzRnJvbVJhbmdlcyA9IHJhbmdlcyA9PiBmaWx0ZXIkNShnZXRTZWxlY3RlZE5vZGVzKHJhbmdlcyksIGlzVGFibGVDZWxsJDIpO1xuICAgIGNvbnN0IGdldENlbGxzRnJvbUVsZW1lbnQgPSBlbG0gPT4gZGVzY2VuZGFudHMoZWxtLCAndGRbZGF0YS1tY2Utc2VsZWN0ZWRdLHRoW2RhdGEtbWNlLXNlbGVjdGVkXScpO1xuICAgIGNvbnN0IGdldENlbGxzRnJvbUVsZW1lbnRPclJhbmdlcyA9IChyYW5nZXMsIGVsZW1lbnQpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkQ2VsbHMgPSBnZXRDZWxsc0Zyb21FbGVtZW50KGVsZW1lbnQpO1xuICAgICAgcmV0dXJuIHNlbGVjdGVkQ2VsbHMubGVuZ3RoID4gMCA/IHNlbGVjdGVkQ2VsbHMgOiBnZXRDZWxsc0Zyb21SYW5nZXMocmFuZ2VzKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldENlbGxzRnJvbUVkaXRvciA9IGVkaXRvciA9PiBnZXRDZWxsc0Zyb21FbGVtZW50T3JSYW5nZXMoZ2V0UmFuZ2VzJDEoZWRpdG9yLnNlbGVjdGlvbi5nZXRTZWwoKSksIFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRCb2R5KCkpKTtcbiAgICBjb25zdCBnZXRDbG9zZXN0VGFibGUgPSAoY2VsbCwgaXNSb290KSA9PiBhbmNlc3RvciQzKGNlbGwsICd0YWJsZScsIGlzUm9vdCk7XG5cbiAgICBjb25zdCBnZXRTdGFydE5vZGUgPSBybmcgPT4ge1xuICAgICAgY29uc3Qgc2MgPSBybmcuc3RhcnRDb250YWluZXIsIHNvID0gcm5nLnN0YXJ0T2Zmc2V0O1xuICAgICAgaWYgKGlzVGV4dCRhKHNjKSkge1xuICAgICAgICByZXR1cm4gc28gPT09IDAgPyBPcHRpb25hbC5zb21lKFN1Z2FyRWxlbWVudC5mcm9tRG9tKHNjKSkgOiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuZnJvbShzYy5jaGlsZE5vZGVzW3NvXSkubWFwKFN1Z2FyRWxlbWVudC5mcm9tRG9tKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGdldEVuZE5vZGUgPSBybmcgPT4ge1xuICAgICAgY29uc3QgZWMgPSBybmcuZW5kQ29udGFpbmVyLCBlbyA9IHJuZy5lbmRPZmZzZXQ7XG4gICAgICBpZiAoaXNUZXh0JGEoZWMpKSB7XG4gICAgICAgIHJldHVybiBlbyA9PT0gZWMuZGF0YS5sZW5ndGggPyBPcHRpb25hbC5zb21lKFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVjKSkgOiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuZnJvbShlYy5jaGlsZE5vZGVzW2VvIC0gMV0pLm1hcChTdWdhckVsZW1lbnQuZnJvbURvbSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBnZXRGaXJzdENoaWxkcmVuID0gbm9kZSA9PiB7XG4gICAgICByZXR1cm4gZmlyc3RDaGlsZChub2RlKS5mb2xkKGNvbnN0YW50KFtub2RlXSksIGNoaWxkID0+IHtcbiAgICAgICAgcmV0dXJuIFtub2RlXS5jb25jYXQoZ2V0Rmlyc3RDaGlsZHJlbihjaGlsZCkpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRMYXN0Q2hpbGRyZW4gPSBub2RlID0+IHtcbiAgICAgIHJldHVybiBsYXN0Q2hpbGQobm9kZSkuZm9sZChjb25zdGFudChbbm9kZV0pLCBjaGlsZCA9PiB7XG4gICAgICAgIGlmIChuYW1lKGNoaWxkKSA9PT0gJ2JyJykge1xuICAgICAgICAgIHJldHVybiBwcmV2U2libGluZyhjaGlsZCkubWFwKHNpYmxpbmcgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFtub2RlXS5jb25jYXQoZ2V0TGFzdENoaWxkcmVuKHNpYmxpbmcpKTtcbiAgICAgICAgICB9KS5nZXRPcihbXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFtub2RlXS5jb25jYXQoZ2V0TGFzdENoaWxkcmVuKGNoaWxkKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgaGFzQWxsQ29udGVudHNTZWxlY3RlZCA9IChlbG0sIHJuZykgPT4ge1xuICAgICAgcmV0dXJuIGxpZnQyKGdldFN0YXJ0Tm9kZShybmcpLCBnZXRFbmROb2RlKHJuZyksIChzdGFydE5vZGUsIGVuZE5vZGUpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBmaW5kJDIoZ2V0Rmlyc3RDaGlsZHJlbihlbG0pLCBjdXJyeShlcSwgc3RhcnROb2RlKSk7XG4gICAgICAgIGNvbnN0IGVuZCA9IGZpbmQkMihnZXRMYXN0Q2hpbGRyZW4oZWxtKSwgY3VycnkoZXEsIGVuZE5vZGUpKTtcbiAgICAgICAgcmV0dXJuIHN0YXJ0LmlzU29tZSgpICYmIGVuZC5pc1NvbWUoKTtcbiAgICAgIH0pLmdldE9yKGZhbHNlKTtcbiAgICB9O1xuICAgIGNvbnN0IG1vdmVFbmRQb2ludCA9IChkb20sIHJuZywgbm9kZSwgc3RhcnQpID0+IHtcbiAgICAgIGNvbnN0IHJvb3QgPSBub2RlO1xuICAgICAgY29uc3Qgd2Fsa2VyID0gbmV3IERvbVRyZWVXYWxrZXIobm9kZSwgcm9vdCk7XG4gICAgICBjb25zdCBtb3ZlQ2FyZXRCZWZvcmVPbkVudGVyRWxlbWVudHNNYXAgPSBmaWx0ZXIkNChkb20uc2NoZW1hLmdldE1vdmVDYXJldEJlZm9yZU9uRW50ZXJFbGVtZW50cygpLCAoXywgbmFtZSkgPT4gIWNvbnRhaW5zJDIoW1xuICAgICAgICAndGQnLFxuICAgICAgICAndGgnLFxuICAgICAgICAndGFibGUnXG4gICAgICBdLCBuYW1lLnRvTG93ZXJDYXNlKCkpKTtcbiAgICAgIGxldCBjdXJyZW50Tm9kZSA9IG5vZGU7XG4gICAgICBkbyB7XG4gICAgICAgIGlmIChpc1RleHQkYShjdXJyZW50Tm9kZSkgJiYgVG9vbHMudHJpbShjdXJyZW50Tm9kZS5kYXRhKS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICAgIHJuZy5zZXRTdGFydChjdXJyZW50Tm9kZSwgMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJuZy5zZXRFbmQoY3VycmVudE5vZGUsIGN1cnJlbnROb2RlLmRhdGEubGVuZ3RoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb3ZlQ2FyZXRCZWZvcmVPbkVudGVyRWxlbWVudHNNYXBbY3VycmVudE5vZGUubm9kZU5hbWVdKSB7XG4gICAgICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgICBybmcuc2V0U3RhcnRCZWZvcmUoY3VycmVudE5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudE5vZGUubm9kZU5hbWUgPT09ICdCUicpIHtcbiAgICAgICAgICAgICAgcm5nLnNldEVuZEJlZm9yZShjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBybmcuc2V0RW5kQWZ0ZXIoY3VycmVudE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKGN1cnJlbnROb2RlID0gc3RhcnQgPyB3YWxrZXIubmV4dCgpIDogd2Fsa2VyLnByZXYoKSk7XG4gICAgICBpZiAocm9vdC5ub2RlTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgICAgIGlmIChzdGFydCkge1xuICAgICAgICAgIHJuZy5zZXRTdGFydChyb290LCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBybmcuc2V0RW5kKHJvb3QsIHJvb3QuY2hpbGROb2Rlcy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBoYXNBbnlSYW5nZXMgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3Qgc2VsID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRTZWwoKTtcbiAgICAgIHJldHVybiBpc05vbk51bGxhYmxlKHNlbCkgJiYgc2VsLnJhbmdlQ291bnQgPiAwO1xuICAgIH07XG4gICAgY29uc3QgcnVuT25SYW5nZXMgPSAoZWRpdG9yLCBleGVjdXRvcikgPT4ge1xuICAgICAgY29uc3QgZmFrZVNlbGVjdGlvbk5vZGVzID0gZ2V0Q2VsbHNGcm9tRWRpdG9yKGVkaXRvcik7XG4gICAgICBpZiAoZmFrZVNlbGVjdGlvbk5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZWFjaCRlKGZha2VTZWxlY3Rpb25Ob2RlcywgZWxlbSA9PiB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IGVsZW0uZG9tO1xuICAgICAgICAgIGNvbnN0IGZha2VOb2RlUm5nID0gZWRpdG9yLmRvbS5jcmVhdGVSbmcoKTtcbiAgICAgICAgICBmYWtlTm9kZVJuZy5zZXRTdGFydEJlZm9yZShub2RlKTtcbiAgICAgICAgICBmYWtlTm9kZVJuZy5zZXRFbmRBZnRlcihub2RlKTtcbiAgICAgICAgICBleGVjdXRvcihmYWtlTm9kZVJuZywgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhlY3V0b3IoZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcHJlc2VydmUgPSAoc2VsZWN0aW9uLCBmaWxsQm9va21hcmssIGV4ZWN1dG9yKSA9PiB7XG4gICAgICBjb25zdCBib29rbWFyayA9IGdldFBlcnNpc3RlbnRCb29rbWFyayhzZWxlY3Rpb24sIGZpbGxCb29rbWFyayk7XG4gICAgICBleGVjdXRvcihib29rbWFyayk7XG4gICAgICBzZWxlY3Rpb24ubW92ZVRvQm9va21hcmsoYm9va21hcmspO1xuICAgIH07XG5cbiAgICBjb25zdCBpc05vZGUgPSBub2RlID0+IGlzTnVtYmVyKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS5ub2RlVHlwZSk7XG4gICAgY29uc3QgaXNFbGVtZW50Tm9kZSQxID0gbm9kZSA9PiBpc0VsZW1lbnQkNihub2RlKSAmJiAhaXNCb29rbWFya05vZGUkMShub2RlKSAmJiAhaXNDYXJldE5vZGUobm9kZSkgJiYgIWlzQm9ndXMkMihub2RlKTtcbiAgICBjb25zdCBpc0VsZW1lbnREaXJlY3RseVNlbGVjdGVkID0gKGRvbSwgbm9kZSkgPT4ge1xuICAgICAgaWYgKGlzRWxlbWVudE5vZGUkMShub2RlKSAmJiAhL14oVER8VEgpJC8udGVzdChub2RlLm5vZGVOYW1lKSkge1xuICAgICAgICBjb25zdCBzZWxlY3RlZEF0dHIgPSBkb20uZ2V0QXR0cmliKG5vZGUsICdkYXRhLW1jZS1zZWxlY3RlZCcpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcnNlSW50KHNlbGVjdGVkQXR0ciwgMTApO1xuICAgICAgICByZXR1cm4gIWlzTmFOKHZhbHVlKSAmJiB2YWx1ZSA+IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpc0VkaXRhYmxlJDIgPSBlbG0gPT4gZWxtLmlzQ29udGVudEVkaXRhYmxlID09PSB0cnVlO1xuICAgIGNvbnN0IHByZXNlcnZlU2VsZWN0aW9uID0gKGVkaXRvciwgYWN0aW9uLCBzaG91bGRNb3ZlU3RhcnQpID0+IHtcbiAgICAgIGNvbnN0IHtzZWxlY3Rpb24sIGRvbX0gPSBlZGl0b3I7XG4gICAgICBjb25zdCBzZWxlY3RlZE5vZGVCZWZvcmVBY3Rpb24gPSBzZWxlY3Rpb24uZ2V0Tm9kZSgpO1xuICAgICAgY29uc3QgaXNTZWxlY3RlZEJlZm9yZU5vZGVOb25lZGl0YWJsZSA9IGlzQ29udGVudEVkaXRhYmxlRmFsc2UkYihzZWxlY3RlZE5vZGVCZWZvcmVBY3Rpb24pO1xuICAgICAgcHJlc2VydmUoc2VsZWN0aW9uLCB0cnVlLCAoKSA9PiB7XG4gICAgICAgIGFjdGlvbigpO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBpc0JlZm9yZU5vZGVTdGlsbE5vbmVkaXRhYmxlID0gaXNTZWxlY3RlZEJlZm9yZU5vZGVOb25lZGl0YWJsZSAmJiBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJGIoc2VsZWN0ZWROb2RlQmVmb3JlQWN0aW9uKTtcbiAgICAgIGlmIChpc0JlZm9yZU5vZGVTdGlsbE5vbmVkaXRhYmxlICYmIGRvbS5pc0NoaWxkT2Yoc2VsZWN0ZWROb2RlQmVmb3JlQWN0aW9uLCBlZGl0b3IuZ2V0Qm9keSgpKSkge1xuICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNlbGVjdChzZWxlY3RlZE5vZGVCZWZvcmVBY3Rpb24pO1xuICAgICAgfSBlbHNlIGlmIChzaG91bGRNb3ZlU3RhcnQoc2VsZWN0aW9uLmdldFN0YXJ0KCkpKSB7XG4gICAgICAgIG1vdmVTdGFydFRvTmVhcmVzdFRleHQoZG9tLCBzZWxlY3Rpb24pO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbW92ZVN0YXJ0VG9OZWFyZXN0VGV4dCA9IChkb20sIHNlbGVjdGlvbikgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGNvbnN0IHJuZyA9IHNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgIGNvbnN0IHtzdGFydENvbnRhaW5lciwgc3RhcnRPZmZzZXR9ID0gcm5nO1xuICAgICAgY29uc3Qgc2VsZWN0ZWROb2RlID0gc2VsZWN0aW9uLmdldE5vZGUoKTtcbiAgICAgIGlmIChpc0VsZW1lbnREaXJlY3RseVNlbGVjdGVkKGRvbSwgc2VsZWN0ZWROb2RlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNFbGVtZW50JDYoc3RhcnRDb250YWluZXIpKSB7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gc3RhcnRDb250YWluZXIuY2hpbGROb2RlcztcbiAgICAgICAgY29uc3Qgcm9vdCA9IGRvbS5nZXRSb290KCk7XG4gICAgICAgIGxldCB3YWxrZXI7XG4gICAgICAgIGlmIChzdGFydE9mZnNldCA8IG5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IHN0YXJ0Tm9kZSA9IG5vZGVzW3N0YXJ0T2Zmc2V0XTtcbiAgICAgICAgICB3YWxrZXIgPSBuZXcgRG9tVHJlZVdhbGtlcihzdGFydE5vZGUsIChfYSA9IGRvbS5nZXRQYXJlbnQoc3RhcnROb2RlLCBkb20uaXNCbG9jaykpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHJvb3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHN0YXJ0Tm9kZSA9IG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIHdhbGtlciA9IG5ldyBEb21UcmVlV2Fsa2VyKHN0YXJ0Tm9kZSwgKF9iID0gZG9tLmdldFBhcmVudChzdGFydE5vZGUsIGRvbS5pc0Jsb2NrKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogcm9vdCk7XG4gICAgICAgICAgd2Fsa2VyLm5leHQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgbm9kZSA9IHdhbGtlci5jdXJyZW50KCk7IG5vZGU7IG5vZGUgPSB3YWxrZXIubmV4dCgpKSB7XG4gICAgICAgICAgaWYgKGRvbS5nZXRDb250ZW50RWRpdGFibGUobm9kZSkgPT09ICdmYWxzZScpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzVGV4dCRhKG5vZGUpICYmICFpc1doaXRlU3BhY2VOb2RlJDEobm9kZSkpIHtcbiAgICAgICAgICAgIHJuZy5zZXRTdGFydChub2RlLCAwKTtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5zZXRSbmcocm5nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGdldE5vbldoaXRlU3BhY2VTaWJsaW5nID0gKG5vZGUsIG5leHQsIGluYykgPT4ge1xuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgY29uc3QgbmV4dE5hbWUgPSBuZXh0ID8gJ25leHRTaWJsaW5nJyA6ICdwcmV2aW91c1NpYmxpbmcnO1xuICAgICAgICBmb3IgKG5vZGUgPSBpbmMgPyBub2RlIDogbm9kZVtuZXh0TmFtZV07IG5vZGU7IG5vZGUgPSBub2RlW25leHROYW1lXSkge1xuICAgICAgICAgIGlmIChpc0VsZW1lbnQkNihub2RlKSB8fCAhaXNXaGl0ZVNwYWNlTm9kZSQxKG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBjb25zdCBpc1RleHRCbG9jayQxID0gKHNjaGVtYSwgbm9kZSkgPT4gISFzY2hlbWEuZ2V0VGV4dEJsb2NrRWxlbWVudHMoKVtub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldIHx8IGlzVHJhbnNwYXJlbnRCbG9jayhzY2hlbWEsIG5vZGUpO1xuICAgIGNvbnN0IGlzVmFsaWQgPSAoZWQsIHBhcmVudCwgY2hpbGQpID0+IHtcbiAgICAgIHJldHVybiBlZC5zY2hlbWEuaXNWYWxpZENoaWxkKHBhcmVudCwgY2hpbGQpO1xuICAgIH07XG4gICAgY29uc3QgaXNXaGl0ZVNwYWNlTm9kZSQxID0gKG5vZGUsIGFsbG93U3BhY2VzID0gZmFsc2UpID0+IHtcbiAgICAgIGlmIChpc05vbk51bGxhYmxlKG5vZGUpICYmIGlzVGV4dCRhKG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhbGxvd1NwYWNlcyA/IG5vZGUuZGF0YS5yZXBsYWNlKC8gL2csICdcXHhBMCcpIDogbm9kZS5kYXRhO1xuICAgICAgICByZXR1cm4gaXNXaGl0ZXNwYWNlVGV4dChkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGlzRW1wdHlUZXh0Tm9kZSQxID0gbm9kZSA9PiB7XG4gICAgICByZXR1cm4gaXNOb25OdWxsYWJsZShub2RlKSAmJiBpc1RleHQkYShub2RlKSAmJiBub2RlLmxlbmd0aCA9PT0gMDtcbiAgICB9O1xuICAgIGNvbnN0IGlzV3JhcE5vbmVkaXRhYmxlVGFyZ2V0ID0gKGVkaXRvciwgbm9kZSkgPT4ge1xuICAgICAgY29uc3QgYmFzZURhdGFTZWxlY3RvciA9ICdbZGF0YS1tY2UtY2VmLXdyYXBwYWJsZV0nO1xuICAgICAgY29uc3QgZm9ybWF0Tm9uZWRpdGFibGVTZWxlY3RvciA9IGdldEZvcm1hdE5vbmVkaXRhYmxlU2VsZWN0b3IoZWRpdG9yKTtcbiAgICAgIGNvbnN0IHNlbGVjdG9yID0gaXNFbXB0eSQzKGZvcm1hdE5vbmVkaXRhYmxlU2VsZWN0b3IpID8gYmFzZURhdGFTZWxlY3RvciA6IGAkeyBiYXNlRGF0YVNlbGVjdG9yIH0sJHsgZm9ybWF0Tm9uZWRpdGFibGVTZWxlY3RvciB9YDtcbiAgICAgIHJldHVybiBpcyQxKFN1Z2FyRWxlbWVudC5mcm9tRG9tKG5vZGUpLCBzZWxlY3Rvcik7XG4gICAgfTtcbiAgICBjb25zdCBpc1dyYXBwYWJsZU5vbmVkaXRhYmxlID0gKGVkaXRvciwgbm9kZSkgPT4ge1xuICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbTtcbiAgICAgIHJldHVybiBpc0VsZW1lbnROb2RlJDEobm9kZSkgJiYgZG9tLmdldENvbnRlbnRFZGl0YWJsZShub2RlKSA9PT0gJ2ZhbHNlJyAmJiBpc1dyYXBOb25lZGl0YWJsZVRhcmdldChlZGl0b3IsIG5vZGUpICYmIGRvbS5zZWxlY3QoJ1tjb250ZW50ZWRpdGFibGU9XCJ0cnVlXCJdJywgbm9kZSkubGVuZ3RoID09PSAwO1xuICAgIH07XG4gICAgY29uc3QgcmVwbGFjZVZhcnMgPSAodmFsdWUsIHZhcnMpID0+IHtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUodmFycyk7XG4gICAgICB9IGVsc2UgaWYgKGlzTm9uTnVsbGFibGUodmFycykpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC8lKFxcdyspL2csIChzdHIsIG5hbWUpID0+IHtcbiAgICAgICAgICByZXR1cm4gdmFyc1tuYW1lXSB8fCBzdHI7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgY29uc3QgaXNFcSQ1ID0gKHN0cjEsIHN0cjIpID0+IHtcbiAgICAgIHN0cjEgPSBzdHIxIHx8ICcnO1xuICAgICAgc3RyMiA9IHN0cjIgfHwgJyc7XG4gICAgICBzdHIxID0gJycgKyAoc3RyMS5ub2RlTmFtZSB8fCBzdHIxKTtcbiAgICAgIHN0cjIgPSAnJyArIChzdHIyLm5vZGVOYW1lIHx8IHN0cjIpO1xuICAgICAgcmV0dXJuIHN0cjEudG9Mb3dlckNhc2UoKSA9PT0gc3RyMi50b0xvd2VyQ2FzZSgpO1xuICAgIH07XG4gICAgY29uc3Qgbm9ybWFsaXplU3R5bGVWYWx1ZSA9ICh2YWx1ZSwgbmFtZSkgPT4ge1xuICAgICAgaWYgKGlzTnVsbGFibGUodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHN0clZhbHVlID0gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgaWYgKG5hbWUgPT09ICdjb2xvcicgfHwgbmFtZSA9PT0gJ2JhY2tncm91bmRDb2xvcicpIHtcbiAgICAgICAgICBzdHJWYWx1ZSA9IHJnYmFUb0hleFN0cmluZyhzdHJWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgPT09ICdmb250V2VpZ2h0JyAmJiB2YWx1ZSA9PT0gNzAwKSB7XG4gICAgICAgICAgc3RyVmFsdWUgPSAnYm9sZCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgPT09ICdmb250RmFtaWx5Jykge1xuICAgICAgICAgIHN0clZhbHVlID0gc3RyVmFsdWUucmVwbGFjZSgvW1xcJ1xcXCJdL2csICcnKS5yZXBsYWNlKC8sXFxzKy9nLCAnLCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJWYWx1ZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGdldFN0eWxlID0gKGRvbSwgbm9kZSwgbmFtZSkgPT4ge1xuICAgICAgY29uc3Qgc3R5bGUgPSBkb20uZ2V0U3R5bGUobm9kZSwgbmFtZSk7XG4gICAgICByZXR1cm4gbm9ybWFsaXplU3R5bGVWYWx1ZShzdHlsZSwgbmFtZSk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRUZXh0RGVjb3JhdGlvbiA9IChkb20sIG5vZGUpID0+IHtcbiAgICAgIGxldCBkZWNvcmF0aW9uO1xuICAgICAgZG9tLmdldFBhcmVudChub2RlLCBuID0+IHtcbiAgICAgICAgaWYgKGlzRWxlbWVudCQ2KG4pKSB7XG4gICAgICAgICAgZGVjb3JhdGlvbiA9IGRvbS5nZXRTdHlsZShuLCAndGV4dC1kZWNvcmF0aW9uJyk7XG4gICAgICAgICAgcmV0dXJuICEhZGVjb3JhdGlvbiAmJiBkZWNvcmF0aW9uICE9PSAnbm9uZSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkZWNvcmF0aW9uO1xuICAgIH07XG4gICAgY29uc3QgZ2V0UGFyZW50cyQyID0gKGRvbSwgbm9kZSwgc2VsZWN0b3IpID0+IHtcbiAgICAgIHJldHVybiBkb20uZ2V0UGFyZW50cyhub2RlLCBzZWxlY3RvciwgZG9tLmdldFJvb3QoKSk7XG4gICAgfTtcbiAgICBjb25zdCBpc0Zvcm1hdFByZWRpY2F0ZSA9IChlZGl0b3IsIGZvcm1hdE5hbWUsIHByZWRpY2F0ZSkgPT4ge1xuICAgICAgY29uc3QgZm9ybWF0cyA9IGVkaXRvci5mb3JtYXR0ZXIuZ2V0KGZvcm1hdE5hbWUpO1xuICAgICAgcmV0dXJuIGlzTm9uTnVsbGFibGUoZm9ybWF0cykgJiYgZXhpc3RzKGZvcm1hdHMsIHByZWRpY2F0ZSk7XG4gICAgfTtcbiAgICBjb25zdCBpc1ZhcmlhYmxlRm9ybWF0TmFtZSA9IChlZGl0b3IsIGZvcm1hdE5hbWUpID0+IHtcbiAgICAgIGNvbnN0IGhhc1ZhcmlhYmxlVmFsdWVzID0gZm9ybWF0ID0+IHtcbiAgICAgICAgY29uc3QgaXNWYXJpYWJsZVZhbHVlID0gdmFsID0+IGlzRnVuY3Rpb24odmFsKSB8fCB2YWwubGVuZ3RoID4gMSAmJiB2YWwuY2hhckF0KDApID09PSAnJSc7XG4gICAgICAgIHJldHVybiBleGlzdHMoW1xuICAgICAgICAgICdzdHlsZXMnLFxuICAgICAgICAgICdhdHRyaWJ1dGVzJ1xuICAgICAgICBdLCBrZXkgPT4gZ2V0JGEoZm9ybWF0LCBrZXkpLmV4aXN0cyhmaWVsZCA9PiB7XG4gICAgICAgICAgY29uc3QgZmllbGRWYWx1ZXMgPSBpc0FycmF5JDEoZmllbGQpID8gZmllbGQgOiB2YWx1ZXMoZmllbGQpO1xuICAgICAgICAgIHJldHVybiBleGlzdHMoZmllbGRWYWx1ZXMsIGlzVmFyaWFibGVWYWx1ZSk7XG4gICAgICAgIH0pKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gaXNGb3JtYXRQcmVkaWNhdGUoZWRpdG9yLCBmb3JtYXROYW1lLCBoYXNWYXJpYWJsZVZhbHVlcyk7XG4gICAgfTtcbiAgICBjb25zdCBhcmVTaW1pbGFyRm9ybWF0cyA9IChlZGl0b3IsIGZvcm1hdE5hbWUsIG90aGVyRm9ybWF0TmFtZSkgPT4ge1xuICAgICAgY29uc3QgdmFsaWRLZXlzID0gW1xuICAgICAgICAnaW5saW5lJyxcbiAgICAgICAgJ2Jsb2NrJyxcbiAgICAgICAgJ3NlbGVjdG9yJyxcbiAgICAgICAgJ2F0dHJpYnV0ZXMnLFxuICAgICAgICAnc3R5bGVzJyxcbiAgICAgICAgJ2NsYXNzZXMnXG4gICAgICBdO1xuICAgICAgY29uc3QgZmlsdGVyT2JqID0gZm9ybWF0ID0+IGZpbHRlciQ0KGZvcm1hdCwgKF8sIGtleSkgPT4gZXhpc3RzKHZhbGlkS2V5cywgdmFsaWRLZXkgPT4gdmFsaWRLZXkgPT09IGtleSkpO1xuICAgICAgcmV0dXJuIGlzRm9ybWF0UHJlZGljYXRlKGVkaXRvciwgZm9ybWF0TmFtZSwgZm10MSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkRm10MSA9IGZpbHRlck9iaihmbXQxKTtcbiAgICAgICAgcmV0dXJuIGlzRm9ybWF0UHJlZGljYXRlKGVkaXRvciwgb3RoZXJGb3JtYXROYW1lLCBmbXQyID0+IHtcbiAgICAgICAgICBjb25zdCBmaWx0ZXJlZEZtdDIgPSBmaWx0ZXJPYmooZm10Mik7XG4gICAgICAgICAgcmV0dXJuIGVxdWFsJDEoZmlsdGVyZWRGbXQxLCBmaWx0ZXJlZEZtdDIpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgaXNCbG9ja0Zvcm1hdCA9IGZvcm1hdCA9PiBoYXNOb25OdWxsYWJsZUtleShmb3JtYXQsICdibG9jaycpO1xuICAgIGNvbnN0IGlzV3JhcHBpbmdCbG9ja0Zvcm1hdCA9IGZvcm1hdCA9PiBpc0Jsb2NrRm9ybWF0KGZvcm1hdCkgJiYgZm9ybWF0LndyYXBwZXIgPT09IHRydWU7XG4gICAgY29uc3QgaXNOb25XcmFwcGluZ0Jsb2NrRm9ybWF0ID0gZm9ybWF0ID0+IGlzQmxvY2tGb3JtYXQoZm9ybWF0KSAmJiBmb3JtYXQud3JhcHBlciAhPT0gdHJ1ZTtcbiAgICBjb25zdCBpc1NlbGVjdG9yRm9ybWF0ID0gZm9ybWF0ID0+IGhhc05vbk51bGxhYmxlS2V5KGZvcm1hdCwgJ3NlbGVjdG9yJyk7XG4gICAgY29uc3QgaXNJbmxpbmVGb3JtYXQgPSBmb3JtYXQgPT4gaGFzTm9uTnVsbGFibGVLZXkoZm9ybWF0LCAnaW5saW5lJyk7XG4gICAgY29uc3QgaXNNaXhlZEZvcm1hdCA9IGZvcm1hdCA9PiBpc1NlbGVjdG9yRm9ybWF0KGZvcm1hdCkgJiYgaXNJbmxpbmVGb3JtYXQoZm9ybWF0KSAmJiBpcyQyKGdldCRhKGZvcm1hdCwgJ21peGVkJyksIHRydWUpO1xuICAgIGNvbnN0IHNob3VsZEV4cGFuZFRvU2VsZWN0b3IgPSBmb3JtYXQgPT4gaXNTZWxlY3RvckZvcm1hdChmb3JtYXQpICYmIGZvcm1hdC5leHBhbmQgIT09IGZhbHNlICYmICFpc0lubGluZUZvcm1hdChmb3JtYXQpO1xuXG4gICAgY29uc3QgaXNCb29rbWFya05vZGUgPSBpc0Jvb2ttYXJrTm9kZSQxO1xuICAgIGNvbnN0IGdldFBhcmVudHMkMSA9IGdldFBhcmVudHMkMjtcbiAgICBjb25zdCBpc1doaXRlU3BhY2VOb2RlID0gaXNXaGl0ZVNwYWNlTm9kZSQxO1xuICAgIGNvbnN0IGlzVGV4dEJsb2NrID0gaXNUZXh0QmxvY2skMTtcbiAgICBjb25zdCBpc0JvZ3VzQnIgPSBub2RlID0+IHtcbiAgICAgIHJldHVybiBpc0JyJDYobm9kZSkgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtbWNlLWJvZ3VzJykgJiYgIW5vZGUubmV4dFNpYmxpbmc7XG4gICAgfTtcbiAgICBjb25zdCBmaW5kUGFyZW50Q29udGVudEVkaXRhYmxlID0gKGRvbSwgbm9kZSkgPT4ge1xuICAgICAgbGV0IHBhcmVudCA9IG5vZGU7XG4gICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgIGlmIChpc0VsZW1lbnQkNihwYXJlbnQpICYmIGRvbS5nZXRDb250ZW50RWRpdGFibGUocGFyZW50KSkge1xuICAgICAgICAgIHJldHVybiBkb20uZ2V0Q29udGVudEVkaXRhYmxlKHBhcmVudCkgPT09ICdmYWxzZScgPyBwYXJlbnQgOiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgICBjb25zdCB3YWxrVGV4dCA9IChzdGFydCwgbm9kZSwgb2Zmc2V0LCBwcmVkaWNhdGUpID0+IHtcbiAgICAgIGNvbnN0IHN0ciA9IG5vZGUuZGF0YTtcbiAgICAgIGlmIChzdGFydCkge1xuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKHByZWRpY2F0ZShzdHIuY2hhckF0KGkgLSAxKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChwcmVkaWNhdGUoc3RyLmNoYXJBdChpKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gICAgY29uc3QgZmluZFNwYWNlID0gKHN0YXJ0LCBub2RlLCBvZmZzZXQpID0+IHdhbGtUZXh0KHN0YXJ0LCBub2RlLCBvZmZzZXQsIGMgPT4gaXNOYnNwKGMpIHx8IGlzV2hpdGVTcGFjZShjKSk7XG4gICAgY29uc3QgZmluZENvbnRlbnQgPSAoc3RhcnQsIG5vZGUsIG9mZnNldCkgPT4gd2Fsa1RleHQoc3RhcnQsIG5vZGUsIG9mZnNldCwgaXNDb250ZW50KTtcbiAgICBjb25zdCBmaW5kV29yZEVuZFBvaW50ID0gKGRvbSwgYm9keSwgY29udGFpbmVyLCBvZmZzZXQsIHN0YXJ0LCBpbmNsdWRlVHJhaWxpbmdTcGFjZXMpID0+IHtcbiAgICAgIGxldCBsYXN0VGV4dE5vZGU7XG4gICAgICBjb25zdCByb290Tm9kZSA9IGRvbS5nZXRQYXJlbnQoY29udGFpbmVyLCBkb20uaXNCbG9jaykgfHwgYm9keTtcbiAgICAgIGNvbnN0IHdhbGsgPSAoY29udGFpbmVyLCBvZmZzZXQsIHByZWQpID0+IHtcbiAgICAgICAgY29uc3QgdGV4dFNlZWtlciA9IFRleHRTZWVrZXIoZG9tKTtcbiAgICAgICAgY29uc3Qgd2Fsa2VyID0gc3RhcnQgPyB0ZXh0U2Vla2VyLmJhY2t3YXJkcyA6IHRleHRTZWVrZXIuZm9yd2FyZHM7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5mcm9tKHdhbGtlcihjb250YWluZXIsIG9mZnNldCwgKHRleHQsIHRleHRPZmZzZXQpID0+IHtcbiAgICAgICAgICBpZiAoaXNCb29rbWFya05vZGUodGV4dC5wYXJlbnROb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsYXN0VGV4dE5vZGUgPSB0ZXh0O1xuICAgICAgICAgICAgcmV0dXJuIHByZWQoc3RhcnQsIHRleHQsIHRleHRPZmZzZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgcm9vdE5vZGUpKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBzcGFjZVJlc3VsdCA9IHdhbGsoY29udGFpbmVyLCBvZmZzZXQsIGZpbmRTcGFjZSk7XG4gICAgICByZXR1cm4gc3BhY2VSZXN1bHQuYmluZChyZXN1bHQgPT4gaW5jbHVkZVRyYWlsaW5nU3BhY2VzID8gd2FsayhyZXN1bHQuY29udGFpbmVyLCByZXN1bHQub2Zmc2V0ICsgKHN0YXJ0ID8gLTEgOiAwKSwgZmluZENvbnRlbnQpIDogT3B0aW9uYWwuc29tZShyZXN1bHQpKS5vclRodW5rKCgpID0+IGxhc3RUZXh0Tm9kZSA/IE9wdGlvbmFsLnNvbWUoe1xuICAgICAgICBjb250YWluZXI6IGxhc3RUZXh0Tm9kZSxcbiAgICAgICAgb2Zmc2V0OiBzdGFydCA/IDAgOiBsYXN0VGV4dE5vZGUubGVuZ3RoXG4gICAgICB9KSA6IE9wdGlvbmFsLm5vbmUoKSk7XG4gICAgfTtcbiAgICBjb25zdCBmaW5kU2VsZWN0b3JFbmRQb2ludCA9IChkb20sIGZvcm1hdExpc3QsIHJuZywgY29udGFpbmVyLCBzaWJsaW5nTmFtZSkgPT4ge1xuICAgICAgY29uc3Qgc2libGluZyA9IGNvbnRhaW5lcltzaWJsaW5nTmFtZV07XG4gICAgICBpZiAoaXNUZXh0JGEoY29udGFpbmVyKSAmJiBpc0VtcHR5JDMoY29udGFpbmVyLmRhdGEpICYmIHNpYmxpbmcpIHtcbiAgICAgICAgY29udGFpbmVyID0gc2libGluZztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcmVudHMgPSBnZXRQYXJlbnRzJDEoZG9tLCBjb250YWluZXIpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgZm9ybWF0TGlzdC5sZW5ndGg7IHkrKykge1xuICAgICAgICAgIGNvbnN0IGN1ckZvcm1hdCA9IGZvcm1hdExpc3RbeV07XG4gICAgICAgICAgaWYgKGlzTm9uTnVsbGFibGUoY3VyRm9ybWF0LmNvbGxhcHNlZCkgJiYgY3VyRm9ybWF0LmNvbGxhcHNlZCAhPT0gcm5nLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1NlbGVjdG9yRm9ybWF0KGN1ckZvcm1hdCkgJiYgZG9tLmlzKHBhcmVudHNbaV0sIGN1ckZvcm1hdC5zZWxlY3RvcikpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRzW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9O1xuICAgIGNvbnN0IGZpbmRCbG9ja0VuZFBvaW50ID0gKGRvbSwgZm9ybWF0TGlzdCwgY29udGFpbmVyLCBzaWJsaW5nTmFtZSkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgbGV0IG5vZGUgPSBjb250YWluZXI7XG4gICAgICBjb25zdCByb290ID0gZG9tLmdldFJvb3QoKTtcbiAgICAgIGNvbnN0IGZvcm1hdCA9IGZvcm1hdExpc3RbMF07XG4gICAgICBpZiAoaXNCbG9ja0Zvcm1hdChmb3JtYXQpKSB7XG4gICAgICAgIG5vZGUgPSBmb3JtYXQud3JhcHBlciA/IG51bGwgOiBkb20uZ2V0UGFyZW50KGNvbnRhaW5lciwgZm9ybWF0LmJsb2NrLCByb290KTtcbiAgICAgIH1cbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICBjb25zdCBzY29wZVJvb3QgPSAoX2EgPSBkb20uZ2V0UGFyZW50KGNvbnRhaW5lciwgJ0xJLFRELFRIJykpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHJvb3Q7XG4gICAgICAgIG5vZGUgPSBkb20uZ2V0UGFyZW50KGlzVGV4dCRhKGNvbnRhaW5lcikgPyBjb250YWluZXIucGFyZW50Tm9kZSA6IGNvbnRhaW5lciwgbm9kZSA9PiBub2RlICE9PSByb290ICYmIGlzVGV4dEJsb2NrKGRvbS5zY2hlbWEsIG5vZGUpLCBzY29wZVJvb3QpO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUgJiYgaXNCbG9ja0Zvcm1hdChmb3JtYXQpICYmIGZvcm1hdC53cmFwcGVyKSB7XG4gICAgICAgIG5vZGUgPSBnZXRQYXJlbnRzJDEoZG9tLCBub2RlLCAndWwsb2wnKS5yZXZlcnNlKClbMF0gfHwgbm9kZTtcbiAgICAgIH1cbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICBub2RlID0gY29udGFpbmVyO1xuICAgICAgICB3aGlsZSAobm9kZSAmJiBub2RlW3NpYmxpbmdOYW1lXSAmJiAhZG9tLmlzQmxvY2sobm9kZVtzaWJsaW5nTmFtZV0pKSB7XG4gICAgICAgICAgbm9kZSA9IG5vZGVbc2libGluZ05hbWVdO1xuICAgICAgICAgIGlmIChpc0VxJDUobm9kZSwgJ2JyJykpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGUgfHwgY29udGFpbmVyO1xuICAgIH07XG4gICAgY29uc3QgaXNBdEJsb2NrQm91bmRhcnkkMSA9IChkb20sIHJvb3QsIGNvbnRhaW5lciwgc2libGluZ05hbWUpID0+IHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IGNvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgICAgaWYgKGlzTm9uTnVsbGFibGUoY29udGFpbmVyW3NpYmxpbmdOYW1lXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChwYXJlbnQgPT09IHJvb3QgfHwgaXNOdWxsYWJsZShwYXJlbnQpIHx8IGRvbS5pc0Jsb2NrKHBhcmVudCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaXNBdEJsb2NrQm91bmRhcnkkMShkb20sIHJvb3QsIHBhcmVudCwgc2libGluZ05hbWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZmluZFBhcmVudENvbnRhaW5lciA9IChkb20sIGZvcm1hdExpc3QsIGNvbnRhaW5lciwgb2Zmc2V0LCBzdGFydCkgPT4ge1xuICAgICAgbGV0IHBhcmVudCA9IGNvbnRhaW5lcjtcbiAgICAgIGNvbnN0IHNpYmxpbmdOYW1lID0gc3RhcnQgPyAncHJldmlvdXNTaWJsaW5nJyA6ICduZXh0U2libGluZyc7XG4gICAgICBjb25zdCByb290ID0gZG9tLmdldFJvb3QoKTtcbiAgICAgIGlmIChpc1RleHQkYShjb250YWluZXIpICYmICFpc1doaXRlU3BhY2VOb2RlKGNvbnRhaW5lcikpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID8gb2Zmc2V0ID4gMCA6IG9mZnNldCA8IGNvbnRhaW5lci5kYXRhLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgaWYgKCFmb3JtYXRMaXN0WzBdLmJsb2NrX2V4cGFuZCAmJiBkb20uaXNCbG9jayhwYXJlbnQpKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBzaWJsaW5nID0gcGFyZW50W3NpYmxpbmdOYW1lXTsgc2libGluZzsgc2libGluZyA9IHNpYmxpbmdbc2libGluZ05hbWVdKSB7XG4gICAgICAgICAgY29uc3QgYWxsb3dTcGFjZXMgPSBpc1RleHQkYShzaWJsaW5nKSAmJiAhaXNBdEJsb2NrQm91bmRhcnkkMShkb20sIHJvb3QsIHNpYmxpbmcsIHNpYmxpbmdOYW1lKTtcbiAgICAgICAgICBpZiAoIWlzQm9va21hcmtOb2RlKHNpYmxpbmcpICYmICFpc0JvZ3VzQnIoc2libGluZykgJiYgIWlzV2hpdGVTcGFjZU5vZGUoc2libGluZywgYWxsb3dTcGFjZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyZW50ID09PSByb290IHx8IHBhcmVudC5wYXJlbnROb2RlID09PSByb290KSB7XG4gICAgICAgICAgY29udGFpbmVyID0gcGFyZW50O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9O1xuICAgIGNvbnN0IGlzU2VsZk9yUGFyZW50Qm9va21hcmsgPSBjb250YWluZXIgPT4gaXNCb29rbWFya05vZGUoY29udGFpbmVyLnBhcmVudE5vZGUpIHx8IGlzQm9va21hcmtOb2RlKGNvbnRhaW5lcik7XG4gICAgY29uc3QgZXhwYW5kUm5nID0gKGRvbSwgcm5nLCBmb3JtYXRMaXN0LCBpbmNsdWRlVHJhaWxpbmdTcGFjZSA9IGZhbHNlKSA9PiB7XG4gICAgICBsZXQge3N0YXJ0Q29udGFpbmVyLCBzdGFydE9mZnNldCwgZW5kQ29udGFpbmVyLCBlbmRPZmZzZXR9ID0gcm5nO1xuICAgICAgY29uc3QgZm9ybWF0ID0gZm9ybWF0TGlzdFswXTtcbiAgICAgIGlmIChpc0VsZW1lbnQkNihzdGFydENvbnRhaW5lcikgJiYgc3RhcnRDb250YWluZXIuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgIHN0YXJ0Q29udGFpbmVyID0gZ2V0Tm9kZSQxKHN0YXJ0Q29udGFpbmVyLCBzdGFydE9mZnNldCk7XG4gICAgICAgIGlmIChpc1RleHQkYShzdGFydENvbnRhaW5lcikpIHtcbiAgICAgICAgICBzdGFydE9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0VsZW1lbnQkNihlbmRDb250YWluZXIpICYmIGVuZENvbnRhaW5lci5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgZW5kQ29udGFpbmVyID0gZ2V0Tm9kZSQxKGVuZENvbnRhaW5lciwgcm5nLmNvbGxhcHNlZCA/IGVuZE9mZnNldCA6IGVuZE9mZnNldCAtIDEpO1xuICAgICAgICBpZiAoaXNUZXh0JGEoZW5kQ29udGFpbmVyKSkge1xuICAgICAgICAgIGVuZE9mZnNldCA9IGVuZENvbnRhaW5lci5kYXRhLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhcnRDb250YWluZXIgPSBmaW5kUGFyZW50Q29udGVudEVkaXRhYmxlKGRvbSwgc3RhcnRDb250YWluZXIpO1xuICAgICAgZW5kQ29udGFpbmVyID0gZmluZFBhcmVudENvbnRlbnRFZGl0YWJsZShkb20sIGVuZENvbnRhaW5lcik7XG4gICAgICBpZiAoaXNTZWxmT3JQYXJlbnRCb29rbWFyayhzdGFydENvbnRhaW5lcikpIHtcbiAgICAgICAgc3RhcnRDb250YWluZXIgPSBpc0Jvb2ttYXJrTm9kZShzdGFydENvbnRhaW5lcikgPyBzdGFydENvbnRhaW5lciA6IHN0YXJ0Q29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgICAgIGlmIChybmcuY29sbGFwc2VkKSB7XG4gICAgICAgICAgc3RhcnRDb250YWluZXIgPSBzdGFydENvbnRhaW5lci5wcmV2aW91c1NpYmxpbmcgfHwgc3RhcnRDb250YWluZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhcnRDb250YWluZXIgPSBzdGFydENvbnRhaW5lci5uZXh0U2libGluZyB8fCBzdGFydENvbnRhaW5lcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNUZXh0JGEoc3RhcnRDb250YWluZXIpKSB7XG4gICAgICAgICAgc3RhcnRPZmZzZXQgPSBybmcuY29sbGFwc2VkID8gc3RhcnRDb250YWluZXIubGVuZ3RoIDogMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzU2VsZk9yUGFyZW50Qm9va21hcmsoZW5kQ29udGFpbmVyKSkge1xuICAgICAgICBlbmRDb250YWluZXIgPSBpc0Jvb2ttYXJrTm9kZShlbmRDb250YWluZXIpID8gZW5kQ29udGFpbmVyIDogZW5kQ29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgICAgIGlmIChybmcuY29sbGFwc2VkKSB7XG4gICAgICAgICAgZW5kQ29udGFpbmVyID0gZW5kQ29udGFpbmVyLm5leHRTaWJsaW5nIHx8IGVuZENvbnRhaW5lcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbmRDb250YWluZXIgPSBlbmRDb250YWluZXIucHJldmlvdXNTaWJsaW5nIHx8IGVuZENvbnRhaW5lcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNUZXh0JGEoZW5kQ29udGFpbmVyKSkge1xuICAgICAgICAgIGVuZE9mZnNldCA9IHJuZy5jb2xsYXBzZWQgPyAwIDogZW5kQ29udGFpbmVyLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJuZy5jb2xsYXBzZWQpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRQb2ludCA9IGZpbmRXb3JkRW5kUG9pbnQoZG9tLCBkb20uZ2V0Um9vdCgpLCBzdGFydENvbnRhaW5lciwgc3RhcnRPZmZzZXQsIHRydWUsIGluY2x1ZGVUcmFpbGluZ1NwYWNlKTtcbiAgICAgICAgc3RhcnRQb2ludC5lYWNoKCh7Y29udGFpbmVyLCBvZmZzZXR9KSA9PiB7XG4gICAgICAgICAgc3RhcnRDb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgICAgc3RhcnRPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBlbmRQb2ludCA9IGZpbmRXb3JkRW5kUG9pbnQoZG9tLCBkb20uZ2V0Um9vdCgpLCBlbmRDb250YWluZXIsIGVuZE9mZnNldCwgZmFsc2UsIGluY2x1ZGVUcmFpbGluZ1NwYWNlKTtcbiAgICAgICAgZW5kUG9pbnQuZWFjaCgoe2NvbnRhaW5lciwgb2Zmc2V0fSkgPT4ge1xuICAgICAgICAgIGVuZENvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgICBlbmRPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzSW5saW5lRm9ybWF0KGZvcm1hdCkgfHwgZm9ybWF0LmJsb2NrX2V4cGFuZCkge1xuICAgICAgICBpZiAoIWlzSW5saW5lRm9ybWF0KGZvcm1hdCkgfHwgKCFpc1RleHQkYShzdGFydENvbnRhaW5lcikgfHwgc3RhcnRPZmZzZXQgPT09IDApKSB7XG4gICAgICAgICAgc3RhcnRDb250YWluZXIgPSBmaW5kUGFyZW50Q29udGFpbmVyKGRvbSwgZm9ybWF0TGlzdCwgc3RhcnRDb250YWluZXIsIHN0YXJ0T2Zmc2V0LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzSW5saW5lRm9ybWF0KGZvcm1hdCkgfHwgKCFpc1RleHQkYShlbmRDb250YWluZXIpIHx8IGVuZE9mZnNldCA9PT0gZW5kQ29udGFpbmVyLmRhdGEubGVuZ3RoKSkge1xuICAgICAgICAgIGVuZENvbnRhaW5lciA9IGZpbmRQYXJlbnRDb250YWluZXIoZG9tLCBmb3JtYXRMaXN0LCBlbmRDb250YWluZXIsIGVuZE9mZnNldCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkRXhwYW5kVG9TZWxlY3Rvcihmb3JtYXQpKSB7XG4gICAgICAgIHN0YXJ0Q29udGFpbmVyID0gZmluZFNlbGVjdG9yRW5kUG9pbnQoZG9tLCBmb3JtYXRMaXN0LCBybmcsIHN0YXJ0Q29udGFpbmVyLCAncHJldmlvdXNTaWJsaW5nJyk7XG4gICAgICAgIGVuZENvbnRhaW5lciA9IGZpbmRTZWxlY3RvckVuZFBvaW50KGRvbSwgZm9ybWF0TGlzdCwgcm5nLCBlbmRDb250YWluZXIsICduZXh0U2libGluZycpO1xuICAgICAgfVxuICAgICAgaWYgKGlzQmxvY2tGb3JtYXQoZm9ybWF0KSB8fCBpc1NlbGVjdG9yRm9ybWF0KGZvcm1hdCkpIHtcbiAgICAgICAgc3RhcnRDb250YWluZXIgPSBmaW5kQmxvY2tFbmRQb2ludChkb20sIGZvcm1hdExpc3QsIHN0YXJ0Q29udGFpbmVyLCAncHJldmlvdXNTaWJsaW5nJyk7XG4gICAgICAgIGVuZENvbnRhaW5lciA9IGZpbmRCbG9ja0VuZFBvaW50KGRvbSwgZm9ybWF0TGlzdCwgZW5kQ29udGFpbmVyLCAnbmV4dFNpYmxpbmcnKTtcbiAgICAgICAgaWYgKGlzQmxvY2tGb3JtYXQoZm9ybWF0KSkge1xuICAgICAgICAgIGlmICghZG9tLmlzQmxvY2soc3RhcnRDb250YWluZXIpKSB7XG4gICAgICAgICAgICBzdGFydENvbnRhaW5lciA9IGZpbmRQYXJlbnRDb250YWluZXIoZG9tLCBmb3JtYXRMaXN0LCBzdGFydENvbnRhaW5lciwgc3RhcnRPZmZzZXQsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWRvbS5pc0Jsb2NrKGVuZENvbnRhaW5lcikpIHtcbiAgICAgICAgICAgIGVuZENvbnRhaW5lciA9IGZpbmRQYXJlbnRDb250YWluZXIoZG9tLCBmb3JtYXRMaXN0LCBlbmRDb250YWluZXIsIGVuZE9mZnNldCwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzRWxlbWVudCQ2KHN0YXJ0Q29udGFpbmVyKSAmJiBzdGFydENvbnRhaW5lci5wYXJlbnROb2RlKSB7XG4gICAgICAgIHN0YXJ0T2Zmc2V0ID0gZG9tLm5vZGVJbmRleChzdGFydENvbnRhaW5lcik7XG4gICAgICAgIHN0YXJ0Q29udGFpbmVyID0gc3RhcnRDb250YWluZXIucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0VsZW1lbnQkNihlbmRDb250YWluZXIpICYmIGVuZENvbnRhaW5lci5wYXJlbnROb2RlKSB7XG4gICAgICAgIGVuZE9mZnNldCA9IGRvbS5ub2RlSW5kZXgoZW5kQ29udGFpbmVyKSArIDE7XG4gICAgICAgIGVuZENvbnRhaW5lciA9IGVuZENvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnRDb250YWluZXIsXG4gICAgICAgIHN0YXJ0T2Zmc2V0LFxuICAgICAgICBlbmRDb250YWluZXIsXG4gICAgICAgIGVuZE9mZnNldFxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3Qgd2FsayQzID0gKGRvbSwgcm5nLCBjYWxsYmFjaykgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBybmcuc3RhcnRPZmZzZXQ7XG4gICAgICBjb25zdCBzdGFydENvbnRhaW5lciA9IGdldE5vZGUkMShybmcuc3RhcnRDb250YWluZXIsIHN0YXJ0T2Zmc2V0KTtcbiAgICAgIGNvbnN0IGVuZE9mZnNldCA9IHJuZy5lbmRPZmZzZXQ7XG4gICAgICBjb25zdCBlbmRDb250YWluZXIgPSBnZXROb2RlJDEocm5nLmVuZENvbnRhaW5lciwgZW5kT2Zmc2V0IC0gMSk7XG4gICAgICBjb25zdCBleGNsdWRlID0gbm9kZXMgPT4ge1xuICAgICAgICBjb25zdCBmaXJzdE5vZGUgPSBub2Rlc1swXTtcbiAgICAgICAgaWYgKGlzVGV4dCRhKGZpcnN0Tm9kZSkgJiYgZmlyc3ROb2RlID09PSBzdGFydENvbnRhaW5lciAmJiBzdGFydE9mZnNldCA+PSBmaXJzdE5vZGUuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICBub2Rlcy5zcGxpY2UoMCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGFzdE5vZGUgPSBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGVuZE9mZnNldCA9PT0gMCAmJiBub2Rlcy5sZW5ndGggPiAwICYmIGxhc3ROb2RlID09PSBlbmRDb250YWluZXIgJiYgaXNUZXh0JGEobGFzdE5vZGUpKSB7XG4gICAgICAgICAgbm9kZXMuc3BsaWNlKG5vZGVzLmxlbmd0aCAtIDEsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICAgIH07XG4gICAgICBjb25zdCBjb2xsZWN0U2libGluZ3MgPSAobm9kZSwgbmFtZSwgZW5kTm9kZSkgPT4ge1xuICAgICAgICBjb25zdCBzaWJsaW5ncyA9IFtdO1xuICAgICAgICBmb3IgKDsgbm9kZSAmJiBub2RlICE9PSBlbmROb2RlOyBub2RlID0gbm9kZVtuYW1lXSkge1xuICAgICAgICAgIHNpYmxpbmdzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpYmxpbmdzO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGZpbmRFbmRQb2ludCA9IChub2RlLCByb290KSA9PiBkb20uZ2V0UGFyZW50KG5vZGUsIG5vZGUgPT4gbm9kZS5wYXJlbnROb2RlID09PSByb290LCByb290KTtcbiAgICAgIGNvbnN0IHdhbGtCb3VuZGFyeSA9IChzdGFydE5vZGUsIGVuZE5vZGUsIG5leHQpID0+IHtcbiAgICAgICAgY29uc3Qgc2libGluZ05hbWUgPSBuZXh0ID8gJ25leHRTaWJsaW5nJyA6ICdwcmV2aW91c1NpYmxpbmcnO1xuICAgICAgICBmb3IgKGxldCBub2RlID0gc3RhcnROb2RlLCBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7IG5vZGUgJiYgbm9kZSAhPT0gZW5kTm9kZTsgbm9kZSA9IHBhcmVudCkge1xuICAgICAgICAgIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICBjb25zdCBzaWJsaW5ncyA9IGNvbGxlY3RTaWJsaW5ncyhub2RlID09PSBzdGFydE5vZGUgPyBub2RlIDogbm9kZVtzaWJsaW5nTmFtZV0sIHNpYmxpbmdOYW1lKTtcbiAgICAgICAgICBpZiAoc2libGluZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIW5leHQpIHtcbiAgICAgICAgICAgICAgc2libGluZ3MucmV2ZXJzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2soZXhjbHVkZShzaWJsaW5ncykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChzdGFydENvbnRhaW5lciA9PT0gZW5kQ29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhleGNsdWRlKFtzdGFydENvbnRhaW5lcl0pKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFuY2VzdG9yID0gKF9hID0gZG9tLmZpbmRDb21tb25BbmNlc3RvcihzdGFydENvbnRhaW5lciwgZW5kQ29udGFpbmVyKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZG9tLmdldFJvb3QoKTtcbiAgICAgIGlmIChkb20uaXNDaGlsZE9mKHN0YXJ0Q29udGFpbmVyLCBlbmRDb250YWluZXIpKSB7XG4gICAgICAgIHJldHVybiB3YWxrQm91bmRhcnkoc3RhcnRDb250YWluZXIsIGFuY2VzdG9yLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChkb20uaXNDaGlsZE9mKGVuZENvbnRhaW5lciwgc3RhcnRDb250YWluZXIpKSB7XG4gICAgICAgIHJldHVybiB3YWxrQm91bmRhcnkoZW5kQ29udGFpbmVyLCBhbmNlc3Rvcik7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGFydFBvaW50ID0gZmluZEVuZFBvaW50KHN0YXJ0Q29udGFpbmVyLCBhbmNlc3RvcikgfHwgc3RhcnRDb250YWluZXI7XG4gICAgICBjb25zdCBlbmRQb2ludCA9IGZpbmRFbmRQb2ludChlbmRDb250YWluZXIsIGFuY2VzdG9yKSB8fCBlbmRDb250YWluZXI7XG4gICAgICB3YWxrQm91bmRhcnkoc3RhcnRDb250YWluZXIsIHN0YXJ0UG9pbnQsIHRydWUpO1xuICAgICAgY29uc3Qgc2libGluZ3MgPSBjb2xsZWN0U2libGluZ3Moc3RhcnRQb2ludCA9PT0gc3RhcnRDb250YWluZXIgPyBzdGFydFBvaW50IDogc3RhcnRQb2ludC5uZXh0U2libGluZywgJ25leHRTaWJsaW5nJywgZW5kUG9pbnQgPT09IGVuZENvbnRhaW5lciA/IGVuZFBvaW50Lm5leHRTaWJsaW5nIDogZW5kUG9pbnQpO1xuICAgICAgaWYgKHNpYmxpbmdzLmxlbmd0aCkge1xuICAgICAgICBjYWxsYmFjayhleGNsdWRlKHNpYmxpbmdzKSk7XG4gICAgICB9XG4gICAgICB3YWxrQm91bmRhcnkoZW5kQ29udGFpbmVyLCBlbmRQb2ludCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHZhbGlkQmxvY2tzID0gW1xuICAgICAgJ3ByZVtjbGFzcyo9bGFuZ3VhZ2UtXVtjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiXScsXG4gICAgICAnZmlndXJlLmltYWdlJyxcbiAgICAgICdkaXZbZGF0YS1lcGhveC1lbWJlZC1pcmldJyxcbiAgICAgICdkaXYudGlueS1wYWdlZW1iZWQnLFxuICAgICAgJ2Rpdi5tY2UtdG9jJyxcbiAgICAgICdkaXZbZGF0YS1tY2UtdG9jXSdcbiAgICBdO1xuICAgIGNvbnN0IGlzWmVyb1dpZHRoID0gZWxlbSA9PiBpc1RleHQkYihlbGVtKSAmJiBnZXQkMyhlbGVtKSA9PT0gWldTUCQxO1xuICAgIGNvbnN0IGNvbnRleHQgPSAoZWRpdG9yLCBlbGVtLCB3cmFwTmFtZSwgbm9kZU5hbWUpID0+IHBhcmVudChlbGVtKS5mb2xkKCgpID0+ICdza2lwcGluZycsIHBhcmVudCA9PiB7XG4gICAgICBpZiAobm9kZU5hbWUgPT09ICdicicgfHwgaXNaZXJvV2lkdGgoZWxlbSkpIHtcbiAgICAgICAgcmV0dXJuICd2YWxpZCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQW5ub3RhdGlvbihlbGVtKSkge1xuICAgICAgICByZXR1cm4gJ2V4aXN0aW5nJztcbiAgICAgIH0gZWxzZSBpZiAoaXNDYXJldE5vZGUoZWxlbS5kb20pKSB7XG4gICAgICAgIHJldHVybiAnY2FyZXQnO1xuICAgICAgfSBlbHNlIGlmIChleGlzdHModmFsaWRCbG9ja3MsIHNlbGVjdG9yID0+IGlzJDEoZWxlbSwgc2VsZWN0b3IpKSkge1xuICAgICAgICByZXR1cm4gJ3ZhbGlkLWJsb2NrJztcbiAgICAgIH0gZWxzZSBpZiAoIWlzVmFsaWQoZWRpdG9yLCB3cmFwTmFtZSwgbm9kZU5hbWUpIHx8ICFpc1ZhbGlkKGVkaXRvciwgbmFtZShwYXJlbnQpLCB3cmFwTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuICdpbnZhbGlkLWNoaWxkJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAndmFsaWQnO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgYXBwbHlXb3JkR3JhYiA9IChlZGl0b3IsIHJuZykgPT4ge1xuICAgICAgY29uc3QgciA9IGV4cGFuZFJuZyhlZGl0b3IuZG9tLCBybmcsIFt7IGlubGluZTogJ3NwYW4nIH1dKTtcbiAgICAgIHJuZy5zZXRTdGFydChyLnN0YXJ0Q29udGFpbmVyLCByLnN0YXJ0T2Zmc2V0KTtcbiAgICAgIHJuZy5zZXRFbmQoci5lbmRDb250YWluZXIsIHIuZW5kT2Zmc2V0KTtcbiAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Um5nKHJuZyk7XG4gICAgfTtcbiAgICBjb25zdCBhcHBseUFubm90YXRpb24gPSAoZWxlbSwgbWFzdGVyVUlkLCBkYXRhLCBhbm5vdGF0aW9uTmFtZSwgZGVjb3JhdGUsIGRpcmVjdEFubm90YXRpb24pID0+IHtcbiAgICAgIGNvbnN0IHt1aWQgPSBtYXN0ZXJVSWQsIC4uLm90aGVyRGF0YX0gPSBkYXRhO1xuICAgICAgYWRkJDIoZWxlbSwgYW5ub3RhdGlvbigpKTtcbiAgICAgIHNldCQzKGVsZW0sIGAkeyBkYXRhQW5ub3RhdGlvbklkKCkgfWAsIHVpZCk7XG4gICAgICBzZXQkMyhlbGVtLCBgJHsgZGF0YUFubm90YXRpb24oKSB9YCwgYW5ub3RhdGlvbk5hbWUpO1xuICAgICAgY29uc3Qge2F0dHJpYnV0ZXMgPSB7fSwgY2xhc3NlcyA9IFtdfSA9IGRlY29yYXRlKHVpZCwgb3RoZXJEYXRhKTtcbiAgICAgIHNldEFsbCQxKGVsZW0sIGF0dHJpYnV0ZXMpO1xuICAgICAgYWRkKGVsZW0sIGNsYXNzZXMpO1xuICAgICAgaWYgKGRpcmVjdEFubm90YXRpb24pIHtcbiAgICAgICAgaWYgKGNsYXNzZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHNldCQzKGVsZW0sIGAkeyBkYXRhQW5ub3RhdGlvbkNsYXNzZXMoKSB9YCwgY2xhc3Nlcy5qb2luKCcsJykpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWVzID0ga2V5cyhhdHRyaWJ1dGVzKTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZU5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzZXQkMyhlbGVtLCBgJHsgZGF0YUFubm90YXRpb25BdHRyaWJ1dGVzKCkgfWAsIGF0dHJpYnV0ZU5hbWVzLmpvaW4oJywnKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZURpcmVjdEFubm90YXRpb24gPSBlbGVtID0+IHtcbiAgICAgIHJlbW92ZSQ4KGVsZW0sIGFubm90YXRpb24oKSk7XG4gICAgICByZW1vdmUkYihlbGVtLCBgJHsgZGF0YUFubm90YXRpb25JZCgpIH1gKTtcbiAgICAgIHJlbW92ZSRiKGVsZW0sIGAkeyBkYXRhQW5ub3RhdGlvbigpIH1gKTtcbiAgICAgIHJlbW92ZSRiKGVsZW0sIGAkeyBkYXRhQW5ub3RhdGlvbkFjdGl2ZSgpIH1gKTtcbiAgICAgIGNvbnN0IGN1c3RvbUF0dHJOYW1lcyA9IGdldE9wdChlbGVtLCBgJHsgZGF0YUFubm90YXRpb25BdHRyaWJ1dGVzKCkgfWApLm1hcChuYW1lcyA9PiBuYW1lcy5zcGxpdCgnLCcpKS5nZXRPcihbXSk7XG4gICAgICBjb25zdCBjdXN0b21DbGFzc2VzID0gZ2V0T3B0KGVsZW0sIGAkeyBkYXRhQW5ub3RhdGlvbkNsYXNzZXMoKSB9YCkubWFwKG5hbWVzID0+IG5hbWVzLnNwbGl0KCcsJykpLmdldE9yKFtdKTtcbiAgICAgIGVhY2gkZShjdXN0b21BdHRyTmFtZXMsIG5hbWUgPT4gcmVtb3ZlJGIoZWxlbSwgbmFtZSkpO1xuICAgICAgcmVtb3ZlJDUoZWxlbSwgY3VzdG9tQ2xhc3Nlcyk7XG4gICAgICByZW1vdmUkYihlbGVtLCBgJHsgZGF0YUFubm90YXRpb25DbGFzc2VzKCkgfWApO1xuICAgICAgcmVtb3ZlJGIoZWxlbSwgYCR7IGRhdGFBbm5vdGF0aW9uQXR0cmlidXRlcygpIH1gKTtcbiAgICB9O1xuICAgIGNvbnN0IG1ha2VBbm5vdGF0aW9uID0gKGVEb2MsIHVpZCwgZGF0YSwgYW5ub3RhdGlvbk5hbWUsIGRlY29yYXRlKSA9PiB7XG4gICAgICBjb25zdCBtYXN0ZXIgPSBTdWdhckVsZW1lbnQuZnJvbVRhZygnc3BhbicsIGVEb2MpO1xuICAgICAgYXBwbHlBbm5vdGF0aW9uKG1hc3RlciwgdWlkLCBkYXRhLCBhbm5vdGF0aW9uTmFtZSwgZGVjb3JhdGUsIGZhbHNlKTtcbiAgICAgIHJldHVybiBtYXN0ZXI7XG4gICAgfTtcbiAgICBjb25zdCBhbm5vdGF0ZSA9IChlZGl0b3IsIHJuZywgdWlkLCBhbm5vdGF0aW9uTmFtZSwgZGVjb3JhdGUsIGRhdGEpID0+IHtcbiAgICAgIGNvbnN0IG5ld1dyYXBwZXJzID0gW107XG4gICAgICBjb25zdCBtYXN0ZXIgPSBtYWtlQW5ub3RhdGlvbihlZGl0b3IuZ2V0RG9jKCksIHVpZCwgZGF0YSwgYW5ub3RhdGlvbk5hbWUsIGRlY29yYXRlKTtcbiAgICAgIGNvbnN0IHdyYXBwZXIgPSB2YWx1ZSQyKCk7XG4gICAgICBjb25zdCBmaW5pc2hXcmFwcGVyID0gKCkgPT4ge1xuICAgICAgICB3cmFwcGVyLmNsZWFyKCk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0T3JPcGVuV3JhcHBlciA9ICgpID0+IHdyYXBwZXIuZ2V0KCkuZ2V0T3JUaHVuaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IG51ID0gc2hhbGxvdyQxKG1hc3Rlcik7XG4gICAgICAgIG5ld1dyYXBwZXJzLnB1c2gobnUpO1xuICAgICAgICB3cmFwcGVyLnNldChudSk7XG4gICAgICAgIHJldHVybiBudTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcHJvY2Vzc0VsZW1lbnRzID0gZWxlbXMgPT4ge1xuICAgICAgICBlYWNoJGUoZWxlbXMsIHByb2Nlc3NFbGVtZW50KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBwcm9jZXNzRWxlbWVudCA9IGVsZW0gPT4ge1xuICAgICAgICBjb25zdCBjdHggPSBjb250ZXh0KGVkaXRvciwgZWxlbSwgJ3NwYW4nLCBuYW1lKGVsZW0pKTtcbiAgICAgICAgc3dpdGNoIChjdHgpIHtcbiAgICAgICAgY2FzZSAnaW52YWxpZC1jaGlsZCc6IHtcbiAgICAgICAgICAgIGZpbmlzaFdyYXBwZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gY2hpbGRyZW4kMShlbGVtKTtcbiAgICAgICAgICAgIHByb2Nlc3NFbGVtZW50cyhjaGlsZHJlbik7XG4gICAgICAgICAgICBmaW5pc2hXcmFwcGVyKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3ZhbGlkLWJsb2NrJzoge1xuICAgICAgICAgICAgZmluaXNoV3JhcHBlcigpO1xuICAgICAgICAgICAgYXBwbHlBbm5vdGF0aW9uKGVsZW0sIHVpZCwgZGF0YSwgYW5ub3RhdGlvbk5hbWUsIGRlY29yYXRlLCB0cnVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAndmFsaWQnOiB7XG4gICAgICAgICAgICBjb25zdCB3ID0gZ2V0T3JPcGVuV3JhcHBlcigpO1xuICAgICAgICAgICAgd3JhcCQyKGVsZW0sIHcpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgcHJvY2Vzc05vZGVzID0gbm9kZXMgPT4ge1xuICAgICAgICBjb25zdCBlbGVtcyA9IG1hcCQzKG5vZGVzLCBTdWdhckVsZW1lbnQuZnJvbURvbSk7XG4gICAgICAgIHByb2Nlc3NFbGVtZW50cyhlbGVtcyk7XG4gICAgICB9O1xuICAgICAgd2FsayQzKGVkaXRvci5kb20sIHJuZywgbm9kZXMgPT4ge1xuICAgICAgICBmaW5pc2hXcmFwcGVyKCk7XG4gICAgICAgIHByb2Nlc3NOb2Rlcyhub2Rlcyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXdXcmFwcGVycztcbiAgICB9O1xuICAgIGNvbnN0IGFubm90YXRlV2l0aEJvb2ttYXJrID0gKGVkaXRvciwgbmFtZSwgc2V0dGluZ3MsIGRhdGEpID0+IHtcbiAgICAgIGVkaXRvci51bmRvTWFuYWdlci50cmFuc2FjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgICAgIGNvbnN0IGluaXRpYWxSbmcgPSBzZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICAgIGNvbnN0IGhhc0Zha2VTZWxlY3Rpb24gPSBnZXRDZWxsc0Zyb21FZGl0b3IoZWRpdG9yKS5sZW5ndGggPiAwO1xuICAgICAgICBjb25zdCBtYXN0ZXJVaWQgPSBnZW5lcmF0ZSQxKCdtY2UtYW5ub3RhdGlvbicpO1xuICAgICAgICBpZiAoaW5pdGlhbFJuZy5jb2xsYXBzZWQgJiYgIWhhc0Zha2VTZWxlY3Rpb24pIHtcbiAgICAgICAgICBhcHBseVdvcmRHcmFiKGVkaXRvciwgaW5pdGlhbFJuZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGVjdGlvbi5nZXRSbmcoKS5jb2xsYXBzZWQgJiYgIWhhc0Zha2VTZWxlY3Rpb24pIHtcbiAgICAgICAgICBjb25zdCB3cmFwcGVyID0gbWFrZUFubm90YXRpb24oZWRpdG9yLmdldERvYygpLCBtYXN0ZXJVaWQsIGRhdGEsIG5hbWUsIHNldHRpbmdzLmRlY29yYXRlKTtcbiAgICAgICAgICBzZXQkMSh3cmFwcGVyLCBuYnNwKTtcbiAgICAgICAgICBzZWxlY3Rpb24uZ2V0Um5nKCkuaW5zZXJ0Tm9kZSh3cmFwcGVyLmRvbSk7XG4gICAgICAgICAgc2VsZWN0aW9uLnNlbGVjdCh3cmFwcGVyLmRvbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJlc2VydmUoc2VsZWN0aW9uLCBmYWxzZSwgKCkgPT4ge1xuICAgICAgICAgICAgcnVuT25SYW5nZXMoZWRpdG9yLCBzZWxlY3Rpb25SbmcgPT4ge1xuICAgICAgICAgICAgICBhbm5vdGF0ZShlZGl0b3IsIHNlbGVjdGlvblJuZywgbWFzdGVyVWlkLCBuYW1lLCBzZXR0aW5ncy5kZWNvcmF0ZSwgZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IEFubm90YXRvciA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCByZWdpc3RyeSA9IGNyZWF0ZSRjKCk7XG4gICAgICBzZXR1cCR3KGVkaXRvciwgcmVnaXN0cnkpO1xuICAgICAgY29uc3QgY2hhbmdlcyA9IHNldHVwJHgoZWRpdG9yLCByZWdpc3RyeSk7XG4gICAgICBjb25zdCBpc1NwYW4gPSBpc1RhZygnc3BhbicpO1xuICAgICAgY29uc3QgcmVtb3ZlQW5ub3RhdGlvbnMgPSBlbGVtZW50cyA9PiB7XG4gICAgICAgIGVhY2gkZShlbGVtZW50cywgZWxlbWVudCA9PiB7XG4gICAgICAgICAgaWYgKGlzU3BhbihlbGVtZW50KSkge1xuICAgICAgICAgICAgdW53cmFwKGVsZW1lbnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW1vdmVEaXJlY3RBbm5vdGF0aW9uKGVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVnaXN0ZXI6IChuYW1lLCBzZXR0aW5ncykgPT4ge1xuICAgICAgICAgIHJlZ2lzdHJ5LnJlZ2lzdGVyKG5hbWUsIHNldHRpbmdzKTtcbiAgICAgICAgfSxcbiAgICAgICAgYW5ub3RhdGU6IChuYW1lLCBkYXRhKSA9PiB7XG4gICAgICAgICAgcmVnaXN0cnkubG9va3VwKG5hbWUpLmVhY2goc2V0dGluZ3MgPT4ge1xuICAgICAgICAgICAgYW5ub3RhdGVXaXRoQm9va21hcmsoZWRpdG9yLCBuYW1lLCBzZXR0aW5ncywgZGF0YSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFubm90YXRpb25DaGFuZ2VkOiAobmFtZSwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICBjaGFuZ2VzLmFkZExpc3RlbmVyKG5hbWUsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlOiBuYW1lID0+IHtcbiAgICAgICAgICBpZGVudGlmeShlZGl0b3IsIE9wdGlvbmFsLnNvbWUobmFtZSkpLmVhY2goKHtlbGVtZW50c30pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJvb2ttYXJrID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRCb29rbWFyaygpO1xuICAgICAgICAgICAgcmVtb3ZlQW5ub3RhdGlvbnMoZWxlbWVudHMpO1xuICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5tb3ZlVG9Cb29rbWFyayhib29rbWFyayk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUFsbDogbmFtZSA9PiB7XG4gICAgICAgICAgY29uc3QgYm9va21hcmsgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldEJvb2ttYXJrKCk7XG4gICAgICAgICAgZWFjaCRkKGZpbmRBbGwoZWRpdG9yLCBuYW1lKSwgKGVsZW1lbnRzLCBfKSA9PiB7XG4gICAgICAgICAgICByZW1vdmVBbm5vdGF0aW9ucyhlbGVtZW50cyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5tb3ZlVG9Cb29rbWFyayhib29rbWFyayk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEFsbDogbmFtZSA9PiB7XG4gICAgICAgICAgY29uc3QgZGlyZWN0b3J5ID0gZmluZEFsbChlZGl0b3IsIG5hbWUpO1xuICAgICAgICAgIHJldHVybiBtYXAkMihkaXJlY3RvcnksIGVsZW1zID0+IG1hcCQzKGVsZW1zLCBlbGVtID0+IGVsZW0uZG9tKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IEJvb2ttYXJrTWFuYWdlciA9IHNlbGVjdGlvbiA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBnZXRCb29rbWFyazogY3VycnkoZ2V0Qm9va21hcmskMSwgc2VsZWN0aW9uKSxcbiAgICAgICAgbW92ZVRvQm9va21hcms6IGN1cnJ5KG1vdmVUb0Jvb2ttYXJrLCBzZWxlY3Rpb24pXG4gICAgICB9O1xuICAgIH07XG4gICAgQm9va21hcmtNYW5hZ2VyLmlzQm9va21hcmtOb2RlID0gaXNCb29rbWFya05vZGUkMTtcblxuICAgIGNvbnN0IGlzWFlXaXRoaW5SYW5nZSA9IChjbGllbnRYLCBjbGllbnRZLCByYW5nZSkgPT4ge1xuICAgICAgaWYgKHJhbmdlLmNvbGxhcHNlZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZXhpc3RzKHJhbmdlLmdldENsaWVudFJlY3RzKCksIHJlY3QgPT4gY29udGFpbnNYWShyZWN0LCBjbGllbnRYLCBjbGllbnRZKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGZpcmVQcmVQcm9jZXNzID0gKGVkaXRvciwgYXJncykgPT4gZWRpdG9yLmRpc3BhdGNoKCdQcmVQcm9jZXNzJywgYXJncyk7XG4gICAgY29uc3QgZmlyZVBvc3RQcm9jZXNzID0gKGVkaXRvciwgYXJncykgPT4gZWRpdG9yLmRpc3BhdGNoKCdQb3N0UHJvY2VzcycsIGFyZ3MpO1xuICAgIGNvbnN0IGZpcmVSZW1vdmUgPSBlZGl0b3IgPT4ge1xuICAgICAgZWRpdG9yLmRpc3BhdGNoKCdyZW1vdmUnKTtcbiAgICB9O1xuICAgIGNvbnN0IGZpcmVEZXRhY2ggPSBlZGl0b3IgPT4ge1xuICAgICAgZWRpdG9yLmRpc3BhdGNoKCdkZXRhY2gnKTtcbiAgICB9O1xuICAgIGNvbnN0IGZpcmVTd2l0Y2hNb2RlID0gKGVkaXRvciwgbW9kZSkgPT4ge1xuICAgICAgZWRpdG9yLmRpc3BhdGNoKCdTd2l0Y2hNb2RlJywgeyBtb2RlIH0pO1xuICAgIH07XG4gICAgY29uc3QgZmlyZU9iamVjdFJlc2l6ZVN0YXJ0ID0gKGVkaXRvciwgdGFyZ2V0LCB3aWR0aCwgaGVpZ2h0LCBvcmlnaW4pID0+IHtcbiAgICAgIGVkaXRvci5kaXNwYXRjaCgnT2JqZWN0UmVzaXplU3RhcnQnLCB7XG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgb3JpZ2luXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGZpcmVPYmplY3RSZXNpemVkID0gKGVkaXRvciwgdGFyZ2V0LCB3aWR0aCwgaGVpZ2h0LCBvcmlnaW4pID0+IHtcbiAgICAgIGVkaXRvci5kaXNwYXRjaCgnT2JqZWN0UmVzaXplZCcsIHtcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICBvcmlnaW5cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgZmlyZVByZUluaXQgPSBlZGl0b3IgPT4ge1xuICAgICAgZWRpdG9yLmRpc3BhdGNoKCdQcmVJbml0Jyk7XG4gICAgfTtcbiAgICBjb25zdCBmaXJlUG9zdFJlbmRlciA9IGVkaXRvciA9PiB7XG4gICAgICBlZGl0b3IuZGlzcGF0Y2goJ1Bvc3RSZW5kZXInKTtcbiAgICB9O1xuICAgIGNvbnN0IGZpcmVJbml0ID0gZWRpdG9yID0+IHtcbiAgICAgIGVkaXRvci5kaXNwYXRjaCgnSW5pdCcpO1xuICAgIH07XG4gICAgY29uc3QgZmlyZVBsYWNlaG9sZGVyVG9nZ2xlID0gKGVkaXRvciwgc3RhdGUpID0+IHtcbiAgICAgIGVkaXRvci5kaXNwYXRjaCgnUGxhY2Vob2xkZXJUb2dnbGUnLCB7IHN0YXRlIH0pO1xuICAgIH07XG4gICAgY29uc3QgZmlyZUVycm9yID0gKGVkaXRvciwgZXJyb3JUeXBlLCBlcnJvcikgPT4ge1xuICAgICAgZWRpdG9yLmRpc3BhdGNoKGVycm9yVHlwZSwgZXJyb3IpO1xuICAgIH07XG4gICAgY29uc3QgZmlyZUZvcm1hdEFwcGx5ID0gKGVkaXRvciwgZm9ybWF0LCBub2RlLCB2YXJzKSA9PiB7XG4gICAgICBlZGl0b3IuZGlzcGF0Y2goJ0Zvcm1hdEFwcGx5Jywge1xuICAgICAgICBmb3JtYXQsXG4gICAgICAgIG5vZGUsXG4gICAgICAgIHZhcnNcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgZmlyZUZvcm1hdFJlbW92ZSA9IChlZGl0b3IsIGZvcm1hdCwgbm9kZSwgdmFycykgPT4ge1xuICAgICAgZWRpdG9yLmRpc3BhdGNoKCdGb3JtYXRSZW1vdmUnLCB7XG4gICAgICAgIGZvcm1hdCxcbiAgICAgICAgbm9kZSxcbiAgICAgICAgdmFyc1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBmaXJlQmVmb3JlU2V0Q29udGVudCA9IChlZGl0b3IsIGFyZ3MpID0+IGVkaXRvci5kaXNwYXRjaCgnQmVmb3JlU2V0Q29udGVudCcsIGFyZ3MpO1xuICAgIGNvbnN0IGZpcmVTZXRDb250ZW50ID0gKGVkaXRvciwgYXJncykgPT4gZWRpdG9yLmRpc3BhdGNoKCdTZXRDb250ZW50JywgYXJncyk7XG4gICAgY29uc3QgZmlyZUJlZm9yZUdldENvbnRlbnQgPSAoZWRpdG9yLCBhcmdzKSA9PiBlZGl0b3IuZGlzcGF0Y2goJ0JlZm9yZUdldENvbnRlbnQnLCBhcmdzKTtcbiAgICBjb25zdCBmaXJlR2V0Q29udGVudCA9IChlZGl0b3IsIGFyZ3MpID0+IGVkaXRvci5kaXNwYXRjaCgnR2V0Q29udGVudCcsIGFyZ3MpO1xuICAgIGNvbnN0IGZpcmVBdXRvY29tcGxldGVyU3RhcnQgPSAoZWRpdG9yLCBhcmdzKSA9PiB7XG4gICAgICBlZGl0b3IuZGlzcGF0Y2goJ0F1dG9jb21wbGV0ZXJTdGFydCcsIGFyZ3MpO1xuICAgIH07XG4gICAgY29uc3QgZmlyZUF1dG9jb21wbGV0ZXJVcGRhdGUgPSAoZWRpdG9yLCBhcmdzKSA9PiB7XG4gICAgICBlZGl0b3IuZGlzcGF0Y2goJ0F1dG9jb21wbGV0ZXJVcGRhdGUnLCBhcmdzKTtcbiAgICB9O1xuICAgIGNvbnN0IGZpcmVBdXRvY29tcGxldGVyRW5kID0gZWRpdG9yID0+IHtcbiAgICAgIGVkaXRvci5kaXNwYXRjaCgnQXV0b2NvbXBsZXRlckVuZCcpO1xuICAgIH07XG4gICAgY29uc3QgZmlyZVBhc3RlUHJlUHJvY2VzcyA9IChlZGl0b3IsIGh0bWwsIGludGVybmFsKSA9PiBlZGl0b3IuZGlzcGF0Y2goJ1Bhc3RlUHJlUHJvY2VzcycsIHtcbiAgICAgIGNvbnRlbnQ6IGh0bWwsXG4gICAgICBpbnRlcm5hbFxuICAgIH0pO1xuICAgIGNvbnN0IGZpcmVQYXN0ZVBvc3RQcm9jZXNzID0gKGVkaXRvciwgbm9kZSwgaW50ZXJuYWwpID0+IGVkaXRvci5kaXNwYXRjaCgnUGFzdGVQb3N0UHJvY2VzcycsIHtcbiAgICAgIG5vZGUsXG4gICAgICBpbnRlcm5hbFxuICAgIH0pO1xuICAgIGNvbnN0IGZpcmVQYXN0ZVBsYWluVGV4dFRvZ2dsZSA9IChlZGl0b3IsIHN0YXRlKSA9PiBlZGl0b3IuZGlzcGF0Y2goJ1Bhc3RlUGxhaW5UZXh0VG9nZ2xlJywgeyBzdGF0ZSB9KTtcblxuICAgIGNvbnN0IFZLID0ge1xuICAgICAgQkFDS1NQQUNFOiA4LFxuICAgICAgREVMRVRFOiA0NixcbiAgICAgIERPV046IDQwLFxuICAgICAgRU5URVI6IDEzLFxuICAgICAgRVNDOiAyNyxcbiAgICAgIExFRlQ6IDM3LFxuICAgICAgUklHSFQ6IDM5LFxuICAgICAgU1BBQ0VCQVI6IDMyLFxuICAgICAgVEFCOiA5LFxuICAgICAgVVA6IDM4LFxuICAgICAgUEFHRV9VUDogMzMsXG4gICAgICBQQUdFX0RPV046IDM0LFxuICAgICAgRU5EOiAzNSxcbiAgICAgIEhPTUU6IDM2LFxuICAgICAgbW9kaWZpZXJQcmVzc2VkOiBlID0+IHtcbiAgICAgICAgcmV0dXJuIGUuc2hpZnRLZXkgfHwgZS5jdHJsS2V5IHx8IGUuYWx0S2V5IHx8IFZLLm1ldGFLZXlQcmVzc2VkKGUpO1xuICAgICAgfSxcbiAgICAgIG1ldGFLZXlQcmVzc2VkOiBlID0+IHtcbiAgICAgICAgcmV0dXJuIEVudi5vcy5pc01hY09TKCkgfHwgRW52Lm9zLmlzaU9TKCkgPyBlLm1ldGFLZXkgOiBlLmN0cmxLZXkgJiYgIWUuYWx0S2V5O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBlbGVtZW50U2VsZWN0aW9uQXR0ciA9ICdkYXRhLW1jZS1zZWxlY3RlZCc7XG4gICAgY29uc3QgY29udHJvbEVsbVNlbGVjdG9yID0gJ3RhYmxlLGltZyxmaWd1cmUuaW1hZ2UsaHIsdmlkZW8sc3Bhbi5tY2UtcHJldmlldy1vYmplY3QnO1xuICAgIGNvbnN0IGFicyA9IE1hdGguYWJzO1xuICAgIGNvbnN0IHJvdW5kJDEgPSBNYXRoLnJvdW5kO1xuICAgIGNvbnN0IHJlc2l6ZUhhbmRsZXMgPSB7XG4gICAgICBudzogW1xuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAtMSxcbiAgICAgICAgLTFcbiAgICAgIF0sXG4gICAgICBuZTogW1xuICAgICAgICAxLFxuICAgICAgICAwLFxuICAgICAgICAxLFxuICAgICAgICAtMVxuICAgICAgXSxcbiAgICAgIHNlOiBbXG4gICAgICAgIDEsXG4gICAgICAgIDEsXG4gICAgICAgIDEsXG4gICAgICAgIDFcbiAgICAgIF0sXG4gICAgICBzdzogW1xuICAgICAgICAwLFxuICAgICAgICAxLFxuICAgICAgICAtMSxcbiAgICAgICAgMVxuICAgICAgXVxuICAgIH07XG4gICAgY29uc3QgaXNUb3VjaEV2ZW50ID0gZXZ0ID0+IGV2dC50eXBlID09PSAnbG9uZ3ByZXNzJyB8fCBldnQudHlwZS5pbmRleE9mKCd0b3VjaCcpID09PSAwO1xuICAgIGNvbnN0IENvbnRyb2xTZWxlY3Rpb24gPSAoc2VsZWN0aW9uLCBlZGl0b3IpID0+IHtcbiAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb207XG4gICAgICBjb25zdCBlZGl0YWJsZURvYyA9IGVkaXRvci5nZXREb2MoKTtcbiAgICAgIGNvbnN0IHJvb3REb2N1bWVudCA9IGRvY3VtZW50O1xuICAgICAgY29uc3Qgcm9vdEVsZW1lbnQgPSBlZGl0b3IuZ2V0Qm9keSgpO1xuICAgICAgbGV0IHNlbGVjdGVkRWxtLCBzZWxlY3RlZEVsbUdob3N0LCByZXNpemVIZWxwZXIsIHNlbGVjdGVkSGFuZGxlLCByZXNpemVCYWNrZHJvcDtcbiAgICAgIGxldCBzdGFydFgsIHN0YXJ0WSwgc2VsZWN0ZWRFbG1YLCBzZWxlY3RlZEVsbVksIHN0YXJ0Vywgc3RhcnRILCByYXRpbywgcmVzaXplU3RhcnRlZDtcbiAgICAgIGxldCB3aWR0aDtcbiAgICAgIGxldCBoZWlnaHQ7XG4gICAgICBsZXQgc3RhcnRTY3JvbGxXaWR0aDtcbiAgICAgIGxldCBzdGFydFNjcm9sbEhlaWdodDtcbiAgICAgIGNvbnN0IGlzSW1hZ2UgPSBlbG0gPT4gaXNOb25OdWxsYWJsZShlbG0pICYmIChpc0ltZyhlbG0pIHx8IGRvbS5pcyhlbG0sICdmaWd1cmUuaW1hZ2UnKSk7XG4gICAgICBjb25zdCBpc01lZGlhID0gZWxtID0+IGlzTWVkaWEkMihlbG0pIHx8IGRvbS5oYXNDbGFzcyhlbG0sICdtY2UtcHJldmlldy1vYmplY3QnKTtcbiAgICAgIGNvbnN0IGlzRXZlbnRPbkltYWdlT3V0c2lkZVJhbmdlID0gKGV2dCwgcmFuZ2UpID0+IHtcbiAgICAgICAgaWYgKGlzVG91Y2hFdmVudChldnQpKSB7XG4gICAgICAgICAgY29uc3QgdG91Y2ggPSBldnQudG91Y2hlc1swXTtcbiAgICAgICAgICByZXR1cm4gaXNJbWFnZShldnQudGFyZ2V0KSAmJiAhaXNYWVdpdGhpblJhbmdlKHRvdWNoLmNsaWVudFgsIHRvdWNoLmNsaWVudFksIHJhbmdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gaXNJbWFnZShldnQudGFyZ2V0KSAmJiAhaXNYWVdpdGhpblJhbmdlKGV2dC5jbGllbnRYLCBldnQuY2xpZW50WSwgcmFuZ2UpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgY29udGV4dE1lbnVTZWxlY3RJbWFnZSA9IGV2dCA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGV2dC50YXJnZXQ7XG4gICAgICAgIGlmIChpc0V2ZW50T25JbWFnZU91dHNpZGVSYW5nZShldnQsIGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCkpICYmICFldnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNlbGVjdCh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0UmVzaXplVGFyZ2V0cyA9IGVsbSA9PiB7XG4gICAgICAgIGlmIChkb20uaGFzQ2xhc3MoZWxtLCAnbWNlLXByZXZpZXctb2JqZWN0JykgJiYgaXNOb25OdWxsYWJsZShlbG0uZmlyc3RFbGVtZW50Q2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGVsbSxcbiAgICAgICAgICAgIGVsbS5maXJzdEVsZW1lbnRDaGlsZFxuICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSBpZiAoZG9tLmlzKGVsbSwgJ2ZpZ3VyZS5pbWFnZScpKSB7XG4gICAgICAgICAgcmV0dXJuIFtlbG0ucXVlcnlTZWxlY3RvcignaW1nJyldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbZWxtXTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzUmVzaXphYmxlID0gZWxtID0+IHtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRPYmplY3RSZXNpemluZyhlZGl0b3IpO1xuICAgICAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbG0uZ2V0QXR0cmlidXRlKCdkYXRhLW1jZS1yZXNpemUnKSA9PT0gJ2ZhbHNlJykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxtID09PSBlZGl0b3IuZ2V0Qm9keSgpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb20uaGFzQ2xhc3MoZWxtLCAnbWNlLXByZXZpZXctb2JqZWN0JykgJiYgaXNOb25OdWxsYWJsZShlbG0uZmlyc3RFbGVtZW50Q2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIGlzJDEoU3VnYXJFbGVtZW50LmZyb21Eb20oZWxtLmZpcnN0RWxlbWVudENoaWxkKSwgc2VsZWN0b3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBpcyQxKFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVsbSksIHNlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNyZWF0ZUdob3N0RWxlbWVudCA9IGVsbSA9PiB7XG4gICAgICAgIGlmIChpc01lZGlhKGVsbSkpIHtcbiAgICAgICAgICByZXR1cm4gZG9tLmNyZWF0ZSgnaW1nJywgeyBzcmM6IEVudi50cmFuc3BhcmVudFNyYyB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZWxtLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNldFNpemVQcm9wID0gKGVsZW1lbnQsIG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmIChpc05vbk51bGxhYmxlKHZhbHVlKSkge1xuICAgICAgICAgIGNvbnN0IHRhcmdldHMgPSBnZXRSZXNpemVUYXJnZXRzKGVsZW1lbnQpO1xuICAgICAgICAgIGVhY2gkZSh0YXJnZXRzLCB0YXJnZXQgPT4ge1xuICAgICAgICAgICAgaWYgKHRhcmdldC5zdHlsZVtuYW1lXSB8fCAhZWRpdG9yLnNjaGVtYS5pc1ZhbGlkKHRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLCBuYW1lKSkge1xuICAgICAgICAgICAgICBkb20uc2V0U3R5bGUodGFyZ2V0LCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkb20uc2V0QXR0cmliKHRhcmdldCwgbmFtZSwgJycgKyB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBzZXRHaG9zdEVsbVNpemUgPSAoZ2hvc3RFbG0sIHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICAgICAgc2V0U2l6ZVByb3AoZ2hvc3RFbG0sICd3aWR0aCcsIHdpZHRoKTtcbiAgICAgICAgc2V0U2l6ZVByb3AoZ2hvc3RFbG0sICdoZWlnaHQnLCBoZWlnaHQpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlc2l6ZUdob3N0RWxlbWVudCA9IGUgPT4ge1xuICAgICAgICBsZXQgZGVsdGFYLCBkZWx0YVksIHByb3BvcnRpb25hbDtcbiAgICAgICAgbGV0IHJlc2l6ZUhlbHBlclgsIHJlc2l6ZUhlbHBlclk7XG4gICAgICAgIGRlbHRhWCA9IGUuc2NyZWVuWCAtIHN0YXJ0WDtcbiAgICAgICAgZGVsdGFZID0gZS5zY3JlZW5ZIC0gc3RhcnRZO1xuICAgICAgICB3aWR0aCA9IGRlbHRhWCAqIHNlbGVjdGVkSGFuZGxlWzJdICsgc3RhcnRXO1xuICAgICAgICBoZWlnaHQgPSBkZWx0YVkgKiBzZWxlY3RlZEhhbmRsZVszXSArIHN0YXJ0SDtcbiAgICAgICAgd2lkdGggPSB3aWR0aCA8IDUgPyA1IDogd2lkdGg7XG4gICAgICAgIGhlaWdodCA9IGhlaWdodCA8IDUgPyA1IDogaGVpZ2h0O1xuICAgICAgICBpZiAoKGlzSW1hZ2Uoc2VsZWN0ZWRFbG0pIHx8IGlzTWVkaWEoc2VsZWN0ZWRFbG0pKSAmJiBnZXRSZXNpemVJbWdQcm9wb3J0aW9uYWwoZWRpdG9yKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBwcm9wb3J0aW9uYWwgPSAhVksubW9kaWZpZXJQcmVzc2VkKGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BvcnRpb25hbCA9IFZLLm1vZGlmaWVyUHJlc3NlZChlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcG9ydGlvbmFsKSB7XG4gICAgICAgICAgaWYgKGFicyhkZWx0YVgpID4gYWJzKGRlbHRhWSkpIHtcbiAgICAgICAgICAgIGhlaWdodCA9IHJvdW5kJDEod2lkdGggKiByYXRpbyk7XG4gICAgICAgICAgICB3aWR0aCA9IHJvdW5kJDEoaGVpZ2h0IC8gcmF0aW8pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aWR0aCA9IHJvdW5kJDEoaGVpZ2h0IC8gcmF0aW8pO1xuICAgICAgICAgICAgaGVpZ2h0ID0gcm91bmQkMSh3aWR0aCAqIHJhdGlvKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2V0R2hvc3RFbG1TaXplKHNlbGVjdGVkRWxtR2hvc3QsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICByZXNpemVIZWxwZXJYID0gc2VsZWN0ZWRIYW5kbGUuc3RhcnRQb3MueCArIGRlbHRhWDtcbiAgICAgICAgcmVzaXplSGVscGVyWSA9IHNlbGVjdGVkSGFuZGxlLnN0YXJ0UG9zLnkgKyBkZWx0YVk7XG4gICAgICAgIHJlc2l6ZUhlbHBlclggPSByZXNpemVIZWxwZXJYID4gMCA/IHJlc2l6ZUhlbHBlclggOiAwO1xuICAgICAgICByZXNpemVIZWxwZXJZID0gcmVzaXplSGVscGVyWSA+IDAgPyByZXNpemVIZWxwZXJZIDogMDtcbiAgICAgICAgZG9tLnNldFN0eWxlcyhyZXNpemVIZWxwZXIsIHtcbiAgICAgICAgICBsZWZ0OiByZXNpemVIZWxwZXJYLFxuICAgICAgICAgIHRvcDogcmVzaXplSGVscGVyWSxcbiAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgICAgIH0pO1xuICAgICAgICByZXNpemVIZWxwZXIuaW5uZXJIVE1MID0gd2lkdGggKyAnICZ0aW1lczsgJyArIGhlaWdodDtcbiAgICAgICAgaWYgKHNlbGVjdGVkSGFuZGxlWzJdIDwgMCAmJiBzZWxlY3RlZEVsbUdob3N0LmNsaWVudFdpZHRoIDw9IHdpZHRoKSB7XG4gICAgICAgICAgZG9tLnNldFN0eWxlKHNlbGVjdGVkRWxtR2hvc3QsICdsZWZ0Jywgc2VsZWN0ZWRFbG1YICsgKHN0YXJ0VyAtIHdpZHRoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGVjdGVkSGFuZGxlWzNdIDwgMCAmJiBzZWxlY3RlZEVsbUdob3N0LmNsaWVudEhlaWdodCA8PSBoZWlnaHQpIHtcbiAgICAgICAgICBkb20uc2V0U3R5bGUoc2VsZWN0ZWRFbG1HaG9zdCwgJ3RvcCcsIHNlbGVjdGVkRWxtWSArIChzdGFydEggLSBoZWlnaHQpKTtcbiAgICAgICAgfVxuICAgICAgICBkZWx0YVggPSByb290RWxlbWVudC5zY3JvbGxXaWR0aCAtIHN0YXJ0U2Nyb2xsV2lkdGg7XG4gICAgICAgIGRlbHRhWSA9IHJvb3RFbGVtZW50LnNjcm9sbEhlaWdodCAtIHN0YXJ0U2Nyb2xsSGVpZ2h0O1xuICAgICAgICBpZiAoZGVsdGFYICsgZGVsdGFZICE9PSAwKSB7XG4gICAgICAgICAgZG9tLnNldFN0eWxlcyhyZXNpemVIZWxwZXIsIHtcbiAgICAgICAgICAgIGxlZnQ6IHJlc2l6ZUhlbHBlclggLSBkZWx0YVgsXG4gICAgICAgICAgICB0b3A6IHJlc2l6ZUhlbHBlclkgLSBkZWx0YVlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc2l6ZVN0YXJ0ZWQpIHtcbiAgICAgICAgICBmaXJlT2JqZWN0UmVzaXplU3RhcnQoZWRpdG9yLCBzZWxlY3RlZEVsbSwgc3RhcnRXLCBzdGFydEgsICdjb3JuZXItJyArIHNlbGVjdGVkSGFuZGxlLm5hbWUpO1xuICAgICAgICAgIHJlc2l6ZVN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgZW5kR2hvc3RSZXNpemUgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHdhc1Jlc2l6ZVN0YXJ0ZWQgPSByZXNpemVTdGFydGVkO1xuICAgICAgICByZXNpemVTdGFydGVkID0gZmFsc2U7XG4gICAgICAgIGlmICh3YXNSZXNpemVTdGFydGVkKSB7XG4gICAgICAgICAgc2V0U2l6ZVByb3Aoc2VsZWN0ZWRFbG0sICd3aWR0aCcsIHdpZHRoKTtcbiAgICAgICAgICBzZXRTaXplUHJvcChzZWxlY3RlZEVsbSwgJ2hlaWdodCcsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZG9tLnVuYmluZChlZGl0YWJsZURvYywgJ21vdXNlbW92ZScsIHJlc2l6ZUdob3N0RWxlbWVudCk7XG4gICAgICAgIGRvbS51bmJpbmQoZWRpdGFibGVEb2MsICdtb3VzZXVwJywgZW5kR2hvc3RSZXNpemUpO1xuICAgICAgICBpZiAocm9vdERvY3VtZW50ICE9PSBlZGl0YWJsZURvYykge1xuICAgICAgICAgIGRvbS51bmJpbmQocm9vdERvY3VtZW50LCAnbW91c2Vtb3ZlJywgcmVzaXplR2hvc3RFbGVtZW50KTtcbiAgICAgICAgICBkb20udW5iaW5kKHJvb3REb2N1bWVudCwgJ21vdXNldXAnLCBlbmRHaG9zdFJlc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZG9tLnJlbW92ZShzZWxlY3RlZEVsbUdob3N0KTtcbiAgICAgICAgZG9tLnJlbW92ZShyZXNpemVIZWxwZXIpO1xuICAgICAgICBkb20ucmVtb3ZlKHJlc2l6ZUJhY2tkcm9wKTtcbiAgICAgICAgc2hvd1Jlc2l6ZVJlY3Qoc2VsZWN0ZWRFbG0pO1xuICAgICAgICBpZiAod2FzUmVzaXplU3RhcnRlZCkge1xuICAgICAgICAgIGZpcmVPYmplY3RSZXNpemVkKGVkaXRvciwgc2VsZWN0ZWRFbG0sIHdpZHRoLCBoZWlnaHQsICdjb3JuZXItJyArIHNlbGVjdGVkSGFuZGxlLm5hbWUpO1xuICAgICAgICAgIGRvbS5zZXRBdHRyaWIoc2VsZWN0ZWRFbG0sICdzdHlsZScsIGRvbS5nZXRBdHRyaWIoc2VsZWN0ZWRFbG0sICdzdHlsZScpKTtcbiAgICAgICAgfVxuICAgICAgICBlZGl0b3Iubm9kZUNoYW5nZWQoKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBzaG93UmVzaXplUmVjdCA9IHRhcmdldEVsbSA9PiB7XG4gICAgICAgIHVuYmluZFJlc2l6ZUhhbmRsZUV2ZW50cygpO1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGRvbS5nZXRQb3ModGFyZ2V0RWxtLCByb290RWxlbWVudCk7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkRWxtWCA9IHBvc2l0aW9uLng7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkRWxtWSA9IHBvc2l0aW9uLnk7XG4gICAgICAgIGNvbnN0IHJlY3QgPSB0YXJnZXRFbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IHRhcmdldFdpZHRoID0gcmVjdC53aWR0aCB8fCByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0O1xuICAgICAgICBjb25zdCB0YXJnZXRIZWlnaHQgPSByZWN0LmhlaWdodCB8fCByZWN0LmJvdHRvbSAtIHJlY3QudG9wO1xuICAgICAgICBpZiAoc2VsZWN0ZWRFbG0gIT09IHRhcmdldEVsbSkge1xuICAgICAgICAgIGhpZGVSZXNpemVSZWN0KCk7XG4gICAgICAgICAgc2VsZWN0ZWRFbG0gPSB0YXJnZXRFbG07XG4gICAgICAgICAgd2lkdGggPSBoZWlnaHQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGUgPSBlZGl0b3IuZGlzcGF0Y2goJ09iamVjdFNlbGVjdGVkJywgeyB0YXJnZXQ6IHRhcmdldEVsbSB9KTtcbiAgICAgICAgaWYgKGlzUmVzaXphYmxlKHRhcmdldEVsbSkgJiYgIWUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICBlYWNoJGQocmVzaXplSGFuZGxlcywgKGhhbmRsZSwgbmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnREcmFnID0gZSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGdldFJlc2l6ZVRhcmdldHMoc2VsZWN0ZWRFbG0pWzBdO1xuICAgICAgICAgICAgICBzdGFydFggPSBlLnNjcmVlblg7XG4gICAgICAgICAgICAgIHN0YXJ0WSA9IGUuc2NyZWVuWTtcbiAgICAgICAgICAgICAgc3RhcnRXID0gdGFyZ2V0LmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgICBzdGFydEggPSB0YXJnZXQuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgICByYXRpbyA9IHN0YXJ0SCAvIHN0YXJ0VztcbiAgICAgICAgICAgICAgc2VsZWN0ZWRIYW5kbGUgPSBoYW5kbGU7XG4gICAgICAgICAgICAgIHNlbGVjdGVkSGFuZGxlLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgICBzZWxlY3RlZEhhbmRsZS5zdGFydFBvcyA9IHtcbiAgICAgICAgICAgICAgICB4OiB0YXJnZXRXaWR0aCAqIGhhbmRsZVswXSArIHNlbGVjdGVkRWxtWCxcbiAgICAgICAgICAgICAgICB5OiB0YXJnZXRIZWlnaHQgKiBoYW5kbGVbMV0gKyBzZWxlY3RlZEVsbVlcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgc3RhcnRTY3JvbGxXaWR0aCA9IHJvb3RFbGVtZW50LnNjcm9sbFdpZHRoO1xuICAgICAgICAgICAgICBzdGFydFNjcm9sbEhlaWdodCA9IHJvb3RFbGVtZW50LnNjcm9sbEhlaWdodDtcbiAgICAgICAgICAgICAgcmVzaXplQmFja2Ryb3AgPSBkb20uYWRkKHJvb3RFbGVtZW50LCAnZGl2Jywge1xuICAgICAgICAgICAgICAgICdjbGFzcyc6ICdtY2UtcmVzaXplLWJhY2tkcm9wJyxcbiAgICAgICAgICAgICAgICAnZGF0YS1tY2UtYm9ndXMnOiAnYWxsJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgZG9tLnNldFN0eWxlcyhyZXNpemVCYWNrZHJvcCwge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgICAgICAgICAgIGxlZnQ6ICcwJyxcbiAgICAgICAgICAgICAgICB0b3A6ICcwJyxcbiAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogJzEwMCUnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBzZWxlY3RlZEVsbUdob3N0ID0gY3JlYXRlR2hvc3RFbGVtZW50KHNlbGVjdGVkRWxtKTtcbiAgICAgICAgICAgICAgZG9tLmFkZENsYXNzKHNlbGVjdGVkRWxtR2hvc3QsICdtY2UtY2xvbmVkcmVzaXphYmxlJyk7XG4gICAgICAgICAgICAgIGRvbS5zZXRBdHRyaWIoc2VsZWN0ZWRFbG1HaG9zdCwgJ2RhdGEtbWNlLWJvZ3VzJywgJ2FsbCcpO1xuICAgICAgICAgICAgICBzZWxlY3RlZEVsbUdob3N0LmNvbnRlbnRFZGl0YWJsZSA9ICdmYWxzZSc7XG4gICAgICAgICAgICAgIGRvbS5zZXRTdHlsZXMoc2VsZWN0ZWRFbG1HaG9zdCwge1xuICAgICAgICAgICAgICAgIGxlZnQ6IHNlbGVjdGVkRWxtWCxcbiAgICAgICAgICAgICAgICB0b3A6IHNlbGVjdGVkRWxtWSxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHNldEdob3N0RWxtU2l6ZShzZWxlY3RlZEVsbUdob3N0LCB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0KTtcbiAgICAgICAgICAgICAgc2VsZWN0ZWRFbG1HaG9zdC5yZW1vdmVBdHRyaWJ1dGUoZWxlbWVudFNlbGVjdGlvbkF0dHIpO1xuICAgICAgICAgICAgICByb290RWxlbWVudC5hcHBlbmRDaGlsZChzZWxlY3RlZEVsbUdob3N0KTtcbiAgICAgICAgICAgICAgZG9tLmJpbmQoZWRpdGFibGVEb2MsICdtb3VzZW1vdmUnLCByZXNpemVHaG9zdEVsZW1lbnQpO1xuICAgICAgICAgICAgICBkb20uYmluZChlZGl0YWJsZURvYywgJ21vdXNldXAnLCBlbmRHaG9zdFJlc2l6ZSk7XG4gICAgICAgICAgICAgIGlmIChyb290RG9jdW1lbnQgIT09IGVkaXRhYmxlRG9jKSB7XG4gICAgICAgICAgICAgICAgZG9tLmJpbmQocm9vdERvY3VtZW50LCAnbW91c2Vtb3ZlJywgcmVzaXplR2hvc3RFbGVtZW50KTtcbiAgICAgICAgICAgICAgICBkb20uYmluZChyb290RG9jdW1lbnQsICdtb3VzZXVwJywgZW5kR2hvc3RSZXNpemUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc2l6ZUhlbHBlciA9IGRvbS5hZGQocm9vdEVsZW1lbnQsICdkaXYnLCB7XG4gICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21jZS1yZXNpemUtaGVscGVyJyxcbiAgICAgICAgICAgICAgICAnZGF0YS1tY2UtYm9ndXMnOiAnYWxsJ1xuICAgICAgICAgICAgICB9LCBzdGFydFcgKyAnICZ0aW1lczsgJyArIHN0YXJ0SCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IGhhbmRsZUVsbSA9IGRvbS5nZXQoJ21jZVJlc2l6ZUhhbmRsZScgKyBuYW1lKTtcbiAgICAgICAgICAgIGlmIChoYW5kbGVFbG0pIHtcbiAgICAgICAgICAgICAgZG9tLnJlbW92ZShoYW5kbGVFbG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlRWxtID0gZG9tLmFkZChyb290RWxlbWVudCwgJ2RpdicsIHtcbiAgICAgICAgICAgICAgJ2lkJzogJ21jZVJlc2l6ZUhhbmRsZScgKyBuYW1lLFxuICAgICAgICAgICAgICAnZGF0YS1tY2UtYm9ndXMnOiAnYWxsJyxcbiAgICAgICAgICAgICAgJ2NsYXNzJzogJ21jZS1yZXNpemVoYW5kbGUnLFxuICAgICAgICAgICAgICAndW5zZWxlY3RhYmxlJzogdHJ1ZSxcbiAgICAgICAgICAgICAgJ3N0eWxlJzogJ2N1cnNvcjonICsgbmFtZSArICctcmVzaXplOyBtYXJnaW46MDsgcGFkZGluZzowJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkb20uYmluZChoYW5kbGVFbG0sICdtb3VzZWRvd24nLCBlID0+IHtcbiAgICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICBzdGFydERyYWcoZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGhhbmRsZS5lbG0gPSBoYW5kbGVFbG07XG4gICAgICAgICAgICBkb20uc2V0U3R5bGVzKGhhbmRsZUVsbSwge1xuICAgICAgICAgICAgICBsZWZ0OiB0YXJnZXRXaWR0aCAqIGhhbmRsZVswXSArIHNlbGVjdGVkRWxtWCAtIGhhbmRsZUVsbS5vZmZzZXRXaWR0aCAvIDIsXG4gICAgICAgICAgICAgIHRvcDogdGFyZ2V0SGVpZ2h0ICogaGFuZGxlWzFdICsgc2VsZWN0ZWRFbG1ZIC0gaGFuZGxlRWxtLm9mZnNldEhlaWdodCAvIDJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhpZGVSZXNpemVSZWN0KGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHRocm90dGxlZFNob3dSZXNpemVSZWN0ID0gZmlyc3QkMShzaG93UmVzaXplUmVjdCwgMCk7XG4gICAgICBjb25zdCBoaWRlUmVzaXplUmVjdCA9IChyZW1vdmVTZWxlY3RlZCA9IHRydWUpID0+IHtcbiAgICAgICAgdGhyb3R0bGVkU2hvd1Jlc2l6ZVJlY3QuY2FuY2VsKCk7XG4gICAgICAgIHVuYmluZFJlc2l6ZUhhbmRsZUV2ZW50cygpO1xuICAgICAgICBpZiAoc2VsZWN0ZWRFbG0gJiYgcmVtb3ZlU2VsZWN0ZWQpIHtcbiAgICAgICAgICBzZWxlY3RlZEVsbS5yZW1vdmVBdHRyaWJ1dGUoZWxlbWVudFNlbGVjdGlvbkF0dHIpO1xuICAgICAgICB9XG4gICAgICAgIGVhY2gkZChyZXNpemVIYW5kbGVzLCAodmFsdWUsIG5hbWUpID0+IHtcbiAgICAgICAgICBjb25zdCBoYW5kbGVFbG0gPSBkb20uZ2V0KCdtY2VSZXNpemVIYW5kbGUnICsgbmFtZSk7XG4gICAgICAgICAgaWYgKGhhbmRsZUVsbSkge1xuICAgICAgICAgICAgZG9tLnVuYmluZChoYW5kbGVFbG0pO1xuICAgICAgICAgICAgZG9tLnJlbW92ZShoYW5kbGVFbG0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgaXNDaGlsZE9yRXF1YWwgPSAobm9kZSwgcGFyZW50KSA9PiBkb20uaXNDaGlsZE9mKG5vZGUsIHBhcmVudCk7XG4gICAgICBjb25zdCB1cGRhdGVSZXNpemVSZWN0ID0gZSA9PiB7XG4gICAgICAgIGlmIChyZXNpemVTdGFydGVkIHx8IGVkaXRvci5yZW1vdmVkIHx8IGVkaXRvci5jb21wb3NpbmcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0RWxtID0gZS50eXBlID09PSAnbW91c2Vkb3duJyA/IGUudGFyZ2V0IDogc2VsZWN0aW9uLmdldE5vZGUoKTtcbiAgICAgICAgY29uc3QgY29udHJvbEVsbSA9IGNsb3Nlc3QkMyhTdWdhckVsZW1lbnQuZnJvbURvbSh0YXJnZXRFbG0pLCBjb250cm9sRWxtU2VsZWN0b3IpLm1hcChlID0+IGUuZG9tKS5maWx0ZXIoZSA9PiBkb20uaXNFZGl0YWJsZShlLnBhcmVudEVsZW1lbnQpKS5nZXRPclVuZGVmaW5lZCgpO1xuICAgICAgICBjb25zdCBzZWxlY3RlZFZhbHVlID0gaXNOb25OdWxsYWJsZShjb250cm9sRWxtKSA/IGRvbS5nZXRBdHRyaWIoY29udHJvbEVsbSwgZWxlbWVudFNlbGVjdGlvbkF0dHIsICcxJykgOiAnMSc7XG4gICAgICAgIGVhY2gkZShkb20uc2VsZWN0KGBpbWdbJHsgZWxlbWVudFNlbGVjdGlvbkF0dHIgfV0saHJbJHsgZWxlbWVudFNlbGVjdGlvbkF0dHIgfV1gKSwgaW1nID0+IHtcbiAgICAgICAgICBpbWcucmVtb3ZlQXR0cmlidXRlKGVsZW1lbnRTZWxlY3Rpb25BdHRyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc05vbk51bGxhYmxlKGNvbnRyb2xFbG0pICYmIGlzQ2hpbGRPckVxdWFsKGNvbnRyb2xFbG0sIHJvb3RFbGVtZW50KSkge1xuICAgICAgICAgIGRpc2FibGVHZWNrb1Jlc2l6ZSgpO1xuICAgICAgICAgIGNvbnN0IHN0YXJ0RWxtID0gc2VsZWN0aW9uLmdldFN0YXJ0KHRydWUpO1xuICAgICAgICAgIGlmIChpc0NoaWxkT3JFcXVhbChzdGFydEVsbSwgY29udHJvbEVsbSkgJiYgaXNDaGlsZE9yRXF1YWwoc2VsZWN0aW9uLmdldEVuZCh0cnVlKSwgY29udHJvbEVsbSkpIHtcbiAgICAgICAgICAgIGRvbS5zZXRBdHRyaWIoY29udHJvbEVsbSwgZWxlbWVudFNlbGVjdGlvbkF0dHIsIHNlbGVjdGVkVmFsdWUpO1xuICAgICAgICAgICAgdGhyb3R0bGVkU2hvd1Jlc2l6ZVJlY3QudGhyb3R0bGUoY29udHJvbEVsbSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGhpZGVSZXNpemVSZWN0KCk7XG4gICAgICB9O1xuICAgICAgY29uc3QgdW5iaW5kUmVzaXplSGFuZGxlRXZlbnRzID0gKCkgPT4ge1xuICAgICAgICBlYWNoJGQocmVzaXplSGFuZGxlcywgaGFuZGxlID0+IHtcbiAgICAgICAgICBpZiAoaGFuZGxlLmVsbSkge1xuICAgICAgICAgICAgZG9tLnVuYmluZChoYW5kbGUuZWxtKTtcbiAgICAgICAgICAgIGRlbGV0ZSBoYW5kbGUuZWxtO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZGlzYWJsZUdlY2tvUmVzaXplID0gKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGVkaXRvci5nZXREb2MoKS5leGVjQ29tbWFuZCgnZW5hYmxlT2JqZWN0UmVzaXppbmcnLCBmYWxzZSwgJ2ZhbHNlJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBlZGl0b3Iub24oJ2luaXQnLCAoKSA9PiB7XG4gICAgICAgIGRpc2FibGVHZWNrb1Jlc2l6ZSgpO1xuICAgICAgICBlZGl0b3Iub24oJ05vZGVDaGFuZ2UgUmVzaXplRWRpdG9yIFJlc2l6ZVdpbmRvdyBSZXNpemVDb250ZW50IGRyb3AnLCB1cGRhdGVSZXNpemVSZWN0KTtcbiAgICAgICAgZWRpdG9yLm9uKCdrZXl1cCBjb21wb3NpdGlvbmVuZCcsIGUgPT4ge1xuICAgICAgICAgIGlmIChzZWxlY3RlZEVsbSAmJiBzZWxlY3RlZEVsbS5ub2RlTmFtZSA9PT0gJ1RBQkxFJykge1xuICAgICAgICAgICAgdXBkYXRlUmVzaXplUmVjdChlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBlZGl0b3Iub24oJ2hpZGUgYmx1cicsIGhpZGVSZXNpemVSZWN0KTtcbiAgICAgICAgZWRpdG9yLm9uKCdjb250ZXh0bWVudSBsb25ncHJlc3MnLCBjb250ZXh0TWVudVNlbGVjdEltYWdlLCB0cnVlKTtcbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm9uKCdyZW1vdmUnLCB1bmJpbmRSZXNpemVIYW5kbGVFdmVudHMpO1xuICAgICAgY29uc3QgZGVzdHJveSA9ICgpID0+IHtcbiAgICAgICAgdGhyb3R0bGVkU2hvd1Jlc2l6ZVJlY3QuY2FuY2VsKCk7XG4gICAgICAgIHNlbGVjdGVkRWxtID0gc2VsZWN0ZWRFbG1HaG9zdCA9IHJlc2l6ZUJhY2tkcm9wID0gbnVsbDtcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc1Jlc2l6YWJsZSxcbiAgICAgICAgc2hvd1Jlc2l6ZVJlY3QsXG4gICAgICAgIGhpZGVSZXNpemVSZWN0LFxuICAgICAgICB1cGRhdGVSZXNpemVSZWN0LFxuICAgICAgICBkZXN0cm95XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBzZXRTdGFydCA9IChybmcsIHNpdHUpID0+IHtcbiAgICAgIHNpdHUuZm9sZChlID0+IHtcbiAgICAgICAgcm5nLnNldFN0YXJ0QmVmb3JlKGUuZG9tKTtcbiAgICAgIH0sIChlLCBvKSA9PiB7XG4gICAgICAgIHJuZy5zZXRTdGFydChlLmRvbSwgbyk7XG4gICAgICB9LCBlID0+IHtcbiAgICAgICAgcm5nLnNldFN0YXJ0QWZ0ZXIoZS5kb20pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBzZXRGaW5pc2ggPSAocm5nLCBzaXR1KSA9PiB7XG4gICAgICBzaXR1LmZvbGQoZSA9PiB7XG4gICAgICAgIHJuZy5zZXRFbmRCZWZvcmUoZS5kb20pO1xuICAgICAgfSwgKGUsIG8pID0+IHtcbiAgICAgICAgcm5nLnNldEVuZChlLmRvbSwgbyk7XG4gICAgICB9LCBlID0+IHtcbiAgICAgICAgcm5nLnNldEVuZEFmdGVyKGUuZG9tKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgcmVsYXRpdmVUb05hdGl2ZSA9ICh3aW4sIHN0YXJ0U2l0dSwgZmluaXNoU2l0dSkgPT4ge1xuICAgICAgY29uc3QgcmFuZ2UgPSB3aW4uZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgIHNldFN0YXJ0KHJhbmdlLCBzdGFydFNpdHUpO1xuICAgICAgc2V0RmluaXNoKHJhbmdlLCBmaW5pc2hTaXR1KTtcbiAgICAgIHJldHVybiByYW5nZTtcbiAgICB9O1xuICAgIGNvbnN0IGV4YWN0VG9OYXRpdmUgPSAod2luLCBzdGFydCwgc29mZnNldCwgZmluaXNoLCBmb2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCBybmcgPSB3aW4uZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgIHJuZy5zZXRTdGFydChzdGFydC5kb20sIHNvZmZzZXQpO1xuICAgICAgcm5nLnNldEVuZChmaW5pc2guZG9tLCBmb2Zmc2V0KTtcbiAgICAgIHJldHVybiBybmc7XG4gICAgfTtcblxuICAgIGNvbnN0IGFkdCQzID0gQWR0LmdlbmVyYXRlKFtcbiAgICAgIHtcbiAgICAgICAgbHRyOiBbXG4gICAgICAgICAgJ3N0YXJ0JyxcbiAgICAgICAgICAnc29mZnNldCcsXG4gICAgICAgICAgJ2ZpbmlzaCcsXG4gICAgICAgICAgJ2ZvZmZzZXQnXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHJ0bDogW1xuICAgICAgICAgICdzdGFydCcsXG4gICAgICAgICAgJ3NvZmZzZXQnLFxuICAgICAgICAgICdmaW5pc2gnLFxuICAgICAgICAgICdmb2Zmc2V0J1xuICAgICAgICBdXG4gICAgICB9XG4gICAgXSk7XG4gICAgY29uc3QgZnJvbVJhbmdlID0gKHdpbiwgdHlwZSwgcmFuZ2UpID0+IHR5cGUoU3VnYXJFbGVtZW50LmZyb21Eb20ocmFuZ2Uuc3RhcnRDb250YWluZXIpLCByYW5nZS5zdGFydE9mZnNldCwgU3VnYXJFbGVtZW50LmZyb21Eb20ocmFuZ2UuZW5kQ29udGFpbmVyKSwgcmFuZ2UuZW5kT2Zmc2V0KTtcbiAgICBjb25zdCBnZXRSYW5nZXMgPSAod2luLCBzZWxlY3Rpb24pID0+IHNlbGVjdGlvbi5tYXRjaCh7XG4gICAgICBkb21SYW5nZTogcm5nID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsdHI6IGNvbnN0YW50KHJuZyksXG4gICAgICAgICAgcnRsOiBPcHRpb25hbC5ub25lXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgcmVsYXRpdmU6IChzdGFydFNpdHUsIGZpbmlzaFNpdHUpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsdHI6IGNhY2hlZCgoKSA9PiByZWxhdGl2ZVRvTmF0aXZlKHdpbiwgc3RhcnRTaXR1LCBmaW5pc2hTaXR1KSksXG4gICAgICAgICAgcnRsOiBjYWNoZWQoKCkgPT4gT3B0aW9uYWwuc29tZShyZWxhdGl2ZVRvTmF0aXZlKHdpbiwgZmluaXNoU2l0dSwgc3RhcnRTaXR1KSkpXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgZXhhY3Q6IChzdGFydCwgc29mZnNldCwgZmluaXNoLCBmb2Zmc2V0KSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbHRyOiBjYWNoZWQoKCkgPT4gZXhhY3RUb05hdGl2ZSh3aW4sIHN0YXJ0LCBzb2Zmc2V0LCBmaW5pc2gsIGZvZmZzZXQpKSxcbiAgICAgICAgICBydGw6IGNhY2hlZCgoKSA9PiBPcHRpb25hbC5zb21lKGV4YWN0VG9OYXRpdmUod2luLCBmaW5pc2gsIGZvZmZzZXQsIHN0YXJ0LCBzb2Zmc2V0KSkpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgZG9EaWFnbm9zZSA9ICh3aW4sIHJhbmdlcykgPT4ge1xuICAgICAgY29uc3Qgcm5nID0gcmFuZ2VzLmx0cigpO1xuICAgICAgaWYgKHJuZy5jb2xsYXBzZWQpIHtcbiAgICAgICAgY29uc3QgcmV2ZXJzZWQgPSByYW5nZXMucnRsKCkuZmlsdGVyKHJldiA9PiByZXYuY29sbGFwc2VkID09PSBmYWxzZSk7XG4gICAgICAgIHJldHVybiByZXZlcnNlZC5tYXAocmV2ID0+IGFkdCQzLnJ0bChTdWdhckVsZW1lbnQuZnJvbURvbShyZXYuZW5kQ29udGFpbmVyKSwgcmV2LmVuZE9mZnNldCwgU3VnYXJFbGVtZW50LmZyb21Eb20ocmV2LnN0YXJ0Q29udGFpbmVyKSwgcmV2LnN0YXJ0T2Zmc2V0KSkuZ2V0T3JUaHVuaygoKSA9PiBmcm9tUmFuZ2Uod2luLCBhZHQkMy5sdHIsIHJuZykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZyb21SYW5nZSh3aW4sIGFkdCQzLmx0ciwgcm5nKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGRpYWdub3NlID0gKHdpbiwgc2VsZWN0aW9uKSA9PiB7XG4gICAgICBjb25zdCByYW5nZXMgPSBnZXRSYW5nZXMod2luLCBzZWxlY3Rpb24pO1xuICAgICAgcmV0dXJuIGRvRGlhZ25vc2Uod2luLCByYW5nZXMpO1xuICAgIH07XG4gICAgYWR0JDMubHRyO1xuICAgIGFkdCQzLnJ0bDtcblxuICAgIGNvbnN0IGNyZWF0ZSRhID0gKHN0YXJ0LCBzb2Zmc2V0LCBmaW5pc2gsIGZvZmZzZXQpID0+ICh7XG4gICAgICBzdGFydCxcbiAgICAgIHNvZmZzZXQsXG4gICAgICBmaW5pc2gsXG4gICAgICBmb2Zmc2V0XG4gICAgfSk7XG4gICAgY29uc3QgU2ltUmFuZ2UgPSB7IGNyZWF0ZTogY3JlYXRlJGEgfTtcblxuICAgIGNvbnN0IGNhcmV0UG9zaXRpb25Gcm9tUG9pbnQgPSAoZG9jLCB4LCB5KSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgcmV0dXJuIE9wdGlvbmFsLmZyb20oKF9iID0gKF9hID0gZG9jLmRvbSkuY2FyZXRQb3NpdGlvbkZyb21Qb2ludCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHgsIHkpKS5iaW5kKHBvcyA9PiB7XG4gICAgICAgIGlmIChwb3Mub2Zmc2V0Tm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgciA9IGRvYy5kb20uY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgci5zZXRTdGFydChwb3Mub2Zmc2V0Tm9kZSwgcG9zLm9mZnNldCk7XG4gICAgICAgIHIuY29sbGFwc2UoKTtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUocik7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGNhcmV0UmFuZ2VGcm9tUG9pbnQgPSAoZG9jLCB4LCB5KSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgcmV0dXJuIE9wdGlvbmFsLmZyb20oKF9iID0gKF9hID0gZG9jLmRvbSkuY2FyZXRSYW5nZUZyb21Qb2ludCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHgsIHkpKTtcbiAgICB9O1xuICAgIGNvbnN0IGF2YWlsYWJsZVNlYXJjaCA9ICgoKSA9PiB7XG4gICAgICBpZiAoZG9jdW1lbnQuY2FyZXRQb3NpdGlvbkZyb21Qb2ludCkge1xuICAgICAgICByZXR1cm4gY2FyZXRQb3NpdGlvbkZyb21Qb2ludDtcbiAgICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuY2FyZXRSYW5nZUZyb21Qb2ludCkge1xuICAgICAgICByZXR1cm4gY2FyZXRSYW5nZUZyb21Qb2ludDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lO1xuICAgICAgfVxuICAgIH0pKCk7XG4gICAgY29uc3QgZnJvbVBvaW50JDEgPSAod2luLCB4LCB5KSA9PiB7XG4gICAgICBjb25zdCBkb2MgPSBTdWdhckVsZW1lbnQuZnJvbURvbSh3aW4uZG9jdW1lbnQpO1xuICAgICAgcmV0dXJuIGF2YWlsYWJsZVNlYXJjaChkb2MsIHgsIHkpLm1hcChybmcgPT4gU2ltUmFuZ2UuY3JlYXRlKFN1Z2FyRWxlbWVudC5mcm9tRG9tKHJuZy5zdGFydENvbnRhaW5lciksIHJuZy5zdGFydE9mZnNldCwgU3VnYXJFbGVtZW50LmZyb21Eb20ocm5nLmVuZENvbnRhaW5lciksIHJuZy5lbmRPZmZzZXQpKTtcbiAgICB9O1xuXG4gICAgY29uc3QgYWR0JDIgPSBBZHQuZ2VuZXJhdGUoW1xuICAgICAgeyBiZWZvcmU6IFsnZWxlbWVudCddIH0sXG4gICAgICB7XG4gICAgICAgIG9uOiBbXG4gICAgICAgICAgJ2VsZW1lbnQnLFxuICAgICAgICAgICdvZmZzZXQnXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7IGFmdGVyOiBbJ2VsZW1lbnQnXSB9XG4gICAgXSk7XG4gICAgY29uc3QgY2F0YSA9IChzdWJqZWN0LCBvbkJlZm9yZSwgb25Pbiwgb25BZnRlcikgPT4gc3ViamVjdC5mb2xkKG9uQmVmb3JlLCBvbk9uLCBvbkFmdGVyKTtcbiAgICBjb25zdCBnZXRTdGFydCQyID0gc2l0dSA9PiBzaXR1LmZvbGQoaWRlbnRpdHksIGlkZW50aXR5LCBpZGVudGl0eSk7XG4gICAgY29uc3QgYmVmb3JlJDEgPSBhZHQkMi5iZWZvcmU7XG4gICAgY29uc3Qgb24gPSBhZHQkMi5vbjtcbiAgICBjb25zdCBhZnRlciQxID0gYWR0JDIuYWZ0ZXI7XG4gICAgY29uc3QgU2l0dSA9IHtcbiAgICAgIGJlZm9yZTogYmVmb3JlJDEsXG4gICAgICBvbixcbiAgICAgIGFmdGVyOiBhZnRlciQxLFxuICAgICAgY2F0YSxcbiAgICAgIGdldFN0YXJ0OiBnZXRTdGFydCQyXG4gICAgfTtcblxuICAgIGNvbnN0IGFkdCQxID0gQWR0LmdlbmVyYXRlKFtcbiAgICAgIHsgZG9tUmFuZ2U6IFsncm5nJ10gfSxcbiAgICAgIHtcbiAgICAgICAgcmVsYXRpdmU6IFtcbiAgICAgICAgICAnc3RhcnRTaXR1JyxcbiAgICAgICAgICAnZmluaXNoU2l0dSdcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgZXhhY3Q6IFtcbiAgICAgICAgICAnc3RhcnQnLFxuICAgICAgICAgICdzb2Zmc2V0JyxcbiAgICAgICAgICAnZmluaXNoJyxcbiAgICAgICAgICAnZm9mZnNldCdcbiAgICAgICAgXVxuICAgICAgfVxuICAgIF0pO1xuICAgIGNvbnN0IGV4YWN0RnJvbVJhbmdlID0gc2ltUmFuZ2UgPT4gYWR0JDEuZXhhY3Qoc2ltUmFuZ2Uuc3RhcnQsIHNpbVJhbmdlLnNvZmZzZXQsIHNpbVJhbmdlLmZpbmlzaCwgc2ltUmFuZ2UuZm9mZnNldCk7XG4gICAgY29uc3QgZ2V0U3RhcnQkMSA9IHNlbGVjdGlvbiA9PiBzZWxlY3Rpb24ubWF0Y2goe1xuICAgICAgZG9tUmFuZ2U6IHJuZyA9PiBTdWdhckVsZW1lbnQuZnJvbURvbShybmcuc3RhcnRDb250YWluZXIpLFxuICAgICAgcmVsYXRpdmU6IChzdGFydFNpdHUsIF9maW5pc2hTaXR1KSA9PiBTaXR1LmdldFN0YXJ0KHN0YXJ0U2l0dSksXG4gICAgICBleGFjdDogKHN0YXJ0LCBfc29mZnNldCwgX2ZpbmlzaCwgX2ZvZmZzZXQpID0+IHN0YXJ0XG4gICAgfSk7XG4gICAgY29uc3QgZG9tUmFuZ2UgPSBhZHQkMS5kb21SYW5nZTtcbiAgICBjb25zdCByZWxhdGl2ZSA9IGFkdCQxLnJlbGF0aXZlO1xuICAgIGNvbnN0IGV4YWN0ID0gYWR0JDEuZXhhY3Q7XG4gICAgY29uc3QgZ2V0V2luID0gc2VsZWN0aW9uID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gZ2V0U3RhcnQkMShzZWxlY3Rpb24pO1xuICAgICAgcmV0dXJuIGRlZmF1bHRWaWV3KHN0YXJ0KTtcbiAgICB9O1xuICAgIGNvbnN0IHJhbmdlID0gU2ltUmFuZ2UuY3JlYXRlO1xuICAgIGNvbnN0IFNpbVNlbGVjdGlvbiA9IHtcbiAgICAgIGRvbVJhbmdlLFxuICAgICAgcmVsYXRpdmUsXG4gICAgICBleGFjdCxcbiAgICAgIGV4YWN0RnJvbVJhbmdlLFxuICAgICAgZ2V0V2luLFxuICAgICAgcmFuZ2VcbiAgICB9O1xuXG4gICAgY29uc3QgYmVmb3JlU3BlY2lhbCA9IChlbGVtZW50LCBvZmZzZXQpID0+IHtcbiAgICAgIGNvbnN0IG5hbWUkMSA9IG5hbWUoZWxlbWVudCk7XG4gICAgICBpZiAoJ2lucHV0JyA9PT0gbmFtZSQxKSB7XG4gICAgICAgIHJldHVybiBTaXR1LmFmdGVyKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIGlmICghY29udGFpbnMkMihbXG4gICAgICAgICAgJ2JyJyxcbiAgICAgICAgICAnaW1nJ1xuICAgICAgICBdLCBuYW1lJDEpKSB7XG4gICAgICAgIHJldHVybiBTaXR1Lm9uKGVsZW1lbnQsIG9mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gb2Zmc2V0ID09PSAwID8gU2l0dS5iZWZvcmUoZWxlbWVudCkgOiBTaXR1LmFmdGVyKGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcHJlcHJvY2Vzc1JlbGF0aXZlID0gKHN0YXJ0U2l0dSwgZmluaXNoU2l0dSkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnQgPSBzdGFydFNpdHUuZm9sZChTaXR1LmJlZm9yZSwgYmVmb3JlU3BlY2lhbCwgU2l0dS5hZnRlcik7XG4gICAgICBjb25zdCBmaW5pc2ggPSBmaW5pc2hTaXR1LmZvbGQoU2l0dS5iZWZvcmUsIGJlZm9yZVNwZWNpYWwsIFNpdHUuYWZ0ZXIpO1xuICAgICAgcmV0dXJuIFNpbVNlbGVjdGlvbi5yZWxhdGl2ZShzdGFydCwgZmluaXNoKTtcbiAgICB9O1xuICAgIGNvbnN0IHByZXByb2Nlc3NFeGFjdCA9IChzdGFydCwgc29mZnNldCwgZmluaXNoLCBmb2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCBzdGFydFNpdHUgPSBiZWZvcmVTcGVjaWFsKHN0YXJ0LCBzb2Zmc2V0KTtcbiAgICAgIGNvbnN0IGZpbmlzaFNpdHUgPSBiZWZvcmVTcGVjaWFsKGZpbmlzaCwgZm9mZnNldCk7XG4gICAgICByZXR1cm4gU2ltU2VsZWN0aW9uLnJlbGF0aXZlKHN0YXJ0U2l0dSwgZmluaXNoU2l0dSk7XG4gICAgfTtcbiAgICBjb25zdCBwcmVwcm9jZXNzID0gc2VsZWN0aW9uID0+IHNlbGVjdGlvbi5tYXRjaCh7XG4gICAgICBkb21SYW5nZTogcm5nID0+IHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBTdWdhckVsZW1lbnQuZnJvbURvbShybmcuc3RhcnRDb250YWluZXIpO1xuICAgICAgICBjb25zdCBmaW5pc2ggPSBTdWdhckVsZW1lbnQuZnJvbURvbShybmcuZW5kQ29udGFpbmVyKTtcbiAgICAgICAgcmV0dXJuIHByZXByb2Nlc3NFeGFjdChzdGFydCwgcm5nLnN0YXJ0T2Zmc2V0LCBmaW5pc2gsIHJuZy5lbmRPZmZzZXQpO1xuICAgICAgfSxcbiAgICAgIHJlbGF0aXZlOiBwcmVwcm9jZXNzUmVsYXRpdmUsXG4gICAgICBleGFjdDogcHJlcHJvY2Vzc0V4YWN0XG4gICAgfSk7XG5cbiAgICBjb25zdCBmcm9tRWxlbWVudHMgPSAoZWxlbWVudHMsIHNjb3BlKSA9PiB7XG4gICAgICBjb25zdCBkb2MgPSBzY29wZSB8fCBkb2N1bWVudDtcbiAgICAgIGNvbnN0IGZyYWdtZW50ID0gZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgIGVhY2gkZShlbGVtZW50cywgZWxlbWVudCA9PiB7XG4gICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGVsZW1lbnQuZG9tKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFN1Z2FyRWxlbWVudC5mcm9tRG9tKGZyYWdtZW50KTtcbiAgICB9O1xuXG4gICAgY29uc3QgdG9OYXRpdmUgPSBzZWxlY3Rpb24gPT4ge1xuICAgICAgY29uc3Qgd2luID0gU2ltU2VsZWN0aW9uLmdldFdpbihzZWxlY3Rpb24pLmRvbTtcbiAgICAgIGNvbnN0IGdldERvbVJhbmdlID0gKHN0YXJ0LCBzb2Zmc2V0LCBmaW5pc2gsIGZvZmZzZXQpID0+IGV4YWN0VG9OYXRpdmUod2luLCBzdGFydCwgc29mZnNldCwgZmluaXNoLCBmb2Zmc2V0KTtcbiAgICAgIGNvbnN0IGZpbHRlcmVkID0gcHJlcHJvY2VzcyhzZWxlY3Rpb24pO1xuICAgICAgcmV0dXJuIGRpYWdub3NlKHdpbiwgZmlsdGVyZWQpLm1hdGNoKHtcbiAgICAgICAgbHRyOiBnZXREb21SYW5nZSxcbiAgICAgICAgcnRsOiBnZXREb21SYW5nZVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRBdFBvaW50ID0gKHdpbiwgeCwgeSkgPT4gZnJvbVBvaW50JDEod2luLCB4LCB5KTtcblxuICAgIGNvbnN0IGZyb21Qb2ludCA9IChjbGllbnRYLCBjbGllbnRZLCBkb2MpID0+IHtcbiAgICAgIGNvbnN0IHdpbiA9IGRlZmF1bHRWaWV3KFN1Z2FyRWxlbWVudC5mcm9tRG9tKGRvYykpO1xuICAgICAgcmV0dXJuIGdldEF0UG9pbnQod2luLmRvbSwgY2xpZW50WCwgY2xpZW50WSkubWFwKHNpbVJhbmdlID0+IHtcbiAgICAgICAgY29uc3Qgcm5nID0gZG9jLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIHJuZy5zZXRTdGFydChzaW1SYW5nZS5zdGFydC5kb20sIHNpbVJhbmdlLnNvZmZzZXQpO1xuICAgICAgICBybmcuc2V0RW5kKHNpbVJhbmdlLmZpbmlzaC5kb20sIHNpbVJhbmdlLmZvZmZzZXQpO1xuICAgICAgICByZXR1cm4gcm5nO1xuICAgICAgfSkuZ2V0T3JVbmRlZmluZWQoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgaXNFcSQ0ID0gKHJuZzEsIHJuZzIpID0+IHtcbiAgICAgIHJldHVybiBpc05vbk51bGxhYmxlKHJuZzEpICYmIGlzTm9uTnVsbGFibGUocm5nMikgJiYgKHJuZzEuc3RhcnRDb250YWluZXIgPT09IHJuZzIuc3RhcnRDb250YWluZXIgJiYgcm5nMS5zdGFydE9mZnNldCA9PT0gcm5nMi5zdGFydE9mZnNldCkgJiYgKHJuZzEuZW5kQ29udGFpbmVyID09PSBybmcyLmVuZENvbnRhaW5lciAmJiBybmcxLmVuZE9mZnNldCA9PT0gcm5nMi5lbmRPZmZzZXQpO1xuICAgIH07XG5cbiAgICBjb25zdCBmaW5kUGFyZW50ID0gKG5vZGUsIHJvb3ROb2RlLCBwcmVkaWNhdGUpID0+IHtcbiAgICAgIGxldCBjdXJyZW50Tm9kZSA9IG5vZGU7XG4gICAgICB3aGlsZSAoY3VycmVudE5vZGUgJiYgY3VycmVudE5vZGUgIT09IHJvb3ROb2RlKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUoY3VycmVudE5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgY29uc3QgaGFzUGFyZW50JDEgPSAobm9kZSwgcm9vdE5vZGUsIHByZWRpY2F0ZSkgPT4gZmluZFBhcmVudChub2RlLCByb290Tm9kZSwgcHJlZGljYXRlKSAhPT0gbnVsbDtcbiAgICBjb25zdCBoYXNQYXJlbnRXaXRoTmFtZSA9IChub2RlLCByb290Tm9kZSwgbmFtZSkgPT4gaGFzUGFyZW50JDEobm9kZSwgcm9vdE5vZGUsIG5vZGUgPT4gbm9kZS5ub2RlTmFtZSA9PT0gbmFtZSk7XG4gICAgY29uc3QgaXNDZUZhbHNlQ2FyZXRDb250YWluZXIgPSAobm9kZSwgcm9vdE5vZGUpID0+IGlzQ2FyZXRDb250YWluZXIkMihub2RlKSAmJiAhaGFzUGFyZW50JDEobm9kZSwgcm9vdE5vZGUsIGlzQ2FyZXROb2RlKTtcbiAgICBjb25zdCBoYXNCckJlZm9yZUFmdGVyID0gKGRvbSwgbm9kZSwgbGVmdCkgPT4ge1xuICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICAgIGNvbnN0IHdhbGtlciA9IG5ldyBEb21UcmVlV2Fsa2VyKG5vZGUsIGRvbS5nZXRQYXJlbnQocGFyZW50Tm9kZSwgZG9tLmlzQmxvY2spIHx8IGRvbS5nZXRSb290KCkpO1xuICAgICAgICBsZXQgY3VycmVudE5vZGU7XG4gICAgICAgIHdoaWxlIChjdXJyZW50Tm9kZSA9IHdhbGtlcltsZWZ0ID8gJ3ByZXYnIDogJ25leHQnXSgpKSB7XG4gICAgICAgICAgaWYgKGlzQnIkNihjdXJyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgY29uc3QgaXNQcmV2Tm9kZSA9IChub2RlLCBuYW1lKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gKChfYSA9IG5vZGUucHJldmlvdXNTaWJsaW5nKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eubm9kZU5hbWUpID09PSBuYW1lO1xuICAgIH07XG4gICAgY29uc3QgaGFzQ29udGVudEVkaXRhYmxlRmFsc2VQYXJlbnQgPSAocm9vdCwgbm9kZSkgPT4ge1xuICAgICAgbGV0IGN1cnJlbnROb2RlID0gbm9kZTtcbiAgICAgIHdoaWxlIChjdXJyZW50Tm9kZSAmJiBjdXJyZW50Tm9kZSAhPT0gcm9vdCkge1xuICAgICAgICBpZiAoaXNDb250ZW50RWRpdGFibGVGYWxzZSRiKGN1cnJlbnROb2RlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGNvbnN0IGZpbmRUZXh0Tm9kZVJlbGF0aXZlID0gKGRvbSwgaXNBZnRlck5vZGUsIGNvbGxhcHNlZCwgbGVmdCwgc3RhcnROb2RlKSA9PiB7XG4gICAgICBjb25zdCBib2R5ID0gZG9tLmdldFJvb3QoKTtcbiAgICAgIGNvbnN0IG5vbkVtcHR5RWxlbWVudHNNYXAgPSBkb20uc2NoZW1hLmdldE5vbkVtcHR5RWxlbWVudHMoKTtcbiAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBzdGFydE5vZGUucGFyZW50Tm9kZTtcbiAgICAgIGxldCBsYXN0SW5saW5lRWxlbWVudDtcbiAgICAgIGxldCBub2RlO1xuICAgICAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJlbnRCbG9ja0NvbnRhaW5lciA9IGRvbS5nZXRQYXJlbnQocGFyZW50Tm9kZSwgZG9tLmlzQmxvY2spIHx8IGJvZHk7XG4gICAgICBpZiAobGVmdCAmJiBpc0JyJDYoc3RhcnROb2RlKSAmJiBpc0FmdGVyTm9kZSAmJiBkb20uaXNFbXB0eShwYXJlbnRCbG9ja0NvbnRhaW5lcikpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoQ2FyZXRQb3NpdGlvbihwYXJlbnROb2RlLCBkb20ubm9kZUluZGV4KHN0YXJ0Tm9kZSkpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdhbGtlciA9IG5ldyBEb21UcmVlV2Fsa2VyKHN0YXJ0Tm9kZSwgcGFyZW50QmxvY2tDb250YWluZXIpO1xuICAgICAgd2hpbGUgKG5vZGUgPSB3YWxrZXJbbGVmdCA/ICdwcmV2JyA6ICduZXh0J10oKSkge1xuICAgICAgICBpZiAoZG9tLmdldENvbnRlbnRFZGl0YWJsZVBhcmVudChub2RlKSA9PT0gJ2ZhbHNlJyB8fCBpc0NlRmFsc2VDYXJldENvbnRhaW5lcihub2RlLCBib2R5KSkge1xuICAgICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVGV4dCRhKG5vZGUpICYmIG5vZGUuZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgaWYgKCFoYXNQYXJlbnRXaXRoTmFtZShub2RlLCBib2R5LCAnQScpKSB7XG4gICAgICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShDYXJldFBvc2l0aW9uKG5vZGUsIGxlZnQgPyBub2RlLmRhdGEubGVuZ3RoIDogMCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb20uaXNCbG9jayhub2RlKSB8fCBub25FbXB0eUVsZW1lbnRzTWFwW25vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKV0pIHtcbiAgICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RJbmxpbmVFbGVtZW50ID0gbm9kZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0NvbW1lbnQobGFzdElubGluZUVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9XG4gICAgICBpZiAoY29sbGFwc2VkICYmIGxhc3RJbmxpbmVFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKENhcmV0UG9zaXRpb24obGFzdElubGluZUVsZW1lbnQsIDApKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgfTtcbiAgICBjb25zdCBub3JtYWxpemVFbmRQb2ludCA9IChkb20sIGNvbGxhcHNlZCwgc3RhcnQsIHJuZykgPT4ge1xuICAgICAgY29uc3QgYm9keSA9IGRvbS5nZXRSb290KCk7XG4gICAgICBsZXQgbm9kZTtcbiAgICAgIGxldCBub3JtYWxpemVkID0gZmFsc2U7XG4gICAgICBsZXQgY29udGFpbmVyID0gc3RhcnQgPyBybmcuc3RhcnRDb250YWluZXIgOiBybmcuZW5kQ29udGFpbmVyO1xuICAgICAgbGV0IG9mZnNldCA9IHN0YXJ0ID8gcm5nLnN0YXJ0T2Zmc2V0IDogcm5nLmVuZE9mZnNldDtcbiAgICAgIGNvbnN0IGlzQWZ0ZXJOb2RlID0gaXNFbGVtZW50JDYoY29udGFpbmVyKSAmJiBvZmZzZXQgPT09IGNvbnRhaW5lci5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgIGNvbnN0IG5vbkVtcHR5RWxlbWVudHNNYXAgPSBkb20uc2NoZW1hLmdldE5vbkVtcHR5RWxlbWVudHMoKTtcbiAgICAgIGxldCBkaXJlY3Rpb25MZWZ0ID0gc3RhcnQ7XG4gICAgICBpZiAoaXNDYXJldENvbnRhaW5lciQyKGNvbnRhaW5lcikpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0VsZW1lbnQkNihjb250YWluZXIpICYmIG9mZnNldCA+IGNvbnRhaW5lci5jaGlsZE5vZGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgZGlyZWN0aW9uTGVmdCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGlzRG9jdW1lbnQkMShjb250YWluZXIpKSB7XG4gICAgICAgIGNvbnRhaW5lciA9IGJvZHk7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoY29udGFpbmVyID09PSBib2R5KSB7XG4gICAgICAgIGlmIChkaXJlY3Rpb25MZWZ0KSB7XG4gICAgICAgICAgbm9kZSA9IGNvbnRhaW5lci5jaGlsZE5vZGVzW29mZnNldCA+IDAgPyBvZmZzZXQgLSAxIDogMF07XG4gICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChpc0NhcmV0Q29udGFpbmVyJDIobm9kZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub25FbXB0eUVsZW1lbnRzTWFwW25vZGUubm9kZU5hbWVdIHx8IGlzVGFibGUkMihub2RlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgIG9mZnNldCA9IE1hdGgubWluKCFkaXJlY3Rpb25MZWZ0ICYmIG9mZnNldCA+IDAgPyBvZmZzZXQgLSAxIDogb2Zmc2V0LCBjb250YWluZXIuY2hpbGROb2Rlcy5sZW5ndGggLSAxKTtcbiAgICAgICAgICBjb250YWluZXIgPSBjb250YWluZXIuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICAgIG9mZnNldCA9IGlzVGV4dCRhKGNvbnRhaW5lcikgJiYgaXNBZnRlck5vZGUgPyBjb250YWluZXIuZGF0YS5sZW5ndGggOiAwO1xuICAgICAgICAgIGlmICghY29sbGFwc2VkICYmIGNvbnRhaW5lciA9PT0gYm9keS5sYXN0Q2hpbGQgJiYgaXNUYWJsZSQyKGNvbnRhaW5lcikpIHtcbiAgICAgICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYXNDb250ZW50RWRpdGFibGVGYWxzZVBhcmVudChib2R5LCBjb250YWluZXIpIHx8IGlzQ2FyZXRDb250YWluZXIkMihjb250YWluZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSAmJiAhaXNUYWJsZSQyKGNvbnRhaW5lcikpIHtcbiAgICAgICAgICAgIG5vZGUgPSBjb250YWluZXI7XG4gICAgICAgICAgICBjb25zdCB3YWxrZXIgPSBuZXcgRG9tVHJlZVdhbGtlcihjb250YWluZXIsIGJvZHkpO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBpZiAoaXNDb250ZW50RWRpdGFibGVGYWxzZSRiKG5vZGUpIHx8IGlzQ2FyZXRDb250YWluZXIkMihub2RlKSkge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXNUZXh0JGEobm9kZSkgJiYgbm9kZS5kYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBkaXJlY3Rpb25MZWZ0ID8gMCA6IG5vZGUuZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gbm9kZTtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobm9uRW1wdHlFbGVtZW50c01hcFtub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldICYmICFpc1RhYmxlQ2VsbE9yQ2FwdGlvbihub2RlKSkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IGRvbS5ub2RlSW5kZXgobm9kZSk7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIGlmICghZGlyZWN0aW9uTGVmdCkge1xuICAgICAgICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChub2RlID0gZGlyZWN0aW9uTGVmdCA/IHdhbGtlci5uZXh0KCkgOiB3YWxrZXIucHJldigpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb2xsYXBzZWQpIHtcbiAgICAgICAgaWYgKGlzVGV4dCRhKGNvbnRhaW5lcikgJiYgb2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgZmluZFRleHROb2RlUmVsYXRpdmUoZG9tLCBpc0FmdGVyTm9kZSwgY29sbGFwc2VkLCB0cnVlLCBjb250YWluZXIpLmVhY2gocG9zID0+IHtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHBvcy5jb250YWluZXIoKTtcbiAgICAgICAgICAgIG9mZnNldCA9IHBvcy5vZmZzZXQoKTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0VsZW1lbnQkNihjb250YWluZXIpKSB7XG4gICAgICAgICAgbm9kZSA9IGNvbnRhaW5lci5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICBub2RlID0gY29udGFpbmVyLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChub2RlICYmIGlzQnIkNihub2RlKSAmJiAhaXNQcmV2Tm9kZShub2RlLCAnQScpICYmICFoYXNCckJlZm9yZUFmdGVyKGRvbSwgbm9kZSwgZmFsc2UpICYmICFoYXNCckJlZm9yZUFmdGVyKGRvbSwgbm9kZSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIGZpbmRUZXh0Tm9kZVJlbGF0aXZlKGRvbSwgaXNBZnRlck5vZGUsIGNvbGxhcHNlZCwgdHJ1ZSwgbm9kZSkuZWFjaChwb3MgPT4ge1xuICAgICAgICAgICAgICBjb250YWluZXIgPSBwb3MuY29udGFpbmVyKCk7XG4gICAgICAgICAgICAgIG9mZnNldCA9IHBvcy5vZmZzZXQoKTtcbiAgICAgICAgICAgICAgbm9ybWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkaXJlY3Rpb25MZWZ0ICYmICFjb2xsYXBzZWQgJiYgaXNUZXh0JGEoY29udGFpbmVyKSAmJiBvZmZzZXQgPT09IGNvbnRhaW5lci5kYXRhLmxlbmd0aCkge1xuICAgICAgICBmaW5kVGV4dE5vZGVSZWxhdGl2ZShkb20sIGlzQWZ0ZXJOb2RlLCBjb2xsYXBzZWQsIGZhbHNlLCBjb250YWluZXIpLmVhY2gocG9zID0+IHtcbiAgICAgICAgICBjb250YWluZXIgPSBwb3MuY29udGFpbmVyKCk7XG4gICAgICAgICAgb2Zmc2V0ID0gcG9zLm9mZnNldCgpO1xuICAgICAgICAgIG5vcm1hbGl6ZWQgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub3JtYWxpemVkICYmIGNvbnRhaW5lciA/IE9wdGlvbmFsLnNvbWUoQ2FyZXRQb3NpdGlvbihjb250YWluZXIsIG9mZnNldCkpIDogT3B0aW9uYWwubm9uZSgpO1xuICAgIH07XG4gICAgY29uc3Qgbm9ybWFsaXplJDIgPSAoZG9tLCBybmcpID0+IHtcbiAgICAgIGNvbnN0IGNvbGxhcHNlZCA9IHJuZy5jb2xsYXBzZWQsIG5vcm1SbmcgPSBybmcuY2xvbmVSYW5nZSgpO1xuICAgICAgY29uc3Qgc3RhcnRQb3MgPSBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KHJuZyk7XG4gICAgICBub3JtYWxpemVFbmRQb2ludChkb20sIGNvbGxhcHNlZCwgdHJ1ZSwgbm9ybVJuZykuZWFjaChwb3MgPT4ge1xuICAgICAgICBpZiAoIWNvbGxhcHNlZCB8fCAhQ2FyZXRQb3NpdGlvbi5pc0Fib3ZlKHN0YXJ0UG9zLCBwb3MpKSB7XG4gICAgICAgICAgbm9ybVJuZy5zZXRTdGFydChwb3MuY29udGFpbmVyKCksIHBvcy5vZmZzZXQoKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFjb2xsYXBzZWQpIHtcbiAgICAgICAgbm9ybWFsaXplRW5kUG9pbnQoZG9tLCBjb2xsYXBzZWQsIGZhbHNlLCBub3JtUm5nKS5lYWNoKHBvcyA9PiB7XG4gICAgICAgICAgbm9ybVJuZy5zZXRFbmQocG9zLmNvbnRhaW5lcigpLCBwb3Mub2Zmc2V0KCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2xsYXBzZWQpIHtcbiAgICAgICAgbm9ybVJuZy5jb2xsYXBzZSh0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0VxJDQocm5nLCBub3JtUm5nKSA/IE9wdGlvbmFsLm5vbmUoKSA6IE9wdGlvbmFsLnNvbWUobm9ybVJuZyk7XG4gICAgfTtcblxuICAgIGNvbnN0IHNwbGl0VGV4dCA9IChub2RlLCBvZmZzZXQpID0+IHtcbiAgICAgIHJldHVybiBub2RlLnNwbGl0VGV4dChvZmZzZXQpO1xuICAgIH07XG4gICAgY29uc3Qgc3BsaXQgPSBybmcgPT4ge1xuICAgICAgbGV0IHN0YXJ0Q29udGFpbmVyID0gcm5nLnN0YXJ0Q29udGFpbmVyLCBzdGFydE9mZnNldCA9IHJuZy5zdGFydE9mZnNldCwgZW5kQ29udGFpbmVyID0gcm5nLmVuZENvbnRhaW5lciwgZW5kT2Zmc2V0ID0gcm5nLmVuZE9mZnNldDtcbiAgICAgIGlmIChzdGFydENvbnRhaW5lciA9PT0gZW5kQ29udGFpbmVyICYmIGlzVGV4dCRhKHN0YXJ0Q29udGFpbmVyKSkge1xuICAgICAgICBpZiAoc3RhcnRPZmZzZXQgPiAwICYmIHN0YXJ0T2Zmc2V0IDwgc3RhcnRDb250YWluZXIuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICBlbmRDb250YWluZXIgPSBzcGxpdFRleHQoc3RhcnRDb250YWluZXIsIHN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICBzdGFydENvbnRhaW5lciA9IGVuZENvbnRhaW5lci5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgaWYgKGVuZE9mZnNldCA+IHN0YXJ0T2Zmc2V0KSB7XG4gICAgICAgICAgICBlbmRPZmZzZXQgPSBlbmRPZmZzZXQgLSBzdGFydE9mZnNldDtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvbnRhaW5lciA9IHNwbGl0VGV4dChlbmRDb250YWluZXIsIGVuZE9mZnNldCkucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgc3RhcnRDb250YWluZXIgPSBlbmRDb250YWluZXIgPSBuZXdDb250YWluZXI7XG4gICAgICAgICAgICBlbmRPZmZzZXQgPSBuZXdDb250YWluZXIuZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICBzdGFydE9mZnNldCA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVuZE9mZnNldCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNUZXh0JGEoc3RhcnRDb250YWluZXIpICYmIHN0YXJ0T2Zmc2V0ID4gMCAmJiBzdGFydE9mZnNldCA8IHN0YXJ0Q29udGFpbmVyLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgc3RhcnRDb250YWluZXIgPSBzcGxpdFRleHQoc3RhcnRDb250YWluZXIsIHN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICBzdGFydE9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVGV4dCRhKGVuZENvbnRhaW5lcikgJiYgZW5kT2Zmc2V0ID4gMCAmJiBlbmRPZmZzZXQgPCBlbmRDb250YWluZXIuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBuZXdDb250YWluZXIgPSBzcGxpdFRleHQoZW5kQ29udGFpbmVyLCBlbmRPZmZzZXQpLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICBlbmRDb250YWluZXIgPSBuZXdDb250YWluZXI7XG4gICAgICAgICAgZW5kT2Zmc2V0ID0gbmV3Q29udGFpbmVyLmRhdGEubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGFydENvbnRhaW5lcixcbiAgICAgICAgc3RhcnRPZmZzZXQsXG4gICAgICAgIGVuZENvbnRhaW5lcixcbiAgICAgICAgZW5kT2Zmc2V0XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBSYW5nZVV0aWxzID0gZG9tID0+IHtcbiAgICAgIGNvbnN0IHdhbGsgPSAocm5nLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICByZXR1cm4gd2FsayQzKGRvbSwgcm5nLCBjYWxsYmFjayk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgc3BsaXQkMSA9IHNwbGl0O1xuICAgICAgY29uc3Qgbm9ybWFsaXplID0gcm5nID0+IHtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZSQyKGRvbSwgcm5nKS5mb2xkKG5ldmVyLCBub3JtYWxpemVkUm5nID0+IHtcbiAgICAgICAgICBybmcuc2V0U3RhcnQobm9ybWFsaXplZFJuZy5zdGFydENvbnRhaW5lciwgbm9ybWFsaXplZFJuZy5zdGFydE9mZnNldCk7XG4gICAgICAgICAgcm5nLnNldEVuZChub3JtYWxpemVkUm5nLmVuZENvbnRhaW5lciwgbm9ybWFsaXplZFJuZy5lbmRPZmZzZXQpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBleHBhbmQgPSAocm5nLCBvcHRpb25zID0geyB0eXBlOiAnd29yZCcgfSkgPT4ge1xuICAgICAgICBpZiAob3B0aW9ucy50eXBlID09PSAnd29yZCcpIHtcbiAgICAgICAgICBjb25zdCByYW5nZUxpa2UgPSBleHBhbmRSbmcoZG9tLCBybmcsIFt7IGlubGluZTogJ3NwYW4nIH1dKTtcbiAgICAgICAgICBjb25zdCBuZXdSYW5nZSA9IGRvbS5jcmVhdGVSbmcoKTtcbiAgICAgICAgICBuZXdSYW5nZS5zZXRTdGFydChyYW5nZUxpa2Uuc3RhcnRDb250YWluZXIsIHJhbmdlTGlrZS5zdGFydE9mZnNldCk7XG4gICAgICAgICAgbmV3UmFuZ2Uuc2V0RW5kKHJhbmdlTGlrZS5lbmRDb250YWluZXIsIHJhbmdlTGlrZS5lbmRPZmZzZXQpO1xuICAgICAgICAgIHJldHVybiBuZXdSYW5nZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm5nO1xuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdhbGssXG4gICAgICAgIHNwbGl0OiBzcGxpdCQxLFxuICAgICAgICBleHBhbmQsXG4gICAgICAgIG5vcm1hbGl6ZVxuICAgICAgfTtcbiAgICB9O1xuICAgIFJhbmdlVXRpbHMuY29tcGFyZVJhbmdlcyA9IGlzRXEkNDtcbiAgICBSYW5nZVV0aWxzLmdldENhcmV0UmFuZ2VGcm9tUG9pbnQgPSBmcm9tUG9pbnQ7XG4gICAgUmFuZ2VVdGlscy5nZXRTZWxlY3RlZE5vZGUgPSBnZXRTZWxlY3RlZE5vZGU7XG4gICAgUmFuZ2VVdGlscy5nZXROb2RlID0gZ2V0Tm9kZSQxO1xuXG4gICAgY29uc3QgRGltZW5zaW9uID0gKG5hbWUsIGdldE9mZnNldCkgPT4ge1xuICAgICAgY29uc3Qgc2V0ID0gKGVsZW1lbnQsIGgpID0+IHtcbiAgICAgICAgaWYgKCFpc051bWJlcihoKSAmJiAhaC5tYXRjaCgvXlswLTldKyQvKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihuYW1lICsgJy5zZXQgYWNjZXB0cyBvbmx5IHBvc2l0aXZlIGludGVnZXIgdmFsdWVzLiBWYWx1ZSB3YXMgJyArIGgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRvbSA9IGVsZW1lbnQuZG9tO1xuICAgICAgICBpZiAoaXNTdXBwb3J0ZWQoZG9tKSkge1xuICAgICAgICAgIGRvbS5zdHlsZVtuYW1lXSA9IGggKyAncHgnO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0ID0gZWxlbWVudCA9PiB7XG4gICAgICAgIGNvbnN0IHIgPSBnZXRPZmZzZXQoZWxlbWVudCk7XG4gICAgICAgIGlmIChyIDw9IDAgfHwgciA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IGNzcyA9IGdldCQ3KGVsZW1lbnQsIG5hbWUpO1xuICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGNzcykgfHwgMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH07XG4gICAgICBjb25zdCBnZXRPdXRlciA9IGdldDtcbiAgICAgIGNvbnN0IGFnZ3JlZ2F0ZSA9IChlbGVtZW50LCBwcm9wZXJ0aWVzKSA9PiBmb2xkbChwcm9wZXJ0aWVzLCAoYWNjLCBwcm9wZXJ0eSkgPT4ge1xuICAgICAgICBjb25zdCB2YWwgPSBnZXQkNyhlbGVtZW50LCBwcm9wZXJ0eSk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdmFsID09PSB1bmRlZmluZWQgPyAwIDogcGFyc2VJbnQodmFsLCAxMCk7XG4gICAgICAgIHJldHVybiBpc05hTih2YWx1ZSkgPyBhY2MgOiBhY2MgKyB2YWx1ZTtcbiAgICAgIH0sIDApO1xuICAgICAgY29uc3QgbWF4ID0gKGVsZW1lbnQsIHZhbHVlLCBwcm9wZXJ0aWVzKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1bXVsYXRpdmVJbmNsdXNpb25zID0gYWdncmVnYXRlKGVsZW1lbnQsIHByb3BlcnRpZXMpO1xuICAgICAgICBjb25zdCBhYnNvbHV0ZU1heCA9IHZhbHVlID4gY3VtdWxhdGl2ZUluY2x1c2lvbnMgPyB2YWx1ZSAtIGN1bXVsYXRpdmVJbmNsdXNpb25zIDogMDtcbiAgICAgICAgcmV0dXJuIGFic29sdXRlTWF4O1xuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNldCxcbiAgICAgICAgZ2V0LFxuICAgICAgICBnZXRPdXRlcixcbiAgICAgICAgYWdncmVnYXRlLFxuICAgICAgICBtYXhcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IGFwaSA9IERpbWVuc2lvbignaGVpZ2h0JywgZWxlbWVudCA9PiB7XG4gICAgICBjb25zdCBkb20gPSBlbGVtZW50LmRvbTtcbiAgICAgIHJldHVybiBpbkJvZHkoZWxlbWVudCkgPyBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0IDogZG9tLm9mZnNldEhlaWdodDtcbiAgICB9KTtcbiAgICBjb25zdCBnZXQkMiA9IGVsZW1lbnQgPT4gYXBpLmdldChlbGVtZW50KTtcblxuICAgIGNvbnN0IGdldERvY3VtZW50ID0gKCkgPT4gU3VnYXJFbGVtZW50LmZyb21Eb20oZG9jdW1lbnQpO1xuXG4gICAgY29uc3Qgd2Fsa1VwID0gKG5hdmlnYXRpb24sIGRvYykgPT4ge1xuICAgICAgY29uc3QgZnJhbWUgPSBuYXZpZ2F0aW9uLnZpZXcoZG9jKTtcbiAgICAgIHJldHVybiBmcmFtZS5mb2xkKGNvbnN0YW50KFtdKSwgZiA9PiB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IG5hdmlnYXRpb24ub3duZXIoZik7XG4gICAgICAgIGNvbnN0IHJlc3QgPSB3YWxrVXAobmF2aWdhdGlvbiwgcGFyZW50KTtcbiAgICAgICAgcmV0dXJuIFtmXS5jb25jYXQocmVzdCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHBhdGhUbyA9IChlbGVtZW50LCBuYXZpZ2F0aW9uKSA9PiB7XG4gICAgICBjb25zdCBkID0gbmF2aWdhdGlvbi5vd25lcihlbGVtZW50KTtcbiAgICAgIHJldHVybiB3YWxrVXAobmF2aWdhdGlvbiwgZCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHZpZXcgPSBkb2MgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgZWxlbWVudCA9IGRvYy5kb20gPT09IGRvY3VtZW50ID8gT3B0aW9uYWwubm9uZSgpIDogT3B0aW9uYWwuZnJvbSgoX2EgPSBkb2MuZG9tLmRlZmF1bHRWaWV3KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZnJhbWVFbGVtZW50KTtcbiAgICAgIHJldHVybiBlbGVtZW50Lm1hcChTdWdhckVsZW1lbnQuZnJvbURvbSk7XG4gICAgfTtcbiAgICBjb25zdCBvd25lciA9IGVsZW1lbnQgPT4gZG9jdW1lbnRPck93bmVyKGVsZW1lbnQpO1xuXG4gICAgdmFyIE5hdmlnYXRpb24gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAgICAgdmlldzogdmlldyxcbiAgICAgICAgb3duZXI6IG93bmVyXG4gICAgfSk7XG5cbiAgICBjb25zdCBmaW5kID0gZWxlbWVudCA9PiB7XG4gICAgICBjb25zdCBkb2MgPSBnZXREb2N1bWVudCgpO1xuICAgICAgY29uc3Qgc2Nyb2xsID0gZ2V0JDUoZG9jKTtcbiAgICAgIGNvbnN0IGZyYW1lcyA9IHBhdGhUbyhlbGVtZW50LCBOYXZpZ2F0aW9uKTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHZpZXdwb3J0KGVsZW1lbnQpO1xuICAgICAgY29uc3QgciA9IGZvbGRyKGZyYW1lcywgKGIsIGEpID0+IHtcbiAgICAgICAgY29uc3QgbG9jID0gdmlld3BvcnQoYSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGVmdDogYi5sZWZ0ICsgbG9jLmxlZnQsXG4gICAgICAgICAgdG9wOiBiLnRvcCArIGxvYy50b3BcbiAgICAgICAgfTtcbiAgICAgIH0sIHtcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgdG9wOiAwXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBTdWdhclBvc2l0aW9uKHIubGVmdCArIG9mZnNldC5sZWZ0ICsgc2Nyb2xsLmxlZnQsIHIudG9wICsgb2Zmc2V0LnRvcCArIHNjcm9sbC50b3ApO1xuICAgIH07XG5cbiAgICBjb25zdCBleGNsdWRlRnJvbURlc2NlbmQgPSBlbGVtZW50ID0+IG5hbWUoZWxlbWVudCkgPT09ICd0ZXh0YXJlYSc7XG4gICAgY29uc3QgZmlyZVNjcm9sbEludG9WaWV3RXZlbnQgPSAoZWRpdG9yLCBkYXRhKSA9PiB7XG4gICAgICBjb25zdCBzY3JvbGxFdmVudCA9IGVkaXRvci5kaXNwYXRjaCgnU2Nyb2xsSW50b1ZpZXcnLCBkYXRhKTtcbiAgICAgIHJldHVybiBzY3JvbGxFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKTtcbiAgICB9O1xuICAgIGNvbnN0IGZpcmVBZnRlclNjcm9sbEludG9WaWV3RXZlbnQgPSAoZWRpdG9yLCBkYXRhKSA9PiB7XG4gICAgICBlZGl0b3IuZGlzcGF0Y2goJ0FmdGVyU2Nyb2xsSW50b1ZpZXcnLCBkYXRhKTtcbiAgICB9O1xuICAgIGNvbnN0IGRlc2NlbmQgPSAoZWxlbWVudCwgb2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGNoaWxkcmVuJDEoZWxlbWVudCk7XG4gICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8IGV4Y2x1ZGVGcm9tRGVzY2VuZChlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgb2Zmc2V0XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKG9mZnNldCA8IGNoaWxkcmVuLmxlbmd0aCAmJiAhZXhjbHVkZUZyb21EZXNjZW5kKGNoaWxkcmVuW29mZnNldF0pKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZWxlbWVudDogY2hpbGRyZW5bb2Zmc2V0XSxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGxhc3QgPSBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGV4Y2x1ZGVGcm9tRGVzY2VuZChsYXN0KSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgb2Zmc2V0XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobmFtZShsYXN0KSA9PT0gJ2ltZycpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGVsZW1lbnQ6IGxhc3QsXG4gICAgICAgICAgICAgIG9mZnNldDogMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzVGV4dCRiKGxhc3QpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBlbGVtZW50OiBsYXN0LFxuICAgICAgICAgICAgICBvZmZzZXQ6IGdldCQzKGxhc3QpLmxlbmd0aFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZWxlbWVudDogbGFzdCxcbiAgICAgICAgICAgICAgb2Zmc2V0OiBjaGlsZHJlbiQxKGxhc3QpLmxlbmd0aFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG1hcmtlckluZm8gPSAoZWxlbWVudCwgY2xlYW51cEZ1bikgPT4ge1xuICAgICAgY29uc3QgcG9zID0gYWJzb2x1dGUoZWxlbWVudCk7XG4gICAgICBjb25zdCBoZWlnaHQgPSBnZXQkMihlbGVtZW50KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVsZW1lbnQsXG4gICAgICAgIGJvdHRvbTogcG9zLnRvcCArIGhlaWdodCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICBwb3MsXG4gICAgICAgIGNsZWFudXA6IGNsZWFudXBGdW5cbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGVNYXJrZXIkMSA9IChlbGVtZW50LCBvZmZzZXQpID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0UG9pbnQgPSBkZXNjZW5kKGVsZW1lbnQsIG9mZnNldCk7XG4gICAgICBjb25zdCBzcGFuID0gU3VnYXJFbGVtZW50LmZyb21IdG1sKCc8c3BhbiBkYXRhLW1jZS1ib2d1cz1cImFsbFwiIHN0eWxlPVwiZGlzcGxheTogaW5saW5lLWJsb2NrO1wiPicgKyBaV1NQJDEgKyAnPC9zcGFuPicpO1xuICAgICAgYmVmb3JlJDMoc3RhcnRQb2ludC5lbGVtZW50LCBzcGFuKTtcbiAgICAgIHJldHVybiBtYXJrZXJJbmZvKHNwYW4sICgpID0+IHJlbW92ZSQ2KHNwYW4pKTtcbiAgICB9O1xuICAgIGNvbnN0IGVsZW1lbnRNYXJrZXIgPSBlbGVtZW50ID0+IG1hcmtlckluZm8oU3VnYXJFbGVtZW50LmZyb21Eb20oZWxlbWVudCksIG5vb3ApO1xuICAgIGNvbnN0IHdpdGhNYXJrZXIgPSAoZWRpdG9yLCBmLCBybmcsIGFsaWduVG9Ub3ApID0+IHtcbiAgICAgIHByZXNlcnZlV2l0aChlZGl0b3IsIChfcywgX2UpID0+IGFwcGx5V2l0aE1hcmtlcihlZGl0b3IsIGYsIHJuZywgYWxpZ25Ub1RvcCksIHJuZyk7XG4gICAgfTtcbiAgICBjb25zdCB3aXRoU2Nyb2xsRXZlbnRzID0gKGVkaXRvciwgZG9jLCBmLCBtYXJrZXIsIGFsaWduVG9Ub3ApID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgIGVsbTogbWFya2VyLmVsZW1lbnQuZG9tLFxuICAgICAgICBhbGlnblRvVG9wXG4gICAgICB9O1xuICAgICAgaWYgKGZpcmVTY3JvbGxJbnRvVmlld0V2ZW50KGVkaXRvciwgZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2Nyb2xsVG9wID0gZ2V0JDUoZG9jKS50b3A7XG4gICAgICBmKGRvYywgc2Nyb2xsVG9wLCBtYXJrZXIsIGFsaWduVG9Ub3ApO1xuICAgICAgZmlyZUFmdGVyU2Nyb2xsSW50b1ZpZXdFdmVudChlZGl0b3IsIGRhdGEpO1xuICAgIH07XG4gICAgY29uc3QgYXBwbHlXaXRoTWFya2VyID0gKGVkaXRvciwgZiwgcm5nLCBhbGlnblRvVG9wKSA9PiB7XG4gICAgICBjb25zdCBib2R5ID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZWRpdG9yLmdldEJvZHkoKSk7XG4gICAgICBjb25zdCBkb2MgPSBTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3IuZ2V0RG9jKCkpO1xuICAgICAgcmVmbG93KGJvZHkpO1xuICAgICAgY29uc3QgbWFya2VyID0gY3JlYXRlTWFya2VyJDEoU3VnYXJFbGVtZW50LmZyb21Eb20ocm5nLnN0YXJ0Q29udGFpbmVyKSwgcm5nLnN0YXJ0T2Zmc2V0KTtcbiAgICAgIHdpdGhTY3JvbGxFdmVudHMoZWRpdG9yLCBkb2MsIGYsIG1hcmtlciwgYWxpZ25Ub1RvcCk7XG4gICAgICBtYXJrZXIuY2xlYW51cCgpO1xuICAgIH07XG4gICAgY29uc3Qgd2l0aEVsZW1lbnQgPSAoZWRpdG9yLCBlbGVtZW50LCBmLCBhbGlnblRvVG9wKSA9PiB7XG4gICAgICBjb25zdCBkb2MgPSBTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3IuZ2V0RG9jKCkpO1xuICAgICAgd2l0aFNjcm9sbEV2ZW50cyhlZGl0b3IsIGRvYywgZiwgZWxlbWVudE1hcmtlcihlbGVtZW50KSwgYWxpZ25Ub1RvcCk7XG4gICAgfTtcbiAgICBjb25zdCBwcmVzZXJ2ZVdpdGggPSAoZWRpdG9yLCBmLCBybmcpID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0RWxlbWVudCA9IHJuZy5zdGFydENvbnRhaW5lcjtcbiAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gcm5nLnN0YXJ0T2Zmc2V0O1xuICAgICAgY29uc3QgZW5kRWxlbWVudCA9IHJuZy5lbmRDb250YWluZXI7XG4gICAgICBjb25zdCBlbmRPZmZzZXQgPSBybmcuZW5kT2Zmc2V0O1xuICAgICAgZihTdWdhckVsZW1lbnQuZnJvbURvbShzdGFydEVsZW1lbnQpLCBTdWdhckVsZW1lbnQuZnJvbURvbShlbmRFbGVtZW50KSk7XG4gICAgICBjb25zdCBuZXdSbmcgPSBlZGl0b3IuZG9tLmNyZWF0ZVJuZygpO1xuICAgICAgbmV3Um5nLnNldFN0YXJ0KHN0YXJ0RWxlbWVudCwgc3RhcnRPZmZzZXQpO1xuICAgICAgbmV3Um5nLnNldEVuZChlbmRFbGVtZW50LCBlbmRPZmZzZXQpO1xuICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRSbmcocm5nKTtcbiAgICB9O1xuICAgIGNvbnN0IHNjcm9sbFRvTWFya2VyID0gKG1hcmtlciwgYWxpZ25Ub1RvcCkgPT4gbWFya2VyLmVsZW1lbnQuZG9tLnNjcm9sbEludG9WaWV3KHsgYmxvY2s6IGFsaWduVG9Ub3AgPyAnc3RhcnQnIDogJ2VuZCcgfSk7XG4gICAgY29uc3QgaW50b1dpbmRvd0lmTmVlZGVkID0gKHNjcm9sbFRvcCwgdmlld0hlaWdodCwgbWFya2VyLCBhbGlnblRvVG9wKSA9PiB7XG4gICAgICBjb25zdCB2aWV3cG9ydEJvdHRvbSA9IHZpZXdIZWlnaHQgKyBzY3JvbGxUb3A7XG4gICAgICBjb25zdCBtYXJrZXJUb3AgPSBtYXJrZXIucG9zLnRvcDtcbiAgICAgIGNvbnN0IG1hcmtlckJvdHRvbSA9IG1hcmtlci5ib3R0b207XG4gICAgICBjb25zdCBsYXJnZXJUaGFuVmlld3BvcnQgPSBtYXJrZXJCb3R0b20gLSBtYXJrZXJUb3AgPj0gdmlld0hlaWdodDtcbiAgICAgIGlmIChtYXJrZXJUb3AgPCBzY3JvbGxUb3ApIHtcbiAgICAgICAgc2Nyb2xsVG9NYXJrZXIobWFya2VyLCBhbGlnblRvVG9wICE9PSBmYWxzZSk7XG4gICAgICB9IGVsc2UgaWYgKG1hcmtlclRvcCA+IHZpZXdwb3J0Qm90dG9tKSB7XG4gICAgICAgIGNvbnN0IGFsaWduID0gbGFyZ2VyVGhhblZpZXdwb3J0ID8gYWxpZ25Ub1RvcCAhPT0gZmFsc2UgOiBhbGlnblRvVG9wID09PSB0cnVlO1xuICAgICAgICBzY3JvbGxUb01hcmtlcihtYXJrZXIsIGFsaWduKTtcbiAgICAgIH0gZWxzZSBpZiAobWFya2VyQm90dG9tID4gdmlld3BvcnRCb3R0b20gJiYgIWxhcmdlclRoYW5WaWV3cG9ydCkge1xuICAgICAgICBzY3JvbGxUb01hcmtlcihtYXJrZXIsIGFsaWduVG9Ub3AgPT09IHRydWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaW50b1dpbmRvdyA9IChkb2MsIHNjcm9sbFRvcCwgbWFya2VyLCBhbGlnblRvVG9wKSA9PiB7XG4gICAgICBjb25zdCB2aWV3SGVpZ2h0ID0gZGVmYXVsdFZpZXcoZG9jKS5kb20uaW5uZXJIZWlnaHQ7XG4gICAgICBpbnRvV2luZG93SWZOZWVkZWQoc2Nyb2xsVG9wLCB2aWV3SGVpZ2h0LCBtYXJrZXIsIGFsaWduVG9Ub3ApO1xuICAgIH07XG4gICAgY29uc3QgaW50b0ZyYW1lID0gKGRvYywgc2Nyb2xsVG9wLCBtYXJrZXIsIGFsaWduVG9Ub3ApID0+IHtcbiAgICAgIGNvbnN0IGZyYW1lVmlld0hlaWdodCA9IGRlZmF1bHRWaWV3KGRvYykuZG9tLmlubmVySGVpZ2h0O1xuICAgICAgaW50b1dpbmRvd0lmTmVlZGVkKHNjcm9sbFRvcCwgZnJhbWVWaWV3SGVpZ2h0LCBtYXJrZXIsIGFsaWduVG9Ub3ApO1xuICAgICAgY29uc3Qgb3AgPSBmaW5kKG1hcmtlci5lbGVtZW50KTtcbiAgICAgIGNvbnN0IHZpZXdwb3J0Qm91bmRzID0gZ2V0Qm91bmRzKHdpbmRvdyk7XG4gICAgICBpZiAob3AudG9wIDwgdmlld3BvcnRCb3VuZHMueSkge1xuICAgICAgICBpbnRvVmlldyhtYXJrZXIuZWxlbWVudCwgYWxpZ25Ub1RvcCAhPT0gZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmIChvcC50b3AgPiB2aWV3cG9ydEJvdW5kcy5ib3R0b20pIHtcbiAgICAgICAgaW50b1ZpZXcobWFya2VyLmVsZW1lbnQsIGFsaWduVG9Ub3AgPT09IHRydWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmFuZ2VJbnRvV2luZG93ID0gKGVkaXRvciwgcm5nLCBhbGlnblRvVG9wKSA9PiB3aXRoTWFya2VyKGVkaXRvciwgaW50b1dpbmRvdywgcm5nLCBhbGlnblRvVG9wKTtcbiAgICBjb25zdCBlbGVtZW50SW50b1dpbmRvdyA9IChlZGl0b3IsIGVsZW1lbnQsIGFsaWduVG9Ub3ApID0+IHdpdGhFbGVtZW50KGVkaXRvciwgZWxlbWVudCwgaW50b1dpbmRvdywgYWxpZ25Ub1RvcCk7XG4gICAgY29uc3QgcmFuZ2VJbnRvRnJhbWUgPSAoZWRpdG9yLCBybmcsIGFsaWduVG9Ub3ApID0+IHdpdGhNYXJrZXIoZWRpdG9yLCBpbnRvRnJhbWUsIHJuZywgYWxpZ25Ub1RvcCk7XG4gICAgY29uc3QgZWxlbWVudEludG9GcmFtZSA9IChlZGl0b3IsIGVsZW1lbnQsIGFsaWduVG9Ub3ApID0+IHdpdGhFbGVtZW50KGVkaXRvciwgZWxlbWVudCwgaW50b0ZyYW1lLCBhbGlnblRvVG9wKTtcbiAgICBjb25zdCBzY3JvbGxFbGVtZW50SW50b1ZpZXcgPSAoZWRpdG9yLCBlbGVtZW50LCBhbGlnblRvVG9wKSA9PiB7XG4gICAgICBjb25zdCBzY3JvbGxlciA9IGVkaXRvci5pbmxpbmUgPyBlbGVtZW50SW50b1dpbmRvdyA6IGVsZW1lbnRJbnRvRnJhbWU7XG4gICAgICBzY3JvbGxlcihlZGl0b3IsIGVsZW1lbnQsIGFsaWduVG9Ub3ApO1xuICAgIH07XG4gICAgY29uc3Qgc2Nyb2xsUmFuZ2VJbnRvVmlldyA9IChlZGl0b3IsIHJuZywgYWxpZ25Ub1RvcCkgPT4ge1xuICAgICAgY29uc3Qgc2Nyb2xsZXIgPSBlZGl0b3IuaW5saW5lID8gcmFuZ2VJbnRvV2luZG93IDogcmFuZ2VJbnRvRnJhbWU7XG4gICAgICBzY3JvbGxlcihlZGl0b3IsIHJuZywgYWxpZ25Ub1RvcCk7XG4gICAgfTtcblxuICAgIGNvbnN0IGZvY3VzJDEgPSBlbGVtZW50ID0+IGVsZW1lbnQuZG9tLmZvY3VzKCk7XG4gICAgY29uc3QgaGFzRm9jdXMkMSA9IGVsZW1lbnQgPT4ge1xuICAgICAgY29uc3Qgcm9vdCA9IGdldFJvb3ROb2RlKGVsZW1lbnQpLmRvbTtcbiAgICAgIHJldHVybiBlbGVtZW50LmRvbSA9PT0gcm9vdC5hY3RpdmVFbGVtZW50O1xuICAgIH07XG4gICAgY29uc3QgYWN0aXZlJDEgPSAocm9vdCA9IGdldERvY3VtZW50KCkpID0+IE9wdGlvbmFsLmZyb20ocm9vdC5kb20uYWN0aXZlRWxlbWVudCkubWFwKFN1Z2FyRWxlbWVudC5mcm9tRG9tKTtcbiAgICBjb25zdCBzZWFyY2ggPSBlbGVtZW50ID0+IGFjdGl2ZSQxKGdldFJvb3ROb2RlKGVsZW1lbnQpKS5maWx0ZXIoZSA9PiBlbGVtZW50LmRvbS5jb250YWlucyhlLmRvbSkpO1xuXG4gICAgY29uc3QgY2xhbXAkMSA9IChvZmZzZXQsIGVsZW1lbnQpID0+IHtcbiAgICAgIGNvbnN0IG1heCA9IGlzVGV4dCRiKGVsZW1lbnQpID8gZ2V0JDMoZWxlbWVudCkubGVuZ3RoIDogY2hpbGRyZW4kMShlbGVtZW50KS5sZW5ndGggKyAxO1xuICAgICAgaWYgKG9mZnNldCA+IG1heCkge1xuICAgICAgICByZXR1cm4gbWF4O1xuICAgICAgfSBlbHNlIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9O1xuICAgIGNvbnN0IG5vcm1hbGl6ZVJuZyA9IHJuZyA9PiBTaW1TZWxlY3Rpb24ucmFuZ2Uocm5nLnN0YXJ0LCBjbGFtcCQxKHJuZy5zb2Zmc2V0LCBybmcuc3RhcnQpLCBybmcuZmluaXNoLCBjbGFtcCQxKHJuZy5mb2Zmc2V0LCBybmcuZmluaXNoKSk7XG4gICAgY29uc3QgaXNPckNvbnRhaW5zID0gKHJvb3QsIGVsbSkgPT4gIWlzUmVzdHJpY3RlZE5vZGUoZWxtLmRvbSkgJiYgKGNvbnRhaW5zKHJvb3QsIGVsbSkgfHwgZXEocm9vdCwgZWxtKSk7XG4gICAgY29uc3QgaXNSbmdJblJvb3QgPSByb290ID0+IHJuZyA9PiBpc09yQ29udGFpbnMocm9vdCwgcm5nLnN0YXJ0KSAmJiBpc09yQ29udGFpbnMocm9vdCwgcm5nLmZpbmlzaCk7XG4gICAgY29uc3Qgc2hvdWxkU3RvcmUgPSBlZGl0b3IgPT4gZWRpdG9yLmlubGluZSB8fCBFbnYuYnJvd3Nlci5pc0ZpcmVmb3goKTtcbiAgICBjb25zdCBuYXRpdmVSYW5nZVRvU2VsZWN0aW9uUmFuZ2UgPSByID0+IFNpbVNlbGVjdGlvbi5yYW5nZShTdWdhckVsZW1lbnQuZnJvbURvbShyLnN0YXJ0Q29udGFpbmVyKSwgci5zdGFydE9mZnNldCwgU3VnYXJFbGVtZW50LmZyb21Eb20oci5lbmRDb250YWluZXIpLCByLmVuZE9mZnNldCk7XG4gICAgY29uc3QgcmVhZFJhbmdlID0gd2luID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHdpbi5nZXRTZWxlY3Rpb24oKTtcbiAgICAgIGNvbnN0IHJuZyA9ICFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDAgPyBPcHRpb25hbC5ub25lKCkgOiBPcHRpb25hbC5mcm9tKHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApKTtcbiAgICAgIHJldHVybiBybmcubWFwKG5hdGl2ZVJhbmdlVG9TZWxlY3Rpb25SYW5nZSk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRCb29rbWFyayA9IHJvb3QgPT4ge1xuICAgICAgY29uc3Qgd2luID0gZGVmYXVsdFZpZXcocm9vdCk7XG4gICAgICByZXR1cm4gcmVhZFJhbmdlKHdpbi5kb20pLmZpbHRlcihpc1JuZ0luUm9vdChyb290KSk7XG4gICAgfTtcbiAgICBjb25zdCB2YWxpZGF0ZSA9IChyb290LCBib29rbWFyaykgPT4gT3B0aW9uYWwuZnJvbShib29rbWFyaykuZmlsdGVyKGlzUm5nSW5Sb290KHJvb3QpKS5tYXAobm9ybWFsaXplUm5nKTtcbiAgICBjb25zdCBib29rbWFya1RvTmF0aXZlUm5nID0gYm9va21hcmsgPT4ge1xuICAgICAgY29uc3Qgcm5nID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJuZy5zZXRTdGFydChib29rbWFyay5zdGFydC5kb20sIGJvb2ttYXJrLnNvZmZzZXQpO1xuICAgICAgICBybmcuc2V0RW5kKGJvb2ttYXJrLmZpbmlzaC5kb20sIGJvb2ttYXJrLmZvZmZzZXQpO1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShybmcpO1xuICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc3RvcmUgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgbmV3Qm9va21hcmsgPSBzaG91bGRTdG9yZShlZGl0b3IpID8gZ2V0Qm9va21hcmsoU3VnYXJFbGVtZW50LmZyb21Eb20oZWRpdG9yLmdldEJvZHkoKSkpIDogT3B0aW9uYWwubm9uZSgpO1xuICAgICAgZWRpdG9yLmJvb2ttYXJrID0gbmV3Qm9va21hcmsuaXNTb21lKCkgPyBuZXdCb29rbWFyayA6IGVkaXRvci5ib29rbWFyaztcbiAgICB9O1xuICAgIGNvbnN0IGdldFJuZyA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBib29rbWFyayA9IGVkaXRvci5ib29rbWFyayA/IGVkaXRvci5ib29rbWFyayA6IE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIHJldHVybiBib29rbWFyay5iaW5kKHggPT4gdmFsaWRhdGUoU3VnYXJFbGVtZW50LmZyb21Eb20oZWRpdG9yLmdldEJvZHkoKSksIHgpKS5iaW5kKGJvb2ttYXJrVG9OYXRpdmVSbmcpO1xuICAgIH07XG4gICAgY29uc3QgcmVzdG9yZSA9IGVkaXRvciA9PiB7XG4gICAgICBnZXRSbmcoZWRpdG9yKS5lYWNoKHJuZyA9PiBlZGl0b3Iuc2VsZWN0aW9uLnNldFJuZyhybmcpKTtcbiAgICB9O1xuXG4gICAgY29uc3QgaXNFZGl0b3JVSUVsZW1lbnQkMSA9IGVsbSA9PiB7XG4gICAgICBjb25zdCBjbGFzc05hbWUgPSBlbG0uY2xhc3NOYW1lLnRvU3RyaW5nKCk7XG4gICAgICByZXR1cm4gY2xhc3NOYW1lLmluZGV4T2YoJ3RveC0nKSAhPT0gLTEgfHwgY2xhc3NOYW1lLmluZGV4T2YoJ21jZS0nKSAhPT0gLTE7XG4gICAgfTtcbiAgICBjb25zdCBGb2N1c01hbmFnZXIgPSB7IGlzRWRpdG9yVUlFbGVtZW50OiBpc0VkaXRvclVJRWxlbWVudCQxIH07XG5cbiAgICBjb25zdCB3cmFwcGVkU2V0VGltZW91dCA9IChjYWxsYmFjaywgdGltZSkgPT4ge1xuICAgICAgaWYgKCFpc051bWJlcih0aW1lKSkge1xuICAgICAgICB0aW1lID0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXRUaW1lb3V0KGNhbGxiYWNrLCB0aW1lKTtcbiAgICB9O1xuICAgIGNvbnN0IHdyYXBwZWRTZXRJbnRlcnZhbCA9IChjYWxsYmFjaywgdGltZSkgPT4ge1xuICAgICAgaWYgKCFpc051bWJlcih0aW1lKSkge1xuICAgICAgICB0aW1lID0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXRJbnRlcnZhbChjYWxsYmFjaywgdGltZSk7XG4gICAgfTtcbiAgICBjb25zdCBEZWxheSA9IHtcbiAgICAgIHNldEVkaXRvclRpbWVvdXQ6IChlZGl0b3IsIGNhbGxiYWNrLCB0aW1lKSA9PiB7XG4gICAgICAgIHJldHVybiB3cmFwcGVkU2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKCFlZGl0b3IucmVtb3ZlZCkge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRpbWUpO1xuICAgICAgfSxcbiAgICAgIHNldEVkaXRvckludGVydmFsOiAoZWRpdG9yLCBjYWxsYmFjaywgdGltZSkgPT4ge1xuICAgICAgICBjb25zdCB0aW1lciA9IHdyYXBwZWRTZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgaWYgKCFlZGl0b3IucmVtb3ZlZCkge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB0aW1lKTtcbiAgICAgICAgcmV0dXJuIHRpbWVyO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBpc01hbnVhbE5vZGVDaGFuZ2UgPSBlID0+IHtcbiAgICAgIHJldHVybiBlLnR5cGUgPT09ICdub2RlY2hhbmdlJyAmJiBlLnNlbGVjdGlvbkNoYW5nZTtcbiAgICB9O1xuICAgIGNvbnN0IHJlZ2lzdGVyUGFnZU1vdXNlVXAgPSAoZWRpdG9yLCB0aHJvdHRsZWRTdG9yZSkgPT4ge1xuICAgICAgY29uc3QgbW91c2VVcFBhZ2UgPSAoKSA9PiB7XG4gICAgICAgIHRocm90dGxlZFN0b3JlLnRocm90dGxlKCk7XG4gICAgICB9O1xuICAgICAgRE9NVXRpbHMuRE9NLmJpbmQoZG9jdW1lbnQsICdtb3VzZXVwJywgbW91c2VVcFBhZ2UpO1xuICAgICAgZWRpdG9yLm9uKCdyZW1vdmUnLCAoKSA9PiB7XG4gICAgICAgIERPTVV0aWxzLkRPTS51bmJpbmQoZG9jdW1lbnQsICdtb3VzZXVwJywgbW91c2VVcFBhZ2UpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCByZWdpc3Rlck1vdXNlVXAgPSAoZWRpdG9yLCB0aHJvdHRsZWRTdG9yZSkgPT4ge1xuICAgICAgZWRpdG9yLm9uKCdtb3VzZXVwIHRvdWNoZW5kJywgX2UgPT4ge1xuICAgICAgICB0aHJvdHRsZWRTdG9yZS50aHJvdHRsZSgpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCByZWdpc3RlckVkaXRvckV2ZW50cyA9IChlZGl0b3IsIHRocm90dGxlZFN0b3JlKSA9PiB7XG4gICAgICByZWdpc3Rlck1vdXNlVXAoZWRpdG9yLCB0aHJvdHRsZWRTdG9yZSk7XG4gICAgICBlZGl0b3Iub24oJ2tleXVwIE5vZGVDaGFuZ2UgQWZ0ZXJTZXRTZWxlY3Rpb25SYW5nZScsIGUgPT4ge1xuICAgICAgICBpZiAoIWlzTWFudWFsTm9kZUNoYW5nZShlKSkge1xuICAgICAgICAgIHN0b3JlKGVkaXRvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgcmVnaXN0ZXIkNiA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCB0aHJvdHRsZWRTdG9yZSA9IGZpcnN0JDEoKCkgPT4ge1xuICAgICAgICBzdG9yZShlZGl0b3IpO1xuICAgICAgfSwgMCk7XG4gICAgICBlZGl0b3Iub24oJ2luaXQnLCAoKSA9PiB7XG4gICAgICAgIGlmIChlZGl0b3IuaW5saW5lKSB7XG4gICAgICAgICAgcmVnaXN0ZXJQYWdlTW91c2VVcChlZGl0b3IsIHRocm90dGxlZFN0b3JlKTtcbiAgICAgICAgfVxuICAgICAgICByZWdpc3RlckVkaXRvckV2ZW50cyhlZGl0b3IsIHRocm90dGxlZFN0b3JlKTtcbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm9uKCdyZW1vdmUnLCAoKSA9PiB7XG4gICAgICAgIHRocm90dGxlZFN0b3JlLmNhbmNlbCgpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGxldCBkb2N1bWVudEZvY3VzSW5IYW5kbGVyO1xuICAgIGNvbnN0IERPTSQ5ID0gRE9NVXRpbHMuRE9NO1xuICAgIGNvbnN0IGlzRWRpdG9yVUlFbGVtZW50ID0gZWxtID0+IHtcbiAgICAgIHJldHVybiBpc0VsZW1lbnQkNihlbG0pICYmIEZvY3VzTWFuYWdlci5pc0VkaXRvclVJRWxlbWVudChlbG0pO1xuICAgIH07XG4gICAgY29uc3QgaXNFZGl0b3JDb250ZW50QXJlYUVsZW1lbnQgPSBlbG0gPT4ge1xuICAgICAgY29uc3QgY2xhc3NMaXN0ID0gZWxtLmNsYXNzTGlzdDtcbiAgICAgIGlmIChjbGFzc0xpc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gY2xhc3NMaXN0LmNvbnRhaW5zKCd0b3gtZWRpdC1hcmVhJykgfHwgY2xhc3NMaXN0LmNvbnRhaW5zKCd0b3gtZWRpdC1hcmVhX19pZnJhbWUnKSB8fCBjbGFzc0xpc3QuY29udGFpbnMoJ21jZS1jb250ZW50LWJvZHknKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGlzVUlFbGVtZW50ID0gKGVkaXRvciwgZWxtKSA9PiB7XG4gICAgICBjb25zdCBjdXN0b21TZWxlY3RvciA9IGdldEN1c3RvbVVpU2VsZWN0b3IoZWRpdG9yKTtcbiAgICAgIGNvbnN0IHBhcmVudCA9IERPTSQ5LmdldFBhcmVudChlbG0sIGVsbSA9PiB7XG4gICAgICAgIHJldHVybiBpc0VkaXRvclVJRWxlbWVudChlbG0pIHx8IChjdXN0b21TZWxlY3RvciA/IGVkaXRvci5kb20uaXMoZWxtLCBjdXN0b21TZWxlY3RvcikgOiBmYWxzZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwYXJlbnQgIT09IG51bGw7XG4gICAgfTtcbiAgICBjb25zdCBnZXRBY3RpdmVFbGVtZW50ID0gZWRpdG9yID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJvb3QgPSBnZXRSb290Tm9kZShTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3IuZ2V0RWxlbWVudCgpKSk7XG4gICAgICAgIHJldHVybiBhY3RpdmUkMShyb290KS5mb2xkKCgpID0+IGRvY3VtZW50LmJvZHksIHggPT4geC5kb20pO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmJvZHk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZWdpc3RlckV2ZW50cyQxID0gKGVkaXRvck1hbmFnZXIsIGUpID0+IHtcbiAgICAgIGNvbnN0IGVkaXRvciA9IGUuZWRpdG9yO1xuICAgICAgcmVnaXN0ZXIkNihlZGl0b3IpO1xuICAgICAgY29uc3QgdG9nZ2xlQ29udGVudEFyZWFPbkZvY3VzID0gKGVkaXRvciwgZm4pID0+IHtcbiAgICAgICAgaWYgKHNob3VsZEhpZ2hsaWdodE9uRm9jdXMoZWRpdG9yKSAmJiBlZGl0b3IuaW5saW5lICE9PSB0cnVlKSB7XG4gICAgICAgICAgY29uc3QgY29udGVudEFyZWEgPSBTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3IuZ2V0Q29udGFpbmVyKCkpO1xuICAgICAgICAgIGZuKGNvbnRlbnRBcmVhLCAndG94LWVkaXQtZm9jdXMnKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGVkaXRvci5vbignZm9jdXNpbicsICgpID0+IHtcbiAgICAgICAgY29uc3QgZm9jdXNlZEVkaXRvciA9IGVkaXRvck1hbmFnZXIuZm9jdXNlZEVkaXRvcjtcbiAgICAgICAgaWYgKGlzRWRpdG9yQ29udGVudEFyZWFFbGVtZW50KGdldEFjdGl2ZUVsZW1lbnQoZWRpdG9yKSkpIHtcbiAgICAgICAgICB0b2dnbGVDb250ZW50QXJlYU9uRm9jdXMoZWRpdG9yLCBhZGQkMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvY3VzZWRFZGl0b3IgIT09IGVkaXRvcikge1xuICAgICAgICAgIGlmIChmb2N1c2VkRWRpdG9yKSB7XG4gICAgICAgICAgICBmb2N1c2VkRWRpdG9yLmRpc3BhdGNoKCdibHVyJywgeyBmb2N1c2VkRWRpdG9yOiBlZGl0b3IgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVkaXRvck1hbmFnZXIuc2V0QWN0aXZlKGVkaXRvcik7XG4gICAgICAgICAgZWRpdG9yTWFuYWdlci5mb2N1c2VkRWRpdG9yID0gZWRpdG9yO1xuICAgICAgICAgIGVkaXRvci5kaXNwYXRjaCgnZm9jdXMnLCB7IGJsdXJyZWRFZGl0b3I6IGZvY3VzZWRFZGl0b3IgfSk7XG4gICAgICAgICAgZWRpdG9yLmZvY3VzKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGVkaXRvci5vbignZm9jdXNvdXQnLCAoKSA9PiB7XG4gICAgICAgIERlbGF5LnNldEVkaXRvclRpbWVvdXQoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgZm9jdXNlZEVkaXRvciA9IGVkaXRvck1hbmFnZXIuZm9jdXNlZEVkaXRvcjtcbiAgICAgICAgICBpZiAoIWlzRWRpdG9yQ29udGVudEFyZWFFbGVtZW50KGdldEFjdGl2ZUVsZW1lbnQoZWRpdG9yKSkgfHwgZm9jdXNlZEVkaXRvciAhPT0gZWRpdG9yKSB7XG4gICAgICAgICAgICB0b2dnbGVDb250ZW50QXJlYU9uRm9jdXMoZWRpdG9yLCByZW1vdmUkOCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXNVSUVsZW1lbnQoZWRpdG9yLCBnZXRBY3RpdmVFbGVtZW50KGVkaXRvcikpICYmIGZvY3VzZWRFZGl0b3IgPT09IGVkaXRvcikge1xuICAgICAgICAgICAgZWRpdG9yLmRpc3BhdGNoKCdibHVyJywgeyBmb2N1c2VkRWRpdG9yOiBudWxsIH0pO1xuICAgICAgICAgICAgZWRpdG9yTWFuYWdlci5mb2N1c2VkRWRpdG9yID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBpZiAoIWRvY3VtZW50Rm9jdXNJbkhhbmRsZXIpIHtcbiAgICAgICAgZG9jdW1lbnRGb2N1c0luSGFuZGxlciA9IGUgPT4ge1xuICAgICAgICAgIGNvbnN0IGFjdGl2ZUVkaXRvciA9IGVkaXRvck1hbmFnZXIuYWN0aXZlRWRpdG9yO1xuICAgICAgICAgIGlmIChhY3RpdmVFZGl0b3IpIHtcbiAgICAgICAgICAgIGdldE9yaWdpbmFsRXZlbnRUYXJnZXQoZSkuZWFjaCh0YXJnZXQgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBlbGVtID0gdGFyZ2V0O1xuICAgICAgICAgICAgICBpZiAoZWxlbS5vd25lckRvY3VtZW50ID09PSBkb2N1bWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtICE9PSBkb2N1bWVudC5ib2R5ICYmICFpc1VJRWxlbWVudChhY3RpdmVFZGl0b3IsIGVsZW0pICYmIGVkaXRvck1hbmFnZXIuZm9jdXNlZEVkaXRvciA9PT0gYWN0aXZlRWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgICBhY3RpdmVFZGl0b3IuZGlzcGF0Y2goJ2JsdXInLCB7IGZvY3VzZWRFZGl0b3I6IG51bGwgfSk7XG4gICAgICAgICAgICAgICAgICBlZGl0b3JNYW5hZ2VyLmZvY3VzZWRFZGl0b3IgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBET00kOS5iaW5kKGRvY3VtZW50LCAnZm9jdXNpbicsIGRvY3VtZW50Rm9jdXNJbkhhbmRsZXIpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgdW5yZWdpc3RlckRvY3VtZW50RXZlbnRzID0gKGVkaXRvck1hbmFnZXIsIGUpID0+IHtcbiAgICAgIGlmIChlZGl0b3JNYW5hZ2VyLmZvY3VzZWRFZGl0b3IgPT09IGUuZWRpdG9yKSB7XG4gICAgICAgIGVkaXRvck1hbmFnZXIuZm9jdXNlZEVkaXRvciA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoIWVkaXRvck1hbmFnZXIuYWN0aXZlRWRpdG9yICYmIGRvY3VtZW50Rm9jdXNJbkhhbmRsZXIpIHtcbiAgICAgICAgRE9NJDkudW5iaW5kKGRvY3VtZW50LCAnZm9jdXNpbicsIGRvY3VtZW50Rm9jdXNJbkhhbmRsZXIpO1xuICAgICAgICBkb2N1bWVudEZvY3VzSW5IYW5kbGVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNldHVwJHYgPSBlZGl0b3JNYW5hZ2VyID0+IHtcbiAgICAgIGVkaXRvck1hbmFnZXIub24oJ0FkZEVkaXRvcicsIGN1cnJ5KHJlZ2lzdGVyRXZlbnRzJDEsIGVkaXRvck1hbmFnZXIpKTtcbiAgICAgIGVkaXRvck1hbmFnZXIub24oJ1JlbW92ZUVkaXRvcicsIGN1cnJ5KHVucmVnaXN0ZXJEb2N1bWVudEV2ZW50cywgZWRpdG9yTWFuYWdlcikpO1xuICAgIH07XG5cbiAgICBjb25zdCBnZXRDb250ZW50RWRpdGFibGVIb3N0ID0gKGVkaXRvciwgbm9kZSkgPT4gZWRpdG9yLmRvbS5nZXRQYXJlbnQobm9kZSwgbm9kZSA9PiBlZGl0b3IuZG9tLmdldENvbnRlbnRFZGl0YWJsZShub2RlKSA9PT0gJ3RydWUnKTtcbiAgICBjb25zdCBnZXRDb2xsYXBzZWROb2RlID0gcm5nID0+IHJuZy5jb2xsYXBzZWQgPyBPcHRpb25hbC5mcm9tKGdldE5vZGUkMShybmcuc3RhcnRDb250YWluZXIsIHJuZy5zdGFydE9mZnNldCkpLm1hcChTdWdhckVsZW1lbnQuZnJvbURvbSkgOiBPcHRpb25hbC5ub25lKCk7XG4gICAgY29uc3QgZ2V0Rm9jdXNJbkVsZW1lbnQgPSAocm9vdCwgcm5nKSA9PiBnZXRDb2xsYXBzZWROb2RlKHJuZykuYmluZChub2RlID0+IHtcbiAgICAgIGlmIChpc1RhYmxlU2VjdGlvbihub2RlKSkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShub2RlKTtcbiAgICAgIH0gZWxzZSBpZiAoIWNvbnRhaW5zKHJvb3QsIG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKHJvb3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBub3JtYWxpemVTZWxlY3Rpb24gPSAoZWRpdG9yLCBybmcpID0+IHtcbiAgICAgIGdldEZvY3VzSW5FbGVtZW50KFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRCb2R5KCkpLCBybmcpLmJpbmQoZWxtID0+IHtcbiAgICAgICAgcmV0dXJuIGZpcnN0UG9zaXRpb25JbihlbG0uZG9tKTtcbiAgICAgIH0pLmZvbGQoKCkgPT4ge1xuICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgICAgfSwgY2FyZXRQb3MgPT4gZWRpdG9yLnNlbGVjdGlvbi5zZXRSbmcoY2FyZXRQb3MudG9SYW5nZSgpKSk7XG4gICAgfTtcbiAgICBjb25zdCBmb2N1c0JvZHkgPSBib2R5ID0+IHtcbiAgICAgIGlmIChib2R5LnNldEFjdGl2ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGJvZHkuc2V0QWN0aXZlKCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgYm9keS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBib2R5LmZvY3VzKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBoYXNFbGVtZW50Rm9jdXMgPSBlbG0gPT4gaGFzRm9jdXMkMShlbG0pIHx8IHNlYXJjaChlbG0pLmlzU29tZSgpO1xuICAgIGNvbnN0IGhhc0lmcmFtZUZvY3VzID0gZWRpdG9yID0+IGlzTm9uTnVsbGFibGUoZWRpdG9yLmlmcmFtZUVsZW1lbnQpICYmIGhhc0ZvY3VzJDEoU3VnYXJFbGVtZW50LmZyb21Eb20oZWRpdG9yLmlmcmFtZUVsZW1lbnQpKTtcbiAgICBjb25zdCBoYXNJbmxpbmVGb2N1cyA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCByYXdCb2R5ID0gZWRpdG9yLmdldEJvZHkoKTtcbiAgICAgIHJldHVybiByYXdCb2R5ICYmIGhhc0VsZW1lbnRGb2N1cyhTdWdhckVsZW1lbnQuZnJvbURvbShyYXdCb2R5KSk7XG4gICAgfTtcbiAgICBjb25zdCBoYXNVaUZvY3VzID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGRvcyA9IGdldFJvb3ROb2RlKFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRFbGVtZW50KCkpKTtcbiAgICAgIHJldHVybiBhY3RpdmUkMShkb3MpLmZpbHRlcihlbGVtID0+ICFpc0VkaXRvckNvbnRlbnRBcmVhRWxlbWVudChlbGVtLmRvbSkgJiYgaXNVSUVsZW1lbnQoZWRpdG9yLCBlbGVtLmRvbSkpLmlzU29tZSgpO1xuICAgIH07XG4gICAgY29uc3QgaGFzRm9jdXMgPSBlZGl0b3IgPT4gZWRpdG9yLmlubGluZSA/IGhhc0lubGluZUZvY3VzKGVkaXRvcikgOiBoYXNJZnJhbWVGb2N1cyhlZGl0b3IpO1xuICAgIGNvbnN0IGhhc0VkaXRvck9yVWlGb2N1cyA9IGVkaXRvciA9PiBoYXNGb2N1cyhlZGl0b3IpIHx8IGhhc1VpRm9jdXMoZWRpdG9yKTtcbiAgICBjb25zdCBmb2N1c0VkaXRvciA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICAgICAgY29uc3QgYm9keSA9IGVkaXRvci5nZXRCb2R5KCk7XG4gICAgICBsZXQgcm5nID0gc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgZWRpdG9yLnF1aXJrcy5yZWZyZXNoQ29udGVudEVkaXRhYmxlKCk7XG4gICAgICBpZiAoaXNOb25OdWxsYWJsZShlZGl0b3IuYm9va21hcmspICYmICFoYXNGb2N1cyhlZGl0b3IpKSB7XG4gICAgICAgIGdldFJuZyhlZGl0b3IpLmVhY2goYm9va21hcmtSbmcgPT4ge1xuICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Um5nKGJvb2ttYXJrUm5nKTtcbiAgICAgICAgICBybmcgPSBib29rbWFya1JuZztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBjb250ZW50RWRpdGFibGVIb3N0ID0gZ2V0Q29udGVudEVkaXRhYmxlSG9zdChlZGl0b3IsIHNlbGVjdGlvbi5nZXROb2RlKCkpO1xuICAgICAgaWYgKGNvbnRlbnRFZGl0YWJsZUhvc3QgJiYgZWRpdG9yLmRvbS5pc0NoaWxkT2YoY29udGVudEVkaXRhYmxlSG9zdCwgYm9keSkpIHtcbiAgICAgICAgZm9jdXNCb2R5KGNvbnRlbnRFZGl0YWJsZUhvc3QpO1xuICAgICAgICBub3JtYWxpemVTZWxlY3Rpb24oZWRpdG9yLCBybmcpO1xuICAgICAgICBhY3RpdmF0ZUVkaXRvcihlZGl0b3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWVkaXRvci5pbmxpbmUpIHtcbiAgICAgICAgaWYgKCFFbnYuYnJvd3Nlci5pc09wZXJhKCkpIHtcbiAgICAgICAgICBmb2N1c0JvZHkoYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgZWRpdG9yLmdldFdpbigpLmZvY3VzKCk7XG4gICAgICB9XG4gICAgICBpZiAoRW52LmJyb3dzZXIuaXNGaXJlZm94KCkgfHwgZWRpdG9yLmlubGluZSkge1xuICAgICAgICBmb2N1c0JvZHkoYm9keSk7XG4gICAgICAgIG5vcm1hbGl6ZVNlbGVjdGlvbihlZGl0b3IsIHJuZyk7XG4gICAgICB9XG4gICAgICBhY3RpdmF0ZUVkaXRvcihlZGl0b3IpO1xuICAgIH07XG4gICAgY29uc3QgYWN0aXZhdGVFZGl0b3IgPSBlZGl0b3IgPT4gZWRpdG9yLmVkaXRvck1hbmFnZXIuc2V0QWN0aXZlKGVkaXRvcik7XG4gICAgY29uc3QgZm9jdXMgPSAoZWRpdG9yLCBza2lwRm9jdXMpID0+IHtcbiAgICAgIGlmIChlZGl0b3IucmVtb3ZlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoc2tpcEZvY3VzKSB7XG4gICAgICAgIGFjdGl2YXRlRWRpdG9yKGVkaXRvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb2N1c0VkaXRvcihlZGl0b3IpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBnZXRFbmRwb2ludEVsZW1lbnQgPSAocm9vdCwgcm5nLCBzdGFydCwgcmVhbCwgcmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3QgY29udGFpbmVyID0gc3RhcnQgPyBybmcuc3RhcnRDb250YWluZXIgOiBybmcuZW5kQ29udGFpbmVyO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gc3RhcnQgPyBybmcuc3RhcnRPZmZzZXQgOiBybmcuZW5kT2Zmc2V0O1xuICAgICAgcmV0dXJuIE9wdGlvbmFsLmZyb20oY29udGFpbmVyKS5tYXAoU3VnYXJFbGVtZW50LmZyb21Eb20pLm1hcChlbG0gPT4gIXJlYWwgfHwgIXJuZy5jb2xsYXBzZWQgPyBjaGlsZCQxKGVsbSwgcmVzb2x2ZShlbG0sIG9mZnNldCkpLmdldE9yKGVsbSkgOiBlbG0pLmJpbmQoZWxtID0+IGlzRWxlbWVudCQ3KGVsbSkgPyBPcHRpb25hbC5zb21lKGVsbSkgOiBwYXJlbnQoZWxtKS5maWx0ZXIoaXNFbGVtZW50JDcpKS5tYXAoZWxtID0+IGVsbS5kb20pLmdldE9yKHJvb3QpO1xuICAgIH07XG4gICAgY29uc3QgZ2V0U3RhcnQgPSAocm9vdCwgcm5nLCByZWFsID0gZmFsc2UpID0+IGdldEVuZHBvaW50RWxlbWVudChyb290LCBybmcsIHRydWUsIHJlYWwsIChlbG0sIG9mZnNldCkgPT4gTWF0aC5taW4oY2hpbGROb2Rlc0NvdW50KGVsbSksIG9mZnNldCkpO1xuICAgIGNvbnN0IGdldEVuZCQxID0gKHJvb3QsIHJuZywgcmVhbCA9IGZhbHNlKSA9PiBnZXRFbmRwb2ludEVsZW1lbnQocm9vdCwgcm5nLCBmYWxzZSwgcmVhbCwgKGVsbSwgb2Zmc2V0KSA9PiBvZmZzZXQgPiAwID8gb2Zmc2V0IC0gMSA6IG9mZnNldCk7XG4gICAgY29uc3Qgc2tpcEVtcHR5VGV4dE5vZGVzID0gKG5vZGUsIGZvcndhcmRzKSA9PiB7XG4gICAgICBjb25zdCBvcmlnID0gbm9kZTtcbiAgICAgIHdoaWxlIChub2RlICYmIGlzVGV4dCRhKG5vZGUpICYmIG5vZGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIG5vZGUgPSBmb3J3YXJkcyA/IG5vZGUubmV4dFNpYmxpbmcgOiBub2RlLnByZXZpb3VzU2libGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlIHx8IG9yaWc7XG4gICAgfTtcbiAgICBjb25zdCBnZXROb2RlID0gKHJvb3QsIHJuZykgPT4ge1xuICAgICAgaWYgKCFybmcpIHtcbiAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICB9XG4gICAgICBsZXQgc3RhcnRDb250YWluZXIgPSBybmcuc3RhcnRDb250YWluZXI7XG4gICAgICBsZXQgZW5kQ29udGFpbmVyID0gcm5nLmVuZENvbnRhaW5lcjtcbiAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gcm5nLnN0YXJ0T2Zmc2V0O1xuICAgICAgY29uc3QgZW5kT2Zmc2V0ID0gcm5nLmVuZE9mZnNldDtcbiAgICAgIGxldCBub2RlID0gcm5nLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuICAgICAgaWYgKCFybmcuY29sbGFwc2VkKSB7XG4gICAgICAgIGlmIChzdGFydENvbnRhaW5lciA9PT0gZW5kQ29udGFpbmVyKSB7XG4gICAgICAgICAgaWYgKGVuZE9mZnNldCAtIHN0YXJ0T2Zmc2V0IDwgMikge1xuICAgICAgICAgICAgaWYgKHN0YXJ0Q29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgICAgICBub2RlID0gc3RhcnRDb250YWluZXIuY2hpbGROb2Rlc1tzdGFydE9mZnNldF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc1RleHQkYShzdGFydENvbnRhaW5lcikgJiYgaXNUZXh0JGEoZW5kQ29udGFpbmVyKSkge1xuICAgICAgICAgIGlmIChzdGFydENvbnRhaW5lci5sZW5ndGggPT09IHN0YXJ0T2Zmc2V0KSB7XG4gICAgICAgICAgICBzdGFydENvbnRhaW5lciA9IHNraXBFbXB0eVRleHROb2RlcyhzdGFydENvbnRhaW5lci5uZXh0U2libGluZywgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0Q29udGFpbmVyID0gc3RhcnRDb250YWluZXIucGFyZW50Tm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVuZE9mZnNldCA9PT0gMCkge1xuICAgICAgICAgICAgZW5kQ29udGFpbmVyID0gc2tpcEVtcHR5VGV4dE5vZGVzKGVuZENvbnRhaW5lci5wcmV2aW91c1NpYmxpbmcsIGZhbHNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW5kQ29udGFpbmVyID0gZW5kQ29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGFydENvbnRhaW5lciAmJiBzdGFydENvbnRhaW5lciA9PT0gZW5kQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBub2RlID0gc3RhcnRDb250YWluZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBlbG0gPSBpc1RleHQkYShub2RlKSA/IG5vZGUucGFyZW50Tm9kZSA6IG5vZGU7XG4gICAgICByZXR1cm4gaXNFbGVtZW50JDYoZWxtKSA/IGVsbSA6IHJvb3Q7XG4gICAgfTtcbiAgICBjb25zdCBnZXRTZWxlY3RlZEJsb2NrcyA9IChkb20sIHJuZywgc3RhcnRFbG0sIGVuZEVsbSkgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0ZWRCbG9ja3MgPSBbXTtcbiAgICAgIGNvbnN0IHJvb3QgPSBkb20uZ2V0Um9vdCgpO1xuICAgICAgY29uc3Qgc3RhcnQgPSBkb20uZ2V0UGFyZW50KHN0YXJ0RWxtIHx8IGdldFN0YXJ0KHJvb3QsIHJuZywgcm5nLmNvbGxhcHNlZCksIGRvbS5pc0Jsb2NrKTtcbiAgICAgIGNvbnN0IGVuZCA9IGRvbS5nZXRQYXJlbnQoZW5kRWxtIHx8IGdldEVuZCQxKHJvb3QsIHJuZywgcm5nLmNvbGxhcHNlZCksIGRvbS5pc0Jsb2NrKTtcbiAgICAgIGlmIChzdGFydCAmJiBzdGFydCAhPT0gcm9vdCkge1xuICAgICAgICBzZWxlY3RlZEJsb2Nrcy5wdXNoKHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCAmJiBlbmQgJiYgc3RhcnQgIT09IGVuZCkge1xuICAgICAgICBsZXQgbm9kZTtcbiAgICAgICAgY29uc3Qgd2Fsa2VyID0gbmV3IERvbVRyZWVXYWxrZXIoc3RhcnQsIHJvb3QpO1xuICAgICAgICB3aGlsZSAoKG5vZGUgPSB3YWxrZXIubmV4dCgpKSAmJiBub2RlICE9PSBlbmQpIHtcbiAgICAgICAgICBpZiAoZG9tLmlzQmxvY2sobm9kZSkpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkQmxvY2tzLnB1c2gobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZW5kICYmIHN0YXJ0ICE9PSBlbmQgJiYgZW5kICE9PSByb290KSB7XG4gICAgICAgIHNlbGVjdGVkQmxvY2tzLnB1c2goZW5kKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxlY3RlZEJsb2NrcztcbiAgICB9O1xuICAgIGNvbnN0IHNlbGVjdCA9IChkb20sIG5vZGUsIGNvbnRlbnQpID0+IE9wdGlvbmFsLmZyb20obm9kZSkuYmluZChub2RlID0+IE9wdGlvbmFsLmZyb20obm9kZS5wYXJlbnROb2RlKS5tYXAocGFyZW50ID0+IHtcbiAgICAgIGNvbnN0IGlkeCA9IGRvbS5ub2RlSW5kZXgobm9kZSk7XG4gICAgICBjb25zdCBybmcgPSBkb20uY3JlYXRlUm5nKCk7XG4gICAgICBybmcuc2V0U3RhcnQocGFyZW50LCBpZHgpO1xuICAgICAgcm5nLnNldEVuZChwYXJlbnQsIGlkeCArIDEpO1xuICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgbW92ZUVuZFBvaW50KGRvbSwgcm5nLCBub2RlLCB0cnVlKTtcbiAgICAgICAgbW92ZUVuZFBvaW50KGRvbSwgcm5nLCBub2RlLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcm5nO1xuICAgIH0pKTtcblxuICAgIGNvbnN0IHByb2Nlc3NSYW5nZXMgPSAoZWRpdG9yLCByYW5nZXMpID0+IG1hcCQzKHJhbmdlcywgcmFuZ2UgPT4ge1xuICAgICAgY29uc3QgZXZ0ID0gZWRpdG9yLmRpc3BhdGNoKCdHZXRTZWxlY3Rpb25SYW5nZScsIHsgcmFuZ2UgfSk7XG4gICAgICByZXR1cm4gZXZ0LnJhbmdlICE9PSByYW5nZSA/IGV2dC5yYW5nZSA6IHJhbmdlO1xuICAgIH0pO1xuXG4gICAgY29uc3QgZ2V0RW5kID0gZWxlbWVudCA9PiBuYW1lKGVsZW1lbnQpID09PSAnaW1nJyA/IDEgOiBnZXRPcHRpb24oZWxlbWVudCkuZm9sZCgoKSA9PiBjaGlsZHJlbiQxKGVsZW1lbnQpLmxlbmd0aCwgdiA9PiB2Lmxlbmd0aCk7XG4gICAgY29uc3QgaXNUZXh0Tm9kZVdpdGhDdXJzb3JQb3NpdGlvbiA9IGVsID0+IGdldE9wdGlvbihlbCkuZmlsdGVyKHRleHQgPT4gdGV4dC50cmltKCkubGVuZ3RoICE9PSAwIHx8IHRleHQuaW5kZXhPZihuYnNwKSA+IC0xKS5pc1NvbWUoKTtcbiAgICBjb25zdCBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJDUgPSBlbGVtID0+IGlzSFRNTEVsZW1lbnQoZWxlbSkgJiYgZ2V0JDkoZWxlbSwgJ2NvbnRlbnRlZGl0YWJsZScpID09PSAnZmFsc2UnO1xuICAgIGNvbnN0IGVsZW1lbnRzV2l0aEN1cnNvclBvc2l0aW9uID0gW1xuICAgICAgJ2ltZycsXG4gICAgICAnYnInXG4gICAgXTtcbiAgICBjb25zdCBpc0N1cnNvclBvc2l0aW9uID0gZWxlbSA9PiB7XG4gICAgICBjb25zdCBoYXNDdXJzb3JQb3NpdGlvbiA9IGlzVGV4dE5vZGVXaXRoQ3Vyc29yUG9zaXRpb24oZWxlbSk7XG4gICAgICByZXR1cm4gaGFzQ3Vyc29yUG9zaXRpb24gfHwgY29udGFpbnMkMihlbGVtZW50c1dpdGhDdXJzb3JQb3NpdGlvbiwgbmFtZShlbGVtKSkgfHwgaXNDb250ZW50RWRpdGFibGVGYWxzZSQ1KGVsZW0pO1xuICAgIH07XG5cbiAgICBjb25zdCBmaXJzdCA9IGVsZW1lbnQgPT4gZGVzY2VuZGFudCQxKGVsZW1lbnQsIGlzQ3Vyc29yUG9zaXRpb24pO1xuICAgIGNvbnN0IGxhc3QgPSBlbGVtZW50ID0+IGRlc2NlbmRhbnRSdGwoZWxlbWVudCwgaXNDdXJzb3JQb3NpdGlvbik7XG4gICAgY29uc3QgZGVzY2VuZGFudFJ0bCA9IChzY29wZSwgcHJlZGljYXRlKSA9PiB7XG4gICAgICBjb25zdCBkZXNjZW5kID0gZWxlbWVudCA9PiB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gY2hpbGRyZW4kMShlbGVtZW50KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICBpZiAocHJlZGljYXRlKGNoaWxkKSkge1xuICAgICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoY2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCByZXMgPSBkZXNjZW5kKGNoaWxkKTtcbiAgICAgICAgICBpZiAocmVzLmlzU29tZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBkZXNjZW5kKHNjb3BlKTtcbiAgICB9O1xuXG4gICAgY29uc3QgYXV0b2NvbXBsZXRlU2VsZWN0b3IgPSAnW2RhdGEtbWNlLWF1dG9jb21wbGV0ZXJdJztcbiAgICBjb25zdCBjcmVhdGUkOSA9IChlZGl0b3IsIHJhbmdlKSA9PiB7XG4gICAgICBpZiAoZmluZEluKFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRCb2R5KCkpKS5pc05vbmUoKSkge1xuICAgICAgICBjb25zdCB3cmFwcGVyID0gU3VnYXJFbGVtZW50LmZyb21IdG1sKCc8c3BhbiBkYXRhLW1jZS1hdXRvY29tcGxldGVyPVwiMVwiIGRhdGEtbWNlLWJvZ3VzPVwiMVwiPjwvc3Bhbj4nLCBlZGl0b3IuZ2V0RG9jKCkpO1xuICAgICAgICBhcHBlbmQkMSh3cmFwcGVyLCBTdWdhckVsZW1lbnQuZnJvbURvbShyYW5nZS5leHRyYWN0Q29udGVudHMoKSkpO1xuICAgICAgICByYW5nZS5pbnNlcnROb2RlKHdyYXBwZXIuZG9tKTtcbiAgICAgICAgcGFyZW50KHdyYXBwZXIpLmVhY2goZWxtID0+IGVsbS5kb20ubm9ybWFsaXplKCkpO1xuICAgICAgICBsYXN0KHdyYXBwZXIpLm1hcChsYXN0ID0+IHtcbiAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldEN1cnNvckxvY2F0aW9uKGxhc3QuZG9tLCBnZXRFbmQobGFzdCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGRldGVjdCQxID0gZWxtID0+IGNsb3Nlc3QkMyhlbG0sIGF1dG9jb21wbGV0ZVNlbGVjdG9yKTtcbiAgICBjb25zdCBmaW5kSW4gPSBlbG0gPT4gZGVzY2VuZGFudChlbG0sIGF1dG9jb21wbGV0ZVNlbGVjdG9yKTtcbiAgICBjb25zdCByZW1vdmUkMyA9IChlZGl0b3IsIGVsbSkgPT4gZmluZEluKGVsbSkuZWFjaCh3cmFwcGVyID0+IHtcbiAgICAgIGNvbnN0IGJvb2ttYXJrID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRCb29rbWFyaygpO1xuICAgICAgdW53cmFwKHdyYXBwZXIpO1xuICAgICAgZWRpdG9yLnNlbGVjdGlvbi5tb3ZlVG9Cb29rbWFyayhib29rbWFyayk7XG4gICAgfSk7XG5cbiAgICBjb25zdCB0eXBlTG9va3VwID0ge1xuICAgICAgJyN0ZXh0JzogMyxcbiAgICAgICcjY29tbWVudCc6IDgsXG4gICAgICAnI2NkYXRhJzogNCxcbiAgICAgICcjcGknOiA3LFxuICAgICAgJyNkb2N0eXBlJzogMTAsXG4gICAgICAnI2RvY3VtZW50LWZyYWdtZW50JzogMTFcbiAgICB9O1xuICAgIGNvbnN0IHdhbGskMiA9IChub2RlLCByb290LCBwcmV2KSA9PiB7XG4gICAgICBjb25zdCBzdGFydE5hbWUgPSBwcmV2ID8gJ2xhc3RDaGlsZCcgOiAnZmlyc3RDaGlsZCc7XG4gICAgICBjb25zdCBzaWJsaW5nTmFtZSA9IHByZXYgPyAncHJldicgOiAnbmV4dCc7XG4gICAgICBpZiAobm9kZVtzdGFydE5hbWVdKSB7XG4gICAgICAgIHJldHVybiBub2RlW3N0YXJ0TmFtZV07XG4gICAgICB9XG4gICAgICBpZiAobm9kZSAhPT0gcm9vdCkge1xuICAgICAgICBsZXQgc2libGluZyA9IG5vZGVbc2libGluZ05hbWVdO1xuICAgICAgICBpZiAoc2libGluZykge1xuICAgICAgICAgIHJldHVybiBzaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHBhcmVudCA9IG5vZGUucGFyZW50OyBwYXJlbnQgJiYgcGFyZW50ICE9PSByb290OyBwYXJlbnQgPSBwYXJlbnQucGFyZW50KSB7XG4gICAgICAgICAgc2libGluZyA9IHBhcmVudFtzaWJsaW5nTmFtZV07XG4gICAgICAgICAgaWYgKHNpYmxpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBzaWJsaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIGNvbnN0IGlzRW1wdHlUZXh0Tm9kZSA9IG5vZGUgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgdGV4dCA9IChfYSA9IG5vZGUudmFsdWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xuICAgICAgaWYgKCFpc1doaXRlc3BhY2VUZXh0KHRleHQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgIGlmIChwYXJlbnROb2RlICYmIChwYXJlbnROb2RlLm5hbWUgIT09ICdzcGFuJyB8fCBwYXJlbnROb2RlLmF0dHIoJ3N0eWxlJykpICYmIC9eWyBdKyQvLnRlc3QodGV4dCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBjb25zdCBpc05vbkVtcHR5RWxlbWVudCA9IG5vZGUgPT4ge1xuICAgICAgY29uc3QgaXNOYW1lZEFuY2hvciA9IG5vZGUubmFtZSA9PT0gJ2EnICYmICFub2RlLmF0dHIoJ2hyZWYnKSAmJiBub2RlLmF0dHIoJ2lkJyk7XG4gICAgICByZXR1cm4gbm9kZS5hdHRyKCduYW1lJykgfHwgbm9kZS5hdHRyKCdpZCcpICYmICFub2RlLmZpcnN0Q2hpbGQgfHwgbm9kZS5hdHRyKCdkYXRhLW1jZS1ib29rbWFyaycpIHx8IGlzTmFtZWRBbmNob3I7XG4gICAgfTtcbiAgICBjbGFzcyBBc3ROb2RlIHtcbiAgICAgIGNvbnN0cnVjdG9yKG5hbWUsIHR5cGUpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgaWYgKHR5cGUgPT09IDEpIHtcbiAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBbXTtcbiAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXMubWFwID0ge307XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YXRpYyBjcmVhdGUobmFtZSwgYXR0cnMpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBBc3ROb2RlKG5hbWUsIHR5cGVMb29rdXBbbmFtZV0gfHwgMSk7XG4gICAgICAgIGlmIChhdHRycykge1xuICAgICAgICAgIGVhY2gkZChhdHRycywgKHZhbHVlLCBhdHRyTmFtZSkgPT4ge1xuICAgICAgICAgICAgbm9kZS5hdHRyKGF0dHJOYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgICByZXBsYWNlKG5vZGUpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmIChub2RlLnBhcmVudCkge1xuICAgICAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5pbnNlcnQobm9kZSwgc2VsZik7XG4gICAgICAgIHNlbGYucmVtb3ZlKCk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuICAgICAgYXR0cihuYW1lLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKCFpc1N0cmluZyhuYW1lKSkge1xuICAgICAgICAgIGlmIChpc05vbk51bGxhYmxlKG5hbWUpKSB7XG4gICAgICAgICAgICBlYWNoJGQobmFtZSwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgc2VsZi5hdHRyKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF0dHJzID0gc2VsZi5hdHRyaWJ1dGVzO1xuICAgICAgICBpZiAoYXR0cnMpIHtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmIChuYW1lIGluIGF0dHJzLm1hcCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBhdHRycy5tYXBbbmFtZV07XG4gICAgICAgICAgICAgICAgbGV0IGkgPSBhdHRycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGF0dHJzW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmFtZSBpbiBhdHRycy5tYXApIHtcbiAgICAgICAgICAgICAgbGV0IGkgPSBhdHRycy5sZW5ndGg7XG4gICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0cnNbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgICAgYXR0cnNbaV0udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYXR0cnMucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF0dHJzLm1hcFtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhdHRycy5tYXBbbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgY29uc3QgY2xvbmUgPSBuZXcgQXN0Tm9kZShzZWxmLm5hbWUsIHNlbGYudHlwZSk7XG4gICAgICAgIGNvbnN0IHNlbGZBdHRycyA9IHNlbGYuYXR0cmlidXRlcztcbiAgICAgICAgaWYgKHNlbGZBdHRycykge1xuICAgICAgICAgIGNvbnN0IGNsb25lQXR0cnMgPSBbXTtcbiAgICAgICAgICBjbG9uZUF0dHJzLm1hcCA9IHt9O1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gc2VsZkF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2VsZkF0dHIgPSBzZWxmQXR0cnNbaV07XG4gICAgICAgICAgICBpZiAoc2VsZkF0dHIubmFtZSAhPT0gJ2lkJykge1xuICAgICAgICAgICAgICBjbG9uZUF0dHJzW2Nsb25lQXR0cnMubGVuZ3RoXSA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBzZWxmQXR0ci5uYW1lLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBzZWxmQXR0ci52YWx1ZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBjbG9uZUF0dHJzLm1hcFtzZWxmQXR0ci5uYW1lXSA9IHNlbGZBdHRyLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjbG9uZS5hdHRyaWJ1dGVzID0gY2xvbmVBdHRycztcbiAgICAgICAgfVxuICAgICAgICBjbG9uZS52YWx1ZSA9IHNlbGYudmFsdWU7XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICAgIH1cbiAgICAgIHdyYXAod3JhcHBlcikge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKHNlbGYucGFyZW50KSB7XG4gICAgICAgICAgc2VsZi5wYXJlbnQuaW5zZXJ0KHdyYXBwZXIsIHNlbGYpO1xuICAgICAgICAgIHdyYXBwZXIuYXBwZW5kKHNlbGYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuICAgICAgdW53cmFwKCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgbm9kZSA9IHNlbGYuZmlyc3RDaGlsZDsgbm9kZTspIHtcbiAgICAgICAgICBjb25zdCBuZXh0ID0gbm9kZS5uZXh0O1xuICAgICAgICAgIHNlbGYuaW5zZXJ0KG5vZGUsIHNlbGYsIHRydWUpO1xuICAgICAgICAgIG5vZGUgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIHNlbGYucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgICByZW1vdmUoKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzLCBwYXJlbnQgPSBzZWxmLnBhcmVudCwgbmV4dCA9IHNlbGYubmV4dCwgcHJldiA9IHNlbGYucHJldjtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgIGlmIChwYXJlbnQuZmlyc3RDaGlsZCA9PT0gc2VsZikge1xuICAgICAgICAgICAgcGFyZW50LmZpcnN0Q2hpbGQgPSBuZXh0O1xuICAgICAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgICAgbmV4dC5wcmV2ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHByZXYpIHtcbiAgICAgICAgICAgIHByZXYubmV4dCA9IG5leHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXJlbnQubGFzdENoaWxkID09PSBzZWxmKSB7XG4gICAgICAgICAgICBwYXJlbnQubGFzdENoaWxkID0gcHJldjtcbiAgICAgICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICAgIHByZXYubmV4dCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChuZXh0KSB7XG4gICAgICAgICAgICBuZXh0LnByZXYgPSBwcmV2O1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLnBhcmVudCA9IHNlbGYubmV4dCA9IHNlbGYucHJldiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG4gICAgICBhcHBlbmQobm9kZSkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKG5vZGUucGFyZW50KSB7XG4gICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXN0ID0gc2VsZi5sYXN0Q2hpbGQ7XG4gICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgbGFzdC5uZXh0ID0gbm9kZTtcbiAgICAgICAgICBub2RlLnByZXYgPSBsYXN0O1xuICAgICAgICAgIHNlbGYubGFzdENoaWxkID0gbm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLmxhc3RDaGlsZCA9IHNlbGYuZmlyc3RDaGlsZCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5wYXJlbnQgPSBzZWxmO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICAgIGluc2VydChub2RlLCByZWZOb2RlLCBiZWZvcmUpIHtcbiAgICAgICAgaWYgKG5vZGUucGFyZW50KSB7XG4gICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJlbnQgPSByZWZOb2RlLnBhcmVudCB8fCB0aGlzO1xuICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgaWYgKHJlZk5vZGUgPT09IHBhcmVudC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICBwYXJlbnQuZmlyc3RDaGlsZCA9IG5vZGU7XG4gICAgICAgICAgfSBlbHNlIGlmIChyZWZOb2RlLnByZXYpIHtcbiAgICAgICAgICAgIHJlZk5vZGUucHJldi5uZXh0ID0gbm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5wcmV2ID0gcmVmTm9kZS5wcmV2O1xuICAgICAgICAgIG5vZGUubmV4dCA9IHJlZk5vZGU7XG4gICAgICAgICAgcmVmTm9kZS5wcmV2ID0gbm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocmVmTm9kZSA9PT0gcGFyZW50Lmxhc3RDaGlsZCkge1xuICAgICAgICAgICAgcGFyZW50Lmxhc3RDaGlsZCA9IG5vZGU7XG4gICAgICAgICAgfSBlbHNlIGlmIChyZWZOb2RlLm5leHQpIHtcbiAgICAgICAgICAgIHJlZk5vZGUubmV4dC5wcmV2ID0gbm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5uZXh0ID0gcmVmTm9kZS5uZXh0O1xuICAgICAgICAgIG5vZGUucHJldiA9IHJlZk5vZGU7XG4gICAgICAgICAgcmVmTm9kZS5uZXh0ID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgICBnZXRBbGwobmFtZSkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgY29uc3QgY29sbGVjdGlvbiA9IFtdO1xuICAgICAgICBmb3IgKGxldCBub2RlID0gc2VsZi5maXJzdENoaWxkOyBub2RlOyBub2RlID0gd2FsayQyKG5vZGUsIHNlbGYpKSB7XG4gICAgICAgICAgaWYgKG5vZGUubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgY29sbGVjdGlvbi5wdXNoKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuKCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgY29uc3QgY29sbGVjdGlvbiA9IFtdO1xuICAgICAgICBmb3IgKGxldCBub2RlID0gc2VsZi5maXJzdENoaWxkOyBub2RlOyBub2RlID0gbm9kZS5uZXh0KSB7XG4gICAgICAgICAgY29sbGVjdGlvbi5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgICAgfVxuICAgICAgZW1wdHkoKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoc2VsZi5maXJzdENoaWxkKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBub2RlID0gc2VsZi5maXJzdENoaWxkOyBub2RlOyBub2RlID0gd2FsayQyKG5vZGUsIHNlbGYpKSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgaSA9IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICBub2RlLnBhcmVudCA9IG5vZGUuZmlyc3RDaGlsZCA9IG5vZGUubGFzdENoaWxkID0gbm9kZS5uZXh0ID0gbm9kZS5wcmV2ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5maXJzdENoaWxkID0gc2VsZi5sYXN0Q2hpbGQgPSBudWxsO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cbiAgICAgIGlzRW1wdHkoZWxlbWVudHMsIHdoaXRlc3BhY2UgPSB7fSwgcHJlZGljYXRlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGxldCBub2RlID0gc2VsZi5maXJzdENoaWxkO1xuICAgICAgICBpZiAoaXNOb25FbXB0eUVsZW1lbnQoc2VsZikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgICAgICAgICAgIGlmIChub2RlLmF0dHIoJ2RhdGEtbWNlLWJvZ3VzJykpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZWxlbWVudHNbbm9kZS5uYW1lXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXNOb25FbXB0eUVsZW1lbnQobm9kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09IDgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gMyAmJiAhaXNFbXB0eVRleHROb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09IDMgJiYgbm9kZS5wYXJlbnQgJiYgd2hpdGVzcGFjZVtub2RlLnBhcmVudC5uYW1lXSAmJiBpc1doaXRlc3BhY2VUZXh0KChfYSA9IG5vZGUudmFsdWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlICYmIHByZWRpY2F0ZShub2RlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAobm9kZSA9IHdhbGskMihub2RlLCBzZWxmKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB3YWxrKHByZXYpIHtcbiAgICAgICAgcmV0dXJuIHdhbGskMih0aGlzLCBudWxsLCBwcmV2KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBpc0NvbmRpdGlvbmFsQ29tbWVudCA9IChodG1sLCBzdGFydEluZGV4KSA9PiAvXlxccypcXFtpZiBbXFx3XFxXXStcXF0+Lio8IVxcW2VuZGlmXFxdKC0tIT8pPz4vLnRlc3QoaHRtbC5zdWJzdHIoc3RhcnRJbmRleCkpO1xuICAgIGNvbnN0IGZpbmRDb21tZW50RW5kSW5kZXggPSAoaHRtbCwgaXNCb2d1cywgc3RhcnRJbmRleCA9IDApID0+IHtcbiAgICAgIGNvbnN0IGxjSHRtbCA9IGh0bWwudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChsY0h0bWwuaW5kZXhPZignW2lmICcsIHN0YXJ0SW5kZXgpICE9PSAtMSAmJiBpc0NvbmRpdGlvbmFsQ29tbWVudChsY0h0bWwsIHN0YXJ0SW5kZXgpKSB7XG4gICAgICAgIGNvbnN0IGVuZElmSW5kZXggPSBsY0h0bWwuaW5kZXhPZignW2VuZGlmXScsIHN0YXJ0SW5kZXgpO1xuICAgICAgICByZXR1cm4gbGNIdG1sLmluZGV4T2YoJz4nLCBlbmRJZkluZGV4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc0JvZ3VzKSB7XG4gICAgICAgICAgY29uc3QgZW5kSW5kZXggPSBsY0h0bWwuaW5kZXhPZignPicsIHN0YXJ0SW5kZXgpO1xuICAgICAgICAgIHJldHVybiBlbmRJbmRleCAhPT0gLTEgPyBlbmRJbmRleCA6IGxjSHRtbC5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgZW5kQ29tbWVudFJlZ2V4cCA9IC8tLSE/Pi9nO1xuICAgICAgICAgIGVuZENvbW1lbnRSZWdleHAubGFzdEluZGV4ID0gc3RhcnRJbmRleDtcbiAgICAgICAgICBjb25zdCBtYXRjaCA9IGVuZENvbW1lbnRSZWdleHAuZXhlYyhodG1sKTtcbiAgICAgICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCA6IGxjSHRtbC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGZpbmRNYXRjaGluZ0VuZFRhZ0luZGV4ID0gKHNjaGVtYSwgaHRtbCwgc3RhcnRJbmRleCkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnRUYWdSZWdFeHAgPSAvPChbIT9cXC9dKT8oW0EtWmEtejAtOVxcLV86Ll0rKS9nO1xuICAgICAgY29uc3QgZW5kVGFnUmVnRXhwID0gLyg/Olxccyg/OlteJ1wiPl0rKD86XCJbXlwiXSpcInwnW14nXSonKSkqW15cIic+XSooPzpcIlteXCI+XSp8J1teJz5dKik/fFxccyp8XFwvKT4vZztcbiAgICAgIGNvbnN0IHZvaWRFbGVtZW50cyA9IHNjaGVtYS5nZXRWb2lkRWxlbWVudHMoKTtcbiAgICAgIGxldCBjb3VudCA9IDEsIGluZGV4ID0gc3RhcnRJbmRleDtcbiAgICAgIHdoaWxlIChjb3VudCAhPT0gMCkge1xuICAgICAgICBzdGFydFRhZ1JlZ0V4cC5sYXN0SW5kZXggPSBpbmRleDtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBjb25zdCBzdGFydE1hdGNoID0gc3RhcnRUYWdSZWdFeHAuZXhlYyhodG1sKTtcbiAgICAgICAgICBpZiAoc3RhcnRNYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhcnRNYXRjaFsxXSA9PT0gJyEnKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnRzV2l0aChzdGFydE1hdGNoWzJdLCAnLS0nKSkge1xuICAgICAgICAgICAgICBpbmRleCA9IGZpbmRDb21tZW50RW5kSW5kZXgoaHRtbCwgZmFsc2UsIHN0YXJ0TWF0Y2guaW5kZXggKyAnIS0tJy5sZW5ndGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaW5kZXggPSBmaW5kQ29tbWVudEVuZEluZGV4KGh0bWwsIHRydWUsIHN0YXJ0TWF0Y2guaW5kZXggKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbmRUYWdSZWdFeHAubGFzdEluZGV4ID0gc3RhcnRUYWdSZWdFeHAubGFzdEluZGV4O1xuICAgICAgICAgICAgY29uc3QgZW5kTWF0Y2ggPSBlbmRUYWdSZWdFeHAuZXhlYyhodG1sKTtcbiAgICAgICAgICAgIGlmIChpc051bGwoZW5kTWF0Y2gpIHx8IGVuZE1hdGNoLmluZGV4ICE9PSBzdGFydFRhZ1JlZ0V4cC5sYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhcnRNYXRjaFsxXSA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgIGNvdW50IC09IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFoYXMkMih2b2lkRWxlbWVudHMsIHN0YXJ0TWF0Y2hbMl0pKSB7XG4gICAgICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRleCA9IHN0YXJ0VGFnUmVnRXhwLmxhc3RJbmRleCArIGVuZE1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH07XG4gICAgY29uc3QgdHJpbUh0bWwkMSA9ICh0ZW1wQXR0cnMsIGh0bWwpID0+IHtcbiAgICAgIGNvbnN0IHRyaW1Db250ZW50UmVnRXhwID0gbmV3IFJlZ0V4cChbJ1xcXFxzPygnICsgdGVtcEF0dHJzLmpvaW4oJ3wnKSArICcpPVwiW15cIl0rXCInXS5qb2luKCd8JyksICdnaScpO1xuICAgICAgcmV0dXJuIGh0bWwucmVwbGFjZSh0cmltQ29udGVudFJlZ0V4cCwgJycpO1xuICAgIH07XG4gICAgY29uc3QgdHJpbUludGVybmFsID0gKHNlcmlhbGl6ZXIsIGh0bWwpID0+IHtcbiAgICAgIGNvbnN0IGJvZ3VzQWxsUmVnRXhwID0gLzwoXFx3KykgW14+XSpkYXRhLW1jZS1ib2d1cz1cImFsbFwiW14+XSo+L2c7XG4gICAgICBjb25zdCBzY2hlbWEgPSBzZXJpYWxpemVyLnNjaGVtYTtcbiAgICAgIGxldCBjb250ZW50ID0gdHJpbUh0bWwkMShzZXJpYWxpemVyLmdldFRlbXBBdHRycygpLCBodG1sKTtcbiAgICAgIGNvbnN0IHZvaWRFbGVtZW50cyA9IHNjaGVtYS5nZXRWb2lkRWxlbWVudHMoKTtcbiAgICAgIGxldCBtYXRjaGVzO1xuICAgICAgd2hpbGUgKG1hdGNoZXMgPSBib2d1c0FsbFJlZ0V4cC5leGVjKGNvbnRlbnQpKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gYm9ndXNBbGxSZWdFeHAubGFzdEluZGV4O1xuICAgICAgICBjb25zdCBtYXRjaExlbmd0aCA9IG1hdGNoZXNbMF0ubGVuZ3RoO1xuICAgICAgICBsZXQgZW5kVGFnSW5kZXg7XG4gICAgICAgIGlmICh2b2lkRWxlbWVudHNbbWF0Y2hlc1sxXV0pIHtcbiAgICAgICAgICBlbmRUYWdJbmRleCA9IGluZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVuZFRhZ0luZGV4ID0gZmluZE1hdGNoaW5nRW5kVGFnSW5kZXgoc2NoZW1hLCBjb250ZW50LCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGVudCA9IGNvbnRlbnQuc3Vic3RyaW5nKDAsIGluZGV4IC0gbWF0Y2hMZW5ndGgpICsgY29udGVudC5zdWJzdHJpbmcoZW5kVGFnSW5kZXgpO1xuICAgICAgICBib2d1c0FsbFJlZ0V4cC5sYXN0SW5kZXggPSBpbmRleCAtIG1hdGNoTGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyaW0kMShjb250ZW50KTtcbiAgICB9O1xuICAgIGNvbnN0IHRyaW1FeHRlcm5hbCA9IHRyaW1JbnRlcm5hbDtcblxuICAgIGNvbnN0IGNsZWFudXBCb2d1c0VsZW1lbnRzID0gcGFyZW50ID0+IHtcbiAgICAgIGNvbnN0IGJvZ3VzRWxlbWVudHMgPSBkZXNjZW5kYW50cyhwYXJlbnQsICdbZGF0YS1tY2UtYm9ndXNdJyk7XG4gICAgICBlYWNoJGUoYm9ndXNFbGVtZW50cywgZWxlbSA9PiB7XG4gICAgICAgIGNvbnN0IGJvZ3VzVmFsdWUgPSBnZXQkOShlbGVtLCAnZGF0YS1tY2UtYm9ndXMnKTtcbiAgICAgICAgaWYgKGJvZ3VzVmFsdWUgPT09ICdhbGwnKSB7XG4gICAgICAgICAgcmVtb3ZlJDYoZWxlbSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNCciQ1KGVsZW0pKSB7XG4gICAgICAgICAgYmVmb3JlJDMoZWxlbSwgU3VnYXJFbGVtZW50LmZyb21UZXh0KHplcm9XaWR0aCkpO1xuICAgICAgICAgIHJlbW92ZSQ2KGVsZW0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVud3JhcChlbGVtKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBjbGVhbnVwSW5wdXROYW1lcyA9IHBhcmVudCA9PiB7XG4gICAgICBjb25zdCBpbnB1dHMgPSBkZXNjZW5kYW50cyhwYXJlbnQsICdpbnB1dCcpO1xuICAgICAgZWFjaCRlKGlucHV0cywgaW5wdXQgPT4ge1xuICAgICAgICByZW1vdmUkYihpbnB1dCwgJ25hbWUnKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCB0cmltRW1wdHlDb250ZW50cyA9IChlZGl0b3IsIGh0bWwpID0+IHtcbiAgICAgIGNvbnN0IGJsb2NrTmFtZSA9IGdldEZvcmNlZFJvb3RCbG9jayhlZGl0b3IpO1xuICAgICAgY29uc3QgZW1wdHlSZWdFeHAgPSBuZXcgUmVnRXhwKGBeKDwkeyBibG9ja05hbWUgfVtePl0qPigmbmJzcDt8JiMxNjA7fFxcXFxzfFxcdTAwYTB8PGJyIFxcXFwvPnwpPFxcXFwvJHsgYmxvY2tOYW1lIH0+W1xcclxcbl0qfDxiciBcXFxcLz5bXFxyXFxuXSopJGApO1xuICAgICAgcmV0dXJuIGh0bWwucmVwbGFjZShlbXB0eVJlZ0V4cCwgJycpO1xuICAgIH07XG4gICAgY29uc3QgZ2V0UGxhaW5UZXh0Q29udGVudCA9IChlZGl0b3IsIGJvZHkpID0+IHtcbiAgICAgIGNvbnN0IGRvYyA9IGVkaXRvci5nZXREb2MoKTtcbiAgICAgIGNvbnN0IGRvcyA9IGdldFJvb3ROb2RlKFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRCb2R5KCkpKTtcbiAgICAgIGNvbnN0IG9mZnNjcmVlbkRpdiA9IFN1Z2FyRWxlbWVudC5mcm9tVGFnKCdkaXYnLCBkb2MpO1xuICAgICAgc2V0JDMob2Zmc2NyZWVuRGl2LCAnZGF0YS1tY2UtYm9ndXMnLCAnYWxsJyk7XG4gICAgICBzZXRBbGwob2Zmc2NyZWVuRGl2LCB7XG4gICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgICBsZWZ0OiAnLTk5OTk5OTlweCcsXG4gICAgICAgIHRvcDogJzAnXG4gICAgICB9KTtcbiAgICAgIHNldCQxKG9mZnNjcmVlbkRpdiwgYm9keS5pbm5lckhUTUwpO1xuICAgICAgY2xlYW51cEJvZ3VzRWxlbWVudHMob2Zmc2NyZWVuRGl2KTtcbiAgICAgIGNsZWFudXBJbnB1dE5hbWVzKG9mZnNjcmVlbkRpdik7XG4gICAgICBjb25zdCByb290ID0gZ2V0Q29udGVudENvbnRhaW5lcihkb3MpO1xuICAgICAgYXBwZW5kJDEocm9vdCwgb2Zmc2NyZWVuRGl2KTtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB0cmltJDEob2Zmc2NyZWVuRGl2LmRvbS5pbm5lclRleHQpO1xuICAgICAgcmVtb3ZlJDYob2Zmc2NyZWVuRGl2KTtcbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH07XG4gICAgY29uc3QgZ2V0Q29udGVudEZyb21Cb2R5ID0gKGVkaXRvciwgYXJncywgYm9keSkgPT4ge1xuICAgICAgbGV0IGNvbnRlbnQ7XG4gICAgICBpZiAoYXJncy5mb3JtYXQgPT09ICdyYXcnKSB7XG4gICAgICAgIGNvbnRlbnQgPSBUb29scy50cmltKHRyaW1FeHRlcm5hbChlZGl0b3Iuc2VyaWFsaXplciwgYm9keS5pbm5lckhUTUwpKTtcbiAgICAgIH0gZWxzZSBpZiAoYXJncy5mb3JtYXQgPT09ICd0ZXh0Jykge1xuICAgICAgICBjb250ZW50ID0gZ2V0UGxhaW5UZXh0Q29udGVudChlZGl0b3IsIGJvZHkpO1xuICAgICAgfSBlbHNlIGlmIChhcmdzLmZvcm1hdCA9PT0gJ3RyZWUnKSB7XG4gICAgICAgIGNvbnRlbnQgPSBlZGl0b3Iuc2VyaWFsaXplci5zZXJpYWxpemUoYm9keSwgYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZW50ID0gdHJpbUVtcHR5Q29udGVudHMoZWRpdG9yLCBlZGl0b3Iuc2VyaWFsaXplci5zZXJpYWxpemUoYm9keSwgYXJncykpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2hvdWxkVHJpbSA9IGFyZ3MuZm9ybWF0ICE9PSAndGV4dCcgJiYgIWlzV3NQcmVzZXJ2ZUVsZW1lbnQoU3VnYXJFbGVtZW50LmZyb21Eb20oYm9keSkpO1xuICAgICAgcmV0dXJuIHNob3VsZFRyaW0gJiYgaXNTdHJpbmcoY29udGVudCkgPyBUb29scy50cmltKGNvbnRlbnQpIDogY29udGVudDtcbiAgICB9O1xuICAgIGNvbnN0IGdldENvbnRlbnRJbnRlcm5hbCA9IChlZGl0b3IsIGFyZ3MpID0+IE9wdGlvbmFsLmZyb20oZWRpdG9yLmdldEJvZHkoKSkuZm9sZChjb25zdGFudChhcmdzLmZvcm1hdCA9PT0gJ3RyZWUnID8gbmV3IEFzdE5vZGUoJ2JvZHknLCAxMSkgOiAnJyksIGJvZHkgPT4gZ2V0Q29udGVudEZyb21Cb2R5KGVkaXRvciwgYXJncywgYm9keSkpO1xuXG4gICAgY29uc3QgbWFrZU1hcCQxID0gVG9vbHMubWFrZU1hcDtcbiAgICBjb25zdCBXcml0ZXIgPSBzZXR0aW5ncyA9PiB7XG4gICAgICBjb25zdCBodG1sID0gW107XG4gICAgICBzZXR0aW5ncyA9IHNldHRpbmdzIHx8IHt9O1xuICAgICAgY29uc3QgaW5kZW50ID0gc2V0dGluZ3MuaW5kZW50O1xuICAgICAgY29uc3QgaW5kZW50QmVmb3JlID0gbWFrZU1hcCQxKHNldHRpbmdzLmluZGVudF9iZWZvcmUgfHwgJycpO1xuICAgICAgY29uc3QgaW5kZW50QWZ0ZXIgPSBtYWtlTWFwJDEoc2V0dGluZ3MuaW5kZW50X2FmdGVyIHx8ICcnKTtcbiAgICAgIGNvbnN0IGVuY29kZSA9IEVudGl0aWVzLmdldEVuY29kZUZ1bmMoc2V0dGluZ3MuZW50aXR5X2VuY29kaW5nIHx8ICdyYXcnLCBzZXR0aW5ncy5lbnRpdGllcyk7XG4gICAgICBjb25zdCBodG1sT3V0cHV0ID0gc2V0dGluZ3MuZWxlbWVudF9mb3JtYXQgIT09ICd4aHRtbCc7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogKG5hbWUsIGF0dHJzLCBlbXB0eSkgPT4ge1xuICAgICAgICAgIGlmIChpbmRlbnQgJiYgaW5kZW50QmVmb3JlW25hbWVdICYmIGh0bWwubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBodG1sW2h0bWwubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMCAmJiB2YWx1ZSAhPT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgaHRtbC5wdXNoKCdcXG4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaHRtbC5wdXNoKCc8JywgbmFtZSk7XG4gICAgICAgICAgaWYgKGF0dHJzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICBjb25zdCBhdHRyID0gYXR0cnNbaV07XG4gICAgICAgICAgICAgIGh0bWwucHVzaCgnICcsIGF0dHIubmFtZSwgJz1cIicsIGVuY29kZShhdHRyLnZhbHVlLCB0cnVlKSwgJ1wiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZW1wdHkgfHwgaHRtbE91dHB1dCkge1xuICAgICAgICAgICAgaHRtbFtodG1sLmxlbmd0aF0gPSAnPic7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGh0bWxbaHRtbC5sZW5ndGhdID0gJyAvPic7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbXB0eSAmJiBpbmRlbnQgJiYgaW5kZW50QWZ0ZXJbbmFtZV0gJiYgaHRtbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGh0bWxbaHRtbC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAwICYmIHZhbHVlICE9PSAnXFxuJykge1xuICAgICAgICAgICAgICBodG1sLnB1c2goJ1xcbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW5kOiBuYW1lID0+IHtcbiAgICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgICAgaHRtbC5wdXNoKCc8LycsIG5hbWUsICc+Jyk7XG4gICAgICAgICAgaWYgKGluZGVudCAmJiBpbmRlbnRBZnRlcltuYW1lXSAmJiBodG1sLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhbHVlID0gaHRtbFtodG1sLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDAgJiYgdmFsdWUgIT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgIGh0bWwucHVzaCgnXFxuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0ZXh0OiAodGV4dCwgcmF3KSA9PiB7XG4gICAgICAgICAgaWYgKHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaHRtbFtodG1sLmxlbmd0aF0gPSByYXcgPyB0ZXh0IDogZW5jb2RlKHRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2RhdGE6IHRleHQgPT4ge1xuICAgICAgICAgIGh0bWwucHVzaCgnPCFbQ0RBVEFbJywgdGV4dCwgJ11dPicpO1xuICAgICAgICB9LFxuICAgICAgICBjb21tZW50OiB0ZXh0ID0+IHtcbiAgICAgICAgICBodG1sLnB1c2goJzwhLS0nLCB0ZXh0LCAnLS0+Jyk7XG4gICAgICAgIH0sXG4gICAgICAgIHBpOiAobmFtZSwgdGV4dCkgPT4ge1xuICAgICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICBodG1sLnB1c2goJzw/JywgbmFtZSwgJyAnLCBlbmNvZGUodGV4dCksICc/PicpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBodG1sLnB1c2goJzw/JywgbmFtZSwgJz8+Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbmRlbnQpIHtcbiAgICAgICAgICAgIGh0bWwucHVzaCgnXFxuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkb2N0eXBlOiB0ZXh0ID0+IHtcbiAgICAgICAgICBodG1sLnB1c2goJzwhRE9DVFlQRScsIHRleHQsICc+JywgaW5kZW50ID8gJ1xcbicgOiAnJyk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc2V0OiAoKSA9PiB7XG4gICAgICAgICAgaHRtbC5sZW5ndGggPSAwO1xuICAgICAgICB9LFxuICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGh0bWwuam9pbignJykucmVwbGFjZSgvXFxuJC8sICcnKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgSHRtbFNlcmlhbGl6ZXIgPSAoc2V0dGluZ3MgPSB7fSwgc2NoZW1hID0gU2NoZW1hKCkpID0+IHtcbiAgICAgIGNvbnN0IHdyaXRlciA9IFdyaXRlcihzZXR0aW5ncyk7XG4gICAgICBzZXR0aW5ncy52YWxpZGF0ZSA9ICd2YWxpZGF0ZScgaW4gc2V0dGluZ3MgPyBzZXR0aW5ncy52YWxpZGF0ZSA6IHRydWU7XG4gICAgICBjb25zdCBzZXJpYWxpemUgPSBub2RlID0+IHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGUgPSBzZXR0aW5ncy52YWxpZGF0ZTtcbiAgICAgICAgY29uc3QgaGFuZGxlcnMgPSB7XG4gICAgICAgICAgMzogbm9kZSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB3cml0ZXIudGV4dCgoX2EgPSBub2RlLnZhbHVlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJywgbm9kZS5yYXcpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgODogbm9kZSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB3cml0ZXIuY29tbWVudCgoX2EgPSBub2RlLnZhbHVlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICA3OiBub2RlID0+IHtcbiAgICAgICAgICAgIHdyaXRlci5waShub2RlLm5hbWUsIG5vZGUudmFsdWUpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgMTA6IG5vZGUgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgd3JpdGVyLmRvY3R5cGUoKF9hID0gbm9kZS52YWx1ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgNDogbm9kZSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB3cml0ZXIuY2RhdGEoKF9hID0gbm9kZS52YWx1ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgMTE6IG5vZGUgPT4ge1xuICAgICAgICAgICAgbGV0IHRlbXBOb2RlID0gbm9kZTtcbiAgICAgICAgICAgIGlmICh0ZW1wTm9kZSA9IHRlbXBOb2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHdhbGsodGVtcE5vZGUpO1xuICAgICAgICAgICAgICB9IHdoaWxlICh0ZW1wTm9kZSA9IHRlbXBOb2RlLm5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgd3JpdGVyLnJlc2V0KCk7XG4gICAgICAgIGNvbnN0IHdhbGsgPSBub2RlID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzW25vZGUudHlwZV07XG4gICAgICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gbm9kZS5uYW1lO1xuICAgICAgICAgICAgY29uc3QgaXNFbXB0eSA9IG5hbWUgaW4gc2NoZW1hLmdldFZvaWRFbGVtZW50cygpO1xuICAgICAgICAgICAgbGV0IGF0dHJzID0gbm9kZS5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRlICYmIGF0dHJzICYmIGF0dHJzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgY29uc3Qgc29ydGVkQXR0cnMgPSBbXTtcbiAgICAgICAgICAgICAgc29ydGVkQXR0cnMubWFwID0ge307XG4gICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRSdWxlID0gc2NoZW1hLmdldEVsZW1lbnRSdWxlKG5vZGUubmFtZSk7XG4gICAgICAgICAgICAgIGlmIChlbGVtZW50UnVsZSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gZWxlbWVudFJ1bGUuYXR0cmlidXRlc09yZGVyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgY29uc3QgYXR0ck5hbWUgPSBlbGVtZW50UnVsZS5hdHRyaWJ1dGVzT3JkZXJbaV07XG4gICAgICAgICAgICAgICAgICBpZiAoYXR0ck5hbWUgaW4gYXR0cnMubWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJWYWx1ZSA9IGF0dHJzLm1hcFthdHRyTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIHNvcnRlZEF0dHJzLm1hcFthdHRyTmFtZV0gPSBhdHRyVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHNvcnRlZEF0dHJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGF0dHJOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhdHRyVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBhdHRyTmFtZSA9IGF0dHJzW2ldLm5hbWU7XG4gICAgICAgICAgICAgICAgICBpZiAoIShhdHRyTmFtZSBpbiBzb3J0ZWRBdHRycy5tYXApKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJWYWx1ZSA9IGF0dHJzLm1hcFthdHRyTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIHNvcnRlZEF0dHJzLm1hcFthdHRyTmFtZV0gPSBhdHRyVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHNvcnRlZEF0dHJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGF0dHJOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhdHRyVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF0dHJzID0gc29ydGVkQXR0cnM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdyaXRlci5zdGFydChuYW1lLCBhdHRycywgaXNFbXB0eSk7XG4gICAgICAgICAgICBpZiAoIWlzRW1wdHkpIHtcbiAgICAgICAgICAgICAgbGV0IGNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoKG5hbWUgPT09ICdwcmUnIHx8IG5hbWUgPT09ICd0ZXh0YXJlYScpICYmIGNoaWxkLnR5cGUgPT09IDMgJiYgKChfYSA9IGNoaWxkLnZhbHVlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgd3JpdGVyLnRleHQoJ1xcbicsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICB3YWxrKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9IHdoaWxlIChjaGlsZCA9IGNoaWxkLm5leHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdyaXRlci5lbmQobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZXIobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSAxICYmICFzZXR0aW5ncy5pbm5lcikge1xuICAgICAgICAgIHdhbGsobm9kZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAzKSB7XG4gICAgICAgICAgaGFuZGxlcnNbM10obm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFuZGxlcnNbMTFdKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXIuZ2V0Q29udGVudCgpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiB7IHNlcmlhbGl6ZSB9O1xuICAgIH07XG5cbiAgICBjb25zdCBub25Jbmhlcml0YWJsZVN0eWxlcyA9IG5ldyBTZXQoKTtcbiAgICAoKCkgPT4ge1xuICAgICAgY29uc3Qgbm9uSW5oZXJpdGFibGVTdHlsZXNBcnIgPSBbXG4gICAgICAgICdtYXJnaW4nLFxuICAgICAgICAnbWFyZ2luLWxlZnQnLFxuICAgICAgICAnbWFyZ2luLXJpZ2h0JyxcbiAgICAgICAgJ21hcmdpbi10b3AnLFxuICAgICAgICAnbWFyZ2luLWJvdHRvbScsXG4gICAgICAgICdwYWRkaW5nJyxcbiAgICAgICAgJ3BhZGRpbmctbGVmdCcsXG4gICAgICAgICdwYWRkaW5nLXJpZ2h0JyxcbiAgICAgICAgJ3BhZGRpbmctdG9wJyxcbiAgICAgICAgJ3BhZGRpbmctYm90dG9tJyxcbiAgICAgICAgJ2JvcmRlcicsXG4gICAgICAgICdib3JkZXItd2lkdGgnLFxuICAgICAgICAnYm9yZGVyLXN0eWxlJyxcbiAgICAgICAgJ2JvcmRlci1jb2xvcicsXG4gICAgICAgICdiYWNrZ3JvdW5kJyxcbiAgICAgICAgJ2JhY2tncm91bmQtYXR0YWNobWVudCcsXG4gICAgICAgICdiYWNrZ3JvdW5kLWNsaXAnLFxuICAgICAgICAnYmFja2dyb3VuZC1jb2xvcicsXG4gICAgICAgICdiYWNrZ3JvdW5kLWltYWdlJyxcbiAgICAgICAgJ2JhY2tncm91bmQtb3JpZ2luJyxcbiAgICAgICAgJ2JhY2tncm91bmQtcG9zaXRpb24nLFxuICAgICAgICAnYmFja2dyb3VuZC1yZXBlYXQnLFxuICAgICAgICAnYmFja2dyb3VuZC1zaXplJyxcbiAgICAgICAgJ2Zsb2F0JyxcbiAgICAgICAgJ3Bvc2l0aW9uJyxcbiAgICAgICAgJ2xlZnQnLFxuICAgICAgICAncmlnaHQnLFxuICAgICAgICAndG9wJyxcbiAgICAgICAgJ2JvdHRvbScsXG4gICAgICAgICd6LWluZGV4JyxcbiAgICAgICAgJ2Rpc3BsYXknLFxuICAgICAgICAndHJhbnNmb3JtJyxcbiAgICAgICAgJ3dpZHRoJyxcbiAgICAgICAgJ21heC13aWR0aCcsXG4gICAgICAgICdtaW4td2lkdGgnLFxuICAgICAgICAnaGVpZ2h0JyxcbiAgICAgICAgJ21heC1oZWlnaHQnLFxuICAgICAgICAnbWluLWhlaWdodCcsXG4gICAgICAgICdvdmVyZmxvdycsXG4gICAgICAgICdvdmVyZmxvdy14JyxcbiAgICAgICAgJ292ZXJmbG93LXknLFxuICAgICAgICAndGV4dC1vdmVyZmxvdycsXG4gICAgICAgICd2ZXJ0aWNhbC1hbGlnbicsXG4gICAgICAgICd0cmFuc2l0aW9uJyxcbiAgICAgICAgJ3RyYW5zaXRpb24tZGVsYXknLFxuICAgICAgICAndHJhbnNpdGlvbi1kdXJhdGlvbicsXG4gICAgICAgICd0cmFuc2l0aW9uLXByb3BlcnR5JyxcbiAgICAgICAgJ3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uJ1xuICAgICAgXTtcbiAgICAgIGVhY2gkZShub25Jbmhlcml0YWJsZVN0eWxlc0Fyciwgc3R5bGUgPT4ge1xuICAgICAgICBub25Jbmhlcml0YWJsZVN0eWxlcy5hZGQoc3R5bGUpO1xuICAgICAgfSk7XG4gICAgfSkoKTtcbiAgICBjb25zdCBzaG9ydGhhbmRTdHlsZVByb3BzID0gW1xuICAgICAgJ2ZvbnQnLFxuICAgICAgJ3RleHQtZGVjb3JhdGlvbicsXG4gICAgICAndGV4dC1lbXBoYXNpcydcbiAgICBdO1xuICAgIGNvbnN0IGdldFN0eWxlUHJvcHMgPSAoZG9tLCBub2RlKSA9PiBrZXlzKGRvbS5wYXJzZVN0eWxlKGRvbS5nZXRBdHRyaWIobm9kZSwgJ3N0eWxlJykpKTtcbiAgICBjb25zdCBpc05vbkluaGVyaXRhYmxlU3R5bGUgPSBzdHlsZSA9PiBub25Jbmhlcml0YWJsZVN0eWxlcy5oYXMoc3R5bGUpO1xuICAgIGNvbnN0IGhhc0luaGVyaXRhYmxlU3R5bGVzID0gKGRvbSwgbm9kZSkgPT4gZm9yYWxsKGdldFN0eWxlUHJvcHMoZG9tLCBub2RlKSwgc3R5bGUgPT4gIWlzTm9uSW5oZXJpdGFibGVTdHlsZShzdHlsZSkpO1xuICAgIGNvbnN0IGdldExvbmdoYW5kU3R5bGVQcm9wcyA9IHN0eWxlcyA9PiBmaWx0ZXIkNShzdHlsZXMsIHN0eWxlID0+IGV4aXN0cyhzaG9ydGhhbmRTdHlsZVByb3BzLCBwcm9wID0+IHN0YXJ0c1dpdGgoc3R5bGUsIHByb3ApKSk7XG4gICAgY29uc3QgaGFzU3R5bGVDb25mbGljdCA9IChkb20sIG5vZGUsIHBhcmVudE5vZGUpID0+IHtcbiAgICAgIGNvbnN0IG5vZGVTdHlsZVByb3BzID0gZ2V0U3R5bGVQcm9wcyhkb20sIG5vZGUpO1xuICAgICAgY29uc3QgcGFyZW50Tm9kZVN0eWxlUHJvcHMgPSBnZXRTdHlsZVByb3BzKGRvbSwgcGFyZW50Tm9kZSk7XG4gICAgICBjb25zdCB2YWx1ZU1pc21hdGNoID0gcHJvcCA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG5vZGVWYWx1ZSA9IChfYSA9IGRvbS5nZXRTdHlsZShub2RlLCBwcm9wKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJyc7XG4gICAgICAgIGNvbnN0IHBhcmVudFZhbHVlID0gKF9iID0gZG9tLmdldFN0eWxlKHBhcmVudE5vZGUsIHByb3ApKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJztcbiAgICAgICAgcmV0dXJuIGlzTm90RW1wdHkobm9kZVZhbHVlKSAmJiBpc05vdEVtcHR5KHBhcmVudFZhbHVlKSAmJiBub2RlVmFsdWUgIT09IHBhcmVudFZhbHVlO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBleGlzdHMobm9kZVN0eWxlUHJvcHMsIG5vZGVTdHlsZVByb3AgPT4ge1xuICAgICAgICBjb25zdCBwcm9wRXhpc3RzID0gcHJvcHMgPT4gZXhpc3RzKHByb3BzLCBwcm9wID0+IHByb3AgPT09IG5vZGVTdHlsZVByb3ApO1xuICAgICAgICBpZiAoIXByb3BFeGlzdHMocGFyZW50Tm9kZVN0eWxlUHJvcHMpICYmIHByb3BFeGlzdHMoc2hvcnRoYW5kU3R5bGVQcm9wcykpIHtcbiAgICAgICAgICBjb25zdCBsb25naGFuZFByb3BzID0gZ2V0TG9uZ2hhbmRTdHlsZVByb3BzKHBhcmVudE5vZGVTdHlsZVByb3BzKTtcbiAgICAgICAgICByZXR1cm4gZXhpc3RzKGxvbmdoYW5kUHJvcHMsIHZhbHVlTWlzbWF0Y2gpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB2YWx1ZU1pc21hdGNoKG5vZGVTdHlsZVByb3ApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgaXNDaGFyID0gKGZvcndhcmQsIHByZWRpY2F0ZSwgcG9zKSA9PiBPcHRpb25hbC5mcm9tKHBvcy5jb250YWluZXIoKSkuZmlsdGVyKGlzVGV4dCRhKS5leGlzdHModGV4dCA9PiB7XG4gICAgICBjb25zdCBkZWx0YSA9IGZvcndhcmQgPyAwIDogLTE7XG4gICAgICByZXR1cm4gcHJlZGljYXRlKHRleHQuZGF0YS5jaGFyQXQocG9zLm9mZnNldCgpICsgZGVsdGEpKTtcbiAgICB9KTtcbiAgICBjb25zdCBpc0JlZm9yZVNwYWNlID0gY3VycnkoaXNDaGFyLCB0cnVlLCBpc1doaXRlU3BhY2UpO1xuICAgIGNvbnN0IGlzQWZ0ZXJTcGFjZSA9IGN1cnJ5KGlzQ2hhciwgZmFsc2UsIGlzV2hpdGVTcGFjZSk7XG4gICAgY29uc3QgaXNFbXB0eVRleHQgPSBwb3MgPT4ge1xuICAgICAgY29uc3QgY29udGFpbmVyID0gcG9zLmNvbnRhaW5lcigpO1xuICAgICAgcmV0dXJuIGlzVGV4dCRhKGNvbnRhaW5lcikgJiYgKGNvbnRhaW5lci5kYXRhLmxlbmd0aCA9PT0gMCB8fCBpc1p3c3AoY29udGFpbmVyLmRhdGEpICYmIEJvb2ttYXJrTWFuYWdlci5pc0Jvb2ttYXJrTm9kZShjb250YWluZXIucGFyZW50Tm9kZSkpO1xuICAgIH07XG4gICAgY29uc3QgbWF0Y2hlc0VsZW1lbnRQb3NpdGlvbiA9IChiZWZvcmUsIHByZWRpY2F0ZSkgPT4gcG9zID0+IGdldENoaWxkTm9kZUF0UmVsYXRpdmVPZmZzZXQoYmVmb3JlID8gMCA6IC0xLCBwb3MpLmZpbHRlcihwcmVkaWNhdGUpLmlzU29tZSgpO1xuICAgIGNvbnN0IGlzSW1hZ2VCbG9jayA9IG5vZGUgPT4gaXNJbWcobm9kZSkgJiYgZ2V0JDcoU3VnYXJFbGVtZW50LmZyb21Eb20obm9kZSksICdkaXNwbGF5JykgPT09ICdibG9jayc7XG4gICAgY29uc3QgaXNDZWZOb2RlID0gbm9kZSA9PiBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJGIobm9kZSkgJiYgIWlzQm9ndXNBbGwkMShub2RlKTtcbiAgICBjb25zdCBpc0JlZm9yZUltYWdlQmxvY2sgPSBtYXRjaGVzRWxlbWVudFBvc2l0aW9uKHRydWUsIGlzSW1hZ2VCbG9jayk7XG4gICAgY29uc3QgaXNBZnRlckltYWdlQmxvY2sgPSBtYXRjaGVzRWxlbWVudFBvc2l0aW9uKGZhbHNlLCBpc0ltYWdlQmxvY2spO1xuICAgIGNvbnN0IGlzQmVmb3JlTWVkaWEgPSBtYXRjaGVzRWxlbWVudFBvc2l0aW9uKHRydWUsIGlzTWVkaWEkMik7XG4gICAgY29uc3QgaXNBZnRlck1lZGlhID0gbWF0Y2hlc0VsZW1lbnRQb3NpdGlvbihmYWxzZSwgaXNNZWRpYSQyKTtcbiAgICBjb25zdCBpc0JlZm9yZVRhYmxlID0gbWF0Y2hlc0VsZW1lbnRQb3NpdGlvbih0cnVlLCBpc1RhYmxlJDIpO1xuICAgIGNvbnN0IGlzQWZ0ZXJUYWJsZSA9IG1hdGNoZXNFbGVtZW50UG9zaXRpb24oZmFsc2UsIGlzVGFibGUkMik7XG4gICAgY29uc3QgaXNCZWZvcmVDb250ZW50RWRpdGFibGVGYWxzZSA9IG1hdGNoZXNFbGVtZW50UG9zaXRpb24odHJ1ZSwgaXNDZWZOb2RlKTtcbiAgICBjb25zdCBpc0FmdGVyQ29udGVudEVkaXRhYmxlRmFsc2UgPSBtYXRjaGVzRWxlbWVudFBvc2l0aW9uKGZhbHNlLCBpc0NlZk5vZGUpO1xuXG4gICAgY29uc3QgZHJvcExhc3QgPSB4cyA9PiB4cy5zbGljZSgwLCAtMSk7XG4gICAgY29uc3QgcGFyZW50c1VudGlsID0gKHN0YXJ0LCByb290LCBwcmVkaWNhdGUpID0+IHtcbiAgICAgIGlmIChjb250YWlucyhyb290LCBzdGFydCkpIHtcbiAgICAgICAgcmV0dXJuIGRyb3BMYXN0KHBhcmVudHMkMShzdGFydCwgZWxtID0+IHtcbiAgICAgICAgICByZXR1cm4gcHJlZGljYXRlKGVsbSkgfHwgZXEoZWxtLCByb290KTtcbiAgICAgICAgfSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcGFyZW50cyA9IChzdGFydCwgcm9vdCkgPT4gcGFyZW50c1VudGlsKHN0YXJ0LCByb290LCBuZXZlcik7XG4gICAgY29uc3QgcGFyZW50c0FuZFNlbGYgPSAoc3RhcnQsIHJvb3QpID0+IFtzdGFydF0uY29uY2F0KHBhcmVudHMoc3RhcnQsIHJvb3QpKTtcblxuICAgIGNvbnN0IG5hdmlnYXRlSWdub3JlRW1wdHlUZXh0Tm9kZXMgPSAoZm9yd2FyZCwgcm9vdCwgZnJvbSkgPT4gbmF2aWdhdGVJZ25vcmUoZm9yd2FyZCwgcm9vdCwgZnJvbSwgaXNFbXB0eVRleHQpO1xuICAgIGNvbnN0IGdldENsb3Nlc3RCbG9jayQxID0gKHJvb3QsIHBvcykgPT4gZmluZCQyKHBhcmVudHNBbmRTZWxmKFN1Z2FyRWxlbWVudC5mcm9tRG9tKHBvcy5jb250YWluZXIoKSksIHJvb3QpLCBpc0Jsb2NrJDIpO1xuICAgIGNvbnN0IGlzQXRCZWZvcmVBZnRlckJsb2NrQm91bmRhcnkgPSAoZm9yd2FyZCwgcm9vdCwgcG9zKSA9PiBuYXZpZ2F0ZUlnbm9yZUVtcHR5VGV4dE5vZGVzKGZvcndhcmQsIHJvb3QuZG9tLCBwb3MpLmZvcmFsbChuZXdQb3MgPT4gZ2V0Q2xvc2VzdEJsb2NrJDEocm9vdCwgcG9zKS5mb2xkKCgpID0+ICFpc0luU2FtZUJsb2NrKG5ld1BvcywgcG9zLCByb290LmRvbSksIGZyb21CbG9jayA9PiAhaXNJblNhbWVCbG9jayhuZXdQb3MsIHBvcywgcm9vdC5kb20pICYmIGNvbnRhaW5zKGZyb21CbG9jaywgU3VnYXJFbGVtZW50LmZyb21Eb20obmV3UG9zLmNvbnRhaW5lcigpKSkpKTtcbiAgICBjb25zdCBpc0F0QmxvY2tCb3VuZGFyeSA9IChmb3J3YXJkLCByb290LCBwb3MpID0+IGdldENsb3Nlc3RCbG9jayQxKHJvb3QsIHBvcykuZm9sZCgoKSA9PiBuYXZpZ2F0ZUlnbm9yZUVtcHR5VGV4dE5vZGVzKGZvcndhcmQsIHJvb3QuZG9tLCBwb3MpLmZvcmFsbChuZXdQb3MgPT4gIWlzSW5TYW1lQmxvY2sobmV3UG9zLCBwb3MsIHJvb3QuZG9tKSksIHBhcmVudCA9PiBuYXZpZ2F0ZUlnbm9yZUVtcHR5VGV4dE5vZGVzKGZvcndhcmQsIHBhcmVudC5kb20sIHBvcykuaXNOb25lKCkpO1xuICAgIGNvbnN0IGlzQXRTdGFydE9mQmxvY2sgPSBjdXJyeShpc0F0QmxvY2tCb3VuZGFyeSwgZmFsc2UpO1xuICAgIGNvbnN0IGlzQXRFbmRPZkJsb2NrID0gY3VycnkoaXNBdEJsb2NrQm91bmRhcnksIHRydWUpO1xuICAgIGNvbnN0IGlzQmVmb3JlQmxvY2sgPSBjdXJyeShpc0F0QmVmb3JlQWZ0ZXJCbG9ja0JvdW5kYXJ5LCBmYWxzZSk7XG4gICAgY29uc3QgaXNBZnRlckJsb2NrID0gY3VycnkoaXNBdEJlZm9yZUFmdGVyQmxvY2tCb3VuZGFyeSwgdHJ1ZSk7XG5cbiAgICBjb25zdCBpc0JyJDEgPSBwb3MgPT4gZ2V0RWxlbWVudEZyb21Qb3NpdGlvbihwb3MpLmV4aXN0cyhpc0JyJDUpO1xuICAgIGNvbnN0IGZpbmRCciA9IChmb3J3YXJkLCByb290LCBwb3MpID0+IHtcbiAgICAgIGNvbnN0IHBhcmVudEJsb2NrcyA9IGZpbHRlciQ1KHBhcmVudHNBbmRTZWxmKFN1Z2FyRWxlbWVudC5mcm9tRG9tKHBvcy5jb250YWluZXIoKSksIHJvb3QpLCBpc0Jsb2NrJDIpO1xuICAgICAgY29uc3Qgc2NvcGUgPSBoZWFkKHBhcmVudEJsb2NrcykuZ2V0T3Iocm9vdCk7XG4gICAgICByZXR1cm4gZnJvbVBvc2l0aW9uKGZvcndhcmQsIHNjb3BlLmRvbSwgcG9zKS5maWx0ZXIoaXNCciQxKTtcbiAgICB9O1xuICAgIGNvbnN0IGlzQmVmb3JlQnIkMSA9IChyb290LCBwb3MpID0+IGdldEVsZW1lbnRGcm9tUG9zaXRpb24ocG9zKS5leGlzdHMoaXNCciQ1KSB8fCBmaW5kQnIodHJ1ZSwgcm9vdCwgcG9zKS5pc1NvbWUoKTtcbiAgICBjb25zdCBpc0FmdGVyQnIgPSAocm9vdCwgcG9zKSA9PiBnZXRFbGVtZW50RnJvbVByZXZQb3NpdGlvbihwb3MpLmV4aXN0cyhpc0JyJDUpIHx8IGZpbmRCcihmYWxzZSwgcm9vdCwgcG9zKS5pc1NvbWUoKTtcbiAgICBjb25zdCBmaW5kUHJldmlvdXNCciA9IGN1cnJ5KGZpbmRCciwgZmFsc2UpO1xuICAgIGNvbnN0IGZpbmROZXh0QnIgPSBjdXJyeShmaW5kQnIsIHRydWUpO1xuXG4gICAgY29uc3QgaXNJbk1pZGRsZU9mVGV4dCA9IHBvcyA9PiBDYXJldFBvc2l0aW9uLmlzVGV4dFBvc2l0aW9uKHBvcykgJiYgIXBvcy5pc0F0U3RhcnQoKSAmJiAhcG9zLmlzQXRFbmQoKTtcbiAgICBjb25zdCBnZXRDbG9zZXN0QmxvY2sgPSAocm9vdCwgcG9zKSA9PiB7XG4gICAgICBjb25zdCBwYXJlbnRCbG9ja3MgPSBmaWx0ZXIkNShwYXJlbnRzQW5kU2VsZihTdWdhckVsZW1lbnQuZnJvbURvbShwb3MuY29udGFpbmVyKCkpLCByb290KSwgaXNCbG9jayQyKTtcbiAgICAgIHJldHVybiBoZWFkKHBhcmVudEJsb2NrcykuZ2V0T3Iocm9vdCk7XG4gICAgfTtcbiAgICBjb25zdCBoYXNTcGFjZUJlZm9yZSA9IChyb290LCBwb3MpID0+IHtcbiAgICAgIGlmIChpc0luTWlkZGxlT2ZUZXh0KHBvcykpIHtcbiAgICAgICAgcmV0dXJuIGlzQWZ0ZXJTcGFjZShwb3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGlzQWZ0ZXJTcGFjZShwb3MpIHx8IHByZXZQb3NpdGlvbihnZXRDbG9zZXN0QmxvY2socm9vdCwgcG9zKS5kb20sIHBvcykuZXhpc3RzKGlzQWZ0ZXJTcGFjZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBoYXNTcGFjZUFmdGVyID0gKHJvb3QsIHBvcykgPT4ge1xuICAgICAgaWYgKGlzSW5NaWRkbGVPZlRleHQocG9zKSkge1xuICAgICAgICByZXR1cm4gaXNCZWZvcmVTcGFjZShwb3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGlzQmVmb3JlU3BhY2UocG9zKSB8fCBuZXh0UG9zaXRpb24oZ2V0Q2xvc2VzdEJsb2NrKHJvb3QsIHBvcykuZG9tLCBwb3MpLmV4aXN0cyhpc0JlZm9yZVNwYWNlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGlzUHJlVmFsdWUgPSB2YWx1ZSA9PiBjb250YWlucyQyKFtcbiAgICAgICdwcmUnLFxuICAgICAgJ3ByZS13cmFwJ1xuICAgIF0sIHZhbHVlKTtcbiAgICBjb25zdCBpc0luUHJlID0gcG9zID0+IGdldEVsZW1lbnRGcm9tUG9zaXRpb24ocG9zKS5iaW5kKGVsbSA9PiBjbG9zZXN0JDQoZWxtLCBpc0VsZW1lbnQkNykpLmV4aXN0cyhlbG0gPT4gaXNQcmVWYWx1ZShnZXQkNyhlbG0sICd3aGl0ZS1zcGFjZScpKSk7XG4gICAgY29uc3QgaXNBdEJlZ2lubmluZ09mQm9keSA9IChyb290LCBwb3MpID0+IHByZXZQb3NpdGlvbihyb290LmRvbSwgcG9zKS5pc05vbmUoKTtcbiAgICBjb25zdCBpc0F0RW5kT2ZCb2R5ID0gKHJvb3QsIHBvcykgPT4gbmV4dFBvc2l0aW9uKHJvb3QuZG9tLCBwb3MpLmlzTm9uZSgpO1xuICAgIGNvbnN0IGlzQXRMaW5lQm91bmRhcnkgPSAocm9vdCwgcG9zKSA9PiBpc0F0QmVnaW5uaW5nT2ZCb2R5KHJvb3QsIHBvcykgfHwgaXNBdEVuZE9mQm9keShyb290LCBwb3MpIHx8IGlzQXRTdGFydE9mQmxvY2socm9vdCwgcG9zKSB8fCBpc0F0RW5kT2ZCbG9jayhyb290LCBwb3MpIHx8IGlzQWZ0ZXJCcihyb290LCBwb3MpIHx8IGlzQmVmb3JlQnIkMShyb290LCBwb3MpO1xuICAgIGNvbnN0IGlzQ2VmQmxvY2sgPSBub2RlID0+IGlzTm9uTnVsbGFibGUobm9kZSkgJiYgaXNDb250ZW50RWRpdGFibGVGYWxzZSRiKG5vZGUpICYmIGlzQmxvY2tMaWtlKG5vZGUpO1xuICAgIGNvbnN0IGlzU2libGluZ0NlZkJsb2NrID0gKHJvb3QsIGRpcmVjdGlvbikgPT4gY29udGFpbmVyID0+IHtcbiAgICAgIHJldHVybiBpc0NlZkJsb2NrKG5ldyBEb21UcmVlV2Fsa2VyKGNvbnRhaW5lciwgcm9vdClbZGlyZWN0aW9uXSgpKTtcbiAgICB9O1xuICAgIGNvbnN0IGlzQmVmb3JlQ2VmQmxvY2sgPSAocm9vdCwgcG9zKSA9PiB7XG4gICAgICBjb25zdCBuZXh0UG9zID0gbmV4dFBvc2l0aW9uKHJvb3QuZG9tLCBwb3MpLmdldE9yKHBvcyk7XG4gICAgICBjb25zdCBpc05leHRDZWZCbG9jayA9IGlzU2libGluZ0NlZkJsb2NrKHJvb3QuZG9tLCAnbmV4dCcpO1xuICAgICAgcmV0dXJuIHBvcy5pc0F0RW5kKCkgJiYgKGlzTmV4dENlZkJsb2NrKHBvcy5jb250YWluZXIoKSkgfHwgaXNOZXh0Q2VmQmxvY2sobmV4dFBvcy5jb250YWluZXIoKSkpO1xuICAgIH07XG4gICAgY29uc3QgaXNBZnRlckNlZkJsb2NrID0gKHJvb3QsIHBvcykgPT4ge1xuICAgICAgY29uc3QgcHJldlBvcyA9IHByZXZQb3NpdGlvbihyb290LmRvbSwgcG9zKS5nZXRPcihwb3MpO1xuICAgICAgY29uc3QgaXNQcmV2Q2VmQmxvY2sgPSBpc1NpYmxpbmdDZWZCbG9jayhyb290LmRvbSwgJ3ByZXYnKTtcbiAgICAgIHJldHVybiBwb3MuaXNBdFN0YXJ0KCkgJiYgKGlzUHJldkNlZkJsb2NrKHBvcy5jb250YWluZXIoKSkgfHwgaXNQcmV2Q2VmQmxvY2socHJldlBvcy5jb250YWluZXIoKSkpO1xuICAgIH07XG4gICAgY29uc3QgbmVlZHNUb0hhdmVOYnNwID0gKHJvb3QsIHBvcykgPT4ge1xuICAgICAgaWYgKGlzSW5QcmUocG9zKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaXNBdExpbmVCb3VuZGFyeShyb290LCBwb3MpIHx8IGhhc1NwYWNlQmVmb3JlKHJvb3QsIHBvcykgfHwgaGFzU3BhY2VBZnRlcihyb290LCBwb3MpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbmVlZHNUb0JlTmJzcExlZnQgPSAocm9vdCwgcG9zKSA9PiB7XG4gICAgICBpZiAoaXNJblByZShwb3MpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpc0F0U3RhcnRPZkJsb2NrKHJvb3QsIHBvcykgfHwgaXNCZWZvcmVCbG9jayhyb290LCBwb3MpIHx8IGlzQWZ0ZXJCcihyb290LCBwb3MpIHx8IGhhc1NwYWNlQmVmb3JlKHJvb3QsIHBvcykgfHwgaXNBZnRlckNlZkJsb2NrKHJvb3QsIHBvcyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBsZWFuUmlnaHQgPSBwb3MgPT4ge1xuICAgICAgY29uc3QgY29udGFpbmVyID0gcG9zLmNvbnRhaW5lcigpO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gcG9zLm9mZnNldCgpO1xuICAgICAgaWYgKGlzVGV4dCRhKGNvbnRhaW5lcikgJiYgb2Zmc2V0IDwgY29udGFpbmVyLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBDYXJldFBvc2l0aW9uKGNvbnRhaW5lciwgb2Zmc2V0ICsgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbmVlZHNUb0JlTmJzcFJpZ2h0ID0gKHJvb3QsIHBvcykgPT4ge1xuICAgICAgaWYgKGlzSW5QcmUocG9zKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaXNBdEVuZE9mQmxvY2socm9vdCwgcG9zKSB8fCBpc0FmdGVyQmxvY2socm9vdCwgcG9zKSB8fCBpc0JlZm9yZUJyJDEocm9vdCwgcG9zKSB8fCBoYXNTcGFjZUFmdGVyKHJvb3QsIHBvcykgfHwgaXNCZWZvcmVDZWZCbG9jayhyb290LCBwb3MpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbmVlZHNUb0JlTmJzcCA9IChyb290LCBwb3MpID0+IG5lZWRzVG9CZU5ic3BMZWZ0KHJvb3QsIHBvcykgfHwgbmVlZHNUb0JlTmJzcFJpZ2h0KHJvb3QsIGxlYW5SaWdodChwb3MpKTtcbiAgICBjb25zdCBpc05ic3BBdCA9ICh0ZXh0LCBvZmZzZXQpID0+IGlzTmJzcCh0ZXh0LmNoYXJBdChvZmZzZXQpKTtcbiAgICBjb25zdCBpc1doaXRlU3BhY2VBdCA9ICh0ZXh0LCBvZmZzZXQpID0+IGlzV2hpdGVTcGFjZSh0ZXh0LmNoYXJBdChvZmZzZXQpKTtcbiAgICBjb25zdCBoYXNOYnNwID0gcG9zID0+IHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHBvcy5jb250YWluZXIoKTtcbiAgICAgIHJldHVybiBpc1RleHQkYShjb250YWluZXIpICYmIGNvbnRhaW5zJDEoY29udGFpbmVyLmRhdGEsIG5ic3ApO1xuICAgIH07XG4gICAgY29uc3Qgbm9ybWFsaXplTmJzcE1pZGRsZSA9IHRleHQgPT4ge1xuICAgICAgY29uc3QgY2hhcnMgPSB0ZXh0LnNwbGl0KCcnKTtcbiAgICAgIHJldHVybiBtYXAkMyhjaGFycywgKGNociwgaSkgPT4ge1xuICAgICAgICBpZiAoaXNOYnNwKGNocikgJiYgaSA+IDAgJiYgaSA8IGNoYXJzLmxlbmd0aCAtIDEgJiYgaXNDb250ZW50KGNoYXJzW2kgLSAxXSkgJiYgaXNDb250ZW50KGNoYXJzW2kgKyAxXSkpIHtcbiAgICAgICAgICByZXR1cm4gJyAnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBjaHI7XG4gICAgICAgIH1cbiAgICAgIH0pLmpvaW4oJycpO1xuICAgIH07XG4gICAgY29uc3Qgbm9ybWFsaXplTmJzcEF0U3RhcnQgPSAocm9vdCwgbm9kZSwgbWFrZU5ic3ApID0+IHtcbiAgICAgIGNvbnN0IHRleHQgPSBub2RlLmRhdGE7XG4gICAgICBjb25zdCBmaXJzdFBvcyA9IENhcmV0UG9zaXRpb24obm9kZSwgMCk7XG4gICAgICBpZiAoIW1ha2VOYnNwICYmIGlzTmJzcEF0KHRleHQsIDApICYmICFuZWVkc1RvQmVOYnNwKHJvb3QsIGZpcnN0UG9zKSkge1xuICAgICAgICBub2RlLmRhdGEgPSAnICcgKyB0ZXh0LnNsaWNlKDEpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAobWFrZU5ic3AgJiYgaXNXaGl0ZVNwYWNlQXQodGV4dCwgMCkgJiYgbmVlZHNUb0JlTmJzcExlZnQocm9vdCwgZmlyc3RQb3MpKSB7XG4gICAgICAgIG5vZGUuZGF0YSA9IG5ic3AgKyB0ZXh0LnNsaWNlKDEpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG5vcm1hbGl6ZU5ic3BJbk1pZGRsZU9mVGV4dE5vZGUgPSBub2RlID0+IHtcbiAgICAgIGNvbnN0IHRleHQgPSBub2RlLmRhdGE7XG4gICAgICBjb25zdCBuZXdUZXh0ID0gbm9ybWFsaXplTmJzcE1pZGRsZSh0ZXh0KTtcbiAgICAgIGlmIChuZXdUZXh0ICE9PSB0ZXh0KSB7XG4gICAgICAgIG5vZGUuZGF0YSA9IG5ld1RleHQ7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgbm9ybWFsaXplTmJzcEF0RW5kID0gKHJvb3QsIG5vZGUsIG1ha2VOYnNwKSA9PiB7XG4gICAgICBjb25zdCB0ZXh0ID0gbm9kZS5kYXRhO1xuICAgICAgY29uc3QgbGFzdFBvcyA9IENhcmV0UG9zaXRpb24obm9kZSwgdGV4dC5sZW5ndGggLSAxKTtcbiAgICAgIGlmICghbWFrZU5ic3AgJiYgaXNOYnNwQXQodGV4dCwgdGV4dC5sZW5ndGggLSAxKSAmJiAhbmVlZHNUb0JlTmJzcChyb290LCBsYXN0UG9zKSkge1xuICAgICAgICBub2RlLmRhdGEgPSB0ZXh0LnNsaWNlKDAsIC0xKSArICcgJztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKG1ha2VOYnNwICYmIGlzV2hpdGVTcGFjZUF0KHRleHQsIHRleHQubGVuZ3RoIC0gMSkgJiYgbmVlZHNUb0JlTmJzcFJpZ2h0KHJvb3QsIGxhc3RQb3MpKSB7XG4gICAgICAgIG5vZGUuZGF0YSA9IHRleHQuc2xpY2UoMCwgLTEpICsgbmJzcDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBub3JtYWxpemVOYnNwcyA9IChyb290LCBwb3MpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHBvcy5jb250YWluZXIoKTtcbiAgICAgIGlmICghaXNUZXh0JGEoY29udGFpbmVyKSkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfVxuICAgICAgaWYgKGhhc05ic3AocG9zKSkge1xuICAgICAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplTmJzcEF0U3RhcnQocm9vdCwgY29udGFpbmVyLCBmYWxzZSkgfHwgbm9ybWFsaXplTmJzcEluTWlkZGxlT2ZUZXh0Tm9kZShjb250YWluZXIpIHx8IG5vcm1hbGl6ZU5ic3BBdEVuZChyb290LCBjb250YWluZXIsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHNvbWVJZihub3JtYWxpemVkLCBwb3MpO1xuICAgICAgfSBlbHNlIGlmIChuZWVkc1RvQmVOYnNwKHJvb3QsIHBvcykpIHtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZU5ic3BBdFN0YXJ0KHJvb3QsIGNvbnRhaW5lciwgdHJ1ZSkgfHwgbm9ybWFsaXplTmJzcEF0RW5kKHJvb3QsIGNvbnRhaW5lciwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBzb21lSWYobm9ybWFsaXplZCwgcG9zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBub3JtYWxpemVOYnNwc0luRWRpdG9yID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IHJvb3QgPSBTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3IuZ2V0Qm9keSgpKTtcbiAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgbm9ybWFsaXplTmJzcHMocm9vdCwgQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpKSkuZWFjaChwb3MgPT4ge1xuICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Um5nKHBvcy50b1JhbmdlKCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3Qgbm9ybWFsaXplJDEgPSAobm9kZSwgb2Zmc2V0LCBjb3VudCkgPT4ge1xuICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVsbSA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKG5vZGUpO1xuICAgICAgY29uc3Qgcm9vdCA9IGFuY2VzdG9yJDQoZWxtLCBpc0Jsb2NrJDIpLmdldE9yKGVsbSk7XG4gICAgICBjb25zdCB3aGl0ZXNwYWNlID0gbm9kZS5kYXRhLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgY291bnQpO1xuICAgICAgY29uc3QgaXNFbmRPZkNvbnRlbnQgPSBvZmZzZXQgKyBjb3VudCA+PSBub2RlLmRhdGEubGVuZ3RoICYmIG5lZWRzVG9CZU5ic3BSaWdodChyb290LCBDYXJldFBvc2l0aW9uKG5vZGUsIG5vZGUuZGF0YS5sZW5ndGgpKTtcbiAgICAgIGNvbnN0IGlzU3RhcnRPZkNvbnRlbnQgPSBvZmZzZXQgPT09IDAgJiYgbmVlZHNUb0JlTmJzcExlZnQocm9vdCwgQ2FyZXRQb3NpdGlvbihub2RlLCAwKSk7XG4gICAgICBub2RlLnJlcGxhY2VEYXRhKG9mZnNldCwgY291bnQsIG5vcm1hbGl6ZSQ0KHdoaXRlc3BhY2UsIDQsIGlzU3RhcnRPZkNvbnRlbnQsIGlzRW5kT2ZDb250ZW50KSk7XG4gICAgfTtcbiAgICBjb25zdCBub3JtYWxpemVXaGl0ZXNwYWNlQWZ0ZXIgPSAobm9kZSwgb2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCBjb250ZW50ID0gbm9kZS5kYXRhLnNsaWNlKG9mZnNldCk7XG4gICAgICBjb25zdCB3aGl0ZXNwYWNlQ291bnQgPSBjb250ZW50Lmxlbmd0aCAtIGxUcmltKGNvbnRlbnQpLmxlbmd0aDtcbiAgICAgIG5vcm1hbGl6ZSQxKG5vZGUsIG9mZnNldCwgd2hpdGVzcGFjZUNvdW50KTtcbiAgICB9O1xuICAgIGNvbnN0IG5vcm1hbGl6ZVdoaXRlc3BhY2VCZWZvcmUgPSAobm9kZSwgb2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCBjb250ZW50ID0gbm9kZS5kYXRhLnNsaWNlKDAsIG9mZnNldCk7XG4gICAgICBjb25zdCB3aGl0ZXNwYWNlQ291bnQgPSBjb250ZW50Lmxlbmd0aCAtIHJUcmltKGNvbnRlbnQpLmxlbmd0aDtcbiAgICAgIG5vcm1hbGl6ZSQxKG5vZGUsIG9mZnNldCAtIHdoaXRlc3BhY2VDb3VudCwgd2hpdGVzcGFjZUNvdW50KTtcbiAgICB9O1xuICAgIGNvbnN0IG1lcmdlVGV4dE5vZGVzID0gKHByZXZOb2RlLCBuZXh0Tm9kZSwgbm9ybWFsaXplV2hpdGVzcGFjZSwgbWVyZ2VUb1ByZXYgPSB0cnVlKSA9PiB7XG4gICAgICBjb25zdCB3aGl0ZXNwYWNlT2Zmc2V0ID0gclRyaW0ocHJldk5vZGUuZGF0YSkubGVuZ3RoO1xuICAgICAgY29uc3QgbmV3Tm9kZSA9IG1lcmdlVG9QcmV2ID8gcHJldk5vZGUgOiBuZXh0Tm9kZTtcbiAgICAgIGNvbnN0IHJlbW92ZU5vZGUgPSBtZXJnZVRvUHJldiA/IG5leHROb2RlIDogcHJldk5vZGU7XG4gICAgICBpZiAobWVyZ2VUb1ByZXYpIHtcbiAgICAgICAgbmV3Tm9kZS5hcHBlbmREYXRhKHJlbW92ZU5vZGUuZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdOb2RlLmluc2VydERhdGEoMCwgcmVtb3ZlTm9kZS5kYXRhKTtcbiAgICAgIH1cbiAgICAgIHJlbW92ZSQ2KFN1Z2FyRWxlbWVudC5mcm9tRG9tKHJlbW92ZU5vZGUpKTtcbiAgICAgIGlmIChub3JtYWxpemVXaGl0ZXNwYWNlKSB7XG4gICAgICAgIG5vcm1hbGl6ZVdoaXRlc3BhY2VBZnRlcihuZXdOb2RlLCB3aGl0ZXNwYWNlT2Zmc2V0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdOb2RlO1xuICAgIH07XG5cbiAgICBjb25zdCBuZWVkc1JlcG9zaXRpb24gPSAocG9zLCBlbG0pID0+IHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHBvcy5jb250YWluZXIoKTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHBvcy5vZmZzZXQoKTtcbiAgICAgIHJldHVybiAhQ2FyZXRQb3NpdGlvbi5pc1RleHRQb3NpdGlvbihwb3MpICYmIGNvbnRhaW5lciA9PT0gZWxtLnBhcmVudE5vZGUgJiYgb2Zmc2V0ID4gQ2FyZXRQb3NpdGlvbi5iZWZvcmUoZWxtKS5vZmZzZXQoKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlcG9zaXRpb24gPSAoZWxtLCBwb3MpID0+IG5lZWRzUmVwb3NpdGlvbihwb3MsIGVsbSkgPyBDYXJldFBvc2l0aW9uKHBvcy5jb250YWluZXIoKSwgcG9zLm9mZnNldCgpIC0gMSkgOiBwb3M7XG4gICAgY29uc3QgYmVmb3JlT3JTdGFydE9mID0gbm9kZSA9PiBpc1RleHQkYShub2RlKSA/IENhcmV0UG9zaXRpb24obm9kZSwgMCkgOiBDYXJldFBvc2l0aW9uLmJlZm9yZShub2RlKTtcbiAgICBjb25zdCBhZnRlck9yRW5kT2YgPSBub2RlID0+IGlzVGV4dCRhKG5vZGUpID8gQ2FyZXRQb3NpdGlvbihub2RlLCBub2RlLmRhdGEubGVuZ3RoKSA6IENhcmV0UG9zaXRpb24uYWZ0ZXIobm9kZSk7XG4gICAgY29uc3QgZ2V0UHJldmlvdXNTaWJsaW5nQ2FyZXRQb3NpdGlvbiA9IGVsbSA9PiB7XG4gICAgICBpZiAoaXNDYXJldENhbmRpZGF0ZSQzKGVsbS5wcmV2aW91c1NpYmxpbmcpKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKGFmdGVyT3JFbmRPZihlbG0ucHJldmlvdXNTaWJsaW5nKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZWxtLnByZXZpb3VzU2libGluZyA/IGxhc3RQb3NpdGlvbkluKGVsbS5wcmV2aW91c1NpYmxpbmcpIDogT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZ2V0TmV4dFNpYmxpbmdDYXJldFBvc2l0aW9uID0gZWxtID0+IHtcbiAgICAgIGlmIChpc0NhcmV0Q2FuZGlkYXRlJDMoZWxtLm5leHRTaWJsaW5nKSkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShiZWZvcmVPclN0YXJ0T2YoZWxtLm5leHRTaWJsaW5nKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZWxtLm5leHRTaWJsaW5nID8gZmlyc3RQb3NpdGlvbkluKGVsbS5uZXh0U2libGluZykgOiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBmaW5kQ2FyZXRQb3NpdGlvbkJhY2t3YXJkc0Zyb21FbG0gPSAocm9vdEVsZW1lbnQsIGVsbSkgPT4ge1xuICAgICAgcmV0dXJuIE9wdGlvbmFsLmZyb20oZWxtLnByZXZpb3VzU2libGluZyA/IGVsbS5wcmV2aW91c1NpYmxpbmcgOiBlbG0ucGFyZW50Tm9kZSkuYmluZChub2RlID0+IHByZXZQb3NpdGlvbihyb290RWxlbWVudCwgQ2FyZXRQb3NpdGlvbi5iZWZvcmUobm9kZSkpKS5vclRodW5rKCgpID0+IG5leHRQb3NpdGlvbihyb290RWxlbWVudCwgQ2FyZXRQb3NpdGlvbi5hZnRlcihlbG0pKSk7XG4gICAgfTtcbiAgICBjb25zdCBmaW5kQ2FyZXRQb3NpdGlvbkZvcndhcmRzRnJvbUVsbSA9IChyb290RWxlbWVudCwgZWxtKSA9PiBuZXh0UG9zaXRpb24ocm9vdEVsZW1lbnQsIENhcmV0UG9zaXRpb24uYWZ0ZXIoZWxtKSkub3JUaHVuaygoKSA9PiBwcmV2UG9zaXRpb24ocm9vdEVsZW1lbnQsIENhcmV0UG9zaXRpb24uYmVmb3JlKGVsbSkpKTtcbiAgICBjb25zdCBmaW5kQ2FyZXRQb3NpdGlvbkJhY2t3YXJkcyA9IChyb290RWxlbWVudCwgZWxtKSA9PiBnZXRQcmV2aW91c1NpYmxpbmdDYXJldFBvc2l0aW9uKGVsbSkub3JUaHVuaygoKSA9PiBnZXROZXh0U2libGluZ0NhcmV0UG9zaXRpb24oZWxtKSkub3JUaHVuaygoKSA9PiBmaW5kQ2FyZXRQb3NpdGlvbkJhY2t3YXJkc0Zyb21FbG0ocm9vdEVsZW1lbnQsIGVsbSkpO1xuICAgIGNvbnN0IGZpbmRDYXJldFBvc2l0aW9uRm9yd2FyZCA9IChyb290RWxlbWVudCwgZWxtKSA9PiBnZXROZXh0U2libGluZ0NhcmV0UG9zaXRpb24oZWxtKS5vclRodW5rKCgpID0+IGdldFByZXZpb3VzU2libGluZ0NhcmV0UG9zaXRpb24oZWxtKSkub3JUaHVuaygoKSA9PiBmaW5kQ2FyZXRQb3NpdGlvbkZvcndhcmRzRnJvbUVsbShyb290RWxlbWVudCwgZWxtKSk7XG4gICAgY29uc3QgZmluZENhcmV0UG9zaXRpb24gPSAoZm9yd2FyZCwgcm9vdEVsZW1lbnQsIGVsbSkgPT4gZm9yd2FyZCA/IGZpbmRDYXJldFBvc2l0aW9uRm9yd2FyZChyb290RWxlbWVudCwgZWxtKSA6IGZpbmRDYXJldFBvc2l0aW9uQmFja3dhcmRzKHJvb3RFbGVtZW50LCBlbG0pO1xuICAgIGNvbnN0IGZpbmRDYXJldFBvc091dHNpZGVFbG1BZnRlckRlbGV0ZSA9IChmb3J3YXJkLCByb290RWxlbWVudCwgZWxtKSA9PiBmaW5kQ2FyZXRQb3NpdGlvbihmb3J3YXJkLCByb290RWxlbWVudCwgZWxtKS5tYXAoY3VycnkocmVwb3NpdGlvbiwgZWxtKSk7XG4gICAgY29uc3Qgc2V0U2VsZWN0aW9uJDEgPSAoZWRpdG9yLCBmb3J3YXJkLCBwb3MpID0+IHtcbiAgICAgIHBvcy5mb2xkKCgpID0+IHtcbiAgICAgICAgZWRpdG9yLmZvY3VzKCk7XG4gICAgICB9LCBwb3MgPT4ge1xuICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFJuZyhwb3MudG9SYW5nZSgpLCBmb3J3YXJkKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgZXFSYXdOb2RlID0gcmF3Tm9kZSA9PiBlbG0gPT4gZWxtLmRvbSA9PT0gcmF3Tm9kZTtcbiAgICBjb25zdCBpc0Jsb2NrID0gKGVkaXRvciwgZWxtKSA9PiBlbG0gJiYgaGFzJDIoZWRpdG9yLnNjaGVtYS5nZXRCbG9ja0VsZW1lbnRzKCksIG5hbWUoZWxtKSk7XG4gICAgY29uc3QgcGFkZEVtcHR5QmxvY2sgPSBlbG0gPT4ge1xuICAgICAgaWYgKGlzRW1wdHkkMihlbG0pKSB7XG4gICAgICAgIGNvbnN0IGJyID0gU3VnYXJFbGVtZW50LmZyb21IdG1sKCc8YnIgZGF0YS1tY2UtYm9ndXM9XCIxXCI+Jyk7XG4gICAgICAgIGVtcHR5KGVsbSk7XG4gICAgICAgIGFwcGVuZCQxKGVsbSwgYnIpO1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShDYXJldFBvc2l0aW9uLmJlZm9yZShici5kb20pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBkZWxldGVOb3JtYWxpemVkID0gKGVsbSwgYWZ0ZXJEZWxldGVQb3NPcHQsIG5vcm1hbGl6ZVdoaXRlc3BhY2UpID0+IHtcbiAgICAgIGNvbnN0IHByZXZUZXh0T3B0ID0gcHJldlNpYmxpbmcoZWxtKS5maWx0ZXIoaXNUZXh0JGIpO1xuICAgICAgY29uc3QgbmV4dFRleHRPcHQgPSBuZXh0U2libGluZyhlbG0pLmZpbHRlcihpc1RleHQkYik7XG4gICAgICByZW1vdmUkNihlbG0pO1xuICAgICAgcmV0dXJuIGxpZnQzKHByZXZUZXh0T3B0LCBuZXh0VGV4dE9wdCwgYWZ0ZXJEZWxldGVQb3NPcHQsIChwcmV2LCBuZXh0LCBwb3MpID0+IHtcbiAgICAgICAgY29uc3QgcHJldk5vZGUgPSBwcmV2LmRvbSwgbmV4dE5vZGUgPSBuZXh0LmRvbTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gcHJldk5vZGUuZGF0YS5sZW5ndGg7XG4gICAgICAgIG1lcmdlVGV4dE5vZGVzKHByZXZOb2RlLCBuZXh0Tm9kZSwgbm9ybWFsaXplV2hpdGVzcGFjZSk7XG4gICAgICAgIHJldHVybiBwb3MuY29udGFpbmVyKCkgPT09IG5leHROb2RlID8gQ2FyZXRQb3NpdGlvbihwcmV2Tm9kZSwgb2Zmc2V0KSA6IHBvcztcbiAgICAgIH0pLm9yVGh1bmsoKCkgPT4ge1xuICAgICAgICBpZiAobm9ybWFsaXplV2hpdGVzcGFjZSkge1xuICAgICAgICAgIHByZXZUZXh0T3B0LmVhY2goZWxtID0+IG5vcm1hbGl6ZVdoaXRlc3BhY2VCZWZvcmUoZWxtLmRvbSwgZWxtLmRvbS5sZW5ndGgpKTtcbiAgICAgICAgICBuZXh0VGV4dE9wdC5lYWNoKGVsbSA9PiBub3JtYWxpemVXaGl0ZXNwYWNlQWZ0ZXIoZWxtLmRvbSwgMCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhZnRlckRlbGV0ZVBvc09wdDtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgaXNJbmxpbmVFbGVtZW50ID0gKGVkaXRvciwgZWxlbWVudCkgPT4gaGFzJDIoZWRpdG9yLnNjaGVtYS5nZXRUZXh0SW5saW5lRWxlbWVudHMoKSwgbmFtZShlbGVtZW50KSk7XG4gICAgY29uc3QgZGVsZXRlRWxlbWVudCQyID0gKGVkaXRvciwgZm9yd2FyZCwgZWxtLCBtb3ZlQ2FyZXQgPSB0cnVlKSA9PiB7XG4gICAgICBjb25zdCBhZnRlckRlbGV0ZVBvcyA9IGZpbmRDYXJldFBvc091dHNpZGVFbG1BZnRlckRlbGV0ZShmb3J3YXJkLCBlZGl0b3IuZ2V0Qm9keSgpLCBlbG0uZG9tKTtcbiAgICAgIGNvbnN0IHBhcmVudEJsb2NrID0gYW5jZXN0b3IkNChlbG0sIGN1cnJ5KGlzQmxvY2ssIGVkaXRvciksIGVxUmF3Tm9kZShlZGl0b3IuZ2V0Qm9keSgpKSk7XG4gICAgICBjb25zdCBub3JtYWxpemVkQWZ0ZXJEZWxldGVQb3MgPSBkZWxldGVOb3JtYWxpemVkKGVsbSwgYWZ0ZXJEZWxldGVQb3MsIGlzSW5saW5lRWxlbWVudChlZGl0b3IsIGVsbSkpO1xuICAgICAgaWYgKGVkaXRvci5kb20uaXNFbXB0eShlZGl0b3IuZ2V0Qm9keSgpKSkge1xuICAgICAgICBlZGl0b3Iuc2V0Q29udGVudCgnJyk7XG4gICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Q3Vyc29yTG9jYXRpb24oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmVudEJsb2NrLmJpbmQocGFkZEVtcHR5QmxvY2spLmZvbGQoKCkgPT4ge1xuICAgICAgICAgIGlmIChtb3ZlQ2FyZXQpIHtcbiAgICAgICAgICAgIHNldFNlbGVjdGlvbiQxKGVkaXRvciwgZm9yd2FyZCwgbm9ybWFsaXplZEFmdGVyRGVsZXRlUG9zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHBhZGRQb3MgPT4ge1xuICAgICAgICAgIGlmIChtb3ZlQ2FyZXQpIHtcbiAgICAgICAgICAgIHNldFNlbGVjdGlvbiQxKGVkaXRvciwgZm9yd2FyZCwgT3B0aW9uYWwuc29tZShwYWRkUG9zKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3Qgc3Ryb25nUnRsID0gL1tcXHUwNTkxLVxcdTA3RkZcXHVGQjFELVxcdUZERkZcXHVGRTcwLVxcdUZFRkNdLztcbiAgICBjb25zdCBoYXNTdHJvbmdSdGwgPSB0ZXh0ID0+IHN0cm9uZ1J0bC50ZXN0KHRleHQpO1xuXG4gICAgY29uc3QgaXNJbmxpbmVUYXJnZXQgPSAoZWRpdG9yLCBlbG0pID0+IGlzJDEoU3VnYXJFbGVtZW50LmZyb21Eb20oZWxtKSwgZ2V0SW5saW5lQm91bmRhcnlTZWxlY3RvcihlZGl0b3IpKSAmJiAhaXNUcmFuc3BhcmVudEJsb2NrKGVkaXRvci5zY2hlbWEsIGVsbSkgJiYgZWRpdG9yLmRvbS5pc0VkaXRhYmxlKGVsbSk7XG4gICAgY29uc3QgaXNSdGwgPSBlbGVtZW50ID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHJldHVybiBET01VdGlscy5ET00uZ2V0U3R5bGUoZWxlbWVudCwgJ2RpcmVjdGlvbicsIHRydWUpID09PSAncnRsJyB8fCBoYXNTdHJvbmdSdGwoKF9hID0gZWxlbWVudC50ZXh0Q29udGVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpO1xuICAgIH07XG4gICAgY29uc3QgZmluZElubGluZVBhcmVudHMgPSAoaXNJbmxpbmVUYXJnZXQsIHJvb3ROb2RlLCBwb3MpID0+IGZpbHRlciQ1KERPTVV0aWxzLkRPTS5nZXRQYXJlbnRzKHBvcy5jb250YWluZXIoKSwgJyonLCByb290Tm9kZSksIGlzSW5saW5lVGFyZ2V0KTtcbiAgICBjb25zdCBmaW5kUm9vdElubGluZSA9IChpc0lubGluZVRhcmdldCwgcm9vdE5vZGUsIHBvcykgPT4ge1xuICAgICAgY29uc3QgcGFyZW50cyA9IGZpbmRJbmxpbmVQYXJlbnRzKGlzSW5saW5lVGFyZ2V0LCByb290Tm9kZSwgcG9zKTtcbiAgICAgIHJldHVybiBPcHRpb25hbC5mcm9tKHBhcmVudHNbcGFyZW50cy5sZW5ndGggLSAxXSk7XG4gICAgfTtcbiAgICBjb25zdCBoYXNTYW1lUGFyZW50QmxvY2sgPSAocm9vdE5vZGUsIG5vZGUxLCBub2RlMikgPT4ge1xuICAgICAgY29uc3QgYmxvY2sxID0gZ2V0UGFyZW50QmxvY2skMyhub2RlMSwgcm9vdE5vZGUpO1xuICAgICAgY29uc3QgYmxvY2syID0gZ2V0UGFyZW50QmxvY2skMyhub2RlMiwgcm9vdE5vZGUpO1xuICAgICAgcmV0dXJuIGlzTm9uTnVsbGFibGUoYmxvY2sxKSAmJiBibG9jazEgPT09IGJsb2NrMjtcbiAgICB9O1xuICAgIGNvbnN0IGlzQXRad3NwID0gcG9zID0+IGlzQmVmb3JlSW5saW5lKHBvcykgfHwgaXNBZnRlcklubGluZShwb3MpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZVBvc2l0aW9uID0gKGZvcndhcmQsIHBvcykgPT4ge1xuICAgICAgY29uc3QgY29udGFpbmVyID0gcG9zLmNvbnRhaW5lcigpLCBvZmZzZXQgPSBwb3Mub2Zmc2V0KCk7XG4gICAgICBpZiAoZm9yd2FyZCkge1xuICAgICAgICBpZiAoaXNDYXJldENvbnRhaW5lcklubGluZShjb250YWluZXIpKSB7XG4gICAgICAgICAgaWYgKGlzVGV4dCRhKGNvbnRhaW5lci5uZXh0U2libGluZykpIHtcbiAgICAgICAgICAgIHJldHVybiBDYXJldFBvc2l0aW9uKGNvbnRhaW5lci5uZXh0U2libGluZywgMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBDYXJldFBvc2l0aW9uLmFmdGVyKGNvbnRhaW5lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBpc0JlZm9yZUlubGluZShwb3MpID8gQ2FyZXRQb3NpdGlvbihjb250YWluZXIsIG9mZnNldCArIDEpIDogcG9zO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNDYXJldENvbnRhaW5lcklubGluZShjb250YWluZXIpKSB7XG4gICAgICAgICAgaWYgKGlzVGV4dCRhKGNvbnRhaW5lci5wcmV2aW91c1NpYmxpbmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbihjb250YWluZXIucHJldmlvdXNTaWJsaW5nLCBjb250YWluZXIucHJldmlvdXNTaWJsaW5nLmRhdGEubGVuZ3RoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIENhcmV0UG9zaXRpb24uYmVmb3JlKGNvbnRhaW5lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBpc0FmdGVySW5saW5lKHBvcykgPyBDYXJldFBvc2l0aW9uKGNvbnRhaW5lciwgb2Zmc2V0IC0gMSkgOiBwb3M7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG5vcm1hbGl6ZUZvcndhcmRzID0gY3Vycnkobm9ybWFsaXplUG9zaXRpb24sIHRydWUpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZUJhY2t3YXJkcyA9IGN1cnJ5KG5vcm1hbGl6ZVBvc2l0aW9uLCBmYWxzZSk7XG5cbiAgICBjb25zdCBleGVjQ29tbWFuZElnbm9yZUlucHV0RXZlbnRzID0gKGVkaXRvciwgY29tbWFuZCkgPT4ge1xuICAgICAgY29uc3QgaW5wdXRCbG9ja2VyID0gZSA9PiBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgZWRpdG9yLm9uKCdiZWZvcmVpbnB1dCBpbnB1dCcsIGlucHV0QmxvY2tlciwgdHJ1ZSk7XG4gICAgICBlZGl0b3IuZ2V0RG9jKCkuZXhlY0NvbW1hbmQoY29tbWFuZCk7XG4gICAgICBlZGl0b3Iub2ZmKCdiZWZvcmVpbnB1dCBpbnB1dCcsIGlucHV0QmxvY2tlcik7XG4gICAgfTtcbiAgICBjb25zdCBleGVjRWRpdG9yRGVsZXRlQ29tbWFuZCA9IGVkaXRvciA9PiB7XG4gICAgICBlZGl0b3IuZXhlY0NvbW1hbmQoJ2RlbGV0ZScpO1xuICAgIH07XG4gICAgY29uc3QgZXhlY05hdGl2ZURlbGV0ZUNvbW1hbmQgPSBlZGl0b3IgPT4gZXhlY0NvbW1hbmRJZ25vcmVJbnB1dEV2ZW50cyhlZGl0b3IsICdEZWxldGUnKTtcbiAgICBjb25zdCBleGVjTmF0aXZlRm9yd2FyZERlbGV0ZUNvbW1hbmQgPSBlZGl0b3IgPT4gZXhlY0NvbW1hbmRJZ25vcmVJbnB1dEV2ZW50cyhlZGl0b3IsICdGb3J3YXJkRGVsZXRlJyk7XG4gICAgY29uc3QgaXNCZWZvcmVSb290ID0gcm9vdE5vZGUgPT4gZWxtID0+IGlzJDIocGFyZW50KGVsbSksIHJvb3ROb2RlLCBlcSk7XG4gICAgY29uc3QgaXNUZXh0QmxvY2tPckxpc3RJdGVtID0gZWxlbWVudCA9PiBpc1RleHRCbG9jayQyKGVsZW1lbnQpIHx8IGlzTGlzdEl0ZW0kMShlbGVtZW50KTtcbiAgICBjb25zdCBnZXRQYXJlbnRCbG9jayQyID0gKHJvb3ROb2RlLCBlbG0pID0+IHtcbiAgICAgIGlmIChjb250YWlucyhyb290Tm9kZSwgZWxtKSkge1xuICAgICAgICByZXR1cm4gY2xvc2VzdCQ0KGVsbSwgaXNUZXh0QmxvY2tPckxpc3RJdGVtLCBpc0JlZm9yZVJvb3Qocm9vdE5vZGUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBwYWRkRW1wdHlCb2R5ID0gKGVkaXRvciwgbW92ZVNlbGVjdGlvbiA9IHRydWUpID0+IHtcbiAgICAgIGlmIChlZGl0b3IuZG9tLmlzRW1wdHkoZWRpdG9yLmdldEJvZHkoKSkpIHtcbiAgICAgICAgZWRpdG9yLnNldENvbnRlbnQoJycsIHsgbm9fc2VsZWN0aW9uOiAhbW92ZVNlbGVjdGlvbiB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHdpbGxEZWxldGVMYXN0UG9zaXRpb25JbkVsZW1lbnQgPSAoZm9yd2FyZCwgZnJvbVBvcywgZWxtKSA9PiBsaWZ0MihmaXJzdFBvc2l0aW9uSW4oZWxtKSwgbGFzdFBvc2l0aW9uSW4oZWxtKSwgKGZpcnN0UG9zLCBsYXN0UG9zKSA9PiB7XG4gICAgICBjb25zdCBub3JtYWxpemVkRmlyc3RQb3MgPSBub3JtYWxpemVQb3NpdGlvbih0cnVlLCBmaXJzdFBvcyk7XG4gICAgICBjb25zdCBub3JtYWxpemVkTGFzdFBvcyA9IG5vcm1hbGl6ZVBvc2l0aW9uKGZhbHNlLCBsYXN0UG9zKTtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRGcm9tUG9zID0gbm9ybWFsaXplUG9zaXRpb24oZmFsc2UsIGZyb21Qb3MpO1xuICAgICAgaWYgKGZvcndhcmQpIHtcbiAgICAgICAgcmV0dXJuIG5leHRQb3NpdGlvbihlbG0sIG5vcm1hbGl6ZWRGcm9tUG9zKS5leGlzdHMobmV4dFBvcyA9PiBuZXh0UG9zLmlzRXF1YWwobm9ybWFsaXplZExhc3RQb3MpICYmIGZyb21Qb3MuaXNFcXVhbChub3JtYWxpemVkRmlyc3RQb3MpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwcmV2UG9zaXRpb24oZWxtLCBub3JtYWxpemVkRnJvbVBvcykuZXhpc3RzKHByZXZQb3MgPT4gcHJldlBvcy5pc0VxdWFsKG5vcm1hbGl6ZWRGaXJzdFBvcykgJiYgZnJvbVBvcy5pc0VxdWFsKG5vcm1hbGl6ZWRMYXN0UG9zKSk7XG4gICAgICB9XG4gICAgfSkuZ2V0T3IodHJ1ZSk7XG4gICAgY29uc3QgZnJlZWZhbGxSdGwgPSByb290ID0+IHtcbiAgICAgIGNvbnN0IGNoaWxkID0gaXNDb21tZW50JDEocm9vdCkgPyBwcmV2U2libGluZyhyb290KSA6IGxhc3RDaGlsZChyb290KTtcbiAgICAgIHJldHVybiBjaGlsZC5iaW5kKGZyZWVmYWxsUnRsKS5vclRodW5rKCgpID0+IE9wdGlvbmFsLnNvbWUocm9vdCkpO1xuICAgIH07XG4gICAgY29uc3QgZGVsZXRlUmFuZ2VDb250ZW50cyA9IChlZGl0b3IsIHJuZywgcm9vdCwgbW92ZVNlbGVjdGlvbiA9IHRydWUpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHJuZy5kZWxldGVDb250ZW50cygpO1xuICAgICAgY29uc3QgbGFzdE5vZGUgPSBmcmVlZmFsbFJ0bChyb290KS5nZXRPcihyb290KTtcbiAgICAgIGNvbnN0IGxhc3RCbG9jayA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKChfYSA9IGVkaXRvci5kb20uZ2V0UGFyZW50KGxhc3ROb2RlLmRvbSwgZWRpdG9yLmRvbS5pc0Jsb2NrKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogcm9vdC5kb20pO1xuICAgICAgaWYgKGxhc3RCbG9jay5kb20gPT09IGVkaXRvci5nZXRCb2R5KCkpIHtcbiAgICAgICAgcGFkZEVtcHR5Qm9keShlZGl0b3IsIG1vdmVTZWxlY3Rpb24pO1xuICAgICAgfSBlbHNlIGlmIChpc0VtcHR5JDIobGFzdEJsb2NrKSkge1xuICAgICAgICBmaWxsV2l0aFBhZGRpbmdCcihsYXN0QmxvY2spO1xuICAgICAgICBpZiAobW92ZVNlbGVjdGlvbikge1xuICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Q3Vyc29yTG9jYXRpb24obGFzdEJsb2NrLmRvbSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghZXEocm9vdCwgbGFzdEJsb2NrKSkge1xuICAgICAgICBjb25zdCBhZGRpdGlvbmFsQ2xlYW51cE5vZGVzID0gaXMkMihwYXJlbnQobGFzdEJsb2NrKSwgcm9vdCkgPyBbXSA6IHNpYmxpbmdzKGxhc3RCbG9jayk7XG4gICAgICAgIGVhY2gkZShhZGRpdGlvbmFsQ2xlYW51cE5vZGVzLmNvbmNhdChjaGlsZHJlbiQxKHJvb3QpKSwgbm9kZSA9PiB7XG4gICAgICAgICAgaWYgKCFlcShub2RlLCBsYXN0QmxvY2spICYmICFjb250YWlucyhub2RlLCBsYXN0QmxvY2spICYmIGlzRW1wdHkkMihub2RlKSkge1xuICAgICAgICAgICAgcmVtb3ZlJDYobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgaXNSb290RnJvbUVsZW1lbnQgPSByb290ID0+IGN1ciA9PiBlcShyb290LCBjdXIpO1xuICAgIGNvbnN0IGdldFRhYmxlQ2VsbHMgPSB0YWJsZSA9PiBkZXNjZW5kYW50cyh0YWJsZSwgJ3RkLHRoJyk7XG4gICAgY29uc3QgZ2V0VGFibGVEZXRhaWxzRnJvbVJhbmdlID0gKHJuZywgaXNSb290KSA9PiB7XG4gICAgICBjb25zdCBnZXRUYWJsZSA9IG5vZGUgPT4gZ2V0Q2xvc2VzdFRhYmxlKFN1Z2FyRWxlbWVudC5mcm9tRG9tKG5vZGUpLCBpc1Jvb3QpO1xuICAgICAgY29uc3Qgc3RhcnRUYWJsZSA9IGdldFRhYmxlKHJuZy5zdGFydENvbnRhaW5lcik7XG4gICAgICBjb25zdCBlbmRUYWJsZSA9IGdldFRhYmxlKHJuZy5lbmRDb250YWluZXIpO1xuICAgICAgY29uc3QgaXNTdGFydEluVGFibGUgPSBzdGFydFRhYmxlLmlzU29tZSgpO1xuICAgICAgY29uc3QgaXNFbmRJblRhYmxlID0gZW5kVGFibGUuaXNTb21lKCk7XG4gICAgICBjb25zdCBpc1NhbWVUYWJsZSA9IGxpZnQyKHN0YXJ0VGFibGUsIGVuZFRhYmxlLCBlcSkuZ2V0T3IoZmFsc2UpO1xuICAgICAgY29uc3QgaXNNdWx0aVRhYmxlID0gIWlzU2FtZVRhYmxlICYmIGlzU3RhcnRJblRhYmxlICYmIGlzRW5kSW5UYWJsZTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0VGFibGUsXG4gICAgICAgIGVuZFRhYmxlLFxuICAgICAgICBpc1N0YXJ0SW5UYWJsZSxcbiAgICAgICAgaXNFbmRJblRhYmxlLFxuICAgICAgICBpc1NhbWVUYWJsZSxcbiAgICAgICAgaXNNdWx0aVRhYmxlXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCB0YWJsZUNlbGxSbmcgPSAoc3RhcnQsIGVuZCkgPT4gKHtcbiAgICAgIHN0YXJ0LFxuICAgICAgZW5kXG4gICAgfSk7XG4gICAgY29uc3QgdGFibGVTZWxlY3Rpb24gPSAocm5nLCB0YWJsZSwgY2VsbHMpID0+ICh7XG4gICAgICBybmcsXG4gICAgICB0YWJsZSxcbiAgICAgIGNlbGxzXG4gICAgfSk7XG4gICAgY29uc3QgZGVsZXRlQWN0aW9uID0gQWR0LmdlbmVyYXRlKFtcbiAgICAgIHtcbiAgICAgICAgc2luZ2xlQ2VsbFRhYmxlOiBbXG4gICAgICAgICAgJ3JuZycsXG4gICAgICAgICAgJ2NlbGwnXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7IGZ1bGxUYWJsZTogWyd0YWJsZSddIH0sXG4gICAgICB7XG4gICAgICAgIHBhcnRpYWxUYWJsZTogW1xuICAgICAgICAgICdjZWxscycsXG4gICAgICAgICAgJ291dHNpZGVEZXRhaWxzJ1xuICAgICAgICBdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBtdWx0aVRhYmxlOiBbXG4gICAgICAgICAgJ3N0YXJ0VGFibGVDZWxscycsXG4gICAgICAgICAgJ2VuZFRhYmxlQ2VsbHMnLFxuICAgICAgICAgICdiZXR3ZWVuUm5nJ1xuICAgICAgICBdXG4gICAgICB9XG4gICAgXSk7XG4gICAgY29uc3QgZ2V0Q2xvc2VzdENlbGwkMSA9IChjb250YWluZXIsIGlzUm9vdCkgPT4gY2xvc2VzdCQzKFN1Z2FyRWxlbWVudC5mcm9tRG9tKGNvbnRhaW5lciksICd0ZCx0aCcsIGlzUm9vdCk7XG4gICAgY29uc3QgaXNFeHBhbmRlZENlbGxSbmcgPSBjZWxsUm5nID0+ICFlcShjZWxsUm5nLnN0YXJ0LCBjZWxsUm5nLmVuZCk7XG4gICAgY29uc3QgZ2V0VGFibGVGcm9tQ2VsbFJuZyA9IChjZWxsUm5nLCBpc1Jvb3QpID0+IGdldENsb3Nlc3RUYWJsZShjZWxsUm5nLnN0YXJ0LCBpc1Jvb3QpLmJpbmQoc3RhcnRQYXJlbnRUYWJsZSA9PiBnZXRDbG9zZXN0VGFibGUoY2VsbFJuZy5lbmQsIGlzUm9vdCkuYmluZChlbmRQYXJlbnRUYWJsZSA9PiBzb21lSWYoZXEoc3RhcnRQYXJlbnRUYWJsZSwgZW5kUGFyZW50VGFibGUpLCBzdGFydFBhcmVudFRhYmxlKSkpO1xuICAgIGNvbnN0IGlzU2luZ2xlQ2VsbFRhYmxlID0gKGNlbGxSbmcsIGlzUm9vdCkgPT4gIWlzRXhwYW5kZWRDZWxsUm5nKGNlbGxSbmcpICYmIGdldFRhYmxlRnJvbUNlbGxSbmcoY2VsbFJuZywgaXNSb290KS5leGlzdHModGFibGUgPT4ge1xuICAgICAgY29uc3Qgcm93cyA9IHRhYmxlLmRvbS5yb3dzO1xuICAgICAgcmV0dXJuIHJvd3MubGVuZ3RoID09PSAxICYmIHJvd3NbMF0uY2VsbHMubGVuZ3RoID09PSAxO1xuICAgIH0pO1xuICAgIGNvbnN0IGdldENlbGxSbmcgPSAocm5nLCBpc1Jvb3QpID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0Q2VsbCA9IGdldENsb3Nlc3RDZWxsJDEocm5nLnN0YXJ0Q29udGFpbmVyLCBpc1Jvb3QpO1xuICAgICAgY29uc3QgZW5kQ2VsbCA9IGdldENsb3Nlc3RDZWxsJDEocm5nLmVuZENvbnRhaW5lciwgaXNSb290KTtcbiAgICAgIHJldHVybiBsaWZ0MihzdGFydENlbGwsIGVuZENlbGwsIHRhYmxlQ2VsbFJuZyk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRDZWxsUmFuZ2VGcm9tU3RhcnRUYWJsZSA9IGlzUm9vdCA9PiBzdGFydENlbGwgPT4gZ2V0Q2xvc2VzdFRhYmxlKHN0YXJ0Q2VsbCwgaXNSb290KS5iaW5kKHRhYmxlID0+IGxhc3QkMyhnZXRUYWJsZUNlbGxzKHRhYmxlKSkubWFwKGVuZENlbGwgPT4gdGFibGVDZWxsUm5nKHN0YXJ0Q2VsbCwgZW5kQ2VsbCkpKTtcbiAgICBjb25zdCBnZXRDZWxsUmFuZ2VGcm9tRW5kVGFibGUgPSBpc1Jvb3QgPT4gZW5kQ2VsbCA9PiBnZXRDbG9zZXN0VGFibGUoZW5kQ2VsbCwgaXNSb290KS5iaW5kKHRhYmxlID0+IGhlYWQoZ2V0VGFibGVDZWxscyh0YWJsZSkpLm1hcChzdGFydENlbGwgPT4gdGFibGVDZWxsUm5nKHN0YXJ0Q2VsbCwgZW5kQ2VsbCkpKTtcbiAgICBjb25zdCBnZXRUYWJsZVNlbGVjdGlvbkZyb21DZWxsUm5nID0gaXNSb290ID0+IGNlbGxSbmcgPT4gZ2V0VGFibGVGcm9tQ2VsbFJuZyhjZWxsUm5nLCBpc1Jvb3QpLm1hcCh0YWJsZSA9PiB0YWJsZVNlbGVjdGlvbihjZWxsUm5nLCB0YWJsZSwgZ2V0VGFibGVDZWxscyh0YWJsZSkpKTtcbiAgICBjb25zdCBnZXRUYWJsZVNlbGVjdGlvbnMgPSAoY2VsbFJuZywgc2VsZWN0aW9uRGV0YWlscywgcm5nLCBpc1Jvb3QpID0+IHtcbiAgICAgIGlmIChybmcuY29sbGFwc2VkIHx8ICFjZWxsUm5nLmZvcmFsbChpc0V4cGFuZGVkQ2VsbFJuZykpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH0gZWxzZSBpZiAoc2VsZWN0aW9uRGV0YWlscy5pc1NhbWVUYWJsZSkge1xuICAgICAgICBjb25zdCBzYW1lVGFibGVTZWxlY3Rpb24gPSBjZWxsUm5nLmJpbmQoZ2V0VGFibGVTZWxlY3Rpb25Gcm9tQ2VsbFJuZyhpc1Jvb3QpKTtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoe1xuICAgICAgICAgIHN0YXJ0OiBzYW1lVGFibGVTZWxlY3Rpb24sXG4gICAgICAgICAgZW5kOiBzYW1lVGFibGVTZWxlY3Rpb25cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzdGFydENlbGwgPSBnZXRDbG9zZXN0Q2VsbCQxKHJuZy5zdGFydENvbnRhaW5lciwgaXNSb290KTtcbiAgICAgICAgY29uc3QgZW5kQ2VsbCA9IGdldENsb3Nlc3RDZWxsJDEocm5nLmVuZENvbnRhaW5lciwgaXNSb290KTtcbiAgICAgICAgY29uc3Qgc3RhcnRUYWJsZVNlbGVjdGlvbiA9IHN0YXJ0Q2VsbC5iaW5kKGdldENlbGxSYW5nZUZyb21TdGFydFRhYmxlKGlzUm9vdCkpLmJpbmQoZ2V0VGFibGVTZWxlY3Rpb25Gcm9tQ2VsbFJuZyhpc1Jvb3QpKTtcbiAgICAgICAgY29uc3QgZW5kVGFibGVTZWxlY3Rpb24gPSBlbmRDZWxsLmJpbmQoZ2V0Q2VsbFJhbmdlRnJvbUVuZFRhYmxlKGlzUm9vdCkpLmJpbmQoZ2V0VGFibGVTZWxlY3Rpb25Gcm9tQ2VsbFJuZyhpc1Jvb3QpKTtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoe1xuICAgICAgICAgIHN0YXJ0OiBzdGFydFRhYmxlU2VsZWN0aW9uLFxuICAgICAgICAgIGVuZDogZW5kVGFibGVTZWxlY3Rpb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBnZXRDZWxsSW5kZXggPSAoY2VsbHMsIGNlbGwpID0+IGZpbmRJbmRleCQyKGNlbGxzLCB4ID0+IGVxKHgsIGNlbGwpKTtcbiAgICBjb25zdCBnZXRTZWxlY3RlZENlbGxzID0gdGFibGVTZWxlY3Rpb24gPT4gbGlmdDIoZ2V0Q2VsbEluZGV4KHRhYmxlU2VsZWN0aW9uLmNlbGxzLCB0YWJsZVNlbGVjdGlvbi5ybmcuc3RhcnQpLCBnZXRDZWxsSW5kZXgodGFibGVTZWxlY3Rpb24uY2VsbHMsIHRhYmxlU2VsZWN0aW9uLnJuZy5lbmQpLCAoc3RhcnRJbmRleCwgZW5kSW5kZXgpID0+IHRhYmxlU2VsZWN0aW9uLmNlbGxzLnNsaWNlKHN0YXJ0SW5kZXgsIGVuZEluZGV4ICsgMSkpO1xuICAgIGNvbnN0IGlzU2luZ2xlQ2VsbFRhYmxlQ29udGVudFNlbGVjdGVkID0gKG9wdENlbGxSbmcsIHJuZywgaXNSb290KSA9PiBvcHRDZWxsUm5nLmV4aXN0cyhjZWxsUm5nID0+IGlzU2luZ2xlQ2VsbFRhYmxlKGNlbGxSbmcsIGlzUm9vdCkgJiYgaGFzQWxsQ29udGVudHNTZWxlY3RlZChjZWxsUm5nLnN0YXJ0LCBybmcpKTtcbiAgICBjb25zdCB1bnNlbGVjdENlbGxzID0gKHJuZywgc2VsZWN0aW9uRGV0YWlscykgPT4ge1xuICAgICAgY29uc3Qge3N0YXJ0VGFibGUsIGVuZFRhYmxlfSA9IHNlbGVjdGlvbkRldGFpbHM7XG4gICAgICBjb25zdCBvdGhlckNvbnRlbnRSbmcgPSBybmcuY2xvbmVSYW5nZSgpO1xuICAgICAgc3RhcnRUYWJsZS5lYWNoKHRhYmxlID0+IG90aGVyQ29udGVudFJuZy5zZXRTdGFydEFmdGVyKHRhYmxlLmRvbSkpO1xuICAgICAgZW5kVGFibGUuZWFjaCh0YWJsZSA9PiBvdGhlckNvbnRlbnRSbmcuc2V0RW5kQmVmb3JlKHRhYmxlLmRvbSkpO1xuICAgICAgcmV0dXJuIG90aGVyQ29udGVudFJuZztcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZVNpbmdsZVRhYmxlID0gKGNlbGxSbmcsIHNlbGVjdGlvbkRldGFpbHMsIHJuZywgaXNSb290KSA9PiBnZXRUYWJsZVNlbGVjdGlvbnMoY2VsbFJuZywgc2VsZWN0aW9uRGV0YWlscywgcm5nLCBpc1Jvb3QpLmJpbmQoKHtzdGFydCwgZW5kfSkgPT4gc3RhcnQub3IoZW5kKSkuYmluZCh0YWJsZVNlbGVjdGlvbiA9PiB7XG4gICAgICBjb25zdCB7aXNTYW1lVGFibGV9ID0gc2VsZWN0aW9uRGV0YWlscztcbiAgICAgIGNvbnN0IHNlbGVjdGVkQ2VsbHMgPSBnZXRTZWxlY3RlZENlbGxzKHRhYmxlU2VsZWN0aW9uKS5nZXRPcihbXSk7XG4gICAgICBpZiAoaXNTYW1lVGFibGUgJiYgdGFibGVTZWxlY3Rpb24uY2VsbHMubGVuZ3RoID09PSBzZWxlY3RlZENlbGxzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShkZWxldGVBY3Rpb24uZnVsbFRhYmxlKHRhYmxlU2VsZWN0aW9uLnRhYmxlKSk7XG4gICAgICB9IGVsc2UgaWYgKHNlbGVjdGVkQ2VsbHMubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoaXNTYW1lVGFibGUpIHtcbiAgICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShkZWxldGVBY3Rpb24ucGFydGlhbFRhYmxlKHNlbGVjdGVkQ2VsbHMsIE9wdGlvbmFsLm5vbmUoKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IG90aGVyQ29udGVudFJuZyA9IHVuc2VsZWN0Q2VsbHMocm5nLCBzZWxlY3Rpb25EZXRhaWxzKTtcbiAgICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShkZWxldGVBY3Rpb24ucGFydGlhbFRhYmxlKHNlbGVjdGVkQ2VsbHMsIE9wdGlvbmFsLnNvbWUoe1xuICAgICAgICAgICAgLi4uc2VsZWN0aW9uRGV0YWlscyxcbiAgICAgICAgICAgIHJuZzogb3RoZXJDb250ZW50Um5nXG4gICAgICAgICAgfSkpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBoYW5kbGVNdWx0aVRhYmxlID0gKGNlbGxSbmcsIHNlbGVjdGlvbkRldGFpbHMsIHJuZywgaXNSb290KSA9PiBnZXRUYWJsZVNlbGVjdGlvbnMoY2VsbFJuZywgc2VsZWN0aW9uRGV0YWlscywgcm5nLCBpc1Jvb3QpLmJpbmQoKHtzdGFydCwgZW5kfSkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnRUYWJsZVNlbGVjdGVkQ2VsbHMgPSBzdGFydC5iaW5kKGdldFNlbGVjdGVkQ2VsbHMpLmdldE9yKFtdKTtcbiAgICAgIGNvbnN0IGVuZFRhYmxlU2VsZWN0ZWRDZWxscyA9IGVuZC5iaW5kKGdldFNlbGVjdGVkQ2VsbHMpLmdldE9yKFtdKTtcbiAgICAgIGlmIChzdGFydFRhYmxlU2VsZWN0ZWRDZWxscy5sZW5ndGggPiAwICYmIGVuZFRhYmxlU2VsZWN0ZWRDZWxscy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IG90aGVyQ29udGVudFJuZyA9IHVuc2VsZWN0Q2VsbHMocm5nLCBzZWxlY3Rpb25EZXRhaWxzKTtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoZGVsZXRlQWN0aW9uLm11bHRpVGFibGUoc3RhcnRUYWJsZVNlbGVjdGVkQ2VsbHMsIGVuZFRhYmxlU2VsZWN0ZWRDZWxscywgb3RoZXJDb250ZW50Um5nKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGdldEFjdGlvbkZyb21SYW5nZSA9IChyb290LCBybmcpID0+IHtcbiAgICAgIGNvbnN0IGlzUm9vdCA9IGlzUm9vdEZyb21FbGVtZW50KHJvb3QpO1xuICAgICAgY29uc3Qgb3B0Q2VsbFJuZyA9IGdldENlbGxSbmcocm5nLCBpc1Jvb3QpO1xuICAgICAgY29uc3Qgc2VsZWN0aW9uRGV0YWlscyA9IGdldFRhYmxlRGV0YWlsc0Zyb21SYW5nZShybmcsIGlzUm9vdCk7XG4gICAgICBpZiAoaXNTaW5nbGVDZWxsVGFibGVDb250ZW50U2VsZWN0ZWQob3B0Q2VsbFJuZywgcm5nLCBpc1Jvb3QpKSB7XG4gICAgICAgIHJldHVybiBvcHRDZWxsUm5nLm1hcChjZWxsUm5nID0+IGRlbGV0ZUFjdGlvbi5zaW5nbGVDZWxsVGFibGUocm5nLCBjZWxsUm5nLnN0YXJ0KSk7XG4gICAgICB9IGVsc2UgaWYgKHNlbGVjdGlvbkRldGFpbHMuaXNNdWx0aVRhYmxlKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVNdWx0aVRhYmxlKG9wdENlbGxSbmcsIHNlbGVjdGlvbkRldGFpbHMsIHJuZywgaXNSb290KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVTaW5nbGVUYWJsZShvcHRDZWxsUm5nLCBzZWxlY3Rpb25EZXRhaWxzLCBybmcsIGlzUm9vdCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGNsZWFuQ2VsbHMgPSBjZWxscyA9PiBlYWNoJGUoY2VsbHMsIGNlbGwgPT4ge1xuICAgICAgcmVtb3ZlJGIoY2VsbCwgJ2NvbnRlbnRlZGl0YWJsZScpO1xuICAgICAgZmlsbFdpdGhQYWRkaW5nQnIoY2VsbCk7XG4gICAgfSk7XG4gICAgY29uc3QgZ2V0T3V0c2lkZUJsb2NrID0gKGVkaXRvciwgY29udGFpbmVyKSA9PiBPcHRpb25hbC5mcm9tKGVkaXRvci5kb20uZ2V0UGFyZW50KGNvbnRhaW5lciwgZWRpdG9yLmRvbS5pc0Jsb2NrKSkubWFwKFN1Z2FyRWxlbWVudC5mcm9tRG9tKTtcbiAgICBjb25zdCBoYW5kbGVFbXB0eUJsb2NrID0gKGVkaXRvciwgc3RhcnRJblRhYmxlLCBlbXB0eUJsb2NrKSA9PiB7XG4gICAgICBlbXB0eUJsb2NrLmVhY2goYmxvY2sgPT4ge1xuICAgICAgICBpZiAoc3RhcnRJblRhYmxlKSB7XG4gICAgICAgICAgcmVtb3ZlJDYoYmxvY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpbGxXaXRoUGFkZGluZ0JyKGJsb2NrKTtcbiAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldEN1cnNvckxvY2F0aW9uKGJsb2NrLmRvbSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgZGVsZXRlQ29udGVudEluc2lkZUNlbGwgPSAoZWRpdG9yLCBjZWxsLCBybmcsIGlzRmlyc3RDZWxsSW5TZWxlY3Rpb24pID0+IHtcbiAgICAgIGNvbnN0IGluc2lkZVRhYmxlUm5nID0gcm5nLmNsb25lUmFuZ2UoKTtcbiAgICAgIGlmIChpc0ZpcnN0Q2VsbEluU2VsZWN0aW9uKSB7XG4gICAgICAgIGluc2lkZVRhYmxlUm5nLnNldFN0YXJ0KHJuZy5zdGFydENvbnRhaW5lciwgcm5nLnN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgaW5zaWRlVGFibGVSbmcuc2V0RW5kQWZ0ZXIoY2VsbC5kb20ubGFzdENoaWxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc2lkZVRhYmxlUm5nLnNldFN0YXJ0QmVmb3JlKGNlbGwuZG9tLmZpcnN0Q2hpbGQpO1xuICAgICAgICBpbnNpZGVUYWJsZVJuZy5zZXRFbmQocm5nLmVuZENvbnRhaW5lciwgcm5nLmVuZE9mZnNldCk7XG4gICAgICB9XG4gICAgICBkZWxldGVDZWxsQ29udGVudHMoZWRpdG9yLCBpbnNpZGVUYWJsZVJuZywgY2VsbCwgZmFsc2UpLmVhY2goYWN0aW9uID0+IGFjdGlvbigpKTtcbiAgICB9O1xuICAgIGNvbnN0IGNvbGxhcHNlQW5kUmVzdG9yZUNlbGxTZWxlY3Rpb24gPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0ZWRDZWxscyA9IGdldENlbGxzRnJvbUVkaXRvcihlZGl0b3IpO1xuICAgICAgY29uc3Qgc2VsZWN0ZWROb2RlID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZWRpdG9yLnNlbGVjdGlvbi5nZXROb2RlKCkpO1xuICAgICAgaWYgKGlzVGFibGVDZWxsJDMoc2VsZWN0ZWROb2RlLmRvbSkgJiYgaXNFbXB0eSQyKHNlbGVjdGVkTm9kZSkpIHtcbiAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRDdXJzb3JMb2NhdGlvbihzZWxlY3RlZE5vZGUuZG9tLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkaXRvci5zZWxlY3Rpb24uY29sbGFwc2UodHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZWN0ZWRDZWxscy5sZW5ndGggPiAxICYmIGV4aXN0cyhzZWxlY3RlZENlbGxzLCBjZWxsID0+IGVxKGNlbGwsIHNlbGVjdGVkTm9kZSkpKSB7XG4gICAgICAgIHNldCQzKHNlbGVjdGVkTm9kZSwgJ2RhdGEtbWNlLXNlbGVjdGVkJywgJzEnKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGVtcHR5U2luZ2xlVGFibGVDZWxscyA9IChlZGl0b3IsIGNlbGxzLCBvdXRzaWRlRGV0YWlscykgPT4gT3B0aW9uYWwuc29tZSgoKSA9PiB7XG4gICAgICBjb25zdCBlZGl0b3JSbmcgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgY29uc3QgY2VsbHNUb0NsZWFuID0gb3V0c2lkZURldGFpbHMuYmluZCgoe3JuZywgaXNTdGFydEluVGFibGV9KSA9PiB7XG4gICAgICAgIGNvbnN0IG91dHNpZGVCbG9jayA9IGdldE91dHNpZGVCbG9jayhlZGl0b3IsIGlzU3RhcnRJblRhYmxlID8gcm5nLmVuZENvbnRhaW5lciA6IHJuZy5zdGFydENvbnRhaW5lcik7XG4gICAgICAgIHJuZy5kZWxldGVDb250ZW50cygpO1xuICAgICAgICBoYW5kbGVFbXB0eUJsb2NrKGVkaXRvciwgaXNTdGFydEluVGFibGUsIG91dHNpZGVCbG9jay5maWx0ZXIoaXNFbXB0eSQyKSk7XG4gICAgICAgIGNvbnN0IGVuZFBvaW50Q2VsbCA9IGlzU3RhcnRJblRhYmxlID8gY2VsbHNbMF0gOiBjZWxsc1tjZWxscy5sZW5ndGggLSAxXTtcbiAgICAgICAgZGVsZXRlQ29udGVudEluc2lkZUNlbGwoZWRpdG9yLCBlbmRQb2ludENlbGwsIGVkaXRvclJuZywgaXNTdGFydEluVGFibGUpO1xuICAgICAgICBpZiAoIWlzRW1wdHkkMihlbmRQb2ludENlbGwpKSB7XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoaXNTdGFydEluVGFibGUgPyBjZWxscy5zbGljZSgxKSA6IGNlbGxzLnNsaWNlKDAsIC0xKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgICAgfVxuICAgICAgfSkuZ2V0T3IoY2VsbHMpO1xuICAgICAgY2xlYW5DZWxscyhjZWxsc1RvQ2xlYW4pO1xuICAgICAgY29sbGFwc2VBbmRSZXN0b3JlQ2VsbFNlbGVjdGlvbihlZGl0b3IpO1xuICAgIH0pO1xuICAgIGNvbnN0IGVtcHR5TXVsdGlUYWJsZUNlbGxzID0gKGVkaXRvciwgc3RhcnRUYWJsZUNlbGxzLCBlbmRUYWJsZUNlbGxzLCBiZXR3ZWVuUm5nKSA9PiBPcHRpb25hbC5zb21lKCgpID0+IHtcbiAgICAgIGNvbnN0IHJuZyA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICBjb25zdCBzdGFydENlbGwgPSBzdGFydFRhYmxlQ2VsbHNbMF07XG4gICAgICBjb25zdCBlbmRDZWxsID0gZW5kVGFibGVDZWxsc1tlbmRUYWJsZUNlbGxzLmxlbmd0aCAtIDFdO1xuICAgICAgZGVsZXRlQ29udGVudEluc2lkZUNlbGwoZWRpdG9yLCBzdGFydENlbGwsIHJuZywgdHJ1ZSk7XG4gICAgICBkZWxldGVDb250ZW50SW5zaWRlQ2VsbChlZGl0b3IsIGVuZENlbGwsIHJuZywgZmFsc2UpO1xuICAgICAgY29uc3Qgc3RhcnRUYWJsZUNlbGxzVG9DbGVhbiA9IGlzRW1wdHkkMihzdGFydENlbGwpID8gc3RhcnRUYWJsZUNlbGxzIDogc3RhcnRUYWJsZUNlbGxzLnNsaWNlKDEpO1xuICAgICAgY29uc3QgZW5kVGFibGVDZWxsc1RvQ2xlYW4gPSBpc0VtcHR5JDIoZW5kQ2VsbCkgPyBlbmRUYWJsZUNlbGxzIDogZW5kVGFibGVDZWxscy5zbGljZSgwLCAtMSk7XG4gICAgICBjbGVhbkNlbGxzKHN0YXJ0VGFibGVDZWxsc1RvQ2xlYW4uY29uY2F0KGVuZFRhYmxlQ2VsbHNUb0NsZWFuKSk7XG4gICAgICBiZXR3ZWVuUm5nLmRlbGV0ZUNvbnRlbnRzKCk7XG4gICAgICBjb2xsYXBzZUFuZFJlc3RvcmVDZWxsU2VsZWN0aW9uKGVkaXRvcik7XG4gICAgfSk7XG4gICAgY29uc3QgZGVsZXRlQ2VsbENvbnRlbnRzID0gKGVkaXRvciwgcm5nLCBjZWxsLCBtb3ZlU2VsZWN0aW9uID0gdHJ1ZSkgPT4gT3B0aW9uYWwuc29tZSgoKSA9PiB7XG4gICAgICBkZWxldGVSYW5nZUNvbnRlbnRzKGVkaXRvciwgcm5nLCBjZWxsLCBtb3ZlU2VsZWN0aW9uKTtcbiAgICB9KTtcbiAgICBjb25zdCBkZWxldGVUYWJsZUVsZW1lbnQgPSAoZWRpdG9yLCB0YWJsZSkgPT4gT3B0aW9uYWwuc29tZSgoKSA9PiBkZWxldGVFbGVtZW50JDIoZWRpdG9yLCBmYWxzZSwgdGFibGUpKTtcbiAgICBjb25zdCBkZWxldGVDZWxsUmFuZ2UgPSAoZWRpdG9yLCByb290RWxtLCBybmcpID0+IGdldEFjdGlvbkZyb21SYW5nZShyb290RWxtLCBybmcpLmJpbmQoYWN0aW9uID0+IGFjdGlvbi5mb2xkKGN1cnJ5KGRlbGV0ZUNlbGxDb250ZW50cywgZWRpdG9yKSwgY3VycnkoZGVsZXRlVGFibGVFbGVtZW50LCBlZGl0b3IpLCBjdXJyeShlbXB0eVNpbmdsZVRhYmxlQ2VsbHMsIGVkaXRvciksIGN1cnJ5KGVtcHR5TXVsdGlUYWJsZUNlbGxzLCBlZGl0b3IpKSk7XG4gICAgY29uc3QgZGVsZXRlQ2FwdGlvblJhbmdlID0gKGVkaXRvciwgY2FwdGlvbikgPT4gZW1wdHlFbGVtZW50KGVkaXRvciwgY2FwdGlvbik7XG4gICAgY29uc3QgZGVsZXRlVGFibGVSYW5nZSA9IChlZGl0b3IsIHJvb3RFbG0sIHJuZywgc3RhcnRFbG0pID0+IGdldFBhcmVudENhcHRpb24ocm9vdEVsbSwgc3RhcnRFbG0pLmZvbGQoKCkgPT4gZGVsZXRlQ2VsbFJhbmdlKGVkaXRvciwgcm9vdEVsbSwgcm5nKSwgY2FwdGlvbiA9PiBkZWxldGVDYXB0aW9uUmFuZ2UoZWRpdG9yLCBjYXB0aW9uKSk7XG4gICAgY29uc3QgZGVsZXRlUmFuZ2UkMyA9IChlZGl0b3IsIHN0YXJ0RWxtLCBzZWxlY3RlZENlbGxzKSA9PiB7XG4gICAgICBjb25zdCByb290Tm9kZSA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRCb2R5KCkpO1xuICAgICAgY29uc3Qgcm5nID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgIHJldHVybiBzZWxlY3RlZENlbGxzLmxlbmd0aCAhPT0gMCA/IGVtcHR5U2luZ2xlVGFibGVDZWxscyhlZGl0b3IsIHNlbGVjdGVkQ2VsbHMsIE9wdGlvbmFsLm5vbmUoKSkgOiBkZWxldGVUYWJsZVJhbmdlKGVkaXRvciwgcm9vdE5vZGUsIHJuZywgc3RhcnRFbG0pO1xuICAgIH07XG4gICAgY29uc3QgZ2V0UGFyZW50Q2VsbCA9IChyb290RWxtLCBlbG0pID0+IGZpbmQkMihwYXJlbnRzQW5kU2VsZihlbG0sIHJvb3RFbG0pLCBpc1RhYmxlQ2VsbCQyKTtcbiAgICBjb25zdCBnZXRQYXJlbnRDYXB0aW9uID0gKHJvb3RFbG0sIGVsbSkgPT4gZmluZCQyKHBhcmVudHNBbmRTZWxmKGVsbSwgcm9vdEVsbSksIGlzVGFnKCdjYXB0aW9uJykpO1xuICAgIGNvbnN0IGRlbGV0ZUJldHdlZW5DZWxscyA9IChlZGl0b3IsIHJvb3RFbG0sIGZvcndhcmQsIGZyb21DZWxsLCBmcm9tKSA9PiBuYXZpZ2F0ZShmb3J3YXJkLCBlZGl0b3IuZ2V0Qm9keSgpLCBmcm9tKS5iaW5kKHRvID0+IGdldFBhcmVudENlbGwocm9vdEVsbSwgU3VnYXJFbGVtZW50LmZyb21Eb20odG8uZ2V0Tm9kZSgpKSkuYmluZCh0b0NlbGwgPT4gZXEodG9DZWxsLCBmcm9tQ2VsbCkgPyBPcHRpb25hbC5ub25lKCkgOiBPcHRpb25hbC5zb21lKG5vb3ApKSk7XG4gICAgY29uc3QgZW1wdHlFbGVtZW50ID0gKGVkaXRvciwgZWxtKSA9PiBPcHRpb25hbC5zb21lKCgpID0+IHtcbiAgICAgIGZpbGxXaXRoUGFkZGluZ0JyKGVsbSk7XG4gICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldEN1cnNvckxvY2F0aW9uKGVsbS5kb20sIDApO1xuICAgIH0pO1xuICAgIGNvbnN0IGlzRGVsZXRlT2ZMYXN0Q2hhclBvcyA9IChmcm9tQ2FwdGlvbiwgZm9yd2FyZCwgZnJvbSwgdG8pID0+IGZpcnN0UG9zaXRpb25Jbihmcm9tQ2FwdGlvbi5kb20pLmJpbmQoZmlyc3QgPT4gbGFzdFBvc2l0aW9uSW4oZnJvbUNhcHRpb24uZG9tKS5tYXAobGFzdCA9PiBmb3J3YXJkID8gZnJvbS5pc0VxdWFsKGZpcnN0KSAmJiB0by5pc0VxdWFsKGxhc3QpIDogZnJvbS5pc0VxdWFsKGxhc3QpICYmIHRvLmlzRXF1YWwoZmlyc3QpKSkuZ2V0T3IodHJ1ZSk7XG4gICAgY29uc3QgZW1wdHlDYXJldENhcHRpb24gPSAoZWRpdG9yLCBlbG0pID0+IGVtcHR5RWxlbWVudChlZGl0b3IsIGVsbSk7XG4gICAgY29uc3QgdmFsaWRhdGVDYXJldENhcHRpb24gPSAocm9vdEVsbSwgZnJvbUNhcHRpb24sIHRvKSA9PiBnZXRQYXJlbnRDYXB0aW9uKHJvb3RFbG0sIFN1Z2FyRWxlbWVudC5mcm9tRG9tKHRvLmdldE5vZGUoKSkpLmZvbGQoKCkgPT4gT3B0aW9uYWwuc29tZShub29wKSwgdG9DYXB0aW9uID0+IHNvbWVJZighZXEodG9DYXB0aW9uLCBmcm9tQ2FwdGlvbiksIG5vb3ApKTtcbiAgICBjb25zdCBkZWxldGVDYXJldEluc2lkZUNhcHRpb24gPSAoZWRpdG9yLCByb290RWxtLCBmb3J3YXJkLCBmcm9tQ2FwdGlvbiwgZnJvbSkgPT4gbmF2aWdhdGUoZm9yd2FyZCwgZWRpdG9yLmdldEJvZHkoKSwgZnJvbSkuZm9sZCgoKSA9PiBPcHRpb25hbC5zb21lKG5vb3ApLCB0byA9PiBpc0RlbGV0ZU9mTGFzdENoYXJQb3MoZnJvbUNhcHRpb24sIGZvcndhcmQsIGZyb20sIHRvKSA/IGVtcHR5Q2FyZXRDYXB0aW9uKGVkaXRvciwgZnJvbUNhcHRpb24pIDogdmFsaWRhdGVDYXJldENhcHRpb24ocm9vdEVsbSwgZnJvbUNhcHRpb24sIHRvKSk7XG4gICAgY29uc3QgZGVsZXRlQ2FyZXRDZWxscyA9IChlZGl0b3IsIGZvcndhcmQsIHJvb3RFbG0sIHN0YXJ0RWxtKSA9PiB7XG4gICAgICBjb25zdCBmcm9tID0gQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpKTtcbiAgICAgIHJldHVybiBnZXRQYXJlbnRDZWxsKHJvb3RFbG0sIHN0YXJ0RWxtKS5iaW5kKGZyb21DZWxsID0+IGlzRW1wdHkkMihmcm9tQ2VsbCkgPyBlbXB0eUVsZW1lbnQoZWRpdG9yLCBmcm9tQ2VsbCkgOiBkZWxldGVCZXR3ZWVuQ2VsbHMoZWRpdG9yLCByb290RWxtLCBmb3J3YXJkLCBmcm9tQ2VsbCwgZnJvbSkpO1xuICAgIH07XG4gICAgY29uc3QgZGVsZXRlQ2FyZXRDYXB0aW9uID0gKGVkaXRvciwgZm9yd2FyZCwgcm9vdEVsbSwgZnJvbUNhcHRpb24pID0+IHtcbiAgICAgIGNvbnN0IGZyb20gPSBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCkpO1xuICAgICAgcmV0dXJuIGlzRW1wdHkkMihmcm9tQ2FwdGlvbikgPyBlbXB0eUVsZW1lbnQoZWRpdG9yLCBmcm9tQ2FwdGlvbikgOiBkZWxldGVDYXJldEluc2lkZUNhcHRpb24oZWRpdG9yLCByb290RWxtLCBmb3J3YXJkLCBmcm9tQ2FwdGlvbiwgZnJvbSk7XG4gICAgfTtcbiAgICBjb25zdCBpc05lYXJUYWJsZSA9IChmb3J3YXJkLCBwb3MpID0+IGZvcndhcmQgPyBpc0JlZm9yZVRhYmxlKHBvcykgOiBpc0FmdGVyVGFibGUocG9zKTtcbiAgICBjb25zdCBpc0JlZm9yZU9yQWZ0ZXJUYWJsZSA9IChlZGl0b3IsIGZvcndhcmQpID0+IHtcbiAgICAgIGNvbnN0IGZyb21Qb3MgPSBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCkpO1xuICAgICAgcmV0dXJuIGlzTmVhclRhYmxlKGZvcndhcmQsIGZyb21Qb3MpIHx8IGZyb21Qb3NpdGlvbihmb3J3YXJkLCBlZGl0b3IuZ2V0Qm9keSgpLCBmcm9tUG9zKS5leGlzdHMocG9zID0+IGlzTmVhclRhYmxlKGZvcndhcmQsIHBvcykpO1xuICAgIH07XG4gICAgY29uc3QgZGVsZXRlQ2FyZXQkMyA9IChlZGl0b3IsIGZvcndhcmQsIHN0YXJ0RWxtKSA9PiB7XG4gICAgICBjb25zdCByb290RWxtID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZWRpdG9yLmdldEJvZHkoKSk7XG4gICAgICByZXR1cm4gZ2V0UGFyZW50Q2FwdGlvbihyb290RWxtLCBzdGFydEVsbSkuZm9sZCgoKSA9PiBkZWxldGVDYXJldENlbGxzKGVkaXRvciwgZm9yd2FyZCwgcm9vdEVsbSwgc3RhcnRFbG0pLm9yVGh1bmsoKCkgPT4gc29tZUlmKGlzQmVmb3JlT3JBZnRlclRhYmxlKGVkaXRvciwgZm9yd2FyZCksIG5vb3ApKSwgZnJvbUNhcHRpb24gPT4gZGVsZXRlQ2FyZXRDYXB0aW9uKGVkaXRvciwgZm9yd2FyZCwgcm9vdEVsbSwgZnJvbUNhcHRpb24pKTtcbiAgICB9O1xuICAgIGNvbnN0IGJhY2tzcGFjZURlbGV0ZSQ5ID0gKGVkaXRvciwgZm9yd2FyZCkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnRFbG0gPSBTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3Iuc2VsZWN0aW9uLmdldFN0YXJ0KHRydWUpKTtcbiAgICAgIGNvbnN0IGNlbGxzID0gZ2V0Q2VsbHNGcm9tRWRpdG9yKGVkaXRvcik7XG4gICAgICByZXR1cm4gZWRpdG9yLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpICYmIGNlbGxzLmxlbmd0aCA9PT0gMCA/IGRlbGV0ZUNhcmV0JDMoZWRpdG9yLCBmb3J3YXJkLCBzdGFydEVsbSkgOiBkZWxldGVSYW5nZSQzKGVkaXRvciwgc3RhcnRFbG0sIGNlbGxzKTtcbiAgICB9O1xuXG4gICAgY29uc3QgZ2V0Q29udGVudEVkaXRhYmxlUm9vdCQxID0gKHJvb3QsIG5vZGUpID0+IHtcbiAgICAgIGxldCB0ZW1wTm9kZSA9IG5vZGU7XG4gICAgICB3aGlsZSAodGVtcE5vZGUgJiYgdGVtcE5vZGUgIT09IHJvb3QpIHtcbiAgICAgICAgaWYgKGlzQ29udGVudEVkaXRhYmxlVHJ1ZSQzKHRlbXBOb2RlKSB8fCBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJGIodGVtcE5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRlbXBOb2RlO1xuICAgICAgICB9XG4gICAgICAgIHRlbXBOb2RlID0gdGVtcE5vZGUucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBjb25zdCBpbnRlcm5hbEF0dHJpYnV0ZXNQcmVmaXhlcyA9IFtcbiAgICAgICdkYXRhLWVwaG94LScsXG4gICAgICAnZGF0YS1tY2UtJyxcbiAgICAgICdkYXRhLWFsbG95LScsXG4gICAgICAnZGF0YS1zbm9va2VyLScsXG4gICAgICAnXydcbiAgICBdO1xuICAgIGNvbnN0IGVhY2gkOSA9IFRvb2xzLmVhY2g7XG4gICAgY29uc3QgRWxlbWVudFV0aWxzID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb207XG4gICAgICBjb25zdCBpbnRlcm5hbEF0dHJpYnV0ZXMgPSBuZXcgU2V0KGVkaXRvci5zZXJpYWxpemVyLmdldFRlbXBBdHRycygpKTtcbiAgICAgIGNvbnN0IGNvbXBhcmUgPSAobm9kZTEsIG5vZGUyKSA9PiB7XG4gICAgICAgIGlmIChub2RlMS5ub2RlTmFtZSAhPT0gbm9kZTIubm9kZU5hbWUgfHwgbm9kZTEubm9kZVR5cGUgIT09IG5vZGUyLm5vZGVUeXBlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGdldEF0dHJpYnMgPSBub2RlID0+IHtcbiAgICAgICAgICBjb25zdCBhdHRyaWJzID0ge307XG4gICAgICAgICAgZWFjaCQ5KGRvbS5nZXRBdHRyaWJzKG5vZGUpLCBhdHRyID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBhdHRyLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAobmFtZSAhPT0gJ3N0eWxlJyAmJiAhaXNBdHRyaWJ1dGVJbnRlcm5hbChuYW1lKSkge1xuICAgICAgICAgICAgICBhdHRyaWJzW25hbWVdID0gZG9tLmdldEF0dHJpYihub2RlLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gYXR0cmlicztcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY29tcGFyZU9iamVjdHMgPSAob2JqMSwgb2JqMikgPT4ge1xuICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBvYmoxKSB7XG4gICAgICAgICAgICBpZiAoaGFzJDIob2JqMSwgbmFtZSkpIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBvYmoyW25hbWVdO1xuICAgICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChvYmoxW25hbWVdICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkZWxldGUgb2JqMltuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIG9iajIpIHtcbiAgICAgICAgICAgIGlmIChoYXMkMihvYmoyLCBuYW1lKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoaXNFbGVtZW50JDYobm9kZTEpICYmIGlzRWxlbWVudCQ2KG5vZGUyKSkge1xuICAgICAgICAgIGlmICghY29tcGFyZU9iamVjdHMoZ2V0QXR0cmlicyhub2RlMSksIGdldEF0dHJpYnMobm9kZTIpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWNvbXBhcmVPYmplY3RzKGRvbS5wYXJzZVN0eWxlKGRvbS5nZXRBdHRyaWIobm9kZTEsICdzdHlsZScpKSwgZG9tLnBhcnNlU3R5bGUoZG9tLmdldEF0dHJpYihub2RlMiwgJ3N0eWxlJykpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIWlzQm9va21hcmtOb2RlJDEobm9kZTEpICYmICFpc0Jvb2ttYXJrTm9kZSQxKG5vZGUyKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBpc0F0dHJpYnV0ZUludGVybmFsID0gYXR0cmlidXRlTmFtZSA9PiBleGlzdHMoaW50ZXJuYWxBdHRyaWJ1dGVzUHJlZml4ZXMsIHZhbHVlID0+IHN0YXJ0c1dpdGgoYXR0cmlidXRlTmFtZSwgdmFsdWUpKSB8fCBpbnRlcm5hbEF0dHJpYnV0ZXMuaGFzKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29tcGFyZSxcbiAgICAgICAgaXNBdHRyaWJ1dGVJbnRlcm5hbFxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgdHJhdmVyc2UgPSAocm9vdCwgZm4pID0+IHtcbiAgICAgIGxldCBub2RlID0gcm9vdDtcbiAgICAgIHdoaWxlIChub2RlID0gbm9kZS53YWxrKCkpIHtcbiAgICAgICAgZm4obm9kZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBtYXRjaE5vZGUkMSA9IChub2RlRmlsdGVycywgYXR0cmlidXRlRmlsdGVycywgbm9kZSwgbWF0Y2hlcykgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IG5vZGUubmFtZTtcbiAgICAgIGZvciAobGV0IG5pID0gMCwgbmwgPSBub2RlRmlsdGVycy5sZW5ndGg7IG5pIDwgbmw7IG5pKyspIHtcbiAgICAgICAgY29uc3QgZmlsdGVyID0gbm9kZUZpbHRlcnNbbmldO1xuICAgICAgICBpZiAoZmlsdGVyLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICBjb25zdCBtYXRjaCA9IG1hdGNoZXMubm9kZXNbbmFtZV07XG4gICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBtYXRjaC5ub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXRjaGVzLm5vZGVzW25hbWVdID0ge1xuICAgICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICAgIG5vZGVzOiBbbm9kZV1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIGZvciAobGV0IGFpID0gMCwgYWwgPSBhdHRyaWJ1dGVGaWx0ZXJzLmxlbmd0aDsgYWkgPCBhbDsgYWkrKykge1xuICAgICAgICAgIGNvbnN0IGZpbHRlciA9IGF0dHJpYnV0ZUZpbHRlcnNbYWldO1xuICAgICAgICAgIGNvbnN0IGF0dHJOYW1lID0gZmlsdGVyLm5hbWU7XG4gICAgICAgICAgaWYgKGF0dHJOYW1lIGluIG5vZGUuYXR0cmlidXRlcy5tYXApIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gbWF0Y2hlcy5hdHRyaWJ1dGVzW2F0dHJOYW1lXTtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICBtYXRjaC5ub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWF0Y2hlcy5hdHRyaWJ1dGVzW2F0dHJOYW1lXSA9IHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICAgICAgbm9kZXM6IFtub2RlXVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZmluZE1hdGNoaW5nTm9kZXMgPSAobm9kZUZpbHRlcnMsIGF0dHJpYnV0ZUZpbHRlcnMsIG5vZGUpID0+IHtcbiAgICAgIGNvbnN0IG1hdGNoZXMgPSB7XG4gICAgICAgIG5vZGVzOiB7fSxcbiAgICAgICAgYXR0cmlidXRlczoge31cbiAgICAgIH07XG4gICAgICBpZiAobm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgIHRyYXZlcnNlKG5vZGUsIGNoaWxkTm9kZSA9PiB7XG4gICAgICAgICAgbWF0Y2hOb2RlJDEobm9kZUZpbHRlcnMsIGF0dHJpYnV0ZUZpbHRlcnMsIGNoaWxkTm9kZSwgbWF0Y2hlcyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoZXM7XG4gICAgfTtcbiAgICBjb25zdCBydW5GaWx0ZXJzID0gKG1hdGNoZXMsIGFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IHJ1biA9IChtYXRjaFJlY29yZCwgZmlsdGVyaW5nQXR0cmlidXRlcykgPT4ge1xuICAgICAgICBlYWNoJGQobWF0Y2hSZWNvcmQsIG1hdGNoID0+IHtcbiAgICAgICAgICBjb25zdCBub2RlcyA9IGZyb20obWF0Y2gubm9kZXMpO1xuICAgICAgICAgIGVhY2gkZShtYXRjaC5maWx0ZXIuY2FsbGJhY2tzLCBjYWxsYmFjayA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gbm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgICBjb25zdCB2YWx1ZU1hdGNoZXMgPSBmaWx0ZXJpbmdBdHRyaWJ1dGVzID8gbm9kZS5hdHRyKG1hdGNoLmZpbHRlci5uYW1lKSAhPT0gdW5kZWZpbmVkIDogbm9kZS5uYW1lID09PSBtYXRjaC5maWx0ZXIubmFtZTtcbiAgICAgICAgICAgICAgaWYgKCF2YWx1ZU1hdGNoZXMgfHwgaXNOdWxsYWJsZShub2RlLnBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKG5vZGVzLCBtYXRjaC5maWx0ZXIubmFtZSwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHJ1bihtYXRjaGVzLm5vZGVzLCBmYWxzZSk7XG4gICAgICBydW4obWF0Y2hlcy5hdHRyaWJ1dGVzLCB0cnVlKTtcbiAgICB9O1xuICAgIGNvbnN0IGZpbHRlciQyID0gKG5vZGVGaWx0ZXJzLCBhdHRyaWJ1dGVGaWx0ZXJzLCBub2RlLCBhcmdzID0ge30pID0+IHtcbiAgICAgIGNvbnN0IG1hdGNoZXMgPSBmaW5kTWF0Y2hpbmdOb2Rlcyhub2RlRmlsdGVycywgYXR0cmlidXRlRmlsdGVycywgbm9kZSk7XG4gICAgICBydW5GaWx0ZXJzKG1hdGNoZXMsIGFyZ3MpO1xuICAgIH07XG5cbiAgICBjb25zdCBwYWRkRW1wdHlOb2RlID0gKGFyZ3MsIGlzQmxvY2ssIG5vZGUpID0+IHtcbiAgICAgIGlmIChhcmdzLmluc2VydCAmJiBpc0Jsb2NrKG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGFzdE5vZGUgPSBuZXcgQXN0Tm9kZSgnYnInLCAxKTtcbiAgICAgICAgYXN0Tm9kZS5hdHRyKCdkYXRhLW1jZS1ib2d1cycsICcxJyk7XG4gICAgICAgIG5vZGUuZW1wdHkoKS5hcHBlbmQoYXN0Tm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmVtcHR5KCkuYXBwZW5kKG5ldyBBc3ROb2RlKCcjdGV4dCcsIDMpKS52YWx1ZSA9IG5ic3A7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpc1BhZGRlZFdpdGhOYnNwID0gbm9kZSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gaGFzT25seUNoaWxkKG5vZGUsICcjdGV4dCcpICYmICgoX2EgPSBub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGUuZmlyc3RDaGlsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnZhbHVlKSA9PT0gbmJzcDtcbiAgICB9O1xuICAgIGNvbnN0IGhhc09ubHlDaGlsZCA9IChub2RlLCBuYW1lKSA9PiB7XG4gICAgICBjb25zdCBmaXJzdENoaWxkID0gbm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICByZXR1cm4gaXNOb25OdWxsYWJsZShmaXJzdENoaWxkKSAmJiBmaXJzdENoaWxkID09PSBub2RlLmxhc3RDaGlsZCAmJiBmaXJzdENoaWxkLm5hbWUgPT09IG5hbWU7XG4gICAgfTtcbiAgICBjb25zdCBpc1BhZGRlZCA9IChzY2hlbWEsIG5vZGUpID0+IHtcbiAgICAgIGNvbnN0IHJ1bGUgPSBzY2hlbWEuZ2V0RWxlbWVudFJ1bGUobm9kZS5uYW1lKTtcbiAgICAgIHJldHVybiAocnVsZSA9PT0gbnVsbCB8fCBydWxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBydWxlLnBhZGRFbXB0eSkgPT09IHRydWU7XG4gICAgfTtcbiAgICBjb25zdCBpc0VtcHR5ID0gKHNjaGVtYSwgbm9uRW1wdHlFbGVtZW50cywgd2hpdGVzcGFjZUVsZW1lbnRzLCBub2RlKSA9PiBub2RlLmlzRW1wdHkobm9uRW1wdHlFbGVtZW50cywgd2hpdGVzcGFjZUVsZW1lbnRzLCBub2RlID0+IGlzUGFkZGVkKHNjaGVtYSwgbm9kZSkpO1xuICAgIGNvbnN0IGlzTGluZUJyZWFrTm9kZSA9IChub2RlLCBpc0Jsb2NrKSA9PiBpc05vbk51bGxhYmxlKG5vZGUpICYmIChpc0Jsb2NrKG5vZGUpIHx8IG5vZGUubmFtZSA9PT0gJ2JyJyk7XG4gICAgY29uc3QgZmluZENsb3Nlc3RFZGl0aW5nSG9zdCA9IHNjb3BlID0+IHtcbiAgICAgIGxldCBlZGl0YWJsZU5vZGU7XG4gICAgICBmb3IgKGxldCBub2RlID0gc2NvcGU7IG5vZGU7IG5vZGUgPSBub2RlLnBhcmVudCkge1xuICAgICAgICBjb25zdCBjb250ZW50RWRpdGFibGUgPSBub2RlLmF0dHIoJ2NvbnRlbnRlZGl0YWJsZScpO1xuICAgICAgICBpZiAoY29udGVudEVkaXRhYmxlID09PSAnZmFsc2UnKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpIHtcbiAgICAgICAgICBlZGl0YWJsZU5vZGUgPSBub2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gT3B0aW9uYWwuZnJvbShlZGl0YWJsZU5vZGUpO1xuICAgIH07XG5cbiAgICBjb25zdCByZW1vdmVPclVud3JhcEludmFsaWROb2RlID0gKG5vZGUsIHNjaGVtYSwgb3JpZ2luYWxOb2RlUGFyZW50ID0gbm9kZS5wYXJlbnQpID0+IHtcbiAgICAgIGlmIChzY2hlbWEuZ2V0U3BlY2lhbEVsZW1lbnRzKClbbm9kZS5uYW1lXSkge1xuICAgICAgICBub2RlLmVtcHR5KCkucmVtb3ZlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4oKTtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZE5vZGUgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAob3JpZ2luYWxOb2RlUGFyZW50ICYmICFzY2hlbWEuaXNWYWxpZENoaWxkKG9yaWdpbmFsTm9kZVBhcmVudC5uYW1lLCBjaGlsZE5vZGUubmFtZSkpIHtcbiAgICAgICAgICAgIHJlbW92ZU9yVW53cmFwSW52YWxpZE5vZGUoY2hpbGROb2RlLCBzY2hlbWEsIG9yaWdpbmFsTm9kZVBhcmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5vZGUudW53cmFwKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBjbGVhbkludmFsaWROb2RlcyA9IChub2Rlcywgc2NoZW1hLCByb290Tm9kZSwgb25DcmVhdGUgPSBub29wKSA9PiB7XG4gICAgICBjb25zdCB0ZXh0QmxvY2tFbGVtZW50cyA9IHNjaGVtYS5nZXRUZXh0QmxvY2tFbGVtZW50cygpO1xuICAgICAgY29uc3Qgbm9uRW1wdHlFbGVtZW50cyA9IHNjaGVtYS5nZXROb25FbXB0eUVsZW1lbnRzKCk7XG4gICAgICBjb25zdCB3aGl0ZXNwYWNlRWxlbWVudHMgPSBzY2hlbWEuZ2V0V2hpdGVzcGFjZUVsZW1lbnRzKCk7XG4gICAgICBjb25zdCBub25TcGxpdHRhYmxlRWxlbWVudHMgPSBUb29scy5tYWtlTWFwKCd0cix0ZCx0aCx0Ym9keSx0aGVhZCx0Zm9vdCx0YWJsZScpO1xuICAgICAgY29uc3QgZml4ZWQgPSBuZXcgU2V0KCk7XG4gICAgICBjb25zdCBpc1NwbGl0dGFibGVFbGVtZW50ID0gbm9kZSA9PiBub2RlICE9PSByb290Tm9kZSAmJiAhbm9uU3BsaXR0YWJsZUVsZW1lbnRzW25vZGUubmFtZV07XG4gICAgICBmb3IgKGxldCBuaSA9IDA7IG5pIDwgbm9kZXMubGVuZ3RoOyBuaSsrKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tuaV07XG4gICAgICAgIGxldCBwYXJlbnQ7XG4gICAgICAgIGxldCBuZXdQYXJlbnQ7XG4gICAgICAgIGxldCB0ZW1wTm9kZTtcbiAgICAgICAgaWYgKCFub2RlLnBhcmVudCB8fCBmaXhlZC5oYXMobm9kZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGV4dEJsb2NrRWxlbWVudHNbbm9kZS5uYW1lXSAmJiBub2RlLnBhcmVudC5uYW1lID09PSAnbGknKSB7XG4gICAgICAgICAgbGV0IHNpYmxpbmcgPSBub2RlLm5leHQ7XG4gICAgICAgICAgd2hpbGUgKHNpYmxpbmcpIHtcbiAgICAgICAgICAgIGlmICh0ZXh0QmxvY2tFbGVtZW50c1tzaWJsaW5nLm5hbWVdKSB7XG4gICAgICAgICAgICAgIHNpYmxpbmcubmFtZSA9ICdsaSc7XG4gICAgICAgICAgICAgIGZpeGVkLmFkZChzaWJsaW5nKTtcbiAgICAgICAgICAgICAgbm9kZS5wYXJlbnQuaW5zZXJ0KHNpYmxpbmcsIG5vZGUucGFyZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2libGluZyA9IHNpYmxpbmcubmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS51bndyYXAoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJlbnRzID0gW25vZGVdO1xuICAgICAgICBmb3IgKHBhcmVudCA9IG5vZGUucGFyZW50OyBwYXJlbnQgJiYgIXNjaGVtYS5pc1ZhbGlkQ2hpbGQocGFyZW50Lm5hbWUsIG5vZGUubmFtZSkgJiYgaXNTcGxpdHRhYmxlRWxlbWVudChwYXJlbnQpOyBwYXJlbnQgPSBwYXJlbnQucGFyZW50KSB7XG4gICAgICAgICAgcGFyZW50cy5wdXNoKHBhcmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBpZiAoc2NoZW1hLmlzVmFsaWRDaGlsZChwYXJlbnQubmFtZSwgbm9kZS5uYW1lKSkge1xuICAgICAgICAgICAgcGFyZW50cy5yZXZlcnNlKCk7XG4gICAgICAgICAgICBuZXdQYXJlbnQgPSBwYXJlbnRzWzBdLmNsb25lKCk7XG4gICAgICAgICAgICBvbkNyZWF0ZShuZXdQYXJlbnQpO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnROb2RlID0gbmV3UGFyZW50O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoc2NoZW1hLmlzVmFsaWRDaGlsZChjdXJyZW50Tm9kZS5uYW1lLCBwYXJlbnRzW2ldLm5hbWUpICYmIGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGVtcE5vZGUgPSBwYXJlbnRzW2ldLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgb25DcmVhdGUodGVtcE5vZGUpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLmFwcGVuZCh0ZW1wTm9kZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGVtcE5vZGUgPSBjdXJyZW50Tm9kZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKGxldCBjaGlsZE5vZGUgPSBwYXJlbnRzW2ldLmZpcnN0Q2hpbGQ7IGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUgIT09IHBhcmVudHNbaSArIDFdOykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHROb2RlID0gY2hpbGROb2RlLm5leHQ7XG4gICAgICAgICAgICAgICAgdGVtcE5vZGUuYXBwZW5kKGNoaWxkTm9kZSk7XG4gICAgICAgICAgICAgICAgY2hpbGROb2RlID0gbmV4dE5vZGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSB0ZW1wTm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNFbXB0eShzY2hlbWEsIG5vbkVtcHR5RWxlbWVudHMsIHdoaXRlc3BhY2VFbGVtZW50cywgbmV3UGFyZW50KSkge1xuICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0KG5ld1BhcmVudCwgcGFyZW50c1swXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHBhcmVudC5pbnNlcnQobm9kZSwgbmV3UGFyZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhcmVudC5pbnNlcnQobm9kZSwgcGFyZW50c1swXSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnRzWzBdO1xuICAgICAgICAgICAgaWYgKGlzRW1wdHkoc2NoZW1hLCBub25FbXB0eUVsZW1lbnRzLCB3aGl0ZXNwYWNlRWxlbWVudHMsIHBhcmVudCkgfHwgaGFzT25seUNoaWxkKHBhcmVudCwgJ2JyJykpIHtcbiAgICAgICAgICAgICAgcGFyZW50LmVtcHR5KCkucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbW92ZU9yVW53cmFwSW52YWxpZE5vZGUobm9kZSwgc2NoZW1hKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5wYXJlbnQpIHtcbiAgICAgICAgICBpZiAobm9kZS5uYW1lID09PSAnbGknKSB7XG4gICAgICAgICAgICBsZXQgc2libGluZyA9IG5vZGUucHJldjtcbiAgICAgICAgICAgIGlmIChzaWJsaW5nICYmIChzaWJsaW5nLm5hbWUgPT09ICd1bCcgfHwgc2libGluZy5uYW1lID09PSAnb2wnKSkge1xuICAgICAgICAgICAgICBzaWJsaW5nLmFwcGVuZChub2RlKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaWJsaW5nID0gbm9kZS5uZXh0O1xuICAgICAgICAgICAgaWYgKHNpYmxpbmcgJiYgKHNpYmxpbmcubmFtZSA9PT0gJ3VsJyB8fCBzaWJsaW5nLm5hbWUgPT09ICdvbCcpICYmIHNpYmxpbmcuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICBzaWJsaW5nLmluc2VydChub2RlLCBzaWJsaW5nLmZpcnN0Q2hpbGQsIHRydWUpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHdyYXBwZXIgPSBuZXcgQXN0Tm9kZSgndWwnLCAxKTtcbiAgICAgICAgICAgIG9uQ3JlYXRlKHdyYXBwZXIpO1xuICAgICAgICAgICAgbm9kZS53cmFwKHdyYXBwZXIpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzY2hlbWEuaXNWYWxpZENoaWxkKG5vZGUucGFyZW50Lm5hbWUsICdkaXYnKSAmJiBzY2hlbWEuaXNWYWxpZENoaWxkKCdkaXYnLCBub2RlLm5hbWUpKSB7XG4gICAgICAgICAgICBjb25zdCB3cmFwcGVyID0gbmV3IEFzdE5vZGUoJ2RpdicsIDEpO1xuICAgICAgICAgICAgb25DcmVhdGUod3JhcHBlcik7XG4gICAgICAgICAgICBub2RlLndyYXAod3JhcHBlcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbW92ZU9yVW53cmFwSW52YWxpZE5vZGUobm9kZSwgc2NoZW1hKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGhhc0Nsb3Nlc3QgPSAobm9kZSwgcGFyZW50TmFtZSkgPT4ge1xuICAgICAgbGV0IHRlbXBOb2RlID0gbm9kZTtcbiAgICAgIHdoaWxlICh0ZW1wTm9kZSkge1xuICAgICAgICBpZiAodGVtcE5vZGUubmFtZSA9PT0gcGFyZW50TmFtZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRlbXBOb2RlID0gdGVtcE5vZGUucGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgY29uc3QgaXNJbnZhbGlkID0gKHNjaGVtYSwgbm9kZSwgcGFyZW50ID0gbm9kZS5wYXJlbnQpID0+IHtcbiAgICAgIGlmIChwYXJlbnQgJiYgc2NoZW1hLmNoaWxkcmVuW25vZGUubmFtZV0gJiYgIXNjaGVtYS5pc1ZhbGlkQ2hpbGQocGFyZW50Lm5hbWUsIG5vZGUubmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHBhcmVudCAmJiBub2RlLm5hbWUgPT09ICdhJyAmJiBoYXNDbG9zZXN0KHBhcmVudCwgJ2EnKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgY3JlYXRlUmFuZ2UgPSAoc2MsIHNvLCBlYywgZW8pID0+IHtcbiAgICAgIGNvbnN0IHJuZyA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICBybmcuc2V0U3RhcnQoc2MsIHNvKTtcbiAgICAgIHJuZy5zZXRFbmQoZWMsIGVvKTtcbiAgICAgIHJldHVybiBybmc7XG4gICAgfTtcbiAgICBjb25zdCBub3JtYWxpemVCbG9ja1NlbGVjdGlvblJhbmdlID0gcm5nID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0UG9zID0gQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChybmcpO1xuICAgICAgY29uc3QgZW5kUG9zID0gQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VFbmQocm5nKTtcbiAgICAgIGNvbnN0IHJvb3ROb2RlID0gcm5nLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuICAgICAgcmV0dXJuIGZyb21Qb3NpdGlvbihmYWxzZSwgcm9vdE5vZGUsIGVuZFBvcykubWFwKG5ld0VuZFBvcyA9PiB7XG4gICAgICAgIGlmICghaXNJblNhbWVCbG9jayhzdGFydFBvcywgZW5kUG9zLCByb290Tm9kZSkgJiYgaXNJblNhbWVCbG9jayhzdGFydFBvcywgbmV3RW5kUG9zLCByb290Tm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlUmFuZ2Uoc3RhcnRQb3MuY29udGFpbmVyKCksIHN0YXJ0UG9zLm9mZnNldCgpLCBuZXdFbmRQb3MuY29udGFpbmVyKCksIG5ld0VuZFBvcy5vZmZzZXQoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHJuZztcbiAgICAgICAgfVxuICAgICAgfSkuZ2V0T3Iocm5nKTtcbiAgICB9O1xuICAgIGNvbnN0IG5vcm1hbGl6ZSA9IHJuZyA9PiBybmcuY29sbGFwc2VkID8gcm5nIDogbm9ybWFsaXplQmxvY2tTZWxlY3Rpb25SYW5nZShybmcpO1xuXG4gICAgY29uc3QgaGFzT25seU9uZUNoaWxkID0gbm9kZSA9PiB7XG4gICAgICByZXR1cm4gaXNOb25OdWxsYWJsZShub2RlLmZpcnN0Q2hpbGQpICYmIG5vZGUuZmlyc3RDaGlsZCA9PT0gbm9kZS5sYXN0Q2hpbGQ7XG4gICAgfTtcbiAgICBjb25zdCBpc1BhZGRpbmdOb2RlID0gbm9kZSA9PiB7XG4gICAgICByZXR1cm4gbm9kZS5uYW1lID09PSAnYnInIHx8IG5vZGUudmFsdWUgPT09IG5ic3A7XG4gICAgfTtcbiAgICBjb25zdCBpc1BhZGRlZEVtcHR5QmxvY2sgPSAoc2NoZW1hLCBub2RlKSA9PiB7XG4gICAgICBjb25zdCBibG9ja0VsZW1lbnRzID0gc2NoZW1hLmdldEJsb2NrRWxlbWVudHMoKTtcbiAgICAgIHJldHVybiBibG9ja0VsZW1lbnRzW25vZGUubmFtZV0gJiYgaGFzT25seU9uZUNoaWxkKG5vZGUpICYmIGlzUGFkZGluZ05vZGUobm9kZS5maXJzdENoaWxkKTtcbiAgICB9O1xuICAgIGNvbnN0IGlzRW1wdHlGcmFnbWVudEVsZW1lbnQgPSAoc2NoZW1hLCBub2RlKSA9PiB7XG4gICAgICBjb25zdCBub25FbXB0eUVsZW1lbnRzID0gc2NoZW1hLmdldE5vbkVtcHR5RWxlbWVudHMoKTtcbiAgICAgIHJldHVybiBpc05vbk51bGxhYmxlKG5vZGUpICYmIChub2RlLmlzRW1wdHkobm9uRW1wdHlFbGVtZW50cykgfHwgaXNQYWRkZWRFbXB0eUJsb2NrKHNjaGVtYSwgbm9kZSkpO1xuICAgIH07XG4gICAgY29uc3QgaXNMaXN0RnJhZ21lbnQgPSAoc2NoZW1hLCBmcmFnbWVudCkgPT4ge1xuICAgICAgbGV0IGZpcnN0Q2hpbGQgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuICAgICAgbGV0IGxhc3RDaGlsZCA9IGZyYWdtZW50Lmxhc3RDaGlsZDtcbiAgICAgIGlmIChmaXJzdENoaWxkICYmIGZpcnN0Q2hpbGQubmFtZSA9PT0gJ21ldGEnKSB7XG4gICAgICAgIGZpcnN0Q2hpbGQgPSBmaXJzdENoaWxkLm5leHQ7XG4gICAgICB9XG4gICAgICBpZiAobGFzdENoaWxkICYmIGxhc3RDaGlsZC5hdHRyKCdpZCcpID09PSAnbWNlX21hcmtlcicpIHtcbiAgICAgICAgbGFzdENoaWxkID0gbGFzdENoaWxkLnByZXY7XG4gICAgICB9XG4gICAgICBpZiAoaXNFbXB0eUZyYWdtZW50RWxlbWVudChzY2hlbWEsIGxhc3RDaGlsZCkpIHtcbiAgICAgICAgbGFzdENoaWxkID0gbGFzdENoaWxkID09PSBudWxsIHx8IGxhc3RDaGlsZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFzdENoaWxkLnByZXY7XG4gICAgICB9XG4gICAgICBpZiAoIWZpcnN0Q2hpbGQgfHwgZmlyc3RDaGlsZCAhPT0gbGFzdENoaWxkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmaXJzdENoaWxkLm5hbWUgPT09ICd1bCcgfHwgZmlyc3RDaGlsZC5uYW1lID09PSAnb2wnO1xuICAgIH07XG4gICAgY29uc3QgY2xlYW51cERvbUZyYWdtZW50ID0gZG9tRnJhZ21lbnQgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBkb21GcmFnbWVudC5maXJzdENoaWxkO1xuICAgICAgY29uc3QgbGFzdENoaWxkID0gZG9tRnJhZ21lbnQubGFzdENoaWxkO1xuICAgICAgaWYgKGZpcnN0Q2hpbGQgJiYgZmlyc3RDaGlsZC5ub2RlTmFtZSA9PT0gJ01FVEEnKSB7XG4gICAgICAgIChfYSA9IGZpcnN0Q2hpbGQucGFyZW50Tm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZUNoaWxkKGZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgICAgaWYgKGxhc3RDaGlsZCAmJiBsYXN0Q2hpbGQuaWQgPT09ICdtY2VfbWFya2VyJykge1xuICAgICAgICAoX2IgPSBsYXN0Q2hpbGQucGFyZW50Tm9kZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlbW92ZUNoaWxkKGxhc3RDaGlsZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZG9tRnJhZ21lbnQ7XG4gICAgfTtcbiAgICBjb25zdCB0b0RvbUZyYWdtZW50ID0gKGRvbSwgc2VyaWFsaXplciwgZnJhZ21lbnQpID0+IHtcbiAgICAgIGNvbnN0IGh0bWwgPSBzZXJpYWxpemVyLnNlcmlhbGl6ZShmcmFnbWVudCk7XG4gICAgICBjb25zdCBkb21GcmFnbWVudCA9IGRvbS5jcmVhdGVGcmFnbWVudChodG1sKTtcbiAgICAgIHJldHVybiBjbGVhbnVwRG9tRnJhZ21lbnQoZG9tRnJhZ21lbnQpO1xuICAgIH07XG4gICAgY29uc3QgbGlzdEl0ZW1zID0gZWxtID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHJldHVybiBmaWx0ZXIkNSgoX2EgPSBlbG0gPT09IG51bGwgfHwgZWxtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbG0uY2hpbGROb2RlcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10sIGNoaWxkID0+IHtcbiAgICAgICAgcmV0dXJuIGNoaWxkLm5vZGVOYW1lID09PSAnTEknO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBpc1BhZGRpbmcgPSBub2RlID0+IHtcbiAgICAgIHJldHVybiBub2RlLmRhdGEgPT09IG5ic3AgfHwgaXNCciQ2KG5vZGUpO1xuICAgIH07XG4gICAgY29uc3QgaXNMaXN0SXRlbVBhZGRlZCA9IG5vZGUgPT4ge1xuICAgICAgcmV0dXJuIGlzTm9uTnVsbGFibGUobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLmZpcnN0Q2hpbGQpICYmIG5vZGUuZmlyc3RDaGlsZCA9PT0gbm9kZS5sYXN0Q2hpbGQgJiYgaXNQYWRkaW5nKG5vZGUuZmlyc3RDaGlsZCk7XG4gICAgfTtcbiAgICBjb25zdCBpc0VtcHR5T3JQYWRkZWQgPSBlbG0gPT4ge1xuICAgICAgcmV0dXJuICFlbG0uZmlyc3RDaGlsZCB8fCBpc0xpc3RJdGVtUGFkZGVkKGVsbSk7XG4gICAgfTtcbiAgICBjb25zdCB0cmltTGlzdEl0ZW1zID0gZWxtcyA9PiB7XG4gICAgICByZXR1cm4gZWxtcy5sZW5ndGggPiAwICYmIGlzRW1wdHlPclBhZGRlZChlbG1zW2VsbXMubGVuZ3RoIC0gMV0pID8gZWxtcy5zbGljZSgwLCAtMSkgOiBlbG1zO1xuICAgIH07XG4gICAgY29uc3QgZ2V0UGFyZW50TGkgPSAoZG9tLCBub2RlKSA9PiB7XG4gICAgICBjb25zdCBwYXJlbnRCbG9jayA9IGRvbS5nZXRQYXJlbnQobm9kZSwgZG9tLmlzQmxvY2spO1xuICAgICAgcmV0dXJuIHBhcmVudEJsb2NrICYmIHBhcmVudEJsb2NrLm5vZGVOYW1lID09PSAnTEknID8gcGFyZW50QmxvY2sgOiBudWxsO1xuICAgIH07XG4gICAgY29uc3QgaXNQYXJlbnRCbG9ja0xpID0gKGRvbSwgbm9kZSkgPT4ge1xuICAgICAgcmV0dXJuICEhZ2V0UGFyZW50TGkoZG9tLCBub2RlKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldFNwbGl0ID0gKHBhcmVudE5vZGUsIHJuZykgPT4ge1xuICAgICAgY29uc3QgYmVmb3JlUm5nID0gcm5nLmNsb25lUmFuZ2UoKTtcbiAgICAgIGNvbnN0IGFmdGVyUm5nID0gcm5nLmNsb25lUmFuZ2UoKTtcbiAgICAgIGJlZm9yZVJuZy5zZXRTdGFydEJlZm9yZShwYXJlbnROb2RlKTtcbiAgICAgIGFmdGVyUm5nLnNldEVuZEFmdGVyKHBhcmVudE5vZGUpO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgYmVmb3JlUm5nLmNsb25lQ29udGVudHMoKSxcbiAgICAgICAgYWZ0ZXJSbmcuY2xvbmVDb250ZW50cygpXG4gICAgICBdO1xuICAgIH07XG4gICAgY29uc3QgZmluZEZpcnN0SW4gPSAobm9kZSwgcm9vdE5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGNhcmV0UG9zID0gQ2FyZXRQb3NpdGlvbi5iZWZvcmUobm9kZSk7XG4gICAgICBjb25zdCBjYXJldFdhbGtlciA9IENhcmV0V2Fsa2VyKHJvb3ROb2RlKTtcbiAgICAgIGNvbnN0IG5ld0NhcmV0UG9zID0gY2FyZXRXYWxrZXIubmV4dChjYXJldFBvcyk7XG4gICAgICByZXR1cm4gbmV3Q2FyZXRQb3MgPyBuZXdDYXJldFBvcy50b1JhbmdlKCkgOiBudWxsO1xuICAgIH07XG4gICAgY29uc3QgZmluZExhc3RPZiA9IChub2RlLCByb290Tm9kZSkgPT4ge1xuICAgICAgY29uc3QgY2FyZXRQb3MgPSBDYXJldFBvc2l0aW9uLmFmdGVyKG5vZGUpO1xuICAgICAgY29uc3QgY2FyZXRXYWxrZXIgPSBDYXJldFdhbGtlcihyb290Tm9kZSk7XG4gICAgICBjb25zdCBuZXdDYXJldFBvcyA9IGNhcmV0V2Fsa2VyLnByZXYoY2FyZXRQb3MpO1xuICAgICAgcmV0dXJuIG5ld0NhcmV0UG9zID8gbmV3Q2FyZXRQb3MudG9SYW5nZSgpIDogbnVsbDtcbiAgICB9O1xuICAgIGNvbnN0IGluc2VydE1pZGRsZSA9ICh0YXJnZXQsIGVsbXMsIHJvb3ROb2RlLCBybmcpID0+IHtcbiAgICAgIGNvbnN0IHBhcnRzID0gZ2V0U3BsaXQodGFyZ2V0LCBybmcpO1xuICAgICAgY29uc3QgcGFyZW50RWxtID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgICBpZiAocGFyZW50RWxtKSB7XG4gICAgICAgIHBhcmVudEVsbS5pbnNlcnRCZWZvcmUocGFydHNbMF0sIHRhcmdldCk7XG4gICAgICAgIFRvb2xzLmVhY2goZWxtcywgbGkgPT4ge1xuICAgICAgICAgIHBhcmVudEVsbS5pbnNlcnRCZWZvcmUobGksIHRhcmdldCk7XG4gICAgICAgIH0pO1xuICAgICAgICBwYXJlbnRFbG0uaW5zZXJ0QmVmb3JlKHBhcnRzWzFdLCB0YXJnZXQpO1xuICAgICAgICBwYXJlbnRFbG0ucmVtb3ZlQ2hpbGQodGFyZ2V0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmaW5kTGFzdE9mKGVsbXNbZWxtcy5sZW5ndGggLSAxXSwgcm9vdE5vZGUpO1xuICAgIH07XG4gICAgY29uc3QgaW5zZXJ0QmVmb3JlJDEgPSAodGFyZ2V0LCBlbG1zLCByb290Tm9kZSkgPT4ge1xuICAgICAgY29uc3QgcGFyZW50RWxtID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgICBpZiAocGFyZW50RWxtKSB7XG4gICAgICAgIFRvb2xzLmVhY2goZWxtcywgZWxtID0+IHtcbiAgICAgICAgICBwYXJlbnRFbG0uaW5zZXJ0QmVmb3JlKGVsbSwgdGFyZ2V0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmluZEZpcnN0SW4odGFyZ2V0LCByb290Tm9kZSk7XG4gICAgfTtcbiAgICBjb25zdCBpbnNlcnRBZnRlciQxID0gKHRhcmdldCwgZWxtcywgcm9vdE5vZGUsIGRvbSkgPT4ge1xuICAgICAgZG9tLmluc2VydEFmdGVyKGVsbXMucmV2ZXJzZSgpLCB0YXJnZXQpO1xuICAgICAgcmV0dXJuIGZpbmRMYXN0T2YoZWxtc1swXSwgcm9vdE5vZGUpO1xuICAgIH07XG4gICAgY29uc3QgaW5zZXJ0QXRDYXJldCQxID0gKHNlcmlhbGl6ZXIsIGRvbSwgcm5nLCBmcmFnbWVudCkgPT4ge1xuICAgICAgY29uc3QgZG9tRnJhZ21lbnQgPSB0b0RvbUZyYWdtZW50KGRvbSwgc2VyaWFsaXplciwgZnJhZ21lbnQpO1xuICAgICAgY29uc3QgbGlUYXJnZXQgPSBnZXRQYXJlbnRMaShkb20sIHJuZy5zdGFydENvbnRhaW5lcik7XG4gICAgICBjb25zdCBsaUVsbXMgPSB0cmltTGlzdEl0ZW1zKGxpc3RJdGVtcyhkb21GcmFnbWVudC5maXJzdENoaWxkKSk7XG4gICAgICBjb25zdCBCRUdJTk5JTkcgPSAxLCBFTkQgPSAyO1xuICAgICAgY29uc3Qgcm9vdE5vZGUgPSBkb20uZ2V0Um9vdCgpO1xuICAgICAgY29uc3QgaXNBdCA9IGxvY2F0aW9uID0+IHtcbiAgICAgICAgY29uc3QgY2FyZXRQb3MgPSBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KHJuZyk7XG4gICAgICAgIGNvbnN0IGNhcmV0V2Fsa2VyID0gQ2FyZXRXYWxrZXIoZG9tLmdldFJvb3QoKSk7XG4gICAgICAgIGNvbnN0IG5ld1BvcyA9IGxvY2F0aW9uID09PSBCRUdJTk5JTkcgPyBjYXJldFdhbGtlci5wcmV2KGNhcmV0UG9zKSA6IGNhcmV0V2Fsa2VyLm5leHQoY2FyZXRQb3MpO1xuICAgICAgICBjb25zdCBuZXdQb3NOb2RlID0gbmV3UG9zID09PSBudWxsIHx8IG5ld1BvcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmV3UG9zLmdldE5vZGUoKTtcbiAgICAgICAgcmV0dXJuIG5ld1Bvc05vZGUgPyBnZXRQYXJlbnRMaShkb20sIG5ld1Bvc05vZGUpICE9PSBsaVRhcmdldCA6IHRydWU7XG4gICAgICB9O1xuICAgICAgaWYgKCFsaVRhcmdldCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoaXNBdChCRUdJTk5JTkcpKSB7XG4gICAgICAgIHJldHVybiBpbnNlcnRCZWZvcmUkMShsaVRhcmdldCwgbGlFbG1zLCByb290Tm9kZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzQXQoRU5EKSkge1xuICAgICAgICByZXR1cm4gaW5zZXJ0QWZ0ZXIkMShsaVRhcmdldCwgbGlFbG1zLCByb290Tm9kZSwgZG9tKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpbnNlcnRNaWRkbGUobGlUYXJnZXQsIGxpRWxtcywgcm9vdE5vZGUsIHJuZyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IG1lcmdlYWJsZVdyYXBwZWRFbGVtZW50cyA9IFsncHJlJ107XG4gICAgY29uc3Qgc2hvdWxkUGFzdGVDb250ZW50T25seSA9IChkb20sIGZyYWdtZW50LCBwYXJlbnROb2RlLCByb290KSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBmaXJzdE5vZGUgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuICAgICAgY29uc3QgbGFzdE5vZGUgPSBmcmFnbWVudC5sYXN0Q2hpbGQ7XG4gICAgICBjb25zdCBsYXN0ID0gbGFzdE5vZGUuYXR0cignZGF0YS1tY2UtdHlwZScpID09PSAnYm9va21hcmsnID8gbGFzdE5vZGUucHJldiA6IGxhc3ROb2RlO1xuICAgICAgY29uc3QgaXNQYXN0aW5nU2luZ2xlRWxlbWVudCA9IGZpcnN0Tm9kZSA9PT0gbGFzdDtcbiAgICAgIGNvbnN0IGlzV3JhcHBlZEVsZW1lbnQgPSBjb250YWlucyQyKG1lcmdlYWJsZVdyYXBwZWRFbGVtZW50cywgZmlyc3ROb2RlLm5hbWUpO1xuICAgICAgaWYgKGlzUGFzdGluZ1NpbmdsZUVsZW1lbnQgJiYgaXNXcmFwcGVkRWxlbWVudCkge1xuICAgICAgICBjb25zdCBpc0NvbnRlbnRFZGl0YWJsZSA9IGZpcnN0Tm9kZS5hdHRyKCdjb250ZW50ZWRpdGFibGUnKSAhPT0gJ2ZhbHNlJztcbiAgICAgICAgY29uc3QgaXNQYXN0aW5nSW5UaGVTYW1lQmxvY2tUYWcgPSAoKF9hID0gZG9tLmdldFBhcmVudChwYXJlbnROb2RlLCBkb20uaXNCbG9jaykpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSA9PT0gZmlyc3ROb2RlLm5hbWU7XG4gICAgICAgIGNvbnN0IGlzUGFzdGluZ0luQ29udGVudEVkaXRhYmxlID0gT3B0aW9uYWwuZnJvbShnZXRDb250ZW50RWRpdGFibGVSb290JDEocm9vdCwgcGFyZW50Tm9kZSkpLmZvcmFsbChpc0NvbnRlbnRFZGl0YWJsZVRydWUkMyk7XG4gICAgICAgIHJldHVybiBpc0NvbnRlbnRFZGl0YWJsZSAmJiBpc1Bhc3RpbmdJblRoZVNhbWVCbG9ja1RhZyAmJiBpc1Bhc3RpbmdJbkNvbnRlbnRFZGl0YWJsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGlzVGFibGVDZWxsID0gaXNUYWJsZUNlbGwkMztcbiAgICBjb25zdCBpc1RhYmxlQ2VsbENvbnRlbnRTZWxlY3RlZCA9IChkb20sIHJuZywgY2VsbCkgPT4ge1xuICAgICAgaWYgKGlzTm9uTnVsbGFibGUoY2VsbCkpIHtcbiAgICAgICAgY29uc3QgZW5kQ2VsbCA9IGRvbS5nZXRQYXJlbnQocm5nLmVuZENvbnRhaW5lciwgaXNUYWJsZUNlbGwpO1xuICAgICAgICByZXR1cm4gY2VsbCA9PT0gZW5kQ2VsbCAmJiBoYXNBbGxDb250ZW50c1NlbGVjdGVkKFN1Z2FyRWxlbWVudC5mcm9tRG9tKGNlbGwpLCBybmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgdmFsaWRJbnNlcnRpb24gPSAoZWRpdG9yLCB2YWx1ZSwgcGFyZW50Tm9kZSkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKHBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLW1jZS1ib2d1cycpID09PSAnYWxsJykge1xuICAgICAgICAoX2EgPSBwYXJlbnROb2RlLnBhcmVudE5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbnNlcnRCZWZvcmUoZWRpdG9yLmRvbS5jcmVhdGVGcmFnbWVudCh2YWx1ZSksIHBhcmVudE5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHBhcmVudE5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgY29uc3Qgbm9kZTIgPSBwYXJlbnROb2RlLmxhc3RDaGlsZDtcbiAgICAgICAgaWYgKCFub2RlIHx8IG5vZGUgPT09IG5vZGUyICYmIG5vZGUubm9kZU5hbWUgPT09ICdCUicpIHtcbiAgICAgICAgICBlZGl0b3IuZG9tLnNldEhUTUwocGFyZW50Tm9kZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Q29udGVudCh2YWx1ZSwgeyBub19ldmVudHM6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHRyaW1CcnNGcm9tVGFibGVDZWxsID0gKGRvbSwgZWxtKSA9PiB7XG4gICAgICBPcHRpb25hbC5mcm9tKGRvbS5nZXRQYXJlbnQoZWxtLCAndGQsdGgnKSkubWFwKFN1Z2FyRWxlbWVudC5mcm9tRG9tKS5lYWNoKHRyaW1CbG9ja1RyYWlsaW5nQnIpO1xuICAgIH07XG4gICAgY29uc3QgcmVkdWNlSW5saW5lVGV4dEVsZW1lbnRzID0gKGVkaXRvciwgbWVyZ2UpID0+IHtcbiAgICAgIGNvbnN0IHRleHRJbmxpbmVFbGVtZW50cyA9IGVkaXRvci5zY2hlbWEuZ2V0VGV4dElubGluZUVsZW1lbnRzKCk7XG4gICAgICBjb25zdCBkb20gPSBlZGl0b3IuZG9tO1xuICAgICAgaWYgKG1lcmdlKSB7XG4gICAgICAgIGNvbnN0IHJvb3QgPSBlZGl0b3IuZ2V0Qm9keSgpO1xuICAgICAgICBjb25zdCBlbGVtZW50VXRpbHMgPSBFbGVtZW50VXRpbHMoZWRpdG9yKTtcbiAgICAgICAgVG9vbHMuZWFjaChkb20uc2VsZWN0KCcqW2RhdGEtbWNlLWZyYWdtZW50XScpLCBub2RlID0+IHtcbiAgICAgICAgICBjb25zdCBpc0lubGluZSA9IGlzTm9uTnVsbGFibGUodGV4dElubGluZUVsZW1lbnRzW25vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKV0pO1xuICAgICAgICAgIGlmIChpc0lubGluZSAmJiBoYXNJbmhlcml0YWJsZVN0eWxlcyhkb20sIG5vZGUpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnRFbGVtZW50OyBpc05vbk51bGxhYmxlKHBhcmVudE5vZGUpICYmIHBhcmVudE5vZGUgIT09IHJvb3Q7IHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgY29uc3Qgc3R5bGVDb25mbGljdCA9IGhhc1N0eWxlQ29uZmxpY3QoZG9tLCBub2RlLCBwYXJlbnROb2RlKTtcbiAgICAgICAgICAgICAgaWYgKHN0eWxlQ29uZmxpY3QpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZWxlbWVudFV0aWxzLmNvbXBhcmUocGFyZW50Tm9kZSwgbm9kZSkpIHtcbiAgICAgICAgICAgICAgICBkb20ucmVtb3ZlKG5vZGUsIHRydWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG1hcmtGcmFnbWVudEVsZW1lbnRzID0gZnJhZ21lbnQgPT4ge1xuICAgICAgbGV0IG5vZGUgPSBmcmFnbWVudDtcbiAgICAgIHdoaWxlIChub2RlID0gbm9kZS53YWxrKCkpIHtcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgICAgICAgIG5vZGUuYXR0cignZGF0YS1tY2UtZnJhZ21lbnQnLCAnMScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB1bm1hcmtGcmFnbWVudEVsZW1lbnRzID0gZWxtID0+IHtcbiAgICAgIFRvb2xzLmVhY2goZWxtLmdldEVsZW1lbnRzQnlUYWdOYW1lKCcqJyksIGVsbSA9PiB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtbWNlLWZyYWdtZW50Jyk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGlzUGFydE9mRnJhZ21lbnQgPSBub2RlID0+IHtcbiAgICAgIHJldHVybiAhIW5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLW1jZS1mcmFnbWVudCcpO1xuICAgIH07XG4gICAgY29uc3QgY2FuSGF2ZUNoaWxkcmVuID0gKGVkaXRvciwgbm9kZSkgPT4ge1xuICAgICAgcmV0dXJuIGlzTm9uTnVsbGFibGUobm9kZSkgJiYgIWVkaXRvci5zY2hlbWEuZ2V0Vm9pZEVsZW1lbnRzKClbbm9kZS5ub2RlTmFtZV07XG4gICAgfTtcbiAgICBjb25zdCBtb3ZlU2VsZWN0aW9uVG9NYXJrZXIgPSAoZWRpdG9yLCBtYXJrZXIpID0+IHtcbiAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgbGV0IG5leHRSbmc7XG4gICAgICBjb25zdCBkb20gPSBlZGl0b3IuZG9tO1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgICAgIGlmICghbWFya2VyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlbGVjdGlvbi5zY3JvbGxJbnRvVmlldyhtYXJrZXIpO1xuICAgICAgY29uc3QgcGFyZW50RWRpdGFibGVFbG0gPSBnZXRDb250ZW50RWRpdGFibGVSb290JDEoZWRpdG9yLmdldEJvZHkoKSwgbWFya2VyKTtcbiAgICAgIGlmIChwYXJlbnRFZGl0YWJsZUVsbSAmJiBkb20uZ2V0Q29udGVudEVkaXRhYmxlKHBhcmVudEVkaXRhYmxlRWxtKSA9PT0gJ2ZhbHNlJykge1xuICAgICAgICBkb20ucmVtb3ZlKG1hcmtlcik7XG4gICAgICAgIHNlbGVjdGlvbi5zZWxlY3QocGFyZW50RWRpdGFibGVFbG0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgcm5nID0gZG9tLmNyZWF0ZVJuZygpO1xuICAgICAgY29uc3Qgbm9kZSA9IG1hcmtlci5wcmV2aW91c1NpYmxpbmc7XG4gICAgICBpZiAoaXNUZXh0JGEobm9kZSkpIHtcbiAgICAgICAgcm5nLnNldFN0YXJ0KG5vZGUsIChfYiA9IChfYSA9IG5vZGUubm9kZVZhbHVlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKTtcbiAgICAgICAgY29uc3Qgbm9kZTIgPSBtYXJrZXIubmV4dFNpYmxpbmc7XG4gICAgICAgIGlmIChpc1RleHQkYShub2RlMikpIHtcbiAgICAgICAgICBub2RlLmFwcGVuZERhdGEobm9kZTIuZGF0YSk7XG4gICAgICAgICAgKF9jID0gbm9kZTIucGFyZW50Tm9kZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJlbW92ZUNoaWxkKG5vZGUyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm5nLnNldFN0YXJ0QmVmb3JlKG1hcmtlcik7XG4gICAgICAgIHJuZy5zZXRFbmRCZWZvcmUobWFya2VyKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZpbmROZXh0Q2FyZXRSbmcgPSBybmcgPT4ge1xuICAgICAgICBsZXQgY2FyZXRQb3MgPSBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KHJuZyk7XG4gICAgICAgIGNvbnN0IGNhcmV0V2Fsa2VyID0gQ2FyZXRXYWxrZXIoZWRpdG9yLmdldEJvZHkoKSk7XG4gICAgICAgIGNhcmV0UG9zID0gY2FyZXRXYWxrZXIubmV4dChjYXJldFBvcyk7XG4gICAgICAgIHJldHVybiBjYXJldFBvcyA9PT0gbnVsbCB8fCBjYXJldFBvcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FyZXRQb3MudG9SYW5nZSgpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHBhcmVudEJsb2NrID0gZG9tLmdldFBhcmVudChtYXJrZXIsIGRvbS5pc0Jsb2NrKTtcbiAgICAgIGRvbS5yZW1vdmUobWFya2VyKTtcbiAgICAgIGlmIChwYXJlbnRCbG9jayAmJiBkb20uaXNFbXB0eShwYXJlbnRCbG9jaykpIHtcbiAgICAgICAgZW1wdHkoU3VnYXJFbGVtZW50LmZyb21Eb20ocGFyZW50QmxvY2spKTtcbiAgICAgICAgcm5nLnNldFN0YXJ0KHBhcmVudEJsb2NrLCAwKTtcbiAgICAgICAgcm5nLnNldEVuZChwYXJlbnRCbG9jaywgMCk7XG4gICAgICAgIGlmICghaXNUYWJsZUNlbGwocGFyZW50QmxvY2spICYmICFpc1BhcnRPZkZyYWdtZW50KHBhcmVudEJsb2NrKSAmJiAobmV4dFJuZyA9IGZpbmROZXh0Q2FyZXRSbmcocm5nKSkpIHtcbiAgICAgICAgICBybmcgPSBuZXh0Um5nO1xuICAgICAgICAgIGRvbS5yZW1vdmUocGFyZW50QmxvY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvbS5hZGQocGFyZW50QmxvY2ssIGRvbS5jcmVhdGUoJ2JyJywgeyAnZGF0YS1tY2UtYm9ndXMnOiAnMScgfSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzZWxlY3Rpb24uc2V0Um5nKHJuZyk7XG4gICAgfTtcbiAgICBjb25zdCBkZWxldGVTZWxlY3RlZENvbnRlbnQgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbTtcbiAgICAgIGNvbnN0IHJuZyA9IG5vcm1hbGl6ZShlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpKTtcbiAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Um5nKHJuZyk7XG4gICAgICBjb25zdCBzdGFydENlbGwgPSBkb20uZ2V0UGFyZW50KHJuZy5zdGFydENvbnRhaW5lciwgaXNUYWJsZUNlbGwpO1xuICAgICAgaWYgKGlzVGFibGVDZWxsQ29udGVudFNlbGVjdGVkKGRvbSwgcm5nLCBzdGFydENlbGwpKSB7XG4gICAgICAgIGRlbGV0ZUNlbGxDb250ZW50cyhlZGl0b3IsIHJuZywgU3VnYXJFbGVtZW50LmZyb21Eb20oc3RhcnRDZWxsKSk7XG4gICAgICB9IGVsc2UgaWYgKHJuZy5zdGFydENvbnRhaW5lciA9PT0gcm5nLmVuZENvbnRhaW5lciAmJiBybmcuZW5kT2Zmc2V0IC0gcm5nLnN0YXJ0T2Zmc2V0ID09PSAxICYmIGlzVGV4dCRhKHJuZy5zdGFydENvbnRhaW5lci5jaGlsZE5vZGVzW3JuZy5zdGFydE9mZnNldF0pKSB7XG4gICAgICAgIHJuZy5kZWxldGVDb250ZW50cygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRpdG9yLmdldERvYygpLmV4ZWNDb21tYW5kKCdEZWxldGUnLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBmaW5kTWFya2VyTm9kZSA9IHNjb3BlID0+IHtcbiAgICAgIGZvciAobGV0IG1hcmtlck5vZGUgPSBzY29wZTsgbWFya2VyTm9kZTsgbWFya2VyTm9kZSA9IG1hcmtlck5vZGUud2FsaygpKSB7XG4gICAgICAgIGlmIChtYXJrZXJOb2RlLmF0dHIoJ2lkJykgPT09ICdtY2VfbWFya2VyJykge1xuICAgICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKG1hcmtlck5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgIH07XG4gICAgY29uc3QgaW5zZXJ0SHRtbEF0Q2FyZXQgPSAoZWRpdG9yLCB2YWx1ZSwgZGV0YWlscykgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgICBjb25zdCBkb20gPSBlZGl0b3IuZG9tO1xuICAgICAgY29uc3QgcGFyc2VyID0gZWRpdG9yLnBhcnNlcjtcbiAgICAgIGNvbnN0IG1lcmdlID0gZGV0YWlscy5tZXJnZTtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZXIgPSBIdG1sU2VyaWFsaXplcih7IHZhbGlkYXRlOiB0cnVlIH0sIGVkaXRvci5zY2hlbWEpO1xuICAgICAgY29uc3QgYm9va21hcmtIdG1sID0gJzxzcGFuIGlkPVwibWNlX21hcmtlclwiIGRhdGEtbWNlLXR5cGU9XCJib29rbWFya1wiPiYjeEZFRkY7PC9zcGFuPic7XG4gICAgICBpZiAodmFsdWUuaW5kZXhPZigneyRjYXJldH0nKSA9PT0gLTEpIHtcbiAgICAgICAgdmFsdWUgKz0gJ3skY2FyZXR9JztcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFx7XFwkY2FyZXRcXH0vLCBib29rbWFya0h0bWwpO1xuICAgICAgbGV0IHJuZyA9IHNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgIGNvbnN0IGNhcmV0RWxlbWVudCA9IHJuZy5zdGFydENvbnRhaW5lcjtcbiAgICAgIGNvbnN0IGJvZHkgPSBlZGl0b3IuZ2V0Qm9keSgpO1xuICAgICAgaWYgKGNhcmV0RWxlbWVudCA9PT0gYm9keSAmJiBzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgICBpZiAoZG9tLmlzQmxvY2soYm9keS5maXJzdENoaWxkKSAmJiBjYW5IYXZlQ2hpbGRyZW4oZWRpdG9yLCBib2R5LmZpcnN0Q2hpbGQpICYmIGRvbS5pc0VtcHR5KGJvZHkuZmlyc3RDaGlsZCkpIHtcbiAgICAgICAgICBybmcgPSBkb20uY3JlYXRlUm5nKCk7XG4gICAgICAgICAgcm5nLnNldFN0YXJ0KGJvZHkuZmlyc3RDaGlsZCwgMCk7XG4gICAgICAgICAgcm5nLnNldEVuZChib2R5LmZpcnN0Q2hpbGQsIDApO1xuICAgICAgICAgIHNlbGVjdGlvbi5zZXRSbmcocm5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgICBkZWxldGVTZWxlY3RlZENvbnRlbnQoZWRpdG9yKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBzZWxlY3Rpb24uZ2V0Tm9kZSgpO1xuICAgICAgY29uc3QgcGFyc2VyQXJncyA9IHtcbiAgICAgICAgY29udGV4dDogcGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICBkYXRhOiBkZXRhaWxzLmRhdGEsXG4gICAgICAgIGluc2VydDogdHJ1ZVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGZyYWdtZW50ID0gcGFyc2VyLnBhcnNlKHZhbHVlLCBwYXJzZXJBcmdzKTtcbiAgICAgIGlmIChkZXRhaWxzLnBhc3RlID09PSB0cnVlICYmIGlzTGlzdEZyYWdtZW50KGVkaXRvci5zY2hlbWEsIGZyYWdtZW50KSAmJiBpc1BhcmVudEJsb2NrTGkoZG9tLCBwYXJlbnROb2RlKSkge1xuICAgICAgICBybmcgPSBpbnNlcnRBdENhcmV0JDEoc2VyaWFsaXplciwgZG9tLCBzZWxlY3Rpb24uZ2V0Um5nKCksIGZyYWdtZW50KTtcbiAgICAgICAgaWYgKHJuZykge1xuICAgICAgICAgIHNlbGVjdGlvbi5zZXRSbmcocm5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoZGV0YWlscy5wYXN0ZSA9PT0gdHJ1ZSAmJiBzaG91bGRQYXN0ZUNvbnRlbnRPbmx5KGRvbSwgZnJhZ21lbnQsIHBhcmVudE5vZGUsIGVkaXRvci5nZXRCb2R5KCkpKSB7XG4gICAgICAgIChfYSA9IGZyYWdtZW50LmZpcnN0Q2hpbGQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51bndyYXAoKTtcbiAgICAgIH1cbiAgICAgIG1hcmtGcmFnbWVudEVsZW1lbnRzKGZyYWdtZW50KTtcbiAgICAgIGxldCBub2RlID0gZnJhZ21lbnQubGFzdENoaWxkO1xuICAgICAgaWYgKG5vZGUgJiYgbm9kZS5hdHRyKCdpZCcpID09PSAnbWNlX21hcmtlcicpIHtcbiAgICAgICAgY29uc3QgbWFya2VyID0gbm9kZTtcbiAgICAgICAgZm9yIChub2RlID0gbm9kZS5wcmV2OyBub2RlOyBub2RlID0gbm9kZS53YWxrKHRydWUpKSB7XG4gICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gMyB8fCAhZG9tLmlzQmxvY2sobm9kZS5uYW1lKSkge1xuICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50ICYmIGVkaXRvci5zY2hlbWEuaXNWYWxpZENoaWxkKG5vZGUucGFyZW50Lm5hbWUsICdzcGFuJykpIHtcbiAgICAgICAgICAgICAgbm9kZS5wYXJlbnQuaW5zZXJ0KG1hcmtlciwgbm9kZSwgbm9kZS5uYW1lID09PSAnYnInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWRpdG9yLl9zZWxlY3Rpb25PdmVycmlkZXMuc2hvd0Jsb2NrQ2FyZXRDb250YWluZXIocGFyZW50Tm9kZSk7XG4gICAgICBpZiAoIXBhcnNlckFyZ3MuaW52YWxpZCkge1xuICAgICAgICB2YWx1ZSA9IHNlcmlhbGl6ZXIuc2VyaWFsaXplKGZyYWdtZW50KTtcbiAgICAgICAgdmFsaWRJbnNlcnRpb24oZWRpdG9yLCB2YWx1ZSwgcGFyZW50Tm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldENvbnRlbnQoYm9va21hcmtIdG1sKTtcbiAgICAgICAgbGV0IHBhcmVudE5vZGUgPSBzZWxlY3Rpb24uZ2V0Tm9kZSgpO1xuICAgICAgICBsZXQgdGVtcE5vZGU7XG4gICAgICAgIGNvbnN0IHJvb3ROb2RlID0gZWRpdG9yLmdldEJvZHkoKTtcbiAgICAgICAgaWYgKGlzRG9jdW1lbnQkMShwYXJlbnROb2RlKSkge1xuICAgICAgICAgIHBhcmVudE5vZGUgPSB0ZW1wTm9kZSA9IHJvb3ROb2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRlbXBOb2RlID0gcGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodGVtcE5vZGUgJiYgdGVtcE5vZGUgIT09IHJvb3ROb2RlKSB7XG4gICAgICAgICAgcGFyZW50Tm9kZSA9IHRlbXBOb2RlO1xuICAgICAgICAgIHRlbXBOb2RlID0gdGVtcE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHBhcmVudE5vZGUgPT09IHJvb3ROb2RlID8gcm9vdE5vZGUuaW5uZXJIVE1MIDogZG9tLmdldE91dGVySFRNTChwYXJlbnROb2RlKTtcbiAgICAgICAgY29uc3Qgcm9vdCA9IHBhcnNlci5wYXJzZSh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IG1hcmtlck5vZGUgPSBmaW5kTWFya2VyTm9kZShyb290KTtcbiAgICAgICAgY29uc3QgZWRpdGluZ0hvc3QgPSBtYXJrZXJOb2RlLmJpbmQoZmluZENsb3Nlc3RFZGl0aW5nSG9zdCkuZ2V0T3Iocm9vdCk7XG4gICAgICAgIG1hcmtlck5vZGUuZWFjaChtYXJrZXIgPT4gbWFya2VyLnJlcGxhY2UoZnJhZ21lbnQpKTtcbiAgICAgICAgY29uc3QgdG9FeHRyYWN0ID0gZnJhZ21lbnQuY2hpbGRyZW4oKTtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gKF9iID0gZnJhZ21lbnQucGFyZW50KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiByb290O1xuICAgICAgICBmcmFnbWVudC51bndyYXAoKTtcbiAgICAgICAgY29uc3QgaW52YWxpZENoaWxkcmVuID0gZmlsdGVyJDUodG9FeHRyYWN0LCBub2RlID0+IGlzSW52YWxpZChlZGl0b3Iuc2NoZW1hLCBub2RlLCBwYXJlbnQpKTtcbiAgICAgICAgY2xlYW5JbnZhbGlkTm9kZXMoaW52YWxpZENoaWxkcmVuLCBlZGl0b3Iuc2NoZW1hLCBlZGl0aW5nSG9zdCk7XG4gICAgICAgIGZpbHRlciQyKHBhcnNlci5nZXROb2RlRmlsdGVycygpLCBwYXJzZXIuZ2V0QXR0cmlidXRlRmlsdGVycygpLCByb290KTtcbiAgICAgICAgdmFsdWUgPSBzZXJpYWxpemVyLnNlcmlhbGl6ZShyb290KTtcbiAgICAgICAgaWYgKHBhcmVudE5vZGUgPT09IHJvb3ROb2RlKSB7XG4gICAgICAgICAgZG9tLnNldEhUTUwocm9vdE5vZGUsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb20uc2V0T3V0ZXJIVE1MKHBhcmVudE5vZGUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVkdWNlSW5saW5lVGV4dEVsZW1lbnRzKGVkaXRvciwgbWVyZ2UpO1xuICAgICAgbW92ZVNlbGVjdGlvblRvTWFya2VyKGVkaXRvciwgZG9tLmdldCgnbWNlX21hcmtlcicpKTtcbiAgICAgIHVubWFya0ZyYWdtZW50RWxlbWVudHMoZWRpdG9yLmdldEJvZHkoKSk7XG4gICAgICB0cmltQnJzRnJvbVRhYmxlQ2VsbChkb20sIHNlbGVjdGlvbi5nZXRTdGFydCgpKTtcbiAgICAgIHVwZGF0ZUNhcmV0KGVkaXRvci5zY2hlbWEsIGVkaXRvci5nZXRCb2R5KCksIHNlbGVjdGlvbi5nZXRTdGFydCgpKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgY29uc3QgaXNUcmVlTm9kZSA9IGNvbnRlbnQgPT4gY29udGVudCBpbnN0YW5jZW9mIEFzdE5vZGU7XG5cbiAgICBjb25zdCBtb3ZlU2VsZWN0aW9uID0gZWRpdG9yID0+IHtcbiAgICAgIGlmIChoYXNGb2N1cyhlZGl0b3IpKSB7XG4gICAgICAgIGZpcnN0UG9zaXRpb25JbihlZGl0b3IuZ2V0Qm9keSgpKS5lYWNoKHBvcyA9PiB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IHBvcy5nZXROb2RlKCk7XG4gICAgICAgICAgY29uc3QgY2FyZXRQb3MgPSBpc1RhYmxlJDIobm9kZSkgPyBmaXJzdFBvc2l0aW9uSW4obm9kZSkuZ2V0T3IocG9zKSA6IHBvcztcbiAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFJuZyhjYXJldFBvcy50b1JhbmdlKCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNldEVkaXRvckh0bWwgPSAoZWRpdG9yLCBodG1sLCBub1NlbGVjdGlvbikgPT4ge1xuICAgICAgZWRpdG9yLmRvbS5zZXRIVE1MKGVkaXRvci5nZXRCb2R5KCksIGh0bWwpO1xuICAgICAgaWYgKG5vU2VsZWN0aW9uICE9PSB0cnVlKSB7XG4gICAgICAgIG1vdmVTZWxlY3Rpb24oZWRpdG9yKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNldENvbnRlbnRTdHJpbmcgPSAoZWRpdG9yLCBib2R5LCBjb250ZW50LCBhcmdzKSA9PiB7XG4gICAgICBpZiAoY29udGVudC5sZW5ndGggPT09IDAgfHwgL15cXHMrJC8udGVzdChjb250ZW50KSkge1xuICAgICAgICBjb25zdCBwYWRkID0gJzxiciBkYXRhLW1jZS1ib2d1cz1cIjFcIj4nO1xuICAgICAgICBpZiAoYm9keS5ub2RlTmFtZSA9PT0gJ1RBQkxFJykge1xuICAgICAgICAgIGNvbnRlbnQgPSAnPHRyPjx0ZD4nICsgcGFkZCArICc8L3RkPjwvdHI+JztcbiAgICAgICAgfSBlbHNlIGlmICgvXihVTHxPTCkkLy50ZXN0KGJvZHkubm9kZU5hbWUpKSB7XG4gICAgICAgICAgY29udGVudCA9ICc8bGk+JyArIHBhZGQgKyAnPC9saT4nO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvcmNlZFJvb3RCbG9ja05hbWUgPSBnZXRGb3JjZWRSb290QmxvY2soZWRpdG9yKTtcbiAgICAgICAgaWYgKGVkaXRvci5zY2hlbWEuaXNWYWxpZENoaWxkKGJvZHkubm9kZU5hbWUudG9Mb3dlckNhc2UoKSwgZm9yY2VkUm9vdEJsb2NrTmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgIGNvbnRlbnQgPSBwYWRkO1xuICAgICAgICAgIGNvbnRlbnQgPSBlZGl0b3IuZG9tLmNyZWF0ZUhUTUwoZm9yY2VkUm9vdEJsb2NrTmFtZSwgZ2V0Rm9yY2VkUm9vdEJsb2NrQXR0cnMoZWRpdG9yKSwgY29udGVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWNvbnRlbnQpIHtcbiAgICAgICAgICBjb250ZW50ID0gcGFkZDtcbiAgICAgICAgfVxuICAgICAgICBzZXRFZGl0b3JIdG1sKGVkaXRvciwgY29udGVudCwgYXJncy5ub19zZWxlY3Rpb24pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgaHRtbDogY29udGVudFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGFyZ3MuZm9ybWF0ICE9PSAncmF3Jykge1xuICAgICAgICAgIGNvbnRlbnQgPSBIdG1sU2VyaWFsaXplcih7IHZhbGlkYXRlOiBmYWxzZSB9LCBlZGl0b3Iuc2NoZW1hKS5zZXJpYWxpemUoZWRpdG9yLnBhcnNlci5wYXJzZShjb250ZW50LCB7XG4gICAgICAgICAgICBpc1Jvb3RDb250ZW50OiB0cnVlLFxuICAgICAgICAgICAgaW5zZXJ0OiB0cnVlXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyaW1tZWRIdG1sID0gaXNXc1ByZXNlcnZlRWxlbWVudChTdWdhckVsZW1lbnQuZnJvbURvbShib2R5KSkgPyBjb250ZW50IDogVG9vbHMudHJpbShjb250ZW50KTtcbiAgICAgICAgc2V0RWRpdG9ySHRtbChlZGl0b3IsIHRyaW1tZWRIdG1sLCBhcmdzLm5vX3NlbGVjdGlvbik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY29udGVudDogdHJpbW1lZEh0bWwsXG4gICAgICAgICAgaHRtbDogdHJpbW1lZEh0bWxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNldENvbnRlbnRUcmVlID0gKGVkaXRvciwgYm9keSwgY29udGVudCwgYXJncykgPT4ge1xuICAgICAgZmlsdGVyJDIoZWRpdG9yLnBhcnNlci5nZXROb2RlRmlsdGVycygpLCBlZGl0b3IucGFyc2VyLmdldEF0dHJpYnV0ZUZpbHRlcnMoKSwgY29udGVudCk7XG4gICAgICBjb25zdCBodG1sID0gSHRtbFNlcmlhbGl6ZXIoeyB2YWxpZGF0ZTogZmFsc2UgfSwgZWRpdG9yLnNjaGVtYSkuc2VyaWFsaXplKGNvbnRlbnQpO1xuICAgICAgY29uc3QgdHJpbW1lZEh0bWwgPSBpc1dzUHJlc2VydmVFbGVtZW50KFN1Z2FyRWxlbWVudC5mcm9tRG9tKGJvZHkpKSA/IGh0bWwgOiBUb29scy50cmltKGh0bWwpO1xuICAgICAgc2V0RWRpdG9ySHRtbChlZGl0b3IsIHRyaW1tZWRIdG1sLCBhcmdzLm5vX3NlbGVjdGlvbik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb250ZW50LFxuICAgICAgICBodG1sOiB0cmltbWVkSHRtbFxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IHNldENvbnRlbnRJbnRlcm5hbCA9IChlZGl0b3IsIGNvbnRlbnQsIGFyZ3MpID0+IHtcbiAgICAgIHJldHVybiBPcHRpb25hbC5mcm9tKGVkaXRvci5nZXRCb2R5KCkpLm1hcChib2R5ID0+IHtcbiAgICAgICAgaWYgKGlzVHJlZU5vZGUoY29udGVudCkpIHtcbiAgICAgICAgICByZXR1cm4gc2V0Q29udGVudFRyZWUoZWRpdG9yLCBib2R5LCBjb250ZW50LCBhcmdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc2V0Q29udGVudFN0cmluZyhlZGl0b3IsIGJvZHksIGNvbnRlbnQsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9KS5nZXRPcih7XG4gICAgICAgIGNvbnRlbnQsXG4gICAgICAgIGh0bWw6IGlzVHJlZU5vZGUoYXJncy5jb250ZW50KSA/ICcnIDogYXJncy5jb250ZW50XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgYW5jZXN0b3IkMSA9IChzY29wZSwgcHJlZGljYXRlLCBpc1Jvb3QpID0+IGFuY2VzdG9yJDQoc2NvcGUsIHByZWRpY2F0ZSwgaXNSb290KS5pc1NvbWUoKTtcbiAgICBjb25zdCBzaWJsaW5nID0gKHNjb3BlLCBwcmVkaWNhdGUpID0+IHNpYmxpbmckMShzY29wZSwgcHJlZGljYXRlKS5pc1NvbWUoKTtcblxuICAgIGNvbnN0IGVuc3VyZUlzUm9vdCA9IGlzUm9vdCA9PiBpc0Z1bmN0aW9uKGlzUm9vdCkgPyBpc1Jvb3QgOiBuZXZlcjtcbiAgICBjb25zdCBhbmNlc3RvciA9IChzY29wZSwgdHJhbnNmb3JtLCBpc1Jvb3QpID0+IHtcbiAgICAgIGxldCBlbGVtZW50ID0gc2NvcGUuZG9tO1xuICAgICAgY29uc3Qgc3RvcCA9IGVuc3VyZUlzUm9vdChpc1Jvb3QpO1xuICAgICAgd2hpbGUgKGVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICBjb25zdCBlbCA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVsZW1lbnQpO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZCA9IHRyYW5zZm9ybShlbCk7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1lZC5pc1NvbWUoKSkge1xuICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZDtcbiAgICAgICAgfSBlbHNlIGlmIChzdG9wKGVsKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgIH07XG4gICAgY29uc3QgY2xvc2VzdCQxID0gKHNjb3BlLCB0cmFuc2Zvcm0sIGlzUm9vdCkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudCA9IHRyYW5zZm9ybShzY29wZSk7XG4gICAgICBjb25zdCBzdG9wID0gZW5zdXJlSXNSb290KGlzUm9vdCk7XG4gICAgICByZXR1cm4gY3VycmVudC5vclRodW5rKCgpID0+IHN0b3Aoc2NvcGUpID8gT3B0aW9uYWwubm9uZSgpIDogYW5jZXN0b3Ioc2NvcGUsIHRyYW5zZm9ybSwgc3RvcCkpO1xuICAgIH07XG5cbiAgICBjb25zdCBpc0VxJDMgPSBpc0VxJDU7XG4gICAgY29uc3QgbWF0Y2hlc1VuSW5oZXJpdGVkRm9ybWF0U2VsZWN0b3IgPSAoZWQsIG5vZGUsIG5hbWUpID0+IHtcbiAgICAgIGNvbnN0IGZvcm1hdExpc3QgPSBlZC5mb3JtYXR0ZXIuZ2V0KG5hbWUpO1xuICAgICAgaWYgKGZvcm1hdExpc3QpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmb3JtYXRMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgZm9ybWF0ID0gZm9ybWF0TGlzdFtpXTtcbiAgICAgICAgICBpZiAoaXNTZWxlY3RvckZvcm1hdChmb3JtYXQpICYmIGZvcm1hdC5pbmhlcml0ID09PSBmYWxzZSAmJiBlZC5kb20uaXMobm9kZSwgZm9ybWF0LnNlbGVjdG9yKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBjb25zdCBtYXRjaFBhcmVudHMgPSAoZWRpdG9yLCBub2RlLCBuYW1lLCB2YXJzLCBzaW1pbGFyKSA9PiB7XG4gICAgICBjb25zdCByb290ID0gZWRpdG9yLmRvbS5nZXRSb290KCk7XG4gICAgICBpZiAobm9kZSA9PT0gcm9vdCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBtYXRjaGVkTm9kZSA9IGVkaXRvci5kb20uZ2V0UGFyZW50KG5vZGUsIGVsbSA9PiB7XG4gICAgICAgIGlmIChtYXRjaGVzVW5Jbmhlcml0ZWRGb3JtYXRTZWxlY3RvcihlZGl0b3IsIGVsbSwgbmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxtLnBhcmVudE5vZGUgPT09IHJvb3QgfHwgISFtYXRjaE5vZGUoZWRpdG9yLCBlbG0sIG5hbWUsIHZhcnMsIHRydWUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gISFtYXRjaE5vZGUoZWRpdG9yLCBtYXRjaGVkTm9kZSwgbmFtZSwgdmFycywgc2ltaWxhcik7XG4gICAgfTtcbiAgICBjb25zdCBtYXRjaE5hbWUgPSAoZG9tLCBub2RlLCBmb3JtYXQpID0+IHtcbiAgICAgIGlmIChpc0lubGluZUZvcm1hdChmb3JtYXQpICYmIGlzRXEkMyhub2RlLCBmb3JtYXQuaW5saW5lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0Jsb2NrRm9ybWF0KGZvcm1hdCkgJiYgaXNFcSQzKG5vZGUsIGZvcm1hdC5ibG9jaykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNTZWxlY3RvckZvcm1hdChmb3JtYXQpKSB7XG4gICAgICAgIHJldHVybiBpc0VsZW1lbnQkNihub2RlKSAmJiBkb20uaXMobm9kZSwgZm9ybWF0LnNlbGVjdG9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGNvbnN0IG1hdGNoSXRlbXMgPSAoZG9tLCBub2RlLCBmb3JtYXQsIGl0ZW1OYW1lLCBzaW1pbGFyLCB2YXJzKSA9PiB7XG4gICAgICBjb25zdCBpdGVtcyA9IGZvcm1hdFtpdGVtTmFtZV07XG4gICAgICBjb25zdCBtYXRjaEF0dHJpYnV0ZXMgPSBpdGVtTmFtZSA9PT0gJ2F0dHJpYnV0ZXMnO1xuICAgICAgaWYgKGlzRnVuY3Rpb24oZm9ybWF0Lm9ubWF0Y2gpKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXQub25tYXRjaChub2RlLCBmb3JtYXQsIGl0ZW1OYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtcykge1xuICAgICAgICBpZiAoIWlzQXJyYXlMaWtlKGl0ZW1zKSkge1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGl0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoaGFzJDIoaXRlbXMsIGtleSkpIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBtYXRjaEF0dHJpYnV0ZXMgPyBkb20uZ2V0QXR0cmliKG5vZGUsIGtleSkgOiBnZXRTdHlsZShkb20sIG5vZGUsIGtleSk7XG4gICAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWUgPSByZXBsYWNlVmFycyhpdGVtc1trZXldLCB2YXJzKTtcbiAgICAgICAgICAgICAgY29uc3QgaXNFbXB0eVZhbHVlID0gaXNOdWxsYWJsZSh2YWx1ZSkgfHwgaXNFbXB0eSQzKHZhbHVlKTtcbiAgICAgICAgICAgICAgaWYgKGlzRW1wdHlWYWx1ZSAmJiBpc051bGxhYmxlKGV4cGVjdGVkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHNpbWlsYXIgJiYgaXNFbXB0eVZhbHVlICYmICFmb3JtYXQuZXhhY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCghc2ltaWxhciB8fCBmb3JtYXQuZXhhY3QpICYmICFpc0VxJDModmFsdWUsIG5vcm1hbGl6ZVN0eWxlVmFsdWUoZXhwZWN0ZWRWYWx1ZSwga2V5KSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG1hdGNoQXR0cmlidXRlcyA/IGRvbS5nZXRBdHRyaWIobm9kZSwgaXRlbXNbaV0pIDogZ2V0U3R5bGUoZG9tLCBub2RlLCBpdGVtc1tpXSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIGNvbnN0IG1hdGNoTm9kZSA9IChlZCwgbm9kZSwgbmFtZSwgdmFycywgc2ltaWxhcikgPT4ge1xuICAgICAgY29uc3QgZm9ybWF0TGlzdCA9IGVkLmZvcm1hdHRlci5nZXQobmFtZSk7XG4gICAgICBjb25zdCBkb20gPSBlZC5kb207XG4gICAgICBpZiAoZm9ybWF0TGlzdCAmJiBpc0VsZW1lbnQkNihub2RlKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZvcm1hdExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBmb3JtYXQgPSBmb3JtYXRMaXN0W2ldO1xuICAgICAgICAgIGlmIChtYXRjaE5hbWUoZWQuZG9tLCBub2RlLCBmb3JtYXQpICYmIG1hdGNoSXRlbXMoZG9tLCBub2RlLCBmb3JtYXQsICdhdHRyaWJ1dGVzJywgc2ltaWxhciwgdmFycykgJiYgbWF0Y2hJdGVtcyhkb20sIG5vZGUsIGZvcm1hdCwgJ3N0eWxlcycsIHNpbWlsYXIsIHZhcnMpKSB7XG4gICAgICAgICAgICBjb25zdCBjbGFzc2VzID0gZm9ybWF0LmNsYXNzZXM7XG4gICAgICAgICAgICBpZiAoY2xhc3Nlcykge1xuICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IGNsYXNzZXMubGVuZ3RoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVkLmRvbS5oYXNDbGFzcyhub2RlLCByZXBsYWNlVmFycyhjbGFzc2VzW3hdLCB2YXJzKSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgY29uc3QgbWF0Y2gkMiA9IChlZGl0b3IsIG5hbWUsIHZhcnMsIG5vZGUsIHNpbWlsYXIpID0+IHtcbiAgICAgIGlmIChub2RlKSB7XG4gICAgICAgIHJldHVybiBtYXRjaFBhcmVudHMoZWRpdG9yLCBub2RlLCBuYW1lLCB2YXJzLCBzaW1pbGFyKTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldE5vZGUoKTtcbiAgICAgIGlmIChtYXRjaFBhcmVudHMoZWRpdG9yLCBub2RlLCBuYW1lLCB2YXJzLCBzaW1pbGFyKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXJ0Tm9kZSA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0U3RhcnQoKTtcbiAgICAgIGlmIChzdGFydE5vZGUgIT09IG5vZGUpIHtcbiAgICAgICAgaWYgKG1hdGNoUGFyZW50cyhlZGl0b3IsIHN0YXJ0Tm9kZSwgbmFtZSwgdmFycywgc2ltaWxhcikpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgY29uc3QgbWF0Y2hBbGwgPSAoZWRpdG9yLCBuYW1lcywgdmFycykgPT4ge1xuICAgICAgY29uc3QgbWF0Y2hlZEZvcm1hdE5hbWVzID0gW107XG4gICAgICBjb25zdCBjaGVja2VkTWFwID0ge307XG4gICAgICBjb25zdCBzdGFydEVsZW1lbnQgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFN0YXJ0KCk7XG4gICAgICBlZGl0b3IuZG9tLmdldFBhcmVudChzdGFydEVsZW1lbnQsIG5vZGUgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICAgIGlmICghY2hlY2tlZE1hcFtuYW1lXSAmJiBtYXRjaE5vZGUoZWRpdG9yLCBub2RlLCBuYW1lLCB2YXJzKSkge1xuICAgICAgICAgICAgY2hlY2tlZE1hcFtuYW1lXSA9IHRydWU7XG4gICAgICAgICAgICBtYXRjaGVkRm9ybWF0TmFtZXMucHVzaChuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIGVkaXRvci5kb20uZ2V0Um9vdCgpKTtcbiAgICAgIHJldHVybiBtYXRjaGVkRm9ybWF0TmFtZXM7XG4gICAgfTtcbiAgICBjb25zdCBjbG9zZXN0ID0gKGVkaXRvciwgbmFtZXMpID0+IHtcbiAgICAgIGNvbnN0IGlzUm9vdCA9IGVsbSA9PiBlcShlbG0sIFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRCb2R5KCkpKTtcbiAgICAgIGNvbnN0IG1hdGNoID0gKGVsbSwgbmFtZSkgPT4gbWF0Y2hOb2RlKGVkaXRvciwgZWxtLmRvbSwgbmFtZSkgPyBPcHRpb25hbC5zb21lKG5hbWUpIDogT3B0aW9uYWwubm9uZSgpO1xuICAgICAgcmV0dXJuIE9wdGlvbmFsLmZyb20oZWRpdG9yLnNlbGVjdGlvbi5nZXRTdGFydCh0cnVlKSkuYmluZChyYXdFbG0gPT4gY2xvc2VzdCQxKFN1Z2FyRWxlbWVudC5mcm9tRG9tKHJhd0VsbSksIGVsbSA9PiBmaW5kTWFwKG5hbWVzLCBuYW1lID0+IG1hdGNoKGVsbSwgbmFtZSkpLCBpc1Jvb3QpKS5nZXRPck51bGwoKTtcbiAgICB9O1xuICAgIGNvbnN0IGNhbkFwcGx5ID0gKGVkaXRvciwgbmFtZSkgPT4ge1xuICAgICAgY29uc3QgZm9ybWF0TGlzdCA9IGVkaXRvci5mb3JtYXR0ZXIuZ2V0KG5hbWUpO1xuICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbTtcbiAgICAgIGlmIChmb3JtYXRMaXN0KSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0Tm9kZSA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0U3RhcnQoKTtcbiAgICAgICAgY29uc3QgcGFyZW50cyA9IGdldFBhcmVudHMkMihkb20sIHN0YXJ0Tm9kZSk7XG4gICAgICAgIGZvciAobGV0IHggPSBmb3JtYXRMaXN0Lmxlbmd0aCAtIDE7IHggPj0gMDsgeC0tKSB7XG4gICAgICAgICAgY29uc3QgZm9ybWF0ID0gZm9ybWF0TGlzdFt4XTtcbiAgICAgICAgICBpZiAoIWlzU2VsZWN0b3JGb3JtYXQoZm9ybWF0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAobGV0IGkgPSBwYXJlbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAoZG9tLmlzKHBhcmVudHNbaV0sIGZvcm1hdC5zZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBjb25zdCBtYXRjaEFsbE9uTm9kZSA9IChlZGl0b3IsIG5vZGUsIGZvcm1hdE5hbWVzKSA9PiBmb2xkbChmb3JtYXROYW1lcywgKGFjYywgbmFtZSkgPT4ge1xuICAgICAgY29uc3QgbWF0Y2hTaW1pbGFyID0gaXNWYXJpYWJsZUZvcm1hdE5hbWUoZWRpdG9yLCBuYW1lKTtcbiAgICAgIGlmIChlZGl0b3IuZm9ybWF0dGVyLm1hdGNoTm9kZShub2RlLCBuYW1lLCB7fSwgbWF0Y2hTaW1pbGFyKSkge1xuICAgICAgICByZXR1cm4gYWNjLmNvbmNhdChbbmFtZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBaV1NQID0gWldTUCQxO1xuICAgIGNvbnN0IGltcG9ydE5vZGUgPSAob3duZXJEb2N1bWVudCwgbm9kZSkgPT4ge1xuICAgICAgcmV0dXJuIG93bmVyRG9jdW1lbnQuaW1wb3J0Tm9kZShub2RlLCB0cnVlKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldEVtcHR5Q2FyZXRDb250YWluZXJzID0gbm9kZSA9PiB7XG4gICAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgICAgbGV0IHRlbXBOb2RlID0gbm9kZTtcbiAgICAgIHdoaWxlICh0ZW1wTm9kZSkge1xuICAgICAgICBpZiAoaXNUZXh0JGEodGVtcE5vZGUpICYmIHRlbXBOb2RlLmRhdGEgIT09IFpXU1AgfHwgdGVtcE5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0VsZW1lbnQkNih0ZW1wTm9kZSkpIHtcbiAgICAgICAgICBub2Rlcy5wdXNoKHRlbXBOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0ZW1wTm9kZSA9IHRlbXBOb2RlLmZpcnN0Q2hpbGQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZXM7XG4gICAgfTtcbiAgICBjb25zdCBpc0NhcmV0Q29udGFpbmVyRW1wdHkgPSBub2RlID0+IHtcbiAgICAgIHJldHVybiBnZXRFbXB0eUNhcmV0Q29udGFpbmVycyhub2RlKS5sZW5ndGggPiAwO1xuICAgIH07XG4gICAgY29uc3QgZmluZEZpcnN0VGV4dE5vZGUgPSBub2RlID0+IHtcbiAgICAgIGlmIChub2RlKSB7XG4gICAgICAgIGNvbnN0IHdhbGtlciA9IG5ldyBEb21UcmVlV2Fsa2VyKG5vZGUsIG5vZGUpO1xuICAgICAgICBmb3IgKGxldCB0ZW1wTm9kZSA9IHdhbGtlci5jdXJyZW50KCk7IHRlbXBOb2RlOyB0ZW1wTm9kZSA9IHdhbGtlci5uZXh0KCkpIHtcbiAgICAgICAgICBpZiAoaXNUZXh0JGEodGVtcE5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGVtcE5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZUNhcmV0Q29udGFpbmVyID0gZmlsbCA9PiB7XG4gICAgICBjb25zdCBjYXJldENvbnRhaW5lciA9IFN1Z2FyRWxlbWVudC5mcm9tVGFnKCdzcGFuJyk7XG4gICAgICBzZXRBbGwkMShjYXJldENvbnRhaW5lciwge1xuICAgICAgICAnaWQnOiBDQVJFVF9JRCxcbiAgICAgICAgJ2RhdGEtbWNlLWJvZ3VzJzogJzEnLFxuICAgICAgICAnZGF0YS1tY2UtdHlwZSc6ICdmb3JtYXQtY2FyZXQnXG4gICAgICB9KTtcbiAgICAgIGlmIChmaWxsKSB7XG4gICAgICAgIGFwcGVuZCQxKGNhcmV0Q29udGFpbmVyLCBTdWdhckVsZW1lbnQuZnJvbVRleHQoWldTUCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhcmV0Q29udGFpbmVyO1xuICAgIH07XG4gICAgY29uc3QgdHJpbVp3c3BGcm9tQ2FyZXRDb250YWluZXIgPSBjYXJldENvbnRhaW5lck5vZGUgPT4ge1xuICAgICAgY29uc3QgdGV4dE5vZGUgPSBmaW5kRmlyc3RUZXh0Tm9kZShjYXJldENvbnRhaW5lck5vZGUpO1xuICAgICAgaWYgKHRleHROb2RlICYmIHRleHROb2RlLmRhdGEuY2hhckF0KDApID09PSBaV1NQKSB7XG4gICAgICAgIHRleHROb2RlLmRlbGV0ZURhdGEoMCwgMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGV4dE5vZGU7XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVDYXJldENvbnRhaW5lck5vZGUgPSAoZWRpdG9yLCBub2RlLCBtb3ZlQ2FyZXQgPSB0cnVlKSA9PiB7XG4gICAgICBjb25zdCBkb20gPSBlZGl0b3IuZG9tLCBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICAgICAgaWYgKGlzQ2FyZXRDb250YWluZXJFbXB0eShub2RlKSkge1xuICAgICAgICBkZWxldGVFbGVtZW50JDIoZWRpdG9yLCBmYWxzZSwgU3VnYXJFbGVtZW50LmZyb21Eb20obm9kZSksIG1vdmVDYXJldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBybmcgPSBzZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gZG9tLmdldFBhcmVudChub2RlLCBkb20uaXNCbG9jayk7XG4gICAgICAgIGNvbnN0IHN0YXJ0Q29udGFpbmVyID0gcm5nLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgICBjb25zdCBzdGFydE9mZnNldCA9IHJuZy5zdGFydE9mZnNldDtcbiAgICAgICAgY29uc3QgZW5kQ29udGFpbmVyID0gcm5nLmVuZENvbnRhaW5lcjtcbiAgICAgICAgY29uc3QgZW5kT2Zmc2V0ID0gcm5nLmVuZE9mZnNldDtcbiAgICAgICAgY29uc3QgdGV4dE5vZGUgPSB0cmltWndzcEZyb21DYXJldENvbnRhaW5lcihub2RlKTtcbiAgICAgICAgZG9tLnJlbW92ZShub2RlLCB0cnVlKTtcbiAgICAgICAgaWYgKHN0YXJ0Q29udGFpbmVyID09PSB0ZXh0Tm9kZSAmJiBzdGFydE9mZnNldCA+IDApIHtcbiAgICAgICAgICBybmcuc2V0U3RhcnQodGV4dE5vZGUsIHN0YXJ0T2Zmc2V0IC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZENvbnRhaW5lciA9PT0gdGV4dE5vZGUgJiYgZW5kT2Zmc2V0ID4gMCkge1xuICAgICAgICAgIHJuZy5zZXRFbmQodGV4dE5vZGUsIGVuZE9mZnNldCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChibG9jayAmJiBkb20uaXNFbXB0eShibG9jaykpIHtcbiAgICAgICAgICBmaWxsV2l0aFBhZGRpbmdCcihTdWdhckVsZW1lbnQuZnJvbURvbShibG9jaykpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGVjdGlvbi5zZXRSbmcocm5nKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZUNhcmV0Q29udGFpbmVyID0gKGVkaXRvciwgbm9kZSwgbW92ZUNhcmV0ID0gdHJ1ZSkgPT4ge1xuICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbSwgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICBub2RlID0gZ2V0UGFyZW50Q2FyZXRDb250YWluZXIoZWRpdG9yLmdldEJvZHkoKSwgc2VsZWN0aW9uLmdldFN0YXJ0KCkpO1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICB3aGlsZSAobm9kZSA9IGRvbS5nZXQoQ0FSRVRfSUQpKSB7XG4gICAgICAgICAgICByZW1vdmVDYXJldENvbnRhaW5lck5vZGUoZWRpdG9yLCBub2RlLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1vdmVDYXJldENvbnRhaW5lck5vZGUoZWRpdG9yLCBub2RlLCBtb3ZlQ2FyZXQpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaW5zZXJ0Q2FyZXRDb250YWluZXJOb2RlID0gKGVkaXRvciwgY2FyZXRDb250YWluZXIsIGZvcm1hdE5vZGUpID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBjb25zdCBkb20gPSBlZGl0b3IuZG9tO1xuICAgICAgY29uc3QgYmxvY2sgPSBkb20uZ2V0UGFyZW50KGZvcm1hdE5vZGUsIGN1cnJ5KGlzVGV4dEJsb2NrJDEsIGVkaXRvci5zY2hlbWEpKTtcbiAgICAgIGlmIChibG9jayAmJiBkb20uaXNFbXB0eShibG9jaykpIHtcbiAgICAgICAgKF9hID0gZm9ybWF0Tm9kZS5wYXJlbnROb2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVwbGFjZUNoaWxkKGNhcmV0Q29udGFpbmVyLCBmb3JtYXROb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZVRyYWlsaW5nQnIoU3VnYXJFbGVtZW50LmZyb21Eb20oZm9ybWF0Tm9kZSkpO1xuICAgICAgICBpZiAoZG9tLmlzRW1wdHkoZm9ybWF0Tm9kZSkpIHtcbiAgICAgICAgICAoX2IgPSBmb3JtYXROb2RlLnBhcmVudE5vZGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZXBsYWNlQ2hpbGQoY2FyZXRDb250YWluZXIsIGZvcm1hdE5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvbS5pbnNlcnRBZnRlcihjYXJldENvbnRhaW5lciwgZm9ybWF0Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGFwcGVuZE5vZGUgPSAocGFyZW50Tm9kZSwgbm9kZSkgPT4ge1xuICAgICAgcGFyZW50Tm9kZS5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gICAgY29uc3QgaW5zZXJ0Rm9ybWF0Tm9kZXNJbnRvQ2FyZXRDb250YWluZXIgPSAoZm9ybWF0Tm9kZXMsIGNhcmV0Q29udGFpbmVyKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBpbm5lck1vc3RGb3JtYXROb2RlID0gZm9sZHIoZm9ybWF0Tm9kZXMsIChwYXJlbnROb2RlLCBmb3JtYXROb2RlKSA9PiB7XG4gICAgICAgIHJldHVybiBhcHBlbmROb2RlKHBhcmVudE5vZGUsIGZvcm1hdE5vZGUuY2xvbmVOb2RlKGZhbHNlKSk7XG4gICAgICB9LCBjYXJldENvbnRhaW5lcik7XG4gICAgICBjb25zdCBkb2MgPSAoX2EgPSBpbm5lck1vc3RGb3JtYXROb2RlLm93bmVyRG9jdW1lbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRvY3VtZW50O1xuICAgICAgcmV0dXJuIGFwcGVuZE5vZGUoaW5uZXJNb3N0Rm9ybWF0Tm9kZSwgZG9jLmNyZWF0ZVRleHROb2RlKFpXU1ApKTtcbiAgICB9O1xuICAgIGNvbnN0IGNsZWFuRm9ybWF0Tm9kZSA9IChlZGl0b3IsIGNhcmV0Q29udGFpbmVyLCBmb3JtYXROb2RlLCBuYW1lLCB2YXJzLCBzaW1pbGFyKSA9PiB7XG4gICAgICBjb25zdCBmb3JtYXR0ZXIgPSBlZGl0b3IuZm9ybWF0dGVyO1xuICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbTtcbiAgICAgIGNvbnN0IHZhbGlkRm9ybWF0cyA9IGZpbHRlciQ1KGtleXMoZm9ybWF0dGVyLmdldCgpKSwgZm9ybWF0TmFtZSA9PiBmb3JtYXROYW1lICE9PSBuYW1lICYmICFjb250YWlucyQxKGZvcm1hdE5hbWUsICdyZW1vdmVmb3JtYXQnKSk7XG4gICAgICBjb25zdCBtYXRjaGVkRm9ybWF0cyA9IG1hdGNoQWxsT25Ob2RlKGVkaXRvciwgZm9ybWF0Tm9kZSwgdmFsaWRGb3JtYXRzKTtcbiAgICAgIGNvbnN0IHVuaXF1ZUZvcm1hdHMgPSBmaWx0ZXIkNShtYXRjaGVkRm9ybWF0cywgZm10TmFtZSA9PiAhYXJlU2ltaWxhckZvcm1hdHMoZWRpdG9yLCBmbXROYW1lLCBuYW1lKSk7XG4gICAgICBpZiAodW5pcXVlRm9ybWF0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGNsb25lZEZvcm1hdE5vZGUgPSBmb3JtYXROb2RlLmNsb25lTm9kZShmYWxzZSk7XG4gICAgICAgIGRvbS5hZGQoY2FyZXRDb250YWluZXIsIGNsb25lZEZvcm1hdE5vZGUpO1xuICAgICAgICBmb3JtYXR0ZXIucmVtb3ZlKG5hbWUsIHZhcnMsIGNsb25lZEZvcm1hdE5vZGUsIHNpbWlsYXIpO1xuICAgICAgICBkb20ucmVtb3ZlKGNsb25lZEZvcm1hdE5vZGUpO1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShjbG9uZWRGb3JtYXROb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBhcHBseUNhcmV0Rm9ybWF0ID0gKGVkaXRvciwgbmFtZSwgdmFycykgPT4ge1xuICAgICAgbGV0IGNhcmV0Q29udGFpbmVyO1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgICAgIGNvbnN0IGZvcm1hdExpc3QgPSBlZGl0b3IuZm9ybWF0dGVyLmdldChuYW1lKTtcbiAgICAgIGlmICghZm9ybWF0TGlzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzZWxlY3Rpb25SbmcgPSBzZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICBsZXQgb2Zmc2V0ID0gc2VsZWN0aW9uUm5nLnN0YXJ0T2Zmc2V0O1xuICAgICAgY29uc3QgY29udGFpbmVyID0gc2VsZWN0aW9uUm5nLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgY29uc3QgdGV4dCA9IGNvbnRhaW5lci5ub2RlVmFsdWU7XG4gICAgICBjYXJldENvbnRhaW5lciA9IGdldFBhcmVudENhcmV0Q29udGFpbmVyKGVkaXRvci5nZXRCb2R5KCksIHNlbGVjdGlvbi5nZXRTdGFydCgpKTtcbiAgICAgIGNvbnN0IHdvcmRjaGFyUmVnZXggPSAvW15cXHNcXHUwMGEwXFx1MDBhZFxcdTIwMGJcXHVmZWZmXS87XG4gICAgICBpZiAodGV4dCAmJiBvZmZzZXQgPiAwICYmIG9mZnNldCA8IHRleHQubGVuZ3RoICYmIHdvcmRjaGFyUmVnZXgudGVzdCh0ZXh0LmNoYXJBdChvZmZzZXQpKSAmJiB3b3JkY2hhclJlZ2V4LnRlc3QodGV4dC5jaGFyQXQob2Zmc2V0IC0gMSkpKSB7XG4gICAgICAgIGNvbnN0IGJvb2ttYXJrID0gc2VsZWN0aW9uLmdldEJvb2ttYXJrKCk7XG4gICAgICAgIHNlbGVjdGlvblJuZy5jb2xsYXBzZSh0cnVlKTtcbiAgICAgICAgbGV0IHJuZyA9IGV4cGFuZFJuZyhlZGl0b3IuZG9tLCBzZWxlY3Rpb25SbmcsIGZvcm1hdExpc3QpO1xuICAgICAgICBybmcgPSBzcGxpdChybmcpO1xuICAgICAgICBlZGl0b3IuZm9ybWF0dGVyLmFwcGx5KG5hbWUsIHZhcnMsIHJuZyk7XG4gICAgICAgIHNlbGVjdGlvbi5tb3ZlVG9Cb29rbWFyayhib29rbWFyayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgdGV4dE5vZGUgPSBjYXJldENvbnRhaW5lciA/IGZpbmRGaXJzdFRleHROb2RlKGNhcmV0Q29udGFpbmVyKSA6IG51bGw7XG4gICAgICAgIGlmICghY2FyZXRDb250YWluZXIgfHwgKHRleHROb2RlID09PSBudWxsIHx8IHRleHROb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0ZXh0Tm9kZS5kYXRhKSAhPT0gWldTUCkge1xuICAgICAgICAgIGNhcmV0Q29udGFpbmVyID0gaW1wb3J0Tm9kZShlZGl0b3IuZ2V0RG9jKCksIGNyZWF0ZUNhcmV0Q29udGFpbmVyKHRydWUpLmRvbSk7XG4gICAgICAgICAgdGV4dE5vZGUgPSBjYXJldENvbnRhaW5lci5maXJzdENoaWxkO1xuICAgICAgICAgIHNlbGVjdGlvblJuZy5pbnNlcnROb2RlKGNhcmV0Q29udGFpbmVyKTtcbiAgICAgICAgICBvZmZzZXQgPSAxO1xuICAgICAgICAgIGVkaXRvci5mb3JtYXR0ZXIuYXBwbHkobmFtZSwgdmFycywgY2FyZXRDb250YWluZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVkaXRvci5mb3JtYXR0ZXIuYXBwbHkobmFtZSwgdmFycywgY2FyZXRDb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGVjdGlvbi5zZXRDdXJzb3JMb2NhdGlvbih0ZXh0Tm9kZSwgb2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZUNhcmV0Rm9ybWF0ID0gKGVkaXRvciwgbmFtZSwgdmFycywgc2ltaWxhcikgPT4ge1xuICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbTtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgICBsZXQgaGFzQ29udGVudEFmdGVyID0gZmFsc2U7XG4gICAgICBjb25zdCBmb3JtYXRMaXN0ID0gZWRpdG9yLmZvcm1hdHRlci5nZXQobmFtZSk7XG4gICAgICBpZiAoIWZvcm1hdExpc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgcm5nID0gc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgY29uc3QgY29udGFpbmVyID0gcm5nLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gcm5nLnN0YXJ0T2Zmc2V0O1xuICAgICAgbGV0IG5vZGUgPSBjb250YWluZXI7XG4gICAgICBpZiAoaXNUZXh0JGEoY29udGFpbmVyKSkge1xuICAgICAgICBpZiAob2Zmc2V0ICE9PSBjb250YWluZXIuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICBoYXNDb250ZW50QWZ0ZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJlbnRzID0gW107XG4gICAgICBsZXQgZm9ybWF0Tm9kZTtcbiAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGlmIChtYXRjaE5vZGUoZWRpdG9yLCBub2RlLCBuYW1lLCB2YXJzLCBzaW1pbGFyKSkge1xuICAgICAgICAgIGZvcm1hdE5vZGUgPSBub2RlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgaGFzQ29udGVudEFmdGVyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnRzLnB1c2gobm9kZSk7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgICBpZiAoIWZvcm1hdE5vZGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGhhc0NvbnRlbnRBZnRlcikge1xuICAgICAgICBjb25zdCBib29rbWFyayA9IHNlbGVjdGlvbi5nZXRCb29rbWFyaygpO1xuICAgICAgICBybmcuY29sbGFwc2UodHJ1ZSk7XG4gICAgICAgIGxldCBleHBhbmRlZFJuZyA9IGV4cGFuZFJuZyhkb20sIHJuZywgZm9ybWF0TGlzdCwgdHJ1ZSk7XG4gICAgICAgIGV4cGFuZGVkUm5nID0gc3BsaXQoZXhwYW5kZWRSbmcpO1xuICAgICAgICBlZGl0b3IuZm9ybWF0dGVyLnJlbW92ZShuYW1lLCB2YXJzLCBleHBhbmRlZFJuZywgc2ltaWxhcik7XG4gICAgICAgIHNlbGVjdGlvbi5tb3ZlVG9Cb29rbWFyayhib29rbWFyayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjYXJldENvbnRhaW5lciA9IGdldFBhcmVudENhcmV0Q29udGFpbmVyKGVkaXRvci5nZXRCb2R5KCksIGZvcm1hdE5vZGUpO1xuICAgICAgICBjb25zdCBuZXdDYXJldENvbnRhaW5lciA9IGNyZWF0ZUNhcmV0Q29udGFpbmVyKGZhbHNlKS5kb207XG4gICAgICAgIGluc2VydENhcmV0Q29udGFpbmVyTm9kZShlZGl0b3IsIG5ld0NhcmV0Q29udGFpbmVyLCBjYXJldENvbnRhaW5lciAhPT0gbnVsbCAmJiBjYXJldENvbnRhaW5lciAhPT0gdm9pZCAwID8gY2FyZXRDb250YWluZXIgOiBmb3JtYXROb2RlKTtcbiAgICAgICAgY29uc3QgY2xlYW5lZEZvcm1hdE5vZGUgPSBjbGVhbkZvcm1hdE5vZGUoZWRpdG9yLCBuZXdDYXJldENvbnRhaW5lciwgZm9ybWF0Tm9kZSwgbmFtZSwgdmFycywgc2ltaWxhcik7XG4gICAgICAgIGNvbnN0IGNhcmV0VGV4dE5vZGUgPSBpbnNlcnRGb3JtYXROb2Rlc0ludG9DYXJldENvbnRhaW5lcihwYXJlbnRzLmNvbmNhdChjbGVhbmVkRm9ybWF0Tm9kZS50b0FycmF5KCkpLCBuZXdDYXJldENvbnRhaW5lcik7XG4gICAgICAgIGlmIChjYXJldENvbnRhaW5lcikge1xuICAgICAgICAgIHJlbW92ZUNhcmV0Q29udGFpbmVyTm9kZShlZGl0b3IsIGNhcmV0Q29udGFpbmVyLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZWN0aW9uLnNldEN1cnNvckxvY2F0aW9uKGNhcmV0VGV4dE5vZGUsIDEpO1xuICAgICAgICBpZiAoZG9tLmlzRW1wdHkoZm9ybWF0Tm9kZSkpIHtcbiAgICAgICAgICBkb20ucmVtb3ZlKGZvcm1hdE5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBkaXNhYmxlQ2FyZXRDb250YWluZXIgPSAoZWRpdG9yLCBrZXlDb2RlKSA9PiB7XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uLCBib2R5ID0gZWRpdG9yLmdldEJvZHkoKTtcbiAgICAgIHJlbW92ZUNhcmV0Q29udGFpbmVyKGVkaXRvciwgbnVsbCwgZmFsc2UpO1xuICAgICAgaWYgKChrZXlDb2RlID09PSA4IHx8IGtleUNvZGUgPT09IDQ2KSAmJiBzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSAmJiBzZWxlY3Rpb24uZ2V0U3RhcnQoKS5pbm5lckhUTUwgPT09IFpXU1ApIHtcbiAgICAgICAgcmVtb3ZlQ2FyZXRDb250YWluZXIoZWRpdG9yLCBnZXRQYXJlbnRDYXJldENvbnRhaW5lcihib2R5LCBzZWxlY3Rpb24uZ2V0U3RhcnQoKSkpO1xuICAgICAgfVxuICAgICAgaWYgKGtleUNvZGUgPT09IDM3IHx8IGtleUNvZGUgPT09IDM5KSB7XG4gICAgICAgIHJlbW92ZUNhcmV0Q29udGFpbmVyKGVkaXRvciwgZ2V0UGFyZW50Q2FyZXRDb250YWluZXIoYm9keSwgc2VsZWN0aW9uLmdldFN0YXJ0KCkpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNldHVwJHUgPSBlZGl0b3IgPT4ge1xuICAgICAgZWRpdG9yLm9uKCdtb3VzZXVwIGtleWRvd24nLCBlID0+IHtcbiAgICAgICAgZGlzYWJsZUNhcmV0Q29udGFpbmVyKGVkaXRvciwgZS5rZXlDb2RlKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgY3JlYXRlQ2FyZXRGb3JtYXQgPSBmb3JtYXROb2RlcyA9PiB7XG4gICAgICBjb25zdCBjYXJldENvbnRhaW5lciA9IGNyZWF0ZUNhcmV0Q29udGFpbmVyKGZhbHNlKTtcbiAgICAgIGNvbnN0IGlubmVyTW9zdCA9IGluc2VydEZvcm1hdE5vZGVzSW50b0NhcmV0Q29udGFpbmVyKGZvcm1hdE5vZGVzLCBjYXJldENvbnRhaW5lci5kb20pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2FyZXRDb250YWluZXIsXG4gICAgICAgIGNhcmV0UG9zaXRpb246IENhcmV0UG9zaXRpb24oaW5uZXJNb3N0LCAwKVxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IHJlcGxhY2VXaXRoQ2FyZXRGb3JtYXQgPSAodGFyZ2V0Tm9kZSwgZm9ybWF0Tm9kZXMpID0+IHtcbiAgICAgIGNvbnN0IHtjYXJldENvbnRhaW5lciwgY2FyZXRQb3NpdGlvbn0gPSBjcmVhdGVDYXJldEZvcm1hdChmb3JtYXROb2Rlcyk7XG4gICAgICBiZWZvcmUkMyhTdWdhckVsZW1lbnQuZnJvbURvbSh0YXJnZXROb2RlKSwgY2FyZXRDb250YWluZXIpO1xuICAgICAgcmVtb3ZlJDYoU3VnYXJFbGVtZW50LmZyb21Eb20odGFyZ2V0Tm9kZSkpO1xuICAgICAgcmV0dXJuIGNhcmV0UG9zaXRpb247XG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGVDYXJldEZvcm1hdEF0U3RhcnQkMSA9IChlZGl0b3IsIGZvcm1hdE5vZGVzKSA9PiB7XG4gICAgICBjb25zdCB7Y2FyZXRDb250YWluZXIsIGNhcmV0UG9zaXRpb259ID0gY3JlYXRlQ2FyZXRGb3JtYXQoZm9ybWF0Tm9kZXMpO1xuICAgICAgZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKS5pbnNlcnROb2RlKGNhcmV0Q29udGFpbmVyLmRvbSk7XG4gICAgICByZXR1cm4gY2FyZXRQb3NpdGlvbjtcbiAgICB9O1xuICAgIGNvbnN0IGlzRm9ybWF0RWxlbWVudCA9IChlZGl0b3IsIGVsZW1lbnQpID0+IHtcbiAgICAgIGNvbnN0IGlubGluZUVsZW1lbnRzID0gZWRpdG9yLnNjaGVtYS5nZXRUZXh0SW5saW5lRWxlbWVudHMoKTtcbiAgICAgIHJldHVybiBoYXMkMihpbmxpbmVFbGVtZW50cywgbmFtZShlbGVtZW50KSkgJiYgIWlzQ2FyZXROb2RlKGVsZW1lbnQuZG9tKSAmJiAhaXNCb2d1cyQyKGVsZW1lbnQuZG9tKTtcbiAgICB9O1xuICAgIGNvbnN0IGlzRW1wdHlDYXJldEZvcm1hdEVsZW1lbnQgPSBlbGVtZW50ID0+IHtcbiAgICAgIHJldHVybiBpc0NhcmV0Tm9kZShlbGVtZW50LmRvbSkgJiYgaXNDYXJldENvbnRhaW5lckVtcHR5KGVsZW1lbnQuZG9tKTtcbiAgICB9O1xuXG4gICAgY29uc3QgcG9zdFByb2Nlc3NIb29rcyA9IHt9O1xuICAgIGNvbnN0IGlzUHJlID0gbWF0Y2hOb2RlTmFtZXMoWydwcmUnXSk7XG4gICAgY29uc3QgYWRkUG9zdFByb2Nlc3NIb29rID0gKG5hbWUsIGhvb2spID0+IHtcbiAgICAgIGNvbnN0IGhvb2tzID0gcG9zdFByb2Nlc3NIb29rc1tuYW1lXTtcbiAgICAgIGlmICghaG9va3MpIHtcbiAgICAgICAgcG9zdFByb2Nlc3NIb29rc1tuYW1lXSA9IFtdO1xuICAgICAgfVxuICAgICAgcG9zdFByb2Nlc3NIb29rc1tuYW1lXS5wdXNoKGhvb2spO1xuICAgIH07XG4gICAgY29uc3QgcG9zdFByb2Nlc3MkMSA9IChuYW1lLCBlZGl0b3IpID0+IHtcbiAgICAgIGlmIChoYXMkMihwb3N0UHJvY2Vzc0hvb2tzLCBuYW1lKSkge1xuICAgICAgICBlYWNoJGUocG9zdFByb2Nlc3NIb29rc1tuYW1lXSwgaG9vayA9PiB7XG4gICAgICAgICAgaG9vayhlZGl0b3IpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGFkZFBvc3RQcm9jZXNzSG9vaygncHJlJywgZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IHJuZyA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICBjb25zdCBoYXNQcmVTaWJsaW5nID0gYmxvY2tzID0+IHByZSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXYgPSBwcmUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICByZXR1cm4gaXNQcmUocHJldikgJiYgY29udGFpbnMkMihibG9ja3MsIHByZXYpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGpvaW5QcmUgPSAocHJlMSwgcHJlMikgPT4ge1xuICAgICAgICBjb25zdCBzUHJlMiA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKHByZTIpO1xuICAgICAgICBjb25zdCBkb2MgPSBkb2N1bWVudE9yT3duZXIoc1ByZTIpLmRvbTtcbiAgICAgICAgcmVtb3ZlJDYoc1ByZTIpO1xuICAgICAgICBhcHBlbmQoU3VnYXJFbGVtZW50LmZyb21Eb20ocHJlMSksIFtcbiAgICAgICAgICBTdWdhckVsZW1lbnQuZnJvbVRhZygnYnInLCBkb2MpLFxuICAgICAgICAgIFN1Z2FyRWxlbWVudC5mcm9tVGFnKCdicicsIGRvYyksXG4gICAgICAgICAgLi4uY2hpbGRyZW4kMShzUHJlMilcbiAgICAgICAgXSk7XG4gICAgICB9O1xuICAgICAgaWYgKCFybmcuY29sbGFwc2VkKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrcyA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0U2VsZWN0ZWRCbG9ja3MoKTtcbiAgICAgICAgY29uc3QgcHJlQmxvY2tzID0gZmlsdGVyJDUoZmlsdGVyJDUoYmxvY2tzLCBpc1ByZSksIGhhc1ByZVNpYmxpbmcoYmxvY2tzKSk7XG4gICAgICAgIGVhY2gkZShwcmVCbG9ja3MsIHByZSA9PiB7XG4gICAgICAgICAgam9pblByZShwcmUucHJldmlvdXNTaWJsaW5nLCBwcmUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IGxpc3RJdGVtU3R5bGVzID0gW1xuICAgICAgJ2ZvbnRXZWlnaHQnLFxuICAgICAgJ2ZvbnRTdHlsZScsXG4gICAgICAnY29sb3InLFxuICAgICAgJ2ZvbnRTaXplJyxcbiAgICAgICdmb250RmFtaWx5J1xuICAgIF07XG4gICAgY29uc3QgaGFzTGlzdFN0eWxlcyA9IGZtdCA9PiBpc09iamVjdChmbXQuc3R5bGVzKSAmJiBleGlzdHMoa2V5cyhmbXQuc3R5bGVzKSwgbmFtZSA9PiBjb250YWlucyQyKGxpc3RJdGVtU3R5bGVzLCBuYW1lKSk7XG4gICAgY29uc3QgZmluZEV4cGFuZGVkTGlzdEl0ZW1Gb3JtYXQgPSBmb3JtYXRzID0+IGZpbmQkMihmb3JtYXRzLCBmbXQgPT4gaXNJbmxpbmVGb3JtYXQoZm10KSAmJiBmbXQuaW5saW5lID09PSAnc3BhbicgJiYgaGFzTGlzdFN0eWxlcyhmbXQpKTtcbiAgICBjb25zdCBnZXRFeHBhbmRlZExpc3RJdGVtRm9ybWF0ID0gKGZvcm1hdHRlciwgZm9ybWF0KSA9PiB7XG4gICAgICBjb25zdCBmb3JtYXRMaXN0ID0gZm9ybWF0dGVyLmdldChmb3JtYXQpO1xuICAgICAgcmV0dXJuIGlzQXJyYXkkMShmb3JtYXRMaXN0KSA/IGZpbmRFeHBhbmRlZExpc3RJdGVtRm9ybWF0KGZvcm1hdExpc3QpIDogT3B0aW9uYWwubm9uZSgpO1xuICAgIH07XG4gICAgY29uc3QgaXNSbmdTdGFydEF0U3RhcnRPZkVsZW1lbnQgPSAocm5nLCBlbG0pID0+IHByZXZQb3NpdGlvbihlbG0sIENhcmV0UG9zaXRpb24uZnJvbVJhbmdlU3RhcnQocm5nKSkuaXNOb25lKCk7XG4gICAgY29uc3QgaXNSbmdFbmRBdEVuZE9mRWxlbWVudCA9IChybmcsIGVsbSkgPT4ge1xuICAgICAgcmV0dXJuIG5leHRQb3NpdGlvbihlbG0sIENhcmV0UG9zaXRpb24uZnJvbVJhbmdlRW5kKHJuZykpLmV4aXN0cyhwb3MgPT4gIWlzQnIkNihwb3MuZ2V0Tm9kZSgpKSB8fCBuZXh0UG9zaXRpb24oZWxtLCBwb3MpLmlzU29tZSgpKSA9PT0gZmFsc2U7XG4gICAgfTtcbiAgICBjb25zdCBpc0VkaXRhYmxlTGlzdEl0ZW0gPSBkb20gPT4gZWxtID0+IGlzTGlzdEl0ZW0kMihlbG0pICYmIGRvbS5pc0VkaXRhYmxlKGVsbSk7XG4gICAgY29uc3QgZ2V0RnVsbHlTZWxlY3RlZEJsb2NrcyA9IHNlbGVjdGlvbiA9PiB7XG4gICAgICBjb25zdCBibG9ja3MgPSBzZWxlY3Rpb24uZ2V0U2VsZWN0ZWRCbG9ja3MoKTtcbiAgICAgIGNvbnN0IHJuZyA9IHNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgIGlmIChzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoYmxvY2tzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gaXNSbmdTdGFydEF0U3RhcnRPZkVsZW1lbnQocm5nLCBibG9ja3NbMF0pICYmIGlzUm5nRW5kQXRFbmRPZkVsZW1lbnQocm5nLCBibG9ja3NbMF0pID8gYmxvY2tzIDogW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBmaXJzdCA9IGhlYWQoYmxvY2tzKS5maWx0ZXIoZWxtID0+IGlzUm5nU3RhcnRBdFN0YXJ0T2ZFbGVtZW50KHJuZywgZWxtKSkudG9BcnJheSgpO1xuICAgICAgICBjb25zdCBsYXN0ID0gbGFzdCQzKGJsb2NrcykuZmlsdGVyKGVsbSA9PiBpc1JuZ0VuZEF0RW5kT2ZFbGVtZW50KHJuZywgZWxtKSkudG9BcnJheSgpO1xuICAgICAgICBjb25zdCBtaWRkbGUgPSBibG9ja3Muc2xpY2UoMSwgLTEpO1xuICAgICAgICByZXR1cm4gZmlyc3QuY29uY2F0KG1pZGRsZSkuY29uY2F0KGxhc3QpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZ2V0RnVsbHlTZWxlY3RlZExpc3RJdGVtcyA9IHNlbGVjdGlvbiA9PiBmaWx0ZXIkNShnZXRGdWxseVNlbGVjdGVkQmxvY2tzKHNlbGVjdGlvbiksIGlzRWRpdGFibGVMaXN0SXRlbShzZWxlY3Rpb24uZG9tKSk7XG4gICAgY29uc3QgZ2V0UGFydGlhbGx5U2VsZWN0ZWRMaXN0SXRlbXMgPSBzZWxlY3Rpb24gPT4gZmlsdGVyJDUoc2VsZWN0aW9uLmdldFNlbGVjdGVkQmxvY2tzKCksIGlzRWRpdGFibGVMaXN0SXRlbShzZWxlY3Rpb24uZG9tKSk7XG5cbiAgICBjb25zdCBlYWNoJDggPSBUb29scy5lYWNoO1xuICAgIGNvbnN0IGlzRWxlbWVudE5vZGUgPSBub2RlID0+IGlzRWxlbWVudCQ2KG5vZGUpICYmICFpc0Jvb2ttYXJrTm9kZSQxKG5vZGUpICYmICFpc0NhcmV0Tm9kZShub2RlKSAmJiAhaXNCb2d1cyQyKG5vZGUpO1xuICAgIGNvbnN0IGZpbmRFbGVtZW50U2libGluZyA9IChub2RlLCBzaWJsaW5nTmFtZSkgPT4ge1xuICAgICAgZm9yIChsZXQgc2libGluZyA9IG5vZGU7IHNpYmxpbmc7IHNpYmxpbmcgPSBzaWJsaW5nW3NpYmxpbmdOYW1lXSkge1xuICAgICAgICBpZiAoaXNUZXh0JGEoc2libGluZykgJiYgaXNOb3RFbXB0eShzaWJsaW5nLmRhdGEpKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRWxlbWVudCQ2KHNpYmxpbmcpICYmICFpc0Jvb2ttYXJrTm9kZSQxKHNpYmxpbmcpKSB7XG4gICAgICAgICAgcmV0dXJuIHNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gICAgY29uc3QgbWVyZ2VTaWJsaW5nc05vZGVzID0gKGVkaXRvciwgcHJldiwgbmV4dCkgPT4ge1xuICAgICAgY29uc3QgZWxlbWVudFV0aWxzID0gRWxlbWVudFV0aWxzKGVkaXRvcik7XG4gICAgICBjb25zdCBpc1ByZXZFZGl0YWJsZSA9IGlzRWxlbWVudCQ2KHByZXYpICYmIGlzRWRpdGFibGUkMihwcmV2KTtcbiAgICAgIGNvbnN0IGlzTmV4dEVkaXRhYmxlID0gaXNFbGVtZW50JDYobmV4dCkgJiYgaXNFZGl0YWJsZSQyKG5leHQpO1xuICAgICAgaWYgKGlzUHJldkVkaXRhYmxlICYmIGlzTmV4dEVkaXRhYmxlKSB7XG4gICAgICAgIGNvbnN0IHByZXZTaWJsaW5nID0gZmluZEVsZW1lbnRTaWJsaW5nKHByZXYsICdwcmV2aW91c1NpYmxpbmcnKTtcbiAgICAgICAgY29uc3QgbmV4dFNpYmxpbmcgPSBmaW5kRWxlbWVudFNpYmxpbmcobmV4dCwgJ25leHRTaWJsaW5nJyk7XG4gICAgICAgIGlmIChlbGVtZW50VXRpbHMuY29tcGFyZShwcmV2U2libGluZywgbmV4dFNpYmxpbmcpKSB7XG4gICAgICAgICAgZm9yIChsZXQgc2libGluZyA9IHByZXZTaWJsaW5nLm5leHRTaWJsaW5nOyBzaWJsaW5nICYmIHNpYmxpbmcgIT09IG5leHRTaWJsaW5nOykge1xuICAgICAgICAgICAgY29uc3QgdG1wU2libGluZyA9IHNpYmxpbmc7XG4gICAgICAgICAgICBzaWJsaW5nID0gc2libGluZy5uZXh0U2libGluZztcbiAgICAgICAgICAgIHByZXZTaWJsaW5nLmFwcGVuZENoaWxkKHRtcFNpYmxpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlZGl0b3IuZG9tLnJlbW92ZShuZXh0U2libGluZyk7XG4gICAgICAgICAgVG9vbHMuZWFjaChUb29scy5ncmVwKG5leHRTaWJsaW5nLmNoaWxkTm9kZXMpLCBub2RlID0+IHtcbiAgICAgICAgICAgIHByZXZTaWJsaW5nLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBwcmV2U2libGluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgICBjb25zdCBtZXJnZVNpYmxpbmdzID0gKGVkaXRvciwgZm9ybWF0LCB2YXJzLCBub2RlKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAobm9kZSAmJiBmb3JtYXQubWVyZ2Vfc2libGluZ3MgIT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IG5ld05vZGUgPSAoX2EgPSBtZXJnZVNpYmxpbmdzTm9kZXMoZWRpdG9yLCBnZXROb25XaGl0ZVNwYWNlU2libGluZyhub2RlKSwgbm9kZSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5vZGU7XG4gICAgICAgIG1lcmdlU2libGluZ3NOb2RlcyhlZGl0b3IsIG5ld05vZGUsIGdldE5vbldoaXRlU3BhY2VTaWJsaW5nKG5ld05vZGUsIHRydWUpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGNsZWFyQ2hpbGRTdHlsZXMgPSAoZG9tLCBmb3JtYXQsIG5vZGUpID0+IHtcbiAgICAgIGlmIChmb3JtYXQuY2xlYXJfY2hpbGRfc3R5bGVzKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gZm9ybWF0LmxpbmtzID8gJyo6bm90KGEpJyA6ICcqJztcbiAgICAgICAgZWFjaCQ4KGRvbS5zZWxlY3Qoc2VsZWN0b3IsIG5vZGUpLCBjaGlsZE5vZGUgPT4ge1xuICAgICAgICAgIGlmIChpc0VsZW1lbnROb2RlKGNoaWxkTm9kZSkgJiYgaXNFZGl0YWJsZSQyKGNoaWxkTm9kZSkpIHtcbiAgICAgICAgICAgIGVhY2gkOChmb3JtYXQuc3R5bGVzLCAoX3ZhbHVlLCBuYW1lKSA9PiB7XG4gICAgICAgICAgICAgIGRvbS5zZXRTdHlsZShjaGlsZE5vZGUsIG5hbWUsICcnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBwcm9jZXNzQ2hpbGRFbGVtZW50cyA9IChub2RlLCBmaWx0ZXIsIHByb2Nlc3MpID0+IHtcbiAgICAgIGVhY2gkOChub2RlLmNoaWxkTm9kZXMsIG5vZGUgPT4ge1xuICAgICAgICBpZiAoaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgICAgICAgIGlmIChmaWx0ZXIobm9kZSkpIHtcbiAgICAgICAgICAgIHByb2Nlc3Mobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChub2RlLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgICAgcHJvY2Vzc0NoaWxkRWxlbWVudHMobm9kZSwgZmlsdGVyLCBwcm9jZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgdW53cmFwRW1wdHlTcGFuID0gKGRvbSwgbm9kZSkgPT4ge1xuICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT09ICdTUEFOJyAmJiBkb20uZ2V0QXR0cmlicyhub2RlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZG9tLnJlbW92ZShub2RlLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGhhc1N0eWxlID0gKGRvbSwgbmFtZSkgPT4gbm9kZSA9PiAhIShub2RlICYmIGdldFN0eWxlKGRvbSwgbm9kZSwgbmFtZSkpO1xuICAgIGNvbnN0IGFwcGx5U3R5bGUgPSAoZG9tLCBuYW1lLCB2YWx1ZSkgPT4gbm9kZSA9PiB7XG4gICAgICBkb20uc2V0U3R5bGUobm9kZSwgbmFtZSwgdmFsdWUpO1xuICAgICAgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKCdzdHlsZScpID09PSAnJykge1xuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgIH1cbiAgICAgIHVud3JhcEVtcHR5U3Bhbihkb20sIG5vZGUpO1xuICAgIH07XG5cbiAgICBjb25zdCByZW1vdmVSZXN1bHQgPSBBZHQuZ2VuZXJhdGUoW1xuICAgICAgeyBrZWVwOiBbXSB9LFxuICAgICAgeyByZW5hbWU6IFsnbmFtZSddIH0sXG4gICAgICB7IHJlbW92ZWQ6IFtdIH1cbiAgICBdKTtcbiAgICBjb25zdCBNQ0VfQVRUUl9SRSA9IC9eKHNyY3xocmVmfHN0eWxlKSQvO1xuICAgIGNvbnN0IGVhY2gkNyA9IFRvb2xzLmVhY2g7XG4gICAgY29uc3QgaXNFcSQyID0gaXNFcSQ1O1xuICAgIGNvbnN0IGlzVGFibGVDZWxsT3JSb3cgPSBub2RlID0+IC9eKFRSfFRIfFREKSQvLnRlc3Qobm9kZS5ub2RlTmFtZSk7XG4gICAgY29uc3QgaXNDaGlsZE9mSW5saW5lUGFyZW50ID0gKGRvbSwgbm9kZSwgcGFyZW50KSA9PiBkb20uaXNDaGlsZE9mKG5vZGUsIHBhcmVudCkgJiYgbm9kZSAhPT0gcGFyZW50ICYmICFkb20uaXNCbG9jayhwYXJlbnQpO1xuICAgIGNvbnN0IGdldENvbnRhaW5lciA9IChlZCwgcm5nLCBzdGFydCkgPT4ge1xuICAgICAgbGV0IGNvbnRhaW5lciA9IHJuZ1tzdGFydCA/ICdzdGFydENvbnRhaW5lcicgOiAnZW5kQ29udGFpbmVyJ107XG4gICAgICBsZXQgb2Zmc2V0ID0gcm5nW3N0YXJ0ID8gJ3N0YXJ0T2Zmc2V0JyA6ICdlbmRPZmZzZXQnXTtcbiAgICAgIGlmIChpc0VsZW1lbnQkNihjb250YWluZXIpKSB7XG4gICAgICAgIGNvbnN0IGxhc3RJZHggPSBjb250YWluZXIuY2hpbGROb2Rlcy5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoIXN0YXJ0ICYmIG9mZnNldCkge1xuICAgICAgICAgIG9mZnNldC0tO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lci5jaGlsZE5vZGVzW29mZnNldCA+IGxhc3RJZHggPyBsYXN0SWR4IDogb2Zmc2V0XTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1RleHQkYShjb250YWluZXIpICYmIHN0YXJ0ICYmIG9mZnNldCA+PSBjb250YWluZXIuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgY29udGFpbmVyID0gbmV3IERvbVRyZWVXYWxrZXIoY29udGFpbmVyLCBlZC5nZXRCb2R5KCkpLm5leHQoKSB8fCBjb250YWluZXI7XG4gICAgICB9XG4gICAgICBpZiAoaXNUZXh0JGEoY29udGFpbmVyKSAmJiAhc3RhcnQgJiYgb2Zmc2V0ID09PSAwKSB7XG4gICAgICAgIGNvbnRhaW5lciA9IG5ldyBEb21UcmVlV2Fsa2VyKGNvbnRhaW5lciwgZWQuZ2V0Qm9keSgpKS5wcmV2KCkgfHwgY29udGFpbmVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9O1xuICAgIGNvbnN0IG5vcm1hbGl6ZVRhYmxlU2VsZWN0aW9uID0gKG5vZGUsIHN0YXJ0KSA9PiB7XG4gICAgICBjb25zdCBwcm9wID0gc3RhcnQgPyAnZmlyc3RDaGlsZCcgOiAnbGFzdENoaWxkJztcbiAgICAgIGNvbnN0IGNoaWxkTm9kZSA9IG5vZGVbcHJvcF07XG4gICAgICBpZiAoaXNUYWJsZUNlbGxPclJvdyhub2RlKSAmJiBjaGlsZE5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT09ICdUUicpIHtcbiAgICAgICAgICByZXR1cm4gY2hpbGROb2RlW3Byb3BdIHx8IGNoaWxkTm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY2hpbGROb2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuICAgIGNvbnN0IHdyYXAkMSA9IChkb20sIG5vZGUsIG5hbWUsIGF0dHJzKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCB3cmFwcGVyID0gZG9tLmNyZWF0ZShuYW1lLCBhdHRycyk7XG4gICAgICAoX2EgPSBub2RlLnBhcmVudE5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbnNlcnRCZWZvcmUod3JhcHBlciwgbm9kZSk7XG4gICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfTtcbiAgICBjb25zdCB3cmFwV2l0aFNpYmxpbmdzID0gKGRvbSwgbm9kZSwgbmV4dCwgbmFtZSwgYXR0cnMpID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gU3VnYXJFbGVtZW50LmZyb21Eb20obm9kZSk7XG4gICAgICBjb25zdCB3cmFwcGVyID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZG9tLmNyZWF0ZShuYW1lLCBhdHRycykpO1xuICAgICAgY29uc3Qgc2libGluZ3MgPSBuZXh0ID8gbmV4dFNpYmxpbmdzKHN0YXJ0KSA6IHByZXZTaWJsaW5ncyhzdGFydCk7XG4gICAgICBhcHBlbmQod3JhcHBlciwgc2libGluZ3MpO1xuICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgYmVmb3JlJDMoc3RhcnQsIHdyYXBwZXIpO1xuICAgICAgICBwcmVwZW5kKHdyYXBwZXIsIHN0YXJ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFmdGVyJDQoc3RhcnQsIHdyYXBwZXIpO1xuICAgICAgICBhcHBlbmQkMSh3cmFwcGVyLCBzdGFydCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlci5kb207XG4gICAgfTtcbiAgICBjb25zdCBpc0NvbG9yRm9ybWF0QW5kQW5jaG9yID0gKG5vZGUsIGZvcm1hdCkgPT4gZm9ybWF0LmxpbmtzICYmIG5vZGUubm9kZU5hbWUgPT09ICdBJztcbiAgICBjb25zdCByZW1vdmVOb2RlID0gKGVkLCBub2RlLCBmb3JtYXQpID0+IHtcbiAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICBsZXQgcm9vdEJsb2NrRWxtO1xuICAgICAgY29uc3QgZG9tID0gZWQuZG9tO1xuICAgICAgY29uc3QgZm9yY2VkUm9vdEJsb2NrID0gZ2V0Rm9yY2VkUm9vdEJsb2NrKGVkKTtcbiAgICAgIGlmIChpc0Jsb2NrRm9ybWF0KGZvcm1hdCkpIHtcbiAgICAgICAgaWYgKHBhcmVudE5vZGUgPT09IGRvbS5nZXRSb290KCkpIHtcbiAgICAgICAgICBpZiAoIWZvcm1hdC5saXN0X2Jsb2NrIHx8ICFpc0VxJDIobm9kZSwgZm9ybWF0Lmxpc3RfYmxvY2spKSB7XG4gICAgICAgICAgICBlYWNoJGUoZnJvbShub2RlLmNoaWxkTm9kZXMpLCBub2RlID0+IHtcbiAgICAgICAgICAgICAgaWYgKGlzVmFsaWQoZWQsIGZvcmNlZFJvb3RCbG9jaywgbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgICAgICAgIGlmICghcm9vdEJsb2NrRWxtKSB7XG4gICAgICAgICAgICAgICAgICByb290QmxvY2tFbG0gPSB3cmFwJDEoZG9tLCBub2RlLCBmb3JjZWRSb290QmxvY2spO1xuICAgICAgICAgICAgICAgICAgZG9tLnNldEF0dHJpYnMocm9vdEJsb2NrRWxtLCBnZXRGb3JjZWRSb290QmxvY2tBdHRycyhlZCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByb290QmxvY2tFbG0uYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvb3RCbG9ja0VsbSA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzTWl4ZWRGb3JtYXQoZm9ybWF0KSAmJiAhaXNFcSQyKGZvcm1hdC5pbmxpbmUsIG5vZGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRvbS5yZW1vdmUobm9kZSwgdHJ1ZSk7XG4gICAgfTtcbiAgICBjb25zdCBwcm9jZXNzRm9ybWF0QXR0ck9yU3R5bGUgPSAobmFtZSwgdmFsdWUsIHZhcnMpID0+IHtcbiAgICAgIGlmIChpc051bWJlcihuYW1lKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IHZhbHVlLFxuICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgdmFsdWU6IHJlcGxhY2VWYXJzKHZhbHVlLCB2YXJzKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmVtb3ZlRW1wdHlTdHlsZUF0dHJpYnV0ZUlmTmVlZGVkID0gKGRvbSwgZWxtKSA9PiB7XG4gICAgICBpZiAoZG9tLmdldEF0dHJpYihlbG0sICdzdHlsZScpID09PSAnJykge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKCdkYXRhLW1jZS1zdHlsZScpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmVtb3ZlU3R5bGVzID0gKGRvbSwgZWxtLCBmb3JtYXQsIHZhcnMsIGNvbXBhcmVOb2RlKSA9PiB7XG4gICAgICBsZXQgc3R5bGVzTW9kaWZpZWQgPSBmYWxzZTtcbiAgICAgIGVhY2gkNyhmb3JtYXQuc3R5bGVzLCAodmFsdWUsIG5hbWUpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIG5hbWU6IHN0eWxlTmFtZSxcbiAgICAgICAgICB2YWx1ZTogc3R5bGVWYWx1ZVxuICAgICAgICB9ID0gcHJvY2Vzc0Zvcm1hdEF0dHJPclN0eWxlKG5hbWUsIHZhbHVlLCB2YXJzKTtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZFN0eWxlVmFsdWUgPSBub3JtYWxpemVTdHlsZVZhbHVlKHN0eWxlVmFsdWUsIHN0eWxlTmFtZSk7XG4gICAgICAgIGlmIChmb3JtYXQucmVtb3ZlX3NpbWlsYXIgfHwgaXNOdWxsKHN0eWxlVmFsdWUpIHx8ICFpc0VsZW1lbnQkNihjb21wYXJlTm9kZSkgfHwgaXNFcSQyKGdldFN0eWxlKGRvbSwgY29tcGFyZU5vZGUsIHN0eWxlTmFtZSksIG5vcm1hbGl6ZWRTdHlsZVZhbHVlKSkge1xuICAgICAgICAgIGRvbS5zZXRTdHlsZShlbG0sIHN0eWxlTmFtZSwgJycpO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlc01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHN0eWxlc01vZGlmaWVkKSB7XG4gICAgICAgIHJlbW92ZUVtcHR5U3R5bGVBdHRyaWJ1dGVJZk5lZWRlZChkb20sIGVsbSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVMaXN0U3R5bGVGb3JtYXRzID0gKGVkaXRvciwgbmFtZSwgdmFycykgPT4ge1xuICAgICAgaWYgKG5hbWUgPT09ICdyZW1vdmVmb3JtYXQnKSB7XG4gICAgICAgIGVhY2gkZShnZXRQYXJ0aWFsbHlTZWxlY3RlZExpc3RJdGVtcyhlZGl0b3Iuc2VsZWN0aW9uKSwgbGkgPT4ge1xuICAgICAgICAgIGVhY2gkZShsaXN0SXRlbVN0eWxlcywgbmFtZSA9PiBlZGl0b3IuZG9tLnNldFN0eWxlKGxpLCBuYW1lLCAnJykpO1xuICAgICAgICAgIHJlbW92ZUVtcHR5U3R5bGVBdHRyaWJ1dGVJZk5lZWRlZChlZGl0b3IuZG9tLCBsaSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2V0RXhwYW5kZWRMaXN0SXRlbUZvcm1hdChlZGl0b3IuZm9ybWF0dGVyLCBuYW1lKS5lYWNoKGxpRm10ID0+IHtcbiAgICAgICAgICBlYWNoJGUoZ2V0UGFydGlhbGx5U2VsZWN0ZWRMaXN0SXRlbXMoZWRpdG9yLnNlbGVjdGlvbiksIGxpID0+IHJlbW92ZVN0eWxlcyhlZGl0b3IuZG9tLCBsaSwgbGlGbXQsIHZhcnMsIG51bGwpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVGb3JtYXRJbnRlcm5hbCA9IChlZCwgZm9ybWF0LCB2YXJzLCBub2RlLCBjb21wYXJlTm9kZSkgPT4ge1xuICAgICAgY29uc3QgZG9tID0gZWQuZG9tO1xuICAgICAgY29uc3QgZWxlbWVudFV0aWxzID0gRWxlbWVudFV0aWxzKGVkKTtcbiAgICAgIGNvbnN0IHNjaGVtYSA9IGVkLnNjaGVtYTtcbiAgICAgIGlmIChpc0lubGluZUZvcm1hdChmb3JtYXQpICYmIGlzVHJhbnNwYXJlbnRFbGVtZW50TmFtZShzY2hlbWEsIGZvcm1hdC5pbmxpbmUpICYmIGlzVHJhbnNwYXJlbnRCbG9jayhzY2hlbWEsIG5vZGUpICYmIG5vZGUucGFyZW50RWxlbWVudCA9PT0gZWQuZ2V0Qm9keSgpKSB7XG4gICAgICAgIHJlbW92ZU5vZGUoZWQsIG5vZGUsIGZvcm1hdCk7XG4gICAgICAgIHJldHVybiByZW1vdmVSZXN1bHQucmVtb3ZlZCgpO1xuICAgICAgfVxuICAgICAgaWYgKCFmb3JtYXQuY2VGYWxzZU92ZXJyaWRlICYmIG5vZGUgJiYgZG9tLmdldENvbnRlbnRFZGl0YWJsZVBhcmVudChub2RlKSA9PT0gJ2ZhbHNlJykge1xuICAgICAgICByZXR1cm4gcmVtb3ZlUmVzdWx0LmtlZXAoKTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlICYmICFtYXRjaE5hbWUoZG9tLCBub2RlLCBmb3JtYXQpICYmICFpc0NvbG9yRm9ybWF0QW5kQW5jaG9yKG5vZGUsIGZvcm1hdCkpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZVJlc3VsdC5rZWVwKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBlbG0gPSBub2RlO1xuICAgICAgY29uc3QgcHJlc2VydmVBdHRyaWJ1dGVzID0gZm9ybWF0LnByZXNlcnZlX2F0dHJpYnV0ZXM7XG4gICAgICBpZiAoaXNJbmxpbmVGb3JtYXQoZm9ybWF0KSAmJiBmb3JtYXQucmVtb3ZlID09PSAnYWxsJyAmJiBpc0FycmF5JDEocHJlc2VydmVBdHRyaWJ1dGVzKSkge1xuICAgICAgICBjb25zdCBhdHRyc1RvUHJlc2VydmUgPSBmaWx0ZXIkNShkb20uZ2V0QXR0cmlicyhlbG0pLCBhdHRyID0+IGNvbnRhaW5zJDIocHJlc2VydmVBdHRyaWJ1dGVzLCBhdHRyLm5hbWUudG9Mb3dlckNhc2UoKSkpO1xuICAgICAgICBkb20ucmVtb3ZlQWxsQXR0cmlicyhlbG0pO1xuICAgICAgICBlYWNoJGUoYXR0cnNUb1ByZXNlcnZlLCBhdHRyID0+IGRvbS5zZXRBdHRyaWIoZWxtLCBhdHRyLm5hbWUsIGF0dHIudmFsdWUpKTtcbiAgICAgICAgaWYgKGF0dHJzVG9QcmVzZXJ2ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIHJlbW92ZVJlc3VsdC5yZW5hbWUoJ3NwYW4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvcm1hdC5yZW1vdmUgIT09ICdhbGwnKSB7XG4gICAgICAgIHJlbW92ZVN0eWxlcyhkb20sIGVsbSwgZm9ybWF0LCB2YXJzLCBjb21wYXJlTm9kZSk7XG4gICAgICAgIGVhY2gkNyhmb3JtYXQuYXR0cmlidXRlcywgKHZhbHVlLCBuYW1lKSA9PiB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgbmFtZTogYXR0ck5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogYXR0clZhbHVlXG4gICAgICAgICAgfSA9IHByb2Nlc3NGb3JtYXRBdHRyT3JTdHlsZShuYW1lLCB2YWx1ZSwgdmFycyk7XG4gICAgICAgICAgaWYgKGZvcm1hdC5yZW1vdmVfc2ltaWxhciB8fCBpc051bGwoYXR0clZhbHVlKSB8fCAhaXNFbGVtZW50JDYoY29tcGFyZU5vZGUpIHx8IGlzRXEkMihkb20uZ2V0QXR0cmliKGNvbXBhcmVOb2RlLCBhdHRyTmFtZSksIGF0dHJWYWx1ZSkpIHtcbiAgICAgICAgICAgIGlmIChhdHRyTmFtZSA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBkb20uZ2V0QXR0cmliKGVsbSwgYXR0ck5hbWUpO1xuICAgICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlT3V0ID0gJyc7XG4gICAgICAgICAgICAgICAgZWFjaCRlKGN1cnJlbnRWYWx1ZS5zcGxpdCgvXFxzKy8pLCBjbHMgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKC9tY2VcXC1cXHcrLy50ZXN0KGNscykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVPdXQgKz0gKHZhbHVlT3V0ID8gJyAnIDogJycpICsgY2xzO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZU91dCkge1xuICAgICAgICAgICAgICAgICAgZG9tLnNldEF0dHJpYihlbG0sIGF0dHJOYW1lLCB2YWx1ZU91dCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTUNFX0FUVFJfUkUudGVzdChhdHRyTmFtZSkpIHtcbiAgICAgICAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1tY2UtJyArIGF0dHJOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhdHRyTmFtZSA9PT0gJ3N0eWxlJyAmJiBtYXRjaE5vZGVOYW1lcyhbJ2xpJ10pKGVsbSkgJiYgZG9tLmdldFN0eWxlKGVsbSwgJ2xpc3Qtc3R5bGUtdHlwZScpID09PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgICAgICAgICAgIGRvbS5zZXRTdHlsZShlbG0sICdsaXN0LXN0eWxlLXR5cGUnLCAnbm9uZScpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXR0ck5hbWUgPT09ICdjbGFzcycpIHtcbiAgICAgICAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3NOYW1lJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBlYWNoJDcoZm9ybWF0LmNsYXNzZXMsIHZhbHVlID0+IHtcbiAgICAgICAgICB2YWx1ZSA9IHJlcGxhY2VWYXJzKHZhbHVlLCB2YXJzKTtcbiAgICAgICAgICBpZiAoIWlzRWxlbWVudCQ2KGNvbXBhcmVOb2RlKSB8fCBkb20uaGFzQ2xhc3MoY29tcGFyZU5vZGUsIHZhbHVlKSkge1xuICAgICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKGVsbSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGF0dHJzID0gZG9tLmdldEF0dHJpYnMoZWxtKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGF0dHJOYW1lID0gYXR0cnNbaV0ubm9kZU5hbWU7XG4gICAgICAgICAgaWYgKCFlbGVtZW50VXRpbHMuaXNBdHRyaWJ1dGVJbnRlcm5hbChhdHRyTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiByZW1vdmVSZXN1bHQua2VlcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvcm1hdC5yZW1vdmUgIT09ICdub25lJykge1xuICAgICAgICByZW1vdmVOb2RlKGVkLCBlbG0sIGZvcm1hdCk7XG4gICAgICAgIHJldHVybiByZW1vdmVSZXN1bHQucmVtb3ZlZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlbW92ZVJlc3VsdC5rZWVwKCk7XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVGb3JtYXQkMSA9IChlZCwgZm9ybWF0LCB2YXJzLCBub2RlLCBjb21wYXJlTm9kZSkgPT4gcmVtb3ZlRm9ybWF0SW50ZXJuYWwoZWQsIGZvcm1hdCwgdmFycywgbm9kZSwgY29tcGFyZU5vZGUpLmZvbGQobmV2ZXIsIG5ld05hbWUgPT4ge1xuICAgICAgZWQuZG9tLnJlbmFtZShub2RlLCBuZXdOYW1lKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sIGFsd2F5cyk7XG4gICAgY29uc3QgZmluZEZvcm1hdFJvb3QgPSAoZWRpdG9yLCBjb250YWluZXIsIG5hbWUsIHZhcnMsIHNpbWlsYXIpID0+IHtcbiAgICAgIGxldCBmb3JtYXRSb290O1xuICAgICAgaWYgKGNvbnRhaW5lci5wYXJlbnROb2RlKSB7XG4gICAgICAgIGVhY2gkZShnZXRQYXJlbnRzJDIoZWRpdG9yLmRvbSwgY29udGFpbmVyLnBhcmVudE5vZGUpLnJldmVyc2UoKSwgcGFyZW50ID0+IHtcbiAgICAgICAgICBpZiAoIWZvcm1hdFJvb3QgJiYgaXNFbGVtZW50JDYocGFyZW50KSAmJiBwYXJlbnQuaWQgIT09ICdfc3RhcnQnICYmIHBhcmVudC5pZCAhPT0gJ19lbmQnKSB7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXQgPSBtYXRjaE5vZGUoZWRpdG9yLCBwYXJlbnQsIG5hbWUsIHZhcnMsIHNpbWlsYXIpO1xuICAgICAgICAgICAgaWYgKGZvcm1hdCAmJiBmb3JtYXQuc3BsaXQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGZvcm1hdFJvb3QgPSBwYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmb3JtYXRSb290O1xuICAgIH07XG4gICAgY29uc3QgcmVtb3ZlRm9ybWF0RnJvbUNsb25lID0gKGVkaXRvciwgZm9ybWF0LCB2YXJzLCBjbG9uZSkgPT4gcmVtb3ZlRm9ybWF0SW50ZXJuYWwoZWRpdG9yLCBmb3JtYXQsIHZhcnMsIGNsb25lLCBjbG9uZSkuZm9sZChjb25zdGFudChjbG9uZSksIG5ld05hbWUgPT4ge1xuICAgICAgY29uc3QgZnJhZ21lbnQgPSBlZGl0b3IuZG9tLmNyZWF0ZUZyYWdtZW50KCk7XG4gICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgICByZXR1cm4gZWRpdG9yLmRvbS5yZW5hbWUoY2xvbmUsIG5ld05hbWUpO1xuICAgIH0sIGNvbnN0YW50KG51bGwpKTtcbiAgICBjb25zdCB3cmFwQW5kU3BsaXQgPSAoZWRpdG9yLCBmb3JtYXRMaXN0LCBmb3JtYXRSb290LCBjb250YWluZXIsIHRhcmdldCwgc3BsaXQsIGZvcm1hdCwgdmFycykgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGxldCBsYXN0Q2xvbmU7XG4gICAgICBsZXQgZmlyc3RDbG9uZTtcbiAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb207XG4gICAgICBpZiAoZm9ybWF0Um9vdCkge1xuICAgICAgICBjb25zdCBmb3JtYXRSb290UGFyZW50ID0gZm9ybWF0Um9vdC5wYXJlbnROb2RlO1xuICAgICAgICBmb3IgKGxldCBwYXJlbnQgPSBjb250YWluZXIucGFyZW50Tm9kZTsgcGFyZW50ICYmIHBhcmVudCAhPT0gZm9ybWF0Um9vdFBhcmVudDsgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBsZXQgY2xvbmUgPSBkb20uY2xvbmUocGFyZW50LCBmYWxzZSk7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmb3JtYXRMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjbG9uZSA9IHJlbW92ZUZvcm1hdEZyb21DbG9uZShlZGl0b3IsIGZvcm1hdExpc3RbaV0sIHZhcnMsIGNsb25lKTtcbiAgICAgICAgICAgIGlmIChjbG9uZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNsb25lKSB7XG4gICAgICAgICAgICBpZiAobGFzdENsb25lKSB7XG4gICAgICAgICAgICAgIGNsb25lLmFwcGVuZENoaWxkKGxhc3RDbG9uZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWZpcnN0Q2xvbmUpIHtcbiAgICAgICAgICAgICAgZmlyc3RDbG9uZSA9IGNsb25lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdENsb25lID0gY2xvbmU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzcGxpdCAmJiAoIWZvcm1hdC5taXhlZCB8fCAhZG9tLmlzQmxvY2soZm9ybWF0Um9vdCkpKSB7XG4gICAgICAgICAgY29udGFpbmVyID0gKF9hID0gZG9tLnNwbGl0KGZvcm1hdFJvb3QsIGNvbnRhaW5lcikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvbnRhaW5lcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdENsb25lICYmIGZpcnN0Q2xvbmUpIHtcbiAgICAgICAgICAoX2IgPSB0YXJnZXQucGFyZW50Tm9kZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmluc2VydEJlZm9yZShsYXN0Q2xvbmUsIHRhcmdldCk7XG4gICAgICAgICAgZmlyc3RDbG9uZS5hcHBlbmRDaGlsZCh0YXJnZXQpO1xuICAgICAgICAgIGlmIChpc0lubGluZUZvcm1hdChmb3JtYXQpKSB7XG4gICAgICAgICAgICBtZXJnZVNpYmxpbmdzKGVkaXRvciwgZm9ybWF0LCB2YXJzLCBsYXN0Q2xvbmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZSQyID0gKGVkLCBuYW1lLCB2YXJzLCBub2RlLCBzaW1pbGFyKSA9PiB7XG4gICAgICBjb25zdCBmb3JtYXRMaXN0ID0gZWQuZm9ybWF0dGVyLmdldChuYW1lKTtcbiAgICAgIGNvbnN0IGZvcm1hdCA9IGZvcm1hdExpc3RbMF07XG4gICAgICBjb25zdCBkb20gPSBlZC5kb207XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSBlZC5zZWxlY3Rpb247XG4gICAgICBjb25zdCBzcGxpdFRvRm9ybWF0Um9vdCA9IGNvbnRhaW5lciA9PiB7XG4gICAgICAgIGNvbnN0IGZvcm1hdFJvb3QgPSBmaW5kRm9ybWF0Um9vdChlZCwgY29udGFpbmVyLCBuYW1lLCB2YXJzLCBzaW1pbGFyKTtcbiAgICAgICAgcmV0dXJuIHdyYXBBbmRTcGxpdChlZCwgZm9ybWF0TGlzdCwgZm9ybWF0Um9vdCwgY29udGFpbmVyLCBjb250YWluZXIsIHRydWUsIGZvcm1hdCwgdmFycyk7XG4gICAgICB9O1xuICAgICAgY29uc3QgaXNSZW1vdmVCb29rbWFya05vZGUgPSBub2RlID0+IGlzQm9va21hcmtOb2RlJDEobm9kZSkgJiYgaXNFbGVtZW50JDYobm9kZSkgJiYgKG5vZGUuaWQgPT09ICdfc3RhcnQnIHx8IG5vZGUuaWQgPT09ICdfZW5kJyk7XG4gICAgICBjb25zdCByZW1vdmVOb2RlRm9ybWF0ID0gbm9kZSA9PiBleGlzdHMoZm9ybWF0TGlzdCwgZm10ID0+IHJlbW92ZUZvcm1hdCQxKGVkLCBmbXQsIHZhcnMsIG5vZGUsIG5vZGUpKTtcbiAgICAgIGNvbnN0IHByb2Nlc3MgPSBub2RlID0+IHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBmcm9tKG5vZGUuY2hpbGROb2Rlcyk7XG4gICAgICAgIGNvbnN0IHJlbW92ZWQgPSByZW1vdmVOb2RlRm9ybWF0KG5vZGUpO1xuICAgICAgICBjb25zdCBjdXJyZW50Tm9kZU1hdGNoZXMgPSByZW1vdmVkIHx8IGV4aXN0cyhmb3JtYXRMaXN0LCBmID0+IG1hdGNoTmFtZShkb20sIG5vZGUsIGYpKTtcbiAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKCFjdXJyZW50Tm9kZU1hdGNoZXMgJiYgaXNOb25OdWxsYWJsZShwYXJlbnROb2RlKSAmJiBzaG91bGRFeHBhbmRUb1NlbGVjdG9yKGZvcm1hdCkpIHtcbiAgICAgICAgICByZW1vdmVOb2RlRm9ybWF0KHBhcmVudE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQuZGVlcCkge1xuICAgICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgcHJvY2VzcyhjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRleHREZWNvcmF0aW9ucyA9IFtcbiAgICAgICAgICAndW5kZXJsaW5lJyxcbiAgICAgICAgICAnbGluZS10aHJvdWdoJyxcbiAgICAgICAgICAnb3ZlcmxpbmUnXG4gICAgICAgIF07XG4gICAgICAgIGVhY2gkZSh0ZXh0RGVjb3JhdGlvbnMsIGRlY29yYXRpb24gPT4ge1xuICAgICAgICAgIGlmIChpc0VsZW1lbnQkNihub2RlKSAmJiBlZC5kb20uZ2V0U3R5bGUobm9kZSwgJ3RleHQtZGVjb3JhdGlvbicpID09PSBkZWNvcmF0aW9uICYmIG5vZGUucGFyZW50Tm9kZSAmJiBnZXRUZXh0RGVjb3JhdGlvbihkb20sIG5vZGUucGFyZW50Tm9kZSkgPT09IGRlY29yYXRpb24pIHtcbiAgICAgICAgICAgIHJlbW92ZUZvcm1hdCQxKGVkLCB7XG4gICAgICAgICAgICAgIGRlZXA6IGZhbHNlLFxuICAgICAgICAgICAgICBleGFjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgaW5saW5lOiAnc3BhbicsXG4gICAgICAgICAgICAgIHN0eWxlczogeyB0ZXh0RGVjb3JhdGlvbjogZGVjb3JhdGlvbiB9XG4gICAgICAgICAgICB9LCB1bmRlZmluZWQsIG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgdW53cmFwID0gc3RhcnQgPT4ge1xuICAgICAgICBjb25zdCBub2RlID0gZG9tLmdldChzdGFydCA/ICdfc3RhcnQnIDogJ19lbmQnKTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICBsZXQgb3V0ID0gbm9kZVtzdGFydCA/ICdmaXJzdENoaWxkJyA6ICdsYXN0Q2hpbGQnXTtcbiAgICAgICAgICBpZiAoaXNSZW1vdmVCb29rbWFya05vZGUob3V0KSkge1xuICAgICAgICAgICAgb3V0ID0gb3V0W3N0YXJ0ID8gJ2ZpcnN0Q2hpbGQnIDogJ2xhc3RDaGlsZCddO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNUZXh0JGEob3V0KSAmJiBvdXQuZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIG91dCA9IHN0YXJ0ID8gbm9kZS5wcmV2aW91c1NpYmxpbmcgfHwgbm9kZS5uZXh0U2libGluZyA6IG5vZGUubmV4dFNpYmxpbmcgfHwgbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRvbS5yZW1vdmUobm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlbW92ZVJuZ1N0eWxlID0gcm5nID0+IHtcbiAgICAgICAgbGV0IHN0YXJ0Q29udGFpbmVyO1xuICAgICAgICBsZXQgZW5kQ29udGFpbmVyO1xuICAgICAgICBsZXQgZXhwYW5kZWRSbmcgPSBleHBhbmRSbmcoZG9tLCBybmcsIGZvcm1hdExpc3QsIHJuZy5jb2xsYXBzZWQpO1xuICAgICAgICBpZiAoZm9ybWF0LnNwbGl0KSB7XG4gICAgICAgICAgZXhwYW5kZWRSbmcgPSBzcGxpdChleHBhbmRlZFJuZyk7XG4gICAgICAgICAgc3RhcnRDb250YWluZXIgPSBnZXRDb250YWluZXIoZWQsIGV4cGFuZGVkUm5nLCB0cnVlKTtcbiAgICAgICAgICBlbmRDb250YWluZXIgPSBnZXRDb250YWluZXIoZWQsIGV4cGFuZGVkUm5nKTtcbiAgICAgICAgICBpZiAoc3RhcnRDb250YWluZXIgIT09IGVuZENvbnRhaW5lcikge1xuICAgICAgICAgICAgc3RhcnRDb250YWluZXIgPSBub3JtYWxpemVUYWJsZVNlbGVjdGlvbihzdGFydENvbnRhaW5lciwgdHJ1ZSk7XG4gICAgICAgICAgICBlbmRDb250YWluZXIgPSBub3JtYWxpemVUYWJsZVNlbGVjdGlvbihlbmRDb250YWluZXIsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChpc0NoaWxkT2ZJbmxpbmVQYXJlbnQoZG9tLCBzdGFydENvbnRhaW5lciwgZW5kQ29udGFpbmVyKSkge1xuICAgICAgICAgICAgICBjb25zdCBtYXJrZXIgPSBPcHRpb25hbC5mcm9tKHN0YXJ0Q29udGFpbmVyLmZpcnN0Q2hpbGQpLmdldE9yKHN0YXJ0Q29udGFpbmVyKTtcbiAgICAgICAgICAgICAgc3BsaXRUb0Zvcm1hdFJvb3Qod3JhcFdpdGhTaWJsaW5ncyhkb20sIG1hcmtlciwgdHJ1ZSwgJ3NwYW4nLCB7XG4gICAgICAgICAgICAgICAgJ2lkJzogJ19zdGFydCcsXG4gICAgICAgICAgICAgICAgJ2RhdGEtbWNlLXR5cGUnOiAnYm9va21hcmsnXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgdW53cmFwKHRydWUpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNDaGlsZE9mSW5saW5lUGFyZW50KGRvbSwgZW5kQ29udGFpbmVyLCBzdGFydENvbnRhaW5lcikpIHtcbiAgICAgICAgICAgICAgY29uc3QgbWFya2VyID0gT3B0aW9uYWwuZnJvbShlbmRDb250YWluZXIubGFzdENoaWxkKS5nZXRPcihlbmRDb250YWluZXIpO1xuICAgICAgICAgICAgICBzcGxpdFRvRm9ybWF0Um9vdCh3cmFwV2l0aFNpYmxpbmdzKGRvbSwgbWFya2VyLCBmYWxzZSwgJ3NwYW4nLCB7XG4gICAgICAgICAgICAgICAgJ2lkJzogJ19lbmQnLFxuICAgICAgICAgICAgICAgICdkYXRhLW1jZS10eXBlJzogJ2Jvb2ttYXJrJ1xuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIHVud3JhcChmYWxzZSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXJ0Q29udGFpbmVyID0gd3JhcCQxKGRvbSwgc3RhcnRDb250YWluZXIsICdzcGFuJywge1xuICAgICAgICAgICAgICAnaWQnOiAnX3N0YXJ0JyxcbiAgICAgICAgICAgICAgJ2RhdGEtbWNlLXR5cGUnOiAnYm9va21hcmsnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVuZENvbnRhaW5lciA9IHdyYXAkMShkb20sIGVuZENvbnRhaW5lciwgJ3NwYW4nLCB7XG4gICAgICAgICAgICAgICdpZCc6ICdfZW5kJyxcbiAgICAgICAgICAgICAgJ2RhdGEtbWNlLXR5cGUnOiAnYm9va21hcmsnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1JuZyA9IGRvbS5jcmVhdGVSbmcoKTtcbiAgICAgICAgICAgIG5ld1JuZy5zZXRTdGFydEFmdGVyKHN0YXJ0Q29udGFpbmVyKTtcbiAgICAgICAgICAgIG5ld1JuZy5zZXRFbmRCZWZvcmUoZW5kQ29udGFpbmVyKTtcbiAgICAgICAgICAgIHdhbGskMyhkb20sIG5ld1JuZywgbm9kZXMgPT4ge1xuICAgICAgICAgICAgICBlYWNoJGUobm9kZXMsIG4gPT4ge1xuICAgICAgICAgICAgICAgIGlmICghaXNCb29rbWFya05vZGUkMShuKSAmJiAhaXNCb29rbWFya05vZGUkMShuLnBhcmVudE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICBzcGxpdFRvRm9ybWF0Um9vdChuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzcGxpdFRvRm9ybWF0Um9vdChzdGFydENvbnRhaW5lcik7XG4gICAgICAgICAgICBzcGxpdFRvRm9ybWF0Um9vdChlbmRDb250YWluZXIpO1xuICAgICAgICAgICAgc3RhcnRDb250YWluZXIgPSB1bndyYXAodHJ1ZSk7XG4gICAgICAgICAgICBlbmRDb250YWluZXIgPSB1bndyYXAoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRDb250YWluZXIgPSBlbmRDb250YWluZXIgPSBzcGxpdFRvRm9ybWF0Um9vdChzdGFydENvbnRhaW5lcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cGFuZGVkUm5nLnN0YXJ0Q29udGFpbmVyID0gc3RhcnRDb250YWluZXIucGFyZW50Tm9kZSA/IHN0YXJ0Q29udGFpbmVyLnBhcmVudE5vZGUgOiBzdGFydENvbnRhaW5lcjtcbiAgICAgICAgICBleHBhbmRlZFJuZy5zdGFydE9mZnNldCA9IGRvbS5ub2RlSW5kZXgoc3RhcnRDb250YWluZXIpO1xuICAgICAgICAgIGV4cGFuZGVkUm5nLmVuZENvbnRhaW5lciA9IGVuZENvbnRhaW5lci5wYXJlbnROb2RlID8gZW5kQ29udGFpbmVyLnBhcmVudE5vZGUgOiBlbmRDb250YWluZXI7XG4gICAgICAgICAgZXhwYW5kZWRSbmcuZW5kT2Zmc2V0ID0gZG9tLm5vZGVJbmRleChlbmRDb250YWluZXIpICsgMTtcbiAgICAgICAgfVxuICAgICAgICB3YWxrJDMoZG9tLCBleHBhbmRlZFJuZywgbm9kZXMgPT4ge1xuICAgICAgICAgIGVhY2gkZShub2RlcywgcHJvY2Vzcyk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGlmIChub2RlKSB7XG4gICAgICAgIGlmIChpc05vZGUobm9kZSkpIHtcbiAgICAgICAgICBjb25zdCBybmcgPSBkb20uY3JlYXRlUm5nKCk7XG4gICAgICAgICAgcm5nLnNldFN0YXJ0QmVmb3JlKG5vZGUpO1xuICAgICAgICAgIHJuZy5zZXRFbmRBZnRlcihub2RlKTtcbiAgICAgICAgICByZW1vdmVSbmdTdHlsZShybmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbW92ZVJuZ1N0eWxlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGZpcmVGb3JtYXRSZW1vdmUoZWQsIG5hbWUsIG5vZGUsIHZhcnMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpIHx8ICFpc0lubGluZUZvcm1hdChmb3JtYXQpIHx8IGdldENlbGxzRnJvbUVkaXRvcihlZCkubGVuZ3RoKSB7XG4gICAgICAgIHByZXNlcnZlU2VsZWN0aW9uKGVkLCAoKSA9PiBydW5PblJhbmdlcyhlZCwgcmVtb3ZlUm5nU3R5bGUpLCBzdGFydE5vZGUgPT4gaXNJbmxpbmVGb3JtYXQoZm9ybWF0KSAmJiBtYXRjaCQyKGVkLCBuYW1lLCB2YXJzLCBzdGFydE5vZGUpKTtcbiAgICAgICAgZWQubm9kZUNoYW5nZWQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZUNhcmV0Rm9ybWF0KGVkLCBuYW1lLCB2YXJzLCBzaW1pbGFyKTtcbiAgICAgIH1cbiAgICAgIHJlbW92ZUxpc3RTdHlsZUZvcm1hdHMoZWQsIG5hbWUsIHZhcnMpO1xuICAgICAgZmlyZUZvcm1hdFJlbW92ZShlZCwgbmFtZSwgbm9kZSwgdmFycyk7XG4gICAgfTtcblxuICAgIGNvbnN0IGVhY2gkNiA9IFRvb2xzLmVhY2g7XG4gICAgY29uc3QgbWVyZ2VUZXh0RGVjb3JhdGlvbnNBbmRDb2xvciA9IChkb20sIGZvcm1hdCwgdmFycywgbm9kZSkgPT4ge1xuICAgICAgY29uc3QgcHJvY2Vzc1RleHREZWNvcmF0aW9uc0FuZENvbG9yID0gbiA9PiB7XG4gICAgICAgIGlmIChpc0VsZW1lbnQkNihuKSAmJiBpc0VsZW1lbnQkNihuLnBhcmVudE5vZGUpICYmIGlzRWRpdGFibGUkMihuKSkge1xuICAgICAgICAgIGNvbnN0IHBhcmVudFRleHREZWNvcmF0aW9uID0gZ2V0VGV4dERlY29yYXRpb24oZG9tLCBuLnBhcmVudE5vZGUpO1xuICAgICAgICAgIGlmIChkb20uZ2V0U3R5bGUobiwgJ2NvbG9yJykgJiYgcGFyZW50VGV4dERlY29yYXRpb24pIHtcbiAgICAgICAgICAgIGRvbS5zZXRTdHlsZShuLCAndGV4dC1kZWNvcmF0aW9uJywgcGFyZW50VGV4dERlY29yYXRpb24pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZG9tLmdldFN0eWxlKG4sICd0ZXh0LWRlY29yYXRpb24nKSA9PT0gcGFyZW50VGV4dERlY29yYXRpb24pIHtcbiAgICAgICAgICAgIGRvbS5zZXRTdHlsZShuLCAndGV4dC1kZWNvcmF0aW9uJywgbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKGZvcm1hdC5zdHlsZXMgJiYgKGZvcm1hdC5zdHlsZXMuY29sb3IgfHwgZm9ybWF0LnN0eWxlcy50ZXh0RGVjb3JhdGlvbikpIHtcbiAgICAgICAgVG9vbHMud2Fsayhub2RlLCBwcm9jZXNzVGV4dERlY29yYXRpb25zQW5kQ29sb3IsICdjaGlsZE5vZGVzJyk7XG4gICAgICAgIHByb2Nlc3NUZXh0RGVjb3JhdGlvbnNBbmRDb2xvcihub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG1lcmdlQmFja2dyb3VuZENvbG9yQW5kRm9udFNpemUgPSAoZG9tLCBmb3JtYXQsIHZhcnMsIG5vZGUpID0+IHtcbiAgICAgIGlmIChmb3JtYXQuc3R5bGVzICYmIGZvcm1hdC5zdHlsZXMuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgIGNvbnN0IGhhc0ZvbnRTaXplID0gaGFzU3R5bGUoZG9tLCAnZm9udFNpemUnKTtcbiAgICAgICAgcHJvY2Vzc0NoaWxkRWxlbWVudHMobm9kZSwgZWxtID0+IGhhc0ZvbnRTaXplKGVsbSkgJiYgaXNFZGl0YWJsZSQyKGVsbSksIGFwcGx5U3R5bGUoZG9tLCAnYmFja2dyb3VuZENvbG9yJywgcmVwbGFjZVZhcnMoZm9ybWF0LnN0eWxlcy5iYWNrZ3JvdW5kQ29sb3IsIHZhcnMpKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBtZXJnZVN1YlN1cCA9IChkb20sIGZvcm1hdCwgdmFycywgbm9kZSkgPT4ge1xuICAgICAgaWYgKGlzSW5saW5lRm9ybWF0KGZvcm1hdCkgJiYgKGZvcm1hdC5pbmxpbmUgPT09ICdzdWInIHx8IGZvcm1hdC5pbmxpbmUgPT09ICdzdXAnKSkge1xuICAgICAgICBjb25zdCBoYXNGb250U2l6ZSA9IGhhc1N0eWxlKGRvbSwgJ2ZvbnRTaXplJyk7XG4gICAgICAgIHByb2Nlc3NDaGlsZEVsZW1lbnRzKG5vZGUsIGVsbSA9PiBoYXNGb250U2l6ZShlbG0pICYmIGlzRWRpdGFibGUkMihlbG0pLCBhcHBseVN0eWxlKGRvbSwgJ2ZvbnRTaXplJywgJycpKTtcbiAgICAgICAgY29uc3QgaW52ZXJzZVRhZ0Rlc2NlbmRhbnRzID0gZmlsdGVyJDUoZG9tLnNlbGVjdChmb3JtYXQuaW5saW5lID09PSAnc3VwJyA/ICdzdWInIDogJ3N1cCcsIG5vZGUpLCBpc0VkaXRhYmxlJDIpO1xuICAgICAgICBkb20ucmVtb3ZlKGludmVyc2VUYWdEZXNjZW5kYW50cywgdHJ1ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBtZXJnZVdpdGhDaGlsZHJlbiA9IChlZGl0b3IsIGZvcm1hdExpc3QsIHZhcnMsIG5vZGUpID0+IHtcbiAgICAgIGVhY2gkNihmb3JtYXRMaXN0LCBmb3JtYXQgPT4ge1xuICAgICAgICBpZiAoaXNJbmxpbmVGb3JtYXQoZm9ybWF0KSkge1xuICAgICAgICAgIGVhY2gkNihlZGl0b3IuZG9tLnNlbGVjdChmb3JtYXQuaW5saW5lLCBub2RlKSwgY2hpbGQgPT4ge1xuICAgICAgICAgICAgaWYgKGlzRWxlbWVudE5vZGUoY2hpbGQpKSB7XG4gICAgICAgICAgICAgIHJlbW92ZUZvcm1hdCQxKGVkaXRvciwgZm9ybWF0LCB2YXJzLCBjaGlsZCwgZm9ybWF0LmV4YWN0ID8gY2hpbGQgOiBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhckNoaWxkU3R5bGVzKGVkaXRvci5kb20sIGZvcm1hdCwgbm9kZSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IG1lcmdlV2l0aFBhcmVudHMgPSAoZWRpdG9yLCBmb3JtYXQsIG5hbWUsIHZhcnMsIG5vZGUpID0+IHtcbiAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICBpZiAobWF0Y2hOb2RlKGVkaXRvciwgcGFyZW50Tm9kZSwgbmFtZSwgdmFycykpIHtcbiAgICAgICAgaWYgKHJlbW92ZUZvcm1hdCQxKGVkaXRvciwgZm9ybWF0LCB2YXJzLCBub2RlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvcm1hdC5tZXJnZV93aXRoX3BhcmVudHMgJiYgcGFyZW50Tm9kZSkge1xuICAgICAgICBlZGl0b3IuZG9tLmdldFBhcmVudChwYXJlbnROb2RlLCBwYXJlbnQgPT4ge1xuICAgICAgICAgIGlmIChtYXRjaE5vZGUoZWRpdG9yLCBwYXJlbnQsIG5hbWUsIHZhcnMpKSB7XG4gICAgICAgICAgICByZW1vdmVGb3JtYXQkMShlZGl0b3IsIGZvcm1hdCwgdmFycywgbm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGVhY2gkNSA9IFRvb2xzLmVhY2g7XG4gICAgY29uc3QgY2FuRm9ybWF0QlIgPSAoZWRpdG9yLCBmb3JtYXQsIG5vZGUsIHBhcmVudE5hbWUpID0+IHtcbiAgICAgIGlmIChjYW5Gb3JtYXRFbXB0eUxpbmVzKGVkaXRvcikgJiYgaXNJbmxpbmVGb3JtYXQoZm9ybWF0KSAmJiBub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgY29uc3QgdmFsaWRCUlBhcmVudEVsZW1lbnRzID0gZ2V0VGV4dFJvb3RCbG9ja0VsZW1lbnRzKGVkaXRvci5zY2hlbWEpO1xuICAgICAgICBjb25zdCBoYXNDYXJldE5vZGVTaWJsaW5nID0gc2libGluZyhTdWdhckVsZW1lbnQuZnJvbURvbShub2RlKSwgc2libGluZyA9PiBpc0NhcmV0Tm9kZShzaWJsaW5nLmRvbSkpO1xuICAgICAgICByZXR1cm4gaGFzTm9uTnVsbGFibGVLZXkodmFsaWRCUlBhcmVudEVsZW1lbnRzLCBwYXJlbnROYW1lKSAmJiBpc0VtcHR5JDIoU3VnYXJFbGVtZW50LmZyb21Eb20obm9kZS5wYXJlbnROb2RlKSwgZmFsc2UpICYmICFoYXNDYXJldE5vZGVTaWJsaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgYXBwbHlTdHlsZXMgPSAoZG9tLCBlbG0sIGZvcm1hdCwgdmFycykgPT4ge1xuICAgICAgZWFjaCQ1KGZvcm1hdC5zdHlsZXMsICh2YWx1ZSwgbmFtZSkgPT4ge1xuICAgICAgICBkb20uc2V0U3R5bGUoZWxtLCBuYW1lLCByZXBsYWNlVmFycyh2YWx1ZSwgdmFycykpO1xuICAgICAgfSk7XG4gICAgICBpZiAoZm9ybWF0LnN0eWxlcykge1xuICAgICAgICBjb25zdCBzdHlsZVZhbCA9IGRvbS5nZXRBdHRyaWIoZWxtLCAnc3R5bGUnKTtcbiAgICAgICAgaWYgKHN0eWxlVmFsKSB7XG4gICAgICAgICAgZG9tLnNldEF0dHJpYihlbG0sICdkYXRhLW1jZS1zdHlsZScsIHN0eWxlVmFsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgYXBwbHlGb3JtYXQkMSA9IChlZCwgbmFtZSwgdmFycywgbm9kZSkgPT4ge1xuICAgICAgY29uc3QgZm9ybWF0TGlzdCA9IGVkLmZvcm1hdHRlci5nZXQobmFtZSk7XG4gICAgICBjb25zdCBmb3JtYXQgPSBmb3JtYXRMaXN0WzBdO1xuICAgICAgY29uc3QgaXNDb2xsYXBzZWQgPSAhbm9kZSAmJiBlZC5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKTtcbiAgICAgIGNvbnN0IGRvbSA9IGVkLmRvbTtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGVkLnNlbGVjdGlvbjtcbiAgICAgIGNvbnN0IHNldEVsZW1lbnRGb3JtYXQgPSAoZWxtLCBmbXQgPSBmb3JtYXQpID0+IHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oZm10Lm9uZm9ybWF0KSkge1xuICAgICAgICAgIGZtdC5vbmZvcm1hdChlbG0sIGZtdCwgdmFycywgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgYXBwbHlTdHlsZXMoZG9tLCBlbG0sIGZtdCwgdmFycyk7XG4gICAgICAgIGVhY2gkNShmbXQuYXR0cmlidXRlcywgKHZhbHVlLCBuYW1lKSA9PiB7XG4gICAgICAgICAgZG9tLnNldEF0dHJpYihlbG0sIG5hbWUsIHJlcGxhY2VWYXJzKHZhbHVlLCB2YXJzKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBlYWNoJDUoZm10LmNsYXNzZXMsIHZhbHVlID0+IHtcbiAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHJlcGxhY2VWYXJzKHZhbHVlLCB2YXJzKTtcbiAgICAgICAgICBpZiAoIWRvbS5oYXNDbGFzcyhlbG0sIG5ld1ZhbHVlKSkge1xuICAgICAgICAgICAgZG9tLmFkZENsYXNzKGVsbSwgbmV3VmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgYXBwbHlOb2RlU3R5bGUgPSAoZm9ybWF0TGlzdCwgbm9kZSkgPT4ge1xuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgZWFjaCQ1KGZvcm1hdExpc3QsIGZvcm1hdCA9PiB7XG4gICAgICAgICAgaWYgKCFpc1NlbGVjdG9yRm9ybWF0KGZvcm1hdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRvbS5nZXRDb250ZW50RWRpdGFibGUobm9kZSkgPT09ICdmYWxzZScgJiYgIWZvcm1hdC5jZUZhbHNlT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNOb25OdWxsYWJsZShmb3JtYXQuY29sbGFwc2VkKSAmJiBmb3JtYXQuY29sbGFwc2VkICE9PSBpc0NvbGxhcHNlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkb20uaXMobm9kZSwgZm9ybWF0LnNlbGVjdG9yKSAmJiAhaXNDYXJldE5vZGUobm9kZSkpIHtcbiAgICAgICAgICAgIHNldEVsZW1lbnRGb3JtYXQobm9kZSwgZm9ybWF0KTtcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICB9O1xuICAgICAgY29uc3QgY3JlYXRlV3JhcEVsZW1lbnQgPSB3cmFwTmFtZSA9PiB7XG4gICAgICAgIGlmIChpc1N0cmluZyh3cmFwTmFtZSkpIHtcbiAgICAgICAgICBjb25zdCB3cmFwRWxtID0gZG9tLmNyZWF0ZSh3cmFwTmFtZSk7XG4gICAgICAgICAgc2V0RWxlbWVudEZvcm1hdCh3cmFwRWxtKTtcbiAgICAgICAgICByZXR1cm4gd3JhcEVsbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGFwcGx5Um5nU3R5bGUgPSAoZG9tLCBybmcsIG5vZGVTcGVjaWZpYykgPT4ge1xuICAgICAgICBjb25zdCBuZXdXcmFwcGVycyA9IFtdO1xuICAgICAgICBsZXQgY29udGVudEVkaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgY29uc3Qgd3JhcE5hbWUgPSBmb3JtYXQuaW5saW5lIHx8IGZvcm1hdC5ibG9jaztcbiAgICAgICAgY29uc3Qgd3JhcEVsbSA9IGNyZWF0ZVdyYXBFbGVtZW50KHdyYXBOYW1lKTtcbiAgICAgICAgY29uc3QgaXNNYXRjaGluZ1dyYXBwaW5nQmxvY2sgPSBub2RlID0+IGlzV3JhcHBpbmdCbG9ja0Zvcm1hdChmb3JtYXQpICYmIG1hdGNoTm9kZShlZCwgbm9kZSwgbmFtZSwgdmFycyk7XG4gICAgICAgIGNvbnN0IGNhblJlbmFtZUJsb2NrID0gKG5vZGUsIHBhcmVudE5hbWUsIGlzRWRpdGFibGVEZXNjZW5kYW50KSA9PiB7XG4gICAgICAgICAgY29uc3QgaXNWYWxpZEJsb2NrRm9ybWF0Rm9yTm9kZSA9IGlzTm9uV3JhcHBpbmdCbG9ja0Zvcm1hdChmb3JtYXQpICYmIGlzVGV4dEJsb2NrJDEoZWQuc2NoZW1hLCBub2RlKSAmJiBpc1ZhbGlkKGVkLCBwYXJlbnROYW1lLCB3cmFwTmFtZSk7XG4gICAgICAgICAgcmV0dXJuIGlzRWRpdGFibGVEZXNjZW5kYW50ICYmIGlzVmFsaWRCbG9ja0Zvcm1hdEZvck5vZGU7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNhbldyYXBOb2RlID0gKG5vZGUsIHBhcmVudE5hbWUsIGlzRWRpdGFibGVEZXNjZW5kYW50LCBpc1dyYXBwYWJsZU5vbmVkaXRhYmxlRWxtKSA9PiB7XG4gICAgICAgICAgY29uc3Qgbm9kZU5hbWUgPSBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgY29uc3QgaXNWYWxpZFdyYXBOb2RlID0gaXNWYWxpZChlZCwgd3JhcE5hbWUsIG5vZGVOYW1lKSAmJiBpc1ZhbGlkKGVkLCBwYXJlbnROYW1lLCB3cmFwTmFtZSk7XG4gICAgICAgICAgY29uc3QgaXNad3NwJDEgPSAhbm9kZVNwZWNpZmljICYmIGlzVGV4dCRhKG5vZGUpICYmIGlzWndzcChub2RlLmRhdGEpO1xuICAgICAgICAgIGNvbnN0IGlzQ2FyZXQgPSBpc0NhcmV0Tm9kZShub2RlKTtcbiAgICAgICAgICBjb25zdCBpc0NvcnJlY3RGb3JtYXRGb3JOb2RlID0gIWlzSW5saW5lRm9ybWF0KGZvcm1hdCkgfHwgIWRvbS5pc0Jsb2NrKG5vZGUpO1xuICAgICAgICAgIHJldHVybiAoaXNFZGl0YWJsZURlc2NlbmRhbnQgfHwgaXNXcmFwcGFibGVOb25lZGl0YWJsZUVsbSkgJiYgaXNWYWxpZFdyYXBOb2RlICYmICFpc1p3c3AkMSAmJiAhaXNDYXJldCAmJiBpc0NvcnJlY3RGb3JtYXRGb3JOb2RlO1xuICAgICAgICB9O1xuICAgICAgICB3YWxrJDMoZG9tLCBybmcsIG5vZGVzID0+IHtcbiAgICAgICAgICBsZXQgY3VycmVudFdyYXBFbG07XG4gICAgICAgICAgY29uc3QgcHJvY2VzcyA9IG5vZGUgPT4ge1xuICAgICAgICAgICAgbGV0IGhhc0NvbnRlbnRFZGl0YWJsZVN0YXRlID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgbGFzdENvbnRlbnRFZGl0YWJsZSA9IGNvbnRlbnRFZGl0YWJsZTtcbiAgICAgICAgICAgIGxldCBpc1dyYXBwYWJsZU5vbmVkaXRhYmxlRWxtID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50TmFtZSA9IHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRFZGl0YWJsZVZhbHVlID0gZG9tLmdldENvbnRlbnRFZGl0YWJsZShub2RlKTtcbiAgICAgICAgICAgIGlmIChpc05vbk51bGxhYmxlKGNvbnRlbnRFZGl0YWJsZVZhbHVlKSkge1xuICAgICAgICAgICAgICBsYXN0Q29udGVudEVkaXRhYmxlID0gY29udGVudEVkaXRhYmxlO1xuICAgICAgICAgICAgICBjb250ZW50RWRpdGFibGUgPSBjb250ZW50RWRpdGFibGVWYWx1ZSA9PT0gJ3RydWUnO1xuICAgICAgICAgICAgICBoYXNDb250ZW50RWRpdGFibGVTdGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgIGlzV3JhcHBhYmxlTm9uZWRpdGFibGVFbG0gPSBpc1dyYXBwYWJsZU5vbmVkaXRhYmxlKGVkLCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlzRWRpdGFibGVEZXNjZW5kYW50ID0gY29udGVudEVkaXRhYmxlICYmICFoYXNDb250ZW50RWRpdGFibGVTdGF0ZTtcbiAgICAgICAgICAgIGlmIChpc0JyJDYobm9kZSkgJiYgIWNhbkZvcm1hdEJSKGVkLCBmb3JtYXQsIG5vZGUsIHBhcmVudE5hbWUpKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRXcmFwRWxtID0gbnVsbDtcbiAgICAgICAgICAgICAgaWYgKGlzQmxvY2tGb3JtYXQoZm9ybWF0KSkge1xuICAgICAgICAgICAgICAgIGRvbS5yZW1vdmUobm9kZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTWF0Y2hpbmdXcmFwcGluZ0Jsb2NrKG5vZGUpKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRXcmFwRWxtID0gbnVsbDtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhblJlbmFtZUJsb2NrKG5vZGUsIHBhcmVudE5hbWUsIGlzRWRpdGFibGVEZXNjZW5kYW50KSkge1xuICAgICAgICAgICAgICBjb25zdCBlbG0gPSBkb20ucmVuYW1lKG5vZGUsIHdyYXBOYW1lKTtcbiAgICAgICAgICAgICAgc2V0RWxlbWVudEZvcm1hdChlbG0pO1xuICAgICAgICAgICAgICBuZXdXcmFwcGVycy5wdXNoKGVsbSk7XG4gICAgICAgICAgICAgIGN1cnJlbnRXcmFwRWxtID0gbnVsbDtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU2VsZWN0b3JGb3JtYXQoZm9ybWF0KSkge1xuICAgICAgICAgICAgICBsZXQgZm91bmQgPSBhcHBseU5vZGVTdHlsZShmb3JtYXRMaXN0LCBub2RlKTtcbiAgICAgICAgICAgICAgaWYgKCFmb3VuZCAmJiBpc05vbk51bGxhYmxlKHBhcmVudE5vZGUpICYmIHNob3VsZEV4cGFuZFRvU2VsZWN0b3IoZm9ybWF0KSkge1xuICAgICAgICAgICAgICAgIGZvdW5kID0gYXBwbHlOb2RlU3R5bGUoZm9ybWF0TGlzdCwgcGFyZW50Tm9kZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFpc0lubGluZUZvcm1hdChmb3JtYXQpIHx8IGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFdyYXBFbG0gPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTm9uTnVsbGFibGUod3JhcEVsbSkgJiYgY2FuV3JhcE5vZGUobm9kZSwgcGFyZW50TmFtZSwgaXNFZGl0YWJsZURlc2NlbmRhbnQsIGlzV3JhcHBhYmxlTm9uZWRpdGFibGVFbG0pKSB7XG4gICAgICAgICAgICAgIGlmICghY3VycmVudFdyYXBFbG0pIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50V3JhcEVsbSA9IGRvbS5jbG9uZSh3cmFwRWxtLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY3VycmVudFdyYXBFbG0sIG5vZGUpO1xuICAgICAgICAgICAgICAgIG5ld1dyYXBwZXJzLnB1c2goY3VycmVudFdyYXBFbG0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpc1dyYXBwYWJsZU5vbmVkaXRhYmxlRWxtICYmIGhhc0NvbnRlbnRFZGl0YWJsZVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY29udGVudEVkaXRhYmxlID0gbGFzdENvbnRlbnRFZGl0YWJsZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjdXJyZW50V3JhcEVsbS5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRXcmFwRWxtID0gbnVsbDtcbiAgICAgICAgICAgICAgZWFjaCRlKGZyb20obm9kZS5jaGlsZE5vZGVzKSwgcHJvY2Vzcyk7XG4gICAgICAgICAgICAgIGlmIChoYXNDb250ZW50RWRpdGFibGVTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRFZGl0YWJsZSA9IGxhc3RDb250ZW50RWRpdGFibGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY3VycmVudFdyYXBFbG0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgZWFjaCRlKG5vZGVzLCBwcm9jZXNzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChmb3JtYXQubGlua3MgPT09IHRydWUpIHtcbiAgICAgICAgICBlYWNoJGUobmV3V3JhcHBlcnMsIG5vZGUgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJvY2VzcyA9IG5vZGUgPT4ge1xuICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlTmFtZSA9PT0gJ0EnKSB7XG4gICAgICAgICAgICAgICAgc2V0RWxlbWVudEZvcm1hdChub2RlLCBmb3JtYXQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVhY2gkZShmcm9tKG5vZGUuY2hpbGROb2RlcyksIHByb2Nlc3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHByb2Nlc3Mobm9kZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWFjaCRlKG5ld1dyYXBwZXJzLCBub2RlID0+IHtcbiAgICAgICAgICBjb25zdCBnZXRDaGlsZENvdW50ID0gbm9kZSA9PiB7XG4gICAgICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICAgICAgZWFjaCRlKG5vZGUuY2hpbGROb2Rlcywgbm9kZSA9PiB7XG4gICAgICAgICAgICAgIGlmICghaXNFbXB0eVRleHROb2RlJDEobm9kZSkgJiYgIWlzQm9va21hcmtOb2RlJDEobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjb3VudDtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IG1lcmdlU3R5bGVzID0gbm9kZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZEVsZW1lbnQgPSBmaW5kJDIobm9kZS5jaGlsZE5vZGVzLCBpc0VsZW1lbnROb2RlJDEpLmZpbHRlcihjaGlsZCA9PiBkb20uZ2V0Q29udGVudEVkaXRhYmxlKGNoaWxkKSAhPT0gJ2ZhbHNlJyAmJiBtYXRjaE5hbWUoZG9tLCBjaGlsZCwgZm9ybWF0KSk7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGRFbGVtZW50Lm1hcChjaGlsZCA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGNsb25lID0gZG9tLmNsb25lKGNoaWxkLCBmYWxzZSk7XG4gICAgICAgICAgICAgIHNldEVsZW1lbnRGb3JtYXQoY2xvbmUpO1xuICAgICAgICAgICAgICBkb20ucmVwbGFjZShjbG9uZSwgbm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGRvbS5yZW1vdmUoY2hpbGQsIHRydWUpO1xuICAgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgICAgICAgICB9KS5nZXRPcihub2RlKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IGNoaWxkQ291bnQgPSBnZXRDaGlsZENvdW50KG5vZGUpO1xuICAgICAgICAgIGlmICgobmV3V3JhcHBlcnMubGVuZ3RoID4gMSB8fCAhZG9tLmlzQmxvY2sobm9kZSkpICYmIGNoaWxkQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIGRvbS5yZW1vdmUobm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0lubGluZUZvcm1hdChmb3JtYXQpIHx8IGlzQmxvY2tGb3JtYXQoZm9ybWF0KSAmJiBmb3JtYXQud3JhcHBlcikge1xuICAgICAgICAgICAgaWYgKCFmb3JtYXQuZXhhY3QgJiYgY2hpbGRDb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgICBub2RlID0gbWVyZ2VTdHlsZXMobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXJnZVdpdGhDaGlsZHJlbihlZCwgZm9ybWF0TGlzdCwgdmFycywgbm9kZSk7XG4gICAgICAgICAgICBtZXJnZVdpdGhQYXJlbnRzKGVkLCBmb3JtYXQsIG5hbWUsIHZhcnMsIG5vZGUpO1xuICAgICAgICAgICAgbWVyZ2VCYWNrZ3JvdW5kQ29sb3JBbmRGb250U2l6ZShkb20sIGZvcm1hdCwgdmFycywgbm9kZSk7XG4gICAgICAgICAgICBtZXJnZVRleHREZWNvcmF0aW9uc0FuZENvbG9yKGRvbSwgZm9ybWF0LCB2YXJzLCBub2RlKTtcbiAgICAgICAgICAgIG1lcmdlU3ViU3VwKGRvbSwgZm9ybWF0LCB2YXJzLCBub2RlKTtcbiAgICAgICAgICAgIG1lcmdlU2libGluZ3MoZWQsIGZvcm1hdCwgdmFycywgbm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCB0YXJnZXROb2RlID0gaXNOb2RlKG5vZGUpID8gbm9kZSA6IHNlbGVjdGlvbi5nZXROb2RlKCk7XG4gICAgICBpZiAoZG9tLmdldENvbnRlbnRFZGl0YWJsZSh0YXJnZXROb2RlKSA9PT0gJ2ZhbHNlJyAmJiAhaXNXcmFwcGFibGVOb25lZGl0YWJsZShlZCwgdGFyZ2V0Tm9kZSkpIHtcbiAgICAgICAgbm9kZSA9IHRhcmdldE5vZGU7XG4gICAgICAgIGFwcGx5Tm9kZVN0eWxlKGZvcm1hdExpc3QsIG5vZGUpO1xuICAgICAgICBmaXJlRm9ybWF0QXBwbHkoZWQsIG5hbWUsIG5vZGUsIHZhcnMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZm9ybWF0KSB7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgaWYgKGlzTm9kZShub2RlKSkge1xuICAgICAgICAgICAgaWYgKCFhcHBseU5vZGVTdHlsZShmb3JtYXRMaXN0LCBub2RlKSkge1xuICAgICAgICAgICAgICBjb25zdCBybmcgPSBkb20uY3JlYXRlUm5nKCk7XG4gICAgICAgICAgICAgIHJuZy5zZXRTdGFydEJlZm9yZShub2RlKTtcbiAgICAgICAgICAgICAgcm5nLnNldEVuZEFmdGVyKG5vZGUpO1xuICAgICAgICAgICAgICBhcHBseVJuZ1N0eWxlKGRvbSwgZXhwYW5kUm5nKGRvbSwgcm5nLCBmb3JtYXRMaXN0KSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFwcGx5Um5nU3R5bGUoZG9tLCBub2RlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFpc0NvbGxhcHNlZCB8fCAhaXNJbmxpbmVGb3JtYXQoZm9ybWF0KSB8fCBnZXRDZWxsc0Zyb21FZGl0b3IoZWQpLmxlbmd0aCkge1xuICAgICAgICAgICAgc2VsZWN0aW9uLnNldFJuZyhub3JtYWxpemUoc2VsZWN0aW9uLmdldFJuZygpKSk7XG4gICAgICAgICAgICBwcmVzZXJ2ZVNlbGVjdGlvbihlZCwgKCkgPT4ge1xuICAgICAgICAgICAgICBydW5PblJhbmdlcyhlZCwgKHNlbGVjdGlvblJuZywgZmFrZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cGFuZGVkUm5nID0gZmFrZSA/IHNlbGVjdGlvblJuZyA6IGV4cGFuZFJuZyhkb20sIHNlbGVjdGlvblJuZywgZm9ybWF0TGlzdCk7XG4gICAgICAgICAgICAgICAgYXBwbHlSbmdTdHlsZShkb20sIGV4cGFuZGVkUm5nLCBmYWxzZSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgYWx3YXlzKTtcbiAgICAgICAgICAgIGVkLm5vZGVDaGFuZ2VkKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFwcGx5Q2FyZXRGb3JtYXQoZWQsIG5hbWUsIHZhcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBnZXRFeHBhbmRlZExpc3RJdGVtRm9ybWF0KGVkLmZvcm1hdHRlciwgbmFtZSkuZWFjaChsaUZtdCA9PiB7XG4gICAgICAgICAgICBlYWNoJGUoZ2V0RnVsbHlTZWxlY3RlZExpc3RJdGVtcyhlZC5zZWxlY3Rpb24pLCBsaSA9PiBhcHBseVN0eWxlcyhkb20sIGxpLCBsaUZtdCwgdmFycykpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHBvc3RQcm9jZXNzJDEobmFtZSwgZWQpO1xuICAgICAgfVxuICAgICAgZmlyZUZvcm1hdEFwcGx5KGVkLCBuYW1lLCBub2RlLCB2YXJzKTtcbiAgICB9O1xuXG4gICAgY29uc3QgaGFzVmFycyA9IHZhbHVlID0+IGhhcyQyKHZhbHVlLCAndmFycycpO1xuICAgIGNvbnN0IHNldHVwJHQgPSAocmVnaXN0ZXJlZEZvcm1hdExpc3RlbmVycywgZWRpdG9yKSA9PiB7XG4gICAgICByZWdpc3RlcmVkRm9ybWF0TGlzdGVuZXJzLnNldCh7fSk7XG4gICAgICBlZGl0b3Iub24oJ05vZGVDaGFuZ2UnLCBlID0+IHtcbiAgICAgICAgdXBkYXRlQW5kRmlyZUNoYW5nZUNhbGxiYWNrcyhlZGl0b3IsIGUuZWxlbWVudCwgcmVnaXN0ZXJlZEZvcm1hdExpc3RlbmVycy5nZXQoKSk7XG4gICAgICB9KTtcbiAgICAgIGVkaXRvci5vbignRm9ybWF0QXBwbHkgRm9ybWF0UmVtb3ZlJywgZSA9PiB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBPcHRpb25hbC5mcm9tKGUubm9kZSkubWFwKG5vZGVPclJhbmdlID0+IGlzTm9kZShub2RlT3JSYW5nZSkgPyBub2RlT3JSYW5nZSA6IG5vZGVPclJhbmdlLnN0YXJ0Q29udGFpbmVyKS5iaW5kKG5vZGUgPT4gaXNFbGVtZW50JDYobm9kZSkgPyBPcHRpb25hbC5zb21lKG5vZGUpIDogT3B0aW9uYWwuZnJvbShub2RlLnBhcmVudEVsZW1lbnQpKS5nZXRPclRodW5rKCgpID0+IGZhbGxiYWNrRWxlbWVudChlZGl0b3IpKTtcbiAgICAgICAgdXBkYXRlQW5kRmlyZUNoYW5nZUNhbGxiYWNrcyhlZGl0b3IsIGVsZW1lbnQsIHJlZ2lzdGVyZWRGb3JtYXRMaXN0ZW5lcnMuZ2V0KCkpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBmYWxsYmFja0VsZW1lbnQgPSBlZGl0b3IgPT4gZWRpdG9yLnNlbGVjdGlvbi5nZXRTdGFydCgpO1xuICAgIGNvbnN0IG1hdGNoaW5nTm9kZSA9IChlZGl0b3IsIHBhcmVudHMsIGZvcm1hdCwgc2ltaWxhciwgdmFycykgPT4ge1xuICAgICAgY29uc3QgaXNNYXRjaGluZ05vZGUgPSBub2RlID0+IHtcbiAgICAgICAgY29uc3QgbWF0Y2hpbmdGb3JtYXQgPSBlZGl0b3IuZm9ybWF0dGVyLm1hdGNoTm9kZShub2RlLCBmb3JtYXQsIHZhcnMgIT09IG51bGwgJiYgdmFycyAhPT0gdm9pZCAwID8gdmFycyA6IHt9LCBzaW1pbGFyKTtcbiAgICAgICAgcmV0dXJuICFpc1VuZGVmaW5lZChtYXRjaGluZ0Zvcm1hdCk7XG4gICAgICB9O1xuICAgICAgY29uc3QgaXNVbmFibGVUb01hdGNoID0gbm9kZSA9PiB7XG4gICAgICAgIGlmIChtYXRjaGVzVW5Jbmhlcml0ZWRGb3JtYXRTZWxlY3RvcihlZGl0b3IsIG5vZGUsIGZvcm1hdCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIXNpbWlsYXIpIHtcbiAgICAgICAgICAgIHJldHVybiBpc05vbk51bGxhYmxlKGVkaXRvci5mb3JtYXR0ZXIubWF0Y2hOb2RlKG5vZGUsIGZvcm1hdCwgdmFycywgdHJ1ZSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGZpbmRVbnRpbCQxKHBhcmVudHMsIGlzTWF0Y2hpbmdOb2RlLCBpc1VuYWJsZVRvTWF0Y2gpO1xuICAgIH07XG4gICAgY29uc3QgZ2V0UGFyZW50cyA9IChlZGl0b3IsIGVsbSkgPT4ge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGVsbSAhPT0gbnVsbCAmJiBlbG0gIT09IHZvaWQgMCA/IGVsbSA6IGZhbGxiYWNrRWxlbWVudChlZGl0b3IpO1xuICAgICAgcmV0dXJuIGZpbHRlciQ1KGdldFBhcmVudHMkMihlZGl0b3IuZG9tLCBlbGVtZW50KSwgbm9kZSA9PiBpc0VsZW1lbnQkNihub2RlKSAmJiAhaXNCb2d1cyQyKG5vZGUpKTtcbiAgICB9O1xuICAgIGNvbnN0IHVwZGF0ZUFuZEZpcmVDaGFuZ2VDYWxsYmFja3MgPSAoZWRpdG9yLCBlbG0sIHJlZ2lzdGVyZWRDYWxsYmFja3MpID0+IHtcbiAgICAgIGNvbnN0IHBhcmVudHMgPSBnZXRQYXJlbnRzKGVkaXRvciwgZWxtKTtcbiAgICAgIGVhY2gkZChyZWdpc3RlcmVkQ2FsbGJhY2tzLCAoZGF0YSwgZm9ybWF0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJ1bklmQ2hhbmdlZCA9IHNwZWMgPT4ge1xuICAgICAgICAgIGNvbnN0IG1hdGNoID0gbWF0Y2hpbmdOb2RlKGVkaXRvciwgcGFyZW50cywgZm9ybWF0LCBzcGVjLnNpbWlsYXIsIGhhc1ZhcnMoc3BlYykgPyBzcGVjLnZhcnMgOiB1bmRlZmluZWQpO1xuICAgICAgICAgIGNvbnN0IGlzU2V0ID0gbWF0Y2guaXNTb21lKCk7XG4gICAgICAgICAgaWYgKHNwZWMuc3RhdGUuZ2V0KCkgIT09IGlzU2V0KSB7XG4gICAgICAgICAgICBzcGVjLnN0YXRlLnNldChpc1NldCk7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gbWF0Y2guZ2V0T3IoZWxtKTtcbiAgICAgICAgICAgIGlmIChoYXNWYXJzKHNwZWMpKSB7XG4gICAgICAgICAgICAgIHNwZWMuY2FsbGJhY2soaXNTZXQsIHtcbiAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgIGZvcm1hdCxcbiAgICAgICAgICAgICAgICBwYXJlbnRzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWFjaCRlKHNwZWMuY2FsbGJhY2tzLCBjYWxsYmFjayA9PiBjYWxsYmFjayhpc1NldCwge1xuICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgZm9ybWF0LFxuICAgICAgICAgICAgICAgIHBhcmVudHNcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZWFjaCRlKFtcbiAgICAgICAgICBkYXRhLndpdGhTaW1pbGFyLFxuICAgICAgICAgIGRhdGEud2l0aG91dFNpbWlsYXJcbiAgICAgICAgXSwgcnVuSWZDaGFuZ2VkKTtcbiAgICAgICAgZWFjaCRlKGRhdGEud2l0aFZhcnMsIHJ1bklmQ2hhbmdlZCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGFkZExpc3RlbmVycyA9IChlZGl0b3IsIHJlZ2lzdGVyZWRGb3JtYXRMaXN0ZW5lcnMsIGZvcm1hdHMsIGNhbGxiYWNrLCBzaW1pbGFyLCB2YXJzKSA9PiB7XG4gICAgICBjb25zdCBmb3JtYXRDaGFuZ2VJdGVtcyA9IHJlZ2lzdGVyZWRGb3JtYXRMaXN0ZW5lcnMuZ2V0KCk7XG4gICAgICBlYWNoJGUoZm9ybWF0cy5zcGxpdCgnLCcpLCBmb3JtYXQgPT4ge1xuICAgICAgICBjb25zdCBncm91cCA9IGdldCRhKGZvcm1hdENoYW5nZUl0ZW1zLCBmb3JtYXQpLmdldE9yVGh1bmsoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGJhc2UgPSB7XG4gICAgICAgICAgICB3aXRoU2ltaWxhcjoge1xuICAgICAgICAgICAgICBzdGF0ZTogQ2VsbChmYWxzZSksXG4gICAgICAgICAgICAgIHNpbWlsYXI6IHRydWUsXG4gICAgICAgICAgICAgIGNhbGxiYWNrczogW11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3aXRob3V0U2ltaWxhcjoge1xuICAgICAgICAgICAgICBzdGF0ZTogQ2VsbChmYWxzZSksXG4gICAgICAgICAgICAgIHNpbWlsYXI6IGZhbHNlLFxuICAgICAgICAgICAgICBjYWxsYmFja3M6IFtdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd2l0aFZhcnM6IFtdXG4gICAgICAgICAgfTtcbiAgICAgICAgICBmb3JtYXRDaGFuZ2VJdGVtc1tmb3JtYXRdID0gYmFzZTtcbiAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGdldEN1cnJlbnQgPSAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgcGFyZW50cyA9IGdldFBhcmVudHMoZWRpdG9yKTtcbiAgICAgICAgICByZXR1cm4gbWF0Y2hpbmdOb2RlKGVkaXRvciwgcGFyZW50cywgZm9ybWF0LCBzaW1pbGFyLCB2YXJzKS5pc1NvbWUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhcnMpKSB7XG4gICAgICAgICAgY29uc3QgdG9BcHBlbmRUbyA9IHNpbWlsYXIgPyBncm91cC53aXRoU2ltaWxhciA6IGdyb3VwLndpdGhvdXRTaW1pbGFyO1xuICAgICAgICAgIHRvQXBwZW5kVG8uY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgIGlmICh0b0FwcGVuZFRvLmNhbGxiYWNrcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRvQXBwZW5kVG8uc3RhdGUuc2V0KGdldEN1cnJlbnQoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdyb3VwLndpdGhWYXJzLnB1c2goe1xuICAgICAgICAgICAgc3RhdGU6IENlbGwoZ2V0Q3VycmVudCgpKSxcbiAgICAgICAgICAgIHNpbWlsYXIsXG4gICAgICAgICAgICB2YXJzLFxuICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZWdpc3RlcmVkRm9ybWF0TGlzdGVuZXJzLnNldChmb3JtYXRDaGFuZ2VJdGVtcyk7XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVMaXN0ZW5lcnMgPSAocmVnaXN0ZXJlZEZvcm1hdExpc3RlbmVycywgZm9ybWF0cywgY2FsbGJhY2spID0+IHtcbiAgICAgIGNvbnN0IGZvcm1hdENoYW5nZUl0ZW1zID0gcmVnaXN0ZXJlZEZvcm1hdExpc3RlbmVycy5nZXQoKTtcbiAgICAgIGVhY2gkZShmb3JtYXRzLnNwbGl0KCcsJyksIGZvcm1hdCA9PiBnZXQkYShmb3JtYXRDaGFuZ2VJdGVtcywgZm9ybWF0KS5lYWNoKGdyb3VwID0+IHtcbiAgICAgICAgZm9ybWF0Q2hhbmdlSXRlbXNbZm9ybWF0XSA9IHtcbiAgICAgICAgICB3aXRoU2ltaWxhcjoge1xuICAgICAgICAgICAgLi4uZ3JvdXAud2l0aFNpbWlsYXIsXG4gICAgICAgICAgICBjYWxsYmFja3M6IGZpbHRlciQ1KGdyb3VwLndpdGhTaW1pbGFyLmNhbGxiYWNrcywgY2IgPT4gY2IgIT09IGNhbGxiYWNrKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgd2l0aG91dFNpbWlsYXI6IHtcbiAgICAgICAgICAgIC4uLmdyb3VwLndpdGhvdXRTaW1pbGFyLFxuICAgICAgICAgICAgY2FsbGJhY2tzOiBmaWx0ZXIkNShncm91cC53aXRob3V0U2ltaWxhci5jYWxsYmFja3MsIGNiID0+IGNiICE9PSBjYWxsYmFjaylcbiAgICAgICAgICB9LFxuICAgICAgICAgIHdpdGhWYXJzOiBmaWx0ZXIkNShncm91cC53aXRoVmFycywgaXRlbSA9PiBpdGVtLmNhbGxiYWNrICE9PSBjYWxsYmFjaylcbiAgICAgICAgfTtcbiAgICAgIH0pKTtcbiAgICAgIHJlZ2lzdGVyZWRGb3JtYXRMaXN0ZW5lcnMuc2V0KGZvcm1hdENoYW5nZUl0ZW1zKTtcbiAgICB9O1xuICAgIGNvbnN0IGZvcm1hdENoYW5nZWRJbnRlcm5hbCA9IChlZGl0b3IsIHJlZ2lzdGVyZWRGb3JtYXRMaXN0ZW5lcnMsIGZvcm1hdHMsIGNhbGxiYWNrLCBzaW1pbGFyLCB2YXJzKSA9PiB7XG4gICAgICBhZGRMaXN0ZW5lcnMoZWRpdG9yLCByZWdpc3RlcmVkRm9ybWF0TGlzdGVuZXJzLCBmb3JtYXRzLCBjYWxsYmFjaywgc2ltaWxhciwgdmFycyk7XG4gICAgICByZXR1cm4geyB1bmJpbmQ6ICgpID0+IHJlbW92ZUxpc3RlbmVycyhyZWdpc3RlcmVkRm9ybWF0TGlzdGVuZXJzLCBmb3JtYXRzLCBjYWxsYmFjaykgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgdG9nZ2xlID0gKGVkaXRvciwgbmFtZSwgdmFycywgbm9kZSkgPT4ge1xuICAgICAgY29uc3QgZm10ID0gZWRpdG9yLmZvcm1hdHRlci5nZXQobmFtZSk7XG4gICAgICBpZiAoZm10KSB7XG4gICAgICAgIGlmIChtYXRjaCQyKGVkaXRvciwgbmFtZSwgdmFycywgbm9kZSkgJiYgKCEoJ3RvZ2dsZScgaW4gZm10WzBdKSB8fCBmbXRbMF0udG9nZ2xlKSkge1xuICAgICAgICAgIHJlbW92ZSQyKGVkaXRvciwgbmFtZSwgdmFycywgbm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXBwbHlGb3JtYXQkMShlZGl0b3IsIG5hbWUsIHZhcnMsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGV4cGxvZGUkMSA9IFRvb2xzLmV4cGxvZGU7XG4gICAgY29uc3QgY3JlYXRlJDggPSAoKSA9PiB7XG4gICAgICBjb25zdCBmaWx0ZXJzID0ge307XG4gICAgICBjb25zdCBhZGRGaWx0ZXIgPSAobmFtZSwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgZWFjaCRlKGV4cGxvZGUkMShuYW1lKSwgbmFtZSA9PiB7XG4gICAgICAgICAgaWYgKCFoYXMkMihmaWx0ZXJzLCBuYW1lKSkge1xuICAgICAgICAgICAgZmlsdGVyc1tuYW1lXSA9IHtcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgY2FsbGJhY2tzOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmlsdGVyc1tuYW1lXS5jYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldEZpbHRlcnMgPSAoKSA9PiB2YWx1ZXMoZmlsdGVycyk7XG4gICAgICBjb25zdCByZW1vdmVGaWx0ZXIgPSAobmFtZSwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgZWFjaCRlKGV4cGxvZGUkMShuYW1lKSwgbmFtZSA9PiB7XG4gICAgICAgICAgaWYgKGhhcyQyKGZpbHRlcnMsIG5hbWUpKSB7XG4gICAgICAgICAgICBpZiAoaXNOb25OdWxsYWJsZShjYWxsYmFjaykpIHtcbiAgICAgICAgICAgICAgY29uc3QgZmlsdGVyID0gZmlsdGVyc1tuYW1lXTtcbiAgICAgICAgICAgICAgY29uc3QgbmV3Q2FsbGJhY2tzID0gZmlsdGVyJDUoZmlsdGVyLmNhbGxiYWNrcywgYyA9PiBjICE9PSBjYWxsYmFjayk7XG4gICAgICAgICAgICAgIGlmIChuZXdDYWxsYmFja3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZpbHRlci5jYWxsYmFja3MgPSBuZXdDYWxsYmFja3M7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGZpbHRlcnNbbmFtZV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBmaWx0ZXJzW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWRkRmlsdGVyLFxuICAgICAgICBnZXRGaWx0ZXJzLFxuICAgICAgICByZW1vdmVGaWx0ZXJcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IHJlbW92ZUF0dHJzID0gKG5vZGUsIG5hbWVzKSA9PiB7XG4gICAgICBlYWNoJGUobmFtZXMsIG5hbWUgPT4ge1xuICAgICAgICBub2RlLmF0dHIobmFtZSwgbnVsbCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGFkZEZvbnRUb1NwYW5zRmlsdGVyID0gKGRvbVBhcnNlciwgc3R5bGVzLCBmb250U2l6ZXMpID0+IHtcbiAgICAgIGRvbVBhcnNlci5hZGROb2RlRmlsdGVyKCdmb250Jywgbm9kZXMgPT4ge1xuICAgICAgICBlYWNoJGUobm9kZXMsIG5vZGUgPT4ge1xuICAgICAgICAgIGNvbnN0IHByb3BzID0gc3R5bGVzLnBhcnNlKG5vZGUuYXR0cignc3R5bGUnKSk7XG4gICAgICAgICAgY29uc3QgY29sb3IgPSBub2RlLmF0dHIoJ2NvbG9yJyk7XG4gICAgICAgICAgY29uc3QgZmFjZSA9IG5vZGUuYXR0cignZmFjZScpO1xuICAgICAgICAgIGNvbnN0IHNpemUgPSBub2RlLmF0dHIoJ3NpemUnKTtcbiAgICAgICAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgICAgIHByb3BzLmNvbG9yID0gY29sb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmYWNlKSB7XG4gICAgICAgICAgICBwcm9wc1snZm9udC1mYW1pbHknXSA9IGZhY2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzaXplKSB7XG4gICAgICAgICAgICB0b0ludChzaXplKS5lYWNoKG51bSA9PiB7XG4gICAgICAgICAgICAgIHByb3BzWydmb250LXNpemUnXSA9IGZvbnRTaXplc1tudW0gLSAxXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLm5hbWUgPSAnc3Bhbic7XG4gICAgICAgICAgbm9kZS5hdHRyKCdzdHlsZScsIHN0eWxlcy5zZXJpYWxpemUocHJvcHMpKTtcbiAgICAgICAgICByZW1vdmVBdHRycyhub2RlLCBbXG4gICAgICAgICAgICAnY29sb3InLFxuICAgICAgICAgICAgJ2ZhY2UnLFxuICAgICAgICAgICAgJ3NpemUnXG4gICAgICAgICAgXSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBhZGRTdHJpa2VGaWx0ZXIgPSAoZG9tUGFyc2VyLCBzY2hlbWEsIHN0eWxlcykgPT4ge1xuICAgICAgZG9tUGFyc2VyLmFkZE5vZGVGaWx0ZXIoJ3N0cmlrZScsIG5vZGVzID0+IHtcbiAgICAgICAgY29uc3QgY29udmVydFRvU1RhZyA9IHNjaGVtYS50eXBlICE9PSAnaHRtbDQnO1xuICAgICAgICBlYWNoJGUobm9kZXMsIG5vZGUgPT4ge1xuICAgICAgICAgIGlmIChjb252ZXJ0VG9TVGFnKSB7XG4gICAgICAgICAgICBub2RlLm5hbWUgPSAncyc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BzID0gc3R5bGVzLnBhcnNlKG5vZGUuYXR0cignc3R5bGUnKSk7XG4gICAgICAgICAgICBwcm9wc1sndGV4dC1kZWNvcmF0aW9uJ10gPSAnbGluZS10aHJvdWdoJztcbiAgICAgICAgICAgIG5vZGUubmFtZSA9ICdzcGFuJztcbiAgICAgICAgICAgIG5vZGUuYXR0cignc3R5bGUnLCBzdHlsZXMuc2VyaWFsaXplKHByb3BzKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgYWRkRmlsdGVycyA9IChkb21QYXJzZXIsIHNldHRpbmdzLCBzY2hlbWEpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IHN0eWxlcyA9IFN0eWxlcygpO1xuICAgICAgaWYgKHNldHRpbmdzLmNvbnZlcnRfZm9udHNfdG9fc3BhbnMpIHtcbiAgICAgICAgYWRkRm9udFRvU3BhbnNGaWx0ZXIoZG9tUGFyc2VyLCBzdHlsZXMsIFRvb2xzLmV4cGxvZGUoKF9hID0gc2V0dGluZ3MuZm9udF9zaXplX2xlZ2FjeV92YWx1ZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKSk7XG4gICAgICB9XG4gICAgICBhZGRTdHJpa2VGaWx0ZXIoZG9tUGFyc2VyLCBzY2hlbWEsIHN0eWxlcyk7XG4gICAgfTtcbiAgICBjb25zdCByZWdpc3RlciQ1ID0gKGRvbVBhcnNlciwgc2V0dGluZ3MsIHNjaGVtYSkgPT4ge1xuICAgICAgaWYgKHNldHRpbmdzLmlubGluZV9zdHlsZXMpIHtcbiAgICAgICAgYWRkRmlsdGVycyhkb21QYXJzZXIsIHNldHRpbmdzLCBzY2hlbWEpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBibG9iVXJpVG9CbG9iID0gdXJsID0+IGZldGNoKHVybCkudGhlbihyZXMgPT4gcmVzLm9rID8gcmVzLmJsb2IoKSA6IFByb21pc2UucmVqZWN0KCkpLmNhdGNoKCgpID0+IFByb21pc2UucmVqZWN0KHtcbiAgICAgIG1lc3NhZ2U6IGBDYW5ub3QgY29udmVydCAkeyB1cmwgfSB0byBCbG9iLiBSZXNvdXJjZSBtaWdodCBub3QgZXhpc3Qgb3IgaXMgaW5hY2Nlc3NpYmxlLmAsXG4gICAgICB1cmlUeXBlOiAnYmxvYidcbiAgICB9KSk7XG4gICAgY29uc3QgZXh0cmFjdEJhc2U2NERhdGEgPSBkYXRhID0+IHtcbiAgICAgIGNvbnN0IG1hdGNoZXMgPSAvKFthLXowLTkrXFwvPVxcc10rKS9pLmV4ZWMoZGF0YSk7XG4gICAgICByZXR1cm4gbWF0Y2hlcyA/IG1hdGNoZXNbMV0gOiAnJztcbiAgICB9O1xuICAgIGNvbnN0IHBhcnNlRGF0YVVyaSA9IHVyaSA9PiB7XG4gICAgICBjb25zdCBbdHlwZSwgLi4ucmVzdF0gPSB1cmkuc3BsaXQoJywnKTtcbiAgICAgIGNvbnN0IGRhdGEgPSByZXN0LmpvaW4oJywnKTtcbiAgICAgIGNvbnN0IG1hdGNoZXMgPSAvZGF0YTooW14vXStcXC9bXjtdKykoOy4rKT8vLmV4ZWModHlwZSk7XG4gICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICBjb25zdCBiYXNlNjRFbmNvZGVkID0gbWF0Y2hlc1syXSA9PT0gJztiYXNlNjQnO1xuICAgICAgICBjb25zdCBleHRyYWN0ZWREYXRhID0gYmFzZTY0RW5jb2RlZCA/IGV4dHJhY3RCYXNlNjREYXRhKGRhdGEpIDogZGVjb2RlVVJJQ29tcG9uZW50KGRhdGEpO1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZSh7XG4gICAgICAgICAgdHlwZTogbWF0Y2hlc1sxXSxcbiAgICAgICAgICBkYXRhOiBleHRyYWN0ZWREYXRhLFxuICAgICAgICAgIGJhc2U2NEVuY29kZWRcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgYnVpbGRCbG9iID0gKHR5cGUsIGRhdGEsIGJhc2U2NEVuY29kZWQgPSB0cnVlKSA9PiB7XG4gICAgICBsZXQgc3RyID0gZGF0YTtcbiAgICAgIGlmIChiYXNlNjRFbmNvZGVkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc3RyID0gYXRvYihkYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KHN0ci5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShuZXcgQmxvYihbYXJyXSwgeyB0eXBlIH0pKTtcbiAgICB9O1xuICAgIGNvbnN0IGRhdGFVcmlUb0Jsb2IgPSB1cmkgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgcGFyc2VEYXRhVXJpKHVyaSkuYmluZCgoe3R5cGUsIGRhdGEsIGJhc2U2NEVuY29kZWR9KSA9PiBidWlsZEJsb2IodHlwZSwgZGF0YSwgYmFzZTY0RW5jb2RlZCkpLmZvbGQoKCkgPT4gcmVqZWN0KCdJbnZhbGlkIGRhdGEgVVJJJyksIHJlc29sdmUpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCB1cmlUb0Jsb2IgPSB1cmwgPT4ge1xuICAgICAgaWYgKHN0YXJ0c1dpdGgodXJsLCAnYmxvYjonKSkge1xuICAgICAgICByZXR1cm4gYmxvYlVyaVRvQmxvYih1cmwpO1xuICAgICAgfSBlbHNlIGlmIChzdGFydHNXaXRoKHVybCwgJ2RhdGE6JykpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFVcmlUb0Jsb2IodXJsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnVW5rbm93biBVUkkgZm9ybWF0Jyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBibG9iVG9EYXRhVXJpID0gYmxvYiA9PiB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICByZWFkZXIub25sb2FkZW5kID0gKCkgPT4ge1xuICAgICAgICAgIHJlc29sdmUocmVhZGVyLnJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlYWRlci5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICByZWplY3QoKF9hID0gcmVhZGVyLmVycm9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWVzc2FnZSk7XG4gICAgICAgIH07XG4gICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGJsb2IpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGxldCBjb3VudCQxID0gMDtcbiAgICBjb25zdCB1bmlxdWVJZCQxID0gcHJlZml4ID0+IHtcbiAgICAgIHJldHVybiAocHJlZml4IHx8ICdibG9iaWQnKSArIGNvdW50JDErKztcbiAgICB9O1xuICAgIGNvbnN0IHByb2Nlc3NEYXRhVXJpID0gKGRhdGFVcmksIGJhc2U2NE9ubHksIGdlbmVyYXRlQmxvYkluZm8pID0+IHtcbiAgICAgIHJldHVybiBwYXJzZURhdGFVcmkoZGF0YVVyaSkuYmluZCgoe2RhdGEsIHR5cGUsIGJhc2U2NEVuY29kZWR9KSA9PiB7XG4gICAgICAgIGlmIChiYXNlNjRPbmx5ICYmICFiYXNlNjRFbmNvZGVkKSB7XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBiYXNlNjQgPSBiYXNlNjRFbmNvZGVkID8gZGF0YSA6IGJ0b2EoZGF0YSk7XG4gICAgICAgICAgcmV0dXJuIGdlbmVyYXRlQmxvYkluZm8oYmFzZTY0LCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGVCbG9iSW5mbyQxID0gKGJsb2JDYWNoZSwgYmxvYiwgYmFzZTY0KSA9PiB7XG4gICAgICBjb25zdCBibG9iSW5mbyA9IGJsb2JDYWNoZS5jcmVhdGUodW5pcXVlSWQkMSgpLCBibG9iLCBiYXNlNjQpO1xuICAgICAgYmxvYkNhY2hlLmFkZChibG9iSW5mbyk7XG4gICAgICByZXR1cm4gYmxvYkluZm87XG4gICAgfTtcbiAgICBjb25zdCBkYXRhVXJpVG9CbG9iSW5mbyA9IChibG9iQ2FjaGUsIGRhdGFVcmksIGJhc2U2NE9ubHkgPSBmYWxzZSkgPT4ge1xuICAgICAgcmV0dXJuIHByb2Nlc3NEYXRhVXJpKGRhdGFVcmksIGJhc2U2NE9ubHksIChiYXNlNjQsIHR5cGUpID0+IE9wdGlvbmFsLmZyb20oYmxvYkNhY2hlLmdldEJ5RGF0YShiYXNlNjQsIHR5cGUpKS5vclRodW5rKCgpID0+IGJ1aWxkQmxvYih0eXBlLCBiYXNlNjQpLm1hcChibG9iID0+IGNyZWF0ZUJsb2JJbmZvJDEoYmxvYkNhY2hlLCBibG9iLCBiYXNlNjQpKSkpO1xuICAgIH07XG4gICAgY29uc3QgaW1hZ2VUb0Jsb2JJbmZvID0gKGJsb2JDYWNoZSwgaW1hZ2VTcmMpID0+IHtcbiAgICAgIGNvbnN0IGludmFsaWREYXRhVXJpID0gKCkgPT4gUHJvbWlzZS5yZWplY3QoJ0ludmFsaWQgZGF0YSBVUkknKTtcbiAgICAgIGlmIChzdGFydHNXaXRoKGltYWdlU3JjLCAnYmxvYjonKSkge1xuICAgICAgICBjb25zdCBibG9iSW5mbyA9IGJsb2JDYWNoZS5nZXRCeVVyaShpbWFnZVNyYyk7XG4gICAgICAgIGlmIChpc05vbk51bGxhYmxlKGJsb2JJbmZvKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYmxvYkluZm8pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB1cmlUb0Jsb2IoaW1hZ2VTcmMpLnRoZW4oYmxvYiA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYmxvYlRvRGF0YVVyaShibG9iKS50aGVuKGRhdGFVcmkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gcHJvY2Vzc0RhdGFVcmkoZGF0YVVyaSwgZmFsc2UsIGJhc2U2NCA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoY3JlYXRlQmxvYkluZm8kMShibG9iQ2FjaGUsIGJsb2IsIGJhc2U2NCkpO1xuICAgICAgICAgICAgICB9KS5nZXRPclRodW5rKGludmFsaWREYXRhVXJpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0c1dpdGgoaW1hZ2VTcmMsICdkYXRhOicpKSB7XG4gICAgICAgIHJldHVybiBkYXRhVXJpVG9CbG9iSW5mbyhibG9iQ2FjaGUsIGltYWdlU3JjKS5mb2xkKGludmFsaWREYXRhVXJpLCBibG9iSW5mbyA9PiBQcm9taXNlLnJlc29sdmUoYmxvYkluZm8pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnVW5rbm93biBpbWFnZSBkYXRhIGZvcm1hdCcpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBpc0JvZ3VzSW1hZ2UgPSBpbWcgPT4gaXNOb25OdWxsYWJsZShpbWcuYXR0cignZGF0YS1tY2UtYm9ndXMnKSk7XG4gICAgY29uc3QgaXNJbnRlcm5hbEltYWdlU291cmNlID0gaW1nID0+IGltZy5hdHRyKCdzcmMnKSA9PT0gRW52LnRyYW5zcGFyZW50U3JjIHx8IGlzTm9uTnVsbGFibGUoaW1nLmF0dHIoJ2RhdGEtbWNlLXBsYWNlaG9sZGVyJykpO1xuICAgIGNvbnN0IHJlZ2lzdGVyQmFzZTY0SW1hZ2VGaWx0ZXIgPSAocGFyc2VyLCBzZXR0aW5ncykgPT4ge1xuICAgICAgY29uc3Qge2Jsb2JfY2FjaGU6IGJsb2JDYWNoZX0gPSBzZXR0aW5ncztcbiAgICAgIGlmIChibG9iQ2FjaGUpIHtcbiAgICAgICAgY29uc3QgcHJvY2Vzc0ltYWdlID0gaW1nID0+IHtcbiAgICAgICAgICBjb25zdCBpbnB1dFNyYyA9IGltZy5hdHRyKCdzcmMnKTtcbiAgICAgICAgICBpZiAoaXNJbnRlcm5hbEltYWdlU291cmNlKGltZykgfHwgaXNCb2d1c0ltYWdlKGltZykgfHwgaXNOdWxsYWJsZShpbnB1dFNyYykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YVVyaVRvQmxvYkluZm8oYmxvYkNhY2hlLCBpbnB1dFNyYywgdHJ1ZSkuZWFjaChibG9iSW5mbyA9PiB7XG4gICAgICAgICAgICBpbWcuYXR0cignc3JjJywgYmxvYkluZm8uYmxvYlVyaSgpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcGFyc2VyLmFkZEF0dHJpYnV0ZUZpbHRlcignc3JjJywgbm9kZXMgPT4gZWFjaCRlKG5vZGVzLCBwcm9jZXNzSW1hZ2UpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlZ2lzdGVyJDQgPSAocGFyc2VyLCBzZXR0aW5ncykgPT4ge1xuICAgICAgY29uc3Qgc2NoZW1hID0gcGFyc2VyLnNjaGVtYTtcbiAgICAgIGlmIChzZXR0aW5ncy5yZW1vdmVfdHJhaWxpbmdfYnJzKSB7XG4gICAgICAgIHBhcnNlci5hZGROb2RlRmlsdGVyKCdicicsIChub2RlcywgXywgYXJncykgPT4ge1xuICAgICAgICAgIGNvbnN0IGJsb2NrRWxlbWVudHMgPSBUb29scy5leHRlbmQoe30sIHNjaGVtYS5nZXRCbG9ja0VsZW1lbnRzKCkpO1xuICAgICAgICAgIGNvbnN0IG5vbkVtcHR5RWxlbWVudHMgPSBzY2hlbWEuZ2V0Tm9uRW1wdHlFbGVtZW50cygpO1xuICAgICAgICAgIGNvbnN0IHdoaXRlc3BhY2VFbGVtZW50cyA9IHNjaGVtYS5nZXRXaGl0ZXNwYWNlRWxlbWVudHMoKTtcbiAgICAgICAgICBibG9ja0VsZW1lbnRzLmJvZHkgPSAxO1xuICAgICAgICAgIGNvbnN0IGlzQmxvY2sgPSBub2RlID0+IG5vZGUubmFtZSBpbiBibG9ja0VsZW1lbnRzICYmIGlzVHJhbnNwYXJlbnRBc3RJbmxpbmUoc2NoZW1hLCBub2RlKTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSBub2RlLnBhcmVudDtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgYmxvY2tFbGVtZW50c1twYXJlbnQubmFtZV0gJiYgbm9kZSA9PT0gcGFyZW50Lmxhc3RDaGlsZCkge1xuICAgICAgICAgICAgICBsZXQgcHJldiA9IG5vZGUucHJldjtcbiAgICAgICAgICAgICAgd2hpbGUgKHByZXYpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2TmFtZSA9IHByZXYubmFtZTtcbiAgICAgICAgICAgICAgICBpZiAocHJldk5hbWUgIT09ICdzcGFuJyB8fCBwcmV2LmF0dHIoJ2RhdGEtbWNlLXR5cGUnKSAhPT0gJ2Jvb2ttYXJrJykge1xuICAgICAgICAgICAgICAgICAgaWYgKHByZXZOYW1lID09PSAnYnInKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXYgPSBwcmV2LnByZXY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KHNjaGVtYSwgbm9uRW1wdHlFbGVtZW50cywgd2hpdGVzcGFjZUVsZW1lbnRzLCBwYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50UnVsZSA9IHNjaGVtYS5nZXRFbGVtZW50UnVsZShwYXJlbnQubmFtZSk7XG4gICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudFJ1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRSdWxlLnJlbW92ZUVtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgcGFyZW50LnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnRSdWxlLnBhZGRFbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICAgIHBhZGRFbXB0eU5vZGUoYXJncywgaXNCbG9jaywgcGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbGV0IGxhc3RQYXJlbnQgPSBub2RlO1xuICAgICAgICAgICAgICB3aGlsZSAocGFyZW50ICYmIHBhcmVudC5maXJzdENoaWxkID09PSBsYXN0UGFyZW50ICYmIHBhcmVudC5sYXN0Q2hpbGQgPT09IGxhc3RQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBsYXN0UGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgICAgIGlmIChibG9ja0VsZW1lbnRzW3BhcmVudC5uYW1lXSkge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGxhc3RQYXJlbnQgPT09IHBhcmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHROb2RlID0gbmV3IEFzdE5vZGUoJyN0ZXh0JywgMyk7XG4gICAgICAgICAgICAgICAgdGV4dE5vZGUudmFsdWUgPSBuYnNwO1xuICAgICAgICAgICAgICAgIG5vZGUucmVwbGFjZSh0ZXh0Tm9kZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcGFyc2VyLmFkZEF0dHJpYnV0ZUZpbHRlcignaHJlZicsIG5vZGVzID0+IHtcbiAgICAgICAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGFwcGVuZFJlbCA9IHJlbCA9PiB7XG4gICAgICAgICAgY29uc3QgcGFydHMgPSByZWwuc3BsaXQoJyAnKS5maWx0ZXIocCA9PiBwLmxlbmd0aCA+IDApO1xuICAgICAgICAgIHJldHVybiBwYXJ0cy5jb25jYXQoWydub29wZW5lciddKS5zb3J0KCkuam9pbignICcpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhZGROb09wZW5lciA9IHJlbCA9PiB7XG4gICAgICAgICAgY29uc3QgbmV3UmVsID0gcmVsID8gVG9vbHMudHJpbShyZWwpIDogJyc7XG4gICAgICAgICAgaWYgKCEvXFxiKG5vb3BlbmVyKVxcYi9nLnRlc3QobmV3UmVsKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFwcGVuZFJlbChuZXdSZWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3UmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFzZXR0aW5ncy5hbGxvd191bnNhZmVfbGlua190YXJnZXQpIHtcbiAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICBpZiAobm9kZS5uYW1lID09PSAnYScgJiYgbm9kZS5hdHRyKCd0YXJnZXQnKSA9PT0gJ19ibGFuaycpIHtcbiAgICAgICAgICAgICAgbm9kZS5hdHRyKCdyZWwnLCBhZGROb09wZW5lcihub2RlLmF0dHIoJ3JlbCcpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICghc2V0dGluZ3MuYWxsb3dfaHRtbF9pbl9uYW1lZF9hbmNob3IpIHtcbiAgICAgICAgcGFyc2VyLmFkZEF0dHJpYnV0ZUZpbHRlcignaWQsbmFtZScsIG5vZGVzID0+IHtcbiAgICAgICAgICBsZXQgaSA9IG5vZGVzLmxlbmd0aCwgc2libGluZywgcHJldlNpYmxpbmcsIHBhcmVudCwgbm9kZTtcbiAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICBpZiAobm9kZS5uYW1lID09PSAnYScgJiYgbm9kZS5maXJzdENoaWxkICYmICFub2RlLmF0dHIoJ2hyZWYnKSkge1xuICAgICAgICAgICAgICBwYXJlbnQgPSBub2RlLnBhcmVudDtcbiAgICAgICAgICAgICAgc2libGluZyA9IG5vZGUubGFzdENoaWxkO1xuICAgICAgICAgICAgICB3aGlsZSAoc2libGluZyAmJiBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBwcmV2U2libGluZyA9IHNpYmxpbmcucHJldjtcbiAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0KHNpYmxpbmcsIG5vZGUpO1xuICAgICAgICAgICAgICAgIHNpYmxpbmcgPSBwcmV2U2libGluZztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoc2V0dGluZ3MuZml4X2xpc3RfZWxlbWVudHMpIHtcbiAgICAgICAgcGFyc2VyLmFkZE5vZGVGaWx0ZXIoJ3VsLG9sJywgbm9kZXMgPT4ge1xuICAgICAgICAgIGxldCBpID0gbm9kZXMubGVuZ3RoLCBub2RlLCBwYXJlbnROb2RlO1xuICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgICAgICAgIGlmIChwYXJlbnROb2RlICYmIChwYXJlbnROb2RlLm5hbWUgPT09ICd1bCcgfHwgcGFyZW50Tm9kZS5uYW1lID09PSAnb2wnKSkge1xuICAgICAgICAgICAgICBpZiAobm9kZS5wcmV2ICYmIG5vZGUucHJldi5uYW1lID09PSAnbGknKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5wcmV2LmFwcGVuZChub2RlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsaSA9IG5ldyBBc3ROb2RlKCdsaScsIDEpO1xuICAgICAgICAgICAgICAgIGxpLmF0dHIoJ3N0eWxlJywgJ2xpc3Qtc3R5bGUtdHlwZTogbm9uZScpO1xuICAgICAgICAgICAgICAgIG5vZGUud3JhcChsaSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsaWRDbGFzc2VzID0gc2NoZW1hLmdldFZhbGlkQ2xhc3NlcygpO1xuICAgICAgaWYgKHNldHRpbmdzLnZhbGlkYXRlICYmIHZhbGlkQ2xhc3Nlcykge1xuICAgICAgICBwYXJzZXIuYWRkQXR0cmlidXRlRmlsdGVyKCdjbGFzcycsIG5vZGVzID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgY29uc3QgY2xhenogPSAoX2EgPSBub2RlLmF0dHIoJ2NsYXNzJykpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xuICAgICAgICAgICAgY29uc3QgY2xhc3NMaXN0ID0gVG9vbHMuZXhwbG9kZShjbGF6eiwgJyAnKTtcbiAgICAgICAgICAgIGxldCBjbGFzc1ZhbHVlID0gJyc7XG4gICAgICAgICAgICBmb3IgKGxldCBjaSA9IDA7IGNpIDwgY2xhc3NMaXN0Lmxlbmd0aDsgY2krKykge1xuICAgICAgICAgICAgICBjb25zdCBjbGFzc05hbWUgPSBjbGFzc0xpc3RbY2ldO1xuICAgICAgICAgICAgICBsZXQgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgbGV0IHZhbGlkQ2xhc3Nlc01hcCA9IHZhbGlkQ2xhc3Nlc1snKiddO1xuICAgICAgICAgICAgICBpZiAodmFsaWRDbGFzc2VzTWFwICYmIHZhbGlkQ2xhc3Nlc01hcFtjbGFzc05hbWVdKSB7XG4gICAgICAgICAgICAgICAgdmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhbGlkQ2xhc3Nlc01hcCA9IHZhbGlkQ2xhc3Nlc1tub2RlLm5hbWVdO1xuICAgICAgICAgICAgICBpZiAoIXZhbGlkICYmIHZhbGlkQ2xhc3Nlc01hcCAmJiB2YWxpZENsYXNzZXNNYXBbY2xhc3NOYW1lXSkge1xuICAgICAgICAgICAgICAgIHZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2xhc3NWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgY2xhc3NWYWx1ZSArPSAnICc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNsYXNzVmFsdWUgKz0gY2xhc3NOYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNsYXNzVmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNsYXNzVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5hdHRyKCdjbGFzcycsIGNsYXNzVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZWdpc3RlckJhc2U2NEltYWdlRmlsdGVyKHBhcnNlciwgc2V0dGluZ3MpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgJ0BiYWJlbC9oZWxwZXJzIC0gdHlwZW9mJztcbiAgICAgIHJldHVybiBfdHlwZW9mID0gJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgU3ltYm9sICYmICdzeW1ib2wnID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgICAgfSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAmJiAnZnVuY3Rpb24nID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gJ3N5bWJvbCcgOiB0eXBlb2Ygb2JqO1xuICAgICAgfSwgX3R5cGVvZihvYmopO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgICB9O1xuICAgICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ3VuZGVmaW5lZCcgfHwgIVJlZmxlY3QuY29uc3RydWN0KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB0cnkge1xuICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICAgIGlmIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHtcbiAgICAgICAgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICAgICAgICAgIHZhciBhID0gW251bGxdO1xuICAgICAgICAgIGEucHVzaC5hcHBseShhLCBhcmdzKTtcbiAgICAgICAgICB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgICAgICAgaWYgKENsYXNzKVxuICAgICAgICAgICAgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgICAgIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpXG4gICAgICAgIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyWydAQGl0ZXJhdG9yJ10gIT0gbnVsbClcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgICAgIGlmICghbylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKHR5cGVvZiBvID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gICAgICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gICAgICBpZiAobiA9PT0gJ09iamVjdCcgJiYgby5jb25zdHJ1Y3RvcilcbiAgICAgICAgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgICAgIGlmIChuID09PSAnTWFwJyB8fCBuID09PSAnU2V0JylcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gICAgICBpZiAobiA9PT0gJ0FyZ3VtZW50cycgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpXG4gICAgICAgIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICAgICAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpXG4gICAgICAgIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspXG4gICAgICAgIGFycjJbaV0gPSBhcnJbaV07XG4gICAgICByZXR1cm4gYXJyMjtcbiAgICB9XG4gICAgZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLicpO1xuICAgIH1cbiAgICB2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QuaGFzT3duUHJvcGVydHksIHNldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mLCBpc0Zyb3plbiA9IE9iamVjdC5pc0Zyb3plbiwgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YsIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICAgdmFyIGZyZWV6ZSA9IE9iamVjdC5mcmVlemUsIHNlYWwgPSBPYmplY3Quc2VhbCwgY3JlYXRlJDcgPSBPYmplY3QuY3JlYXRlO1xuICAgIHZhciBfcmVmID0gdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIFJlZmxlY3QsIGFwcGx5ID0gX3JlZi5hcHBseSwgY29uc3RydWN0ID0gX3JlZi5jb25zdHJ1Y3Q7XG4gICAgaWYgKCFhcHBseSkge1xuICAgICAgYXBwbHkgPSBmdW5jdGlvbiBhcHBseShmdW4sIHRoaXNWYWx1ZSwgYXJncykge1xuICAgICAgICByZXR1cm4gZnVuLmFwcGx5KHRoaXNWYWx1ZSwgYXJncyk7XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoIWZyZWV6ZSkge1xuICAgICAgZnJlZXplID0gZnVuY3Rpb24gZnJlZXplKHgpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoIXNlYWwpIHtcbiAgICAgIHNlYWwgPSBmdW5jdGlvbiBzZWFsKHgpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoIWNvbnN0cnVjdCkge1xuICAgICAgY29uc3RydWN0ID0gZnVuY3Rpb24gY29uc3RydWN0KEZ1bmMsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9jb25zdHJ1Y3QoRnVuYywgX3RvQ29uc3VtYWJsZUFycmF5KGFyZ3MpKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHZhciBhcnJheUZvckVhY2ggPSB1bmFwcGx5KEFycmF5LnByb3RvdHlwZS5mb3JFYWNoKTtcbiAgICB2YXIgYXJyYXlQb3AgPSB1bmFwcGx5KEFycmF5LnByb3RvdHlwZS5wb3ApO1xuICAgIHZhciBhcnJheVB1c2ggPSB1bmFwcGx5KEFycmF5LnByb3RvdHlwZS5wdXNoKTtcbiAgICB2YXIgc3RyaW5nVG9Mb3dlckNhc2UgPSB1bmFwcGx5KFN0cmluZy5wcm90b3R5cGUudG9Mb3dlckNhc2UpO1xuICAgIHZhciBzdHJpbmdNYXRjaCA9IHVuYXBwbHkoU3RyaW5nLnByb3RvdHlwZS5tYXRjaCk7XG4gICAgdmFyIHN0cmluZ1JlcGxhY2UgPSB1bmFwcGx5KFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSk7XG4gICAgdmFyIHN0cmluZ0luZGV4T2YgPSB1bmFwcGx5KFN0cmluZy5wcm90b3R5cGUuaW5kZXhPZik7XG4gICAgdmFyIHN0cmluZ1RyaW0gPSB1bmFwcGx5KFN0cmluZy5wcm90b3R5cGUudHJpbSk7XG4gICAgdmFyIHJlZ0V4cFRlc3QgPSB1bmFwcGx5KFJlZ0V4cC5wcm90b3R5cGUudGVzdCk7XG4gICAgdmFyIHR5cGVFcnJvckNyZWF0ZSA9IHVuY29uc3RydWN0KFR5cGVFcnJvcik7XG4gICAgZnVuY3Rpb24gdW5hcHBseShmdW5jKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHRoaXNBcmcpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuY29uc3RydWN0KGZ1bmMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uc3RydWN0KGZ1bmMsIGFyZ3MpO1xuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkVG9TZXQoc2V0LCBhcnJheSkge1xuICAgICAgaWYgKHNldFByb3RvdHlwZU9mKSB7XG4gICAgICAgIHNldFByb3RvdHlwZU9mKHNldCwgbnVsbCk7XG4gICAgICB9XG4gICAgICB2YXIgbCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIHdoaWxlIChsLS0pIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBhcnJheVtsXTtcbiAgICAgICAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHZhciBsY0VsZW1lbnQgPSBzdHJpbmdUb0xvd2VyQ2FzZShlbGVtZW50KTtcbiAgICAgICAgICBpZiAobGNFbGVtZW50ICE9PSBlbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoIWlzRnJvemVuKGFycmF5KSkge1xuICAgICAgICAgICAgICBhcnJheVtsXSA9IGxjRWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW1lbnQgPSBsY0VsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNldFtlbGVtZW50XSA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2V0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbG9uZShvYmplY3QpIHtcbiAgICAgIHZhciBuZXdPYmplY3QgPSBjcmVhdGUkNyhudWxsKTtcbiAgICAgIHZhciBwcm9wZXJ0eTtcbiAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmIChhcHBseShoYXNPd25Qcm9wZXJ0eSwgb2JqZWN0LCBbcHJvcGVydHldKSkge1xuICAgICAgICAgIG5ld09iamVjdFtwcm9wZXJ0eV0gPSBvYmplY3RbcHJvcGVydHldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3T2JqZWN0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBsb29rdXBHZXR0ZXIob2JqZWN0LCBwcm9wKSB7XG4gICAgICB3aGlsZSAob2JqZWN0ICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBkZXNjID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcCk7XG4gICAgICAgIGlmIChkZXNjKSB7XG4gICAgICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdW5hcHBseShkZXNjLmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgZGVzYy52YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuYXBwbHkoZGVzYy52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9iamVjdCA9IGdldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBmYWxsYmFja1ZhbHVlKGVsZW1lbnQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdmYWxsYmFjayB2YWx1ZSBmb3InLCBlbGVtZW50KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsbGJhY2tWYWx1ZTtcbiAgICB9XG4gICAgdmFyIGh0bWwkMSA9IGZyZWV6ZShbXG4gICAgICAnYScsXG4gICAgICAnYWJicicsXG4gICAgICAnYWNyb255bScsXG4gICAgICAnYWRkcmVzcycsXG4gICAgICAnYXJlYScsXG4gICAgICAnYXJ0aWNsZScsXG4gICAgICAnYXNpZGUnLFxuICAgICAgJ2F1ZGlvJyxcbiAgICAgICdiJyxcbiAgICAgICdiZGknLFxuICAgICAgJ2JkbycsXG4gICAgICAnYmlnJyxcbiAgICAgICdibGluaycsXG4gICAgICAnYmxvY2txdW90ZScsXG4gICAgICAnYm9keScsXG4gICAgICAnYnInLFxuICAgICAgJ2J1dHRvbicsXG4gICAgICAnY2FudmFzJyxcbiAgICAgICdjYXB0aW9uJyxcbiAgICAgICdjZW50ZXInLFxuICAgICAgJ2NpdGUnLFxuICAgICAgJ2NvZGUnLFxuICAgICAgJ2NvbCcsXG4gICAgICAnY29sZ3JvdXAnLFxuICAgICAgJ2NvbnRlbnQnLFxuICAgICAgJ2RhdGEnLFxuICAgICAgJ2RhdGFsaXN0JyxcbiAgICAgICdkZCcsXG4gICAgICAnZGVjb3JhdG9yJyxcbiAgICAgICdkZWwnLFxuICAgICAgJ2RldGFpbHMnLFxuICAgICAgJ2RmbicsXG4gICAgICAnZGlhbG9nJyxcbiAgICAgICdkaXInLFxuICAgICAgJ2RpdicsXG4gICAgICAnZGwnLFxuICAgICAgJ2R0JyxcbiAgICAgICdlbGVtZW50JyxcbiAgICAgICdlbScsXG4gICAgICAnZmllbGRzZXQnLFxuICAgICAgJ2ZpZ2NhcHRpb24nLFxuICAgICAgJ2ZpZ3VyZScsXG4gICAgICAnZm9udCcsXG4gICAgICAnZm9vdGVyJyxcbiAgICAgICdmb3JtJyxcbiAgICAgICdoMScsXG4gICAgICAnaDInLFxuICAgICAgJ2gzJyxcbiAgICAgICdoNCcsXG4gICAgICAnaDUnLFxuICAgICAgJ2g2JyxcbiAgICAgICdoZWFkJyxcbiAgICAgICdoZWFkZXInLFxuICAgICAgJ2hncm91cCcsXG4gICAgICAnaHInLFxuICAgICAgJ2h0bWwnLFxuICAgICAgJ2knLFxuICAgICAgJ2ltZycsXG4gICAgICAnaW5wdXQnLFxuICAgICAgJ2lucycsXG4gICAgICAna2JkJyxcbiAgICAgICdsYWJlbCcsXG4gICAgICAnbGVnZW5kJyxcbiAgICAgICdsaScsXG4gICAgICAnbWFpbicsXG4gICAgICAnbWFwJyxcbiAgICAgICdtYXJrJyxcbiAgICAgICdtYXJxdWVlJyxcbiAgICAgICdtZW51JyxcbiAgICAgICdtZW51aXRlbScsXG4gICAgICAnbWV0ZXInLFxuICAgICAgJ25hdicsXG4gICAgICAnbm9icicsXG4gICAgICAnb2wnLFxuICAgICAgJ29wdGdyb3VwJyxcbiAgICAgICdvcHRpb24nLFxuICAgICAgJ291dHB1dCcsXG4gICAgICAncCcsXG4gICAgICAncGljdHVyZScsXG4gICAgICAncHJlJyxcbiAgICAgICdwcm9ncmVzcycsXG4gICAgICAncScsXG4gICAgICAncnAnLFxuICAgICAgJ3J0JyxcbiAgICAgICdydWJ5JyxcbiAgICAgICdzJyxcbiAgICAgICdzYW1wJyxcbiAgICAgICdzZWN0aW9uJyxcbiAgICAgICdzZWxlY3QnLFxuICAgICAgJ3NoYWRvdycsXG4gICAgICAnc21hbGwnLFxuICAgICAgJ3NvdXJjZScsXG4gICAgICAnc3BhY2VyJyxcbiAgICAgICdzcGFuJyxcbiAgICAgICdzdHJpa2UnLFxuICAgICAgJ3N0cm9uZycsXG4gICAgICAnc3R5bGUnLFxuICAgICAgJ3N1YicsXG4gICAgICAnc3VtbWFyeScsXG4gICAgICAnc3VwJyxcbiAgICAgICd0YWJsZScsXG4gICAgICAndGJvZHknLFxuICAgICAgJ3RkJyxcbiAgICAgICd0ZW1wbGF0ZScsXG4gICAgICAndGV4dGFyZWEnLFxuICAgICAgJ3Rmb290JyxcbiAgICAgICd0aCcsXG4gICAgICAndGhlYWQnLFxuICAgICAgJ3RpbWUnLFxuICAgICAgJ3RyJyxcbiAgICAgICd0cmFjaycsXG4gICAgICAndHQnLFxuICAgICAgJ3UnLFxuICAgICAgJ3VsJyxcbiAgICAgICd2YXInLFxuICAgICAgJ3ZpZGVvJyxcbiAgICAgICd3YnInXG4gICAgXSk7XG4gICAgdmFyIHN2ZyQxID0gZnJlZXplKFtcbiAgICAgICdzdmcnLFxuICAgICAgJ2EnLFxuICAgICAgJ2FsdGdseXBoJyxcbiAgICAgICdhbHRnbHlwaGRlZicsXG4gICAgICAnYWx0Z2x5cGhpdGVtJyxcbiAgICAgICdhbmltYXRlY29sb3InLFxuICAgICAgJ2FuaW1hdGVtb3Rpb24nLFxuICAgICAgJ2FuaW1hdGV0cmFuc2Zvcm0nLFxuICAgICAgJ2NpcmNsZScsXG4gICAgICAnY2xpcHBhdGgnLFxuICAgICAgJ2RlZnMnLFxuICAgICAgJ2Rlc2MnLFxuICAgICAgJ2VsbGlwc2UnLFxuICAgICAgJ2ZpbHRlcicsXG4gICAgICAnZm9udCcsXG4gICAgICAnZycsXG4gICAgICAnZ2x5cGgnLFxuICAgICAgJ2dseXBocmVmJyxcbiAgICAgICdoa2VybicsXG4gICAgICAnaW1hZ2UnLFxuICAgICAgJ2xpbmUnLFxuICAgICAgJ2xpbmVhcmdyYWRpZW50JyxcbiAgICAgICdtYXJrZXInLFxuICAgICAgJ21hc2snLFxuICAgICAgJ21ldGFkYXRhJyxcbiAgICAgICdtcGF0aCcsXG4gICAgICAncGF0aCcsXG4gICAgICAncGF0dGVybicsXG4gICAgICAncG9seWdvbicsXG4gICAgICAncG9seWxpbmUnLFxuICAgICAgJ3JhZGlhbGdyYWRpZW50JyxcbiAgICAgICdyZWN0JyxcbiAgICAgICdzdG9wJyxcbiAgICAgICdzdHlsZScsXG4gICAgICAnc3dpdGNoJyxcbiAgICAgICdzeW1ib2wnLFxuICAgICAgJ3RleHQnLFxuICAgICAgJ3RleHRwYXRoJyxcbiAgICAgICd0aXRsZScsXG4gICAgICAndHJlZicsXG4gICAgICAndHNwYW4nLFxuICAgICAgJ3ZpZXcnLFxuICAgICAgJ3ZrZXJuJ1xuICAgIF0pO1xuICAgIHZhciBzdmdGaWx0ZXJzID0gZnJlZXplKFtcbiAgICAgICdmZUJsZW5kJyxcbiAgICAgICdmZUNvbG9yTWF0cml4JyxcbiAgICAgICdmZUNvbXBvbmVudFRyYW5zZmVyJyxcbiAgICAgICdmZUNvbXBvc2l0ZScsXG4gICAgICAnZmVDb252b2x2ZU1hdHJpeCcsXG4gICAgICAnZmVEaWZmdXNlTGlnaHRpbmcnLFxuICAgICAgJ2ZlRGlzcGxhY2VtZW50TWFwJyxcbiAgICAgICdmZURpc3RhbnRMaWdodCcsXG4gICAgICAnZmVGbG9vZCcsXG4gICAgICAnZmVGdW5jQScsXG4gICAgICAnZmVGdW5jQicsXG4gICAgICAnZmVGdW5jRycsXG4gICAgICAnZmVGdW5jUicsXG4gICAgICAnZmVHYXVzc2lhbkJsdXInLFxuICAgICAgJ2ZlSW1hZ2UnLFxuICAgICAgJ2ZlTWVyZ2UnLFxuICAgICAgJ2ZlTWVyZ2VOb2RlJyxcbiAgICAgICdmZU1vcnBob2xvZ3knLFxuICAgICAgJ2ZlT2Zmc2V0JyxcbiAgICAgICdmZVBvaW50TGlnaHQnLFxuICAgICAgJ2ZlU3BlY3VsYXJMaWdodGluZycsXG4gICAgICAnZmVTcG90TGlnaHQnLFxuICAgICAgJ2ZlVGlsZScsXG4gICAgICAnZmVUdXJidWxlbmNlJ1xuICAgIF0pO1xuICAgIHZhciBzdmdEaXNhbGxvd2VkID0gZnJlZXplKFtcbiAgICAgICdhbmltYXRlJyxcbiAgICAgICdjb2xvci1wcm9maWxlJyxcbiAgICAgICdjdXJzb3InLFxuICAgICAgJ2Rpc2NhcmQnLFxuICAgICAgJ2ZlZHJvcHNoYWRvdycsXG4gICAgICAnZm9udC1mYWNlJyxcbiAgICAgICdmb250LWZhY2UtZm9ybWF0JyxcbiAgICAgICdmb250LWZhY2UtbmFtZScsXG4gICAgICAnZm9udC1mYWNlLXNyYycsXG4gICAgICAnZm9udC1mYWNlLXVyaScsXG4gICAgICAnZm9yZWlnbm9iamVjdCcsXG4gICAgICAnaGF0Y2gnLFxuICAgICAgJ2hhdGNocGF0aCcsXG4gICAgICAnbWVzaCcsXG4gICAgICAnbWVzaGdyYWRpZW50JyxcbiAgICAgICdtZXNocGF0Y2gnLFxuICAgICAgJ21lc2hyb3cnLFxuICAgICAgJ21pc3NpbmctZ2x5cGgnLFxuICAgICAgJ3NjcmlwdCcsXG4gICAgICAnc2V0JyxcbiAgICAgICdzb2xpZGNvbG9yJyxcbiAgICAgICd1bmtub3duJyxcbiAgICAgICd1c2UnXG4gICAgXSk7XG4gICAgdmFyIG1hdGhNbCQxID0gZnJlZXplKFtcbiAgICAgICdtYXRoJyxcbiAgICAgICdtZW5jbG9zZScsXG4gICAgICAnbWVycm9yJyxcbiAgICAgICdtZmVuY2VkJyxcbiAgICAgICdtZnJhYycsXG4gICAgICAnbWdseXBoJyxcbiAgICAgICdtaScsXG4gICAgICAnbWxhYmVsZWR0cicsXG4gICAgICAnbW11bHRpc2NyaXB0cycsXG4gICAgICAnbW4nLFxuICAgICAgJ21vJyxcbiAgICAgICdtb3ZlcicsXG4gICAgICAnbXBhZGRlZCcsXG4gICAgICAnbXBoYW50b20nLFxuICAgICAgJ21yb290JyxcbiAgICAgICdtcm93JyxcbiAgICAgICdtcycsXG4gICAgICAnbXNwYWNlJyxcbiAgICAgICdtc3FydCcsXG4gICAgICAnbXN0eWxlJyxcbiAgICAgICdtc3ViJyxcbiAgICAgICdtc3VwJyxcbiAgICAgICdtc3Vic3VwJyxcbiAgICAgICdtdGFibGUnLFxuICAgICAgJ210ZCcsXG4gICAgICAnbXRleHQnLFxuICAgICAgJ210cicsXG4gICAgICAnbXVuZGVyJyxcbiAgICAgICdtdW5kZXJvdmVyJ1xuICAgIF0pO1xuICAgIHZhciBtYXRoTWxEaXNhbGxvd2VkID0gZnJlZXplKFtcbiAgICAgICdtYWN0aW9uJyxcbiAgICAgICdtYWxpZ25ncm91cCcsXG4gICAgICAnbWFsaWdubWFyaycsXG4gICAgICAnbWxvbmdkaXYnLFxuICAgICAgJ21zY2FycmllcycsXG4gICAgICAnbXNjYXJyeScsXG4gICAgICAnbXNncm91cCcsXG4gICAgICAnbXN0YWNrJyxcbiAgICAgICdtc2xpbmUnLFxuICAgICAgJ21zcm93JyxcbiAgICAgICdzZW1hbnRpY3MnLFxuICAgICAgJ2Fubm90YXRpb24nLFxuICAgICAgJ2Fubm90YXRpb24teG1sJyxcbiAgICAgICdtcHJlc2NyaXB0cycsXG4gICAgICAnbm9uZSdcbiAgICBdKTtcbiAgICB2YXIgdGV4dCA9IGZyZWV6ZShbJyN0ZXh0J10pO1xuICAgIHZhciBodG1sID0gZnJlZXplKFtcbiAgICAgICdhY2NlcHQnLFxuICAgICAgJ2FjdGlvbicsXG4gICAgICAnYWxpZ24nLFxuICAgICAgJ2FsdCcsXG4gICAgICAnYXV0b2NhcGl0YWxpemUnLFxuICAgICAgJ2F1dG9jb21wbGV0ZScsXG4gICAgICAnYXV0b3BpY3R1cmVpbnBpY3R1cmUnLFxuICAgICAgJ2F1dG9wbGF5JyxcbiAgICAgICdiYWNrZ3JvdW5kJyxcbiAgICAgICdiZ2NvbG9yJyxcbiAgICAgICdib3JkZXInLFxuICAgICAgJ2NhcHR1cmUnLFxuICAgICAgJ2NlbGxwYWRkaW5nJyxcbiAgICAgICdjZWxsc3BhY2luZycsXG4gICAgICAnY2hlY2tlZCcsXG4gICAgICAnY2l0ZScsXG4gICAgICAnY2xhc3MnLFxuICAgICAgJ2NsZWFyJyxcbiAgICAgICdjb2xvcicsXG4gICAgICAnY29scycsXG4gICAgICAnY29sc3BhbicsXG4gICAgICAnY29udHJvbHMnLFxuICAgICAgJ2NvbnRyb2xzbGlzdCcsXG4gICAgICAnY29vcmRzJyxcbiAgICAgICdjcm9zc29yaWdpbicsXG4gICAgICAnZGF0ZXRpbWUnLFxuICAgICAgJ2RlY29kaW5nJyxcbiAgICAgICdkZWZhdWx0JyxcbiAgICAgICdkaXInLFxuICAgICAgJ2Rpc2FibGVkJyxcbiAgICAgICdkaXNhYmxlcGljdHVyZWlucGljdHVyZScsXG4gICAgICAnZGlzYWJsZXJlbW90ZXBsYXliYWNrJyxcbiAgICAgICdkb3dubG9hZCcsXG4gICAgICAnZHJhZ2dhYmxlJyxcbiAgICAgICdlbmN0eXBlJyxcbiAgICAgICdlbnRlcmtleWhpbnQnLFxuICAgICAgJ2ZhY2UnLFxuICAgICAgJ2ZvcicsXG4gICAgICAnaGVhZGVycycsXG4gICAgICAnaGVpZ2h0JyxcbiAgICAgICdoaWRkZW4nLFxuICAgICAgJ2hpZ2gnLFxuICAgICAgJ2hyZWYnLFxuICAgICAgJ2hyZWZsYW5nJyxcbiAgICAgICdpZCcsXG4gICAgICAnaW5wdXRtb2RlJyxcbiAgICAgICdpbnRlZ3JpdHknLFxuICAgICAgJ2lzbWFwJyxcbiAgICAgICdraW5kJyxcbiAgICAgICdsYWJlbCcsXG4gICAgICAnbGFuZycsXG4gICAgICAnbGlzdCcsXG4gICAgICAnbG9hZGluZycsXG4gICAgICAnbG9vcCcsXG4gICAgICAnbG93JyxcbiAgICAgICdtYXgnLFxuICAgICAgJ21heGxlbmd0aCcsXG4gICAgICAnbWVkaWEnLFxuICAgICAgJ21ldGhvZCcsXG4gICAgICAnbWluJyxcbiAgICAgICdtaW5sZW5ndGgnLFxuICAgICAgJ211bHRpcGxlJyxcbiAgICAgICdtdXRlZCcsXG4gICAgICAnbmFtZScsXG4gICAgICAnbm9uY2UnLFxuICAgICAgJ25vc2hhZGUnLFxuICAgICAgJ25vdmFsaWRhdGUnLFxuICAgICAgJ25vd3JhcCcsXG4gICAgICAnb3BlbicsXG4gICAgICAnb3B0aW11bScsXG4gICAgICAncGF0dGVybicsXG4gICAgICAncGxhY2Vob2xkZXInLFxuICAgICAgJ3BsYXlzaW5saW5lJyxcbiAgICAgICdwb3N0ZXInLFxuICAgICAgJ3ByZWxvYWQnLFxuICAgICAgJ3B1YmRhdGUnLFxuICAgICAgJ3JhZGlvZ3JvdXAnLFxuICAgICAgJ3JlYWRvbmx5JyxcbiAgICAgICdyZWwnLFxuICAgICAgJ3JlcXVpcmVkJyxcbiAgICAgICdyZXYnLFxuICAgICAgJ3JldmVyc2VkJyxcbiAgICAgICdyb2xlJyxcbiAgICAgICdyb3dzJyxcbiAgICAgICdyb3dzcGFuJyxcbiAgICAgICdzcGVsbGNoZWNrJyxcbiAgICAgICdzY29wZScsXG4gICAgICAnc2VsZWN0ZWQnLFxuICAgICAgJ3NoYXBlJyxcbiAgICAgICdzaXplJyxcbiAgICAgICdzaXplcycsXG4gICAgICAnc3BhbicsXG4gICAgICAnc3JjbGFuZycsXG4gICAgICAnc3RhcnQnLFxuICAgICAgJ3NyYycsXG4gICAgICAnc3Jjc2V0JyxcbiAgICAgICdzdGVwJyxcbiAgICAgICdzdHlsZScsXG4gICAgICAnc3VtbWFyeScsXG4gICAgICAndGFiaW5kZXgnLFxuICAgICAgJ3RpdGxlJyxcbiAgICAgICd0cmFuc2xhdGUnLFxuICAgICAgJ3R5cGUnLFxuICAgICAgJ3VzZW1hcCcsXG4gICAgICAndmFsaWduJyxcbiAgICAgICd2YWx1ZScsXG4gICAgICAnd2lkdGgnLFxuICAgICAgJ3htbG5zJyxcbiAgICAgICdzbG90J1xuICAgIF0pO1xuICAgIHZhciBzdmcgPSBmcmVlemUoW1xuICAgICAgJ2FjY2VudC1oZWlnaHQnLFxuICAgICAgJ2FjY3VtdWxhdGUnLFxuICAgICAgJ2FkZGl0aXZlJyxcbiAgICAgICdhbGlnbm1lbnQtYmFzZWxpbmUnLFxuICAgICAgJ2FzY2VudCcsXG4gICAgICAnYXR0cmlidXRlbmFtZScsXG4gICAgICAnYXR0cmlidXRldHlwZScsXG4gICAgICAnYXppbXV0aCcsXG4gICAgICAnYmFzZWZyZXF1ZW5jeScsXG4gICAgICAnYmFzZWxpbmUtc2hpZnQnLFxuICAgICAgJ2JlZ2luJyxcbiAgICAgICdiaWFzJyxcbiAgICAgICdieScsXG4gICAgICAnY2xhc3MnLFxuICAgICAgJ2NsaXAnLFxuICAgICAgJ2NsaXBwYXRodW5pdHMnLFxuICAgICAgJ2NsaXAtcGF0aCcsXG4gICAgICAnY2xpcC1ydWxlJyxcbiAgICAgICdjb2xvcicsXG4gICAgICAnY29sb3ItaW50ZXJwb2xhdGlvbicsXG4gICAgICAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJyxcbiAgICAgICdjb2xvci1wcm9maWxlJyxcbiAgICAgICdjb2xvci1yZW5kZXJpbmcnLFxuICAgICAgJ2N4JyxcbiAgICAgICdjeScsXG4gICAgICAnZCcsXG4gICAgICAnZHgnLFxuICAgICAgJ2R5JyxcbiAgICAgICdkaWZmdXNlY29uc3RhbnQnLFxuICAgICAgJ2RpcmVjdGlvbicsXG4gICAgICAnZGlzcGxheScsXG4gICAgICAnZGl2aXNvcicsXG4gICAgICAnZHVyJyxcbiAgICAgICdlZGdlbW9kZScsXG4gICAgICAnZWxldmF0aW9uJyxcbiAgICAgICdlbmQnLFxuICAgICAgJ2ZpbGwnLFxuICAgICAgJ2ZpbGwtb3BhY2l0eScsXG4gICAgICAnZmlsbC1ydWxlJyxcbiAgICAgICdmaWx0ZXInLFxuICAgICAgJ2ZpbHRlcnVuaXRzJyxcbiAgICAgICdmbG9vZC1jb2xvcicsXG4gICAgICAnZmxvb2Qtb3BhY2l0eScsXG4gICAgICAnZm9udC1mYW1pbHknLFxuICAgICAgJ2ZvbnQtc2l6ZScsXG4gICAgICAnZm9udC1zaXplLWFkanVzdCcsXG4gICAgICAnZm9udC1zdHJldGNoJyxcbiAgICAgICdmb250LXN0eWxlJyxcbiAgICAgICdmb250LXZhcmlhbnQnLFxuICAgICAgJ2ZvbnQtd2VpZ2h0JyxcbiAgICAgICdmeCcsXG4gICAgICAnZnknLFxuICAgICAgJ2cxJyxcbiAgICAgICdnMicsXG4gICAgICAnZ2x5cGgtbmFtZScsXG4gICAgICAnZ2x5cGhyZWYnLFxuICAgICAgJ2dyYWRpZW50dW5pdHMnLFxuICAgICAgJ2dyYWRpZW50dHJhbnNmb3JtJyxcbiAgICAgICdoZWlnaHQnLFxuICAgICAgJ2hyZWYnLFxuICAgICAgJ2lkJyxcbiAgICAgICdpbWFnZS1yZW5kZXJpbmcnLFxuICAgICAgJ2luJyxcbiAgICAgICdpbjInLFxuICAgICAgJ2snLFxuICAgICAgJ2sxJyxcbiAgICAgICdrMicsXG4gICAgICAnazMnLFxuICAgICAgJ2s0JyxcbiAgICAgICdrZXJuaW5nJyxcbiAgICAgICdrZXlwb2ludHMnLFxuICAgICAgJ2tleXNwbGluZXMnLFxuICAgICAgJ2tleXRpbWVzJyxcbiAgICAgICdsYW5nJyxcbiAgICAgICdsZW5ndGhhZGp1c3QnLFxuICAgICAgJ2xldHRlci1zcGFjaW5nJyxcbiAgICAgICdrZXJuZWxtYXRyaXgnLFxuICAgICAgJ2tlcm5lbHVuaXRsZW5ndGgnLFxuICAgICAgJ2xpZ2h0aW5nLWNvbG9yJyxcbiAgICAgICdsb2NhbCcsXG4gICAgICAnbWFya2VyLWVuZCcsXG4gICAgICAnbWFya2VyLW1pZCcsXG4gICAgICAnbWFya2VyLXN0YXJ0JyxcbiAgICAgICdtYXJrZXJoZWlnaHQnLFxuICAgICAgJ21hcmtlcnVuaXRzJyxcbiAgICAgICdtYXJrZXJ3aWR0aCcsXG4gICAgICAnbWFza2NvbnRlbnR1bml0cycsXG4gICAgICAnbWFza3VuaXRzJyxcbiAgICAgICdtYXgnLFxuICAgICAgJ21hc2snLFxuICAgICAgJ21lZGlhJyxcbiAgICAgICdtZXRob2QnLFxuICAgICAgJ21vZGUnLFxuICAgICAgJ21pbicsXG4gICAgICAnbmFtZScsXG4gICAgICAnbnVtb2N0YXZlcycsXG4gICAgICAnb2Zmc2V0JyxcbiAgICAgICdvcGVyYXRvcicsXG4gICAgICAnb3BhY2l0eScsXG4gICAgICAnb3JkZXInLFxuICAgICAgJ29yaWVudCcsXG4gICAgICAnb3JpZW50YXRpb24nLFxuICAgICAgJ29yaWdpbicsXG4gICAgICAnb3ZlcmZsb3cnLFxuICAgICAgJ3BhaW50LW9yZGVyJyxcbiAgICAgICdwYXRoJyxcbiAgICAgICdwYXRobGVuZ3RoJyxcbiAgICAgICdwYXR0ZXJuY29udGVudHVuaXRzJyxcbiAgICAgICdwYXR0ZXJudHJhbnNmb3JtJyxcbiAgICAgICdwYXR0ZXJudW5pdHMnLFxuICAgICAgJ3BvaW50cycsXG4gICAgICAncHJlc2VydmVhbHBoYScsXG4gICAgICAncHJlc2VydmVhc3BlY3RyYXRpbycsXG4gICAgICAncHJpbWl0aXZldW5pdHMnLFxuICAgICAgJ3InLFxuICAgICAgJ3J4JyxcbiAgICAgICdyeScsXG4gICAgICAncmFkaXVzJyxcbiAgICAgICdyZWZ4JyxcbiAgICAgICdyZWZ5JyxcbiAgICAgICdyZXBlYXRjb3VudCcsXG4gICAgICAncmVwZWF0ZHVyJyxcbiAgICAgICdyZXN0YXJ0JyxcbiAgICAgICdyZXN1bHQnLFxuICAgICAgJ3JvdGF0ZScsXG4gICAgICAnc2NhbGUnLFxuICAgICAgJ3NlZWQnLFxuICAgICAgJ3NoYXBlLXJlbmRlcmluZycsXG4gICAgICAnc3BlY3VsYXJjb25zdGFudCcsXG4gICAgICAnc3BlY3VsYXJleHBvbmVudCcsXG4gICAgICAnc3ByZWFkbWV0aG9kJyxcbiAgICAgICdzdGFydG9mZnNldCcsXG4gICAgICAnc3RkZGV2aWF0aW9uJyxcbiAgICAgICdzdGl0Y2h0aWxlcycsXG4gICAgICAnc3RvcC1jb2xvcicsXG4gICAgICAnc3RvcC1vcGFjaXR5JyxcbiAgICAgICdzdHJva2UtZGFzaGFycmF5JyxcbiAgICAgICdzdHJva2UtZGFzaG9mZnNldCcsXG4gICAgICAnc3Ryb2tlLWxpbmVjYXAnLFxuICAgICAgJ3N0cm9rZS1saW5lam9pbicsXG4gICAgICAnc3Ryb2tlLW1pdGVybGltaXQnLFxuICAgICAgJ3N0cm9rZS1vcGFjaXR5JyxcbiAgICAgICdzdHJva2UnLFxuICAgICAgJ3N0cm9rZS13aWR0aCcsXG4gICAgICAnc3R5bGUnLFxuICAgICAgJ3N1cmZhY2VzY2FsZScsXG4gICAgICAnc3lzdGVtbGFuZ3VhZ2UnLFxuICAgICAgJ3RhYmluZGV4JyxcbiAgICAgICd0YXJnZXR4JyxcbiAgICAgICd0YXJnZXR5JyxcbiAgICAgICd0cmFuc2Zvcm0nLFxuICAgICAgJ3RyYW5zZm9ybS1vcmlnaW4nLFxuICAgICAgJ3RleHQtYW5jaG9yJyxcbiAgICAgICd0ZXh0LWRlY29yYXRpb24nLFxuICAgICAgJ3RleHQtcmVuZGVyaW5nJyxcbiAgICAgICd0ZXh0bGVuZ3RoJyxcbiAgICAgICd0eXBlJyxcbiAgICAgICd1MScsXG4gICAgICAndTInLFxuICAgICAgJ3VuaWNvZGUnLFxuICAgICAgJ3ZhbHVlcycsXG4gICAgICAndmlld2JveCcsXG4gICAgICAndmlzaWJpbGl0eScsXG4gICAgICAndmVyc2lvbicsXG4gICAgICAndmVydC1hZHYteScsXG4gICAgICAndmVydC1vcmlnaW4teCcsXG4gICAgICAndmVydC1vcmlnaW4teScsXG4gICAgICAnd2lkdGgnLFxuICAgICAgJ3dvcmQtc3BhY2luZycsXG4gICAgICAnd3JhcCcsXG4gICAgICAnd3JpdGluZy1tb2RlJyxcbiAgICAgICd4Y2hhbm5lbHNlbGVjdG9yJyxcbiAgICAgICd5Y2hhbm5lbHNlbGVjdG9yJyxcbiAgICAgICd4JyxcbiAgICAgICd4MScsXG4gICAgICAneDInLFxuICAgICAgJ3htbG5zJyxcbiAgICAgICd5JyxcbiAgICAgICd5MScsXG4gICAgICAneTInLFxuICAgICAgJ3onLFxuICAgICAgJ3pvb21hbmRwYW4nXG4gICAgXSk7XG4gICAgdmFyIG1hdGhNbCA9IGZyZWV6ZShbXG4gICAgICAnYWNjZW50JyxcbiAgICAgICdhY2NlbnR1bmRlcicsXG4gICAgICAnYWxpZ24nLFxuICAgICAgJ2JldmVsbGVkJyxcbiAgICAgICdjbG9zZScsXG4gICAgICAnY29sdW1uc2FsaWduJyxcbiAgICAgICdjb2x1bW5saW5lcycsXG4gICAgICAnY29sdW1uc3BhbicsXG4gICAgICAnZGVub21hbGlnbicsXG4gICAgICAnZGVwdGgnLFxuICAgICAgJ2RpcicsXG4gICAgICAnZGlzcGxheScsXG4gICAgICAnZGlzcGxheXN0eWxlJyxcbiAgICAgICdlbmNvZGluZycsXG4gICAgICAnZmVuY2UnLFxuICAgICAgJ2ZyYW1lJyxcbiAgICAgICdoZWlnaHQnLFxuICAgICAgJ2hyZWYnLFxuICAgICAgJ2lkJyxcbiAgICAgICdsYXJnZW9wJyxcbiAgICAgICdsZW5ndGgnLFxuICAgICAgJ2xpbmV0aGlja25lc3MnLFxuICAgICAgJ2xzcGFjZScsXG4gICAgICAnbHF1b3RlJyxcbiAgICAgICdtYXRoYmFja2dyb3VuZCcsXG4gICAgICAnbWF0aGNvbG9yJyxcbiAgICAgICdtYXRoc2l6ZScsXG4gICAgICAnbWF0aHZhcmlhbnQnLFxuICAgICAgJ21heHNpemUnLFxuICAgICAgJ21pbnNpemUnLFxuICAgICAgJ21vdmFibGVsaW1pdHMnLFxuICAgICAgJ25vdGF0aW9uJyxcbiAgICAgICdudW1hbGlnbicsXG4gICAgICAnb3BlbicsXG4gICAgICAncm93YWxpZ24nLFxuICAgICAgJ3Jvd2xpbmVzJyxcbiAgICAgICdyb3dzcGFjaW5nJyxcbiAgICAgICdyb3dzcGFuJyxcbiAgICAgICdyc3BhY2UnLFxuICAgICAgJ3JxdW90ZScsXG4gICAgICAnc2NyaXB0bGV2ZWwnLFxuICAgICAgJ3NjcmlwdG1pbnNpemUnLFxuICAgICAgJ3NjcmlwdHNpemVtdWx0aXBsaWVyJyxcbiAgICAgICdzZWxlY3Rpb24nLFxuICAgICAgJ3NlcGFyYXRvcicsXG4gICAgICAnc2VwYXJhdG9ycycsXG4gICAgICAnc3RyZXRjaHknLFxuICAgICAgJ3N1YnNjcmlwdHNoaWZ0JyxcbiAgICAgICdzdXBzY3JpcHRzaGlmdCcsXG4gICAgICAnc3ltbWV0cmljJyxcbiAgICAgICd2b2Zmc2V0JyxcbiAgICAgICd3aWR0aCcsXG4gICAgICAneG1sbnMnXG4gICAgXSk7XG4gICAgdmFyIHhtbCA9IGZyZWV6ZShbXG4gICAgICAneGxpbms6aHJlZicsXG4gICAgICAneG1sOmlkJyxcbiAgICAgICd4bGluazp0aXRsZScsXG4gICAgICAneG1sOnNwYWNlJyxcbiAgICAgICd4bWxuczp4bGluaydcbiAgICBdKTtcbiAgICB2YXIgTVVTVEFDSEVfRVhQUiA9IHNlYWwoL1xce1xce1tcXHdcXFddKnxbXFx3XFxXXSpcXH1cXH0vZ20pO1xuICAgIHZhciBFUkJfRVhQUiA9IHNlYWwoLzwlW1xcd1xcV10qfFtcXHdcXFddKiU+L2dtKTtcbiAgICB2YXIgREFUQV9BVFRSID0gc2VhbCgvXmRhdGEtW1xcLVxcdy5cXHUwMEI3LVxcdUZGRkZdLyk7XG4gICAgdmFyIEFSSUFfQVRUUiA9IHNlYWwoL15hcmlhLVtcXC1cXHddKyQvKTtcbiAgICB2YXIgSVNfQUxMT1dFRF9VUkkgPSBzZWFsKC9eKD86KD86KD86ZnxodCl0cHM/fG1haWx0b3x0ZWx8Y2FsbHRvfGNpZHx4bXBwKTp8W15hLXpdfFthLXorLlxcLV0rKD86W15hLXorLlxcLTpdfCQpKS9pKTtcbiAgICB2YXIgSVNfU0NSSVBUX09SX0RBVEEgPSBzZWFsKC9eKD86XFx3K3NjcmlwdHxkYXRhKTovaSk7XG4gICAgdmFyIEFUVFJfV0hJVEVTUEFDRSA9IHNlYWwoL1tcXHUwMDAwLVxcdTAwMjBcXHUwMEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwLVxcdTIwMjlcXHUyMDVGXFx1MzAwMF0vZyk7XG4gICAgdmFyIERPQ1RZUEVfTkFNRSA9IHNlYWwoL15odG1sJC9pKTtcbiAgICB2YXIgZ2V0R2xvYmFsID0gZnVuY3Rpb24gZ2V0R2xvYmFsKCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHdpbmRvdztcbiAgICB9O1xuICAgIHZhciBfY3JlYXRlVHJ1c3RlZFR5cGVzUG9saWN5ID0gZnVuY3Rpb24gX2NyZWF0ZVRydXN0ZWRUeXBlc1BvbGljeSh0cnVzdGVkVHlwZXMsIGRvY3VtZW50KSB7XG4gICAgICBpZiAoX3R5cGVvZih0cnVzdGVkVHlwZXMpICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgdHJ1c3RlZFR5cGVzLmNyZWF0ZVBvbGljeSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBzdWZmaXggPSBudWxsO1xuICAgICAgdmFyIEFUVFJfTkFNRSA9ICdkYXRhLXR0LXBvbGljeS1zdWZmaXgnO1xuICAgICAgaWYgKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgJiYgZG9jdW1lbnQuY3VycmVudFNjcmlwdC5oYXNBdHRyaWJ1dGUoQVRUUl9OQU1FKSkge1xuICAgICAgICBzdWZmaXggPSBkb2N1bWVudC5jdXJyZW50U2NyaXB0LmdldEF0dHJpYnV0ZShBVFRSX05BTUUpO1xuICAgICAgfVxuICAgICAgdmFyIHBvbGljeU5hbWUgPSAnZG9tcHVyaWZ5JyArIChzdWZmaXggPyAnIycgKyBzdWZmaXggOiAnJyk7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdHJ1c3RlZFR5cGVzLmNyZWF0ZVBvbGljeShwb2xpY3lOYW1lLCB7XG4gICAgICAgICAgY3JlYXRlSFRNTDogZnVuY3Rpb24gY3JlYXRlSFRNTChodG1sKSB7XG4gICAgICAgICAgICByZXR1cm4gaHRtbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1RydXN0ZWRUeXBlcyBwb2xpY3kgJyArIHBvbGljeU5hbWUgKyAnIGNvdWxkIG5vdCBiZSBjcmVhdGVkLicpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGNyZWF0ZURPTVB1cmlmeSgpIHtcbiAgICAgIHZhciB3aW5kb3cgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGdldEdsb2JhbCgpO1xuICAgICAgdmFyIERPTVB1cmlmeSA9IGZ1bmN0aW9uIERPTVB1cmlmeShyb290KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVET01QdXJpZnkocm9vdCk7XG4gICAgICB9O1xuICAgICAgRE9NUHVyaWZ5LnZlcnNpb24gPSAnMi4zLjgnO1xuICAgICAgRE9NUHVyaWZ5LnJlbW92ZWQgPSBbXTtcbiAgICAgIGlmICghd2luZG93IHx8ICF3aW5kb3cuZG9jdW1lbnQgfHwgd2luZG93LmRvY3VtZW50Lm5vZGVUeXBlICE9PSA5KSB7XG4gICAgICAgIERPTVB1cmlmeS5pc1N1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gRE9NUHVyaWZ5O1xuICAgICAgfVxuICAgICAgdmFyIG9yaWdpbmFsRG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG4gICAgICB2YXIgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG4gICAgICB2YXIgRG9jdW1lbnRGcmFnbWVudCA9IHdpbmRvdy5Eb2N1bWVudEZyYWdtZW50LCBIVE1MVGVtcGxhdGVFbGVtZW50ID0gd2luZG93LkhUTUxUZW1wbGF0ZUVsZW1lbnQsIE5vZGUgPSB3aW5kb3cuTm9kZSwgRWxlbWVudCA9IHdpbmRvdy5FbGVtZW50LCBOb2RlRmlsdGVyID0gd2luZG93Lk5vZGVGaWx0ZXIsIF93aW5kb3ckTmFtZWROb2RlTWFwID0gd2luZG93Lk5hbWVkTm9kZU1hcCwgTmFtZWROb2RlTWFwID0gX3dpbmRvdyROYW1lZE5vZGVNYXAgPT09IHZvaWQgMCA/IHdpbmRvdy5OYW1lZE5vZGVNYXAgfHwgd2luZG93Lk1vek5hbWVkQXR0ck1hcCA6IF93aW5kb3ckTmFtZWROb2RlTWFwLCBIVE1MRm9ybUVsZW1lbnQgPSB3aW5kb3cuSFRNTEZvcm1FbGVtZW50LCBET01QYXJzZXIgPSB3aW5kb3cuRE9NUGFyc2VyLCB0cnVzdGVkVHlwZXMgPSB3aW5kb3cudHJ1c3RlZFR5cGVzO1xuICAgICAgdmFyIEVsZW1lbnRQcm90b3R5cGUgPSBFbGVtZW50LnByb3RvdHlwZTtcbiAgICAgIHZhciBjbG9uZU5vZGUgPSBsb29rdXBHZXR0ZXIoRWxlbWVudFByb3RvdHlwZSwgJ2Nsb25lTm9kZScpO1xuICAgICAgdmFyIGdldE5leHRTaWJsaW5nID0gbG9va3VwR2V0dGVyKEVsZW1lbnRQcm90b3R5cGUsICduZXh0U2libGluZycpO1xuICAgICAgdmFyIGdldENoaWxkTm9kZXMgPSBsb29rdXBHZXR0ZXIoRWxlbWVudFByb3RvdHlwZSwgJ2NoaWxkTm9kZXMnKTtcbiAgICAgIHZhciBnZXRQYXJlbnROb2RlID0gbG9va3VwR2V0dGVyKEVsZW1lbnRQcm90b3R5cGUsICdwYXJlbnROb2RlJyk7XG4gICAgICBpZiAodHlwZW9mIEhUTUxUZW1wbGF0ZUVsZW1lbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgaWYgKHRlbXBsYXRlLmNvbnRlbnQgJiYgdGVtcGxhdGUuY29udGVudC5vd25lckRvY3VtZW50KSB7XG4gICAgICAgICAgZG9jdW1lbnQgPSB0ZW1wbGF0ZS5jb250ZW50Lm93bmVyRG9jdW1lbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciB0cnVzdGVkVHlwZXNQb2xpY3kgPSBfY3JlYXRlVHJ1c3RlZFR5cGVzUG9saWN5KHRydXN0ZWRUeXBlcywgb3JpZ2luYWxEb2N1bWVudCk7XG4gICAgICB2YXIgZW1wdHlIVE1MID0gdHJ1c3RlZFR5cGVzUG9saWN5ID8gdHJ1c3RlZFR5cGVzUG9saWN5LmNyZWF0ZUhUTUwoJycpIDogJyc7XG4gICAgICB2YXIgX2RvY3VtZW50ID0gZG9jdW1lbnQsIGltcGxlbWVudGF0aW9uID0gX2RvY3VtZW50LmltcGxlbWVudGF0aW9uLCBjcmVhdGVOb2RlSXRlcmF0b3IgPSBfZG9jdW1lbnQuY3JlYXRlTm9kZUl0ZXJhdG9yLCBjcmVhdGVEb2N1bWVudEZyYWdtZW50ID0gX2RvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQsIGdldEVsZW1lbnRzQnlUYWdOYW1lID0gX2RvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lO1xuICAgICAgdmFyIGltcG9ydE5vZGUgPSBvcmlnaW5hbERvY3VtZW50LmltcG9ydE5vZGU7XG4gICAgICB2YXIgZG9jdW1lbnRNb2RlID0ge307XG4gICAgICB0cnkge1xuICAgICAgICBkb2N1bWVudE1vZGUgPSBjbG9uZShkb2N1bWVudCkuZG9jdW1lbnRNb2RlID8gZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDoge307XG4gICAgICB9IGNhdGNoIChfKSB7XG4gICAgICB9XG4gICAgICB2YXIgaG9va3MgPSB7fTtcbiAgICAgIERPTVB1cmlmeS5pc1N1cHBvcnRlZCA9IHR5cGVvZiBnZXRQYXJlbnROb2RlID09PSAnZnVuY3Rpb24nICYmIGltcGxlbWVudGF0aW9uICYmIHR5cGVvZiBpbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50TW9kZSAhPT0gOTtcbiAgICAgIHZhciBNVVNUQUNIRV9FWFBSJDEgPSBNVVNUQUNIRV9FWFBSLCBFUkJfRVhQUiQxID0gRVJCX0VYUFIsIERBVEFfQVRUUiQxID0gREFUQV9BVFRSLCBBUklBX0FUVFIkMSA9IEFSSUFfQVRUUiwgSVNfU0NSSVBUX09SX0RBVEEkMSA9IElTX1NDUklQVF9PUl9EQVRBLCBBVFRSX1dISVRFU1BBQ0UkMSA9IEFUVFJfV0hJVEVTUEFDRTtcbiAgICAgIHZhciBJU19BTExPV0VEX1VSSSQxID0gSVNfQUxMT1dFRF9VUkk7XG4gICAgICB2YXIgQUxMT1dFRF9UQUdTID0gbnVsbDtcbiAgICAgIHZhciBERUZBVUxUX0FMTE9XRURfVEFHUyA9IGFkZFRvU2V0KHt9LCBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGh0bWwkMSksIF90b0NvbnN1bWFibGVBcnJheShzdmckMSksIF90b0NvbnN1bWFibGVBcnJheShzdmdGaWx0ZXJzKSwgX3RvQ29uc3VtYWJsZUFycmF5KG1hdGhNbCQxKSwgX3RvQ29uc3VtYWJsZUFycmF5KHRleHQpKSk7XG4gICAgICB2YXIgQUxMT1dFRF9BVFRSID0gbnVsbDtcbiAgICAgIHZhciBERUZBVUxUX0FMTE9XRURfQVRUUiA9IGFkZFRvU2V0KHt9LCBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGh0bWwpLCBfdG9Db25zdW1hYmxlQXJyYXkoc3ZnKSwgX3RvQ29uc3VtYWJsZUFycmF5KG1hdGhNbCksIF90b0NvbnN1bWFibGVBcnJheSh4bWwpKSk7XG4gICAgICB2YXIgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcgPSBPYmplY3Quc2VhbChPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgICAgdGFnTmFtZUNoZWNrOiB7XG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIGF0dHJpYnV0ZU5hbWVDaGVjazoge1xuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICB9LFxuICAgICAgICBhbGxvd0N1c3RvbWl6ZWRCdWlsdEluRWxlbWVudHM6IHtcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICAgIHZhciBGT1JCSURfVEFHUyA9IG51bGw7XG4gICAgICB2YXIgRk9SQklEX0FUVFIgPSBudWxsO1xuICAgICAgdmFyIEFMTE9XX0FSSUFfQVRUUiA9IHRydWU7XG4gICAgICB2YXIgQUxMT1dfREFUQV9BVFRSID0gdHJ1ZTtcbiAgICAgIHZhciBBTExPV19VTktOT1dOX1BST1RPQ09MUyA9IGZhbHNlO1xuICAgICAgdmFyIFNBRkVfRk9SX1RFTVBMQVRFUyA9IGZhbHNlO1xuICAgICAgdmFyIFdIT0xFX0RPQ1VNRU5UID0gZmFsc2U7XG4gICAgICB2YXIgU0VUX0NPTkZJRyA9IGZhbHNlO1xuICAgICAgdmFyIEZPUkNFX0JPRFkgPSBmYWxzZTtcbiAgICAgIHZhciBSRVRVUk5fRE9NID0gZmFsc2U7XG4gICAgICB2YXIgUkVUVVJOX0RPTV9GUkFHTUVOVCA9IGZhbHNlO1xuICAgICAgdmFyIFJFVFVSTl9UUlVTVEVEX1RZUEUgPSBmYWxzZTtcbiAgICAgIHZhciBTQU5JVElaRV9ET00gPSB0cnVlO1xuICAgICAgdmFyIEtFRVBfQ09OVEVOVCA9IHRydWU7XG4gICAgICB2YXIgSU5fUExBQ0UgPSBmYWxzZTtcbiAgICAgIHZhciBVU0VfUFJPRklMRVMgPSB7fTtcbiAgICAgIHZhciBGT1JCSURfQ09OVEVOVFMgPSBudWxsO1xuICAgICAgdmFyIERFRkFVTFRfRk9SQklEX0NPTlRFTlRTID0gYWRkVG9TZXQoe30sIFtcbiAgICAgICAgJ2Fubm90YXRpb24teG1sJyxcbiAgICAgICAgJ2F1ZGlvJyxcbiAgICAgICAgJ2NvbGdyb3VwJyxcbiAgICAgICAgJ2Rlc2MnLFxuICAgICAgICAnZm9yZWlnbm9iamVjdCcsXG4gICAgICAgICdoZWFkJyxcbiAgICAgICAgJ2lmcmFtZScsXG4gICAgICAgICdtYXRoJyxcbiAgICAgICAgJ21pJyxcbiAgICAgICAgJ21uJyxcbiAgICAgICAgJ21vJyxcbiAgICAgICAgJ21zJyxcbiAgICAgICAgJ210ZXh0JyxcbiAgICAgICAgJ25vZW1iZWQnLFxuICAgICAgICAnbm9mcmFtZXMnLFxuICAgICAgICAnbm9zY3JpcHQnLFxuICAgICAgICAncGxhaW50ZXh0JyxcbiAgICAgICAgJ3NjcmlwdCcsXG4gICAgICAgICdzdHlsZScsXG4gICAgICAgICdzdmcnLFxuICAgICAgICAndGVtcGxhdGUnLFxuICAgICAgICAndGhlYWQnLFxuICAgICAgICAndGl0bGUnLFxuICAgICAgICAndmlkZW8nLFxuICAgICAgICAneG1wJ1xuICAgICAgXSk7XG4gICAgICB2YXIgREFUQV9VUklfVEFHUyA9IG51bGw7XG4gICAgICB2YXIgREVGQVVMVF9EQVRBX1VSSV9UQUdTID0gYWRkVG9TZXQoe30sIFtcbiAgICAgICAgJ2F1ZGlvJyxcbiAgICAgICAgJ3ZpZGVvJyxcbiAgICAgICAgJ2ltZycsXG4gICAgICAgICdzb3VyY2UnLFxuICAgICAgICAnaW1hZ2UnLFxuICAgICAgICAndHJhY2snXG4gICAgICBdKTtcbiAgICAgIHZhciBVUklfU0FGRV9BVFRSSUJVVEVTID0gbnVsbDtcbiAgICAgIHZhciBERUZBVUxUX1VSSV9TQUZFX0FUVFJJQlVURVMgPSBhZGRUb1NldCh7fSwgW1xuICAgICAgICAnYWx0JyxcbiAgICAgICAgJ2NsYXNzJyxcbiAgICAgICAgJ2ZvcicsXG4gICAgICAgICdpZCcsXG4gICAgICAgICdsYWJlbCcsXG4gICAgICAgICduYW1lJyxcbiAgICAgICAgJ3BhdHRlcm4nLFxuICAgICAgICAncGxhY2Vob2xkZXInLFxuICAgICAgICAncm9sZScsXG4gICAgICAgICdzdW1tYXJ5JyxcbiAgICAgICAgJ3RpdGxlJyxcbiAgICAgICAgJ3ZhbHVlJyxcbiAgICAgICAgJ3N0eWxlJyxcbiAgICAgICAgJ3htbG5zJ1xuICAgICAgXSk7XG4gICAgICB2YXIgTUFUSE1MX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJztcbiAgICAgIHZhciBTVkdfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbiAgICAgIHZhciBIVE1MX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcbiAgICAgIHZhciBOQU1FU1BBQ0UgPSBIVE1MX05BTUVTUEFDRTtcbiAgICAgIHZhciBJU19FTVBUWV9JTlBVVCA9IGZhbHNlO1xuICAgICAgdmFyIFBBUlNFUl9NRURJQV9UWVBFO1xuICAgICAgdmFyIFNVUFBPUlRFRF9QQVJTRVJfTUVESUFfVFlQRVMgPSBbXG4gICAgICAgICdhcHBsaWNhdGlvbi94aHRtbCt4bWwnLFxuICAgICAgICAndGV4dC9odG1sJ1xuICAgICAgXTtcbiAgICAgIHZhciBERUZBVUxUX1BBUlNFUl9NRURJQV9UWVBFID0gJ3RleHQvaHRtbCc7XG4gICAgICB2YXIgdHJhbnNmb3JtQ2FzZUZ1bmM7XG4gICAgICB2YXIgQ09ORklHID0gbnVsbDtcbiAgICAgIHZhciBmb3JtRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKTtcbiAgICAgIHZhciBpc1JlZ2V4T3JGdW5jdGlvbiA9IGZ1bmN0aW9uIGlzUmVnZXhPckZ1bmN0aW9uKHRlc3RWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGVzdFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwIHx8IHRlc3RWYWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uO1xuICAgICAgfTtcbiAgICAgIHZhciBfcGFyc2VDb25maWcgPSBmdW5jdGlvbiBfcGFyc2VDb25maWcoY2ZnKSB7XG4gICAgICAgIGlmIChDT05GSUcgJiYgQ09ORklHID09PSBjZmcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjZmcgfHwgX3R5cGVvZihjZmcpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGNmZyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGNmZyA9IGNsb25lKGNmZyk7XG4gICAgICAgIEFMTE9XRURfVEFHUyA9ICdBTExPV0VEX1RBR1MnIGluIGNmZyA/IGFkZFRvU2V0KHt9LCBjZmcuQUxMT1dFRF9UQUdTKSA6IERFRkFVTFRfQUxMT1dFRF9UQUdTO1xuICAgICAgICBBTExPV0VEX0FUVFIgPSAnQUxMT1dFRF9BVFRSJyBpbiBjZmcgPyBhZGRUb1NldCh7fSwgY2ZnLkFMTE9XRURfQVRUUikgOiBERUZBVUxUX0FMTE9XRURfQVRUUjtcbiAgICAgICAgVVJJX1NBRkVfQVRUUklCVVRFUyA9ICdBRERfVVJJX1NBRkVfQVRUUicgaW4gY2ZnID8gYWRkVG9TZXQoY2xvbmUoREVGQVVMVF9VUklfU0FGRV9BVFRSSUJVVEVTKSwgY2ZnLkFERF9VUklfU0FGRV9BVFRSKSA6IERFRkFVTFRfVVJJX1NBRkVfQVRUUklCVVRFUztcbiAgICAgICAgREFUQV9VUklfVEFHUyA9ICdBRERfREFUQV9VUklfVEFHUycgaW4gY2ZnID8gYWRkVG9TZXQoY2xvbmUoREVGQVVMVF9EQVRBX1VSSV9UQUdTKSwgY2ZnLkFERF9EQVRBX1VSSV9UQUdTKSA6IERFRkFVTFRfREFUQV9VUklfVEFHUztcbiAgICAgICAgRk9SQklEX0NPTlRFTlRTID0gJ0ZPUkJJRF9DT05URU5UUycgaW4gY2ZnID8gYWRkVG9TZXQoe30sIGNmZy5GT1JCSURfQ09OVEVOVFMpIDogREVGQVVMVF9GT1JCSURfQ09OVEVOVFM7XG4gICAgICAgIEZPUkJJRF9UQUdTID0gJ0ZPUkJJRF9UQUdTJyBpbiBjZmcgPyBhZGRUb1NldCh7fSwgY2ZnLkZPUkJJRF9UQUdTKSA6IHt9O1xuICAgICAgICBGT1JCSURfQVRUUiA9ICdGT1JCSURfQVRUUicgaW4gY2ZnID8gYWRkVG9TZXQoe30sIGNmZy5GT1JCSURfQVRUUikgOiB7fTtcbiAgICAgICAgVVNFX1BST0ZJTEVTID0gJ1VTRV9QUk9GSUxFUycgaW4gY2ZnID8gY2ZnLlVTRV9QUk9GSUxFUyA6IGZhbHNlO1xuICAgICAgICBBTExPV19BUklBX0FUVFIgPSBjZmcuQUxMT1dfQVJJQV9BVFRSICE9PSBmYWxzZTtcbiAgICAgICAgQUxMT1dfREFUQV9BVFRSID0gY2ZnLkFMTE9XX0RBVEFfQVRUUiAhPT0gZmFsc2U7XG4gICAgICAgIEFMTE9XX1VOS05PV05fUFJPVE9DT0xTID0gY2ZnLkFMTE9XX1VOS05PV05fUFJPVE9DT0xTIHx8IGZhbHNlO1xuICAgICAgICBTQUZFX0ZPUl9URU1QTEFURVMgPSBjZmcuU0FGRV9GT1JfVEVNUExBVEVTIHx8IGZhbHNlO1xuICAgICAgICBXSE9MRV9ET0NVTUVOVCA9IGNmZy5XSE9MRV9ET0NVTUVOVCB8fCBmYWxzZTtcbiAgICAgICAgUkVUVVJOX0RPTSA9IGNmZy5SRVRVUk5fRE9NIHx8IGZhbHNlO1xuICAgICAgICBSRVRVUk5fRE9NX0ZSQUdNRU5UID0gY2ZnLlJFVFVSTl9ET01fRlJBR01FTlQgfHwgZmFsc2U7XG4gICAgICAgIFJFVFVSTl9UUlVTVEVEX1RZUEUgPSBjZmcuUkVUVVJOX1RSVVNURURfVFlQRSB8fCBmYWxzZTtcbiAgICAgICAgRk9SQ0VfQk9EWSA9IGNmZy5GT1JDRV9CT0RZIHx8IGZhbHNlO1xuICAgICAgICBTQU5JVElaRV9ET00gPSBjZmcuU0FOSVRJWkVfRE9NICE9PSBmYWxzZTtcbiAgICAgICAgS0VFUF9DT05URU5UID0gY2ZnLktFRVBfQ09OVEVOVCAhPT0gZmFsc2U7XG4gICAgICAgIElOX1BMQUNFID0gY2ZnLklOX1BMQUNFIHx8IGZhbHNlO1xuICAgICAgICBJU19BTExPV0VEX1VSSSQxID0gY2ZnLkFMTE9XRURfVVJJX1JFR0VYUCB8fCBJU19BTExPV0VEX1VSSSQxO1xuICAgICAgICBOQU1FU1BBQ0UgPSBjZmcuTkFNRVNQQUNFIHx8IEhUTUxfTkFNRVNQQUNFO1xuICAgICAgICBpZiAoY2ZnLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HICYmIGlzUmVnZXhPckZ1bmN0aW9uKGNmZy5DVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2spKSB7XG4gICAgICAgICAgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrID0gY2ZnLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ZnLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HICYmIGlzUmVnZXhPckZ1bmN0aW9uKGNmZy5DVVNUT01fRUxFTUVOVF9IQU5ETElORy5hdHRyaWJ1dGVOYW1lQ2hlY2spKSB7XG4gICAgICAgICAgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYXR0cmlidXRlTmFtZUNoZWNrID0gY2ZnLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmF0dHJpYnV0ZU5hbWVDaGVjaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ZnLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HICYmIHR5cGVvZiBjZmcuQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYWxsb3dDdXN0b21pemVkQnVpbHRJbkVsZW1lbnRzID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBDVVNUT01fRUxFTUVOVF9IQU5ETElORy5hbGxvd0N1c3RvbWl6ZWRCdWlsdEluRWxlbWVudHMgPSBjZmcuQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYWxsb3dDdXN0b21pemVkQnVpbHRJbkVsZW1lbnRzO1xuICAgICAgICB9XG4gICAgICAgIFBBUlNFUl9NRURJQV9UWVBFID0gU1VQUE9SVEVEX1BBUlNFUl9NRURJQV9UWVBFUy5pbmRleE9mKGNmZy5QQVJTRVJfTUVESUFfVFlQRSkgPT09IC0xID8gUEFSU0VSX01FRElBX1RZUEUgPSBERUZBVUxUX1BBUlNFUl9NRURJQV9UWVBFIDogUEFSU0VSX01FRElBX1RZUEUgPSBjZmcuUEFSU0VSX01FRElBX1RZUEU7XG4gICAgICAgIHRyYW5zZm9ybUNhc2VGdW5jID0gUEFSU0VSX01FRElBX1RZUEUgPT09ICdhcHBsaWNhdGlvbi94aHRtbCt4bWwnID8gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfSA6IHN0cmluZ1RvTG93ZXJDYXNlO1xuICAgICAgICBpZiAoU0FGRV9GT1JfVEVNUExBVEVTKSB7XG4gICAgICAgICAgQUxMT1dfREFUQV9BVFRSID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFJFVFVSTl9ET01fRlJBR01FTlQpIHtcbiAgICAgICAgICBSRVRVUk5fRE9NID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoVVNFX1BST0ZJTEVTKSB7XG4gICAgICAgICAgQUxMT1dFRF9UQUdTID0gYWRkVG9TZXQoe30sIF90b0NvbnN1bWFibGVBcnJheSh0ZXh0KSk7XG4gICAgICAgICAgQUxMT1dFRF9BVFRSID0gW107XG4gICAgICAgICAgaWYgKFVTRV9QUk9GSUxFUy5odG1sID09PSB0cnVlKSB7XG4gICAgICAgICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIGh0bWwkMSk7XG4gICAgICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIGh0bWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoVVNFX1BST0ZJTEVTLnN2ZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9UQUdTLCBzdmckMSk7XG4gICAgICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHN2Zyk7XG4gICAgICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHhtbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChVU0VfUFJPRklMRVMuc3ZnRmlsdGVycyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9UQUdTLCBzdmdGaWx0ZXJzKTtcbiAgICAgICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgc3ZnKTtcbiAgICAgICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgeG1sKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFVTRV9QUk9GSUxFUy5tYXRoTWwgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgbWF0aE1sJDEpO1xuICAgICAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCBtYXRoTWwpO1xuICAgICAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCB4bWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ZnLkFERF9UQUdTKSB7XG4gICAgICAgICAgaWYgKEFMTE9XRURfVEFHUyA9PT0gREVGQVVMVF9BTExPV0VEX1RBR1MpIHtcbiAgICAgICAgICAgIEFMTE9XRURfVEFHUyA9IGNsb25lKEFMTE9XRURfVEFHUyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgY2ZnLkFERF9UQUdTKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ZnLkFERF9BVFRSKSB7XG4gICAgICAgICAgaWYgKEFMTE9XRURfQVRUUiA9PT0gREVGQVVMVF9BTExPV0VEX0FUVFIpIHtcbiAgICAgICAgICAgIEFMTE9XRURfQVRUUiA9IGNsb25lKEFMTE9XRURfQVRUUik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgY2ZnLkFERF9BVFRSKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ZnLkFERF9VUklfU0FGRV9BVFRSKSB7XG4gICAgICAgICAgYWRkVG9TZXQoVVJJX1NBRkVfQVRUUklCVVRFUywgY2ZnLkFERF9VUklfU0FGRV9BVFRSKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ZnLkZPUkJJRF9DT05URU5UUykge1xuICAgICAgICAgIGlmIChGT1JCSURfQ09OVEVOVFMgPT09IERFRkFVTFRfRk9SQklEX0NPTlRFTlRTKSB7XG4gICAgICAgICAgICBGT1JCSURfQ09OVEVOVFMgPSBjbG9uZShGT1JCSURfQ09OVEVOVFMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhZGRUb1NldChGT1JCSURfQ09OVEVOVFMsIGNmZy5GT1JCSURfQ09OVEVOVFMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChLRUVQX0NPTlRFTlQpIHtcbiAgICAgICAgICBBTExPV0VEX1RBR1NbJyN0ZXh0J10gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChXSE9MRV9ET0NVTUVOVCkge1xuICAgICAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgW1xuICAgICAgICAgICAgJ2h0bWwnLFxuICAgICAgICAgICAgJ2hlYWQnLFxuICAgICAgICAgICAgJ2JvZHknXG4gICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFMTE9XRURfVEFHUy50YWJsZSkge1xuICAgICAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgWyd0Ym9keSddKTtcbiAgICAgICAgICBkZWxldGUgRk9SQklEX1RBR1MudGJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyZWV6ZSkge1xuICAgICAgICAgIGZyZWV6ZShjZmcpO1xuICAgICAgICB9XG4gICAgICAgIENPTkZJRyA9IGNmZztcbiAgICAgIH07XG4gICAgICB2YXIgTUFUSE1MX1RFWFRfSU5URUdSQVRJT05fUE9JTlRTID0gYWRkVG9TZXQoe30sIFtcbiAgICAgICAgJ21pJyxcbiAgICAgICAgJ21vJyxcbiAgICAgICAgJ21uJyxcbiAgICAgICAgJ21zJyxcbiAgICAgICAgJ210ZXh0J1xuICAgICAgXSk7XG4gICAgICB2YXIgSFRNTF9JTlRFR1JBVElPTl9QT0lOVFMgPSBhZGRUb1NldCh7fSwgW1xuICAgICAgICAnZm9yZWlnbm9iamVjdCcsXG4gICAgICAgICdkZXNjJyxcbiAgICAgICAgJ3RpdGxlJyxcbiAgICAgICAgJ2Fubm90YXRpb24teG1sJ1xuICAgICAgXSk7XG4gICAgICB2YXIgQ09NTU9OX1NWR19BTkRfSFRNTF9FTEVNRU5UUyA9IGFkZFRvU2V0KHt9LCBbXG4gICAgICAgICd0aXRsZScsXG4gICAgICAgICdzdHlsZScsXG4gICAgICAgICdmb250JyxcbiAgICAgICAgJ2EnLFxuICAgICAgICAnc2NyaXB0J1xuICAgICAgXSk7XG4gICAgICB2YXIgQUxMX1NWR19UQUdTID0gYWRkVG9TZXQoe30sIHN2ZyQxKTtcbiAgICAgIGFkZFRvU2V0KEFMTF9TVkdfVEFHUywgc3ZnRmlsdGVycyk7XG4gICAgICBhZGRUb1NldChBTExfU1ZHX1RBR1MsIHN2Z0Rpc2FsbG93ZWQpO1xuICAgICAgdmFyIEFMTF9NQVRITUxfVEFHUyA9IGFkZFRvU2V0KHt9LCBtYXRoTWwkMSk7XG4gICAgICBhZGRUb1NldChBTExfTUFUSE1MX1RBR1MsIG1hdGhNbERpc2FsbG93ZWQpO1xuICAgICAgdmFyIF9jaGVja1ZhbGlkTmFtZXNwYWNlID0gZnVuY3Rpb24gX2NoZWNrVmFsaWROYW1lc3BhY2UoZWxlbWVudCkge1xuICAgICAgICB2YXIgcGFyZW50ID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcbiAgICAgICAgaWYgKCFwYXJlbnQgfHwgIXBhcmVudC50YWdOYW1lKSB7XG4gICAgICAgICAgcGFyZW50ID0ge1xuICAgICAgICAgICAgbmFtZXNwYWNlVVJJOiBIVE1MX05BTUVTUEFDRSxcbiAgICAgICAgICAgIHRhZ05hbWU6ICd0ZW1wbGF0ZSdcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciB0YWdOYW1lID0gc3RyaW5nVG9Mb3dlckNhc2UoZWxlbWVudC50YWdOYW1lKTtcbiAgICAgICAgdmFyIHBhcmVudFRhZ05hbWUgPSBzdHJpbmdUb0xvd2VyQ2FzZShwYXJlbnQudGFnTmFtZSk7XG4gICAgICAgIGlmIChlbGVtZW50Lm5hbWVzcGFjZVVSSSA9PT0gU1ZHX05BTUVTUEFDRSkge1xuICAgICAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgICAgICAgcmV0dXJuIHRhZ05hbWUgPT09ICdzdmcnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gTUFUSE1MX05BTUVTUEFDRSkge1xuICAgICAgICAgICAgcmV0dXJuIHRhZ05hbWUgPT09ICdzdmcnICYmIChwYXJlbnRUYWdOYW1lID09PSAnYW5ub3RhdGlvbi14bWwnIHx8IE1BVEhNTF9URVhUX0lOVEVHUkFUSU9OX1BPSU5UU1twYXJlbnRUYWdOYW1lXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBCb29sZWFuKEFMTF9TVkdfVEFHU1t0YWdOYW1lXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1lbnQubmFtZXNwYWNlVVJJID09PSBNQVRITUxfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgaWYgKHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFnTmFtZSA9PT0gJ21hdGgnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gU1ZHX05BTUVTUEFDRSkge1xuICAgICAgICAgICAgcmV0dXJuIHRhZ05hbWUgPT09ICdtYXRoJyAmJiBIVE1MX0lOVEVHUkFUSU9OX1BPSU5UU1twYXJlbnRUYWdOYW1lXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIEJvb2xlYW4oQUxMX01BVEhNTF9UQUdTW3RhZ05hbWVdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbWVudC5uYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgaWYgKHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IFNWR19OQU1FU1BBQ0UgJiYgIUhUTUxfSU5URUdSQVRJT05fUE9JTlRTW3BhcmVudFRhZ05hbWVdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJID09PSBNQVRITUxfTkFNRVNQQUNFICYmICFNQVRITUxfVEVYVF9JTlRFR1JBVElPTl9QT0lOVFNbcGFyZW50VGFnTmFtZV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICFBTExfTUFUSE1MX1RBR1NbdGFnTmFtZV0gJiYgKENPTU1PTl9TVkdfQU5EX0hUTUxfRUxFTUVOVFNbdGFnTmFtZV0gfHwgIUFMTF9TVkdfVEFHU1t0YWdOYW1lXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICAgIHZhciBfZm9yY2VSZW1vdmUgPSBmdW5jdGlvbiBfZm9yY2VSZW1vdmUobm9kZSkge1xuICAgICAgICBhcnJheVB1c2goRE9NUHVyaWZ5LnJlbW92ZWQsIHsgZWxlbWVudDogbm9kZSB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbm9kZS5vdXRlckhUTUwgPSBlbXB0eUhUTUw7XG4gICAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgX3JlbW92ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIF9yZW1vdmVBdHRyaWJ1dGUobmFtZSwgbm9kZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGFycmF5UHVzaChET01QdXJpZnkucmVtb3ZlZCwge1xuICAgICAgICAgICAgYXR0cmlidXRlOiBub2RlLmdldEF0dHJpYnV0ZU5vZGUobmFtZSksXG4gICAgICAgICAgICBmcm9tOiBub2RlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICBhcnJheVB1c2goRE9NUHVyaWZ5LnJlbW92ZWQsIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZTogbnVsbCxcbiAgICAgICAgICAgIGZyb206IG5vZGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgaWYgKG5hbWUgPT09ICdpcycgJiYgIUFMTE9XRURfQVRUUltuYW1lXSkge1xuICAgICAgICAgIGlmIChSRVRVUk5fRE9NIHx8IFJFVFVSTl9ET01fRlJBR01FTlQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIF9mb3JjZVJlbW92ZShub2RlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgJycpO1xuICAgICAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBfaW5pdERvY3VtZW50ID0gZnVuY3Rpb24gX2luaXREb2N1bWVudChkaXJ0eSkge1xuICAgICAgICB2YXIgZG9jO1xuICAgICAgICB2YXIgbGVhZGluZ1doaXRlc3BhY2U7XG4gICAgICAgIGlmIChGT1JDRV9CT0RZKSB7XG4gICAgICAgICAgZGlydHkgPSAnPHJlbW92ZT48L3JlbW92ZT4nICsgZGlydHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG1hdGNoZXMgPSBzdHJpbmdNYXRjaChkaXJ0eSwgL15bXFxyXFxuXFx0IF0rLyk7XG4gICAgICAgICAgbGVhZGluZ1doaXRlc3BhY2UgPSBtYXRjaGVzICYmIG1hdGNoZXNbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFBBUlNFUl9NRURJQV9UWVBFID09PSAnYXBwbGljYXRpb24veGh0bWwreG1sJykge1xuICAgICAgICAgIGRpcnR5ID0gJzxodG1sIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiPjxoZWFkPjwvaGVhZD48Ym9keT4nICsgZGlydHkgKyAnPC9ib2R5PjwvaHRtbD4nO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkaXJ0eVBheWxvYWQgPSB0cnVzdGVkVHlwZXNQb2xpY3kgPyB0cnVzdGVkVHlwZXNQb2xpY3kuY3JlYXRlSFRNTChkaXJ0eSkgOiBkaXJ0eTtcbiAgICAgICAgaWYgKE5BTUVTUEFDRSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZG9jID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhkaXJ0eVBheWxvYWQsIFBBUlNFUl9NRURJQV9UWVBFKTtcbiAgICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZG9jIHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgICAgZG9jID0gaW1wbGVtZW50YXRpb24uY3JlYXRlRG9jdW1lbnQoTkFNRVNQQUNFLCAndGVtcGxhdGUnLCBudWxsKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZG9jLmRvY3VtZW50RWxlbWVudC5pbm5lckhUTUwgPSBJU19FTVBUWV9JTlBVVCA/ICcnIDogZGlydHlQYXlsb2FkO1xuICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJvZHkgPSBkb2MuYm9keSB8fCBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICBpZiAoZGlydHkgJiYgbGVhZGluZ1doaXRlc3BhY2UpIHtcbiAgICAgICAgICBib2R5Lmluc2VydEJlZm9yZShkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsZWFkaW5nV2hpdGVzcGFjZSksIGJvZHkuY2hpbGROb2Rlc1swXSB8fCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTkFNRVNQQUNFID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgICAgIHJldHVybiBnZXRFbGVtZW50c0J5VGFnTmFtZS5jYWxsKGRvYywgV0hPTEVfRE9DVU1FTlQgPyAnaHRtbCcgOiAnYm9keScpWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBXSE9MRV9ET0NVTUVOVCA/IGRvYy5kb2N1bWVudEVsZW1lbnQgOiBib2R5O1xuICAgICAgfTtcbiAgICAgIHZhciBfY3JlYXRlSXRlcmF0b3IgPSBmdW5jdGlvbiBfY3JlYXRlSXRlcmF0b3Iocm9vdCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTm9kZUl0ZXJhdG9yLmNhbGwocm9vdC5vd25lckRvY3VtZW50IHx8IHJvb3QsIHJvb3QsIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5UIHwgTm9kZUZpbHRlci5TSE9XX0NPTU1FTlQgfCBOb2RlRmlsdGVyLlNIT1dfVEVYVCwgbnVsbCwgZmFsc2UpO1xuICAgICAgfTtcbiAgICAgIHZhciBfaXNDbG9iYmVyZWQgPSBmdW5jdGlvbiBfaXNDbG9iYmVyZWQoZWxtKSB7XG4gICAgICAgIHJldHVybiBlbG0gaW5zdGFuY2VvZiBIVE1MRm9ybUVsZW1lbnQgJiYgKHR5cGVvZiBlbG0ubm9kZU5hbWUgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbG0udGV4dENvbnRlbnQgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbG0ucmVtb3ZlQ2hpbGQgIT09ICdmdW5jdGlvbicgfHwgIShlbG0uYXR0cmlidXRlcyBpbnN0YW5jZW9mIE5hbWVkTm9kZU1hcCkgfHwgdHlwZW9mIGVsbS5yZW1vdmVBdHRyaWJ1dGUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGVsbS5zZXRBdHRyaWJ1dGUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGVsbS5uYW1lc3BhY2VVUkkgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbG0uaW5zZXJ0QmVmb3JlICE9PSAnZnVuY3Rpb24nKTtcbiAgICAgIH07XG4gICAgICB2YXIgX2lzTm9kZSA9IGZ1bmN0aW9uIF9pc05vZGUob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBfdHlwZW9mKE5vZGUpID09PSAnb2JqZWN0JyA/IG9iamVjdCBpbnN0YW5jZW9mIE5vZGUgOiBvYmplY3QgJiYgX3R5cGVvZihvYmplY3QpID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVUeXBlID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVOYW1lID09PSAnc3RyaW5nJztcbiAgICAgIH07XG4gICAgICB2YXIgX2V4ZWN1dGVIb29rID0gZnVuY3Rpb24gX2V4ZWN1dGVIb29rKGVudHJ5UG9pbnQsIGN1cnJlbnROb2RlLCBkYXRhKSB7XG4gICAgICAgIGlmICghaG9va3NbZW50cnlQb2ludF0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYXJyYXlGb3JFYWNoKGhvb2tzW2VudHJ5UG9pbnRdLCBmdW5jdGlvbiAoaG9vaykge1xuICAgICAgICAgIGhvb2suY2FsbChET01QdXJpZnksIGN1cnJlbnROb2RlLCBkYXRhLCBDT05GSUcpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICB2YXIgX3Nhbml0aXplRWxlbWVudHMgPSBmdW5jdGlvbiBfc2FuaXRpemVFbGVtZW50cyhjdXJyZW50Tm9kZSkge1xuICAgICAgICB2YXIgY29udGVudDtcbiAgICAgICAgX2V4ZWN1dGVIb29rKCdiZWZvcmVTYW5pdGl6ZUVsZW1lbnRzJywgY3VycmVudE5vZGUsIG51bGwpO1xuICAgICAgICBpZiAoX2lzQ2xvYmJlcmVkKGN1cnJlbnROb2RlKSkge1xuICAgICAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZ0V4cFRlc3QoL1tcXHUwMDgwLVxcdUZGRkZdLywgY3VycmVudE5vZGUubm9kZU5hbWUpKSB7XG4gICAgICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGFnTmFtZSA9IHRyYW5zZm9ybUNhc2VGdW5jKGN1cnJlbnROb2RlLm5vZGVOYW1lKTtcbiAgICAgICAgX2V4ZWN1dGVIb29rKCd1cG9uU2FuaXRpemVFbGVtZW50JywgY3VycmVudE5vZGUsIHtcbiAgICAgICAgICB0YWdOYW1lOiB0YWdOYW1lLFxuICAgICAgICAgIGFsbG93ZWRUYWdzOiBBTExPV0VEX1RBR1NcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjdXJyZW50Tm9kZS5oYXNDaGlsZE5vZGVzKCkgJiYgIV9pc05vZGUoY3VycmVudE5vZGUuZmlyc3RFbGVtZW50Q2hpbGQpICYmICghX2lzTm9kZShjdXJyZW50Tm9kZS5jb250ZW50KSB8fCAhX2lzTm9kZShjdXJyZW50Tm9kZS5jb250ZW50LmZpcnN0RWxlbWVudENoaWxkKSkgJiYgcmVnRXhwVGVzdCgvPFsvXFx3XS9nLCBjdXJyZW50Tm9kZS5pbm5lckhUTUwpICYmIHJlZ0V4cFRlc3QoLzxbL1xcd10vZywgY3VycmVudE5vZGUudGV4dENvbnRlbnQpKSB7XG4gICAgICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ3NlbGVjdCcgJiYgcmVnRXhwVGVzdCgvPHRlbXBsYXRlL2ksIGN1cnJlbnROb2RlLmlubmVySFRNTCkpIHtcbiAgICAgICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghQUxMT1dFRF9UQUdTW3RhZ05hbWVdIHx8IEZPUkJJRF9UQUdTW3RhZ05hbWVdKSB7XG4gICAgICAgICAgaWYgKCFGT1JCSURfVEFHU1t0YWdOYW1lXSAmJiBfYmFzaWNDdXN0b21FbGVtZW50VGVzdCh0YWdOYW1lKSkge1xuICAgICAgICAgICAgaWYgKENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjayBpbnN0YW5jZW9mIFJlZ0V4cCAmJiByZWdFeHBUZXN0KENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjaywgdGFnTmFtZSkpXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sodGFnTmFtZSkpXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKEtFRVBfQ09OVEVOVCAmJiAhRk9SQklEX0NPTlRFTlRTW3RhZ05hbWVdKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoY3VycmVudE5vZGUpIHx8IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB2YXIgY2hpbGROb2RlcyA9IGdldENoaWxkTm9kZXMoY3VycmVudE5vZGUpIHx8IGN1cnJlbnROb2RlLmNoaWxkTm9kZXM7XG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlcyAmJiBwYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgIHZhciBjaGlsZENvdW50ID0gY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSBjaGlsZENvdW50IC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShjbG9uZU5vZGUoY2hpbGROb2Rlc1tpXSwgdHJ1ZSksIGdldE5leHRTaWJsaW5nKGN1cnJlbnROb2RlKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudE5vZGUgaW5zdGFuY2VvZiBFbGVtZW50ICYmICFfY2hlY2tWYWxpZE5hbWVzcGFjZShjdXJyZW50Tm9kZSkpIHtcbiAgICAgICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgodGFnTmFtZSA9PT0gJ25vc2NyaXB0JyB8fCB0YWdOYW1lID09PSAnbm9lbWJlZCcpICYmIHJlZ0V4cFRlc3QoLzxcXC9ubyhzY3JpcHR8ZW1iZWQpL2ksIGN1cnJlbnROb2RlLmlubmVySFRNTCkpIHtcbiAgICAgICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChTQUZFX0ZPUl9URU1QTEFURVMgJiYgY3VycmVudE5vZGUubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgICAgICBjb250ZW50ID0gY3VycmVudE5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgICAgY29udGVudCA9IHN0cmluZ1JlcGxhY2UoY29udGVudCwgTVVTVEFDSEVfRVhQUiQxLCAnICcpO1xuICAgICAgICAgIGNvbnRlbnQgPSBzdHJpbmdSZXBsYWNlKGNvbnRlbnQsIEVSQl9FWFBSJDEsICcgJyk7XG4gICAgICAgICAgaWYgKGN1cnJlbnROb2RlLnRleHRDb250ZW50ICE9PSBjb250ZW50KSB7XG4gICAgICAgICAgICBhcnJheVB1c2goRE9NUHVyaWZ5LnJlbW92ZWQsIHsgZWxlbWVudDogY3VycmVudE5vZGUuY2xvbmVOb2RlKCkgfSk7XG4gICAgICAgICAgICBjdXJyZW50Tm9kZS50ZXh0Q29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF9leGVjdXRlSG9vaygnYWZ0ZXJTYW5pdGl6ZUVsZW1lbnRzJywgY3VycmVudE5vZGUsIG51bGwpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgICAgdmFyIF9pc1ZhbGlkQXR0cmlidXRlID0gZnVuY3Rpb24gX2lzVmFsaWRBdHRyaWJ1dGUobGNUYWcsIGxjTmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKFNBTklUSVpFX0RPTSAmJiAobGNOYW1lID09PSAnaWQnIHx8IGxjTmFtZSA9PT0gJ25hbWUnKSAmJiAodmFsdWUgaW4gZG9jdW1lbnQgfHwgdmFsdWUgaW4gZm9ybUVsZW1lbnQpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBTExPV19EQVRBX0FUVFIgJiYgIUZPUkJJRF9BVFRSW2xjTmFtZV0gJiYgcmVnRXhwVGVzdChEQVRBX0FUVFIkMSwgbGNOYW1lKSk7XG4gICAgICAgIGVsc2UgaWYgKEFMTE9XX0FSSUFfQVRUUiAmJiByZWdFeHBUZXN0KEFSSUFfQVRUUiQxLCBsY05hbWUpKTtcbiAgICAgICAgZWxzZSBpZiAoIUFMTE9XRURfQVRUUltsY05hbWVdIHx8IEZPUkJJRF9BVFRSW2xjTmFtZV0pIHtcbiAgICAgICAgICBpZiAoX2Jhc2ljQ3VzdG9tRWxlbWVudFRlc3QobGNUYWcpICYmIChDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sgaW5zdGFuY2VvZiBSZWdFeHAgJiYgcmVnRXhwVGVzdChDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2ssIGxjVGFnKSB8fCBDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sobGNUYWcpKSAmJiAoQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYXR0cmlidXRlTmFtZUNoZWNrIGluc3RhbmNlb2YgUmVnRXhwICYmIHJlZ0V4cFRlc3QoQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYXR0cmlidXRlTmFtZUNoZWNrLCBsY05hbWUpIHx8IENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmF0dHJpYnV0ZU5hbWVDaGVjayBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmF0dHJpYnV0ZU5hbWVDaGVjayhsY05hbWUpKSB8fCBsY05hbWUgPT09ICdpcycgJiYgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYWxsb3dDdXN0b21pemVkQnVpbHRJbkVsZW1lbnRzICYmIChDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sgaW5zdGFuY2VvZiBSZWdFeHAgJiYgcmVnRXhwVGVzdChDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2ssIHZhbHVlKSB8fCBDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sodmFsdWUpKSk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKFVSSV9TQUZFX0FUVFJJQlVURVNbbGNOYW1lXSk7XG4gICAgICAgIGVsc2UgaWYgKHJlZ0V4cFRlc3QoSVNfQUxMT1dFRF9VUkkkMSwgc3RyaW5nUmVwbGFjZSh2YWx1ZSwgQVRUUl9XSElURVNQQUNFJDEsICcnKSkpO1xuICAgICAgICBlbHNlIGlmICgobGNOYW1lID09PSAnc3JjJyB8fCBsY05hbWUgPT09ICd4bGluazpocmVmJyB8fCBsY05hbWUgPT09ICdocmVmJykgJiYgbGNUYWcgIT09ICdzY3JpcHQnICYmIHN0cmluZ0luZGV4T2YodmFsdWUsICdkYXRhOicpID09PSAwICYmIERBVEFfVVJJX1RBR1NbbGNUYWddKTtcbiAgICAgICAgZWxzZSBpZiAoQUxMT1dfVU5LTk9XTl9QUk9UT0NPTFMgJiYgIXJlZ0V4cFRlc3QoSVNfU0NSSVBUX09SX0RBVEEkMSwgc3RyaW5nUmVwbGFjZSh2YWx1ZSwgQVRUUl9XSElURVNQQUNFJDEsICcnKSkpO1xuICAgICAgICBlbHNlIGlmICghdmFsdWUpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgICAgdmFyIF9iYXNpY0N1c3RvbUVsZW1lbnRUZXN0ID0gZnVuY3Rpb24gX2Jhc2ljQ3VzdG9tRWxlbWVudFRlc3QodGFnTmFtZSkge1xuICAgICAgICByZXR1cm4gdGFnTmFtZS5pbmRleE9mKCctJykgPiAwO1xuICAgICAgfTtcbiAgICAgIHZhciBfc2FuaXRpemVBdHRyaWJ1dGVzID0gZnVuY3Rpb24gX3Nhbml0aXplQXR0cmlidXRlcyhjdXJyZW50Tm9kZSkge1xuICAgICAgICB2YXIgYXR0cjtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICB2YXIgbGNOYW1lO1xuICAgICAgICB2YXIgbDtcbiAgICAgICAgX2V4ZWN1dGVIb29rKCdiZWZvcmVTYW5pdGl6ZUF0dHJpYnV0ZXMnLCBjdXJyZW50Tm9kZSwgbnVsbCk7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gY3VycmVudE5vZGUuYXR0cmlidXRlcztcbiAgICAgICAgaWYgKCFhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBob29rRXZlbnQgPSB7XG4gICAgICAgICAgYXR0ck5hbWU6ICcnLFxuICAgICAgICAgIGF0dHJWYWx1ZTogJycsXG4gICAgICAgICAga2VlcEF0dHI6IHRydWUsXG4gICAgICAgICAgYWxsb3dlZEF0dHJpYnV0ZXM6IEFMTE9XRURfQVRUUlxuICAgICAgICB9O1xuICAgICAgICBsID0gYXR0cmlidXRlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChsLS0pIHtcbiAgICAgICAgICBhdHRyID0gYXR0cmlidXRlc1tsXTtcbiAgICAgICAgICB2YXIgX2F0dHIgPSBhdHRyLCBuYW1lID0gX2F0dHIubmFtZSwgbmFtZXNwYWNlVVJJID0gX2F0dHIubmFtZXNwYWNlVVJJO1xuICAgICAgICAgIHZhbHVlID0gbmFtZSA9PT0gJ3ZhbHVlJyA/IGF0dHIudmFsdWUgOiBzdHJpbmdUcmltKGF0dHIudmFsdWUpO1xuICAgICAgICAgIGxjTmFtZSA9IHRyYW5zZm9ybUNhc2VGdW5jKG5hbWUpO1xuICAgICAgICAgIHZhciBpbml0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICBob29rRXZlbnQuYXR0ck5hbWUgPSBsY05hbWU7XG4gICAgICAgICAgaG9va0V2ZW50LmF0dHJWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIGhvb2tFdmVudC5rZWVwQXR0ciA9IHRydWU7XG4gICAgICAgICAgaG9va0V2ZW50LmZvcmNlS2VlcEF0dHIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgX2V4ZWN1dGVIb29rKCd1cG9uU2FuaXRpemVBdHRyaWJ1dGUnLCBjdXJyZW50Tm9kZSwgaG9va0V2ZW50KTtcbiAgICAgICAgICB2YWx1ZSA9IGhvb2tFdmVudC5hdHRyVmFsdWU7XG4gICAgICAgICAgaWYgKGhvb2tFdmVudC5mb3JjZUtlZXBBdHRyKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFob29rRXZlbnQua2VlcEF0dHIpIHtcbiAgICAgICAgICAgIF9yZW1vdmVBdHRyaWJ1dGUobmFtZSwgY3VycmVudE5vZGUpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZWdFeHBUZXN0KC9cXC8+L2ksIHZhbHVlKSkge1xuICAgICAgICAgICAgX3JlbW92ZUF0dHJpYnV0ZShuYW1lLCBjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFNBRkVfRk9SX1RFTVBMQVRFUykge1xuICAgICAgICAgICAgdmFsdWUgPSBzdHJpbmdSZXBsYWNlKHZhbHVlLCBNVVNUQUNIRV9FWFBSJDEsICcgJyk7XG4gICAgICAgICAgICB2YWx1ZSA9IHN0cmluZ1JlcGxhY2UodmFsdWUsIEVSQl9FWFBSJDEsICcgJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBsY1RhZyA9IHRyYW5zZm9ybUNhc2VGdW5jKGN1cnJlbnROb2RlLm5vZGVOYW1lKTtcbiAgICAgICAgICBpZiAoIV9pc1ZhbGlkQXR0cmlidXRlKGxjVGFnLCBsY05hbWUsIHZhbHVlKSkge1xuICAgICAgICAgICAgX3JlbW92ZUF0dHJpYnV0ZShuYW1lLCBjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSBpbml0VmFsdWUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmIChuYW1lc3BhY2VVUkkpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5zZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2VVUkksIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgIF9yZW1vdmVBdHRyaWJ1dGUobmFtZSwgY3VycmVudE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfZXhlY3V0ZUhvb2soJ2FmdGVyU2FuaXRpemVBdHRyaWJ1dGVzJywgY3VycmVudE5vZGUsIG51bGwpO1xuICAgICAgfTtcbiAgICAgIHZhciBfc2FuaXRpemVTaGFkb3dET00gPSBmdW5jdGlvbiBfc2FuaXRpemVTaGFkb3dET00oZnJhZ21lbnQpIHtcbiAgICAgICAgdmFyIHNoYWRvd05vZGU7XG4gICAgICAgIHZhciBzaGFkb3dJdGVyYXRvciA9IF9jcmVhdGVJdGVyYXRvcihmcmFnbWVudCk7XG4gICAgICAgIF9leGVjdXRlSG9vaygnYmVmb3JlU2FuaXRpemVTaGFkb3dET00nLCBmcmFnbWVudCwgbnVsbCk7XG4gICAgICAgIHdoaWxlIChzaGFkb3dOb2RlID0gc2hhZG93SXRlcmF0b3IubmV4dE5vZGUoKSkge1xuICAgICAgICAgIF9leGVjdXRlSG9vaygndXBvblNhbml0aXplU2hhZG93Tm9kZScsIHNoYWRvd05vZGUsIG51bGwpO1xuICAgICAgICAgIGlmIChfc2FuaXRpemVFbGVtZW50cyhzaGFkb3dOb2RlKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzaGFkb3dOb2RlLmNvbnRlbnQgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSB7XG4gICAgICAgICAgICBfc2FuaXRpemVTaGFkb3dET00oc2hhZG93Tm9kZS5jb250ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3Nhbml0aXplQXR0cmlidXRlcyhzaGFkb3dOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBfZXhlY3V0ZUhvb2soJ2FmdGVyU2FuaXRpemVTaGFkb3dET00nLCBmcmFnbWVudCwgbnVsbCk7XG4gICAgICB9O1xuICAgICAgRE9NUHVyaWZ5LnNhbml0aXplID0gZnVuY3Rpb24gKGRpcnR5LCBjZmcpIHtcbiAgICAgICAgdmFyIGJvZHk7XG4gICAgICAgIHZhciBpbXBvcnRlZE5vZGU7XG4gICAgICAgIHZhciBjdXJyZW50Tm9kZTtcbiAgICAgICAgdmFyIG9sZE5vZGU7XG4gICAgICAgIHZhciByZXR1cm5Ob2RlO1xuICAgICAgICBJU19FTVBUWV9JTlBVVCA9ICFkaXJ0eTtcbiAgICAgICAgaWYgKElTX0VNUFRZX0lOUFVUKSB7XG4gICAgICAgICAgZGlydHkgPSAnPCEtLT4nO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZGlydHkgIT09ICdzdHJpbmcnICYmICFfaXNOb2RlKGRpcnR5KSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgZGlydHkudG9TdHJpbmcgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IHR5cGVFcnJvckNyZWF0ZSgndG9TdHJpbmcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlydHkgPSBkaXJ0eS50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkaXJ0eSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgdGhyb3cgdHlwZUVycm9yQ3JlYXRlKCdkaXJ0eSBpcyBub3QgYSBzdHJpbmcsIGFib3J0aW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghRE9NUHVyaWZ5LmlzU3VwcG9ydGVkKSB7XG4gICAgICAgICAgaWYgKF90eXBlb2Yod2luZG93LnRvU3RhdGljSFRNTCkgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB3aW5kb3cudG9TdGF0aWNIVE1MID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRpcnR5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICByZXR1cm4gd2luZG93LnRvU3RhdGljSFRNTChkaXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX2lzTm9kZShkaXJ0eSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy50b1N0YXRpY0hUTUwoZGlydHkub3V0ZXJIVE1MKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRpcnR5O1xuICAgICAgICB9XG4gICAgICAgIGlmICghU0VUX0NPTkZJRykge1xuICAgICAgICAgIF9wYXJzZUNvbmZpZyhjZmcpO1xuICAgICAgICB9XG4gICAgICAgIERPTVB1cmlmeS5yZW1vdmVkID0gW107XG4gICAgICAgIGlmICh0eXBlb2YgZGlydHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgSU5fUExBQ0UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSU5fUExBQ0UpIHtcbiAgICAgICAgICBpZiAoZGlydHkubm9kZU5hbWUpIHtcbiAgICAgICAgICAgIHZhciB0YWdOYW1lID0gdHJhbnNmb3JtQ2FzZUZ1bmMoZGlydHkubm9kZU5hbWUpO1xuICAgICAgICAgICAgaWYgKCFBTExPV0VEX1RBR1NbdGFnTmFtZV0gfHwgRk9SQklEX1RBR1NbdGFnTmFtZV0pIHtcbiAgICAgICAgICAgICAgdGhyb3cgdHlwZUVycm9yQ3JlYXRlKCdyb290IG5vZGUgaXMgZm9yYmlkZGVuIGFuZCBjYW5ub3QgYmUgc2FuaXRpemVkIGluLXBsYWNlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRpcnR5IGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICAgIGJvZHkgPSBfaW5pdERvY3VtZW50KCc8IS0tLS0+Jyk7XG4gICAgICAgICAgaW1wb3J0ZWROb2RlID0gYm9keS5vd25lckRvY3VtZW50LmltcG9ydE5vZGUoZGlydHksIHRydWUpO1xuICAgICAgICAgIGlmIChpbXBvcnRlZE5vZGUubm9kZVR5cGUgPT09IDEgJiYgaW1wb3J0ZWROb2RlLm5vZGVOYW1lID09PSAnQk9EWScpIHtcbiAgICAgICAgICAgIGJvZHkgPSBpbXBvcnRlZE5vZGU7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbXBvcnRlZE5vZGUubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgICAgICAgICAgYm9keSA9IGltcG9ydGVkTm9kZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYm9keS5hcHBlbmRDaGlsZChpbXBvcnRlZE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIVJFVFVSTl9ET00gJiYgIVNBRkVfRk9SX1RFTVBMQVRFUyAmJiAhV0hPTEVfRE9DVU1FTlQgJiYgZGlydHkuaW5kZXhPZignPCcpID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydXN0ZWRUeXBlc1BvbGljeSAmJiBSRVRVUk5fVFJVU1RFRF9UWVBFID8gdHJ1c3RlZFR5cGVzUG9saWN5LmNyZWF0ZUhUTUwoZGlydHkpIDogZGlydHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJvZHkgPSBfaW5pdERvY3VtZW50KGRpcnR5KTtcbiAgICAgICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgICAgIHJldHVybiBSRVRVUk5fRE9NID8gbnVsbCA6IFJFVFVSTl9UUlVTVEVEX1RZUEUgPyBlbXB0eUhUTUwgOiAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJvZHkgJiYgRk9SQ0VfQk9EWSkge1xuICAgICAgICAgIF9mb3JjZVJlbW92ZShib2R5LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlSXRlcmF0b3IgPSBfY3JlYXRlSXRlcmF0b3IoSU5fUExBQ0UgPyBkaXJ0eSA6IGJvZHkpO1xuICAgICAgICB3aGlsZSAoY3VycmVudE5vZGUgPSBub2RlSXRlcmF0b3IubmV4dE5vZGUoKSkge1xuICAgICAgICAgIGlmIChjdXJyZW50Tm9kZS5ub2RlVHlwZSA9PT0gMyAmJiBjdXJyZW50Tm9kZSA9PT0gb2xkTm9kZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChfc2FuaXRpemVFbGVtZW50cyhjdXJyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY3VycmVudE5vZGUuY29udGVudCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgICAgICAgIF9zYW5pdGl6ZVNoYWRvd0RPTShjdXJyZW50Tm9kZS5jb250ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3Nhbml0aXplQXR0cmlidXRlcyhjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgb2xkTm9kZSA9IGN1cnJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIG9sZE5vZGUgPSBudWxsO1xuICAgICAgICBpZiAoSU5fUExBQ0UpIHtcbiAgICAgICAgICByZXR1cm4gZGlydHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFJFVFVSTl9ET00pIHtcbiAgICAgICAgICBpZiAoUkVUVVJOX0RPTV9GUkFHTUVOVCkge1xuICAgICAgICAgICAgcmV0dXJuTm9kZSA9IGNyZWF0ZURvY3VtZW50RnJhZ21lbnQuY2FsbChib2R5Lm93bmVyRG9jdW1lbnQpO1xuICAgICAgICAgICAgd2hpbGUgKGJvZHkuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICByZXR1cm5Ob2RlLmFwcGVuZENoaWxkKGJvZHkuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybk5vZGUgPSBib2R5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoQUxMT1dFRF9BVFRSLnNoYWRvd3Jvb3QpIHtcbiAgICAgICAgICAgIHJldHVybk5vZGUgPSBpbXBvcnROb2RlLmNhbGwob3JpZ2luYWxEb2N1bWVudCwgcmV0dXJuTm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXR1cm5Ob2RlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZXJpYWxpemVkSFRNTCA9IFdIT0xFX0RPQ1VNRU5UID8gYm9keS5vdXRlckhUTUwgOiBib2R5LmlubmVySFRNTDtcbiAgICAgICAgaWYgKFdIT0xFX0RPQ1VNRU5UICYmIEFMTE9XRURfVEFHU1snIWRvY3R5cGUnXSAmJiBib2R5Lm93bmVyRG9jdW1lbnQgJiYgYm9keS5vd25lckRvY3VtZW50LmRvY3R5cGUgJiYgYm9keS5vd25lckRvY3VtZW50LmRvY3R5cGUubmFtZSAmJiByZWdFeHBUZXN0KERPQ1RZUEVfTkFNRSwgYm9keS5vd25lckRvY3VtZW50LmRvY3R5cGUubmFtZSkpIHtcbiAgICAgICAgICBzZXJpYWxpemVkSFRNTCA9ICc8IURPQ1RZUEUgJyArIGJvZHkub3duZXJEb2N1bWVudC5kb2N0eXBlLm5hbWUgKyAnPlxcbicgKyBzZXJpYWxpemVkSFRNTDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoU0FGRV9GT1JfVEVNUExBVEVTKSB7XG4gICAgICAgICAgc2VyaWFsaXplZEhUTUwgPSBzdHJpbmdSZXBsYWNlKHNlcmlhbGl6ZWRIVE1MLCBNVVNUQUNIRV9FWFBSJDEsICcgJyk7XG4gICAgICAgICAgc2VyaWFsaXplZEhUTUwgPSBzdHJpbmdSZXBsYWNlKHNlcmlhbGl6ZWRIVE1MLCBFUkJfRVhQUiQxLCAnICcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVzdGVkVHlwZXNQb2xpY3kgJiYgUkVUVVJOX1RSVVNURURfVFlQRSA/IHRydXN0ZWRUeXBlc1BvbGljeS5jcmVhdGVIVE1MKHNlcmlhbGl6ZWRIVE1MKSA6IHNlcmlhbGl6ZWRIVE1MO1xuICAgICAgfTtcbiAgICAgIERPTVB1cmlmeS5zZXRDb25maWcgPSBmdW5jdGlvbiAoY2ZnKSB7XG4gICAgICAgIF9wYXJzZUNvbmZpZyhjZmcpO1xuICAgICAgICBTRVRfQ09ORklHID0gdHJ1ZTtcbiAgICAgIH07XG4gICAgICBET01QdXJpZnkuY2xlYXJDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIENPTkZJRyA9IG51bGw7XG4gICAgICAgIFNFVF9DT05GSUcgPSBmYWxzZTtcbiAgICAgIH07XG4gICAgICBET01QdXJpZnkuaXNWYWxpZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHIsIHZhbHVlKSB7XG4gICAgICAgIGlmICghQ09ORklHKSB7XG4gICAgICAgICAgX3BhcnNlQ29uZmlnKHt9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGNUYWcgPSB0cmFuc2Zvcm1DYXNlRnVuYyh0YWcpO1xuICAgICAgICB2YXIgbGNOYW1lID0gdHJhbnNmb3JtQ2FzZUZ1bmMoYXR0cik7XG4gICAgICAgIHJldHVybiBfaXNWYWxpZEF0dHJpYnV0ZShsY1RhZywgbGNOYW1lLCB2YWx1ZSk7XG4gICAgICB9O1xuICAgICAgRE9NUHVyaWZ5LmFkZEhvb2sgPSBmdW5jdGlvbiAoZW50cnlQb2ludCwgaG9va0Z1bmN0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaG9va0Z1bmN0aW9uICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGhvb2tzW2VudHJ5UG9pbnRdID0gaG9va3NbZW50cnlQb2ludF0gfHwgW107XG4gICAgICAgIGFycmF5UHVzaChob29rc1tlbnRyeVBvaW50XSwgaG9va0Z1bmN0aW9uKTtcbiAgICAgIH07XG4gICAgICBET01QdXJpZnkucmVtb3ZlSG9vayA9IGZ1bmN0aW9uIChlbnRyeVBvaW50KSB7XG4gICAgICAgIGlmIChob29rc1tlbnRyeVBvaW50XSkge1xuICAgICAgICAgIHJldHVybiBhcnJheVBvcChob29rc1tlbnRyeVBvaW50XSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBET01QdXJpZnkucmVtb3ZlSG9va3MgPSBmdW5jdGlvbiAoZW50cnlQb2ludCkge1xuICAgICAgICBpZiAoaG9va3NbZW50cnlQb2ludF0pIHtcbiAgICAgICAgICBob29rc1tlbnRyeVBvaW50XSA9IFtdO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgRE9NUHVyaWZ5LnJlbW92ZUFsbEhvb2tzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBob29rcyA9IHt9O1xuICAgICAgfTtcbiAgICAgIHJldHVybiBET01QdXJpZnk7XG4gICAgfVxuICAgIHZhciBwdXJpZnkgPSBjcmVhdGVET01QdXJpZnkoKTtcblxuICAgIGNvbnN0IGVhY2gkNCA9IFRvb2xzLmVhY2gsIHRyaW0gPSBUb29scy50cmltO1xuICAgIGNvbnN0IHF1ZXJ5UGFydHMgPSBbXG4gICAgICAnc291cmNlJyxcbiAgICAgICdwcm90b2NvbCcsXG4gICAgICAnYXV0aG9yaXR5JyxcbiAgICAgICd1c2VySW5mbycsXG4gICAgICAndXNlcicsXG4gICAgICAncGFzc3dvcmQnLFxuICAgICAgJ2hvc3QnLFxuICAgICAgJ3BvcnQnLFxuICAgICAgJ3JlbGF0aXZlJyxcbiAgICAgICdwYXRoJyxcbiAgICAgICdkaXJlY3RvcnknLFxuICAgICAgJ2ZpbGUnLFxuICAgICAgJ3F1ZXJ5JyxcbiAgICAgICdhbmNob3InXG4gICAgXTtcbiAgICBjb25zdCBERUZBVUxUX1BPUlRTID0ge1xuICAgICAgZnRwOiAyMSxcbiAgICAgIGh0dHA6IDgwLFxuICAgICAgaHR0cHM6IDQ0MyxcbiAgICAgIG1haWx0bzogMjVcbiAgICB9O1xuICAgIGNvbnN0IHNhZmVTdmdEYXRhVXJsRWxlbWVudHMgPSBbXG4gICAgICAnaW1nJyxcbiAgICAgICd2aWRlbydcbiAgICBdO1xuICAgIGNvbnN0IGJsb2NrU3ZnRGF0YVVyaXMgPSAoYWxsb3dTdmdEYXRhVXJscywgdGFnTmFtZSkgPT4ge1xuICAgICAgaWYgKGlzTm9uTnVsbGFibGUoYWxsb3dTdmdEYXRhVXJscykpIHtcbiAgICAgICAgcmV0dXJuICFhbGxvd1N2Z0RhdGFVcmxzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGlzTm9uTnVsbGFibGUodGFnTmFtZSkgPyAhY29udGFpbnMkMihzYWZlU3ZnRGF0YVVybEVsZW1lbnRzLCB0YWdOYW1lKSA6IHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBkZWNvZGVVcmkgPSBlbmNvZGVkVXJpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZW5jb2RlZFVyaSk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICByZXR1cm4gdW5lc2NhcGUoZW5jb2RlZFVyaSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpc0ludmFsaWRVcmkgPSAoc2V0dGluZ3MsIHVyaSwgdGFnTmFtZSkgPT4ge1xuICAgICAgY29uc3QgZGVjb2RlZFVyaSA9IGRlY29kZVVyaSh1cmkpLnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgICBpZiAoc2V0dGluZ3MuYWxsb3dfc2NyaXB0X3VybHMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICgvKChqYXZhfHZiKXNjcmlwdHxtaHRtbCk6L2kudGVzdChkZWNvZGVkVXJpKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MuYWxsb3dfaHRtbF9kYXRhX3VybHMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICgvXmRhdGE6aW1hZ2VcXC8vaS50ZXN0KGRlY29kZWRVcmkpKSB7XG4gICAgICAgIHJldHVybiBibG9ja1N2Z0RhdGFVcmlzKHNldHRpbmdzLmFsbG93X3N2Z19kYXRhX3VybHMsIHRhZ05hbWUpICYmIC9eZGF0YTppbWFnZVxcL3N2Z1xcK3htbC9pLnRlc3QoZGVjb2RlZFVyaSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gL15kYXRhOi9pLnRlc3QoZGVjb2RlZFVyaSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjbGFzcyBVUkkge1xuICAgICAgY29uc3RydWN0b3IodXJsLCBzZXR0aW5ncyA9IHt9KSB7XG4gICAgICAgIHRoaXMucGF0aCA9ICcnO1xuICAgICAgICB0aGlzLmRpcmVjdG9yeSA9ICcnO1xuICAgICAgICB1cmwgPSB0cmltKHVybCk7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAgICAgY29uc3QgYmFzZVVyaSA9IHNldHRpbmdzLmJhc2VfdXJpO1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKC9eKFtcXHdcXC1dKyk6KFteXFwvXXsyfSkvaS50ZXN0KHVybCkgfHwgL15cXHMqIy8udGVzdCh1cmwpKSB7XG4gICAgICAgICAgc2VsZi5zb3VyY2UgPSB1cmw7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzUHJvdG9jb2xSZWxhdGl2ZSA9IHVybC5pbmRleE9mKCcvLycpID09PSAwO1xuICAgICAgICBpZiAodXJsLmluZGV4T2YoJy8nKSA9PT0gMCAmJiAhaXNQcm90b2NvbFJlbGF0aXZlKSB7XG4gICAgICAgICAgdXJsID0gKGJhc2VVcmkgPyBiYXNlVXJpLnByb3RvY29sIHx8ICdodHRwJyA6ICdodHRwJykgKyAnOi8vbWNlX2hvc3QnICsgdXJsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghL15bXFx3XFwtXSo6P1xcL1xcLy8udGVzdCh1cmwpKSB7XG4gICAgICAgICAgY29uc3QgYmFzZVVybCA9IGJhc2VVcmkgPyBiYXNlVXJpLnBhdGggOiBuZXcgVVJJKGRvY3VtZW50LmxvY2F0aW9uLmhyZWYpLmRpcmVjdG9yeTtcbiAgICAgICAgICBpZiAoKGJhc2VVcmkgPT09IG51bGwgfHwgYmFzZVVyaSA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmFzZVVyaS5wcm90b2NvbCkgPT09ICcnKSB7XG4gICAgICAgICAgICB1cmwgPSAnLy9tY2VfaG9zdCcgKyBzZWxmLnRvQWJzUGF0aChiYXNlVXJsLCB1cmwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IC8oW14jP10qKShbIz9dPy4qKS8uZXhlYyh1cmwpO1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgIHVybCA9IChiYXNlVXJpICYmIGJhc2VVcmkucHJvdG9jb2wgfHwgJ2h0dHAnKSArICc6Ly9tY2VfaG9zdCcgKyBzZWxmLnRvQWJzUGF0aChiYXNlVXJsLCBtYXRjaFsxXSkgKyBtYXRjaFsyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoL0BAL2csICcobWNlX2F0KScpO1xuICAgICAgICBjb25zdCB1cmxNYXRjaCA9IC9eKD86KD8hW146QF0rOlteOkBcXC9dKkApKFteOlxcLz8jLl0rKTopPyg/OlxcL1xcLyk/KCg/OigoW146QFxcL10qKTo/KFteOkBcXC9dKikpP0ApPyhcXFtbYS16QS1aMC05Oi4lXStcXF18W146XFwvPyNdKikoPzo6KFxcZCopKT8pKCgoXFwvKD86W14/I10oPyFbXj8jXFwvXSpcXC5bXj8jXFwvLl0rKD86Wz8jXXwkKSkpKlxcLz8pPyhbXj8jXFwvXSopKSg/OlxcPyhbXiNdKikpPyg/OiMoLiopKT8pLy5leGVjKHVybCk7XG4gICAgICAgIGlmICh1cmxNYXRjaCkge1xuICAgICAgICAgIGVhY2gkNChxdWVyeVBhcnRzLCAodiwgaSkgPT4ge1xuICAgICAgICAgICAgbGV0IHBhcnQgPSB1cmxNYXRjaFtpXTtcbiAgICAgICAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgICAgICAgIHBhcnQgPSBwYXJ0LnJlcGxhY2UoL1xcKG1jZV9hdFxcKS9nLCAnQEAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGZbdl0gPSBwYXJ0O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXNlVXJpKSB7XG4gICAgICAgICAgaWYgKCFzZWxmLnByb3RvY29sKSB7XG4gICAgICAgICAgICBzZWxmLnByb3RvY29sID0gYmFzZVVyaS5wcm90b2NvbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFzZWxmLnVzZXJJbmZvKSB7XG4gICAgICAgICAgICBzZWxmLnVzZXJJbmZvID0gYmFzZVVyaS51c2VySW5mbztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFzZWxmLnBvcnQgJiYgc2VsZi5ob3N0ID09PSAnbWNlX2hvc3QnKSB7XG4gICAgICAgICAgICBzZWxmLnBvcnQgPSBiYXNlVXJpLnBvcnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghc2VsZi5ob3N0IHx8IHNlbGYuaG9zdCA9PT0gJ21jZV9ob3N0Jykge1xuICAgICAgICAgICAgc2VsZi5ob3N0ID0gYmFzZVVyaS5ob3N0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLnNvdXJjZSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Byb3RvY29sUmVsYXRpdmUpIHtcbiAgICAgICAgICBzZWxmLnByb3RvY29sID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YXRpYyBwYXJzZURhdGFVcmkodXJpKSB7XG4gICAgICAgIGxldCB0eXBlO1xuICAgICAgICBjb25zdCB1cmlDb21wb25lbnRzID0gZGVjb2RlVVJJQ29tcG9uZW50KHVyaSkuc3BsaXQoJywnKTtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IC9kYXRhOihbXjtdKykvLmV4ZWModXJpQ29tcG9uZW50c1swXSk7XG4gICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgdHlwZSA9IG1hdGNoZXNbMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIGRhdGE6IHVyaUNvbXBvbmVudHNbMV1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHN0YXRpYyBpc0RvbVNhZmUodXJpLCBjb250ZXh0LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYWxsb3dfc2NyaXB0X3VybHMpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBkZWNvZGVkVXJpID0gRW50aXRpZXMuZGVjb2RlKHVyaSkucmVwbGFjZSgvW1xcc1xcdTAwMDAtXFx1MDAxRl0rL2csICcnKTtcbiAgICAgICAgICByZXR1cm4gIWlzSW52YWxpZFVyaShvcHRpb25zLCBkZWNvZGVkVXJpLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhdGljIGdldERvY3VtZW50QmFzZVVybChsb2MpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgYmFzZVVybDtcbiAgICAgICAgaWYgKGxvYy5wcm90b2NvbC5pbmRleE9mKCdodHRwJykgIT09IDAgJiYgbG9jLnByb3RvY29sICE9PSAnZmlsZTonKSB7XG4gICAgICAgICAgYmFzZVVybCA9IChfYSA9IGxvYy5ocmVmKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBiYXNlVXJsID0gbG9jLnByb3RvY29sICsgJy8vJyArIGxvYy5ob3N0ICsgbG9jLnBhdGhuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmICgvXlteOl0rOlxcL1xcL1xcLz9bXlxcL10rXFwvLy50ZXN0KGJhc2VVcmwpKSB7XG4gICAgICAgICAgYmFzZVVybCA9IGJhc2VVcmwucmVwbGFjZSgvW1xcPyNdLiokLywgJycpLnJlcGxhY2UoL1tcXC9cXFxcXVteXFwvXSskLywgJycpO1xuICAgICAgICAgIGlmICghL1tcXC9cXFxcXSQvLnRlc3QoYmFzZVVybCkpIHtcbiAgICAgICAgICAgIGJhc2VVcmwgKz0gJy8nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZVVybDtcbiAgICAgIH1cbiAgICAgIHNldFBhdGgocGF0aCkge1xuICAgICAgICBjb25zdCBwYXRoTWF0Y2ggPSAvXiguKj8pXFwvPyhcXHcrKT8kLy5leGVjKHBhdGgpO1xuICAgICAgICBpZiAocGF0aE1hdGNoKSB7XG4gICAgICAgICAgdGhpcy5wYXRoID0gcGF0aE1hdGNoWzBdO1xuICAgICAgICAgIHRoaXMuZGlyZWN0b3J5ID0gcGF0aE1hdGNoWzFdO1xuICAgICAgICAgIHRoaXMuZmlsZSA9IHBhdGhNYXRjaFsyXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNvdXJjZSA9ICcnO1xuICAgICAgICB0aGlzLmdldFVSSSgpO1xuICAgICAgfVxuICAgICAgdG9SZWxhdGl2ZSh1cmkpIHtcbiAgICAgICAgaWYgKHVyaSA9PT0gJy4vJykge1xuICAgICAgICAgIHJldHVybiB1cmk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVsYXRpdmVVcmkgPSBuZXcgVVJJKHVyaSwgeyBiYXNlX3VyaTogdGhpcyB9KTtcbiAgICAgICAgaWYgKHJlbGF0aXZlVXJpLmhvc3QgIT09ICdtY2VfaG9zdCcgJiYgdGhpcy5ob3N0ICE9PSByZWxhdGl2ZVVyaS5ob3N0ICYmIHJlbGF0aXZlVXJpLmhvc3QgfHwgdGhpcy5wb3J0ICE9PSByZWxhdGl2ZVVyaS5wb3J0IHx8IHRoaXMucHJvdG9jb2wgIT09IHJlbGF0aXZlVXJpLnByb3RvY29sICYmIHJlbGF0aXZlVXJpLnByb3RvY29sICE9PSAnJykge1xuICAgICAgICAgIHJldHVybiByZWxhdGl2ZVVyaS5nZXRVUkkoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0dSA9IHRoaXMuZ2V0VVJJKCksIHV1ID0gcmVsYXRpdmVVcmkuZ2V0VVJJKCk7XG4gICAgICAgIGlmICh0dSA9PT0gdXUgfHwgdHUuY2hhckF0KHR1Lmxlbmd0aCAtIDEpID09PSAnLycgJiYgdHUuc3Vic3RyKDAsIHR1Lmxlbmd0aCAtIDEpID09PSB1dSkge1xuICAgICAgICAgIHJldHVybiB0dTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3V0cHV0ID0gdGhpcy50b1JlbFBhdGgodGhpcy5wYXRoLCByZWxhdGl2ZVVyaS5wYXRoKTtcbiAgICAgICAgaWYgKHJlbGF0aXZlVXJpLnF1ZXJ5KSB7XG4gICAgICAgICAgb3V0cHV0ICs9ICc/JyArIHJlbGF0aXZlVXJpLnF1ZXJ5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWxhdGl2ZVVyaS5hbmNob3IpIHtcbiAgICAgICAgICBvdXRwdXQgKz0gJyMnICsgcmVsYXRpdmVVcmkuYW5jaG9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICB9XG4gICAgICB0b0Fic29sdXRlKHVyaSwgbm9Ib3N0KSB7XG4gICAgICAgIGNvbnN0IGFic29sdXRlVXJpID0gbmV3IFVSSSh1cmksIHsgYmFzZV91cmk6IHRoaXMgfSk7XG4gICAgICAgIHJldHVybiBhYnNvbHV0ZVVyaS5nZXRVUkkobm9Ib3N0ICYmIHRoaXMuaXNTYW1lT3JpZ2luKGFic29sdXRlVXJpKSk7XG4gICAgICB9XG4gICAgICBpc1NhbWVPcmlnaW4odXJpKSB7XG4gICAgICAgIGlmICh0aGlzLmhvc3QgPT0gdXJpLmhvc3QgJiYgdGhpcy5wcm90b2NvbCA9PSB1cmkucHJvdG9jb2wpIHtcbiAgICAgICAgICBpZiAodGhpcy5wb3J0ID09IHVyaS5wb3J0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZGVmYXVsdFBvcnQgPSB0aGlzLnByb3RvY29sID8gREVGQVVMVF9QT1JUU1t0aGlzLnByb3RvY29sXSA6IG51bGw7XG4gICAgICAgICAgaWYgKGRlZmF1bHRQb3J0ICYmICh0aGlzLnBvcnQgfHwgZGVmYXVsdFBvcnQpID09ICh1cmkucG9ydCB8fCBkZWZhdWx0UG9ydCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0b1JlbFBhdGgoYmFzZSwgcGF0aCkge1xuICAgICAgICBsZXQgYnJlYWtQb2ludCA9IDAsIG91dCA9ICcnLCBpLCBsO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkQmFzZSA9IGJhc2Uuc3Vic3RyaW5nKDAsIGJhc2UubGFzdEluZGV4T2YoJy8nKSkuc3BsaXQoJy8nKTtcbiAgICAgICAgY29uc3QgaXRlbXMgPSBwYXRoLnNwbGl0KCcvJyk7XG4gICAgICAgIGlmIChub3JtYWxpemVkQmFzZS5sZW5ndGggPj0gaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yIChpID0gMCwgbCA9IG5vcm1hbGl6ZWRCYXNlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPj0gaXRlbXMubGVuZ3RoIHx8IG5vcm1hbGl6ZWRCYXNlW2ldICE9PSBpdGVtc1tpXSkge1xuICAgICAgICAgICAgICBicmVha1BvaW50ID0gaSArIDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9ybWFsaXplZEJhc2UubGVuZ3RoIDwgaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yIChpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPj0gbm9ybWFsaXplZEJhc2UubGVuZ3RoIHx8IG5vcm1hbGl6ZWRCYXNlW2ldICE9PSBpdGVtc1tpXSkge1xuICAgICAgICAgICAgICBicmVha1BvaW50ID0gaSArIDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYnJlYWtQb2ludCA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBub3JtYWxpemVkQmFzZS5sZW5ndGggLSAoYnJlYWtQb2ludCAtIDEpOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgb3V0ICs9ICcuLi8nO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IGJyZWFrUG9pbnQgLSAxLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGkgIT09IGJyZWFrUG9pbnQgLSAxKSB7XG4gICAgICAgICAgICBvdXQgKz0gJy8nICsgaXRlbXNbaV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dCArPSBpdGVtc1tpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgIH1cbiAgICAgIHRvQWJzUGF0aChiYXNlLCBwYXRoKSB7XG4gICAgICAgIGxldCBuYiA9IDA7XG4gICAgICAgIGNvbnN0IHRyID0gL1xcLyQvLnRlc3QocGF0aCkgPyAnLycgOiAnJztcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZEJhc2UgPSBiYXNlLnNwbGl0KCcvJyk7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRQYXRoID0gcGF0aC5zcGxpdCgnLycpO1xuICAgICAgICBjb25zdCBiYXNlUGFydHMgPSBbXTtcbiAgICAgICAgZWFjaCQ0KG5vcm1hbGl6ZWRCYXNlLCBrID0+IHtcbiAgICAgICAgICBpZiAoaykge1xuICAgICAgICAgICAgYmFzZVBhcnRzLnB1c2goayk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcGF0aFBhcnRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSBub3JtYWxpemVkUGF0aC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChub3JtYWxpemVkUGF0aFtpXS5sZW5ndGggPT09IDAgfHwgbm9ybWFsaXplZFBhdGhbaV0gPT09ICcuJykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChub3JtYWxpemVkUGF0aFtpXSA9PT0gJy4uJykge1xuICAgICAgICAgICAgbmIrKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobmIgPiAwKSB7XG4gICAgICAgICAgICBuYi0tO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhdGhQYXJ0cy5wdXNoKG5vcm1hbGl6ZWRQYXRoW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpID0gYmFzZVBhcnRzLmxlbmd0aCAtIG5iO1xuICAgICAgICBsZXQgb3V0UGF0aDtcbiAgICAgICAgaWYgKGkgPD0gMCkge1xuICAgICAgICAgIG91dFBhdGggPSByZXZlcnNlKHBhdGhQYXJ0cykuam9pbignLycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dFBhdGggPSBiYXNlUGFydHMuc2xpY2UoMCwgaSkuam9pbignLycpICsgJy8nICsgcmV2ZXJzZShwYXRoUGFydHMpLmpvaW4oJy8nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3V0UGF0aC5pbmRleE9mKCcvJykgIT09IDApIHtcbiAgICAgICAgICBvdXRQYXRoID0gJy8nICsgb3V0UGF0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHIgJiYgb3V0UGF0aC5sYXN0SW5kZXhPZignLycpICE9PSBvdXRQYXRoLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBvdXRQYXRoICs9IHRyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRQYXRoO1xuICAgICAgfVxuICAgICAgZ2V0VVJJKG5vUHJvdG9Ib3N0ID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHM7XG4gICAgICAgIGlmICghdGhpcy5zb3VyY2UgfHwgbm9Qcm90b0hvc3QpIHtcbiAgICAgICAgICBzID0gJyc7XG4gICAgICAgICAgaWYgKCFub1Byb3RvSG9zdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvdG9jb2wpIHtcbiAgICAgICAgICAgICAgcyArPSB0aGlzLnByb3RvY29sICsgJzovLyc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzICs9ICcvLyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy51c2VySW5mbykge1xuICAgICAgICAgICAgICBzICs9IHRoaXMudXNlckluZm8gKyAnQCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5ob3N0KSB7XG4gICAgICAgICAgICAgIHMgKz0gdGhpcy5ob3N0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgICAgICAgICBzICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMucGF0aCkge1xuICAgICAgICAgICAgcyArPSB0aGlzLnBhdGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLnF1ZXJ5KSB7XG4gICAgICAgICAgICBzICs9ICc/JyArIHRoaXMucXVlcnk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLmFuY2hvcikge1xuICAgICAgICAgICAgcyArPSAnIycgKyB0aGlzLmFuY2hvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zb3VyY2UgPSBzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBmaWx0ZXJlZFVybEF0dHJzID0gVG9vbHMubWFrZU1hcCgnc3JjLGhyZWYsZGF0YSxiYWNrZ3JvdW5kLGFjdGlvbixmb3JtYWN0aW9uLHBvc3Rlcix4bGluazpocmVmJyk7XG4gICAgY29uc3QgaW50ZXJuYWxFbGVtZW50QXR0ciA9ICdkYXRhLW1jZS10eXBlJztcbiAgICBsZXQgdWlkID0gMDtcbiAgICBjb25zdCBwcm9jZXNzTm9kZSA9IChub2RlLCBzZXR0aW5ncywgc2NoZW1hLCBldnQpID0+IHtcbiAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgIGNvbnN0IHZhbGlkYXRlID0gc2V0dGluZ3MudmFsaWRhdGU7XG4gICAgICBjb25zdCBzcGVjaWFsRWxlbWVudHMgPSBzY2hlbWEuZ2V0U3BlY2lhbEVsZW1lbnRzKCk7XG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gQ09NTUVOVCAmJiAhc2V0dGluZ3MuYWxsb3dfY29uZGl0aW9uYWxfY29tbWVudHMgJiYgL15cXFtpZi9pLnRlc3QoKF9hID0gbm9kZS5ub2RlVmFsdWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKSkge1xuICAgICAgICBub2RlLm5vZGVWYWx1ZSA9ICcgJyArIG5vZGUubm9kZVZhbHVlO1xuICAgICAgfVxuICAgICAgY29uc3QgbGNUYWdOYW1lID0gKF9iID0gZXZ0ID09PSBudWxsIHx8IGV2dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXZ0LnRhZ05hbWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSBFTEVNRU5UIHx8IGxjVGFnTmFtZSA9PT0gJ2JvZHknKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBTdWdhckVsZW1lbnQuZnJvbURvbShub2RlKTtcbiAgICAgIGNvbnN0IGlzSW50ZXJuYWxFbGVtZW50ID0gaGFzJDEoZWxlbWVudCwgaW50ZXJuYWxFbGVtZW50QXR0cik7XG4gICAgICBjb25zdCBib2d1cyA9IGdldCQ5KGVsZW1lbnQsICdkYXRhLW1jZS1ib2d1cycpO1xuICAgICAgaWYgKCFpc0ludGVybmFsRWxlbWVudCAmJiBpc1N0cmluZyhib2d1cykpIHtcbiAgICAgICAgaWYgKGJvZ3VzID09PSAnYWxsJykge1xuICAgICAgICAgIHJlbW92ZSQ2KGVsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVud3JhcChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBydWxlID0gc2NoZW1hLmdldEVsZW1lbnRSdWxlKGxjVGFnTmFtZSk7XG4gICAgICBpZiAodmFsaWRhdGUgJiYgIXJ1bGUpIHtcbiAgICAgICAgaWYgKGhhcyQyKHNwZWNpYWxFbGVtZW50cywgbGNUYWdOYW1lKSkge1xuICAgICAgICAgIHJlbW92ZSQ2KGVsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVud3JhcChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNOb25OdWxsYWJsZShldnQpKSB7XG4gICAgICAgICAgZXZ0LmFsbG93ZWRUYWdzW2xjVGFnTmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodmFsaWRhdGUgJiYgcnVsZSAmJiAhaXNJbnRlcm5hbEVsZW1lbnQpIHtcbiAgICAgICAgZWFjaCRlKChfYyA9IHJ1bGUuYXR0cmlidXRlc0ZvcmNlZCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogW10sIGF0dHIgPT4ge1xuICAgICAgICAgIHNldCQzKGVsZW1lbnQsIGF0dHIubmFtZSwgYXR0ci52YWx1ZSA9PT0gJ3skdWlkfScgPyBgbWNlXyR7IHVpZCsrIH1gIDogYXR0ci52YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBlYWNoJGUoKF9kID0gcnVsZS5hdHRyaWJ1dGVzRGVmYXVsdCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogW10sIGF0dHIgPT4ge1xuICAgICAgICAgIGlmICghaGFzJDEoZWxlbWVudCwgYXR0ci5uYW1lKSkge1xuICAgICAgICAgICAgc2V0JDMoZWxlbWVudCwgYXR0ci5uYW1lLCBhdHRyLnZhbHVlID09PSAneyR1aWR9JyA/IGBtY2VfJHsgdWlkKysgfWAgOiBhdHRyLnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocnVsZS5hdHRyaWJ1dGVzUmVxdWlyZWQgJiYgIWV4aXN0cyhydWxlLmF0dHJpYnV0ZXNSZXF1aXJlZCwgYXR0ciA9PiBoYXMkMShlbGVtZW50LCBhdHRyKSkpIHtcbiAgICAgICAgICB1bndyYXAoZWxlbWVudCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydWxlLnJlbW92ZUVtcHR5QXR0cnMgJiYgaGFzTm9uZShlbGVtZW50KSkge1xuICAgICAgICAgIHVud3JhcChlbGVtZW50KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bGUub3V0cHV0TmFtZSAmJiBydWxlLm91dHB1dE5hbWUgIT09IGxjVGFnTmFtZSkge1xuICAgICAgICAgIG11dGF0ZShlbGVtZW50LCBydWxlLm91dHB1dE5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzaG91bGRLZWVwQXR0cmlidXRlID0gKHNldHRpbmdzLCBzY2hlbWEsIHRhZ05hbWUsIGF0dHJOYW1lLCBhdHRyVmFsdWUpID0+ICEoYXR0ck5hbWUgaW4gZmlsdGVyZWRVcmxBdHRycyAmJiBpc0ludmFsaWRVcmkoc2V0dGluZ3MsIGF0dHJWYWx1ZSwgdGFnTmFtZSkpICYmICghc2V0dGluZ3MudmFsaWRhdGUgfHwgc2NoZW1hLmlzVmFsaWQodGFnTmFtZSwgYXR0ck5hbWUpIHx8IHN0YXJ0c1dpdGgoYXR0ck5hbWUsICdkYXRhLScpIHx8IHN0YXJ0c1dpdGgoYXR0ck5hbWUsICdhcmlhLScpKTtcbiAgICBjb25zdCBpc1JlcXVpcmVkQXR0cmlidXRlT2ZJbnRlcm5hbEVsZW1lbnQgPSAoZWxlLCBhdHRyTmFtZSkgPT4gZWxlLmhhc0F0dHJpYnV0ZShpbnRlcm5hbEVsZW1lbnRBdHRyKSAmJiAoYXR0ck5hbWUgPT09ICdpZCcgfHwgYXR0ck5hbWUgPT09ICdjbGFzcycgfHwgYXR0ck5hbWUgPT09ICdzdHlsZScpO1xuICAgIGNvbnN0IGlzQm9vbGVhbkF0dHJpYnV0ZSA9IChhdHRyTmFtZSwgc2NoZW1hKSA9PiBhdHRyTmFtZSBpbiBzY2hlbWEuZ2V0Qm9vbEF0dHJzKCk7XG4gICAgY29uc3QgZmlsdGVyQXR0cmlidXRlcyA9IChlbGUsIHNldHRpbmdzLCBzY2hlbWEpID0+IHtcbiAgICAgIGNvbnN0IHthdHRyaWJ1dGVzfSA9IGVsZTtcbiAgICAgIGZvciAobGV0IGkgPSBhdHRyaWJ1dGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGF0dHIgPSBhdHRyaWJ1dGVzW2ldO1xuICAgICAgICBjb25zdCBhdHRyTmFtZSA9IGF0dHIubmFtZTtcbiAgICAgICAgY29uc3QgYXR0clZhbHVlID0gYXR0ci52YWx1ZTtcbiAgICAgICAgaWYgKCFzaG91bGRLZWVwQXR0cmlidXRlKHNldHRpbmdzLCBzY2hlbWEsIGVsZS50YWdOYW1lLnRvTG93ZXJDYXNlKCksIGF0dHJOYW1lLCBhdHRyVmFsdWUpICYmICFpc1JlcXVpcmVkQXR0cmlidXRlT2ZJbnRlcm5hbEVsZW1lbnQoZWxlLCBhdHRyTmFtZSkpIHtcbiAgICAgICAgICBlbGUucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Jvb2xlYW5BdHRyaWJ1dGUoYXR0ck5hbWUsIHNjaGVtYSkpIHtcbiAgICAgICAgICBlbGUuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyTmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNldHVwUHVyaWZ5ID0gKHNldHRpbmdzLCBzY2hlbWEpID0+IHtcbiAgICAgIGNvbnN0IHB1cmlmeSQxID0gcHVyaWZ5KCk7XG4gICAgICBwdXJpZnkkMS5hZGRIb29rKCd1cG9uU2FuaXRpemVFbGVtZW50JywgKGVsZSwgZXZ0KSA9PiB7XG4gICAgICAgIHByb2Nlc3NOb2RlKGVsZSwgc2V0dGluZ3MsIHNjaGVtYSwgZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgcHVyaWZ5JDEuYWRkSG9vaygndXBvblNhbml0aXplQXR0cmlidXRlJywgKGVsZSwgZXZ0KSA9PiB7XG4gICAgICAgIGNvbnN0IHRhZ05hbWUgPSBlbGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCB7YXR0ck5hbWUsIGF0dHJWYWx1ZX0gPSBldnQ7XG4gICAgICAgIGV2dC5rZWVwQXR0ciA9IHNob3VsZEtlZXBBdHRyaWJ1dGUoc2V0dGluZ3MsIHNjaGVtYSwgdGFnTmFtZSwgYXR0ck5hbWUsIGF0dHJWYWx1ZSk7XG4gICAgICAgIGlmIChldnQua2VlcEF0dHIpIHtcbiAgICAgICAgICBldnQuYWxsb3dlZEF0dHJpYnV0ZXNbYXR0ck5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoaXNCb29sZWFuQXR0cmlidXRlKGF0dHJOYW1lLCBzY2hlbWEpKSB7XG4gICAgICAgICAgICBldnQuYXR0clZhbHVlID0gYXR0ck5hbWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzZXR0aW5ncy5hbGxvd19zdmdfZGF0YV91cmxzICYmIHN0YXJ0c1dpdGgoYXR0clZhbHVlLCAnZGF0YTppbWFnZS9zdmcreG1sJykpIHtcbiAgICAgICAgICAgIGV2dC5mb3JjZUtlZXBBdHRyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXNSZXF1aXJlZEF0dHJpYnV0ZU9mSW50ZXJuYWxFbGVtZW50KGVsZSwgYXR0ck5hbWUpKSB7XG4gICAgICAgICAgZXZ0LmZvcmNlS2VlcEF0dHIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwdXJpZnkkMTtcbiAgICB9O1xuICAgIGNvbnN0IGdldFB1cmlmeUNvbmZpZyA9IChzZXR0aW5ncywgbWltZVR5cGUpID0+IHtcbiAgICAgIGNvbnN0IGJhc2VQdXJpZnlDb25maWcgPSB7XG4gICAgICAgIElOX1BMQUNFOiB0cnVlLFxuICAgICAgICBBTExPV19VTktOT1dOX1BST1RPQ09MUzogdHJ1ZSxcbiAgICAgICAgQUxMT1dFRF9UQUdTOiBbXG4gICAgICAgICAgJyNjb21tZW50JyxcbiAgICAgICAgICAnI2NkYXRhLXNlY3Rpb24nLFxuICAgICAgICAgICdib2R5J1xuICAgICAgICBdLFxuICAgICAgICBBTExPV0VEX0FUVFI6IFtdXG4gICAgICB9O1xuICAgICAgY29uc3QgY29uZmlnID0geyAuLi5iYXNlUHVyaWZ5Q29uZmlnIH07XG4gICAgICBjb25maWcuUEFSU0VSX01FRElBX1RZUEUgPSBtaW1lVHlwZTtcbiAgICAgIGlmIChzZXR0aW5ncy5hbGxvd19zY3JpcHRfdXJscykge1xuICAgICAgICBjb25maWcuQUxMT1dFRF9VUklfUkVHRVhQID0gLy4qLztcbiAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MuYWxsb3dfaHRtbF9kYXRhX3VybHMpIHtcbiAgICAgICAgY29uZmlnLkFMTE9XRURfVVJJX1JFR0VYUCA9IC9eKD8hKFxcdytzY3JpcHR8bWh0bWwpOikvaTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfTtcbiAgICBjb25zdCBnZXRTYW5pdGl6ZXIgPSAoc2V0dGluZ3MsIHNjaGVtYSkgPT4ge1xuICAgICAgaWYgKHNldHRpbmdzLnNhbml0aXplKSB7XG4gICAgICAgIGNvbnN0IHB1cmlmeSA9IHNldHVwUHVyaWZ5KHNldHRpbmdzLCBzY2hlbWEpO1xuICAgICAgICByZXR1cm4gKGJvZHksIG1pbWVUeXBlKSA9PiB7XG4gICAgICAgICAgcHVyaWZ5LnNhbml0aXplKGJvZHksIGdldFB1cmlmeUNvbmZpZyhzZXR0aW5ncywgbWltZVR5cGUpKTtcbiAgICAgICAgICBwdXJpZnkucmVtb3ZlZCA9IFtdO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIChib2R5LCBfKSA9PiB7XG4gICAgICAgICAgY29uc3Qgbm9kZUl0ZXJhdG9yID0gZG9jdW1lbnQuY3JlYXRlTm9kZUl0ZXJhdG9yKGJvZHksIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5UIHwgTm9kZUZpbHRlci5TSE9XX0NPTU1FTlQgfCBOb2RlRmlsdGVyLlNIT1dfVEVYVCk7XG4gICAgICAgICAgbGV0IG5vZGU7XG4gICAgICAgICAgd2hpbGUgKG5vZGUgPSBub2RlSXRlcmF0b3IubmV4dE5vZGUoKSkge1xuICAgICAgICAgICAgcHJvY2Vzc05vZGUobm9kZSwgc2V0dGluZ3MsIHNjaGVtYSk7XG4gICAgICAgICAgICBpZiAoaXNFbGVtZW50JDYobm9kZSkpIHtcbiAgICAgICAgICAgICAgZmlsdGVyQXR0cmlidXRlcyhub2RlLCBzZXR0aW5ncywgc2NoZW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IG1ha2VNYXAgPSBUb29scy5tYWtlTWFwLCBleHRlbmQkMSA9IFRvb2xzLmV4dGVuZDtcbiAgICBjb25zdCB0cmFuc2ZlckNoaWxkcmVuID0gKHBhcmVudCwgbmF0aXZlUGFyZW50LCBzcGVjaWFsRWxlbWVudHMpID0+IHtcbiAgICAgIGNvbnN0IHBhcmVudE5hbWUgPSBwYXJlbnQubmFtZTtcbiAgICAgIGNvbnN0IGlzU3BlY2lhbCA9IHBhcmVudE5hbWUgaW4gc3BlY2lhbEVsZW1lbnRzICYmIHBhcmVudE5hbWUgIT09ICd0aXRsZScgJiYgcGFyZW50TmFtZSAhPT0gJ3RleHRhcmVhJztcbiAgICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBuYXRpdmVQYXJlbnQuY2hpbGROb2RlcztcbiAgICAgIGZvciAobGV0IG5pID0gMCwgbmwgPSBjaGlsZE5vZGVzLmxlbmd0aDsgbmkgPCBubDsgbmkrKykge1xuICAgICAgICBjb25zdCBuYXRpdmVDaGlsZCA9IGNoaWxkTm9kZXNbbmldO1xuICAgICAgICBjb25zdCBjaGlsZCA9IG5ldyBBc3ROb2RlKG5hdGl2ZUNoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksIG5hdGl2ZUNoaWxkLm5vZGVUeXBlKTtcbiAgICAgICAgaWYgKGlzRWxlbWVudCQ2KG5hdGl2ZUNoaWxkKSkge1xuICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBuYXRpdmVDaGlsZC5hdHRyaWJ1dGVzO1xuICAgICAgICAgIGZvciAobGV0IGFpID0gMCwgYWwgPSBhdHRyaWJ1dGVzLmxlbmd0aDsgYWkgPCBhbDsgYWkrKykge1xuICAgICAgICAgICAgY29uc3QgYXR0ciA9IGF0dHJpYnV0ZXNbYWldO1xuICAgICAgICAgICAgY2hpbGQuYXR0cihhdHRyLm5hbWUsIGF0dHIudmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpc1RleHQkYShuYXRpdmVDaGlsZCkpIHtcbiAgICAgICAgICBjaGlsZC52YWx1ZSA9IG5hdGl2ZUNoaWxkLmRhdGE7XG4gICAgICAgICAgaWYgKGlzU3BlY2lhbCkge1xuICAgICAgICAgICAgY2hpbGQucmF3ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXNDb21tZW50KG5hdGl2ZUNoaWxkKSB8fCBpc0NEYXRhKG5hdGl2ZUNoaWxkKSB8fCBpc1BpKG5hdGl2ZUNoaWxkKSkge1xuICAgICAgICAgIGNoaWxkLnZhbHVlID0gbmF0aXZlQ2hpbGQuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc2ZlckNoaWxkcmVuKGNoaWxkLCBuYXRpdmVDaGlsZCwgc3BlY2lhbEVsZW1lbnRzKTtcbiAgICAgICAgcGFyZW50LmFwcGVuZChjaGlsZCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB3YWxrVHJlZSA9IChyb290LCBwcmVwcm9jZXNzb3JzLCBwb3N0cHJvY2Vzc29ycykgPT4ge1xuICAgICAgY29uc3QgdHJhdmVyc2VPcmRlciA9IFtdO1xuICAgICAgZm9yIChsZXQgbm9kZSA9IHJvb3QsIGxhc3ROb2RlID0gbm9kZTsgbm9kZTsgbGFzdE5vZGUgPSBub2RlLCBub2RlID0gbm9kZS53YWxrKCkpIHtcbiAgICAgICAgY29uc3QgdGVtcE5vZGUgPSBub2RlO1xuICAgICAgICBlYWNoJGUocHJlcHJvY2Vzc29ycywgcHJlcHJvY2VzcyA9PiBwcmVwcm9jZXNzKHRlbXBOb2RlKSk7XG4gICAgICAgIGlmIChpc051bGxhYmxlKHRlbXBOb2RlLnBhcmVudCkgJiYgdGVtcE5vZGUgIT09IHJvb3QpIHtcbiAgICAgICAgICBub2RlID0gbGFzdE5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJhdmVyc2VPcmRlci5wdXNoKHRlbXBOb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IHRyYXZlcnNlT3JkZXIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRyYXZlcnNlT3JkZXJbaV07XG4gICAgICAgIGVhY2gkZShwb3N0cHJvY2Vzc29ycywgcG9zdHByb2Nlc3MgPT4gcG9zdHByb2Nlc3Mobm9kZSkpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgd2hpdGVzcGFjZUNsZWFuZXIgPSAocm9vdCwgc2NoZW1hLCBzZXR0aW5ncywgYXJncykgPT4ge1xuICAgICAgY29uc3QgdmFsaWRhdGUgPSBzZXR0aW5ncy52YWxpZGF0ZTtcbiAgICAgIGNvbnN0IG5vbkVtcHR5RWxlbWVudHMgPSBzY2hlbWEuZ2V0Tm9uRW1wdHlFbGVtZW50cygpO1xuICAgICAgY29uc3Qgd2hpdGVzcGFjZUVsZW1lbnRzID0gc2NoZW1hLmdldFdoaXRlc3BhY2VFbGVtZW50cygpO1xuICAgICAgY29uc3QgYmxvY2tFbGVtZW50cyA9IGV4dGVuZCQxKG1ha2VNYXAoJ3NjcmlwdCxzdHlsZSxoZWFkLGh0bWwsYm9keSx0aXRsZSxtZXRhLHBhcmFtJyksIHNjaGVtYS5nZXRCbG9ja0VsZW1lbnRzKCkpO1xuICAgICAgY29uc3QgdGV4dFJvb3RCbG9ja0VsZW1lbnRzID0gZ2V0VGV4dFJvb3RCbG9ja0VsZW1lbnRzKHNjaGVtYSk7XG4gICAgICBjb25zdCBhbGxXaGl0ZVNwYWNlUmVnRXhwID0gL1sgXFx0XFxyXFxuXSsvZztcbiAgICAgIGNvbnN0IHN0YXJ0V2hpdGVTcGFjZVJlZ0V4cCA9IC9eWyBcXHRcXHJcXG5dKy87XG4gICAgICBjb25zdCBlbmRXaGl0ZVNwYWNlUmVnRXhwID0gL1sgXFx0XFxyXFxuXSskLztcbiAgICAgIGNvbnN0IGhhc1doaXRlc3BhY2VQYXJlbnQgPSBub2RlID0+IHtcbiAgICAgICAgbGV0IHRlbXBOb2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgIHdoaWxlIChpc05vbk51bGxhYmxlKHRlbXBOb2RlKSkge1xuICAgICAgICAgIGlmICh0ZW1wTm9kZS5uYW1lIGluIHdoaXRlc3BhY2VFbGVtZW50cykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRlbXBOb2RlID0gdGVtcE5vZGUucGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgICAgY29uc3QgaXNUZXh0Um9vdEJsb2NrRW1wdHkgPSBub2RlID0+IHtcbiAgICAgICAgbGV0IHRlbXBOb2RlID0gbm9kZTtcbiAgICAgICAgd2hpbGUgKGlzTm9uTnVsbGFibGUodGVtcE5vZGUpKSB7XG4gICAgICAgICAgaWYgKHRlbXBOb2RlLm5hbWUgaW4gdGV4dFJvb3RCbG9ja0VsZW1lbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNFbXB0eShzY2hlbWEsIG5vbkVtcHR5RWxlbWVudHMsIHdoaXRlc3BhY2VFbGVtZW50cywgdGVtcE5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZW1wTm9kZSA9IHRlbXBOb2RlLnBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzQmxvY2sgPSBub2RlID0+IG5vZGUubmFtZSBpbiBibG9ja0VsZW1lbnRzICYmICFpc1RyYW5zcGFyZW50QXN0SW5saW5lKHNjaGVtYSwgbm9kZSk7XG4gICAgICBjb25zdCBpc0F0RWRnZU9mQmxvY2sgPSAobm9kZSwgc3RhcnQpID0+IHtcbiAgICAgICAgY29uc3QgbmVpZ2hib3VyID0gc3RhcnQgPyBub2RlLnByZXYgOiBub2RlLm5leHQ7XG4gICAgICAgIGlmIChpc05vbk51bGxhYmxlKG5laWdoYm91cikgfHwgaXNOdWxsYWJsZShub2RlLnBhcmVudCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzQmxvY2sobm9kZS5wYXJlbnQpICYmIChub2RlLnBhcmVudCAhPT0gcm9vdCB8fCBhcmdzLmlzUm9vdENvbnRlbnQgPT09IHRydWUpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHByZXByb2Nlc3MgPSBub2RlID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSAzKSB7XG4gICAgICAgICAgaWYgKCFoYXNXaGl0ZXNwYWNlUGFyZW50KG5vZGUpKSB7XG4gICAgICAgICAgICBsZXQgdGV4dCA9IChfYSA9IG5vZGUudmFsdWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xuICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZShhbGxXaGl0ZVNwYWNlUmVnRXhwLCAnICcpO1xuICAgICAgICAgICAgaWYgKGlzTGluZUJyZWFrTm9kZShub2RlLnByZXYsIGlzQmxvY2spIHx8IGlzQXRFZGdlT2ZCbG9jayhub2RlLCB0cnVlKSkge1xuICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHN0YXJ0V2hpdGVTcGFjZVJlZ0V4cCwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBub2RlLnZhbHVlID0gdGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBwb3N0cHJvY2VzcyA9IG5vZGUgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICAgICAgICBjb25zdCBlbGVtZW50UnVsZSA9IHNjaGVtYS5nZXRFbGVtZW50UnVsZShub2RlLm5hbWUpO1xuICAgICAgICAgIGlmICh2YWxpZGF0ZSAmJiBlbGVtZW50UnVsZSkge1xuICAgICAgICAgICAgY29uc3QgaXNOb2RlRW1wdHkgPSBpc0VtcHR5KHNjaGVtYSwgbm9uRW1wdHlFbGVtZW50cywgd2hpdGVzcGFjZUVsZW1lbnRzLCBub2RlKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50UnVsZS5wYWRkSW5FbXB0eUJsb2NrICYmIGlzTm9kZUVtcHR5ICYmIGlzVGV4dFJvb3RCbG9ja0VtcHR5KG5vZGUpKSB7XG4gICAgICAgICAgICAgIHBhZGRFbXB0eU5vZGUoYXJncywgaXNCbG9jaywgbm9kZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnRSdWxlLnJlbW92ZUVtcHR5ICYmIGlzTm9kZUVtcHR5KSB7XG4gICAgICAgICAgICAgIGlmIChpc0Jsb2NrKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlLnVud3JhcCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnRSdWxlLnBhZGRFbXB0eSAmJiAoaXNOb2RlRW1wdHkgfHwgaXNQYWRkZWRXaXRoTmJzcChub2RlKSkpIHtcbiAgICAgICAgICAgICAgcGFkZEVtcHR5Tm9kZShhcmdzLCBpc0Jsb2NrLCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAzKSB7XG4gICAgICAgICAgaWYgKCFoYXNXaGl0ZXNwYWNlUGFyZW50KG5vZGUpKSB7XG4gICAgICAgICAgICBsZXQgdGV4dCA9IChfYSA9IG5vZGUudmFsdWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xuICAgICAgICAgICAgaWYgKG5vZGUubmV4dCAmJiBpc0Jsb2NrKG5vZGUubmV4dCkgfHwgaXNBdEVkZ2VPZkJsb2NrKG5vZGUsIGZhbHNlKSkge1xuICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKGVuZFdoaXRlU3BhY2VSZWdFeHAsICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbm9kZS52YWx1ZSA9IHRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgcHJlcHJvY2VzcyxcbiAgICAgICAgcG9zdHByb2Nlc3NcbiAgICAgIF07XG4gICAgfTtcbiAgICBjb25zdCBnZXRSb290QmxvY2tOYW1lID0gKHNldHRpbmdzLCBhcmdzKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBuYW1lID0gKF9hID0gYXJncy5mb3JjZWRfcm9vdF9ibG9jaykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogc2V0dGluZ3MuZm9yY2VkX3Jvb3RfYmxvY2s7XG4gICAgICBpZiAobmFtZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfSBlbHNlIGlmIChuYW1lID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiAncCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IERvbVBhcnNlciA9IChzZXR0aW5ncyA9IHt9LCBzY2hlbWEgPSBTY2hlbWEoKSkgPT4ge1xuICAgICAgY29uc3Qgbm9kZUZpbHRlclJlZ2lzdHJ5ID0gY3JlYXRlJDgoKTtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZUZpbHRlclJlZ2lzdHJ5ID0gY3JlYXRlJDgoKTtcbiAgICAgIGNvbnN0IGRlZmF1bHRlZFNldHRpbmdzID0ge1xuICAgICAgICB2YWxpZGF0ZTogdHJ1ZSxcbiAgICAgICAgcm9vdF9uYW1lOiAnYm9keScsXG4gICAgICAgIHNhbml0aXplOiB0cnVlLFxuICAgICAgICAuLi5zZXR0aW5nc1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICAgIGNvbnN0IHNhbml0aXplID0gZ2V0U2FuaXRpemVyKGRlZmF1bHRlZFNldHRpbmdzLCBzY2hlbWEpO1xuICAgICAgY29uc3QgcGFyc2VBbmRTYW5pdGl6ZVdpdGhDb250ZXh0ID0gKGh0bWwsIHJvb3ROYW1lLCBmb3JtYXQgPSAnaHRtbCcpID0+IHtcbiAgICAgICAgY29uc3QgbWltZVR5cGUgPSBmb3JtYXQgPT09ICd4aHRtbCcgPyAnYXBwbGljYXRpb24veGh0bWwreG1sJyA6ICd0ZXh0L2h0bWwnO1xuICAgICAgICBjb25zdCBpc1NwZWNpYWxSb290ID0gaGFzJDIoc2NoZW1hLmdldFNwZWNpYWxFbGVtZW50cygpLCByb290TmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgY29uc3QgY29udGVudCA9IGlzU3BlY2lhbFJvb3QgPyBgPCR7IHJvb3ROYW1lIH0+JHsgaHRtbCB9PC8keyByb290TmFtZSB9PmAgOiBodG1sO1xuICAgICAgICBjb25zdCB3cmFwcGVkSHRtbCA9IGZvcm1hdCA9PT0gJ3hodG1sJyA/IGA8aHRtbCB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIj48aGVhZD48L2hlYWQ+PGJvZHk+JHsgY29udGVudCB9PC9ib2R5PjwvaHRtbD5gIDogYDxib2R5PiR7IGNvbnRlbnQgfTwvYm9keT5gO1xuICAgICAgICBjb25zdCBib2R5ID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyh3cmFwcGVkSHRtbCwgbWltZVR5cGUpLmJvZHk7XG4gICAgICAgIHNhbml0aXplKGJvZHksIG1pbWVUeXBlKTtcbiAgICAgICAgcmV0dXJuIGlzU3BlY2lhbFJvb3QgPyBib2R5LmZpcnN0Q2hpbGQgOiBib2R5O1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGFkZE5vZGVGaWx0ZXIgPSBub2RlRmlsdGVyUmVnaXN0cnkuYWRkRmlsdGVyO1xuICAgICAgY29uc3QgZ2V0Tm9kZUZpbHRlcnMgPSBub2RlRmlsdGVyUmVnaXN0cnkuZ2V0RmlsdGVycztcbiAgICAgIGNvbnN0IHJlbW92ZU5vZGVGaWx0ZXIgPSBub2RlRmlsdGVyUmVnaXN0cnkucmVtb3ZlRmlsdGVyO1xuICAgICAgY29uc3QgYWRkQXR0cmlidXRlRmlsdGVyID0gYXR0cmlidXRlRmlsdGVyUmVnaXN0cnkuYWRkRmlsdGVyO1xuICAgICAgY29uc3QgZ2V0QXR0cmlidXRlRmlsdGVycyA9IGF0dHJpYnV0ZUZpbHRlclJlZ2lzdHJ5LmdldEZpbHRlcnM7XG4gICAgICBjb25zdCByZW1vdmVBdHRyaWJ1dGVGaWx0ZXIgPSBhdHRyaWJ1dGVGaWx0ZXJSZWdpc3RyeS5yZW1vdmVGaWx0ZXI7XG4gICAgICBjb25zdCBmaW5kSW52YWxpZENoaWxkcmVuID0gKG5vZGUsIGludmFsaWRDaGlsZHJlbikgPT4ge1xuICAgICAgICBpZiAoaXNJbnZhbGlkKHNjaGVtYSwgbm9kZSkpIHtcbiAgICAgICAgICBpbnZhbGlkQ2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzV3JhcHBhYmxlTm9kZSA9IChibG9ja0VsZW1lbnRzLCBub2RlKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzSW50ZXJuYWxFbGVtZW50ID0gaXNTdHJpbmcobm9kZS5hdHRyKGludGVybmFsRWxlbWVudEF0dHIpKTtcbiAgICAgICAgY29uc3QgaXNJbmxpbmVFbGVtZW50ID0gbm9kZS50eXBlID09PSAxICYmICghaGFzJDIoYmxvY2tFbGVtZW50cywgbm9kZS5uYW1lKSAmJiAhaXNUcmFuc3BhcmVudEFzdEJsb2NrKHNjaGVtYSwgbm9kZSkpO1xuICAgICAgICByZXR1cm4gbm9kZS50eXBlID09PSAzIHx8IGlzSW5saW5lRWxlbWVudCAmJiAhaXNJbnRlcm5hbEVsZW1lbnQ7XG4gICAgICB9O1xuICAgICAgY29uc3QgYWRkUm9vdEJsb2NrcyA9IChyb290Tm9kZSwgcm9vdEJsb2NrTmFtZSkgPT4ge1xuICAgICAgICBjb25zdCBibG9ja0VsZW1lbnRzID0gZXh0ZW5kJDEobWFrZU1hcCgnc2NyaXB0LHN0eWxlLGhlYWQsaHRtbCxib2R5LHRpdGxlLG1ldGEscGFyYW0nKSwgc2NoZW1hLmdldEJsb2NrRWxlbWVudHMoKSk7XG4gICAgICAgIGNvbnN0IHN0YXJ0V2hpdGVTcGFjZVJlZ0V4cCA9IC9eWyBcXHRcXHJcXG5dKy87XG4gICAgICAgIGNvbnN0IGVuZFdoaXRlU3BhY2VSZWdFeHAgPSAvWyBcXHRcXHJcXG5dKyQvO1xuICAgICAgICBsZXQgbm9kZSA9IHJvb3ROb2RlLmZpcnN0Q2hpbGQsIHJvb3RCbG9ja05vZGUgPSBudWxsO1xuICAgICAgICBjb25zdCB0cmltID0gcm9vdEJsb2NrID0+IHtcbiAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgIGlmIChyb290QmxvY2spIHtcbiAgICAgICAgICAgIG5vZGUgPSByb290QmxvY2suZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGlmIChub2RlICYmIG5vZGUudHlwZSA9PT0gMykge1xuICAgICAgICAgICAgICBub2RlLnZhbHVlID0gKF9hID0gbm9kZS52YWx1ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlcGxhY2Uoc3RhcnRXaGl0ZVNwYWNlUmVnRXhwLCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gcm9vdEJsb2NrLmxhc3RDaGlsZDtcbiAgICAgICAgICAgIGlmIChub2RlICYmIG5vZGUudHlwZSA9PT0gMykge1xuICAgICAgICAgICAgICBub2RlLnZhbHVlID0gKF9iID0gbm9kZS52YWx1ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlcGxhY2UoZW5kV2hpdGVTcGFjZVJlZ0V4cCwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFzY2hlbWEuaXNWYWxpZENoaWxkKHJvb3ROb2RlLm5hbWUsIHJvb3RCbG9ja05hbWUudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICBjb25zdCBuZXh0ID0gbm9kZS5uZXh0O1xuICAgICAgICAgIGlmIChpc1dyYXBwYWJsZU5vZGUoYmxvY2tFbGVtZW50cywgbm9kZSkpIHtcbiAgICAgICAgICAgIGlmICghcm9vdEJsb2NrTm9kZSkge1xuICAgICAgICAgICAgICByb290QmxvY2tOb2RlID0gbmV3IEFzdE5vZGUocm9vdEJsb2NrTmFtZSwgMSk7XG4gICAgICAgICAgICAgIHJvb3RCbG9ja05vZGUuYXR0cihkZWZhdWx0ZWRTZXR0aW5ncy5mb3JjZWRfcm9vdF9ibG9ja19hdHRycyk7XG4gICAgICAgICAgICAgIHJvb3ROb2RlLmluc2VydChyb290QmxvY2tOb2RlLCBub2RlKTtcbiAgICAgICAgICAgICAgcm9vdEJsb2NrTm9kZS5hcHBlbmQobm9kZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByb290QmxvY2tOb2RlLmFwcGVuZChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJpbShyb290QmxvY2tOb2RlKTtcbiAgICAgICAgICAgIHJvb3RCbG9ja05vZGUgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICB0cmltKHJvb3RCbG9ja05vZGUpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHBhcnNlID0gKGh0bWwsIGFyZ3MgPSB7fSkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRlID0gZGVmYXVsdGVkU2V0dGluZ3MudmFsaWRhdGU7XG4gICAgICAgIGNvbnN0IHJvb3ROYW1lID0gKF9hID0gYXJncy5jb250ZXh0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkZWZhdWx0ZWRTZXR0aW5ncy5yb290X25hbWU7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBwYXJzZUFuZFNhbml0aXplV2l0aENvbnRleHQoaHRtbCwgcm9vdE5hbWUsIGFyZ3MuZm9ybWF0KTtcbiAgICAgICAgdXBkYXRlQ2hpbGRyZW4oc2NoZW1hLCBlbGVtZW50KTtcbiAgICAgICAgY29uc3Qgcm9vdE5vZGUgPSBuZXcgQXN0Tm9kZShyb290TmFtZSwgMTEpO1xuICAgICAgICB0cmFuc2ZlckNoaWxkcmVuKHJvb3ROb2RlLCBlbGVtZW50LCBzY2hlbWEuZ2V0U3BlY2lhbEVsZW1lbnRzKCkpO1xuICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9ICcnO1xuICAgICAgICBjb25zdCBbd2hpdGVzcGFjZVByZSwgd2hpdGVzcGFjZVBvc3RdID0gd2hpdGVzcGFjZUNsZWFuZXIocm9vdE5vZGUsIHNjaGVtYSwgZGVmYXVsdGVkU2V0dGluZ3MsIGFyZ3MpO1xuICAgICAgICBjb25zdCBpbnZhbGlkQ2hpbGRyZW4gPSBbXTtcbiAgICAgICAgY29uc3QgaW52YWxpZEZpbmRlciA9IHZhbGlkYXRlID8gbm9kZSA9PiBmaW5kSW52YWxpZENoaWxkcmVuKG5vZGUsIGludmFsaWRDaGlsZHJlbikgOiBub29wO1xuICAgICAgICBjb25zdCBtYXRjaGVzID0ge1xuICAgICAgICAgIG5vZGVzOiB7fSxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB7fVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBtYXRjaEZpbmRlciA9IG5vZGUgPT4gbWF0Y2hOb2RlJDEoZ2V0Tm9kZUZpbHRlcnMoKSwgZ2V0QXR0cmlidXRlRmlsdGVycygpLCBub2RlLCBtYXRjaGVzKTtcbiAgICAgICAgd2Fsa1RyZWUocm9vdE5vZGUsIFtcbiAgICAgICAgICB3aGl0ZXNwYWNlUHJlLFxuICAgICAgICAgIG1hdGNoRmluZGVyXG4gICAgICAgIF0sIFtcbiAgICAgICAgICB3aGl0ZXNwYWNlUG9zdCxcbiAgICAgICAgICBpbnZhbGlkRmluZGVyXG4gICAgICAgIF0pO1xuICAgICAgICBpbnZhbGlkQ2hpbGRyZW4ucmV2ZXJzZSgpO1xuICAgICAgICBpZiAodmFsaWRhdGUgJiYgaW52YWxpZENoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBpZiAoYXJncy5jb250ZXh0KSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIHBhc3M6IHRvcExldmVsQ2hpbGRyZW4sXG4gICAgICAgICAgICAgIGZhaWw6IG90aGVyQ2hpbGRyZW5cbiAgICAgICAgICAgIH0gPSBwYXJ0aXRpb24kMihpbnZhbGlkQ2hpbGRyZW4sIGNoaWxkID0+IGNoaWxkLnBhcmVudCA9PT0gcm9vdE5vZGUpO1xuICAgICAgICAgICAgY2xlYW5JbnZhbGlkTm9kZXMob3RoZXJDaGlsZHJlbiwgc2NoZW1hLCByb290Tm9kZSwgbWF0Y2hGaW5kZXIpO1xuICAgICAgICAgICAgYXJncy5pbnZhbGlkID0gdG9wTGV2ZWxDaGlsZHJlbi5sZW5ndGggPiAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbGVhbkludmFsaWROb2RlcyhpbnZhbGlkQ2hpbGRyZW4sIHNjaGVtYSwgcm9vdE5vZGUsIG1hdGNoRmluZGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm9vdEJsb2NrTmFtZSA9IGdldFJvb3RCbG9ja05hbWUoZGVmYXVsdGVkU2V0dGluZ3MsIGFyZ3MpO1xuICAgICAgICBpZiAocm9vdEJsb2NrTmFtZSAmJiAocm9vdE5vZGUubmFtZSA9PT0gJ2JvZHknIHx8IGFyZ3MuaXNSb290Q29udGVudCkpIHtcbiAgICAgICAgICBhZGRSb290QmxvY2tzKHJvb3ROb2RlLCByb290QmxvY2tOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFyZ3MuaW52YWxpZCkge1xuICAgICAgICAgIHJ1bkZpbHRlcnMobWF0Y2hlcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvb3ROb2RlO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGV4cG9ydHMgPSB7XG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgYWRkQXR0cmlidXRlRmlsdGVyLFxuICAgICAgICBnZXRBdHRyaWJ1dGVGaWx0ZXJzLFxuICAgICAgICByZW1vdmVBdHRyaWJ1dGVGaWx0ZXIsXG4gICAgICAgIGFkZE5vZGVGaWx0ZXIsXG4gICAgICAgIGdldE5vZGVGaWx0ZXJzLFxuICAgICAgICByZW1vdmVOb2RlRmlsdGVyLFxuICAgICAgICBwYXJzZVxuICAgICAgfTtcbiAgICAgIHJlZ2lzdGVyJDQoZXhwb3J0cywgZGVmYXVsdGVkU2V0dGluZ3MpO1xuICAgICAgcmVnaXN0ZXIkNShleHBvcnRzLCBkZWZhdWx0ZWRTZXR0aW5ncywgc2NoZW1hKTtcbiAgICAgIHJldHVybiBleHBvcnRzO1xuICAgIH07XG5cbiAgICBjb25zdCBzZXJpYWxpemVDb250ZW50ID0gY29udGVudCA9PiBpc1RyZWVOb2RlKGNvbnRlbnQpID8gSHRtbFNlcmlhbGl6ZXIoeyB2YWxpZGF0ZTogZmFsc2UgfSkuc2VyaWFsaXplKGNvbnRlbnQpIDogY29udGVudDtcbiAgICBjb25zdCB3aXRoU2VyaWFsaXplZENvbnRlbnQgPSAoY29udGVudCwgZmlyZUV2ZW50LCBzYW5pdGl6ZSkgPT4ge1xuICAgICAgY29uc3Qgc2VyaWFsaXplZENvbnRlbnQgPSBzZXJpYWxpemVDb250ZW50KGNvbnRlbnQpO1xuICAgICAgY29uc3QgZXZlbnRBcmdzID0gZmlyZUV2ZW50KHNlcmlhbGl6ZWRDb250ZW50KTtcbiAgICAgIGlmIChldmVudEFyZ3MuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50QXJncztcbiAgICAgIH0gZWxzZSBpZiAoaXNUcmVlTm9kZShjb250ZW50KSkge1xuICAgICAgICBpZiAoZXZlbnRBcmdzLmNvbnRlbnQgIT09IHNlcmlhbGl6ZWRDb250ZW50KSB7XG4gICAgICAgICAgY29uc3Qgcm9vdE5vZGUgPSBEb21QYXJzZXIoe1xuICAgICAgICAgICAgdmFsaWRhdGU6IGZhbHNlLFxuICAgICAgICAgICAgZm9yY2VkX3Jvb3RfYmxvY2s6IGZhbHNlLFxuICAgICAgICAgICAgc2FuaXRpemVcbiAgICAgICAgICB9KS5wYXJzZShldmVudEFyZ3MuY29udGVudCwgeyBjb250ZXh0OiBjb250ZW50Lm5hbWUgfSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmV2ZW50QXJncyxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHJvb3ROb2RlXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZXZlbnRBcmdzLFxuICAgICAgICAgICAgY29udGVudFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBldmVudEFyZ3M7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBwcmVQcm9jZXNzR2V0Q29udGVudCA9IChlZGl0b3IsIGFyZ3MpID0+IHtcbiAgICAgIGlmIChhcmdzLm5vX2V2ZW50cykge1xuICAgICAgICByZXR1cm4gUmVzdWx0LnZhbHVlKGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZXZlbnRBcmdzID0gZmlyZUJlZm9yZUdldENvbnRlbnQoZWRpdG9yLCBhcmdzKTtcbiAgICAgICAgaWYgKGV2ZW50QXJncy5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgIHJldHVybiBSZXN1bHQuZXJyb3IoZmlyZUdldENvbnRlbnQoZWRpdG9yLCB7XG4gICAgICAgICAgICBjb250ZW50OiAnJyxcbiAgICAgICAgICAgIC4uLmV2ZW50QXJnc1xuICAgICAgICAgIH0pLmNvbnRlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBSZXN1bHQudmFsdWUoZXZlbnRBcmdzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcG9zdFByb2Nlc3NHZXRDb250ZW50ID0gKGVkaXRvciwgY29udGVudCwgYXJncykgPT4ge1xuICAgICAgaWYgKGFyZ3Mubm9fZXZlbnRzKSB7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkRXZlbnRBcmdzID0gd2l0aFNlcmlhbGl6ZWRDb250ZW50KGNvbnRlbnQsIGNvbnRlbnQgPT4gZmlyZUdldENvbnRlbnQoZWRpdG9yLCB7XG4gICAgICAgICAgLi4uYXJncyxcbiAgICAgICAgICBjb250ZW50XG4gICAgICAgIH0pLCBzaG91bGRTYW5pdGl6ZVhzcyhlZGl0b3IpKTtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NlZEV2ZW50QXJncy5jb250ZW50O1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcHJlUHJvY2Vzc1NldENvbnRlbnQgPSAoZWRpdG9yLCBhcmdzKSA9PiB7XG4gICAgICBpZiAoYXJncy5ub19ldmVudHMpIHtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC52YWx1ZShhcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZEV2ZW50QXJncyA9IHdpdGhTZXJpYWxpemVkQ29udGVudChhcmdzLmNvbnRlbnQsIGNvbnRlbnQgPT4gZmlyZUJlZm9yZVNldENvbnRlbnQoZWRpdG9yLCB7XG4gICAgICAgICAgLi4uYXJncyxcbiAgICAgICAgICBjb250ZW50XG4gICAgICAgIH0pLCBzaG91bGRTYW5pdGl6ZVhzcyhlZGl0b3IpKTtcbiAgICAgICAgaWYgKHByb2Nlc3NlZEV2ZW50QXJncy5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgIGZpcmVTZXRDb250ZW50KGVkaXRvciwgcHJvY2Vzc2VkRXZlbnRBcmdzKTtcbiAgICAgICAgICByZXR1cm4gUmVzdWx0LmVycm9yKHVuZGVmaW5lZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFJlc3VsdC52YWx1ZShwcm9jZXNzZWRFdmVudEFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBwb3N0UHJvY2Vzc1NldENvbnRlbnQgPSAoZWRpdG9yLCBjb250ZW50LCBhcmdzKSA9PiB7XG4gICAgICBpZiAoIWFyZ3Mubm9fZXZlbnRzKSB7XG4gICAgICAgIGZpcmVTZXRDb250ZW50KGVkaXRvciwge1xuICAgICAgICAgIC4uLmFyZ3MsXG4gICAgICAgICAgY29udGVudFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgdGFibGVNb2RlbCA9IChlbGVtZW50LCB3aWR0aCwgcm93cykgPT4gKHtcbiAgICAgIGVsZW1lbnQsXG4gICAgICB3aWR0aCxcbiAgICAgIHJvd3NcbiAgICB9KTtcbiAgICBjb25zdCB0YWJsZVJvdyA9IChlbGVtZW50LCBjZWxscykgPT4gKHtcbiAgICAgIGVsZW1lbnQsXG4gICAgICBjZWxsc1xuICAgIH0pO1xuICAgIGNvbnN0IGNlbGxQb3NpdGlvbiA9ICh4LCB5KSA9PiAoe1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9KTtcbiAgICBjb25zdCBnZXRTcGFuID0gKHRkLCBrZXkpID0+IHtcbiAgICAgIHJldHVybiBnZXRPcHQodGQsIGtleSkuYmluZCh0b0ludCkuZ2V0T3IoMSk7XG4gICAgfTtcbiAgICBjb25zdCBmaWxsb3V0ID0gKHRhYmxlLCB4LCB5LCB0ciwgdGQpID0+IHtcbiAgICAgIGNvbnN0IHJvd3NwYW4gPSBnZXRTcGFuKHRkLCAncm93c3BhbicpO1xuICAgICAgY29uc3QgY29sc3BhbiA9IGdldFNwYW4odGQsICdjb2xzcGFuJyk7XG4gICAgICBjb25zdCByb3dzID0gdGFibGUucm93cztcbiAgICAgIGZvciAobGV0IHkyID0geTsgeTIgPCB5ICsgcm93c3BhbjsgeTIrKykge1xuICAgICAgICBpZiAoIXJvd3NbeTJdKSB7XG4gICAgICAgICAgcm93c1t5Ml0gPSB0YWJsZVJvdyhkZWVwJDEodHIpLCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgeDIgPSB4OyB4MiA8IHggKyBjb2xzcGFuOyB4MisrKSB7XG4gICAgICAgICAgY29uc3QgY2VsbHMgPSByb3dzW3kyXS5jZWxscztcbiAgICAgICAgICBjZWxsc1t4Ml0gPSB5MiA9PT0geSAmJiB4MiA9PT0geCA/IHRkIDogc2hhbGxvdyQxKHRkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgY2VsbEV4aXN0cyA9ICh0YWJsZSwgeCwgeSkgPT4ge1xuICAgICAgY29uc3Qgcm93cyA9IHRhYmxlLnJvd3M7XG4gICAgICBjb25zdCBjZWxscyA9IHJvd3NbeV0gPyByb3dzW3ldLmNlbGxzIDogW107XG4gICAgICByZXR1cm4gISFjZWxsc1t4XTtcbiAgICB9O1xuICAgIGNvbnN0IHNraXBDZWxsc1ggPSAodGFibGUsIHgsIHkpID0+IHtcbiAgICAgIHdoaWxlIChjZWxsRXhpc3RzKHRhYmxlLCB4LCB5KSkge1xuICAgICAgICB4Kys7XG4gICAgICB9XG4gICAgICByZXR1cm4geDtcbiAgICB9O1xuICAgIGNvbnN0IGdldFdpZHRoID0gcm93cyA9PiB7XG4gICAgICByZXR1cm4gZm9sZGwocm93cywgKGFjYywgcm93KSA9PiB7XG4gICAgICAgIHJldHVybiByb3cuY2VsbHMubGVuZ3RoID4gYWNjID8gcm93LmNlbGxzLmxlbmd0aCA6IGFjYztcbiAgICAgIH0sIDApO1xuICAgIH07XG4gICAgY29uc3QgZmluZEVsZW1lbnRQb3MgPSAodGFibGUsIGVsZW1lbnQpID0+IHtcbiAgICAgIGNvbnN0IHJvd3MgPSB0YWJsZS5yb3dzO1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCByb3dzLmxlbmd0aDsgeSsrKSB7XG4gICAgICAgIGNvbnN0IGNlbGxzID0gcm93c1t5XS5jZWxscztcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBjZWxscy5sZW5ndGg7IHgrKykge1xuICAgICAgICAgIGlmIChlcShjZWxsc1t4XSwgZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKGNlbGxQb3NpdGlvbih4LCB5KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgIH07XG4gICAgY29uc3QgZXh0cmFjdFJvd3MgPSAodGFibGUsIHN4LCBzeSwgZXgsIGV5KSA9PiB7XG4gICAgICBjb25zdCBuZXdSb3dzID0gW107XG4gICAgICBjb25zdCByb3dzID0gdGFibGUucm93cztcbiAgICAgIGZvciAobGV0IHkgPSBzeTsgeSA8PSBleTsgeSsrKSB7XG4gICAgICAgIGNvbnN0IGNlbGxzID0gcm93c1t5XS5jZWxscztcbiAgICAgICAgY29uc3Qgc2xpY2UgPSBzeCA8IGV4ID8gY2VsbHMuc2xpY2Uoc3gsIGV4ICsgMSkgOiBjZWxscy5zbGljZShleCwgc3ggKyAxKTtcbiAgICAgICAgbmV3Um93cy5wdXNoKHRhYmxlUm93KHJvd3NbeV0uZWxlbWVudCwgc2xpY2UpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdSb3dzO1xuICAgIH07XG4gICAgY29uc3Qgc3ViVGFibGUgPSAodGFibGUsIHN0YXJ0UG9zLCBlbmRQb3MpID0+IHtcbiAgICAgIGNvbnN0IHN4ID0gc3RhcnRQb3MueCwgc3kgPSBzdGFydFBvcy55O1xuICAgICAgY29uc3QgZXggPSBlbmRQb3MueCwgZXkgPSBlbmRQb3MueTtcbiAgICAgIGNvbnN0IG5ld1Jvd3MgPSBzeSA8IGV5ID8gZXh0cmFjdFJvd3ModGFibGUsIHN4LCBzeSwgZXgsIGV5KSA6IGV4dHJhY3RSb3dzKHRhYmxlLCBzeCwgZXksIGV4LCBzeSk7XG4gICAgICByZXR1cm4gdGFibGVNb2RlbCh0YWJsZS5lbGVtZW50LCBnZXRXaWR0aChuZXdSb3dzKSwgbmV3Um93cyk7XG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGVEb21UYWJsZSA9ICh0YWJsZSwgcm93cykgPT4ge1xuICAgICAgY29uc3QgdGFibGVFbGVtZW50ID0gc2hhbGxvdyQxKHRhYmxlLmVsZW1lbnQpO1xuICAgICAgY29uc3QgdGFibGVCb2R5ID0gU3VnYXJFbGVtZW50LmZyb21UYWcoJ3Rib2R5Jyk7XG4gICAgICBhcHBlbmQodGFibGVCb2R5LCByb3dzKTtcbiAgICAgIGFwcGVuZCQxKHRhYmxlRWxlbWVudCwgdGFibGVCb2R5KTtcbiAgICAgIHJldHVybiB0YWJsZUVsZW1lbnQ7XG4gICAgfTtcbiAgICBjb25zdCBtb2RlbFJvd3NUb0RvbVJvd3MgPSB0YWJsZSA9PiB7XG4gICAgICByZXR1cm4gbWFwJDModGFibGUucm93cywgcm93ID0+IHtcbiAgICAgICAgY29uc3QgY2VsbHMgPSBtYXAkMyhyb3cuY2VsbHMsIGNlbGwgPT4ge1xuICAgICAgICAgIGNvbnN0IHRkID0gZGVlcCQxKGNlbGwpO1xuICAgICAgICAgIHJlbW92ZSRiKHRkLCAnY29sc3BhbicpO1xuICAgICAgICAgIHJlbW92ZSRiKHRkLCAncm93c3BhbicpO1xuICAgICAgICAgIHJldHVybiB0ZDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHRyID0gc2hhbGxvdyQxKHJvdy5lbGVtZW50KTtcbiAgICAgICAgYXBwZW5kKHRyLCBjZWxscyk7XG4gICAgICAgIHJldHVybiB0cjtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgZnJvbURvbSA9IHRhYmxlRWxtID0+IHtcbiAgICAgIGNvbnN0IHRhYmxlID0gdGFibGVNb2RlbChzaGFsbG93JDEodGFibGVFbG0pLCAwLCBbXSk7XG4gICAgICBlYWNoJGUoZGVzY2VuZGFudHModGFibGVFbG0sICd0cicpLCAodHIsIHkpID0+IHtcbiAgICAgICAgZWFjaCRlKGRlc2NlbmRhbnRzKHRyLCAndGQsdGgnKSwgKHRkLCB4KSA9PiB7XG4gICAgICAgICAgZmlsbG91dCh0YWJsZSwgc2tpcENlbGxzWCh0YWJsZSwgeCwgeSksIHksIHRyLCB0ZCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGFibGVNb2RlbCh0YWJsZS5lbGVtZW50LCBnZXRXaWR0aCh0YWJsZS5yb3dzKSwgdGFibGUucm93cyk7XG4gICAgfTtcbiAgICBjb25zdCB0b0RvbSA9IHRhYmxlID0+IHtcbiAgICAgIHJldHVybiBjcmVhdGVEb21UYWJsZSh0YWJsZSwgbW9kZWxSb3dzVG9Eb21Sb3dzKHRhYmxlKSk7XG4gICAgfTtcbiAgICBjb25zdCBzdWJzZWN0aW9uID0gKHRhYmxlLCBzdGFydEVsZW1lbnQsIGVuZEVsZW1lbnQpID0+IHtcbiAgICAgIHJldHVybiBmaW5kRWxlbWVudFBvcyh0YWJsZSwgc3RhcnRFbGVtZW50KS5iaW5kKHN0YXJ0UG9zID0+IHtcbiAgICAgICAgcmV0dXJuIGZpbmRFbGVtZW50UG9zKHRhYmxlLCBlbmRFbGVtZW50KS5tYXAoZW5kUG9zID0+IHtcbiAgICAgICAgICByZXR1cm4gc3ViVGFibGUodGFibGUsIHN0YXJ0UG9zLCBlbmRQb3MpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBmaW5kUGFyZW50TGlzdENvbnRhaW5lciA9IHBhcmVudHMgPT4gZmluZCQyKHBhcmVudHMsIGVsbSA9PiBuYW1lKGVsbSkgPT09ICd1bCcgfHwgbmFtZShlbG0pID09PSAnb2wnKTtcbiAgICBjb25zdCBnZXRGdWxseVNlbGVjdGVkTGlzdFdyYXBwZXJzID0gKHBhcmVudHMsIHJuZykgPT4gZmluZCQyKHBhcmVudHMsIGVsbSA9PiBuYW1lKGVsbSkgPT09ICdsaScgJiYgaGFzQWxsQ29udGVudHNTZWxlY3RlZChlbG0sIHJuZykpLmZvbGQoY29uc3RhbnQoW10pLCBfbGkgPT4gZmluZFBhcmVudExpc3RDb250YWluZXIocGFyZW50cykubWFwKGxpc3RDb250ID0+IHtcbiAgICAgIGNvbnN0IGxpc3RFbG0gPSBTdWdhckVsZW1lbnQuZnJvbVRhZyhuYW1lKGxpc3RDb250KSk7XG4gICAgICBjb25zdCBsaXN0U3R5bGVzID0gZmlsdGVyJDQoZ2V0QWxsUmF3KGxpc3RDb250KSwgKF9zdHlsZSwgbmFtZSkgPT4gc3RhcnRzV2l0aChuYW1lLCAnbGlzdC1zdHlsZScpKTtcbiAgICAgIHNldEFsbChsaXN0RWxtLCBsaXN0U3R5bGVzKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIFN1Z2FyRWxlbWVudC5mcm9tVGFnKCdsaScpLFxuICAgICAgICBsaXN0RWxtXG4gICAgICBdO1xuICAgIH0pLmdldE9yKFtdKSk7XG4gICAgY29uc3Qgd3JhcCA9IChpbm5lckVsbSwgZWxtcykgPT4ge1xuICAgICAgY29uc3Qgd3JhcHBlZCA9IGZvbGRsKGVsbXMsIChhY2MsIGVsbSkgPT4ge1xuICAgICAgICBhcHBlbmQkMShlbG0sIGFjYyk7XG4gICAgICAgIHJldHVybiBlbG07XG4gICAgICB9LCBpbm5lckVsbSk7XG4gICAgICByZXR1cm4gZWxtcy5sZW5ndGggPiAwID8gZnJvbUVsZW1lbnRzKFt3cmFwcGVkXSkgOiB3cmFwcGVkO1xuICAgIH07XG4gICAgY29uc3QgZGlyZWN0TGlzdFdyYXBwZXJzID0gY29tbW9uQW5jaG9yQ29udGFpbmVyID0+IHtcbiAgICAgIGlmIChpc0xpc3RJdGVtJDEoY29tbW9uQW5jaG9yQ29udGFpbmVyKSkge1xuICAgICAgICByZXR1cm4gcGFyZW50KGNvbW1vbkFuY2hvckNvbnRhaW5lcikuZmlsdGVyKGlzTGlzdCkuZm9sZChjb25zdGFudChbXSksIGxpc3RFbG0gPT4gW1xuICAgICAgICAgIGNvbW1vbkFuY2hvckNvbnRhaW5lcixcbiAgICAgICAgICBsaXN0RWxtXG4gICAgICAgIF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGlzTGlzdChjb21tb25BbmNob3JDb250YWluZXIpID8gW2NvbW1vbkFuY2hvckNvbnRhaW5lcl0gOiBbXTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGdldFdyYXBFbGVtZW50cyA9IChyb290Tm9kZSwgcm5nKSA9PiB7XG4gICAgICBjb25zdCBjb21tb25BbmNob3JDb250YWluZXIgPSBTdWdhckVsZW1lbnQuZnJvbURvbShybmcuY29tbW9uQW5jZXN0b3JDb250YWluZXIpO1xuICAgICAgY29uc3QgcGFyZW50cyA9IHBhcmVudHNBbmRTZWxmKGNvbW1vbkFuY2hvckNvbnRhaW5lciwgcm9vdE5vZGUpO1xuICAgICAgY29uc3Qgd3JhcEVsZW1lbnRzID0gZmlsdGVyJDUocGFyZW50cywgaXNXcmFwRWxlbWVudCk7XG4gICAgICBjb25zdCBsaXN0V3JhcHBlcnMgPSBnZXRGdWxseVNlbGVjdGVkTGlzdFdyYXBwZXJzKHBhcmVudHMsIHJuZyk7XG4gICAgICBjb25zdCBhbGxXcmFwcGVycyA9IHdyYXBFbGVtZW50cy5jb25jYXQobGlzdFdyYXBwZXJzLmxlbmd0aCA/IGxpc3RXcmFwcGVycyA6IGRpcmVjdExpc3RXcmFwcGVycyhjb21tb25BbmNob3JDb250YWluZXIpKTtcbiAgICAgIHJldHVybiBtYXAkMyhhbGxXcmFwcGVycywgc2hhbGxvdyQxKTtcbiAgICB9O1xuICAgIGNvbnN0IGVtcHR5RnJhZ21lbnQgPSAoKSA9PiBmcm9tRWxlbWVudHMoW10pO1xuICAgIGNvbnN0IGdldEZyYWdtZW50RnJvbVJhbmdlID0gKHJvb3ROb2RlLCBybmcpID0+IHdyYXAoU3VnYXJFbGVtZW50LmZyb21Eb20ocm5nLmNsb25lQ29udGVudHMoKSksIGdldFdyYXBFbGVtZW50cyhyb290Tm9kZSwgcm5nKSk7XG4gICAgY29uc3QgZ2V0UGFyZW50VGFibGUgPSAocm9vdEVsbSwgY2VsbCkgPT4gYW5jZXN0b3IkMyhjZWxsLCAndGFibGUnLCBjdXJyeShlcSwgcm9vdEVsbSkpO1xuICAgIGNvbnN0IGdldFRhYmxlRnJhZ21lbnQgPSAocm9vdE5vZGUsIHNlbGVjdGVkVGFibGVDZWxscykgPT4gZ2V0UGFyZW50VGFibGUocm9vdE5vZGUsIHNlbGVjdGVkVGFibGVDZWxsc1swXSkuYmluZCh0YWJsZUVsbSA9PiB7XG4gICAgICBjb25zdCBmaXJzdENlbGwgPSBzZWxlY3RlZFRhYmxlQ2VsbHNbMF07XG4gICAgICBjb25zdCBsYXN0Q2VsbCA9IHNlbGVjdGVkVGFibGVDZWxsc1tzZWxlY3RlZFRhYmxlQ2VsbHMubGVuZ3RoIC0gMV07XG4gICAgICBjb25zdCBmdWxsVGFibGVNb2RlbCA9IGZyb21Eb20odGFibGVFbG0pO1xuICAgICAgcmV0dXJuIHN1YnNlY3Rpb24oZnVsbFRhYmxlTW9kZWwsIGZpcnN0Q2VsbCwgbGFzdENlbGwpLm1hcChzZWN0aW9uZWRUYWJsZU1vZGVsID0+IGZyb21FbGVtZW50cyhbdG9Eb20oc2VjdGlvbmVkVGFibGVNb2RlbCldKSk7XG4gICAgfSkuZ2V0T3JUaHVuayhlbXB0eUZyYWdtZW50KTtcbiAgICBjb25zdCBnZXRTZWxlY3Rpb25GcmFnbWVudCA9IChyb290Tm9kZSwgcmFuZ2VzKSA9PiByYW5nZXMubGVuZ3RoID4gMCAmJiByYW5nZXNbMF0uY29sbGFwc2VkID8gZW1wdHlGcmFnbWVudCgpIDogZ2V0RnJhZ21lbnRGcm9tUmFuZ2Uocm9vdE5vZGUsIHJhbmdlc1swXSk7XG4gICAgY29uc3QgcmVhZCQzID0gKHJvb3ROb2RlLCByYW5nZXMpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkQ2VsbHMgPSBnZXRDZWxsc0Zyb21FbGVtZW50T3JSYW5nZXMocmFuZ2VzLCByb290Tm9kZSk7XG4gICAgICByZXR1cm4gc2VsZWN0ZWRDZWxscy5sZW5ndGggPiAwID8gZ2V0VGFibGVGcmFnbWVudChyb290Tm9kZSwgc2VsZWN0ZWRDZWxscykgOiBnZXRTZWxlY3Rpb25GcmFnbWVudChyb290Tm9kZSwgcmFuZ2VzKTtcbiAgICB9O1xuXG4gICAgY29uc3QgaXNDb2xsYXBzaWJsZVdoaXRlc3BhY2UgPSAodGV4dCwgaW5kZXgpID0+IGluZGV4ID49IDAgJiYgaW5kZXggPCB0ZXh0Lmxlbmd0aCAmJiBpc1doaXRlU3BhY2UodGV4dC5jaGFyQXQoaW5kZXgpKTtcbiAgICBjb25zdCBnZXRJbm5lclRleHQgPSBiaW4gPT4ge1xuICAgICAgcmV0dXJuIHRyaW0kMShiaW4uaW5uZXJUZXh0KTtcbiAgICB9O1xuICAgIGNvbnN0IGdldENvbnRleHROb2RlTmFtZSA9IHBhcmVudEJsb2NrT3B0ID0+IHBhcmVudEJsb2NrT3B0Lm1hcChibG9jayA9PiBibG9jay5ub2RlTmFtZSkuZ2V0T3IoJ2RpdicpLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgZ2V0VGV4dENvbnRlbnQgPSBlZGl0b3IgPT4gT3B0aW9uYWwuZnJvbShlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpKS5tYXAocm5nID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IHBhcmVudEJsb2NrT3B0ID0gT3B0aW9uYWwuZnJvbShlZGl0b3IuZG9tLmdldFBhcmVudChybmcuY29tbW9uQW5jZXN0b3JDb250YWluZXIsIGVkaXRvci5kb20uaXNCbG9jaykpO1xuICAgICAgY29uc3QgYm9keSA9IGVkaXRvci5nZXRCb2R5KCk7XG4gICAgICBjb25zdCBjb250ZXh0Tm9kZU5hbWUgPSBnZXRDb250ZXh0Tm9kZU5hbWUocGFyZW50QmxvY2tPcHQpO1xuICAgICAgY29uc3QgcmFuZ2VDb250ZW50Q2xvbmUgPSBTdWdhckVsZW1lbnQuZnJvbURvbShybmcuY2xvbmVDb250ZW50cygpKTtcbiAgICAgIGNsZWFudXBCb2d1c0VsZW1lbnRzKHJhbmdlQ29udGVudENsb25lKTtcbiAgICAgIGNsZWFudXBJbnB1dE5hbWVzKHJhbmdlQ29udGVudENsb25lKTtcbiAgICAgIGNvbnN0IGJpbiA9IGVkaXRvci5kb20uYWRkKGJvZHksIGNvbnRleHROb2RlTmFtZSwge1xuICAgICAgICAnZGF0YS1tY2UtYm9ndXMnOiAnYWxsJyxcbiAgICAgICAgJ3N0eWxlJzogJ292ZXJmbG93OiBoaWRkZW47IG9wYWNpdHk6IDA7J1xuICAgICAgfSwgcmFuZ2VDb250ZW50Q2xvbmUuZG9tKTtcbiAgICAgIGNvbnN0IHRleHQgPSBnZXRJbm5lclRleHQoYmluKTtcbiAgICAgIGNvbnN0IG5vblJlbmRlcmVkVGV4dCA9IHRyaW0kMSgoX2EgPSBiaW4udGV4dENvbnRlbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKTtcbiAgICAgIGVkaXRvci5kb20ucmVtb3ZlKGJpbik7XG4gICAgICBpZiAoaXNDb2xsYXBzaWJsZVdoaXRlc3BhY2Uobm9uUmVuZGVyZWRUZXh0LCAwKSB8fCBpc0NvbGxhcHNpYmxlV2hpdGVzcGFjZShub25SZW5kZXJlZFRleHQsIG5vblJlbmRlcmVkVGV4dC5sZW5ndGggLSAxKSkge1xuICAgICAgICBjb25zdCBwYXJlbnRCbG9jayA9IHBhcmVudEJsb2NrT3B0LmdldE9yKGJvZHkpO1xuICAgICAgICBjb25zdCBwYXJlbnRCbG9ja1RleHQgPSBnZXRJbm5lclRleHQocGFyZW50QmxvY2spO1xuICAgICAgICBjb25zdCB0ZXh0SW5kZXggPSBwYXJlbnRCbG9ja1RleHQuaW5kZXhPZih0ZXh0KTtcbiAgICAgICAgaWYgKHRleHRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBoYXNQcm9jZWVkaW5nU3BhY2UgPSBpc0NvbGxhcHNpYmxlV2hpdGVzcGFjZShwYXJlbnRCbG9ja1RleHQsIHRleHRJbmRleCAtIDEpO1xuICAgICAgICAgIGNvbnN0IGhhc1RyYWlsaW5nU3BhY2UgPSBpc0NvbGxhcHNpYmxlV2hpdGVzcGFjZShwYXJlbnRCbG9ja1RleHQsIHRleHRJbmRleCArIHRleHQubGVuZ3RoKTtcbiAgICAgICAgICByZXR1cm4gKGhhc1Byb2NlZWRpbmdTcGFjZSA/ICcgJyA6ICcnKSArIHRleHQgKyAoaGFzVHJhaWxpbmdTcGFjZSA/ICcgJyA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICB9XG4gICAgfSkuZ2V0T3IoJycpO1xuICAgIGNvbnN0IGdldFNlcmlhbGl6ZWRDb250ZW50ID0gKGVkaXRvciwgYXJncykgPT4ge1xuICAgICAgY29uc3Qgcm5nID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKSwgdG1wRWxtID0gZWRpdG9yLmRvbS5jcmVhdGUoJ2JvZHknKTtcbiAgICAgIGNvbnN0IHNlbCA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0U2VsKCk7XG4gICAgICBjb25zdCByYW5nZXMgPSBwcm9jZXNzUmFuZ2VzKGVkaXRvciwgZ2V0UmFuZ2VzJDEoc2VsKSk7XG4gICAgICBjb25zdCBmcmFnbWVudCA9IGFyZ3MuY29udGV4dHVhbCA/IHJlYWQkMyhTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3IuZ2V0Qm9keSgpKSwgcmFuZ2VzKS5kb20gOiBybmcuY2xvbmVDb250ZW50cygpO1xuICAgICAgaWYgKGZyYWdtZW50KSB7XG4gICAgICAgIHRtcEVsbS5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWRpdG9yLnNlbGVjdGlvbi5zZXJpYWxpemVyLnNlcmlhbGl6ZSh0bXBFbG0sIGFyZ3MpO1xuICAgIH07XG4gICAgY29uc3QgZXh0cmFjdFNlbGVjdGVkQ29udGVudCA9IChlZGl0b3IsIGFyZ3MpID0+IHtcbiAgICAgIGlmIChhcmdzLmZvcm1hdCA9PT0gJ3RleHQnKSB7XG4gICAgICAgIHJldHVybiBnZXRUZXh0Q29udGVudChlZGl0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IGdldFNlcmlhbGl6ZWRDb250ZW50KGVkaXRvciwgYXJncyk7XG4gICAgICAgIGlmIChhcmdzLmZvcm1hdCA9PT0gJ3RyZWUnKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGVkaXRvci5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSA/ICcnIDogY29udGVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc2V0dXBBcmdzJDMgPSAoYXJncywgZm9ybWF0KSA9PiAoe1xuICAgICAgLi4uYXJncyxcbiAgICAgIGZvcm1hdCxcbiAgICAgIGdldDogdHJ1ZSxcbiAgICAgIHNlbGVjdGlvbjogdHJ1ZSxcbiAgICAgIGdldElubmVyOiB0cnVlXG4gICAgfSk7XG4gICAgY29uc3QgZ2V0U2VsZWN0ZWRDb250ZW50SW50ZXJuYWwgPSAoZWRpdG9yLCBmb3JtYXQsIGFyZ3MgPSB7fSkgPT4ge1xuICAgICAgY29uc3QgZGVmYXVsdGVkQXJncyA9IHNldHVwQXJncyQzKGFyZ3MsIGZvcm1hdCk7XG4gICAgICByZXR1cm4gcHJlUHJvY2Vzc0dldENvbnRlbnQoZWRpdG9yLCBkZWZhdWx0ZWRBcmdzKS5mb2xkKGlkZW50aXR5LCB1cGRhdGVkQXJncyA9PiB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBleHRyYWN0U2VsZWN0ZWRDb250ZW50KGVkaXRvciwgdXBkYXRlZEFyZ3MpO1xuICAgICAgICByZXR1cm4gcG9zdFByb2Nlc3NHZXRDb250ZW50KGVkaXRvciwgY29udGVudCwgdXBkYXRlZEFyZ3MpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IEtFRVAgPSAwLCBJTlNFUlQgPSAxLCBERUxFVEUgPSAyO1xuICAgIGNvbnN0IGRpZmYgPSAobGVmdCwgcmlnaHQpID0+IHtcbiAgICAgIGNvbnN0IHNpemUgPSBsZWZ0Lmxlbmd0aCArIHJpZ2h0Lmxlbmd0aCArIDI7XG4gICAgICBjb25zdCB2RG93biA9IG5ldyBBcnJheShzaXplKTtcbiAgICAgIGNvbnN0IHZVcCA9IG5ldyBBcnJheShzaXplKTtcbiAgICAgIGNvbnN0IHNuYWtlID0gKHN0YXJ0LCBlbmQsIGRpYWcpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGFydCxcbiAgICAgICAgICBlbmQsXG4gICAgICAgICAgZGlhZ1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGJ1aWxkU2NyaXB0ID0gKHN0YXJ0MSwgZW5kMSwgc3RhcnQyLCBlbmQyLCBzY3JpcHQpID0+IHtcbiAgICAgICAgY29uc3QgbWlkZGxlID0gZ2V0TWlkZGxlU25ha2Uoc3RhcnQxLCBlbmQxLCBzdGFydDIsIGVuZDIpO1xuICAgICAgICBpZiAobWlkZGxlID09PSBudWxsIHx8IG1pZGRsZS5zdGFydCA9PT0gZW5kMSAmJiBtaWRkbGUuZGlhZyA9PT0gZW5kMSAtIGVuZDIgfHwgbWlkZGxlLmVuZCA9PT0gc3RhcnQxICYmIG1pZGRsZS5kaWFnID09PSBzdGFydDEgLSBzdGFydDIpIHtcbiAgICAgICAgICBsZXQgaSA9IHN0YXJ0MTtcbiAgICAgICAgICBsZXQgaiA9IHN0YXJ0MjtcbiAgICAgICAgICB3aGlsZSAoaSA8IGVuZDEgfHwgaiA8IGVuZDIpIHtcbiAgICAgICAgICAgIGlmIChpIDwgZW5kMSAmJiBqIDwgZW5kMiAmJiBsZWZ0W2ldID09PSByaWdodFtqXSkge1xuICAgICAgICAgICAgICBzY3JpcHQucHVzaChbXG4gICAgICAgICAgICAgICAgS0VFUCxcbiAgICAgICAgICAgICAgICBsZWZ0W2ldXG4gICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICAgICsrajtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChlbmQxIC0gc3RhcnQxID4gZW5kMiAtIHN0YXJ0Mikge1xuICAgICAgICAgICAgICAgIHNjcmlwdC5wdXNoKFtcbiAgICAgICAgICAgICAgICAgIERFTEVURSxcbiAgICAgICAgICAgICAgICAgIGxlZnRbaV1cbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2NyaXB0LnB1c2goW1xuICAgICAgICAgICAgICAgICAgSU5TRVJULFxuICAgICAgICAgICAgICAgICAgcmlnaHRbal1cbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICArK2o7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnVpbGRTY3JpcHQoc3RhcnQxLCBtaWRkbGUuc3RhcnQsIHN0YXJ0MiwgbWlkZGxlLnN0YXJ0IC0gbWlkZGxlLmRpYWcsIHNjcmlwdCk7XG4gICAgICAgICAgZm9yIChsZXQgaTIgPSBtaWRkbGUuc3RhcnQ7IGkyIDwgbWlkZGxlLmVuZDsgKytpMikge1xuICAgICAgICAgICAgc2NyaXB0LnB1c2goW1xuICAgICAgICAgICAgICBLRUVQLFxuICAgICAgICAgICAgICBsZWZ0W2kyXVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJ1aWxkU2NyaXB0KG1pZGRsZS5lbmQsIGVuZDEsIG1pZGRsZS5lbmQgLSBtaWRkbGUuZGlhZywgZW5kMiwgc2NyaXB0KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGJ1aWxkU25ha2UgPSAoc3RhcnQsIGRpYWcsIGVuZDEsIGVuZDIpID0+IHtcbiAgICAgICAgbGV0IGVuZCA9IHN0YXJ0O1xuICAgICAgICB3aGlsZSAoZW5kIC0gZGlhZyA8IGVuZDIgJiYgZW5kIDwgZW5kMSAmJiBsZWZ0W2VuZF0gPT09IHJpZ2h0W2VuZCAtIGRpYWddKSB7XG4gICAgICAgICAgKytlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNuYWtlKHN0YXJ0LCBlbmQsIGRpYWcpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldE1pZGRsZVNuYWtlID0gKHN0YXJ0MSwgZW5kMSwgc3RhcnQyLCBlbmQyKSA9PiB7XG4gICAgICAgIGNvbnN0IG0gPSBlbmQxIC0gc3RhcnQxO1xuICAgICAgICBjb25zdCBuID0gZW5kMiAtIHN0YXJ0MjtcbiAgICAgICAgaWYgKG0gPT09IDAgfHwgbiA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlbHRhID0gbSAtIG47XG4gICAgICAgIGNvbnN0IHN1bSA9IG4gKyBtO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSAoc3VtICUgMiA9PT0gMCA/IHN1bSA6IHN1bSArIDEpIC8gMjtcbiAgICAgICAgdkRvd25bMSArIG9mZnNldF0gPSBzdGFydDE7XG4gICAgICAgIHZVcFsxICsgb2Zmc2V0XSA9IGVuZDEgKyAxO1xuICAgICAgICBsZXQgZCwgaywgaSwgeCwgeTtcbiAgICAgICAgZm9yIChkID0gMDsgZCA8PSBvZmZzZXQ7ICsrZCkge1xuICAgICAgICAgIGZvciAoayA9IC1kOyBrIDw9IGQ7IGsgKz0gMikge1xuICAgICAgICAgICAgaSA9IGsgKyBvZmZzZXQ7XG4gICAgICAgICAgICBpZiAoayA9PT0gLWQgfHwgayAhPT0gZCAmJiB2RG93bltpIC0gMV0gPCB2RG93bltpICsgMV0pIHtcbiAgICAgICAgICAgICAgdkRvd25baV0gPSB2RG93bltpICsgMV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2RG93bltpXSA9IHZEb3duW2kgLSAxXSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4ID0gdkRvd25baV07XG4gICAgICAgICAgICB5ID0geCAtIHN0YXJ0MSArIHN0YXJ0MiAtIGs7XG4gICAgICAgICAgICB3aGlsZSAoeCA8IGVuZDEgJiYgeSA8IGVuZDIgJiYgbGVmdFt4XSA9PT0gcmlnaHRbeV0pIHtcbiAgICAgICAgICAgICAgdkRvd25baV0gPSArK3g7XG4gICAgICAgICAgICAgICsreTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWx0YSAlIDIgIT09IDAgJiYgZGVsdGEgLSBkIDw9IGsgJiYgayA8PSBkZWx0YSArIGQpIHtcbiAgICAgICAgICAgICAgaWYgKHZVcFtpIC0gZGVsdGFdIDw9IHZEb3duW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1aWxkU25ha2UodlVwW2kgLSBkZWx0YV0sIGsgKyBzdGFydDEgLSBzdGFydDIsIGVuZDEsIGVuZDIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoayA9IGRlbHRhIC0gZDsgayA8PSBkZWx0YSArIGQ7IGsgKz0gMikge1xuICAgICAgICAgICAgaSA9IGsgKyBvZmZzZXQgLSBkZWx0YTtcbiAgICAgICAgICAgIGlmIChrID09PSBkZWx0YSAtIGQgfHwgayAhPT0gZGVsdGEgKyBkICYmIHZVcFtpICsgMV0gPD0gdlVwW2kgLSAxXSkge1xuICAgICAgICAgICAgICB2VXBbaV0gPSB2VXBbaSArIDFdIC0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZVcFtpXSA9IHZVcFtpIC0gMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4ID0gdlVwW2ldIC0gMTtcbiAgICAgICAgICAgIHkgPSB4IC0gc3RhcnQxICsgc3RhcnQyIC0gaztcbiAgICAgICAgICAgIHdoaWxlICh4ID49IHN0YXJ0MSAmJiB5ID49IHN0YXJ0MiAmJiBsZWZ0W3hdID09PSByaWdodFt5XSkge1xuICAgICAgICAgICAgICB2VXBbaV0gPSB4LS07XG4gICAgICAgICAgICAgIHktLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWx0YSAlIDIgPT09IDAgJiYgLWQgPD0gayAmJiBrIDw9IGQpIHtcbiAgICAgICAgICAgICAgaWYgKHZVcFtpXSA8PSB2RG93bltpICsgZGVsdGFdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1aWxkU25ha2UodlVwW2ldLCBrICsgc3RhcnQxIC0gc3RhcnQyLCBlbmQxLCBlbmQyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBjb25zdCBzY3JpcHQgPSBbXTtcbiAgICAgIGJ1aWxkU2NyaXB0KDAsIGxlZnQubGVuZ3RoLCAwLCByaWdodC5sZW5ndGgsIHNjcmlwdCk7XG4gICAgICByZXR1cm4gc2NyaXB0O1xuICAgIH07XG5cbiAgICBjb25zdCBnZXRPdXRlckh0bWwgPSBlbG0gPT4ge1xuICAgICAgaWYgKGlzRWxlbWVudCQ2KGVsbSkpIHtcbiAgICAgICAgcmV0dXJuIGVsbS5vdXRlckhUTUw7XG4gICAgICB9IGVsc2UgaWYgKGlzVGV4dCRhKGVsbSkpIHtcbiAgICAgICAgcmV0dXJuIEVudGl0aWVzLmVuY29kZVJhdyhlbG0uZGF0YSwgZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmIChpc0NvbW1lbnQoZWxtKSkge1xuICAgICAgICByZXR1cm4gJzwhLS0nICsgZWxtLmRhdGEgKyAnLS0+JztcbiAgICAgIH1cbiAgICAgIHJldHVybiAnJztcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZUZyYWdtZW50ID0gaHRtbCA9PiB7XG4gICAgICBsZXQgbm9kZTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgY29uc3QgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgIGlmIChodG1sKSB7XG4gICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgfVxuICAgICAgd2hpbGUgKG5vZGUgPSBjb250YWluZXIuZmlyc3RDaGlsZCkge1xuICAgICAgICBmcmFnLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZyYWc7XG4gICAgfTtcbiAgICBjb25zdCBpbnNlcnRBdCA9IChlbG0sIGh0bWwsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBmcmFnbWVudCA9IGNyZWF0ZUZyYWdtZW50KGh0bWwpO1xuICAgICAgaWYgKGVsbS5oYXNDaGlsZE5vZGVzKCkgJiYgaW5kZXggPCBlbG0uY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZWxtLmNoaWxkTm9kZXNbaW5kZXhdO1xuICAgICAgICBlbG0uaW5zZXJ0QmVmb3JlKGZyYWdtZW50LCB0YXJnZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxtLmFwcGVuZENoaWxkKGZyYWdtZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZUF0ID0gKGVsbSwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChlbG0uaGFzQ2hpbGROb2RlcygpICYmIGluZGV4IDwgZWxtLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGVsbS5jaGlsZE5vZGVzW2luZGV4XTtcbiAgICAgICAgZWxtLnJlbW92ZUNoaWxkKHRhcmdldCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBhcHBseURpZmYgPSAoZGlmZiwgZWxtKSA9PiB7XG4gICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgZWFjaCRlKGRpZmYsIGFjdGlvbiA9PiB7XG4gICAgICAgIGlmIChhY3Rpb25bMF0gPT09IEtFRVApIHtcbiAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9IGVsc2UgaWYgKGFjdGlvblswXSA9PT0gSU5TRVJUKSB7XG4gICAgICAgICAgaW5zZXJ0QXQoZWxtLCBhY3Rpb25bMV0sIGluZGV4KTtcbiAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9IGVsc2UgaWYgKGFjdGlvblswXSA9PT0gREVMRVRFKSB7XG4gICAgICAgICAgcmVtb3ZlQXQoZWxtLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgcmVhZCQyID0gZWxtID0+IHtcbiAgICAgIHJldHVybiBmaWx0ZXIkNShtYXAkMyhmcm9tKGVsbS5jaGlsZE5vZGVzKSwgZ2V0T3V0ZXJIdG1sKSwgaXRlbSA9PiB7XG4gICAgICAgIHJldHVybiBpdGVtLmxlbmd0aCA+IDA7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHdyaXRlID0gKGZyYWdtZW50cywgZWxtKSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50RnJhZ21lbnRzID0gbWFwJDMoZnJvbShlbG0uY2hpbGROb2RlcyksIGdldE91dGVySHRtbCk7XG4gICAgICBhcHBseURpZmYoZGlmZihjdXJyZW50RnJhZ21lbnRzLCBmcmFnbWVudHMpLCBlbG0pO1xuICAgICAgcmV0dXJuIGVsbTtcbiAgICB9O1xuXG4gICAgY29uc3QgbGF6eVRlbXBEb2N1bWVudCA9IGNhY2hlZCgoKSA9PiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoJ3VuZG8nKSk7XG4gICAgY29uc3QgaGFzSWZyYW1lcyA9IGh0bWwgPT4ge1xuICAgICAgcmV0dXJuIGh0bWwuaW5kZXhPZignPC9pZnJhbWU+JykgIT09IC0xO1xuICAgIH07XG4gICAgY29uc3QgY3JlYXRlRnJhZ21lbnRlZExldmVsID0gZnJhZ21lbnRzID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdmcmFnbWVudGVkJyxcbiAgICAgICAgZnJhZ21lbnRzLFxuICAgICAgICBjb250ZW50OiAnJyxcbiAgICAgICAgYm9va21hcms6IG51bGwsXG4gICAgICAgIGJlZm9yZUJvb2ttYXJrOiBudWxsXG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgY3JlYXRlQ29tcGxldGVMZXZlbCA9IGNvbnRlbnQgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2NvbXBsZXRlJyxcbiAgICAgICAgZnJhZ21lbnRzOiBudWxsLFxuICAgICAgICBjb250ZW50LFxuICAgICAgICBib29rbWFyazogbnVsbCxcbiAgICAgICAgYmVmb3JlQm9va21hcms6IG51bGxcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGVGcm9tRWRpdG9yID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGZyYWdtZW50cyA9IHJlYWQkMihlZGl0b3IuZ2V0Qm9keSgpKTtcbiAgICAgIGNvbnN0IHRyaW1tZWRGcmFnbWVudHMgPSBiaW5kJDMoZnJhZ21lbnRzLCBodG1sID0+IHtcbiAgICAgICAgY29uc3QgdHJpbW1lZCA9IHRyaW1JbnRlcm5hbChlZGl0b3Iuc2VyaWFsaXplciwgaHRtbCk7XG4gICAgICAgIHJldHVybiB0cmltbWVkLmxlbmd0aCA+IDAgPyBbdHJpbW1lZF0gOiBbXTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgY29udGVudCA9IHRyaW1tZWRGcmFnbWVudHMuam9pbignJyk7XG4gICAgICByZXR1cm4gaGFzSWZyYW1lcyhjb250ZW50KSA/IGNyZWF0ZUZyYWdtZW50ZWRMZXZlbCh0cmltbWVkRnJhZ21lbnRzKSA6IGNyZWF0ZUNvbXBsZXRlTGV2ZWwoY29udGVudCk7XG4gICAgfTtcbiAgICBjb25zdCBhcHBseVRvRWRpdG9yID0gKGVkaXRvciwgbGV2ZWwsIGJlZm9yZSkgPT4ge1xuICAgICAgY29uc3QgYm9va21hcmsgPSBiZWZvcmUgPyBsZXZlbC5iZWZvcmVCb29rbWFyayA6IGxldmVsLmJvb2ttYXJrO1xuICAgICAgaWYgKGxldmVsLnR5cGUgPT09ICdmcmFnbWVudGVkJykge1xuICAgICAgICB3cml0ZShsZXZlbC5mcmFnbWVudHMsIGVkaXRvci5nZXRCb2R5KCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRpdG9yLnNldENvbnRlbnQobGV2ZWwuY29udGVudCwge1xuICAgICAgICAgIGZvcm1hdDogJ3JhdycsXG4gICAgICAgICAgbm9fc2VsZWN0aW9uOiBpc05vbk51bGxhYmxlKGJvb2ttYXJrKSAmJiBpc1BhdGhCb29rbWFyayhib29rbWFyaykgPyAhYm9va21hcmsuaXNGYWtlQ2FyZXQgOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGJvb2ttYXJrKSB7XG4gICAgICAgIGVkaXRvci5zZWxlY3Rpb24ubW92ZVRvQm9va21hcmsoYm9va21hcmspO1xuICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBnZXRMZXZlbENvbnRlbnQgPSBsZXZlbCA9PiB7XG4gICAgICByZXR1cm4gbGV2ZWwudHlwZSA9PT0gJ2ZyYWdtZW50ZWQnID8gbGV2ZWwuZnJhZ21lbnRzLmpvaW4oJycpIDogbGV2ZWwuY29udGVudDtcbiAgICB9O1xuICAgIGNvbnN0IGdldENsZWFuTGV2ZWxDb250ZW50ID0gbGV2ZWwgPT4ge1xuICAgICAgY29uc3QgZWxtID0gU3VnYXJFbGVtZW50LmZyb21UYWcoJ2JvZHknLCBsYXp5VGVtcERvY3VtZW50KCkpO1xuICAgICAgc2V0JDEoZWxtLCBnZXRMZXZlbENvbnRlbnQobGV2ZWwpKTtcbiAgICAgIGVhY2gkZShkZXNjZW5kYW50cyhlbG0sICcqW2RhdGEtbWNlLWJvZ3VzXScpLCB1bndyYXApO1xuICAgICAgcmV0dXJuIGdldCQ2KGVsbSk7XG4gICAgfTtcbiAgICBjb25zdCBoYXNFcXVhbENvbnRlbnQgPSAobGV2ZWwxLCBsZXZlbDIpID0+IGdldExldmVsQ29udGVudChsZXZlbDEpID09PSBnZXRMZXZlbENvbnRlbnQobGV2ZWwyKTtcbiAgICBjb25zdCBoYXNFcXVhbENsZWFuZWRDb250ZW50ID0gKGxldmVsMSwgbGV2ZWwyKSA9PiBnZXRDbGVhbkxldmVsQ29udGVudChsZXZlbDEpID09PSBnZXRDbGVhbkxldmVsQ29udGVudChsZXZlbDIpO1xuICAgIGNvbnN0IGlzRXEkMSA9IChsZXZlbDEsIGxldmVsMikgPT4ge1xuICAgICAgaWYgKCFsZXZlbDEgfHwgIWxldmVsMikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGhhc0VxdWFsQ29udGVudChsZXZlbDEsIGxldmVsMikpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaGFzRXF1YWxDbGVhbmVkQ29udGVudChsZXZlbDEsIGxldmVsMik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGlzVW5sb2NrZWQgPSBsb2NrcyA9PiBsb2Nrcy5nZXQoKSA9PT0gMDtcblxuICAgIGNvbnN0IHNldFR5cGluZyA9ICh1bmRvTWFuYWdlciwgdHlwaW5nLCBsb2NrcykgPT4ge1xuICAgICAgaWYgKGlzVW5sb2NrZWQobG9ja3MpKSB7XG4gICAgICAgIHVuZG9NYW5hZ2VyLnR5cGluZyA9IHR5cGluZztcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGVuZFR5cGluZyA9ICh1bmRvTWFuYWdlciwgbG9ja3MpID0+IHtcbiAgICAgIGlmICh1bmRvTWFuYWdlci50eXBpbmcpIHtcbiAgICAgICAgc2V0VHlwaW5nKHVuZG9NYW5hZ2VyLCBmYWxzZSwgbG9ja3MpO1xuICAgICAgICB1bmRvTWFuYWdlci5hZGQoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGVuZFR5cGluZ0xldmVsSWdub3JlTG9ja3MgPSB1bmRvTWFuYWdlciA9PiB7XG4gICAgICBpZiAodW5kb01hbmFnZXIudHlwaW5nKSB7XG4gICAgICAgIHVuZG9NYW5hZ2VyLnR5cGluZyA9IGZhbHNlO1xuICAgICAgICB1bmRvTWFuYWdlci5hZGQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgYmVmb3JlQ2hhbmdlJDEgPSAoZWRpdG9yLCBsb2NrcywgYmVmb3JlQm9va21hcmspID0+IHtcbiAgICAgIGlmIChpc1VubG9ja2VkKGxvY2tzKSkge1xuICAgICAgICBiZWZvcmVCb29rbWFyay5zZXQoZ2V0VW5kb0Jvb2ttYXJrKGVkaXRvci5zZWxlY3Rpb24pKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGFkZFVuZG9MZXZlbCQxID0gKGVkaXRvciwgdW5kb01hbmFnZXIsIGluZGV4LCBsb2NrcywgYmVmb3JlQm9va21hcmssIGxldmVsLCBldmVudCkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudExldmVsID0gY3JlYXRlRnJvbUVkaXRvcihlZGl0b3IpO1xuICAgICAgY29uc3QgbmV3TGV2ZWwgPSBUb29scy5leHRlbmQobGV2ZWwgfHwge30sIGN1cnJlbnRMZXZlbCk7XG4gICAgICBpZiAoIWlzVW5sb2NrZWQobG9ja3MpIHx8IGVkaXRvci5yZW1vdmVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgbGFzdExldmVsID0gdW5kb01hbmFnZXIuZGF0YVtpbmRleC5nZXQoKV07XG4gICAgICBpZiAoZWRpdG9yLmRpc3BhdGNoKCdCZWZvcmVBZGRVbmRvJywge1xuICAgICAgICAgIGxldmVsOiBuZXdMZXZlbCxcbiAgICAgICAgICBsYXN0TGV2ZWwsXG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcbiAgICAgICAgfSkuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAobGFzdExldmVsICYmIGlzRXEkMShsYXN0TGV2ZWwsIG5ld0xldmVsKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh1bmRvTWFuYWdlci5kYXRhW2luZGV4LmdldCgpXSkge1xuICAgICAgICBiZWZvcmVCb29rbWFyay5nZXQoKS5lYWNoKGJtID0+IHtcbiAgICAgICAgICB1bmRvTWFuYWdlci5kYXRhW2luZGV4LmdldCgpXS5iZWZvcmVCb29rbWFyayA9IGJtO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGN1c3RvbVVuZG9SZWRvTGV2ZWxzID0gZ2V0Q3VzdG9tVW5kb1JlZG9MZXZlbHMoZWRpdG9yKTtcbiAgICAgIGlmIChjdXN0b21VbmRvUmVkb0xldmVscykge1xuICAgICAgICBpZiAodW5kb01hbmFnZXIuZGF0YS5sZW5ndGggPiBjdXN0b21VbmRvUmVkb0xldmVscykge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdW5kb01hbmFnZXIuZGF0YS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIHVuZG9NYW5hZ2VyLmRhdGFbaV0gPSB1bmRvTWFuYWdlci5kYXRhW2kgKyAxXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdW5kb01hbmFnZXIuZGF0YS5sZW5ndGgtLTtcbiAgICAgICAgICBpbmRleC5zZXQodW5kb01hbmFnZXIuZGF0YS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBuZXdMZXZlbC5ib29rbWFyayA9IGdldFVuZG9Cb29rbWFyayhlZGl0b3Iuc2VsZWN0aW9uKTtcbiAgICAgIGlmIChpbmRleC5nZXQoKSA8IHVuZG9NYW5hZ2VyLmRhdGEubGVuZ3RoIC0gMSkge1xuICAgICAgICB1bmRvTWFuYWdlci5kYXRhLmxlbmd0aCA9IGluZGV4LmdldCgpICsgMTtcbiAgICAgIH1cbiAgICAgIHVuZG9NYW5hZ2VyLmRhdGEucHVzaChuZXdMZXZlbCk7XG4gICAgICBpbmRleC5zZXQodW5kb01hbmFnZXIuZGF0YS5sZW5ndGggLSAxKTtcbiAgICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICAgIGxldmVsOiBuZXdMZXZlbCxcbiAgICAgICAgbGFzdExldmVsLFxuICAgICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxuICAgICAgfTtcbiAgICAgIGlmIChpbmRleC5nZXQoKSA+IDApIHtcbiAgICAgICAgZWRpdG9yLnNldERpcnR5KHRydWUpO1xuICAgICAgICBlZGl0b3IuZGlzcGF0Y2goJ0FkZFVuZG8nLCBhcmdzKTtcbiAgICAgICAgZWRpdG9yLmRpc3BhdGNoKCdjaGFuZ2UnLCBhcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkaXRvci5kaXNwYXRjaCgnQWRkVW5kbycsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0xldmVsO1xuICAgIH07XG4gICAgY29uc3QgY2xlYXIkMSA9IChlZGl0b3IsIHVuZG9NYW5hZ2VyLCBpbmRleCkgPT4ge1xuICAgICAgdW5kb01hbmFnZXIuZGF0YSA9IFtdO1xuICAgICAgaW5kZXguc2V0KDApO1xuICAgICAgdW5kb01hbmFnZXIudHlwaW5nID0gZmFsc2U7XG4gICAgICBlZGl0b3IuZGlzcGF0Y2goJ0NsZWFyVW5kb3MnKTtcbiAgICB9O1xuICAgIGNvbnN0IGV4dHJhJDEgPSAoZWRpdG9yLCB1bmRvTWFuYWdlciwgaW5kZXgsIGNhbGxiYWNrMSwgY2FsbGJhY2syKSA9PiB7XG4gICAgICBpZiAodW5kb01hbmFnZXIudHJhbnNhY3QoY2FsbGJhY2sxKSkge1xuICAgICAgICBjb25zdCBib29rbWFyayA9IHVuZG9NYW5hZ2VyLmRhdGFbaW5kZXguZ2V0KCldLmJvb2ttYXJrO1xuICAgICAgICBjb25zdCBsYXN0TGV2ZWwgPSB1bmRvTWFuYWdlci5kYXRhW2luZGV4LmdldCgpIC0gMV07XG4gICAgICAgIGFwcGx5VG9FZGl0b3IoZWRpdG9yLCBsYXN0TGV2ZWwsIHRydWUpO1xuICAgICAgICBpZiAodW5kb01hbmFnZXIudHJhbnNhY3QoY2FsbGJhY2syKSkge1xuICAgICAgICAgIHVuZG9NYW5hZ2VyLmRhdGFbaW5kZXguZ2V0KCkgLSAxXS5iZWZvcmVCb29rbWFyayA9IGJvb2ttYXJrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZWRvJDEgPSAoZWRpdG9yLCBpbmRleCwgZGF0YSkgPT4ge1xuICAgICAgbGV0IGxldmVsO1xuICAgICAgaWYgKGluZGV4LmdldCgpIDwgZGF0YS5sZW5ndGggLSAxKSB7XG4gICAgICAgIGluZGV4LnNldChpbmRleC5nZXQoKSArIDEpO1xuICAgICAgICBsZXZlbCA9IGRhdGFbaW5kZXguZ2V0KCldO1xuICAgICAgICBhcHBseVRvRWRpdG9yKGVkaXRvciwgbGV2ZWwsIGZhbHNlKTtcbiAgICAgICAgZWRpdG9yLnNldERpcnR5KHRydWUpO1xuICAgICAgICBlZGl0b3IuZGlzcGF0Y2goJ1JlZG8nLCB7IGxldmVsIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxldmVsO1xuICAgIH07XG4gICAgY29uc3QgdW5kbyQxID0gKGVkaXRvciwgdW5kb01hbmFnZXIsIGxvY2tzLCBpbmRleCkgPT4ge1xuICAgICAgbGV0IGxldmVsO1xuICAgICAgaWYgKHVuZG9NYW5hZ2VyLnR5cGluZykge1xuICAgICAgICB1bmRvTWFuYWdlci5hZGQoKTtcbiAgICAgICAgdW5kb01hbmFnZXIudHlwaW5nID0gZmFsc2U7XG4gICAgICAgIHNldFR5cGluZyh1bmRvTWFuYWdlciwgZmFsc2UsIGxvY2tzKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmRleC5nZXQoKSA+IDApIHtcbiAgICAgICAgaW5kZXguc2V0KGluZGV4LmdldCgpIC0gMSk7XG4gICAgICAgIGxldmVsID0gdW5kb01hbmFnZXIuZGF0YVtpbmRleC5nZXQoKV07XG4gICAgICAgIGFwcGx5VG9FZGl0b3IoZWRpdG9yLCBsZXZlbCwgdHJ1ZSk7XG4gICAgICAgIGVkaXRvci5zZXREaXJ0eSh0cnVlKTtcbiAgICAgICAgZWRpdG9yLmRpc3BhdGNoKCdVbmRvJywgeyBsZXZlbCB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZXZlbDtcbiAgICB9O1xuICAgIGNvbnN0IHJlc2V0JDEgPSB1bmRvTWFuYWdlciA9PiB7XG4gICAgICB1bmRvTWFuYWdlci5jbGVhcigpO1xuICAgICAgdW5kb01hbmFnZXIuYWRkKCk7XG4gICAgfTtcbiAgICBjb25zdCBoYXNVbmRvJDEgPSAoZWRpdG9yLCB1bmRvTWFuYWdlciwgaW5kZXgpID0+IGluZGV4LmdldCgpID4gMCB8fCB1bmRvTWFuYWdlci50eXBpbmcgJiYgdW5kb01hbmFnZXIuZGF0YVswXSAmJiAhaXNFcSQxKGNyZWF0ZUZyb21FZGl0b3IoZWRpdG9yKSwgdW5kb01hbmFnZXIuZGF0YVswXSk7XG4gICAgY29uc3QgaGFzUmVkbyQxID0gKHVuZG9NYW5hZ2VyLCBpbmRleCkgPT4gaW5kZXguZ2V0KCkgPCB1bmRvTWFuYWdlci5kYXRhLmxlbmd0aCAtIDEgJiYgIXVuZG9NYW5hZ2VyLnR5cGluZztcbiAgICBjb25zdCB0cmFuc2FjdCQxID0gKHVuZG9NYW5hZ2VyLCBsb2NrcywgY2FsbGJhY2spID0+IHtcbiAgICAgIGVuZFR5cGluZyh1bmRvTWFuYWdlciwgbG9ja3MpO1xuICAgICAgdW5kb01hbmFnZXIuYmVmb3JlQ2hhbmdlKCk7XG4gICAgICB1bmRvTWFuYWdlci5pZ25vcmUoY2FsbGJhY2spO1xuICAgICAgcmV0dXJuIHVuZG9NYW5hZ2VyLmFkZCgpO1xuICAgIH07XG4gICAgY29uc3QgaWdub3JlJDEgPSAobG9ja3MsIGNhbGxiYWNrKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBsb2Nrcy5zZXQobG9ja3MuZ2V0KCkgKyAxKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGxvY2tzLnNldChsb2Nrcy5nZXQoKSAtIDEpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBhZGRWaXN1YWxJbnRlcm5hbCA9IChlZGl0b3IsIGVsbSkgPT4ge1xuICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbTtcbiAgICAgIGNvbnN0IHNjb3BlID0gaXNOb25OdWxsYWJsZShlbG0pID8gZWxtIDogZWRpdG9yLmdldEJvZHkoKTtcbiAgICAgIGVhY2gkZShkb20uc2VsZWN0KCd0YWJsZSxhJywgc2NvcGUpLCBtYXRjaGVkRWxtID0+IHtcbiAgICAgICAgc3dpdGNoIChtYXRjaGVkRWxtLm5vZGVOYW1lKSB7XG4gICAgICAgIGNhc2UgJ1RBQkxFJzpcbiAgICAgICAgICBjb25zdCBjbHMgPSBnZXRWaXN1YWxBaWRzVGFibGVDbGFzcyhlZGl0b3IpO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gZG9tLmdldEF0dHJpYihtYXRjaGVkRWxtLCAnYm9yZGVyJyk7XG4gICAgICAgICAgaWYgKCghdmFsdWUgfHwgdmFsdWUgPT09ICcwJykgJiYgZWRpdG9yLmhhc1Zpc3VhbCkge1xuICAgICAgICAgICAgZG9tLmFkZENsYXNzKG1hdGNoZWRFbG0sIGNscyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyhtYXRjaGVkRWxtLCBjbHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgaWYgKCFkb20uZ2V0QXR0cmliKG1hdGNoZWRFbG0sICdocmVmJykpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZG9tLmdldEF0dHJpYihtYXRjaGVkRWxtLCAnbmFtZScpIHx8IG1hdGNoZWRFbG0uaWQ7XG4gICAgICAgICAgICBjb25zdCBjbHMgPSBnZXRWaXN1YWxBaWRzQW5jaG9yQ2xhc3MoZWRpdG9yKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiBlZGl0b3IuaGFzVmlzdWFsKSB7XG4gICAgICAgICAgICAgIGRvbS5hZGRDbGFzcyhtYXRjaGVkRWxtLCBjbHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKG1hdGNoZWRFbG0sIGNscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGVkaXRvci5kaXNwYXRjaCgnVmlzdWFsQWlkJywge1xuICAgICAgICBlbGVtZW50OiBlbG0sXG4gICAgICAgIGhhc1Zpc3VhbDogZWRpdG9yLmhhc1Zpc3VhbFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IG1ha2VQbGFpbkFkYXB0b3IgPSBlZGl0b3IgPT4gKHtcbiAgICAgIGluaXQ6IHsgYmluZEV2ZW50czogbm9vcCB9LFxuICAgICAgdW5kb01hbmFnZXI6IHtcbiAgICAgICAgYmVmb3JlQ2hhbmdlOiAobG9ja3MsIGJlZm9yZUJvb2ttYXJrKSA9PiBiZWZvcmVDaGFuZ2UkMShlZGl0b3IsIGxvY2tzLCBiZWZvcmVCb29rbWFyayksXG4gICAgICAgIGFkZDogKHVuZG9NYW5hZ2VyLCBpbmRleCwgbG9ja3MsIGJlZm9yZUJvb2ttYXJrLCBsZXZlbCwgZXZlbnQpID0+IGFkZFVuZG9MZXZlbCQxKGVkaXRvciwgdW5kb01hbmFnZXIsIGluZGV4LCBsb2NrcywgYmVmb3JlQm9va21hcmssIGxldmVsLCBldmVudCksXG4gICAgICAgIHVuZG86ICh1bmRvTWFuYWdlciwgbG9ja3MsIGluZGV4KSA9PiB1bmRvJDEoZWRpdG9yLCB1bmRvTWFuYWdlciwgbG9ja3MsIGluZGV4KSxcbiAgICAgICAgcmVkbzogKGluZGV4LCBkYXRhKSA9PiByZWRvJDEoZWRpdG9yLCBpbmRleCwgZGF0YSksXG4gICAgICAgIGNsZWFyOiAodW5kb01hbmFnZXIsIGluZGV4KSA9PiBjbGVhciQxKGVkaXRvciwgdW5kb01hbmFnZXIsIGluZGV4KSxcbiAgICAgICAgcmVzZXQ6IHVuZG9NYW5hZ2VyID0+IHJlc2V0JDEodW5kb01hbmFnZXIpLFxuICAgICAgICBoYXNVbmRvOiAodW5kb01hbmFnZXIsIGluZGV4KSA9PiBoYXNVbmRvJDEoZWRpdG9yLCB1bmRvTWFuYWdlciwgaW5kZXgpLFxuICAgICAgICBoYXNSZWRvOiAodW5kb01hbmFnZXIsIGluZGV4KSA9PiBoYXNSZWRvJDEodW5kb01hbmFnZXIsIGluZGV4KSxcbiAgICAgICAgdHJhbnNhY3Q6ICh1bmRvTWFuYWdlciwgbG9ja3MsIGNhbGxiYWNrKSA9PiB0cmFuc2FjdCQxKHVuZG9NYW5hZ2VyLCBsb2NrcywgY2FsbGJhY2spLFxuICAgICAgICBpZ25vcmU6IChsb2NrcywgY2FsbGJhY2spID0+IGlnbm9yZSQxKGxvY2tzLCBjYWxsYmFjayksXG4gICAgICAgIGV4dHJhOiAodW5kb01hbmFnZXIsIGluZGV4LCBjYWxsYmFjazEsIGNhbGxiYWNrMikgPT4gZXh0cmEkMShlZGl0b3IsIHVuZG9NYW5hZ2VyLCBpbmRleCwgY2FsbGJhY2sxLCBjYWxsYmFjazIpXG4gICAgICB9LFxuICAgICAgZm9ybWF0dGVyOiB7XG4gICAgICAgIG1hdGNoOiAobmFtZSwgdmFycywgbm9kZSwgc2ltaWxhcikgPT4gbWF0Y2gkMihlZGl0b3IsIG5hbWUsIHZhcnMsIG5vZGUsIHNpbWlsYXIpLFxuICAgICAgICBtYXRjaEFsbDogKG5hbWVzLCB2YXJzKSA9PiBtYXRjaEFsbChlZGl0b3IsIG5hbWVzLCB2YXJzKSxcbiAgICAgICAgbWF0Y2hOb2RlOiAobm9kZSwgbmFtZSwgdmFycywgc2ltaWxhcikgPT4gbWF0Y2hOb2RlKGVkaXRvciwgbm9kZSwgbmFtZSwgdmFycywgc2ltaWxhciksXG4gICAgICAgIGNhbkFwcGx5OiBuYW1lID0+IGNhbkFwcGx5KGVkaXRvciwgbmFtZSksXG4gICAgICAgIGNsb3Nlc3Q6IG5hbWVzID0+IGNsb3Nlc3QoZWRpdG9yLCBuYW1lcyksXG4gICAgICAgIGFwcGx5OiAobmFtZSwgdmFycywgbm9kZSkgPT4gYXBwbHlGb3JtYXQkMShlZGl0b3IsIG5hbWUsIHZhcnMsIG5vZGUpLFxuICAgICAgICByZW1vdmU6IChuYW1lLCB2YXJzLCBub2RlLCBzaW1pbGFyKSA9PiByZW1vdmUkMihlZGl0b3IsIG5hbWUsIHZhcnMsIG5vZGUsIHNpbWlsYXIpLFxuICAgICAgICB0b2dnbGU6IChuYW1lLCB2YXJzLCBub2RlKSA9PiB0b2dnbGUoZWRpdG9yLCBuYW1lLCB2YXJzLCBub2RlKSxcbiAgICAgICAgZm9ybWF0Q2hhbmdlZDogKHJlZ2lzdGVyZWRGb3JtYXRMaXN0ZW5lcnMsIGZvcm1hdHMsIGNhbGxiYWNrLCBzaW1pbGFyLCB2YXJzKSA9PiBmb3JtYXRDaGFuZ2VkSW50ZXJuYWwoZWRpdG9yLCByZWdpc3RlcmVkRm9ybWF0TGlzdGVuZXJzLCBmb3JtYXRzLCBjYWxsYmFjaywgc2ltaWxhciwgdmFycylcbiAgICAgIH0sXG4gICAgICBlZGl0b3I6IHtcbiAgICAgICAgZ2V0Q29udGVudDogYXJncyA9PiBnZXRDb250ZW50SW50ZXJuYWwoZWRpdG9yLCBhcmdzKSxcbiAgICAgICAgc2V0Q29udGVudDogKGNvbnRlbnQsIGFyZ3MpID0+IHNldENvbnRlbnRJbnRlcm5hbChlZGl0b3IsIGNvbnRlbnQsIGFyZ3MpLFxuICAgICAgICBpbnNlcnRDb250ZW50OiAodmFsdWUsIGRldGFpbHMpID0+IGluc2VydEh0bWxBdENhcmV0KGVkaXRvciwgdmFsdWUsIGRldGFpbHMpLFxuICAgICAgICBhZGRWaXN1YWw6IGVsbSA9PiBhZGRWaXN1YWxJbnRlcm5hbChlZGl0b3IsIGVsbSlcbiAgICAgIH0sXG4gICAgICBzZWxlY3Rpb246IHsgZ2V0Q29udGVudDogKGZvcm1hdCwgYXJncykgPT4gZ2V0U2VsZWN0ZWRDb250ZW50SW50ZXJuYWwoZWRpdG9yLCBmb3JtYXQsIGFyZ3MpIH0sXG4gICAgICBhdXRvY29tcGxldGVyOiB7XG4gICAgICAgIGFkZERlY29yYXRpb246IHJhbmdlID0+IGNyZWF0ZSQ5KGVkaXRvciwgcmFuZ2UpLFxuICAgICAgICByZW1vdmVEZWNvcmF0aW9uOiAoKSA9PiByZW1vdmUkMyhlZGl0b3IsIFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRCb2R5KCkpKVxuICAgICAgfSxcbiAgICAgIHJhdzogeyBnZXRNb2RlbDogKCkgPT4gT3B0aW9uYWwubm9uZSgpIH1cbiAgICB9KTtcbiAgICBjb25zdCBtYWtlUnRjQWRhcHRvciA9IHJ0Y0VkaXRvciA9PiB7XG4gICAgICBjb25zdCBkZWZhdWx0VmFycyA9IHZhcnMgPT4gaXNPYmplY3QodmFycykgPyB2YXJzIDoge307XG4gICAgICBjb25zdCB7aW5pdCwgdW5kb01hbmFnZXIsIGZvcm1hdHRlciwgZWRpdG9yLCBzZWxlY3Rpb24sIGF1dG9jb21wbGV0ZXIsIHJhd30gPSBydGNFZGl0b3I7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbml0OiB7IGJpbmRFdmVudHM6IGluaXQuYmluZEV2ZW50cyB9LFxuICAgICAgICB1bmRvTWFuYWdlcjoge1xuICAgICAgICAgIGJlZm9yZUNoYW5nZTogdW5kb01hbmFnZXIuYmVmb3JlQ2hhbmdlLFxuICAgICAgICAgIGFkZDogdW5kb01hbmFnZXIuYWRkLFxuICAgICAgICAgIHVuZG86IHVuZG9NYW5hZ2VyLnVuZG8sXG4gICAgICAgICAgcmVkbzogdW5kb01hbmFnZXIucmVkbyxcbiAgICAgICAgICBjbGVhcjogdW5kb01hbmFnZXIuY2xlYXIsXG4gICAgICAgICAgcmVzZXQ6IHVuZG9NYW5hZ2VyLnJlc2V0LFxuICAgICAgICAgIGhhc1VuZG86IHVuZG9NYW5hZ2VyLmhhc1VuZG8sXG4gICAgICAgICAgaGFzUmVkbzogdW5kb01hbmFnZXIuaGFzUmVkbyxcbiAgICAgICAgICB0cmFuc2FjdDogKF91bmRvTWFuYWdlciwgX2xvY2tzLCBmbikgPT4gdW5kb01hbmFnZXIudHJhbnNhY3QoZm4pLFxuICAgICAgICAgIGlnbm9yZTogKF9sb2NrcywgY2FsbGJhY2spID0+IHVuZG9NYW5hZ2VyLmlnbm9yZShjYWxsYmFjayksXG4gICAgICAgICAgZXh0cmE6IChfdW5kb01hbmFnZXIsIF9pbmRleCwgY2FsbGJhY2sxLCBjYWxsYmFjazIpID0+IHVuZG9NYW5hZ2VyLmV4dHJhKGNhbGxiYWNrMSwgY2FsbGJhY2syKVxuICAgICAgICB9LFxuICAgICAgICBmb3JtYXR0ZXI6IHtcbiAgICAgICAgICBtYXRjaDogKG5hbWUsIHZhcnMsIF9ub2RlLCBzaW1pbGFyKSA9PiBmb3JtYXR0ZXIubWF0Y2gobmFtZSwgZGVmYXVsdFZhcnModmFycyksIHNpbWlsYXIpLFxuICAgICAgICAgIG1hdGNoQWxsOiBmb3JtYXR0ZXIubWF0Y2hBbGwsXG4gICAgICAgICAgbWF0Y2hOb2RlOiBmb3JtYXR0ZXIubWF0Y2hOb2RlLFxuICAgICAgICAgIGNhbkFwcGx5OiBuYW1lID0+IGZvcm1hdHRlci5jYW5BcHBseShuYW1lKSxcbiAgICAgICAgICBjbG9zZXN0OiBuYW1lcyA9PiBmb3JtYXR0ZXIuY2xvc2VzdChuYW1lcyksXG4gICAgICAgICAgYXBwbHk6IChuYW1lLCB2YXJzLCBfbm9kZSkgPT4gZm9ybWF0dGVyLmFwcGx5KG5hbWUsIGRlZmF1bHRWYXJzKHZhcnMpKSxcbiAgICAgICAgICByZW1vdmU6IChuYW1lLCB2YXJzLCBfbm9kZSwgX3NpbWlsYXIpID0+IGZvcm1hdHRlci5yZW1vdmUobmFtZSwgZGVmYXVsdFZhcnModmFycykpLFxuICAgICAgICAgIHRvZ2dsZTogKG5hbWUsIHZhcnMsIF9ub2RlKSA9PiBmb3JtYXR0ZXIudG9nZ2xlKG5hbWUsIGRlZmF1bHRWYXJzKHZhcnMpKSxcbiAgICAgICAgICBmb3JtYXRDaGFuZ2VkOiAoX3JmbCwgZm9ybWF0cywgY2FsbGJhY2ssIHNpbWlsYXIsIHZhcnMpID0+IGZvcm1hdHRlci5mb3JtYXRDaGFuZ2VkKGZvcm1hdHMsIGNhbGxiYWNrLCBzaW1pbGFyLCB2YXJzKVxuICAgICAgICB9LFxuICAgICAgICBlZGl0b3I6IHtcbiAgICAgICAgICBnZXRDb250ZW50OiBhcmdzID0+IGVkaXRvci5nZXRDb250ZW50KGFyZ3MpLFxuICAgICAgICAgIHNldENvbnRlbnQ6IChjb250ZW50LCBhcmdzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBjb250ZW50OiBlZGl0b3Iuc2V0Q29udGVudChjb250ZW50LCBhcmdzKSxcbiAgICAgICAgICAgICAgaHRtbDogJydcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbnNlcnRDb250ZW50OiAoY29udGVudCwgX2RldGFpbHMpID0+IHtcbiAgICAgICAgICAgIGVkaXRvci5pbnNlcnRDb250ZW50KGNvbnRlbnQpO1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYWRkVmlzdWFsOiBlZGl0b3IuYWRkVmlzdWFsXG4gICAgICAgIH0sXG4gICAgICAgIHNlbGVjdGlvbjogeyBnZXRDb250ZW50OiAoX2Zvcm1hdCwgYXJncykgPT4gc2VsZWN0aW9uLmdldENvbnRlbnQoYXJncykgfSxcbiAgICAgICAgYXV0b2NvbXBsZXRlcjoge1xuICAgICAgICAgIGFkZERlY29yYXRpb246IGF1dG9jb21wbGV0ZXIuYWRkRGVjb3JhdGlvbixcbiAgICAgICAgICByZW1vdmVEZWNvcmF0aW9uOiBhdXRvY29tcGxldGVyLnJlbW92ZURlY29yYXRpb25cbiAgICAgICAgfSxcbiAgICAgICAgcmF3OiB7IGdldE1vZGVsOiAoKSA9PiBPcHRpb25hbC5zb21lKHJhdy5nZXRSYXdNb2RlbCgpKSB9XG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgbWFrZU5vb3BBZGFwdG9yID0gKCkgPT4ge1xuICAgICAgY29uc3QgbnVsID0gY29uc3RhbnQobnVsbCk7XG4gICAgICBjb25zdCBlbXB0eSA9IGNvbnN0YW50KCcnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluaXQ6IHsgYmluZEV2ZW50czogbm9vcCB9LFxuICAgICAgICB1bmRvTWFuYWdlcjoge1xuICAgICAgICAgIGJlZm9yZUNoYW5nZTogbm9vcCxcbiAgICAgICAgICBhZGQ6IG51bCxcbiAgICAgICAgICB1bmRvOiBudWwsXG4gICAgICAgICAgcmVkbzogbnVsLFxuICAgICAgICAgIGNsZWFyOiBub29wLFxuICAgICAgICAgIHJlc2V0OiBub29wLFxuICAgICAgICAgIGhhc1VuZG86IG5ldmVyLFxuICAgICAgICAgIGhhc1JlZG86IG5ldmVyLFxuICAgICAgICAgIHRyYW5zYWN0OiBudWwsXG4gICAgICAgICAgaWdub3JlOiBub29wLFxuICAgICAgICAgIGV4dHJhOiBub29wXG4gICAgICAgIH0sXG4gICAgICAgIGZvcm1hdHRlcjoge1xuICAgICAgICAgIG1hdGNoOiBuZXZlcixcbiAgICAgICAgICBtYXRjaEFsbDogY29uc3RhbnQoW10pLFxuICAgICAgICAgIG1hdGNoTm9kZTogY29uc3RhbnQodW5kZWZpbmVkKSxcbiAgICAgICAgICBjYW5BcHBseTogbmV2ZXIsXG4gICAgICAgICAgY2xvc2VzdDogZW1wdHksXG4gICAgICAgICAgYXBwbHk6IG5vb3AsXG4gICAgICAgICAgcmVtb3ZlOiBub29wLFxuICAgICAgICAgIHRvZ2dsZTogbm9vcCxcbiAgICAgICAgICBmb3JtYXRDaGFuZ2VkOiBjb25zdGFudCh7IHVuYmluZDogbm9vcCB9KVxuICAgICAgICB9LFxuICAgICAgICBlZGl0b3I6IHtcbiAgICAgICAgICBnZXRDb250ZW50OiBlbXB0eSxcbiAgICAgICAgICBzZXRDb250ZW50OiBjb25zdGFudCh7XG4gICAgICAgICAgICBjb250ZW50OiAnJyxcbiAgICAgICAgICAgIGh0bWw6ICcnXG4gICAgICAgICAgfSksXG4gICAgICAgICAgaW5zZXJ0Q29udGVudDogY29uc3RhbnQoJycpLFxuICAgICAgICAgIGFkZFZpc3VhbDogbm9vcFxuICAgICAgICB9LFxuICAgICAgICBzZWxlY3Rpb246IHsgZ2V0Q29udGVudDogZW1wdHkgfSxcbiAgICAgICAgYXV0b2NvbXBsZXRlcjoge1xuICAgICAgICAgIGFkZERlY29yYXRpb246IG5vb3AsXG4gICAgICAgICAgcmVtb3ZlRGVjb3JhdGlvbjogbm9vcFxuICAgICAgICB9LFxuICAgICAgICByYXc6IHsgZ2V0TW9kZWw6IGNvbnN0YW50KE9wdGlvbmFsLm5vbmUoKSkgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGlzUnRjID0gZWRpdG9yID0+IGhhcyQyKGVkaXRvci5wbHVnaW5zLCAncnRjJyk7XG4gICAgY29uc3QgZ2V0UnRjU2V0dXAgPSBlZGl0b3IgPT4gZ2V0JGEoZWRpdG9yLnBsdWdpbnMsICdydGMnKS5iaW5kKHJ0Y1BsdWdpbiA9PiBPcHRpb25hbC5mcm9tKHJ0Y1BsdWdpbi5zZXR1cCkpO1xuICAgIGNvbnN0IHNldHVwJHMgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgZWRpdG9yQ2FzdCA9IGVkaXRvcjtcbiAgICAgIHJldHVybiBnZXRSdGNTZXR1cChlZGl0b3IpLmZvbGQoKCkgPT4ge1xuICAgICAgICBlZGl0b3JDYXN0LnJ0Y0luc3RhbmNlID0gbWFrZVBsYWluQWRhcHRvcihlZGl0b3IpO1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfSwgc2V0dXAgPT4ge1xuICAgICAgICBlZGl0b3JDYXN0LnJ0Y0luc3RhbmNlID0gbWFrZU5vb3BBZGFwdG9yKCk7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKCgpID0+IHNldHVwKCkudGhlbihydGNFZGl0b3IgPT4ge1xuICAgICAgICAgIGVkaXRvckNhc3QucnRjSW5zdGFuY2UgPSBtYWtlUnRjQWRhcHRvcihydGNFZGl0b3IpO1xuICAgICAgICAgIHJldHVybiBydGNFZGl0b3IucnRjLmlzUmVtb3RlO1xuICAgICAgICB9KSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGdldFJ0Y0luc3RhbmNlV2l0aEZhbGxiYWNrID0gZWRpdG9yID0+IGVkaXRvci5ydGNJbnN0YW5jZSA/IGVkaXRvci5ydGNJbnN0YW5jZSA6IG1ha2VQbGFpbkFkYXB0b3IoZWRpdG9yKTtcbiAgICBjb25zdCBnZXRSdGNJbnN0YW5jZVdpdGhFcnJvciA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBydGNJbnN0YW5jZSA9IGVkaXRvci5ydGNJbnN0YW5jZTtcbiAgICAgIGlmICghcnRjSW5zdGFuY2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZ2V0IFJUQyBpbnN0YW5jZSBub3QgeWV0IGluaXRpYWxpemVkLicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJ0Y0luc3RhbmNlO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgYmVmb3JlQ2hhbmdlID0gKGVkaXRvciwgbG9ja3MsIGJlZm9yZUJvb2ttYXJrKSA9PiB7XG4gICAgICBnZXRSdGNJbnN0YW5jZVdpdGhFcnJvcihlZGl0b3IpLnVuZG9NYW5hZ2VyLmJlZm9yZUNoYW5nZShsb2NrcywgYmVmb3JlQm9va21hcmspO1xuICAgIH07XG4gICAgY29uc3QgYWRkVW5kb0xldmVsID0gKGVkaXRvciwgdW5kb01hbmFnZXIsIGluZGV4LCBsb2NrcywgYmVmb3JlQm9va21hcmssIGxldmVsLCBldmVudCkgPT4gZ2V0UnRjSW5zdGFuY2VXaXRoRXJyb3IoZWRpdG9yKS51bmRvTWFuYWdlci5hZGQodW5kb01hbmFnZXIsIGluZGV4LCBsb2NrcywgYmVmb3JlQm9va21hcmssIGxldmVsLCBldmVudCk7XG4gICAgY29uc3QgdW5kbyA9IChlZGl0b3IsIHVuZG9NYW5hZ2VyLCBsb2NrcywgaW5kZXgpID0+IGdldFJ0Y0luc3RhbmNlV2l0aEVycm9yKGVkaXRvcikudW5kb01hbmFnZXIudW5kbyh1bmRvTWFuYWdlciwgbG9ja3MsIGluZGV4KTtcbiAgICBjb25zdCByZWRvID0gKGVkaXRvciwgaW5kZXgsIGRhdGEpID0+IGdldFJ0Y0luc3RhbmNlV2l0aEVycm9yKGVkaXRvcikudW5kb01hbmFnZXIucmVkbyhpbmRleCwgZGF0YSk7XG4gICAgY29uc3QgY2xlYXIgPSAoZWRpdG9yLCB1bmRvTWFuYWdlciwgaW5kZXgpID0+IHtcbiAgICAgIGdldFJ0Y0luc3RhbmNlV2l0aEVycm9yKGVkaXRvcikudW5kb01hbmFnZXIuY2xlYXIodW5kb01hbmFnZXIsIGluZGV4KTtcbiAgICB9O1xuICAgIGNvbnN0IHJlc2V0ID0gKGVkaXRvciwgdW5kb01hbmFnZXIpID0+IHtcbiAgICAgIGdldFJ0Y0luc3RhbmNlV2l0aEVycm9yKGVkaXRvcikudW5kb01hbmFnZXIucmVzZXQodW5kb01hbmFnZXIpO1xuICAgIH07XG4gICAgY29uc3QgaGFzVW5kbyA9IChlZGl0b3IsIHVuZG9NYW5hZ2VyLCBpbmRleCkgPT4gZ2V0UnRjSW5zdGFuY2VXaXRoRXJyb3IoZWRpdG9yKS51bmRvTWFuYWdlci5oYXNVbmRvKHVuZG9NYW5hZ2VyLCBpbmRleCk7XG4gICAgY29uc3QgaGFzUmVkbyA9IChlZGl0b3IsIHVuZG9NYW5hZ2VyLCBpbmRleCkgPT4gZ2V0UnRjSW5zdGFuY2VXaXRoRXJyb3IoZWRpdG9yKS51bmRvTWFuYWdlci5oYXNSZWRvKHVuZG9NYW5hZ2VyLCBpbmRleCk7XG4gICAgY29uc3QgdHJhbnNhY3QgPSAoZWRpdG9yLCB1bmRvTWFuYWdlciwgbG9ja3MsIGNhbGxiYWNrKSA9PiBnZXRSdGNJbnN0YW5jZVdpdGhFcnJvcihlZGl0b3IpLnVuZG9NYW5hZ2VyLnRyYW5zYWN0KHVuZG9NYW5hZ2VyLCBsb2NrcywgY2FsbGJhY2spO1xuICAgIGNvbnN0IGlnbm9yZSA9IChlZGl0b3IsIGxvY2tzLCBjYWxsYmFjaykgPT4ge1xuICAgICAgZ2V0UnRjSW5zdGFuY2VXaXRoRXJyb3IoZWRpdG9yKS51bmRvTWFuYWdlci5pZ25vcmUobG9ja3MsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIGNvbnN0IGV4dHJhID0gKGVkaXRvciwgdW5kb01hbmFnZXIsIGluZGV4LCBjYWxsYmFjazEsIGNhbGxiYWNrMikgPT4ge1xuICAgICAgZ2V0UnRjSW5zdGFuY2VXaXRoRXJyb3IoZWRpdG9yKS51bmRvTWFuYWdlci5leHRyYSh1bmRvTWFuYWdlciwgaW5kZXgsIGNhbGxiYWNrMSwgY2FsbGJhY2syKTtcbiAgICB9O1xuICAgIGNvbnN0IG1hdGNoRm9ybWF0ID0gKGVkaXRvciwgbmFtZSwgdmFycywgbm9kZSwgc2ltaWxhcikgPT4gZ2V0UnRjSW5zdGFuY2VXaXRoRXJyb3IoZWRpdG9yKS5mb3JtYXR0ZXIubWF0Y2gobmFtZSwgdmFycywgbm9kZSwgc2ltaWxhcik7XG4gICAgY29uc3QgbWF0Y2hBbGxGb3JtYXRzID0gKGVkaXRvciwgbmFtZXMsIHZhcnMpID0+IGdldFJ0Y0luc3RhbmNlV2l0aEVycm9yKGVkaXRvcikuZm9ybWF0dGVyLm1hdGNoQWxsKG5hbWVzLCB2YXJzKTtcbiAgICBjb25zdCBtYXRjaE5vZGVGb3JtYXQgPSAoZWRpdG9yLCBub2RlLCBuYW1lLCB2YXJzLCBzaW1pbGFyKSA9PiBnZXRSdGNJbnN0YW5jZVdpdGhFcnJvcihlZGl0b3IpLmZvcm1hdHRlci5tYXRjaE5vZGUobm9kZSwgbmFtZSwgdmFycywgc2ltaWxhcik7XG4gICAgY29uc3QgY2FuQXBwbHlGb3JtYXQgPSAoZWRpdG9yLCBuYW1lKSA9PiBnZXRSdGNJbnN0YW5jZVdpdGhFcnJvcihlZGl0b3IpLmZvcm1hdHRlci5jYW5BcHBseShuYW1lKTtcbiAgICBjb25zdCBjbG9zZXN0Rm9ybWF0ID0gKGVkaXRvciwgbmFtZXMpID0+IGdldFJ0Y0luc3RhbmNlV2l0aEVycm9yKGVkaXRvcikuZm9ybWF0dGVyLmNsb3Nlc3QobmFtZXMpO1xuICAgIGNvbnN0IGFwcGx5Rm9ybWF0ID0gKGVkaXRvciwgbmFtZSwgdmFycywgbm9kZSkgPT4ge1xuICAgICAgZ2V0UnRjSW5zdGFuY2VXaXRoRXJyb3IoZWRpdG9yKS5mb3JtYXR0ZXIuYXBwbHkobmFtZSwgdmFycywgbm9kZSk7XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVGb3JtYXQgPSAoZWRpdG9yLCBuYW1lLCB2YXJzLCBub2RlLCBzaW1pbGFyKSA9PiB7XG4gICAgICBnZXRSdGNJbnN0YW5jZVdpdGhFcnJvcihlZGl0b3IpLmZvcm1hdHRlci5yZW1vdmUobmFtZSwgdmFycywgbm9kZSwgc2ltaWxhcik7XG4gICAgfTtcbiAgICBjb25zdCB0b2dnbGVGb3JtYXQgPSAoZWRpdG9yLCBuYW1lLCB2YXJzLCBub2RlKSA9PiB7XG4gICAgICBnZXRSdGNJbnN0YW5jZVdpdGhFcnJvcihlZGl0b3IpLmZvcm1hdHRlci50b2dnbGUobmFtZSwgdmFycywgbm9kZSk7XG4gICAgfTtcbiAgICBjb25zdCBmb3JtYXRDaGFuZ2VkID0gKGVkaXRvciwgcmVnaXN0ZXJlZEZvcm1hdExpc3RlbmVycywgZm9ybWF0cywgY2FsbGJhY2ssIHNpbWlsYXIsIHZhcnMpID0+IGdldFJ0Y0luc3RhbmNlV2l0aEVycm9yKGVkaXRvcikuZm9ybWF0dGVyLmZvcm1hdENoYW5nZWQocmVnaXN0ZXJlZEZvcm1hdExpc3RlbmVycywgZm9ybWF0cywgY2FsbGJhY2ssIHNpbWlsYXIsIHZhcnMpO1xuICAgIGNvbnN0IGdldENvbnRlbnQkMiA9IChlZGl0b3IsIGFyZ3MpID0+IGdldFJ0Y0luc3RhbmNlV2l0aEZhbGxiYWNrKGVkaXRvcikuZWRpdG9yLmdldENvbnRlbnQoYXJncyk7XG4gICAgY29uc3Qgc2V0Q29udGVudCQyID0gKGVkaXRvciwgY29udGVudCwgYXJncykgPT4gZ2V0UnRjSW5zdGFuY2VXaXRoRmFsbGJhY2soZWRpdG9yKS5lZGl0b3Iuc2V0Q29udGVudChjb250ZW50LCBhcmdzKTtcbiAgICBjb25zdCBpbnNlcnRDb250ZW50JDEgPSAoZWRpdG9yLCB2YWx1ZSwgZGV0YWlscykgPT4gZ2V0UnRjSW5zdGFuY2VXaXRoRmFsbGJhY2soZWRpdG9yKS5lZGl0b3IuaW5zZXJ0Q29udGVudCh2YWx1ZSwgZGV0YWlscyk7XG4gICAgY29uc3QgZ2V0U2VsZWN0ZWRDb250ZW50ID0gKGVkaXRvciwgZm9ybWF0LCBhcmdzKSA9PiBnZXRSdGNJbnN0YW5jZVdpdGhFcnJvcihlZGl0b3IpLnNlbGVjdGlvbi5nZXRDb250ZW50KGZvcm1hdCwgYXJncyk7XG4gICAgY29uc3QgYWRkVmlzdWFsJDEgPSAoZWRpdG9yLCBlbG0pID0+IGdldFJ0Y0luc3RhbmNlV2l0aEVycm9yKGVkaXRvcikuZWRpdG9yLmFkZFZpc3VhbChlbG0pO1xuICAgIGNvbnN0IGJpbmRFdmVudHMgPSBlZGl0b3IgPT4gZ2V0UnRjSW5zdGFuY2VXaXRoRXJyb3IoZWRpdG9yKS5pbml0LmJpbmRFdmVudHMoKTtcbiAgICBjb25zdCBhZGRBdXRvY29tcGxldGVyRGVjb3JhdGlvbiA9IChlZGl0b3IsIHJhbmdlKSA9PiBnZXRSdGNJbnN0YW5jZVdpdGhFcnJvcihlZGl0b3IpLmF1dG9jb21wbGV0ZXIuYWRkRGVjb3JhdGlvbihyYW5nZSk7XG4gICAgY29uc3QgcmVtb3ZlQXV0b2NvbXBsZXRlckRlY29yYXRpb24gPSBlZGl0b3IgPT4gZ2V0UnRjSW5zdGFuY2VXaXRoRXJyb3IoZWRpdG9yKS5hdXRvY29tcGxldGVyLnJlbW92ZURlY29yYXRpb24oKTtcblxuICAgIGNvbnN0IGdldENvbnRlbnQkMSA9IChlZGl0b3IsIGFyZ3MgPSB7fSkgPT4ge1xuICAgICAgY29uc3QgZm9ybWF0ID0gYXJncy5mb3JtYXQgPyBhcmdzLmZvcm1hdCA6ICdodG1sJztcbiAgICAgIHJldHVybiBnZXRTZWxlY3RlZENvbnRlbnQoZWRpdG9yLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH07XG5cbiAgICBjb25zdCByZW1vdmVFbXB0eSA9IHRleHQgPT4ge1xuICAgICAgaWYgKHRleHQuZG9tLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZW1vdmUkNih0ZXh0KTtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKHRleHQpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgd2Fsa1Bhc3RCb29rbWFyayA9IChub2RlLCBzdGFydCkgPT4gbm9kZS5maWx0ZXIoZWxtID0+IEJvb2ttYXJrTWFuYWdlci5pc0Jvb2ttYXJrTm9kZShlbG0uZG9tKSkuYmluZChzdGFydCA/IG5leHRTaWJsaW5nIDogcHJldlNpYmxpbmcpO1xuICAgIGNvbnN0IG1lcmdlJDEgPSAob3V0ZXIsIGlubmVyLCBybmcsIHN0YXJ0KSA9PiB7XG4gICAgICBjb25zdCBvdXRlckVsbSA9IG91dGVyLmRvbTtcbiAgICAgIGNvbnN0IGlubmVyRWxtID0gaW5uZXIuZG9tO1xuICAgICAgY29uc3Qgb2xkTGVuZ3RoID0gc3RhcnQgPyBvdXRlckVsbS5sZW5ndGggOiBpbm5lckVsbS5sZW5ndGg7XG4gICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgbWVyZ2VUZXh0Tm9kZXMob3V0ZXJFbG0sIGlubmVyRWxtLCBmYWxzZSwgIXN0YXJ0KTtcbiAgICAgICAgcm5nLnNldFN0YXJ0KGlubmVyRWxtLCBvbGRMZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVyZ2VUZXh0Tm9kZXMoaW5uZXJFbG0sIG91dGVyRWxtLCBmYWxzZSwgIXN0YXJ0KTtcbiAgICAgICAgcm5nLnNldEVuZChpbm5lckVsbSwgb2xkTGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG5vcm1hbGl6ZVRleHRJZlJlcXVpcmVkID0gKGlubmVyLCBzdGFydCkgPT4ge1xuICAgICAgcGFyZW50KGlubmVyKS5lYWNoKHJvb3QgPT4ge1xuICAgICAgICBjb25zdCB0ZXh0ID0gaW5uZXIuZG9tO1xuICAgICAgICBpZiAoc3RhcnQgJiYgbmVlZHNUb0JlTmJzcExlZnQocm9vdCwgQ2FyZXRQb3NpdGlvbih0ZXh0LCAwKSkpIHtcbiAgICAgICAgICBub3JtYWxpemVXaGl0ZXNwYWNlQWZ0ZXIodGV4dCwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXN0YXJ0ICYmIG5lZWRzVG9CZU5ic3BSaWdodChyb290LCBDYXJldFBvc2l0aW9uKHRleHQsIHRleHQubGVuZ3RoKSkpIHtcbiAgICAgICAgICBub3JtYWxpemVXaGl0ZXNwYWNlQmVmb3JlKHRleHQsIHRleHQubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBtZXJnZUFuZE5vcm1hbGl6ZVRleHQgPSAob3V0ZXJOb2RlLCBpbm5lck5vZGUsIHJuZywgc3RhcnQpID0+IHtcbiAgICAgIG91dGVyTm9kZS5iaW5kKG91dGVyID0+IHtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplciA9IHN0YXJ0ID8gbm9ybWFsaXplV2hpdGVzcGFjZUJlZm9yZSA6IG5vcm1hbGl6ZVdoaXRlc3BhY2VBZnRlcjtcbiAgICAgICAgbm9ybWFsaXplcihvdXRlci5kb20sIHN0YXJ0ID8gb3V0ZXIuZG9tLmxlbmd0aCA6IDApO1xuICAgICAgICByZXR1cm4gaW5uZXJOb2RlLmZpbHRlcihpc1RleHQkYikubWFwKGlubmVyID0+IG1lcmdlJDEob3V0ZXIsIGlubmVyLCBybmcsIHN0YXJ0KSk7XG4gICAgICB9KS5vclRodW5rKCgpID0+IHtcbiAgICAgICAgY29uc3QgaW5uZXJUZXh0Tm9kZSA9IHdhbGtQYXN0Qm9va21hcmsoaW5uZXJOb2RlLCBzdGFydCkub3IoaW5uZXJOb2RlKS5maWx0ZXIoaXNUZXh0JGIpO1xuICAgICAgICByZXR1cm4gaW5uZXJUZXh0Tm9kZS5tYXAoaW5uZXIgPT4gbm9ybWFsaXplVGV4dElmUmVxdWlyZWQoaW5uZXIsIHN0YXJ0KSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHJuZ1NldENvbnRlbnQgPSAocm5nLCBmcmFnbWVudCkgPT4ge1xuICAgICAgY29uc3QgZmlyc3RDaGlsZCA9IE9wdGlvbmFsLmZyb20oZnJhZ21lbnQuZmlyc3RDaGlsZCkubWFwKFN1Z2FyRWxlbWVudC5mcm9tRG9tKTtcbiAgICAgIGNvbnN0IGxhc3RDaGlsZCA9IE9wdGlvbmFsLmZyb20oZnJhZ21lbnQubGFzdENoaWxkKS5tYXAoU3VnYXJFbGVtZW50LmZyb21Eb20pO1xuICAgICAgcm5nLmRlbGV0ZUNvbnRlbnRzKCk7XG4gICAgICBybmcuaW5zZXJ0Tm9kZShmcmFnbWVudCk7XG4gICAgICBjb25zdCBwcmV2VGV4dCA9IGZpcnN0Q2hpbGQuYmluZChwcmV2U2libGluZykuZmlsdGVyKGlzVGV4dCRiKS5iaW5kKHJlbW92ZUVtcHR5KTtcbiAgICAgIGNvbnN0IG5leHRUZXh0ID0gbGFzdENoaWxkLmJpbmQobmV4dFNpYmxpbmcpLmZpbHRlcihpc1RleHQkYikuYmluZChyZW1vdmVFbXB0eSk7XG4gICAgICBtZXJnZUFuZE5vcm1hbGl6ZVRleHQocHJldlRleHQsIGZpcnN0Q2hpbGQsIHJuZywgdHJ1ZSk7XG4gICAgICBtZXJnZUFuZE5vcm1hbGl6ZVRleHQobmV4dFRleHQsIGxhc3RDaGlsZCwgcm5nLCBmYWxzZSk7XG4gICAgICBybmcuY29sbGFwc2UoZmFsc2UpO1xuICAgIH07XG4gICAgY29uc3Qgc2V0dXBBcmdzJDIgPSAoYXJncywgY29udGVudCkgPT4gKHtcbiAgICAgIGZvcm1hdDogJ2h0bWwnLFxuICAgICAgLi4uYXJncyxcbiAgICAgIHNldDogdHJ1ZSxcbiAgICAgIHNlbGVjdGlvbjogdHJ1ZSxcbiAgICAgIGNvbnRlbnRcbiAgICB9KTtcbiAgICBjb25zdCBjbGVhbkNvbnRlbnQgPSAoZWRpdG9yLCBhcmdzKSA9PiB7XG4gICAgICBpZiAoYXJncy5mb3JtYXQgIT09ICdyYXcnKSB7XG4gICAgICAgIGNvbnN0IHJuZyA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICAgIGNvbnN0IGNvbnRleHRCbG9jayA9IGVkaXRvci5kb20uZ2V0UGFyZW50KHJuZy5jb21tb25BbmNlc3RvckNvbnRhaW5lciwgZWRpdG9yLmRvbS5pc0Jsb2NrKTtcbiAgICAgICAgY29uc3QgY29udGV4dEFyZ3MgPSBjb250ZXh0QmxvY2sgPyB7IGNvbnRleHQ6IGNvbnRleHRCbG9jay5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIH0gOiB7fTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGVkaXRvci5wYXJzZXIucGFyc2UoYXJncy5jb250ZW50LCB7XG4gICAgICAgICAgZm9yY2VkX3Jvb3RfYmxvY2s6IGZhbHNlLFxuICAgICAgICAgIC4uLmNvbnRleHRBcmdzLFxuICAgICAgICAgIC4uLmFyZ3NcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBIdG1sU2VyaWFsaXplcih7IHZhbGlkYXRlOiBmYWxzZSB9LCBlZGl0b3Iuc2NoZW1hKS5zZXJpYWxpemUobm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYXJncy5jb250ZW50O1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc2V0Q29udGVudCQxID0gKGVkaXRvciwgY29udGVudCwgYXJncyA9IHt9KSA9PiB7XG4gICAgICBjb25zdCBkZWZhdWx0ZWRBcmdzID0gc2V0dXBBcmdzJDIoYXJncywgY29udGVudCk7XG4gICAgICBwcmVQcm9jZXNzU2V0Q29udGVudChlZGl0b3IsIGRlZmF1bHRlZEFyZ3MpLmVhY2godXBkYXRlZEFyZ3MgPT4ge1xuICAgICAgICBjb25zdCBjbGVhbmVkQ29udGVudCA9IGNsZWFuQ29udGVudChlZGl0b3IsIHVwZGF0ZWRBcmdzKTtcbiAgICAgICAgY29uc3Qgcm5nID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgICAgcm5nU2V0Q29udGVudChybmcsIHJuZy5jcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQoY2xlYW5lZENvbnRlbnQpKTtcbiAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRSbmcocm5nKTtcbiAgICAgICAgc2Nyb2xsUmFuZ2VJbnRvVmlldyhlZGl0b3IsIHJuZyk7XG4gICAgICAgIHBvc3RQcm9jZXNzU2V0Q29udGVudChlZGl0b3IsIGNsZWFuZWRDb250ZW50LCB1cGRhdGVkQXJncyk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgZGVsZXRlRnJvbUNhbGxiYWNrTWFwID0gKGNhbGxiYWNrTWFwLCBzZWxlY3RvciwgY2FsbGJhY2spID0+IHtcbiAgICAgIGlmIChoYXMkMihjYWxsYmFja01hcCwgc2VsZWN0b3IpKSB7XG4gICAgICAgIGNvbnN0IG5ld0NhbGxiYWNrcyA9IGZpbHRlciQ1KGNhbGxiYWNrTWFwW3NlbGVjdG9yXSwgY2IgPT4gY2IgIT09IGNhbGxiYWNrKTtcbiAgICAgICAgaWYgKG5ld0NhbGxiYWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBkZWxldGUgY2FsbGJhY2tNYXBbc2VsZWN0b3JdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrTWFwW3NlbGVjdG9yXSA9IG5ld0NhbGxiYWNrcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdmFyIFNlbGVjdG9yQ2hhbmdlZCA9IChkb20sIGVkaXRvcikgPT4ge1xuICAgICAgbGV0IHNlbGVjdG9yQ2hhbmdlZERhdGE7XG4gICAgICBsZXQgY3VycmVudFNlbGVjdG9ycztcbiAgICAgIGNvbnN0IGZpbmRNYXRjaGluZ05vZGUgPSAoc2VsZWN0b3IsIG5vZGVzKSA9PiBmaW5kJDIobm9kZXMsIG5vZGUgPT4gZG9tLmlzKG5vZGUsIHNlbGVjdG9yKSk7XG4gICAgICBjb25zdCBnZXRQYXJlbnRzID0gZWxlbSA9PiBkb20uZ2V0UGFyZW50cyhlbGVtLCB1bmRlZmluZWQsIGRvbS5nZXRSb290KCkpO1xuICAgICAgY29uc3Qgc2V0dXAgPSAoKSA9PiB7XG4gICAgICAgIHNlbGVjdG9yQ2hhbmdlZERhdGEgPSB7fTtcbiAgICAgICAgY3VycmVudFNlbGVjdG9ycyA9IHt9O1xuICAgICAgICBlZGl0b3Iub24oJ05vZGVDaGFuZ2UnLCBlID0+IHtcbiAgICAgICAgICBjb25zdCBub2RlID0gZS5lbGVtZW50O1xuICAgICAgICAgIGNvbnN0IHBhcmVudHMgPSBnZXRQYXJlbnRzKG5vZGUpO1xuICAgICAgICAgIGNvbnN0IG1hdGNoZWRTZWxlY3RvcnMgPSB7fTtcbiAgICAgICAgICBlYWNoJGQoc2VsZWN0b3JDaGFuZ2VkRGF0YSwgKGNhbGxiYWNrcywgc2VsZWN0b3IpID0+IHtcbiAgICAgICAgICAgIGZpbmRNYXRjaGluZ05vZGUoc2VsZWN0b3IsIHBhcmVudHMpLmVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICAgIGlmICghY3VycmVudFNlbGVjdG9yc1tzZWxlY3Rvcl0pIHtcbiAgICAgICAgICAgICAgICBlYWNoJGUoY2FsbGJhY2tzLCBjYWxsYmFjayA9PiB7XG4gICAgICAgICAgICAgICAgICBjYWxsYmFjayh0cnVlLCB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRzXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjdXJyZW50U2VsZWN0b3JzW3NlbGVjdG9yXSA9IGNhbGxiYWNrcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBtYXRjaGVkU2VsZWN0b3JzW3NlbGVjdG9yXSA9IGNhbGxiYWNrcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGVhY2gkZChjdXJyZW50U2VsZWN0b3JzLCAoY2FsbGJhY2tzLCBzZWxlY3RvcikgPT4ge1xuICAgICAgICAgICAgaWYgKCFtYXRjaGVkU2VsZWN0b3JzW3NlbGVjdG9yXSkge1xuICAgICAgICAgICAgICBkZWxldGUgY3VycmVudFNlbGVjdG9yc1tzZWxlY3Rvcl07XG4gICAgICAgICAgICAgIGVhY2gkZShjYWxsYmFja3MsIGNhbGxiYWNrID0+IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhmYWxzZSwge1xuICAgICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICAgIHNlbGVjdG9yLFxuICAgICAgICAgICAgICAgICAgcGFyZW50c1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2VsZWN0b3JDaGFuZ2VkV2l0aFVuYmluZDogKHNlbGVjdG9yLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgIGlmICghc2VsZWN0b3JDaGFuZ2VkRGF0YSkge1xuICAgICAgICAgICAgc2V0dXAoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFzZWxlY3RvckNoYW5nZWREYXRhW3NlbGVjdG9yXSkge1xuICAgICAgICAgICAgc2VsZWN0b3JDaGFuZ2VkRGF0YVtzZWxlY3Rvcl0gPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZWN0b3JDaGFuZ2VkRGF0YVtzZWxlY3Rvcl0ucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgZmluZE1hdGNoaW5nTm9kZShzZWxlY3RvciwgZ2V0UGFyZW50cyhlZGl0b3Iuc2VsZWN0aW9uLmdldFN0YXJ0KCkpKS5lYWNoKCgpID0+IHtcbiAgICAgICAgICAgIGN1cnJlbnRTZWxlY3RvcnNbc2VsZWN0b3JdID0gc2VsZWN0b3JDaGFuZ2VkRGF0YVtzZWxlY3Rvcl07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVuYmluZDogKCkgPT4ge1xuICAgICAgICAgICAgICBkZWxldGVGcm9tQ2FsbGJhY2tNYXAoc2VsZWN0b3JDaGFuZ2VkRGF0YSwgc2VsZWN0b3IsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgZGVsZXRlRnJvbUNhbGxiYWNrTWFwKGN1cnJlbnRTZWxlY3RvcnMsIHNlbGVjdG9yLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgaXNBdHRhY2hlZFRvRG9tID0gbm9kZSA9PiB7XG4gICAgICByZXR1cm4gISEobm9kZSAmJiBub2RlLm93bmVyRG9jdW1lbnQpICYmIGNvbnRhaW5zKFN1Z2FyRWxlbWVudC5mcm9tRG9tKG5vZGUub3duZXJEb2N1bWVudCksIFN1Z2FyRWxlbWVudC5mcm9tRG9tKG5vZGUpKTtcbiAgICB9O1xuICAgIGNvbnN0IGlzVmFsaWRSYW5nZSA9IHJuZyA9PiB7XG4gICAgICBpZiAoIXJuZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaXNBdHRhY2hlZFRvRG9tKHJuZy5zdGFydENvbnRhaW5lcikgJiYgaXNBdHRhY2hlZFRvRG9tKHJuZy5lbmRDb250YWluZXIpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgRWRpdG9yU2VsZWN0aW9uID0gKGRvbSwgd2luLCBzZXJpYWxpemVyLCBlZGl0b3IpID0+IHtcbiAgICAgIGxldCBzZWxlY3RlZFJhbmdlO1xuICAgICAgbGV0IGV4cGxpY2l0UmFuZ2U7XG4gICAgICBjb25zdCB7c2VsZWN0b3JDaGFuZ2VkV2l0aFVuYmluZH0gPSBTZWxlY3RvckNoYW5nZWQoZG9tLCBlZGl0b3IpO1xuICAgICAgY29uc3Qgc2V0Q3Vyc29yTG9jYXRpb24gPSAobm9kZSwgb2Zmc2V0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJuZyA9IGRvbS5jcmVhdGVSbmcoKTtcbiAgICAgICAgaWYgKGlzTm9uTnVsbGFibGUobm9kZSkgJiYgaXNOb25OdWxsYWJsZShvZmZzZXQpKSB7XG4gICAgICAgICAgcm5nLnNldFN0YXJ0KG5vZGUsIG9mZnNldCk7XG4gICAgICAgICAgcm5nLnNldEVuZChub2RlLCBvZmZzZXQpO1xuICAgICAgICAgIHNldFJuZyhybmcpO1xuICAgICAgICAgIGNvbGxhcHNlKGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb3ZlRW5kUG9pbnQoZG9tLCBybmcsIGVkaXRvci5nZXRCb2R5KCksIHRydWUpO1xuICAgICAgICAgIHNldFJuZyhybmcpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0Q29udGVudCA9IGFyZ3MgPT4gZ2V0Q29udGVudCQxKGVkaXRvciwgYXJncyk7XG4gICAgICBjb25zdCBzZXRDb250ZW50ID0gKGNvbnRlbnQsIGFyZ3MpID0+IHNldENvbnRlbnQkMShlZGl0b3IsIGNvbnRlbnQsIGFyZ3MpO1xuICAgICAgY29uc3QgZ2V0U3RhcnQkMSA9IHJlYWwgPT4gZ2V0U3RhcnQoZWRpdG9yLmdldEJvZHkoKSwgZ2V0Um5nJDEoKSwgcmVhbCk7XG4gICAgICBjb25zdCBnZXRFbmQgPSByZWFsID0+IGdldEVuZCQxKGVkaXRvci5nZXRCb2R5KCksIGdldFJuZyQxKCksIHJlYWwpO1xuICAgICAgY29uc3QgZ2V0Qm9va21hcmsgPSAodHlwZSwgbm9ybWFsaXplZCkgPT4gYm9va21hcmtNYW5hZ2VyLmdldEJvb2ttYXJrKHR5cGUsIG5vcm1hbGl6ZWQpO1xuICAgICAgY29uc3QgbW92ZVRvQm9va21hcmsgPSBib29rbWFyayA9PiBib29rbWFya01hbmFnZXIubW92ZVRvQm9va21hcmsoYm9va21hcmspO1xuICAgICAgY29uc3Qgc2VsZWN0JDEgPSAobm9kZSwgY29udGVudCkgPT4ge1xuICAgICAgICBzZWxlY3QoZG9tLCBub2RlLCBjb250ZW50KS5lYWNoKHNldFJuZyk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzQ29sbGFwc2VkID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBybmcgPSBnZXRSbmckMSgpLCBzZWwgPSBnZXRTZWwoKTtcbiAgICAgICAgaWYgKCFybmcgfHwgcm5nLml0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJuZy5jb21wYXJlRW5kUG9pbnRzKSB7XG4gICAgICAgICAgcmV0dXJuIHJuZy5jb21wYXJlRW5kUG9pbnRzKCdTdGFydFRvRW5kJywgcm5nKSA9PT0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXNlbCB8fCBybmcuY29sbGFwc2VkO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzRWRpdGFibGUgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJuZyA9IGdldFJuZyQxKCk7XG4gICAgICAgIGNvbnN0IGZha2VTZWxlY3RlZEVsZW1lbnRzID0gZWRpdG9yLmdldEJvZHkoKS5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1tY2Utc2VsZWN0ZWQ9XCIxXCJdJyk7XG4gICAgICAgIGlmIChmYWtlU2VsZWN0ZWRFbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIGZvcmFsbChmYWtlU2VsZWN0ZWRFbGVtZW50cywgZWwgPT4gZG9tLmlzRWRpdGFibGUoZWwucGFyZW50RWxlbWVudCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHJuZy5zdGFydENvbnRhaW5lciA9PT0gcm5nLmVuZENvbnRhaW5lcikge1xuICAgICAgICAgIHJldHVybiBkb20uaXNFZGl0YWJsZShybmcuc3RhcnRDb250YWluZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBkb20uaXNFZGl0YWJsZShybmcuc3RhcnRDb250YWluZXIpICYmIGRvbS5pc0VkaXRhYmxlKHJuZy5lbmRDb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgY29sbGFwc2UgPSB0b1N0YXJ0ID0+IHtcbiAgICAgICAgY29uc3Qgcm5nID0gZ2V0Um5nJDEoKTtcbiAgICAgICAgcm5nLmNvbGxhcHNlKCEhdG9TdGFydCk7XG4gICAgICAgIHNldFJuZyhybmcpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldFNlbCA9ICgpID0+IHdpbi5nZXRTZWxlY3Rpb24gPyB3aW4uZ2V0U2VsZWN0aW9uKCkgOiB3aW4uZG9jdW1lbnQuc2VsZWN0aW9uO1xuICAgICAgY29uc3QgZ2V0Um5nJDEgPSAoKSA9PiB7XG4gICAgICAgIGxldCBybmc7XG4gICAgICAgIGNvbnN0IHRyeUNvbXBhcmVCb3VuZGFyeVBvaW50cyA9IChob3csIHNvdXJjZVJhbmdlLCBkZXN0aW5hdGlvblJhbmdlKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2VSYW5nZS5jb21wYXJlQm91bmRhcnlQb2ludHMoaG93LCBkZXN0aW5hdGlvblJhbmdlKTtcbiAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZG9jID0gd2luLmRvY3VtZW50O1xuICAgICAgICBpZiAoaXNOb25OdWxsYWJsZShlZGl0b3IuYm9va21hcmspICYmICFoYXNGb2N1cyhlZGl0b3IpKSB7XG4gICAgICAgICAgY29uc3QgYm9va21hcmsgPSBnZXRSbmcoZWRpdG9yKTtcbiAgICAgICAgICBpZiAoYm9va21hcmsuaXNTb21lKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBib29rbWFyay5tYXAociA9PiBwcm9jZXNzUmFuZ2VzKGVkaXRvciwgW3JdKVswXSkuZ2V0T3IoZG9jLmNyZWF0ZVJhbmdlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGdldFNlbCgpO1xuICAgICAgICAgIGlmIChzZWxlY3Rpb24gJiYgIWlzUmVzdHJpY3RlZE5vZGUoc2VsZWN0aW9uLmFuY2hvck5vZGUpKSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uLnJhbmdlQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgIHJuZyA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcm5nID0gZG9jLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBybmcgPSBwcm9jZXNzUmFuZ2VzKGVkaXRvciwgW3JuZ10pWzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJuZykge1xuICAgICAgICAgIHJuZyA9IGRvYy5jcmVhdGVSYW5nZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RvY3VtZW50JDEocm5nLnN0YXJ0Q29udGFpbmVyKSAmJiBybmcuY29sbGFwc2VkKSB7XG4gICAgICAgICAgY29uc3QgZWxtID0gZG9tLmdldFJvb3QoKTtcbiAgICAgICAgICBybmcuc2V0U3RhcnQoZWxtLCAwKTtcbiAgICAgICAgICBybmcuc2V0RW5kKGVsbSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGVjdGVkUmFuZ2UgJiYgZXhwbGljaXRSYW5nZSkge1xuICAgICAgICAgIGlmICh0cnlDb21wYXJlQm91bmRhcnlQb2ludHMocm5nLlNUQVJUX1RPX1NUQVJULCBybmcsIHNlbGVjdGVkUmFuZ2UpID09PSAwICYmIHRyeUNvbXBhcmVCb3VuZGFyeVBvaW50cyhybmcuRU5EX1RPX0VORCwgcm5nLCBzZWxlY3RlZFJhbmdlKSA9PT0gMCkge1xuICAgICAgICAgICAgcm5nID0gZXhwbGljaXRSYW5nZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZWN0ZWRSYW5nZSA9IG51bGw7XG4gICAgICAgICAgICBleHBsaWNpdFJhbmdlID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJuZztcbiAgICAgIH07XG4gICAgICBjb25zdCBzZXRSbmcgPSAocm5nLCBmb3J3YXJkKSA9PiB7XG4gICAgICAgIGlmICghaXNWYWxpZFJhbmdlKHJuZykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VsID0gZ2V0U2VsKCk7XG4gICAgICAgIGNvbnN0IGV2dCA9IGVkaXRvci5kaXNwYXRjaCgnU2V0U2VsZWN0aW9uUmFuZ2UnLCB7XG4gICAgICAgICAgcmFuZ2U6IHJuZyxcbiAgICAgICAgICBmb3J3YXJkXG4gICAgICAgIH0pO1xuICAgICAgICBybmcgPSBldnQucmFuZ2U7XG4gICAgICAgIGlmIChzZWwpIHtcbiAgICAgICAgICBleHBsaWNpdFJhbmdlID0gcm5nO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgICBzZWwuYWRkUmFuZ2Uocm5nKTtcbiAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZm9yd2FyZCA9PT0gZmFsc2UgJiYgc2VsLmV4dGVuZCkge1xuICAgICAgICAgICAgc2VsLmNvbGxhcHNlKHJuZy5lbmRDb250YWluZXIsIHJuZy5lbmRPZmZzZXQpO1xuICAgICAgICAgICAgc2VsLmV4dGVuZChybmcuc3RhcnRDb250YWluZXIsIHJuZy5zdGFydE9mZnNldCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGVjdGVkUmFuZ2UgPSBzZWwucmFuZ2VDb3VudCA+IDAgPyBzZWwuZ2V0UmFuZ2VBdCgwKSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFybmcuY29sbGFwc2VkICYmIHJuZy5zdGFydENvbnRhaW5lciA9PT0gcm5nLmVuZENvbnRhaW5lciAmJiAoc2VsID09PSBudWxsIHx8IHNlbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VsLnNldEJhc2VBbmRFeHRlbnQpKSB7XG4gICAgICAgICAgaWYgKHJuZy5lbmRPZmZzZXQgLSBybmcuc3RhcnRPZmZzZXQgPCAyKSB7XG4gICAgICAgICAgICBpZiAocm5nLnN0YXJ0Q29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgICAgICBjb25zdCBub2RlID0gcm5nLnN0YXJ0Q29udGFpbmVyLmNoaWxkTm9kZXNbcm5nLnN0YXJ0T2Zmc2V0XTtcbiAgICAgICAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS5ub2RlTmFtZSA9PT0gJ0lNRycpIHtcbiAgICAgICAgICAgICAgICBzZWwuc2V0QmFzZUFuZEV4dGVudChybmcuc3RhcnRDb250YWluZXIsIHJuZy5zdGFydE9mZnNldCwgcm5nLmVuZENvbnRhaW5lciwgcm5nLmVuZE9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbC5hbmNob3JOb2RlICE9PSBybmcuc3RhcnRDb250YWluZXIgfHwgc2VsLmZvY3VzTm9kZSAhPT0gcm5nLmVuZENvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgc2VsLnNldEJhc2VBbmRFeHRlbnQobm9kZSwgMCwgbm9kZSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVkaXRvci5kaXNwYXRjaCgnQWZ0ZXJTZXRTZWxlY3Rpb25SYW5nZScsIHtcbiAgICAgICAgICByYW5nZTogcm5nLFxuICAgICAgICAgIGZvcndhcmRcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2V0Tm9kZSA9IGVsbSA9PiB7XG4gICAgICAgIHNldENvbnRlbnQoZG9tLmdldE91dGVySFRNTChlbG0pKTtcbiAgICAgICAgcmV0dXJuIGVsbTtcbiAgICAgIH07XG4gICAgICBjb25zdCBnZXROb2RlJDEgPSAoKSA9PiBnZXROb2RlKGVkaXRvci5nZXRCb2R5KCksIGdldFJuZyQxKCkpO1xuICAgICAgY29uc3QgZ2V0U2VsZWN0ZWRCbG9ja3MkMSA9IChzdGFydEVsbSwgZW5kRWxtKSA9PiBnZXRTZWxlY3RlZEJsb2Nrcyhkb20sIGdldFJuZyQxKCksIHN0YXJ0RWxtLCBlbmRFbG0pO1xuICAgICAgY29uc3QgaXNGb3J3YXJkID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBzZWwgPSBnZXRTZWwoKTtcbiAgICAgICAgY29uc3QgYW5jaG9yTm9kZSA9IHNlbCA9PT0gbnVsbCB8fCBzZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlbC5hbmNob3JOb2RlO1xuICAgICAgICBjb25zdCBmb2N1c05vZGUgPSBzZWwgPT09IG51bGwgfHwgc2VsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWwuZm9jdXNOb2RlO1xuICAgICAgICBpZiAoIXNlbCB8fCAhYW5jaG9yTm9kZSB8fCAhZm9jdXNOb2RlIHx8IGlzUmVzdHJpY3RlZE5vZGUoYW5jaG9yTm9kZSkgfHwgaXNSZXN0cmljdGVkTm9kZShmb2N1c05vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYW5jaG9yUmFuZ2UgPSBkb20uY3JlYXRlUm5nKCk7XG4gICAgICAgIGNvbnN0IGZvY3VzUmFuZ2UgPSBkb20uY3JlYXRlUm5nKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYW5jaG9yUmFuZ2Uuc2V0U3RhcnQoYW5jaG9yTm9kZSwgc2VsLmFuY2hvck9mZnNldCk7XG4gICAgICAgICAgYW5jaG9yUmFuZ2UuY29sbGFwc2UodHJ1ZSk7XG4gICAgICAgICAgZm9jdXNSYW5nZS5zZXRTdGFydChmb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCk7XG4gICAgICAgICAgZm9jdXNSYW5nZS5jb2xsYXBzZSh0cnVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbmNob3JSYW5nZS5jb21wYXJlQm91bmRhcnlQb2ludHMoYW5jaG9yUmFuZ2UuU1RBUlRfVE9fU1RBUlQsIGZvY3VzUmFuZ2UpIDw9IDA7XG4gICAgICB9O1xuICAgICAgY29uc3Qgbm9ybWFsaXplID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBybmcgPSBnZXRSbmckMSgpO1xuICAgICAgICBjb25zdCBzZWwgPSBnZXRTZWwoKTtcbiAgICAgICAgaWYgKCFoYXNNdWx0aXBsZVJhbmdlcyhzZWwpICYmIGhhc0FueVJhbmdlcyhlZGl0b3IpKSB7XG4gICAgICAgICAgY29uc3Qgbm9ybVJuZyA9IG5vcm1hbGl6ZSQyKGRvbSwgcm5nKTtcbiAgICAgICAgICBub3JtUm5nLmVhY2gobm9ybVJuZyA9PiB7XG4gICAgICAgICAgICBzZXRSbmcobm9ybVJuZywgaXNGb3J3YXJkKCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBub3JtUm5nLmdldE9yKHJuZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJuZztcbiAgICAgIH07XG4gICAgICBjb25zdCBzZWxlY3RvckNoYW5nZWQgPSAoc2VsZWN0b3IsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIHNlbGVjdG9yQ2hhbmdlZFdpdGhVbmJpbmQoc2VsZWN0b3IsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHM7XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0U2Nyb2xsQ29udGFpbmVyID0gKCkgPT4ge1xuICAgICAgICBsZXQgc2Nyb2xsQ29udGFpbmVyO1xuICAgICAgICBsZXQgbm9kZSA9IGRvbS5nZXRSb290KCk7XG4gICAgICAgIHdoaWxlIChub2RlICYmIG5vZGUubm9kZU5hbWUgIT09ICdCT0RZJykge1xuICAgICAgICAgIGlmIChub2RlLnNjcm9sbEhlaWdodCA+IG5vZGUuY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICBzY3JvbGxDb250YWluZXIgPSBub2RlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjcm9sbENvbnRhaW5lcjtcbiAgICAgIH07XG4gICAgICBjb25zdCBzY3JvbGxJbnRvVmlldyA9IChlbG0sIGFsaWduVG9Ub3ApID0+IHtcbiAgICAgICAgaWYgKGlzTm9uTnVsbGFibGUoZWxtKSkge1xuICAgICAgICAgIHNjcm9sbEVsZW1lbnRJbnRvVmlldyhlZGl0b3IsIGVsbSwgYWxpZ25Ub1RvcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2Nyb2xsUmFuZ2VJbnRvVmlldyhlZGl0b3IsIGdldFJuZyQxKCksIGFsaWduVG9Ub3ApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgcGxhY2VDYXJldEF0ID0gKGNsaWVudFgsIGNsaWVudFkpID0+IHNldFJuZyhmcm9tUG9pbnQoY2xpZW50WCwgY2xpZW50WSwgZWRpdG9yLmdldERvYygpKSk7XG4gICAgICBjb25zdCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJuZyA9IGdldFJuZyQxKCk7XG4gICAgICAgIHJldHVybiBybmcuY29sbGFwc2VkID8gQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChybmcpLmdldENsaWVudFJlY3RzKClbMF0gOiBybmcuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZGVzdHJveSA9ICgpID0+IHtcbiAgICAgICAgd2luID0gc2VsZWN0ZWRSYW5nZSA9IGV4cGxpY2l0UmFuZ2UgPSBudWxsO1xuICAgICAgICBjb250cm9sU2VsZWN0aW9uLmRlc3Ryb3koKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBleHBhbmQgPSAob3B0aW9ucyA9IHsgdHlwZTogJ3dvcmQnIH0pID0+IHNldFJuZyhSYW5nZVV0aWxzKGRvbSkuZXhwYW5kKGdldFJuZyQxKCksIG9wdGlvbnMpKTtcbiAgICAgIGNvbnN0IGV4cG9ydHMgPSB7XG4gICAgICAgIGRvbSxcbiAgICAgICAgd2luLFxuICAgICAgICBzZXJpYWxpemVyLFxuICAgICAgICBlZGl0b3IsXG4gICAgICAgIGV4cGFuZCxcbiAgICAgICAgY29sbGFwc2UsXG4gICAgICAgIHNldEN1cnNvckxvY2F0aW9uLFxuICAgICAgICBnZXRDb250ZW50LFxuICAgICAgICBzZXRDb250ZW50LFxuICAgICAgICBnZXRCb29rbWFyayxcbiAgICAgICAgbW92ZVRvQm9va21hcmssXG4gICAgICAgIHNlbGVjdDogc2VsZWN0JDEsXG4gICAgICAgIGlzQ29sbGFwc2VkLFxuICAgICAgICBpc0VkaXRhYmxlLFxuICAgICAgICBpc0ZvcndhcmQsXG4gICAgICAgIHNldE5vZGUsXG4gICAgICAgIGdldE5vZGU6IGdldE5vZGUkMSxcbiAgICAgICAgZ2V0U2VsLFxuICAgICAgICBzZXRSbmcsXG4gICAgICAgIGdldFJuZzogZ2V0Um5nJDEsXG4gICAgICAgIGdldFN0YXJ0OiBnZXRTdGFydCQxLFxuICAgICAgICBnZXRFbmQsXG4gICAgICAgIGdldFNlbGVjdGVkQmxvY2tzOiBnZXRTZWxlY3RlZEJsb2NrcyQxLFxuICAgICAgICBub3JtYWxpemUsXG4gICAgICAgIHNlbGVjdG9yQ2hhbmdlZCxcbiAgICAgICAgc2VsZWN0b3JDaGFuZ2VkV2l0aFVuYmluZCxcbiAgICAgICAgZ2V0U2Nyb2xsQ29udGFpbmVyLFxuICAgICAgICBzY3JvbGxJbnRvVmlldyxcbiAgICAgICAgcGxhY2VDYXJldEF0LFxuICAgICAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3QsXG4gICAgICAgIGRlc3Ryb3lcbiAgICAgIH07XG4gICAgICBjb25zdCBib29rbWFya01hbmFnZXIgPSBCb29rbWFya01hbmFnZXIoZXhwb3J0cyk7XG4gICAgICBjb25zdCBjb250cm9sU2VsZWN0aW9uID0gQ29udHJvbFNlbGVjdGlvbihleHBvcnRzLCBlZGl0b3IpO1xuICAgICAgZXhwb3J0cy5ib29rbWFya01hbmFnZXIgPSBib29rbWFya01hbmFnZXI7XG4gICAgICBleHBvcnRzLmNvbnRyb2xTZWxlY3Rpb24gPSBjb250cm9sU2VsZWN0aW9uO1xuICAgICAgcmV0dXJuIGV4cG9ydHM7XG4gICAgfTtcblxuICAgIGNvbnN0IHJlZ2lzdGVyJDMgPSAoaHRtbFBhcnNlciwgc2V0dGluZ3MsIGRvbSkgPT4ge1xuICAgICAgaHRtbFBhcnNlci5hZGRBdHRyaWJ1dGVGaWx0ZXIoJ2RhdGEtbWNlLXRhYmluZGV4JywgKG5vZGVzLCBuYW1lKSA9PiB7XG4gICAgICAgIGxldCBpID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgIG5vZGUuYXR0cigndGFiaW5kZXgnLCBub2RlLmF0dHIoJ2RhdGEtbWNlLXRhYmluZGV4JykpO1xuICAgICAgICAgIG5vZGUuYXR0cihuYW1lLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBodG1sUGFyc2VyLmFkZEF0dHJpYnV0ZUZpbHRlcignc3JjLGhyZWYsc3R5bGUnLCAobm9kZXMsIG5hbWUpID0+IHtcbiAgICAgICAgY29uc3QgaW50ZXJuYWxOYW1lID0gJ2RhdGEtbWNlLScgKyBuYW1lO1xuICAgICAgICBjb25zdCB1cmxDb252ZXJ0ZXIgPSBzZXR0aW5ncy51cmxfY29udmVydGVyO1xuICAgICAgICBjb25zdCB1cmxDb252ZXJ0ZXJTY29wZSA9IHNldHRpbmdzLnVybF9jb252ZXJ0ZXJfc2NvcGU7XG4gICAgICAgIGxldCBpID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgIGxldCB2YWx1ZSA9IG5vZGUuYXR0cihpbnRlcm5hbE5hbWUpO1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBub2RlLmF0dHIobmFtZSwgdmFsdWUubGVuZ3RoID4gMCA/IHZhbHVlIDogbnVsbCk7XG4gICAgICAgICAgICBub2RlLmF0dHIoaW50ZXJuYWxOYW1lLCBudWxsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBub2RlLmF0dHIobmFtZSk7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgICB2YWx1ZSA9IGRvbS5zZXJpYWxpemVTdHlsZShkb20ucGFyc2VTdHlsZSh2YWx1ZSksIG5vZGUubmFtZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHVybENvbnZlcnRlcikge1xuICAgICAgICAgICAgICB2YWx1ZSA9IHVybENvbnZlcnRlci5jYWxsKHVybENvbnZlcnRlclNjb3BlLCB2YWx1ZSwgbmFtZSwgbm9kZS5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUuYXR0cihuYW1lLCB2YWx1ZS5sZW5ndGggPiAwID8gdmFsdWUgOiBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaHRtbFBhcnNlci5hZGRBdHRyaWJ1dGVGaWx0ZXIoJ2NsYXNzJywgbm9kZXMgPT4ge1xuICAgICAgICBsZXQgaSA9IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICBsZXQgdmFsdWUgPSBub2RlLmF0dHIoJ2NsYXNzJyk7XG4gICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoLyg/Ol58XFxzKW1jZS1pdGVtLVxcdysoPyFcXFMpL2csICcnKTtcbiAgICAgICAgICAgIG5vZGUuYXR0cignY2xhc3MnLCB2YWx1ZS5sZW5ndGggPiAwID8gdmFsdWUgOiBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaHRtbFBhcnNlci5hZGRBdHRyaWJ1dGVGaWx0ZXIoJ2RhdGEtbWNlLXR5cGUnLCAobm9kZXMsIG5hbWUsIGFyZ3MpID0+IHtcbiAgICAgICAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgaWYgKG5vZGUuYXR0cignZGF0YS1tY2UtdHlwZScpID09PSAnYm9va21hcmsnICYmICFhcmdzLmNsZWFudXApIHtcbiAgICAgICAgICAgIGNvbnN0IGhhc0NoaWxkcmVuID0gT3B0aW9uYWwuZnJvbShub2RlLmZpcnN0Q2hpbGQpLmV4aXN0cyhmaXJzdENoaWxkID0+IHtcbiAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICByZXR1cm4gIWlzWndzcCgoX2EgPSBmaXJzdENoaWxkLnZhbHVlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChoYXNDaGlsZHJlbikge1xuICAgICAgICAgICAgICBub2RlLnVud3JhcCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaHRtbFBhcnNlci5hZGROb2RlRmlsdGVyKCdub3NjcmlwdCcsIG5vZGVzID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgaSA9IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXS5maXJzdENoaWxkO1xuICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBub2RlLnZhbHVlID0gRW50aXRpZXMuZGVjb2RlKChfYSA9IG5vZGUudmFsdWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaHRtbFBhcnNlci5hZGROb2RlRmlsdGVyKCdzY3JpcHQsc3R5bGUnLCAobm9kZXMsIG5hbWUpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB0cmltID0gdmFsdWUgPT4ge1xuICAgICAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC8oPCEtLVxcW0NEQVRBXFxbfFxcXVxcXS0tPikvZywgJ1xcbicpLnJlcGxhY2UoL15bXFxyXFxuXSp8W1xcclxcbl0qJC9nLCAnJykucmVwbGFjZSgvXlxccyooKDwhLS0pPyhcXHMqXFwvXFwvKT9cXHMqPCFcXFtDREFUQVxcW3woPCEtLVxccyopP1xcL1xcKlxccyo8IVxcW0NEQVRBXFxbXFxzKlxcKlxcL3woXFwvXFwvKT9cXHMqPCEtLXxcXC9cXCpcXHMqPCEtLVxccypcXCpcXC8pXFxzKltcXHJcXG5dKi9naSwgJycpLnJlcGxhY2UoL1xccyooXFwvXFwqXFxzKlxcXVxcXT5cXHMqXFwqXFwvKC0tPik/fFxccypcXC9cXC9cXHMqXFxdXFxdPigtLT4pP3xcXC9cXC9cXHMqKC0tPik/fFxcXVxcXT58XFwvXFwqXFxzKi0tPlxccypcXCpcXC98XFxzKi0tPlxccyopXFxzKiQvZywgJycpO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgaSA9IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICBjb25zdCBmaXJzdENoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gKF9hID0gZmlyc3RDaGlsZCA9PT0gbnVsbCB8fCBmaXJzdENoaWxkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaXJzdENoaWxkLnZhbHVlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJztcbiAgICAgICAgICBpZiAobmFtZSA9PT0gJ3NjcmlwdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBub2RlLmF0dHIoJ3R5cGUnKTtcbiAgICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICAgIG5vZGUuYXR0cigndHlwZScsIHR5cGUgPT09ICdtY2Utbm8vdHlwZScgPyBudWxsIDogdHlwZS5yZXBsYWNlKC9ebWNlXFwtLywgJycpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5lbGVtZW50X2Zvcm1hdCA9PT0gJ3hodG1sJyAmJiBmaXJzdENoaWxkICYmIHZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgZmlyc3RDaGlsZC52YWx1ZSA9ICcvLyA8IVtDREFUQVtcXG4nICsgdHJpbSh2YWx1ZSkgKyAnXFxuLy8gXV0+JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmVsZW1lbnRfZm9ybWF0ID09PSAneGh0bWwnICYmIGZpcnN0Q2hpbGQgJiYgdmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBmaXJzdENoaWxkLnZhbHVlID0gJzwhLS1cXG4nICsgdHJpbSh2YWx1ZSkgKyAnXFxuLS0+JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaHRtbFBhcnNlci5hZGROb2RlRmlsdGVyKCcjY29tbWVudCcsIG5vZGVzID0+IHtcbiAgICAgICAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBub2RlLnZhbHVlO1xuICAgICAgICAgIGlmIChzZXR0aW5ncy5wcmVzZXJ2ZV9jZGF0YSAmJiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlLmluZGV4T2YoJ1tDREFUQVsnKSkgPT09IDApIHtcbiAgICAgICAgICAgIG5vZGUubmFtZSA9ICcjY2RhdGEnO1xuICAgICAgICAgICAgbm9kZS50eXBlID0gNDtcbiAgICAgICAgICAgIG5vZGUudmFsdWUgPSBkb20uZGVjb2RlKHZhbHVlLnJlcGxhY2UoL15cXFtDREFUQVxcW3xcXF1cXF0kL2csICcnKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICgodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlLmluZGV4T2YoJ21jZTpwcm90ZWN0ZWQgJykpID09PSAwKSB7XG4gICAgICAgICAgICBub2RlLm5hbWUgPSAnI3RleHQnO1xuICAgICAgICAgICAgbm9kZS50eXBlID0gMztcbiAgICAgICAgICAgIG5vZGUucmF3ID0gdHJ1ZTtcbiAgICAgICAgICAgIG5vZGUudmFsdWUgPSB1bmVzY2FwZSh2YWx1ZSkuc3Vic3RyKDE0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaHRtbFBhcnNlci5hZGROb2RlRmlsdGVyKCd4bWw6bmFtZXNwYWNlLGlucHV0JywgKG5vZGVzLCBuYW1lKSA9PiB7XG4gICAgICAgIGxldCBpID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09IDcpIHtcbiAgICAgICAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnaW5wdXQnICYmICFub2RlLmF0dHIoJ3R5cGUnKSkge1xuICAgICAgICAgICAgICBub2RlLmF0dHIoJ3R5cGUnLCAndGV4dCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBodG1sUGFyc2VyLmFkZEF0dHJpYnV0ZUZpbHRlcignZGF0YS1tY2UtdHlwZScsIG5vZGVzID0+IHtcbiAgICAgICAgZWFjaCRlKG5vZGVzLCBub2RlID0+IHtcbiAgICAgICAgICBpZiAobm9kZS5hdHRyKCdkYXRhLW1jZS10eXBlJykgPT09ICdmb3JtYXQtY2FyZXQnKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5pc0VtcHR5KGh0bWxQYXJzZXIuc2NoZW1hLmdldE5vbkVtcHR5RWxlbWVudHMoKSkpIHtcbiAgICAgICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5vZGUudW53cmFwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgaHRtbFBhcnNlci5hZGRBdHRyaWJ1dGVGaWx0ZXIoJ2RhdGEtbWNlLXNyYyxkYXRhLW1jZS1ocmVmLGRhdGEtbWNlLXN0eWxlLCcgKyAnZGF0YS1tY2Utc2VsZWN0ZWQsZGF0YS1tY2UtZXhwYW5kbyxkYXRhLW1jZS1ibG9jaywnICsgJ2RhdGEtbWNlLXR5cGUsZGF0YS1tY2UtcmVzaXplLGRhdGEtbWNlLXBsYWNlaG9sZGVyJywgKG5vZGVzLCBuYW1lKSA9PiB7XG4gICAgICAgIGxldCBpID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgbm9kZXNbaV0uYXR0cihuYW1lLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCB0cmltVHJhaWxpbmdCciA9IHJvb3ROb2RlID0+IHtcbiAgICAgIGNvbnN0IGlzQnIgPSBub2RlID0+IHtcbiAgICAgICAgcmV0dXJuIChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGUubmFtZSkgPT09ICdicic7XG4gICAgICB9O1xuICAgICAgY29uc3QgYnJOb2RlMSA9IHJvb3ROb2RlLmxhc3RDaGlsZDtcbiAgICAgIGlmIChpc0JyKGJyTm9kZTEpKSB7XG4gICAgICAgIGNvbnN0IGJyTm9kZTIgPSBick5vZGUxLnByZXY7XG4gICAgICAgIGlmIChpc0JyKGJyTm9kZTIpKSB7XG4gICAgICAgICAgYnJOb2RlMS5yZW1vdmUoKTtcbiAgICAgICAgICBick5vZGUyLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHByZVByb2Nlc3MkMSA9IChlZGl0b3IsIG5vZGUsIGFyZ3MpID0+IHtcbiAgICAgIGxldCBvbGREb2M7XG4gICAgICBjb25zdCBkb20gPSBlZGl0b3IuZG9tO1xuICAgICAgbGV0IGNsb25lZE5vZGUgPSBub2RlLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgIGNvbnN0IGltcGwgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbjtcbiAgICAgIGlmIChpbXBsLmNyZWF0ZUhUTUxEb2N1bWVudCkge1xuICAgICAgICBjb25zdCBkb2MgPSBpbXBsLmNyZWF0ZUhUTUxEb2N1bWVudCgnJyk7XG4gICAgICAgIFRvb2xzLmVhY2goY2xvbmVkTm9kZS5ub2RlTmFtZSA9PT0gJ0JPRFknID8gY2xvbmVkTm9kZS5jaGlsZE5vZGVzIDogW2Nsb25lZE5vZGVdLCBub2RlID0+IHtcbiAgICAgICAgICBkb2MuYm9keS5hcHBlbmRDaGlsZChkb2MuaW1wb3J0Tm9kZShub2RlLCB0cnVlKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY2xvbmVkTm9kZS5ub2RlTmFtZSAhPT0gJ0JPRFknKSB7XG4gICAgICAgICAgY2xvbmVkTm9kZSA9IGRvYy5ib2R5LmZpcnN0Q2hpbGQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xvbmVkTm9kZSA9IGRvYy5ib2R5O1xuICAgICAgICB9XG4gICAgICAgIG9sZERvYyA9IGRvbS5kb2M7XG4gICAgICAgIGRvbS5kb2MgPSBkb2M7XG4gICAgICB9XG4gICAgICBmaXJlUHJlUHJvY2VzcyhlZGl0b3IsIHtcbiAgICAgICAgLi4uYXJncyxcbiAgICAgICAgbm9kZTogY2xvbmVkTm9kZVxuICAgICAgfSk7XG4gICAgICBpZiAob2xkRG9jKSB7XG4gICAgICAgIGRvbS5kb2MgPSBvbGREb2M7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2xvbmVkTm9kZTtcbiAgICB9O1xuICAgIGNvbnN0IHNob3VsZEZpcmVFdmVudCA9IChlZGl0b3IsIGFyZ3MpID0+IHtcbiAgICAgIHJldHVybiBpc05vbk51bGxhYmxlKGVkaXRvcikgJiYgZWRpdG9yLmhhc0V2ZW50TGlzdGVuZXJzKCdQcmVQcm9jZXNzJykgJiYgIWFyZ3Mubm9fZXZlbnRzO1xuICAgIH07XG4gICAgY29uc3QgcHJvY2VzcyQxID0gKGVkaXRvciwgbm9kZSwgYXJncykgPT4ge1xuICAgICAgcmV0dXJuIHNob3VsZEZpcmVFdmVudChlZGl0b3IsIGFyZ3MpID8gcHJlUHJvY2VzcyQxKGVkaXRvciwgbm9kZSwgYXJncykgOiBub2RlO1xuICAgIH07XG5cbiAgICBjb25zdCBhZGRUZW1wQXR0ciA9IChodG1sUGFyc2VyLCB0ZW1wQXR0cnMsIG5hbWUpID0+IHtcbiAgICAgIGlmIChUb29scy5pbkFycmF5KHRlbXBBdHRycywgbmFtZSkgPT09IC0xKSB7XG4gICAgICAgIGh0bWxQYXJzZXIuYWRkQXR0cmlidXRlRmlsdGVyKG5hbWUsIChub2RlcywgbmFtZSkgPT4ge1xuICAgICAgICAgIGxldCBpID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIG5vZGVzW2ldLmF0dHIobmFtZSwgbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGVtcEF0dHJzLnB1c2gobmFtZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBwb3N0UHJvY2VzcyA9IChlZGl0b3IsIGFyZ3MsIGNvbnRlbnQpID0+IHtcbiAgICAgIGlmICghYXJncy5ub19ldmVudHMgJiYgZWRpdG9yKSB7XG4gICAgICAgIGNvbnN0IG91dEFyZ3MgPSBmaXJlUG9zdFByb2Nlc3MoZWRpdG9yLCB7XG4gICAgICAgICAgLi4uYXJncyxcbiAgICAgICAgICBjb250ZW50XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb3V0QXJncy5jb250ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBnZXRIdG1sRnJvbU5vZGUgPSAoZG9tLCBub2RlLCBhcmdzKSA9PiB7XG4gICAgICBjb25zdCBodG1sID0gdHJpbSQxKGFyZ3MuZ2V0SW5uZXIgPyBub2RlLmlubmVySFRNTCA6IGRvbS5nZXRPdXRlckhUTUwobm9kZSkpO1xuICAgICAgcmV0dXJuIGFyZ3Muc2VsZWN0aW9uIHx8IGlzV3NQcmVzZXJ2ZUVsZW1lbnQoU3VnYXJFbGVtZW50LmZyb21Eb20obm9kZSkpID8gaHRtbCA6IFRvb2xzLnRyaW0oaHRtbCk7XG4gICAgfTtcbiAgICBjb25zdCBwYXJzZUh0bWwgPSAoaHRtbFBhcnNlciwgaHRtbCwgYXJncykgPT4ge1xuICAgICAgY29uc3QgcGFyc2VyQXJncyA9IGFyZ3Muc2VsZWN0aW9uID8ge1xuICAgICAgICBmb3JjZWRfcm9vdF9ibG9jazogZmFsc2UsXG4gICAgICAgIC4uLmFyZ3NcbiAgICAgIH0gOiBhcmdzO1xuICAgICAgY29uc3Qgcm9vdE5vZGUgPSBodG1sUGFyc2VyLnBhcnNlKGh0bWwsIHBhcnNlckFyZ3MpO1xuICAgICAgdHJpbVRyYWlsaW5nQnIocm9vdE5vZGUpO1xuICAgICAgcmV0dXJuIHJvb3ROb2RlO1xuICAgIH07XG4gICAgY29uc3Qgc2VyaWFsaXplTm9kZSA9IChzZXR0aW5ncywgc2NoZW1hLCBub2RlKSA9PiB7XG4gICAgICBjb25zdCBodG1sU2VyaWFsaXplciA9IEh0bWxTZXJpYWxpemVyKHNldHRpbmdzLCBzY2hlbWEpO1xuICAgICAgcmV0dXJuIGh0bWxTZXJpYWxpemVyLnNlcmlhbGl6ZShub2RlKTtcbiAgICB9O1xuICAgIGNvbnN0IHRvSHRtbCA9IChlZGl0b3IsIHNldHRpbmdzLCBzY2hlbWEsIHJvb3ROb2RlLCBhcmdzKSA9PiB7XG4gICAgICBjb25zdCBjb250ZW50ID0gc2VyaWFsaXplTm9kZShzZXR0aW5ncywgc2NoZW1hLCByb290Tm9kZSk7XG4gICAgICByZXR1cm4gcG9zdFByb2Nlc3MoZWRpdG9yLCBhcmdzLCBjb250ZW50KTtcbiAgICB9O1xuICAgIGNvbnN0IERvbVNlcmlhbGl6ZXJJbXBsID0gKHNldHRpbmdzLCBlZGl0b3IpID0+IHtcbiAgICAgIGNvbnN0IHRlbXBBdHRycyA9IFsnZGF0YS1tY2Utc2VsZWN0ZWQnXTtcbiAgICAgIGNvbnN0IGRvbSA9IGVkaXRvciAmJiBlZGl0b3IuZG9tID8gZWRpdG9yLmRvbSA6IERPTVV0aWxzLkRPTTtcbiAgICAgIGNvbnN0IHNjaGVtYSA9IGVkaXRvciAmJiBlZGl0b3Iuc2NoZW1hID8gZWRpdG9yLnNjaGVtYSA6IFNjaGVtYShzZXR0aW5ncyk7XG4gICAgICBzZXR0aW5ncy5lbnRpdHlfZW5jb2RpbmcgPSBzZXR0aW5ncy5lbnRpdHlfZW5jb2RpbmcgfHwgJ25hbWVkJztcbiAgICAgIHNldHRpbmdzLnJlbW92ZV90cmFpbGluZ19icnMgPSAncmVtb3ZlX3RyYWlsaW5nX2JycycgaW4gc2V0dGluZ3MgPyBzZXR0aW5ncy5yZW1vdmVfdHJhaWxpbmdfYnJzIDogdHJ1ZTtcbiAgICAgIGNvbnN0IGh0bWxQYXJzZXIgPSBEb21QYXJzZXIoc2V0dGluZ3MsIHNjaGVtYSk7XG4gICAgICByZWdpc3RlciQzKGh0bWxQYXJzZXIsIHNldHRpbmdzLCBkb20pO1xuICAgICAgY29uc3Qgc2VyaWFsaXplID0gKG5vZGUsIHBhcnNlckFyZ3MgPSB7fSkgPT4ge1xuICAgICAgICBjb25zdCBhcmdzID0ge1xuICAgICAgICAgIGZvcm1hdDogJ2h0bWwnLFxuICAgICAgICAgIC4uLnBhcnNlckFyZ3NcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdGFyZ2V0Tm9kZSA9IHByb2Nlc3MkMShlZGl0b3IsIG5vZGUsIGFyZ3MpO1xuICAgICAgICBjb25zdCBodG1sID0gZ2V0SHRtbEZyb21Ob2RlKGRvbSwgdGFyZ2V0Tm9kZSwgYXJncyk7XG4gICAgICAgIGNvbnN0IHJvb3ROb2RlID0gcGFyc2VIdG1sKGh0bWxQYXJzZXIsIGh0bWwsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gYXJncy5mb3JtYXQgPT09ICd0cmVlJyA/IHJvb3ROb2RlIDogdG9IdG1sKGVkaXRvciwgc2V0dGluZ3MsIHNjaGVtYSwgcm9vdE5vZGUsIGFyZ3MpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgYWRkTm9kZUZpbHRlcjogaHRtbFBhcnNlci5hZGROb2RlRmlsdGVyLFxuICAgICAgICBhZGRBdHRyaWJ1dGVGaWx0ZXI6IGh0bWxQYXJzZXIuYWRkQXR0cmlidXRlRmlsdGVyLFxuICAgICAgICBzZXJpYWxpemU6IHNlcmlhbGl6ZSxcbiAgICAgICAgYWRkUnVsZXM6IHNjaGVtYS5hZGRWYWxpZEVsZW1lbnRzLFxuICAgICAgICBzZXRSdWxlczogc2NoZW1hLnNldFZhbGlkRWxlbWVudHMsXG4gICAgICAgIGFkZFRlbXBBdHRyOiBjdXJyeShhZGRUZW1wQXR0ciwgaHRtbFBhcnNlciwgdGVtcEF0dHJzKSxcbiAgICAgICAgZ2V0VGVtcEF0dHJzOiBjb25zdGFudCh0ZW1wQXR0cnMpLFxuICAgICAgICBnZXROb2RlRmlsdGVyczogaHRtbFBhcnNlci5nZXROb2RlRmlsdGVycyxcbiAgICAgICAgZ2V0QXR0cmlidXRlRmlsdGVyczogaHRtbFBhcnNlci5nZXRBdHRyaWJ1dGVGaWx0ZXJzLFxuICAgICAgICByZW1vdmVOb2RlRmlsdGVyOiBodG1sUGFyc2VyLnJlbW92ZU5vZGVGaWx0ZXIsXG4gICAgICAgIHJlbW92ZUF0dHJpYnV0ZUZpbHRlcjogaHRtbFBhcnNlci5yZW1vdmVBdHRyaWJ1dGVGaWx0ZXJcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IERvbVNlcmlhbGl6ZXIgPSAoc2V0dGluZ3MsIGVkaXRvcikgPT4ge1xuICAgICAgY29uc3QgZG9tU2VyaWFsaXplciA9IERvbVNlcmlhbGl6ZXJJbXBsKHNldHRpbmdzLCBlZGl0b3IpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2NoZW1hOiBkb21TZXJpYWxpemVyLnNjaGVtYSxcbiAgICAgICAgYWRkTm9kZUZpbHRlcjogZG9tU2VyaWFsaXplci5hZGROb2RlRmlsdGVyLFxuICAgICAgICBhZGRBdHRyaWJ1dGVGaWx0ZXI6IGRvbVNlcmlhbGl6ZXIuYWRkQXR0cmlidXRlRmlsdGVyLFxuICAgICAgICBzZXJpYWxpemU6IGRvbVNlcmlhbGl6ZXIuc2VyaWFsaXplLFxuICAgICAgICBhZGRSdWxlczogZG9tU2VyaWFsaXplci5hZGRSdWxlcyxcbiAgICAgICAgc2V0UnVsZXM6IGRvbVNlcmlhbGl6ZXIuc2V0UnVsZXMsXG4gICAgICAgIGFkZFRlbXBBdHRyOiBkb21TZXJpYWxpemVyLmFkZFRlbXBBdHRyLFxuICAgICAgICBnZXRUZW1wQXR0cnM6IGRvbVNlcmlhbGl6ZXIuZ2V0VGVtcEF0dHJzLFxuICAgICAgICBnZXROb2RlRmlsdGVyczogZG9tU2VyaWFsaXplci5nZXROb2RlRmlsdGVycyxcbiAgICAgICAgZ2V0QXR0cmlidXRlRmlsdGVyczogZG9tU2VyaWFsaXplci5nZXRBdHRyaWJ1dGVGaWx0ZXJzLFxuICAgICAgICByZW1vdmVOb2RlRmlsdGVyOiBkb21TZXJpYWxpemVyLnJlbW92ZU5vZGVGaWx0ZXIsXG4gICAgICAgIHJlbW92ZUF0dHJpYnV0ZUZpbHRlcjogZG9tU2VyaWFsaXplci5yZW1vdmVBdHRyaWJ1dGVGaWx0ZXJcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IGRlZmF1bHRGb3JtYXQkMSA9ICdodG1sJztcbiAgICBjb25zdCBzZXR1cEFyZ3MkMSA9IChhcmdzLCBmb3JtYXQpID0+ICh7XG4gICAgICAuLi5hcmdzLFxuICAgICAgZm9ybWF0LFxuICAgICAgZ2V0OiB0cnVlLFxuICAgICAgZ2V0SW5uZXI6IHRydWVcbiAgICB9KTtcbiAgICBjb25zdCBnZXRDb250ZW50ID0gKGVkaXRvciwgYXJncyA9IHt9KSA9PiB7XG4gICAgICBjb25zdCBmb3JtYXQgPSBhcmdzLmZvcm1hdCA/IGFyZ3MuZm9ybWF0IDogZGVmYXVsdEZvcm1hdCQxO1xuICAgICAgY29uc3QgZGVmYXVsdGVkQXJncyA9IHNldHVwQXJncyQxKGFyZ3MsIGZvcm1hdCk7XG4gICAgICByZXR1cm4gcHJlUHJvY2Vzc0dldENvbnRlbnQoZWRpdG9yLCBkZWZhdWx0ZWRBcmdzKS5mb2xkKGlkZW50aXR5LCB1cGRhdGVkQXJncyA9PiB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBnZXRDb250ZW50JDIoZWRpdG9yLCB1cGRhdGVkQXJncyk7XG4gICAgICAgIHJldHVybiBwb3N0UHJvY2Vzc0dldENvbnRlbnQoZWRpdG9yLCBjb250ZW50LCB1cGRhdGVkQXJncyk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgZGVmYXVsdEZvcm1hdCA9ICdodG1sJztcbiAgICBjb25zdCBzZXR1cEFyZ3MgPSAoYXJncywgY29udGVudCkgPT4gKHtcbiAgICAgIGZvcm1hdDogZGVmYXVsdEZvcm1hdCxcbiAgICAgIC4uLmFyZ3MsXG4gICAgICBzZXQ6IHRydWUsXG4gICAgICBjb250ZW50XG4gICAgfSk7XG4gICAgY29uc3Qgc2V0Q29udGVudCA9IChlZGl0b3IsIGNvbnRlbnQsIGFyZ3MgPSB7fSkgPT4ge1xuICAgICAgY29uc3QgZGVmYXVsdGVkQXJncyA9IHNldHVwQXJncyhhcmdzLCBjb250ZW50KTtcbiAgICAgIHJldHVybiBwcmVQcm9jZXNzU2V0Q29udGVudChlZGl0b3IsIGRlZmF1bHRlZEFyZ3MpLm1hcCh1cGRhdGVkQXJncyA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHNldENvbnRlbnQkMihlZGl0b3IsIHVwZGF0ZWRBcmdzLmNvbnRlbnQsIHVwZGF0ZWRBcmdzKTtcbiAgICAgICAgcG9zdFByb2Nlc3NTZXRDb250ZW50KGVkaXRvciwgcmVzdWx0Lmh0bWwsIHVwZGF0ZWRBcmdzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5jb250ZW50O1xuICAgICAgfSkuZ2V0T3IoY29udGVudCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHJlbW92ZWRPcHRpb25zID0gKCdhdXRvcmVzaXplX29uX2luaXQsY29udGVudF9lZGl0YWJsZV9zdGF0ZSxwYWRkX2VtcHR5X3dpdGhfYnIsYmxvY2tfZWxlbWVudHMsJyArICdib29sZWFuX2F0dHJpYnV0ZXMsZWRpdG9yX2Rlc2VsZWN0b3IsZWRpdG9yX3NlbGVjdG9yLGVsZW1lbnRzLGZpbGVfYnJvd3Nlcl9jYWxsYmFja190eXBlcyxmaWxlcGlja2VyX3ZhbGlkYXRvcl9oYW5kbGVyLCcgKyAnZm9yY2VfaGV4X3N0eWxlX2NvbG9ycyxmb3JjZV9wX25ld2xpbmVzLGdlY2tvX3NwZWxsY2hlY2ssaW1hZ2VzX2RhdGFpbWdfZmlsdGVyLG1lZGlhX3NjcmlwdHMsbW9kZSxtb3ZlX2NhcmV0X2JlZm9yZV9vbl9lbnRlcl9lbGVtZW50cywnICsgJ25vbl9lbXB0eV9lbGVtZW50cyxzZWxmX2Nsb3NpbmdfZWxlbWVudHMsc2hvcnRfZW5kZWRfZWxlbWVudHMsc3BlY2lhbCxzcGVsbGNoZWNrZXJfc2VsZWN0X2xhbmd1YWdlcyxzcGVsbGNoZWNrZXJfd2hpdGVsaXN0LCcgKyAndGFiX2ZvY3VzLHRhYmZvY3VzX2VsZW1lbnRzLHRhYmxlX3Jlc3BvbnNpdmVfd2lkdGgsdGV4dF9ibG9ja19lbGVtZW50cyx0ZXh0X2lubGluZV9lbGVtZW50cyx0b29sYmFyX2RyYXdlcix0eXBlcyx2YWxpZGF0ZSx3aGl0ZXNwYWNlX2VsZW1lbnRzLCcgKyAncGFzdGVfZW5hYmxlX2RlZmF1bHRfZmlsdGVycyxwYXN0ZV9maWx0ZXJfZHJvcCxwYXN0ZV93b3JkX3ZhbGlkX2VsZW1lbnRzLHBhc3RlX3JldGFpbl9zdHlsZV9wcm9wZXJ0aWVzLHBhc3RlX2NvbnZlcnRfd29yZF9mYWtlX2xpc3RzJykuc3BsaXQoJywnKTtcbiAgICBjb25zdCBkZXByZWNhdGVkT3B0aW9ucyA9ICd0ZW1wbGF0ZV9jZGF0ZV9jbGFzc2VzLHRlbXBsYXRlX21kYXRlX2NsYXNzZXMsdGVtcGxhdGVfc2VsZWN0ZWRfY29udGVudF9jbGFzc2VzLHRlbXBsYXRlX3ByZXZpZXdfcmVwbGFjZV92YWx1ZXMsdGVtcGxhdGVfcmVwbGFjZV92YWx1ZXMsdGVtcGxhdGVzLHRlbXBsYXRlX2NkYXRlX2Zvcm1hdCx0ZW1wbGF0ZV9tZGF0ZV9mb3JtYXQnLnNwbGl0KCcsJyk7XG4gICAgY29uc3QgcmVtb3ZlZFBsdWdpbnMgPSAnYmJjb2RlLGNvbG9ycGlja2VyLGNvbnRleHRtZW51LGZ1bGxwYWdlLGxlZ2FjeW91dHB1dCxzcGVsbGNoZWNrZXIsdGV4dGNvbG9yJy5zcGxpdCgnLCcpO1xuICAgIGNvbnN0IGRlcHJlY2F0ZWRQbHVnaW5zID0gW3tcbiAgICAgICAgbmFtZTogJ3RlbXBsYXRlJyxcbiAgICAgICAgcmVwbGFjZWRXaXRoOiAnQWR2YW5jZWQgVGVtcGxhdGUnXG4gICAgICB9XTtcbiAgICBjb25zdCBnZXRNYXRjaGluZ09wdGlvbnMgPSAob3B0aW9ucywgc2VhcmNoaW5nRm9yKSA9PiB7XG4gICAgICBjb25zdCBzZXR0aW5nTmFtZXMgPSBmaWx0ZXIkNShzZWFyY2hpbmdGb3IsIHNldHRpbmcgPT4gaGFzJDIob3B0aW9ucywgc2V0dGluZykpO1xuICAgICAgcmV0dXJuIHNvcnQoc2V0dGluZ05hbWVzKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldFJlbW92ZWRPcHRpb25zID0gb3B0aW9ucyA9PiB7XG4gICAgICBjb25zdCBzZXR0aW5nTmFtZXMgPSBnZXRNYXRjaGluZ09wdGlvbnMob3B0aW9ucywgcmVtb3ZlZE9wdGlvbnMpO1xuICAgICAgY29uc3QgZm9yY2VkUm9vdEJsb2NrID0gb3B0aW9ucy5mb3JjZWRfcm9vdF9ibG9jaztcbiAgICAgIGlmIChmb3JjZWRSb290QmxvY2sgPT09IGZhbHNlIHx8IGZvcmNlZFJvb3RCbG9jayA9PT0gJycpIHtcbiAgICAgICAgc2V0dGluZ05hbWVzLnB1c2goJ2ZvcmNlZF9yb290X2Jsb2NrIChmYWxzZSBvbmx5KScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNvcnQoc2V0dGluZ05hbWVzKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldERlcHJlY2F0ZWRPcHRpb25zID0gb3B0aW9ucyA9PiBnZXRNYXRjaGluZ09wdGlvbnMob3B0aW9ucywgZGVwcmVjYXRlZE9wdGlvbnMpO1xuICAgIGNvbnN0IGdldE1hdGNoaW5nUGx1Z2lucyA9IChvcHRpb25zLCBzZWFyY2hpbmdGb3IpID0+IHtcbiAgICAgIGNvbnN0IHBsdWdpbnMgPSBUb29scy5tYWtlTWFwKG9wdGlvbnMucGx1Z2lucywgJyAnKTtcbiAgICAgIGNvbnN0IGhhc1BsdWdpbiA9IHBsdWdpbiA9PiBoYXMkMihwbHVnaW5zLCBwbHVnaW4pO1xuICAgICAgY29uc3QgcGx1Z2luTmFtZXMgPSBmaWx0ZXIkNShzZWFyY2hpbmdGb3IsIGhhc1BsdWdpbik7XG4gICAgICByZXR1cm4gc29ydChwbHVnaW5OYW1lcyk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRSZW1vdmVkUGx1Z2lucyA9IG9wdGlvbnMgPT4gZ2V0TWF0Y2hpbmdQbHVnaW5zKG9wdGlvbnMsIHJlbW92ZWRQbHVnaW5zKTtcbiAgICBjb25zdCBnZXREZXByZWNhdGVkUGx1Z2lucyA9IG9wdGlvbnMgPT4gZ2V0TWF0Y2hpbmdQbHVnaW5zKG9wdGlvbnMsIGRlcHJlY2F0ZWRQbHVnaW5zLm1hcChlbnRyeSA9PiBlbnRyeS5uYW1lKSk7XG4gICAgY29uc3QgbG9nUmVtb3ZlZFdhcm5pbmdzID0gKHJhd09wdGlvbnMsIG5vcm1hbGl6ZWRPcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCByZW1vdmVkT3B0aW9ucyA9IGdldFJlbW92ZWRPcHRpb25zKHJhd09wdGlvbnMpO1xuICAgICAgY29uc3QgcmVtb3ZlZFBsdWdpbnMgPSBnZXRSZW1vdmVkUGx1Z2lucyhub3JtYWxpemVkT3B0aW9ucyk7XG4gICAgICBjb25zdCBoYXNSZW1vdmVkUGx1Z2lucyA9IHJlbW92ZWRQbHVnaW5zLmxlbmd0aCA+IDA7XG4gICAgICBjb25zdCBoYXNSZW1vdmVkT3B0aW9ucyA9IHJlbW92ZWRPcHRpb25zLmxlbmd0aCA+IDA7XG4gICAgICBjb25zdCBpc0xlZ2FjeU1vYmlsZVRoZW1lID0gbm9ybWFsaXplZE9wdGlvbnMudGhlbWUgPT09ICdtb2JpbGUnO1xuICAgICAgaWYgKGhhc1JlbW92ZWRQbHVnaW5zIHx8IGhhc1JlbW92ZWRPcHRpb25zIHx8IGlzTGVnYWN5TW9iaWxlVGhlbWUpIHtcbiAgICAgICAgY29uc3QgbGlzdEpvaW5lciA9ICdcXG4tICc7XG4gICAgICAgIGNvbnN0IHRoZW1lc01lc3NhZ2UgPSBpc0xlZ2FjeU1vYmlsZVRoZW1lID8gYFxcblxcblRoZW1lczokeyBsaXN0Sm9pbmVyIH1tb2JpbGVgIDogJyc7XG4gICAgICAgIGNvbnN0IHBsdWdpbnNNZXNzYWdlID0gaGFzUmVtb3ZlZFBsdWdpbnMgPyBgXFxuXFxuUGx1Z2luczokeyBsaXN0Sm9pbmVyIH0keyByZW1vdmVkUGx1Z2lucy5qb2luKGxpc3RKb2luZXIpIH1gIDogJyc7XG4gICAgICAgIGNvbnN0IG9wdGlvbnNNZXNzYWdlID0gaGFzUmVtb3ZlZE9wdGlvbnMgPyBgXFxuXFxuT3B0aW9uczokeyBsaXN0Sm9pbmVyIH0keyByZW1vdmVkT3B0aW9ucy5qb2luKGxpc3RKb2luZXIpIH1gIDogJyc7XG4gICAgICAgIGNvbnNvbGUud2FybignVGhlIGZvbGxvd2luZyBkZXByZWNhdGVkIGZlYXR1cmVzIGFyZSBjdXJyZW50bHkgZW5hYmxlZCBhbmQgaGF2ZSBiZWVuIHJlbW92ZWQgaW4gVGlueU1DRSA2LjAuIFRoZXNlIGZlYXR1cmVzIHdpbGwgbm8gbG9uZ2VyIHdvcmsgYW5kIHNob3VsZCBiZSByZW1vdmVkIGZyb20gdGhlIFRpbnlNQ0UgY29uZmlndXJhdGlvbi4gJyArICdTZWUgaHR0cHM6Ly93d3cudGlueS5jbG91ZC9kb2NzL3RpbnltY2UvNi9taWdyYXRpb24tZnJvbS01eC8gZm9yIG1vcmUgaW5mb3JtYXRpb24uJyArIHRoZW1lc01lc3NhZ2UgKyBwbHVnaW5zTWVzc2FnZSArIG9wdGlvbnNNZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGdldFBsdWdpbkRlc2NyaXB0aW9uID0gbmFtZSA9PiBmaW5kJDIoZGVwcmVjYXRlZFBsdWdpbnMsIGVudHJ5ID0+IGVudHJ5Lm5hbWUgPT09IG5hbWUpLmZvbGQoKCkgPT4gbmFtZSwgZW50cnkgPT4gYCR7IG5hbWUgfSwgcmVwbGFjZWQgYnkgJHsgZW50cnkucmVwbGFjZWRXaXRoIH1gKTtcbiAgICBjb25zdCBsb2dEZXByZWNhdGVkV2FybmluZ3MgPSAocmF3T3B0aW9ucywgbm9ybWFsaXplZE9wdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IGRlcHJlY2F0ZWRPcHRpb25zID0gZ2V0RGVwcmVjYXRlZE9wdGlvbnMocmF3T3B0aW9ucyk7XG4gICAgICBjb25zdCBkZXByZWNhdGVkUGx1Z2lucyA9IGdldERlcHJlY2F0ZWRQbHVnaW5zKG5vcm1hbGl6ZWRPcHRpb25zKTtcbiAgICAgIGNvbnN0IGhhc0RlcHJlY2F0ZWRQbHVnaW5zID0gZGVwcmVjYXRlZFBsdWdpbnMubGVuZ3RoID4gMDtcbiAgICAgIGNvbnN0IGhhc0RlcHJlY2F0ZWRPcHRpb25zID0gZGVwcmVjYXRlZE9wdGlvbnMubGVuZ3RoID4gMDtcbiAgICAgIGlmIChoYXNEZXByZWNhdGVkUGx1Z2lucyB8fCBoYXNEZXByZWNhdGVkT3B0aW9ucykge1xuICAgICAgICBjb25zdCBsaXN0Sm9pbmVyID0gJ1xcbi0gJztcbiAgICAgICAgY29uc3QgcGx1Z2luc01lc3NhZ2UgPSBoYXNEZXByZWNhdGVkUGx1Z2lucyA/IGBcXG5cXG5QbHVnaW5zOiR7IGxpc3RKb2luZXIgfSR7IGRlcHJlY2F0ZWRQbHVnaW5zLm1hcChnZXRQbHVnaW5EZXNjcmlwdGlvbikuam9pbihsaXN0Sm9pbmVyKSB9YCA6ICcnO1xuICAgICAgICBjb25zdCBvcHRpb25zTWVzc2FnZSA9IGhhc0RlcHJlY2F0ZWRPcHRpb25zID8gYFxcblxcbk9wdGlvbnM6JHsgbGlzdEpvaW5lciB9JHsgZGVwcmVjYXRlZE9wdGlvbnMuam9pbihsaXN0Sm9pbmVyKSB9YCA6ICcnO1xuICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBmb2xsb3dpbmcgZGVwcmVjYXRlZCBmZWF0dXJlcyBhcmUgY3VycmVudGx5IGVuYWJsZWQgYnV0IHdpbGwgYmUgcmVtb3ZlZCBzb29uLicgKyBwbHVnaW5zTWVzc2FnZSArIG9wdGlvbnNNZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGxvZ1dhcm5pbmdzID0gKHJhd09wdGlvbnMsIG5vcm1hbGl6ZWRPcHRpb25zKSA9PiB7XG4gICAgICBsb2dSZW1vdmVkV2FybmluZ3MocmF3T3B0aW9ucywgbm9ybWFsaXplZE9wdGlvbnMpO1xuICAgICAgbG9nRGVwcmVjYXRlZFdhcm5pbmdzKHJhd09wdGlvbnMsIG5vcm1hbGl6ZWRPcHRpb25zKTtcbiAgICB9O1xuXG4gICAgY29uc3QgRE9NJDggPSBET01VdGlscy5ET007XG4gICAgY29uc3QgcmVzdG9yZU9yaWdpbmFsU3R5bGVzID0gZWRpdG9yID0+IHtcbiAgICAgIERPTSQ4LnNldFN0eWxlKGVkaXRvci5pZCwgJ2Rpc3BsYXknLCBlZGl0b3Iub3JnRGlzcGxheSk7XG4gICAgfTtcbiAgICBjb25zdCBzYWZlRGVzdHJveSA9IHggPT4gT3B0aW9uYWwuZnJvbSh4KS5lYWNoKHggPT4geC5kZXN0cm95KCkpO1xuICAgIGNvbnN0IGNsZWFyRG9tUmVmZXJlbmNlcyA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBlZCA9IGVkaXRvcjtcbiAgICAgIGVkLmNvbnRlbnRBcmVhQ29udGFpbmVyID0gZWQuZm9ybUVsZW1lbnQgPSBlZC5jb250YWluZXIgPSBlZC5lZGl0b3JDb250YWluZXIgPSBudWxsO1xuICAgICAgZWQuYm9keUVsZW1lbnQgPSBlZC5jb250ZW50RG9jdW1lbnQgPSBlZC5jb250ZW50V2luZG93ID0gbnVsbDtcbiAgICAgIGVkLmlmcmFtZUVsZW1lbnQgPSBlZC50YXJnZXRFbG0gPSBudWxsO1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgY29uc3QgZG9tID0gc2VsZWN0aW9uLmRvbTtcbiAgICAgICAgZWQuc2VsZWN0aW9uID0gc2VsZWN0aW9uLndpbiA9IHNlbGVjdGlvbi5kb20gPSBkb20uZG9jID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlc3RvcmVGb3JtID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGZvcm0gPSBlZGl0b3IuZm9ybUVsZW1lbnQ7XG4gICAgICBpZiAoZm9ybSkge1xuICAgICAgICBpZiAoZm9ybS5fbWNlT2xkU3VibWl0KSB7XG4gICAgICAgICAgZm9ybS5zdWJtaXQgPSBmb3JtLl9tY2VPbGRTdWJtaXQ7XG4gICAgICAgICAgZGVsZXRlIGZvcm0uX21jZU9sZFN1Ym1pdDtcbiAgICAgICAgfVxuICAgICAgICBET00kOC51bmJpbmQoZm9ybSwgJ3N1Ym1pdCByZXNldCcsIGVkaXRvci5mb3JtRXZlbnREZWxlZ2F0ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmUkMSA9IGVkaXRvciA9PiB7XG4gICAgICBpZiAoIWVkaXRvci5yZW1vdmVkKSB7XG4gICAgICAgIGNvbnN0IHtfc2VsZWN0aW9uT3ZlcnJpZGVzLCBlZGl0b3JVcGxvYWR9ID0gZWRpdG9yO1xuICAgICAgICBjb25zdCBib2R5ID0gZWRpdG9yLmdldEJvZHkoKTtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGVkaXRvci5nZXRFbGVtZW50KCk7XG4gICAgICAgIGlmIChib2R5KSB7XG4gICAgICAgICAgZWRpdG9yLnNhdmUoeyBpc19yZW1vdmluZzogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlZGl0b3IucmVtb3ZlZCA9IHRydWU7XG4gICAgICAgIGVkaXRvci51bmJpbmRBbGxOYXRpdmVFdmVudHMoKTtcbiAgICAgICAgaWYgKGVkaXRvci5oYXNIaWRkZW5JbnB1dCAmJiBpc05vbk51bGxhYmxlKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWxlbWVudC5uZXh0U2libGluZykpIHtcbiAgICAgICAgICBET00kOC5yZW1vdmUoZWxlbWVudC5uZXh0U2libGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgZmlyZVJlbW92ZShlZGl0b3IpO1xuICAgICAgICBlZGl0b3IuZWRpdG9yTWFuYWdlci5yZW1vdmUoZWRpdG9yKTtcbiAgICAgICAgaWYgKCFlZGl0b3IuaW5saW5lICYmIGJvZHkpIHtcbiAgICAgICAgICByZXN0b3JlT3JpZ2luYWxTdHlsZXMoZWRpdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBmaXJlRGV0YWNoKGVkaXRvcik7XG4gICAgICAgIERPTSQ4LnJlbW92ZShlZGl0b3IuZ2V0Q29udGFpbmVyKCkpO1xuICAgICAgICBzYWZlRGVzdHJveShfc2VsZWN0aW9uT3ZlcnJpZGVzKTtcbiAgICAgICAgc2FmZURlc3Ryb3koZWRpdG9yVXBsb2FkKTtcbiAgICAgICAgZWRpdG9yLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGRlc3Ryb3kgPSAoZWRpdG9yLCBhdXRvbWF0aWMpID0+IHtcbiAgICAgIGNvbnN0IHtzZWxlY3Rpb24sIGRvbX0gPSBlZGl0b3I7XG4gICAgICBpZiAoZWRpdG9yLmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWF1dG9tYXRpYyAmJiAhZWRpdG9yLnJlbW92ZWQpIHtcbiAgICAgICAgZWRpdG9yLnJlbW92ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWF1dG9tYXRpYykge1xuICAgICAgICBlZGl0b3IuZWRpdG9yTWFuYWdlci5vZmYoJ2JlZm9yZXVubG9hZCcsIGVkaXRvci5fYmVmb3JlVW5sb2FkKTtcbiAgICAgICAgaWYgKGVkaXRvci50aGVtZSAmJiBlZGl0b3IudGhlbWUuZGVzdHJveSkge1xuICAgICAgICAgIGVkaXRvci50aGVtZS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgc2FmZURlc3Ryb3koc2VsZWN0aW9uKTtcbiAgICAgICAgc2FmZURlc3Ryb3koZG9tKTtcbiAgICAgIH1cbiAgICAgIHJlc3RvcmVGb3JtKGVkaXRvcik7XG4gICAgICBjbGVhckRvbVJlZmVyZW5jZXMoZWRpdG9yKTtcbiAgICAgIGVkaXRvci5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIH07XG5cbiAgICBjb25zdCBDcmVhdGVJY29uTWFuYWdlciA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGxvb2t1cCA9IHt9O1xuICAgICAgY29uc3QgYWRkID0gKGlkLCBpY29uUGFjaykgPT4ge1xuICAgICAgICBsb29rdXBbaWRdID0gaWNvblBhY2s7XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0ID0gaWQgPT4ge1xuICAgICAgICBpZiAobG9va3VwW2lkXSkge1xuICAgICAgICAgIHJldHVybiBsb29rdXBbaWRdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB7IGljb25zOiB7fSB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgaGFzID0gaWQgPT4gaGFzJDIobG9va3VwLCBpZCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhZGQsXG4gICAgICAgIGdldCxcbiAgICAgICAgaGFzXG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgSWNvbk1hbmFnZXIgPSBDcmVhdGVJY29uTWFuYWdlcigpO1xuXG4gICAgY29uc3QgTW9kZWxNYW5hZ2VyID0gQWRkT25NYW5hZ2VyLk1vZGVsTWFuYWdlcjtcblxuICAgIGNvbnN0IGdldFByb3AgPSAocHJvcE5hbWUsIGVsbSkgPT4ge1xuICAgICAgY29uc3QgcmF3RWxtID0gZWxtLmRvbTtcbiAgICAgIHJldHVybiByYXdFbG1bcHJvcE5hbWVdO1xuICAgIH07XG4gICAgY29uc3QgZ2V0Q29tcHV0ZWRTaXplUHJvcCA9IChwcm9wTmFtZSwgZWxtKSA9PiBwYXJzZUludChnZXQkNyhlbG0sIHByb3BOYW1lKSwgMTApO1xuICAgIGNvbnN0IGdldENsaWVudFdpZHRoID0gY3VycnkoZ2V0UHJvcCwgJ2NsaWVudFdpZHRoJyk7XG4gICAgY29uc3QgZ2V0Q2xpZW50SGVpZ2h0ID0gY3VycnkoZ2V0UHJvcCwgJ2NsaWVudEhlaWdodCcpO1xuICAgIGNvbnN0IGdldE1hcmdpblRvcCA9IGN1cnJ5KGdldENvbXB1dGVkU2l6ZVByb3AsICdtYXJnaW4tdG9wJyk7XG4gICAgY29uc3QgZ2V0TWFyZ2luTGVmdCA9IGN1cnJ5KGdldENvbXB1dGVkU2l6ZVByb3AsICdtYXJnaW4tbGVmdCcpO1xuICAgIGNvbnN0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCA9IGVsbSA9PiBlbG0uZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGlzSW5zaWRlRWxlbWVudENvbnRlbnRBcmVhID0gKGJvZHlFbG0sIGNsaWVudFgsIGNsaWVudFkpID0+IHtcbiAgICAgIGNvbnN0IGNsaWVudFdpZHRoID0gZ2V0Q2xpZW50V2lkdGgoYm9keUVsbSk7XG4gICAgICBjb25zdCBjbGllbnRIZWlnaHQgPSBnZXRDbGllbnRIZWlnaHQoYm9keUVsbSk7XG4gICAgICByZXR1cm4gY2xpZW50WCA+PSAwICYmIGNsaWVudFkgPj0gMCAmJiBjbGllbnRYIDw9IGNsaWVudFdpZHRoICYmIGNsaWVudFkgPD0gY2xpZW50SGVpZ2h0O1xuICAgIH07XG4gICAgY29uc3QgdHJhbnNwb3NlID0gKGlubGluZSwgZWxtLCBjbGllbnRYLCBjbGllbnRZKSA9PiB7XG4gICAgICBjb25zdCBjbGllbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsbSk7XG4gICAgICBjb25zdCBkZWx0YVggPSBpbmxpbmUgPyBjbGllbnRSZWN0LmxlZnQgKyBlbG0uZG9tLmNsaWVudExlZnQgKyBnZXRNYXJnaW5MZWZ0KGVsbSkgOiAwO1xuICAgICAgY29uc3QgZGVsdGFZID0gaW5saW5lID8gY2xpZW50UmVjdC50b3AgKyBlbG0uZG9tLmNsaWVudFRvcCArIGdldE1hcmdpblRvcChlbG0pIDogMDtcbiAgICAgIGNvbnN0IHggPSBjbGllbnRYIC0gZGVsdGFYO1xuICAgICAgY29uc3QgeSA9IGNsaWVudFkgLSBkZWx0YVk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgaXNYWUluQ29udGVudEFyZWEgPSAoZWRpdG9yLCBjbGllbnRYLCBjbGllbnRZKSA9PiB7XG4gICAgICBjb25zdCBib2R5RWxtID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZWRpdG9yLmdldEJvZHkoKSk7XG4gICAgICBjb25zdCB0YXJnZXRFbG0gPSBlZGl0b3IuaW5saW5lID8gYm9keUVsbSA6IGRvY3VtZW50RWxlbWVudChib2R5RWxtKTtcbiAgICAgIGNvbnN0IHRyYW5zcG9zZWRQb2ludCA9IHRyYW5zcG9zZShlZGl0b3IuaW5saW5lLCB0YXJnZXRFbG0sIGNsaWVudFgsIGNsaWVudFkpO1xuICAgICAgcmV0dXJuIGlzSW5zaWRlRWxlbWVudENvbnRlbnRBcmVhKHRhcmdldEVsbSwgdHJhbnNwb3NlZFBvaW50LngsIHRyYW5zcG9zZWRQb2ludC55KTtcbiAgICB9O1xuICAgIGNvbnN0IGZyb21Eb21TYWZlID0gbm9kZSA9PiBPcHRpb25hbC5mcm9tKG5vZGUpLm1hcChTdWdhckVsZW1lbnQuZnJvbURvbSk7XG4gICAgY29uc3QgaXNFZGl0b3JBdHRhY2hlZFRvRG9tID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IHJhd0NvbnRhaW5lciA9IGVkaXRvci5pbmxpbmUgPyBlZGl0b3IuZ2V0Qm9keSgpIDogZWRpdG9yLmdldENvbnRlbnRBcmVhQ29udGFpbmVyKCk7XG4gICAgICByZXR1cm4gZnJvbURvbVNhZmUocmF3Q29udGFpbmVyKS5tYXAoaW5Cb2R5KS5nZXRPcihmYWxzZSk7XG4gICAgfTtcblxuICAgIHZhciBOb3RpZmljYXRpb25NYW5hZ2VySW1wbCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHVuaW1wbGVtZW50ZWQgPSAoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlbWUgZGlkIG5vdCBwcm92aWRlIGEgTm90aWZpY2F0aW9uTWFuYWdlciBpbXBsZW1lbnRhdGlvbi4nKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvcGVuOiB1bmltcGxlbWVudGVkLFxuICAgICAgICBjbG9zZTogdW5pbXBsZW1lbnRlZCxcbiAgICAgICAgZ2V0QXJnczogdW5pbXBsZW1lbnRlZFxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgTm90aWZpY2F0aW9uTWFuYWdlciA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBub3RpZmljYXRpb25zID0gW107XG4gICAgICBjb25zdCBnZXRJbXBsZW1lbnRhdGlvbiA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgdGhlbWUgPSBlZGl0b3IudGhlbWU7XG4gICAgICAgIHJldHVybiB0aGVtZSAmJiB0aGVtZS5nZXROb3RpZmljYXRpb25NYW5hZ2VySW1wbCA/IHRoZW1lLmdldE5vdGlmaWNhdGlvbk1hbmFnZXJJbXBsKCkgOiBOb3RpZmljYXRpb25NYW5hZ2VySW1wbCgpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldFRvcE5vdGlmaWNhdGlvbiA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLmZyb20obm90aWZpY2F0aW9uc1swXSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgaXNFcXVhbCA9IChhLCBiKSA9PiB7XG4gICAgICAgIHJldHVybiBhLnR5cGUgPT09IGIudHlwZSAmJiBhLnRleHQgPT09IGIudGV4dCAmJiAhYS5wcm9ncmVzc0JhciAmJiAhYS50aW1lb3V0ICYmICFiLnByb2dyZXNzQmFyICYmICFiLnRpbWVvdXQ7XG4gICAgICB9O1xuICAgICAgY29uc3QgcmVwb3NpdGlvbiA9ICgpID0+IHtcbiAgICAgICAgZWFjaCRlKG5vdGlmaWNhdGlvbnMsIG5vdGlmaWNhdGlvbiA9PiB7XG4gICAgICAgICAgbm90aWZpY2F0aW9uLnJlcG9zaXRpb24oKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgYWRkTm90aWZpY2F0aW9uID0gbm90aWZpY2F0aW9uID0+IHtcbiAgICAgICAgbm90aWZpY2F0aW9ucy5wdXNoKG5vdGlmaWNhdGlvbik7XG4gICAgICB9O1xuICAgICAgY29uc3QgY2xvc2VOb3RpZmljYXRpb24gPSBub3RpZmljYXRpb24gPT4ge1xuICAgICAgICBmaW5kSW5kZXgkMihub3RpZmljYXRpb25zLCBvdGhlck5vdGlmaWNhdGlvbiA9PiB7XG4gICAgICAgICAgcmV0dXJuIG90aGVyTm90aWZpY2F0aW9uID09PSBub3RpZmljYXRpb247XG4gICAgICAgIH0pLmVhY2goaW5kZXggPT4ge1xuICAgICAgICAgIG5vdGlmaWNhdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgb3BlbiA9IChzcGVjLCBmaXJlRXZlbnQgPSB0cnVlKSA9PiB7XG4gICAgICAgIGlmIChlZGl0b3IucmVtb3ZlZCB8fCAhaXNFZGl0b3JBdHRhY2hlZFRvRG9tKGVkaXRvcikpIHtcbiAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpcmVFdmVudCkge1xuICAgICAgICAgIGVkaXRvci5kaXNwYXRjaCgnQmVmb3JlT3Blbk5vdGlmaWNhdGlvbicsIHsgbm90aWZpY2F0aW9uOiBzcGVjIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaW5kJDIobm90aWZpY2F0aW9ucywgbm90aWZpY2F0aW9uID0+IHtcbiAgICAgICAgICByZXR1cm4gaXNFcXVhbChnZXRJbXBsZW1lbnRhdGlvbigpLmdldEFyZ3Mobm90aWZpY2F0aW9uKSwgc3BlYyk7XG4gICAgICAgIH0pLmdldE9yVGh1bmsoKCkgPT4ge1xuICAgICAgICAgIGVkaXRvci5lZGl0b3JNYW5hZ2VyLnNldEFjdGl2ZShlZGl0b3IpO1xuICAgICAgICAgIGNvbnN0IG5vdGlmaWNhdGlvbiA9IGdldEltcGxlbWVudGF0aW9uKCkub3BlbihzcGVjLCAoKSA9PiB7XG4gICAgICAgICAgICBjbG9zZU5vdGlmaWNhdGlvbihub3RpZmljYXRpb24pO1xuICAgICAgICAgICAgcmVwb3NpdGlvbigpO1xuICAgICAgICAgICAgZ2V0VG9wTm90aWZpY2F0aW9uKCkuZm9sZCgoKSA9PiBlZGl0b3IuZm9jdXMoKSwgdG9wID0+IGZvY3VzJDEoU3VnYXJFbGVtZW50LmZyb21Eb20odG9wLmdldEVsKCkpKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYWRkTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbik7XG4gICAgICAgICAgcmVwb3NpdGlvbigpO1xuICAgICAgICAgIGVkaXRvci5kaXNwYXRjaCgnT3Blbk5vdGlmaWNhdGlvbicsIHsgbm90aWZpY2F0aW9uOiB7IC4uLm5vdGlmaWNhdGlvbiB9IH0pO1xuICAgICAgICAgIHJldHVybiBub3RpZmljYXRpb247XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGNsb3NlID0gKCkgPT4ge1xuICAgICAgICBnZXRUb3BOb3RpZmljYXRpb24oKS5lYWNoKG5vdGlmaWNhdGlvbiA9PiB7XG4gICAgICAgICAgZ2V0SW1wbGVtZW50YXRpb24oKS5jbG9zZShub3RpZmljYXRpb24pO1xuICAgICAgICAgIGNsb3NlTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbik7XG4gICAgICAgICAgcmVwb3NpdGlvbigpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBnZXROb3RpZmljYXRpb25zID0gY29uc3RhbnQobm90aWZpY2F0aW9ucyk7XG4gICAgICBjb25zdCByZWdpc3RlckV2ZW50cyA9IGVkaXRvciA9PiB7XG4gICAgICAgIGVkaXRvci5vbignU2tpbkxvYWRlZCcsICgpID0+IHtcbiAgICAgICAgICBjb25zdCBzZXJ2aWNlTWVzc2FnZSA9IGdldFNlcnZpY2VNZXNzYWdlKGVkaXRvcik7XG4gICAgICAgICAgaWYgKHNlcnZpY2VNZXNzYWdlKSB7XG4gICAgICAgICAgICBvcGVuKHtcbiAgICAgICAgICAgICAgdGV4dDogc2VydmljZU1lc3NhZ2UsXG4gICAgICAgICAgICAgIHR5cGU6ICd3YXJuaW5nJyxcbiAgICAgICAgICAgICAgdGltZW91dDogMFxuICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXBvc2l0aW9uKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBlZGl0b3Iub24oJ3Nob3cgUmVzaXplRWRpdG9yIFJlc2l6ZVdpbmRvdyBOb2RlQ2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShyZXBvc2l0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVkaXRvci5vbigncmVtb3ZlJywgKCkgPT4ge1xuICAgICAgICAgIGVhY2gkZShub3RpZmljYXRpb25zLnNsaWNlKCksIG5vdGlmaWNhdGlvbiA9PiB7XG4gICAgICAgICAgICBnZXRJbXBsZW1lbnRhdGlvbigpLmNsb3NlKG5vdGlmaWNhdGlvbik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHJlZ2lzdGVyRXZlbnRzKGVkaXRvcik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvcGVuLFxuICAgICAgICBjbG9zZSxcbiAgICAgICAgZ2V0Tm90aWZpY2F0aW9uc1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgUGx1Z2luTWFuYWdlciA9IEFkZE9uTWFuYWdlci5QbHVnaW5NYW5hZ2VyO1xuXG4gICAgY29uc3QgVGhlbWVNYW5hZ2VyID0gQWRkT25NYW5hZ2VyLlRoZW1lTWFuYWdlcjtcblxuICAgIHZhciBXaW5kb3dNYW5hZ2VySW1wbCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHVuaW1wbGVtZW50ZWQgPSAoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlbWUgZGlkIG5vdCBwcm92aWRlIGEgV2luZG93TWFuYWdlciBpbXBsZW1lbnRhdGlvbi4nKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvcGVuOiB1bmltcGxlbWVudGVkLFxuICAgICAgICBvcGVuVXJsOiB1bmltcGxlbWVudGVkLFxuICAgICAgICBhbGVydDogdW5pbXBsZW1lbnRlZCxcbiAgICAgICAgY29uZmlybTogdW5pbXBsZW1lbnRlZCxcbiAgICAgICAgY2xvc2U6IHVuaW1wbGVtZW50ZWRcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IFdpbmRvd01hbmFnZXIgPSBlZGl0b3IgPT4ge1xuICAgICAgbGV0IGRpYWxvZ3MgPSBbXTtcbiAgICAgIGNvbnN0IGdldEltcGxlbWVudGF0aW9uID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB0aGVtZSA9IGVkaXRvci50aGVtZTtcbiAgICAgICAgcmV0dXJuIHRoZW1lICYmIHRoZW1lLmdldFdpbmRvd01hbmFnZXJJbXBsID8gdGhlbWUuZ2V0V2luZG93TWFuYWdlckltcGwoKSA6IFdpbmRvd01hbmFnZXJJbXBsKCk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZnVuY0JpbmQgPSAoc2NvcGUsIGYpID0+IHtcbiAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGYgPyBmLmFwcGx5KHNjb3BlLCBhcmdzKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICBjb25zdCBmaXJlT3BlbkV2ZW50ID0gZGlhbG9nID0+IHtcbiAgICAgICAgZWRpdG9yLmRpc3BhdGNoKCdPcGVuV2luZG93JywgeyBkaWFsb2cgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZmlyZUNsb3NlRXZlbnQgPSBkaWFsb2cgPT4ge1xuICAgICAgICBlZGl0b3IuZGlzcGF0Y2goJ0Nsb3NlV2luZG93JywgeyBkaWFsb2cgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgYWRkRGlhbG9nID0gZGlhbG9nID0+IHtcbiAgICAgICAgZGlhbG9ncy5wdXNoKGRpYWxvZyk7XG4gICAgICAgIGZpcmVPcGVuRXZlbnQoZGlhbG9nKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBjbG9zZURpYWxvZyA9IGRpYWxvZyA9PiB7XG4gICAgICAgIGZpcmVDbG9zZUV2ZW50KGRpYWxvZyk7XG4gICAgICAgIGRpYWxvZ3MgPSBmaWx0ZXIkNShkaWFsb2dzLCBvdGhlckRpYWxvZyA9PiB7XG4gICAgICAgICAgcmV0dXJuIG90aGVyRGlhbG9nICE9PSBkaWFsb2c7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGlhbG9ncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBlZGl0b3IuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldFRvcERpYWxvZyA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLmZyb20oZGlhbG9nc1tkaWFsb2dzLmxlbmd0aCAtIDFdKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBzdG9yZVNlbGVjdGlvbkFuZE9wZW5EaWFsb2cgPSBvcGVuRGlhbG9nID0+IHtcbiAgICAgICAgZWRpdG9yLmVkaXRvck1hbmFnZXIuc2V0QWN0aXZlKGVkaXRvcik7XG4gICAgICAgIHN0b3JlKGVkaXRvcik7XG4gICAgICAgIGVkaXRvci51aS5zaG93KCk7XG4gICAgICAgIGNvbnN0IGRpYWxvZyA9IG9wZW5EaWFsb2coKTtcbiAgICAgICAgYWRkRGlhbG9nKGRpYWxvZyk7XG4gICAgICAgIHJldHVybiBkaWFsb2c7XG4gICAgICB9O1xuICAgICAgY29uc3Qgb3BlbiA9IChhcmdzLCBwYXJhbXMpID0+IHtcbiAgICAgICAgcmV0dXJuIHN0b3JlU2VsZWN0aW9uQW5kT3BlbkRpYWxvZygoKSA9PiBnZXRJbXBsZW1lbnRhdGlvbigpLm9wZW4oYXJncywgcGFyYW1zLCBjbG9zZURpYWxvZykpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IG9wZW5VcmwgPSBhcmdzID0+IHtcbiAgICAgICAgcmV0dXJuIHN0b3JlU2VsZWN0aW9uQW5kT3BlbkRpYWxvZygoKSA9PiBnZXRJbXBsZW1lbnRhdGlvbigpLm9wZW5VcmwoYXJncywgY2xvc2VEaWFsb2cpKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBhbGVydCA9IChtZXNzYWdlLCBjYWxsYmFjaywgc2NvcGUpID0+IHtcbiAgICAgICAgY29uc3Qgd2luZG93TWFuYWdlckltcGwgPSBnZXRJbXBsZW1lbnRhdGlvbigpO1xuICAgICAgICB3aW5kb3dNYW5hZ2VySW1wbC5hbGVydChtZXNzYWdlLCBmdW5jQmluZChzY29wZSA/IHNjb3BlIDogd2luZG93TWFuYWdlckltcGwsIGNhbGxiYWNrKSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgY29uZmlybSA9IChtZXNzYWdlLCBjYWxsYmFjaywgc2NvcGUpID0+IHtcbiAgICAgICAgY29uc3Qgd2luZG93TWFuYWdlckltcGwgPSBnZXRJbXBsZW1lbnRhdGlvbigpO1xuICAgICAgICB3aW5kb3dNYW5hZ2VySW1wbC5jb25maXJtKG1lc3NhZ2UsIGZ1bmNCaW5kKHNjb3BlID8gc2NvcGUgOiB3aW5kb3dNYW5hZ2VySW1wbCwgY2FsbGJhY2spKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBjbG9zZSA9ICgpID0+IHtcbiAgICAgICAgZ2V0VG9wRGlhbG9nKCkuZWFjaChkaWFsb2cgPT4ge1xuICAgICAgICAgIGdldEltcGxlbWVudGF0aW9uKCkuY2xvc2UoZGlhbG9nKTtcbiAgICAgICAgICBjbG9zZURpYWxvZyhkaWFsb2cpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBlZGl0b3Iub24oJ3JlbW92ZScsICgpID0+IHtcbiAgICAgICAgZWFjaCRlKGRpYWxvZ3MsIGRpYWxvZyA9PiB7XG4gICAgICAgICAgZ2V0SW1wbGVtZW50YXRpb24oKS5jbG9zZShkaWFsb2cpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3BlbixcbiAgICAgICAgb3BlblVybCxcbiAgICAgICAgYWxlcnQsXG4gICAgICAgIGNvbmZpcm0sXG4gICAgICAgIGNsb3NlXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBkaXNwbGF5Tm90aWZpY2F0aW9uID0gKGVkaXRvciwgbWVzc2FnZSkgPT4ge1xuICAgICAgZWRpdG9yLm5vdGlmaWNhdGlvbk1hbmFnZXIub3Blbih7XG4gICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgIHRleHQ6IG1lc3NhZ2VcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgZGlzcGxheUVycm9yID0gKGVkaXRvciwgbWVzc2FnZSkgPT4ge1xuICAgICAgaWYgKGVkaXRvci5fc2tpbkxvYWRlZCkge1xuICAgICAgICBkaXNwbGF5Tm90aWZpY2F0aW9uKGVkaXRvciwgbWVzc2FnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGl0b3Iub24oJ1NraW5Mb2FkZWQnLCAoKSA9PiB7XG4gICAgICAgICAgZGlzcGxheU5vdGlmaWNhdGlvbihlZGl0b3IsIG1lc3NhZ2UpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHVwbG9hZEVycm9yID0gKGVkaXRvciwgbWVzc2FnZSkgPT4ge1xuICAgICAgZGlzcGxheUVycm9yKGVkaXRvciwgSTE4bi50cmFuc2xhdGUoW1xuICAgICAgICAnRmFpbGVkIHRvIHVwbG9hZCBpbWFnZTogezB9JyxcbiAgICAgICAgbWVzc2FnZVxuICAgICAgXSkpO1xuICAgIH07XG4gICAgY29uc3QgbG9nRXJyb3IgPSAoZWRpdG9yLCBlcnJvclR5cGUsIG1zZykgPT4ge1xuICAgICAgZmlyZUVycm9yKGVkaXRvciwgZXJyb3JUeXBlLCB7IG1lc3NhZ2U6IG1zZyB9KTtcbiAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZUxvYWRFcnJvciA9ICh0eXBlLCB1cmwsIG5hbWUpID0+IG5hbWUgPyBgRmFpbGVkIHRvIGxvYWQgJHsgdHlwZSB9OiAkeyBuYW1lIH0gZnJvbSB1cmwgJHsgdXJsIH1gIDogYEZhaWxlZCB0byBsb2FkICR7IHR5cGUgfSB1cmw6ICR7IHVybCB9YDtcbiAgICBjb25zdCBwbHVnaW5Mb2FkRXJyb3IgPSAoZWRpdG9yLCB1cmwsIG5hbWUpID0+IHtcbiAgICAgIGxvZ0Vycm9yKGVkaXRvciwgJ1BsdWdpbkxvYWRFcnJvcicsIGNyZWF0ZUxvYWRFcnJvcigncGx1Z2luJywgdXJsLCBuYW1lKSk7XG4gICAgfTtcbiAgICBjb25zdCBpY29uc0xvYWRFcnJvciA9IChlZGl0b3IsIHVybCwgbmFtZSkgPT4ge1xuICAgICAgbG9nRXJyb3IoZWRpdG9yLCAnSWNvbnNMb2FkRXJyb3InLCBjcmVhdGVMb2FkRXJyb3IoJ2ljb25zJywgdXJsLCBuYW1lKSk7XG4gICAgfTtcbiAgICBjb25zdCBsYW5ndWFnZUxvYWRFcnJvciA9IChlZGl0b3IsIHVybCwgbmFtZSkgPT4ge1xuICAgICAgbG9nRXJyb3IoZWRpdG9yLCAnTGFuZ3VhZ2VMb2FkRXJyb3InLCBjcmVhdGVMb2FkRXJyb3IoJ2xhbmd1YWdlJywgdXJsLCBuYW1lKSk7XG4gICAgfTtcbiAgICBjb25zdCB0aGVtZUxvYWRFcnJvciA9IChlZGl0b3IsIHVybCwgbmFtZSkgPT4ge1xuICAgICAgbG9nRXJyb3IoZWRpdG9yLCAnVGhlbWVMb2FkRXJyb3InLCBjcmVhdGVMb2FkRXJyb3IoJ3RoZW1lJywgdXJsLCBuYW1lKSk7XG4gICAgfTtcbiAgICBjb25zdCBtb2RlbExvYWRFcnJvciA9IChlZGl0b3IsIHVybCwgbmFtZSkgPT4ge1xuICAgICAgbG9nRXJyb3IoZWRpdG9yLCAnTW9kZWxMb2FkRXJyb3InLCBjcmVhdGVMb2FkRXJyb3IoJ21vZGVsJywgdXJsLCBuYW1lKSk7XG4gICAgfTtcbiAgICBjb25zdCBwbHVnaW5Jbml0RXJyb3IgPSAoZWRpdG9yLCBuYW1lLCBlcnIpID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBJMThuLnRyYW5zbGF0ZShbXG4gICAgICAgICdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBwbHVnaW46IHswfScsXG4gICAgICAgIG5hbWVcbiAgICAgIF0pO1xuICAgICAgZmlyZUVycm9yKGVkaXRvciwgJ1BsdWdpbkxvYWRFcnJvcicsIHsgbWVzc2FnZSB9KTtcbiAgICAgIGluaXRFcnJvcihtZXNzYWdlLCBlcnIpO1xuICAgICAgZGlzcGxheUVycm9yKGVkaXRvciwgbWVzc2FnZSk7XG4gICAgfTtcbiAgICBjb25zdCBpbml0RXJyb3IgPSAobWVzc2FnZSwgLi4ueCkgPT4ge1xuICAgICAgY29uc3QgY29uc29sZSA9IHdpbmRvdy5jb25zb2xlO1xuICAgICAgaWYgKGNvbnNvbGUpIHtcbiAgICAgICAgaWYgKGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UsIC4uLngpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UsIC4uLngpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGlzQ29udGVudENzc1NraW5OYW1lID0gdXJsID0+IC9eW2EtejAtOVxcLV0rJC9pLnRlc3QodXJsKTtcbiAgICBjb25zdCBnZXRDb250ZW50Q3NzVXJscyA9IGVkaXRvciA9PiB7XG4gICAgICByZXR1cm4gdHJhbnNmb3JtVG9VcmxzKGVkaXRvciwgZ2V0Q29udGVudENzcyhlZGl0b3IpKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldEZvbnRDc3NVcmxzID0gZWRpdG9yID0+IHtcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1Ub1VybHMoZWRpdG9yLCBnZXRGb250Q3NzKGVkaXRvcikpO1xuICAgIH07XG4gICAgY29uc3QgdHJhbnNmb3JtVG9VcmxzID0gKGVkaXRvciwgY3NzTGlua3MpID0+IHtcbiAgICAgIGNvbnN0IHNraW5VcmwgPSBlZGl0b3IuZWRpdG9yTWFuYWdlci5iYXNlVVJMICsgJy9za2lucy9jb250ZW50JztcbiAgICAgIGNvbnN0IHN1ZmZpeCA9IGVkaXRvci5lZGl0b3JNYW5hZ2VyLnN1ZmZpeDtcbiAgICAgIGNvbnN0IGNvbnRlbnRDc3NGaWxlID0gYGNvbnRlbnQkeyBzdWZmaXggfS5jc3NgO1xuICAgICAgcmV0dXJuIG1hcCQzKGNzc0xpbmtzLCB1cmwgPT4ge1xuICAgICAgICBpZiAoaXNDb250ZW50Q3NzU2tpbk5hbWUodXJsKSAmJiAhZWRpdG9yLmlubGluZSkge1xuICAgICAgICAgIHJldHVybiBgJHsgc2tpblVybCB9LyR7IHVybCB9LyR7IGNvbnRlbnRDc3NGaWxlIH1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBlZGl0b3IuZG9jdW1lbnRCYXNlVVJJLnRvQWJzb2x1dGUodXJsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBhcHBlbmRDb250ZW50Q3NzRnJvbVNldHRpbmdzID0gZWRpdG9yID0+IHtcbiAgICAgIGVkaXRvci5jb250ZW50Q1NTID0gZWRpdG9yLmNvbnRlbnRDU1MuY29uY2F0KGdldENvbnRlbnRDc3NVcmxzKGVkaXRvciksIGdldEZvbnRDc3NVcmxzKGVkaXRvcikpO1xuICAgIH07XG5cbiAgICBjb25zdCBnZXRBbGxJbWFnZXMgPSBlbG0gPT4ge1xuICAgICAgcmV0dXJuIGVsbSA/IGZyb20oZWxtLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbWcnKSkgOiBbXTtcbiAgICB9O1xuICAgIGNvbnN0IEltYWdlU2Nhbm5lciA9ICh1cGxvYWRTdGF0dXMsIGJsb2JDYWNoZSkgPT4ge1xuICAgICAgY29uc3QgY2FjaGVkUHJvbWlzZXMgPSB7fTtcbiAgICAgIGNvbnN0IGZpbmRBbGwgPSAoZWxtLCBwcmVkaWNhdGUgPSBhbHdheXMpID0+IHtcbiAgICAgICAgY29uc3QgaW1hZ2VzID0gZmlsdGVyJDUoZ2V0QWxsSW1hZ2VzKGVsbSksIGltZyA9PiB7XG4gICAgICAgICAgY29uc3Qgc3JjID0gaW1nLnNyYztcbiAgICAgICAgICBpZiAoaW1nLmhhc0F0dHJpYnV0ZSgnZGF0YS1tY2UtYm9ndXMnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW1nLmhhc0F0dHJpYnV0ZSgnZGF0YS1tY2UtcGxhY2Vob2xkZXInKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXNyYyB8fCBzcmMgPT09IEVudi50cmFuc3BhcmVudFNyYykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhcnRzV2l0aChzcmMsICdibG9iOicpKSB7XG4gICAgICAgICAgICByZXR1cm4gIXVwbG9hZFN0YXR1cy5pc1VwbG9hZGVkKHNyYykgJiYgcHJlZGljYXRlKGltZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGFydHNXaXRoKHNyYywgJ2RhdGE6JykpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmVkaWNhdGUoaW1nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBtYXAkMyhpbWFnZXMsIGltZyA9PiB7XG4gICAgICAgICAgY29uc3QgaW1hZ2VTcmMgPSBpbWcuc3JjO1xuICAgICAgICAgIGlmIChoYXMkMihjYWNoZWRQcm9taXNlcywgaW1hZ2VTcmMpKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkUHJvbWlzZXNbaW1hZ2VTcmNdLnRoZW4oaW1hZ2VJbmZvID0+IHtcbiAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGltYWdlSW5mbykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW1hZ2VJbmZvO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICBpbWFnZTogaW1nLFxuICAgICAgICAgICAgICAgICAgYmxvYkluZm86IGltYWdlSW5mby5ibG9iSW5mb1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBuZXdQcm9taXNlID0gaW1hZ2VUb0Jsb2JJbmZvKGJsb2JDYWNoZSwgaW1hZ2VTcmMpLnRoZW4oYmxvYkluZm8gPT4ge1xuICAgICAgICAgICAgICBkZWxldGUgY2FjaGVkUHJvbWlzZXNbaW1hZ2VTcmNdO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGltYWdlOiBpbWcsXG4gICAgICAgICAgICAgICAgYmxvYkluZm9cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgZGVsZXRlIGNhY2hlZFByb21pc2VzW2ltYWdlU3JjXTtcbiAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYWNoZWRQcm9taXNlc1tpbWFnZVNyY10gPSBuZXdQcm9taXNlO1xuICAgICAgICAgICAgcmV0dXJuIG5ld1Byb21pc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4geyBmaW5kQWxsIH07XG4gICAgfTtcblxuICAgIGNvbnN0IFVwbG9hZFN0YXR1cyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IFBFTkRJTkcgPSAxLCBVUExPQURFRCA9IDI7XG4gICAgICBsZXQgYmxvYlVyaVN0YXR1c2VzID0ge307XG4gICAgICBjb25zdCBjcmVhdGVTdGF0dXMgPSAoc3RhdHVzLCByZXN1bHRVcmkpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgcmVzdWx0VXJpXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgY29uc3QgaGFzQmxvYlVyaSA9IGJsb2JVcmkgPT4ge1xuICAgICAgICByZXR1cm4gYmxvYlVyaSBpbiBibG9iVXJpU3RhdHVzZXM7XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0UmVzdWx0VXJpID0gYmxvYlVyaSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGJsb2JVcmlTdGF0dXNlc1tibG9iVXJpXTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA/IHJlc3VsdC5yZXN1bHRVcmkgOiBudWxsO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzUGVuZGluZyA9IGJsb2JVcmkgPT4ge1xuICAgICAgICByZXR1cm4gaGFzQmxvYlVyaShibG9iVXJpKSA/IGJsb2JVcmlTdGF0dXNlc1tibG9iVXJpXS5zdGF0dXMgPT09IFBFTkRJTkcgOiBmYWxzZTtcbiAgICAgIH07XG4gICAgICBjb25zdCBpc1VwbG9hZGVkID0gYmxvYlVyaSA9PiB7XG4gICAgICAgIHJldHVybiBoYXNCbG9iVXJpKGJsb2JVcmkpID8gYmxvYlVyaVN0YXR1c2VzW2Jsb2JVcmldLnN0YXR1cyA9PT0gVVBMT0FERUQgOiBmYWxzZTtcbiAgICAgIH07XG4gICAgICBjb25zdCBtYXJrUGVuZGluZyA9IGJsb2JVcmkgPT4ge1xuICAgICAgICBibG9iVXJpU3RhdHVzZXNbYmxvYlVyaV0gPSBjcmVhdGVTdGF0dXMoUEVORElORywgbnVsbCk7XG4gICAgICB9O1xuICAgICAgY29uc3QgbWFya1VwbG9hZGVkID0gKGJsb2JVcmksIHJlc3VsdFVyaSkgPT4ge1xuICAgICAgICBibG9iVXJpU3RhdHVzZXNbYmxvYlVyaV0gPSBjcmVhdGVTdGF0dXMoVVBMT0FERUQsIHJlc3VsdFVyaSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgcmVtb3ZlRmFpbGVkID0gYmxvYlVyaSA9PiB7XG4gICAgICAgIGRlbGV0ZSBibG9iVXJpU3RhdHVzZXNbYmxvYlVyaV07XG4gICAgICB9O1xuICAgICAgY29uc3QgZGVzdHJveSA9ICgpID0+IHtcbiAgICAgICAgYmxvYlVyaVN0YXR1c2VzID0ge307XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaGFzQmxvYlVyaSxcbiAgICAgICAgZ2V0UmVzdWx0VXJpLFxuICAgICAgICBpc1BlbmRpbmcsXG4gICAgICAgIGlzVXBsb2FkZWQsXG4gICAgICAgIG1hcmtQZW5kaW5nLFxuICAgICAgICBtYXJrVXBsb2FkZWQsXG4gICAgICAgIHJlbW92ZUZhaWxlZCxcbiAgICAgICAgZGVzdHJveVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBjb25zdCBzZWVkID0gKCkgPT4ge1xuICAgICAgY29uc3Qgcm5kID0gKCkgPT4ge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogNDI5NDk2NzI5NSkudG9TdHJpbmcoMzYpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgcmV0dXJuICdzJyArIG5vdy50b1N0cmluZygzNikgKyBybmQoKSArIHJuZCgpICsgcm5kKCk7XG4gICAgfTtcbiAgICBjb25zdCB1dWlkID0gcHJlZml4ID0+IHtcbiAgICAgIHJldHVybiBwcmVmaXggKyBjb3VudCsrICsgc2VlZCgpO1xuICAgIH07XG5cbiAgICBjb25zdCBCbG9iQ2FjaGUgPSAoKSA9PiB7XG4gICAgICBsZXQgY2FjaGUgPSBbXTtcbiAgICAgIGNvbnN0IG1pbWVUb0V4dCA9IG1pbWUgPT4ge1xuICAgICAgICBjb25zdCBtaW1lcyA9IHtcbiAgICAgICAgICAnaW1hZ2UvanBlZyc6ICdqcGcnLFxuICAgICAgICAgICdpbWFnZS9qcGcnOiAnanBnJyxcbiAgICAgICAgICAnaW1hZ2UvZ2lmJzogJ2dpZicsXG4gICAgICAgICAgJ2ltYWdlL3BuZyc6ICdwbmcnLFxuICAgICAgICAgICdpbWFnZS9hcG5nJzogJ2FwbmcnLFxuICAgICAgICAgICdpbWFnZS9hdmlmJzogJ2F2aWYnLFxuICAgICAgICAgICdpbWFnZS9zdmcreG1sJzogJ3N2ZycsXG4gICAgICAgICAgJ2ltYWdlL3dlYnAnOiAnd2VicCcsXG4gICAgICAgICAgJ2ltYWdlL2JtcCc6ICdibXAnLFxuICAgICAgICAgICdpbWFnZS90aWZmJzogJ3RpZmYnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBtaW1lc1ttaW1lLnRvTG93ZXJDYXNlKCldIHx8ICdkYXQnO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGNyZWF0ZSA9IChvLCBibG9iLCBiYXNlNjQsIG5hbWUsIGZpbGVuYW1lKSA9PiB7XG4gICAgICAgIGlmIChpc1N0cmluZyhvKSkge1xuICAgICAgICAgIGNvbnN0IGlkID0gbztcbiAgICAgICAgICByZXR1cm4gdG9CbG9iSW5mbyh7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgICAgIGJsb2I6IGJsb2IsXG4gICAgICAgICAgICBiYXNlNjQ6IGJhc2U2NFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KG8pKSB7XG4gICAgICAgICAgcmV0dXJuIHRvQmxvYkluZm8obyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGlucHV0IHR5cGUnKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHRvQmxvYkluZm8gPSBvID0+IHtcbiAgICAgICAgaWYgKCFvLmJsb2IgfHwgIW8uYmFzZTY0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdibG9iIGFuZCBiYXNlNjQgcmVwcmVzZW50YXRpb25zIG9mIHRoZSBpbWFnZSBhcmUgcmVxdWlyZWQgZm9yIEJsb2JJbmZvIHRvIGJlIGNyZWF0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZCA9IG8uaWQgfHwgdXVpZCgnYmxvYmlkJyk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBvLm5hbWUgfHwgaWQ7XG4gICAgICAgIGNvbnN0IGJsb2IgPSBvLmJsb2I7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWQ6IGNvbnN0YW50KGlkKSxcbiAgICAgICAgICBuYW1lOiBjb25zdGFudChuYW1lKSxcbiAgICAgICAgICBmaWxlbmFtZTogY29uc3RhbnQoby5maWxlbmFtZSB8fCBuYW1lICsgJy4nICsgbWltZVRvRXh0KGJsb2IudHlwZSkpLFxuICAgICAgICAgIGJsb2I6IGNvbnN0YW50KGJsb2IpLFxuICAgICAgICAgIGJhc2U2NDogY29uc3RhbnQoby5iYXNlNjQpLFxuICAgICAgICAgIGJsb2JVcmk6IGNvbnN0YW50KG8uYmxvYlVyaSB8fCBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpKSxcbiAgICAgICAgICB1cmk6IGNvbnN0YW50KG8udXJpKVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGFkZCA9IGJsb2JJbmZvID0+IHtcbiAgICAgICAgaWYgKCFnZXQoYmxvYkluZm8uaWQoKSkpIHtcbiAgICAgICAgICBjYWNoZS5wdXNoKGJsb2JJbmZvKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGZpbmRGaXJzdCA9IHByZWRpY2F0ZSA9PiBmaW5kJDIoY2FjaGUsIHByZWRpY2F0ZSkuZ2V0T3JVbmRlZmluZWQoKTtcbiAgICAgIGNvbnN0IGdldCA9IGlkID0+IGZpbmRGaXJzdChjYWNoZWRCbG9iSW5mbyA9PiBjYWNoZWRCbG9iSW5mby5pZCgpID09PSBpZCk7XG4gICAgICBjb25zdCBnZXRCeVVyaSA9IGJsb2JVcmkgPT4gZmluZEZpcnN0KGJsb2JJbmZvID0+IGJsb2JJbmZvLmJsb2JVcmkoKSA9PT0gYmxvYlVyaSk7XG4gICAgICBjb25zdCBnZXRCeURhdGEgPSAoYmFzZTY0LCB0eXBlKSA9PiBmaW5kRmlyc3QoYmxvYkluZm8gPT4gYmxvYkluZm8uYmFzZTY0KCkgPT09IGJhc2U2NCAmJiBibG9iSW5mby5ibG9iKCkudHlwZSA9PT0gdHlwZSk7XG4gICAgICBjb25zdCByZW1vdmVCeVVyaSA9IGJsb2JVcmkgPT4ge1xuICAgICAgICBjYWNoZSA9IGZpbHRlciQ1KGNhY2hlLCBibG9iSW5mbyA9PiB7XG4gICAgICAgICAgaWYgKGJsb2JJbmZvLmJsb2JVcmkoKSA9PT0gYmxvYlVyaSkge1xuICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChibG9iSW5mby5ibG9iVXJpKCkpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZGVzdHJveSA9ICgpID0+IHtcbiAgICAgICAgZWFjaCRlKGNhY2hlLCBjYWNoZWRCbG9iSW5mbyA9PiB7XG4gICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChjYWNoZWRCbG9iSW5mby5ibG9iVXJpKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgY2FjaGUgPSBbXTtcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjcmVhdGUsXG4gICAgICAgIGFkZCxcbiAgICAgICAgZ2V0LFxuICAgICAgICBnZXRCeVVyaSxcbiAgICAgICAgZ2V0QnlEYXRhLFxuICAgICAgICBmaW5kRmlyc3QsXG4gICAgICAgIHJlbW92ZUJ5VXJpLFxuICAgICAgICBkZXN0cm95XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBVcGxvYWRlciA9ICh1cGxvYWRTdGF0dXMsIHNldHRpbmdzKSA9PiB7XG4gICAgICBjb25zdCBwZW5kaW5nUHJvbWlzZXMgPSB7fTtcbiAgICAgIGNvbnN0IHBhdGhKb2luID0gKHBhdGgxLCBwYXRoMikgPT4ge1xuICAgICAgICBpZiAocGF0aDEpIHtcbiAgICAgICAgICByZXR1cm4gcGF0aDEucmVwbGFjZSgvXFwvJC8sICcnKSArICcvJyArIHBhdGgyLnJlcGxhY2UoL15cXC8vLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGgyO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGRlZmF1bHRIYW5kbGVyID0gKGJsb2JJbmZvLCBwcm9ncmVzcykgPT4gbmV3IFByb21pc2UoKHN1Y2Nlc3MsIGZhaWx1cmUpID0+IHtcbiAgICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHhoci5vcGVuKCdQT1NUJywgc2V0dGluZ3MudXJsKTtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHNldHRpbmdzLmNyZWRlbnRpYWxzO1xuICAgICAgICB4aHIudXBsb2FkLm9ucHJvZ3Jlc3MgPSBlID0+IHtcbiAgICAgICAgICBwcm9ncmVzcyhlLmxvYWRlZCAvIGUudG90YWwgKiAxMDApO1xuICAgICAgICB9O1xuICAgICAgICB4aHIub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICBmYWlsdXJlKCdJbWFnZSB1cGxvYWQgZmFpbGVkIGR1ZSB0byBhIFhIUiBUcmFuc3BvcnQgZXJyb3IuIENvZGU6ICcgKyB4aHIuc3RhdHVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgeGhyLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA8IDIwMCB8fCB4aHIuc3RhdHVzID49IDMwMCkge1xuICAgICAgICAgICAgZmFpbHVyZSgnSFRUUCBFcnJvcjogJyArIHhoci5zdGF0dXMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBqc29uID0gSlNPTi5wYXJzZSh4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICBpZiAoIWpzb24gfHwgIWlzU3RyaW5nKGpzb24ubG9jYXRpb24pKSB7XG4gICAgICAgICAgICBmYWlsdXJlKCdJbnZhbGlkIEpTT046ICcgKyB4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3VjY2VzcyhwYXRoSm9pbihzZXR0aW5ncy5iYXNlUGF0aCwganNvbi5sb2NhdGlvbikpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoJ2ZpbGUnLCBibG9iSW5mby5ibG9iKCksIGJsb2JJbmZvLmZpbGVuYW1lKCkpO1xuICAgICAgICB4aHIuc2VuZChmb3JtRGF0YSk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHVwbG9hZEhhbmRsZXIgPSBpc0Z1bmN0aW9uKHNldHRpbmdzLmhhbmRsZXIpID8gc2V0dGluZ3MuaGFuZGxlciA6IGRlZmF1bHRIYW5kbGVyO1xuICAgICAgY29uc3Qgbm9VcGxvYWQgPSAoKSA9PiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgcmVzb2x2ZShbXSk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGhhbmRsZXJTdWNjZXNzID0gKGJsb2JJbmZvLCB1cmwpID0+ICh7XG4gICAgICAgIHVybCxcbiAgICAgICAgYmxvYkluZm8sXG4gICAgICAgIHN0YXR1czogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBjb25zdCBoYW5kbGVyRmFpbHVyZSA9IChibG9iSW5mbywgZXJyb3IpID0+ICh7XG4gICAgICAgIHVybDogJycsXG4gICAgICAgIGJsb2JJbmZvLFxuICAgICAgICBzdGF0dXM6IGZhbHNlLFxuICAgICAgICBlcnJvclxuICAgICAgfSk7XG4gICAgICBjb25zdCByZXNvbHZlUGVuZGluZyA9IChibG9iVXJpLCByZXN1bHQpID0+IHtcbiAgICAgICAgVG9vbHMuZWFjaChwZW5kaW5nUHJvbWlzZXNbYmxvYlVyaV0sIHJlc29sdmUgPT4ge1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlbGV0ZSBwZW5kaW5nUHJvbWlzZXNbYmxvYlVyaV07XG4gICAgICB9O1xuICAgICAgY29uc3QgdXBsb2FkQmxvYkluZm8gPSAoYmxvYkluZm8sIGhhbmRsZXIsIG9wZW5Ob3RpZmljYXRpb24pID0+IHtcbiAgICAgICAgdXBsb2FkU3RhdHVzLm1hcmtQZW5kaW5nKGJsb2JJbmZvLmJsb2JVcmkoKSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICBsZXQgbm90aWZpY2F0aW9uO1xuICAgICAgICAgIGxldCBwcm9ncmVzcztcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY2xvc2VOb3RpZmljYXRpb24gPSAoKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChub3RpZmljYXRpb24pIHtcbiAgICAgICAgICAgICAgICBub3RpZmljYXRpb24uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBwcm9ncmVzcyA9IG5vb3A7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBzdWNjZXNzID0gdXJsID0+IHtcbiAgICAgICAgICAgICAgY2xvc2VOb3RpZmljYXRpb24oKTtcbiAgICAgICAgICAgICAgdXBsb2FkU3RhdHVzLm1hcmtVcGxvYWRlZChibG9iSW5mby5ibG9iVXJpKCksIHVybCk7XG4gICAgICAgICAgICAgIHJlc29sdmVQZW5kaW5nKGJsb2JJbmZvLmJsb2JVcmkoKSwgaGFuZGxlclN1Y2Nlc3MoYmxvYkluZm8sIHVybCkpO1xuICAgICAgICAgICAgICByZXNvbHZlKGhhbmRsZXJTdWNjZXNzKGJsb2JJbmZvLCB1cmwpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBmYWlsdXJlID0gZXJyb3IgPT4ge1xuICAgICAgICAgICAgICBjbG9zZU5vdGlmaWNhdGlvbigpO1xuICAgICAgICAgICAgICB1cGxvYWRTdGF0dXMucmVtb3ZlRmFpbGVkKGJsb2JJbmZvLmJsb2JVcmkoKSk7XG4gICAgICAgICAgICAgIHJlc29sdmVQZW5kaW5nKGJsb2JJbmZvLmJsb2JVcmkoKSwgaGFuZGxlckZhaWx1cmUoYmxvYkluZm8sIGVycm9yKSk7XG4gICAgICAgICAgICAgIHJlc29sdmUoaGFuZGxlckZhaWx1cmUoYmxvYkluZm8sIGVycm9yKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcHJvZ3Jlc3MgPSBwZXJjZW50ID0+IHtcbiAgICAgICAgICAgICAgaWYgKHBlcmNlbnQgPCAwIHx8IHBlcmNlbnQgPiAxMDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgT3B0aW9uYWwuZnJvbShub3RpZmljYXRpb24pLm9yVGh1bmsoKCkgPT4gT3B0aW9uYWwuZnJvbShvcGVuTm90aWZpY2F0aW9uKS5tYXAoYXBwbHkkMSkpLmVhY2gobiA9PiB7XG4gICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uID0gbjtcbiAgICAgICAgICAgICAgICBuLnByb2dyZXNzQmFyLnZhbHVlKHBlcmNlbnQpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBoYW5kbGVyKGJsb2JJbmZvLCBwcm9ncmVzcykudGhlbihzdWNjZXNzLCBlcnIgPT4ge1xuICAgICAgICAgICAgICBmYWlsdXJlKGlzU3RyaW5nKGVycikgPyB7IG1lc3NhZ2U6IGVyciB9IDogZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICByZXNvbHZlKGhhbmRsZXJGYWlsdXJlKGJsb2JJbmZvLCBleCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgaXNEZWZhdWx0SGFuZGxlciA9IGhhbmRsZXIgPT4gaGFuZGxlciA9PT0gZGVmYXVsdEhhbmRsZXI7XG4gICAgICBjb25zdCBwZW5kaW5nVXBsb2FkQmxvYkluZm8gPSBibG9iSW5mbyA9PiB7XG4gICAgICAgIGNvbnN0IGJsb2JVcmkgPSBibG9iSW5mby5ibG9iVXJpKCk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICBwZW5kaW5nUHJvbWlzZXNbYmxvYlVyaV0gPSBwZW5kaW5nUHJvbWlzZXNbYmxvYlVyaV0gfHwgW107XG4gICAgICAgICAgcGVuZGluZ1Byb21pc2VzW2Jsb2JVcmldLnB1c2gocmVzb2x2ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHVwbG9hZEJsb2JzID0gKGJsb2JJbmZvcywgb3Blbk5vdGlmaWNhdGlvbikgPT4ge1xuICAgICAgICBibG9iSW5mb3MgPSBUb29scy5ncmVwKGJsb2JJbmZvcywgYmxvYkluZm8gPT4gIXVwbG9hZFN0YXR1cy5pc1VwbG9hZGVkKGJsb2JJbmZvLmJsb2JVcmkoKSkpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoVG9vbHMubWFwKGJsb2JJbmZvcywgYmxvYkluZm8gPT4gdXBsb2FkU3RhdHVzLmlzUGVuZGluZyhibG9iSW5mby5ibG9iVXJpKCkpID8gcGVuZGluZ1VwbG9hZEJsb2JJbmZvKGJsb2JJbmZvKSA6IHVwbG9hZEJsb2JJbmZvKGJsb2JJbmZvLCB1cGxvYWRIYW5kbGVyLCBvcGVuTm90aWZpY2F0aW9uKSkpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHVwbG9hZCA9IChibG9iSW5mb3MsIG9wZW5Ob3RpZmljYXRpb24pID0+ICFzZXR0aW5ncy51cmwgJiYgaXNEZWZhdWx0SGFuZGxlcih1cGxvYWRIYW5kbGVyKSA/IG5vVXBsb2FkKCkgOiB1cGxvYWRCbG9icyhibG9iSW5mb3MsIG9wZW5Ob3RpZmljYXRpb24pO1xuICAgICAgcmV0dXJuIHsgdXBsb2FkIH07XG4gICAgfTtcblxuICAgIGNvbnN0IG9wZW5Ob3RpZmljYXRpb24gPSBlZGl0b3IgPT4gKCkgPT4gZWRpdG9yLm5vdGlmaWNhdGlvbk1hbmFnZXIub3Blbih7XG4gICAgICB0ZXh0OiBlZGl0b3IudHJhbnNsYXRlKCdJbWFnZSB1cGxvYWRpbmcuLi4nKSxcbiAgICAgIHR5cGU6ICdpbmZvJyxcbiAgICAgIHRpbWVvdXQ6IC0xLFxuICAgICAgcHJvZ3Jlc3NCYXI6IHRydWVcbiAgICB9KTtcbiAgICBjb25zdCBjcmVhdGVVcGxvYWRlciA9IChlZGl0b3IsIHVwbG9hZFN0YXR1cykgPT4gVXBsb2FkZXIodXBsb2FkU3RhdHVzLCB7XG4gICAgICB1cmw6IGdldEltYWdlVXBsb2FkVXJsKGVkaXRvciksXG4gICAgICBiYXNlUGF0aDogZ2V0SW1hZ2VVcGxvYWRCYXNlUGF0aChlZGl0b3IpLFxuICAgICAgY3JlZGVudGlhbHM6IGdldEltYWdlc1VwbG9hZENyZWRlbnRpYWxzKGVkaXRvciksXG4gICAgICBoYW5kbGVyOiBnZXRJbWFnZXNVcGxvYWRIYW5kbGVyKGVkaXRvcilcbiAgICB9KTtcbiAgICBjb25zdCBJbWFnZVVwbG9hZGVyID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IHVwbG9hZFN0YXR1cyA9IFVwbG9hZFN0YXR1cygpO1xuICAgICAgY29uc3QgdXBsb2FkZXIgPSBjcmVhdGVVcGxvYWRlcihlZGl0b3IsIHVwbG9hZFN0YXR1cyk7XG4gICAgICByZXR1cm4geyB1cGxvYWQ6IChibG9iSW5mb3MsIHNob3dOb3RpZmljYXRpb24gPSB0cnVlKSA9PiB1cGxvYWRlci51cGxvYWQoYmxvYkluZm9zLCBzaG93Tm90aWZpY2F0aW9uID8gb3Blbk5vdGlmaWNhdGlvbihlZGl0b3IpIDogdW5kZWZpbmVkKSB9O1xuICAgIH07XG5cbiAgICBjb25zdCBFZGl0b3JVcGxvYWQgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgYmxvYkNhY2hlID0gQmxvYkNhY2hlKCk7XG4gICAgICBsZXQgdXBsb2FkZXIsIGltYWdlU2Nhbm5lcjtcbiAgICAgIGNvbnN0IHVwbG9hZFN0YXR1cyA9IFVwbG9hZFN0YXR1cygpO1xuICAgICAgY29uc3QgdXJsRmlsdGVycyA9IFtdO1xuICAgICAgY29uc3QgYWxpdmVHdWFyZCA9IGNhbGxiYWNrID0+IHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA9PiB7XG4gICAgICAgICAgaWYgKGVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgY29uc3QgY2FjaGVJbnZhbGlkYXRvciA9IHVybCA9PiB1cmwgKyAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICBjb25zdCByZXBsYWNlU3RyaW5nID0gKGNvbnRlbnQsIHNlYXJjaCwgcmVwbGFjZSkgPT4ge1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgaW5kZXggPSBjb250ZW50LmluZGV4T2Yoc2VhcmNoLCBpbmRleCk7XG4gICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuc3Vic3RyaW5nKDAsIGluZGV4KSArIHJlcGxhY2UgKyBjb250ZW50LnN1YnN0cihpbmRleCArIHNlYXJjaC5sZW5ndGgpO1xuICAgICAgICAgICAgaW5kZXggKz0gcmVwbGFjZS5sZW5ndGggLSBzZWFyY2gubGVuZ3RoICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGluZGV4ICE9PSAtMSk7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlcGxhY2VJbWFnZVVybCA9IChjb250ZW50LCB0YXJnZXRVcmwsIHJlcGxhY2VtZW50VXJsKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcGxhY2VtZW50U3RyaW5nID0gYHNyYz1cIiR7IHJlcGxhY2VtZW50VXJsIH1cIiR7IHJlcGxhY2VtZW50VXJsID09PSBFbnYudHJhbnNwYXJlbnRTcmMgPyAnIGRhdGEtbWNlLXBsYWNlaG9sZGVyPVwiMVwiJyA6ICcnIH1gO1xuICAgICAgICBjb250ZW50ID0gcmVwbGFjZVN0cmluZyhjb250ZW50LCBgc3JjPVwiJHsgdGFyZ2V0VXJsIH1cImAsIHJlcGxhY2VtZW50U3RyaW5nKTtcbiAgICAgICAgY29udGVudCA9IHJlcGxhY2VTdHJpbmcoY29udGVudCwgJ2RhdGEtbWNlLXNyYz1cIicgKyB0YXJnZXRVcmwgKyAnXCInLCAnZGF0YS1tY2Utc3JjPVwiJyArIHJlcGxhY2VtZW50VXJsICsgJ1wiJyk7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlcGxhY2VVcmxJblVuZG9TdGFjayA9ICh0YXJnZXRVcmwsIHJlcGxhY2VtZW50VXJsKSA9PiB7XG4gICAgICAgIGVhY2gkZShlZGl0b3IudW5kb01hbmFnZXIuZGF0YSwgbGV2ZWwgPT4ge1xuICAgICAgICAgIGlmIChsZXZlbC50eXBlID09PSAnZnJhZ21lbnRlZCcpIHtcbiAgICAgICAgICAgIGxldmVsLmZyYWdtZW50cyA9IG1hcCQzKGxldmVsLmZyYWdtZW50cywgZnJhZ21lbnQgPT4gcmVwbGFjZUltYWdlVXJsKGZyYWdtZW50LCB0YXJnZXRVcmwsIHJlcGxhY2VtZW50VXJsKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldmVsLmNvbnRlbnQgPSByZXBsYWNlSW1hZ2VVcmwobGV2ZWwuY29udGVudCwgdGFyZ2V0VXJsLCByZXBsYWNlbWVudFVybCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCByZXBsYWNlSW1hZ2VVcmlJblZpZXcgPSAoaW1hZ2UsIHJlc3VsdFVyaSkgPT4ge1xuICAgICAgICBjb25zdCBzcmMgPSBlZGl0b3IuY29udmVydFVSTChyZXN1bHRVcmksICdzcmMnKTtcbiAgICAgICAgcmVwbGFjZVVybEluVW5kb1N0YWNrKGltYWdlLnNyYywgcmVzdWx0VXJpKTtcbiAgICAgICAgc2V0QWxsJDEoU3VnYXJFbGVtZW50LmZyb21Eb20oaW1hZ2UpLCB7XG4gICAgICAgICAgJ3NyYyc6IHNob3VsZFJldXNlRmlsZU5hbWUoZWRpdG9yKSA/IGNhY2hlSW52YWxpZGF0b3IocmVzdWx0VXJpKSA6IHJlc3VsdFVyaSxcbiAgICAgICAgICAnZGF0YS1tY2Utc3JjJzogc3JjXG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHVwbG9hZEltYWdlcyA9ICgpID0+IHtcbiAgICAgICAgaWYgKCF1cGxvYWRlcikge1xuICAgICAgICAgIHVwbG9hZGVyID0gY3JlYXRlVXBsb2FkZXIoZWRpdG9yLCB1cGxvYWRTdGF0dXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2FuRm9ySW1hZ2VzKCkudGhlbihhbGl2ZUd1YXJkKGltYWdlSW5mb3MgPT4ge1xuICAgICAgICAgIGNvbnN0IGJsb2JJbmZvcyA9IG1hcCQzKGltYWdlSW5mb3MsIGltYWdlSW5mbyA9PiBpbWFnZUluZm8uYmxvYkluZm8pO1xuICAgICAgICAgIHJldHVybiB1cGxvYWRlci51cGxvYWQoYmxvYkluZm9zLCBvcGVuTm90aWZpY2F0aW9uKGVkaXRvcikpLnRoZW4oYWxpdmVHdWFyZChyZXN1bHQgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW1hZ2VzVG9SZW1vdmUgPSBbXTtcbiAgICAgICAgICAgIGxldCBzaG91bGREaXNwYXRjaENoYW5nZSA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyZWRSZXN1bHQgPSBtYXAkMyhyZXN1bHQsICh1cGxvYWRJbmZvLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCB7YmxvYkluZm8sIGltYWdlfSA9IGltYWdlSW5mb3NbaW5kZXhdO1xuICAgICAgICAgICAgICBsZXQgcmVtb3ZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBpZiAodXBsb2FkSW5mby5zdGF0dXMgJiYgc2hvdWxkUmVwbGFjZUJsb2JVcmlzKGVkaXRvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAodXBsb2FkSW5mby51cmwgJiYgIWNvbnRhaW5zJDEoaW1hZ2Uuc3JjLCB1cGxvYWRJbmZvLnVybCkpIHtcbiAgICAgICAgICAgICAgICAgIHNob3VsZERpc3BhdGNoQ2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmxvYkNhY2hlLnJlbW92ZUJ5VXJpKGltYWdlLnNyYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlzUnRjKGVkaXRvcikpIDsgZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXBsYWNlSW1hZ2VVcmlJblZpZXcoaW1hZ2UsIHVwbG9hZEluZm8udXJsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodXBsb2FkSW5mby5lcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICh1cGxvYWRJbmZvLmVycm9yLnJlbW92ZSkge1xuICAgICAgICAgICAgICAgICAgcmVwbGFjZVVybEluVW5kb1N0YWNrKGltYWdlLnNyYywgRW52LnRyYW5zcGFyZW50U3JjKTtcbiAgICAgICAgICAgICAgICAgIGltYWdlc1RvUmVtb3ZlLnB1c2goaW1hZ2UpO1xuICAgICAgICAgICAgICAgICAgcmVtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVwbG9hZEVycm9yKGVkaXRvciwgdXBsb2FkSW5mby5lcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGltYWdlLFxuICAgICAgICAgICAgICAgIHN0YXR1czogdXBsb2FkSW5mby5zdGF0dXMsXG4gICAgICAgICAgICAgICAgdXBsb2FkVXJpOiB1cGxvYWRJbmZvLnVybCxcbiAgICAgICAgICAgICAgICBibG9iSW5mbyxcbiAgICAgICAgICAgICAgICByZW1vdmVkXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpbWFnZXNUb1JlbW92ZS5sZW5ndGggPiAwICYmICFpc1J0YyhlZGl0b3IpKSB7XG4gICAgICAgICAgICAgIGVkaXRvci51bmRvTWFuYWdlci50cmFuc2FjdCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgZWFjaCRlKGltYWdlc1RvUmVtb3ZlLCBlbGVtZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgIGVkaXRvci5kb20ucmVtb3ZlKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgYmxvYkNhY2hlLnJlbW92ZUJ5VXJpKGVsZW1lbnQuc3JjKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNob3VsZERpc3BhdGNoQ2hhbmdlKSB7XG4gICAgICAgICAgICAgIGVkaXRvci51bmRvTWFuYWdlci5kaXNwYXRjaENoYW5nZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcmVkUmVzdWx0O1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSkpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHVwbG9hZEltYWdlc0F1dG8gPSAoKSA9PiBpc0F1dG9tYXRpY1VwbG9hZHNFbmFibGVkKGVkaXRvcikgPyB1cGxvYWRJbWFnZXMoKSA6IFByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgICBjb25zdCBpc1ZhbGlkRGF0YVVyaUltYWdlID0gaW1nRWxtID0+IGZvcmFsbCh1cmxGaWx0ZXJzLCBmaWx0ZXIgPT4gZmlsdGVyKGltZ0VsbSkpO1xuICAgICAgY29uc3QgYWRkRmlsdGVyID0gZmlsdGVyID0+IHtcbiAgICAgICAgdXJsRmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2NhbkZvckltYWdlcyA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFpbWFnZVNjYW5uZXIpIHtcbiAgICAgICAgICBpbWFnZVNjYW5uZXIgPSBJbWFnZVNjYW5uZXIodXBsb2FkU3RhdHVzLCBibG9iQ2FjaGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbWFnZVNjYW5uZXIuZmluZEFsbChlZGl0b3IuZ2V0Qm9keSgpLCBpc1ZhbGlkRGF0YVVyaUltYWdlKS50aGVuKGFsaXZlR3VhcmQocmVzdWx0ID0+IHtcbiAgICAgICAgICBjb25zdCBmaWx0ZXJlZFJlc3VsdCA9IGZpbHRlciQ1KHJlc3VsdCwgcmVzdWx0SXRlbSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcocmVzdWx0SXRlbSkpIHtcbiAgICAgICAgICAgICAgZGlzcGxheUVycm9yKGVkaXRvciwgcmVzdWx0SXRlbSk7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0SXRlbS51cmlUeXBlID09PSAnYmxvYicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGlzUnRjKGVkaXRvcikpIDsgZWxzZSB7XG4gICAgICAgICAgICBlYWNoJGUoZmlsdGVyZWRSZXN1bHQsIHJlc3VsdEl0ZW0gPT4ge1xuICAgICAgICAgICAgICByZXBsYWNlVXJsSW5VbmRvU3RhY2socmVzdWx0SXRlbS5pbWFnZS5zcmMsIHJlc3VsdEl0ZW0uYmxvYkluZm8uYmxvYlVyaSgpKTtcbiAgICAgICAgICAgICAgcmVzdWx0SXRlbS5pbWFnZS5zcmMgPSByZXN1bHRJdGVtLmJsb2JJbmZvLmJsb2JVcmkoKTtcbiAgICAgICAgICAgICAgcmVzdWx0SXRlbS5pbWFnZS5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtbWNlLXNyYycpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmaWx0ZXJlZFJlc3VsdDtcbiAgICAgICAgfSkpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGRlc3Ryb3kgPSAoKSA9PiB7XG4gICAgICAgIGJsb2JDYWNoZS5kZXN0cm95KCk7XG4gICAgICAgIHVwbG9hZFN0YXR1cy5kZXN0cm95KCk7XG4gICAgICAgIGltYWdlU2Nhbm5lciA9IHVwbG9hZGVyID0gbnVsbDtcbiAgICAgIH07XG4gICAgICBjb25zdCByZXBsYWNlQmxvYlVyaXMgPSBjb250ZW50ID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQucmVwbGFjZSgvc3JjPVwiKGJsb2I6W15cIl0rKVwiL2csIChtYXRjaCwgYmxvYlVyaSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdFVyaSA9IHVwbG9hZFN0YXR1cy5nZXRSZXN1bHRVcmkoYmxvYlVyaSk7XG4gICAgICAgICAgaWYgKHJlc3VsdFVyaSkge1xuICAgICAgICAgICAgcmV0dXJuICdzcmM9XCInICsgcmVzdWx0VXJpICsgJ1wiJztcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGJsb2JJbmZvID0gYmxvYkNhY2hlLmdldEJ5VXJpKGJsb2JVcmkpO1xuICAgICAgICAgIGlmICghYmxvYkluZm8pIHtcbiAgICAgICAgICAgIGJsb2JJbmZvID0gZm9sZGwoZWRpdG9yLmVkaXRvck1hbmFnZXIuZ2V0KCksIChyZXN1bHQsIGVkaXRvcikgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0IHx8IGVkaXRvci5lZGl0b3JVcGxvYWQgJiYgZWRpdG9yLmVkaXRvclVwbG9hZC5ibG9iQ2FjaGUuZ2V0QnlVcmkoYmxvYlVyaSk7XG4gICAgICAgICAgICB9LCB1bmRlZmluZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYmxvYkluZm8pIHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2IgPSBibG9iSW5mby5ibG9iKCk7XG4gICAgICAgICAgICByZXR1cm4gJ3NyYz1cImRhdGE6JyArIGJsb2IudHlwZSArICc7YmFzZTY0LCcgKyBibG9iSW5mby5iYXNlNjQoKSArICdcIic7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgZWRpdG9yLm9uKCdTZXRDb250ZW50JywgKCkgPT4ge1xuICAgICAgICBpZiAoaXNBdXRvbWF0aWNVcGxvYWRzRW5hYmxlZChlZGl0b3IpKSB7XG4gICAgICAgICAgdXBsb2FkSW1hZ2VzQXV0bygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjYW5Gb3JJbWFnZXMoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlZGl0b3Iub24oJ1Jhd1NhdmVDb250ZW50JywgZSA9PiB7XG4gICAgICAgIGUuY29udGVudCA9IHJlcGxhY2VCbG9iVXJpcyhlLmNvbnRlbnQpO1xuICAgICAgfSk7XG4gICAgICBlZGl0b3Iub24oJ0dldENvbnRlbnQnLCBlID0+IHtcbiAgICAgICAgaWYgKGUuc291cmNlX3ZpZXcgfHwgZS5mb3JtYXQgPT09ICdyYXcnIHx8IGUuZm9ybWF0ID09PSAndHJlZScpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZS5jb250ZW50ID0gcmVwbGFjZUJsb2JVcmlzKGUuY29udGVudCk7XG4gICAgICB9KTtcbiAgICAgIGVkaXRvci5vbignUG9zdFJlbmRlcicsICgpID0+IHtcbiAgICAgICAgZWRpdG9yLnBhcnNlci5hZGROb2RlRmlsdGVyKCdpbWcnLCBpbWFnZXMgPT4ge1xuICAgICAgICAgIGVhY2gkZShpbWFnZXMsIGltZyA9PiB7XG4gICAgICAgICAgICBjb25zdCBzcmMgPSBpbWcuYXR0cignc3JjJyk7XG4gICAgICAgICAgICBpZiAoIXNyYyB8fCBibG9iQ2FjaGUuZ2V0QnlVcmkoc3JjKSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHRVcmkgPSB1cGxvYWRTdGF0dXMuZ2V0UmVzdWx0VXJpKHNyYyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0VXJpKSB7XG4gICAgICAgICAgICAgIGltZy5hdHRyKCdzcmMnLCByZXN1bHRVcmkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYmxvYkNhY2hlLFxuICAgICAgICBhZGRGaWx0ZXIsXG4gICAgICAgIHVwbG9hZEltYWdlcyxcbiAgICAgICAgdXBsb2FkSW1hZ2VzQXV0byxcbiAgICAgICAgc2NhbkZvckltYWdlcyxcbiAgICAgICAgZGVzdHJveVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgZ2V0JDEgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbTtcbiAgICAgIGNvbnN0IHNjaGVtYVR5cGUgPSBlZGl0b3Iuc2NoZW1hLnR5cGU7XG4gICAgICBjb25zdCBmb3JtYXRzID0ge1xuICAgICAgICB2YWxpZ250b3A6IFt7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ3RkLHRoJyxcbiAgICAgICAgICAgIHN0eWxlczogeyB2ZXJ0aWNhbEFsaWduOiAndG9wJyB9XG4gICAgICAgICAgfV0sXG4gICAgICAgIHZhbGlnbm1pZGRsZTogW3tcbiAgICAgICAgICAgIHNlbGVjdG9yOiAndGQsdGgnLFxuICAgICAgICAgICAgc3R5bGVzOiB7IHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnIH1cbiAgICAgICAgICB9XSxcbiAgICAgICAgdmFsaWduYm90dG9tOiBbe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICd0ZCx0aCcsXG4gICAgICAgICAgICBzdHlsZXM6IHsgdmVydGljYWxBbGlnbjogJ2JvdHRvbScgfVxuICAgICAgICAgIH1dLFxuICAgICAgICBhbGlnbmxlZnQ6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ2ZpZ3VyZS5pbWFnZScsXG4gICAgICAgICAgICBjb2xsYXBzZWQ6IGZhbHNlLFxuICAgICAgICAgICAgY2xhc3NlczogJ2FsaWduLWxlZnQnLFxuICAgICAgICAgICAgY2VGYWxzZU92ZXJyaWRlOiB0cnVlLFxuICAgICAgICAgICAgcHJldmlldzogJ2ZvbnQtZmFtaWx5IGZvbnQtc2l6ZSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZmlndXJlLHAsaDEsaDIsaDMsaDQsaDUsaDYsdGQsdGgsdHIsZGl2LHVsLG9sLGxpLHByZScsXG4gICAgICAgICAgICBzdHlsZXM6IHsgdGV4dEFsaWduOiAnbGVmdCcgfSxcbiAgICAgICAgICAgIGluaGVyaXQ6IGZhbHNlLFxuICAgICAgICAgICAgcHJldmlldzogZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnaW1nLGF1ZGlvLHZpZGVvJyxcbiAgICAgICAgICAgIGNvbGxhcHNlZDogZmFsc2UsXG4gICAgICAgICAgICBzdHlsZXM6IHsgZmxvYXQ6ICdsZWZ0JyB9LFxuICAgICAgICAgICAgcHJldmlldzogJ2ZvbnQtZmFtaWx5IGZvbnQtc2l6ZSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAndGFibGUnLFxuICAgICAgICAgICAgY29sbGFwc2VkOiBmYWxzZSxcbiAgICAgICAgICAgIHN0eWxlczoge1xuICAgICAgICAgICAgICBtYXJnaW5MZWZ0OiAnMHB4JyxcbiAgICAgICAgICAgICAgbWFyZ2luUmlnaHQ6ICdhdXRvJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uZm9ybWF0OiB0YWJsZSA9PiB7XG4gICAgICAgICAgICAgIGRvbS5zZXRTdHlsZSh0YWJsZSwgJ2Zsb2F0JywgbnVsbCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJldmlldzogJ2ZvbnQtZmFtaWx5IGZvbnQtc2l6ZSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnLm1jZS1wcmV2aWV3LW9iamVjdCxbZGF0YS1lcGhveC1lbWJlZC1pcmldJyxcbiAgICAgICAgICAgIGNlRmFsc2VPdmVycmlkZTogdHJ1ZSxcbiAgICAgICAgICAgIHN0eWxlczogeyBmbG9hdDogJ2xlZnQnIH1cbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIGFsaWduY2VudGVyOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdmaWd1cmUscCxoMSxoMixoMyxoNCxoNSxoNix0ZCx0aCx0cixkaXYsdWwsb2wsbGkscHJlJyxcbiAgICAgICAgICAgIHN0eWxlczogeyB0ZXh0QWxpZ246ICdjZW50ZXInIH0sXG4gICAgICAgICAgICBpbmhlcml0OiBmYWxzZSxcbiAgICAgICAgICAgIHByZXZpZXc6ICdmb250LWZhbWlseSBmb250LXNpemUnXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ2ZpZ3VyZS5pbWFnZScsXG4gICAgICAgICAgICBjb2xsYXBzZWQ6IGZhbHNlLFxuICAgICAgICAgICAgY2xhc3NlczogJ2FsaWduLWNlbnRlcicsXG4gICAgICAgICAgICBjZUZhbHNlT3ZlcnJpZGU6IHRydWUsXG4gICAgICAgICAgICBwcmV2aWV3OiAnZm9udC1mYW1pbHkgZm9udC1zaXplJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdpbWcsYXVkaW8sdmlkZW8nLFxuICAgICAgICAgICAgY29sbGFwc2VkOiBmYWxzZSxcbiAgICAgICAgICAgIHN0eWxlczoge1xuICAgICAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICAgICAgICBtYXJnaW5MZWZ0OiAnYXV0bycsXG4gICAgICAgICAgICAgIG1hcmdpblJpZ2h0OiAnYXV0bydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmV2aWV3OiBmYWxzZVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgc2VsZWN0b3I6ICd0YWJsZScsXG4gICAgICAgICAgICBjb2xsYXBzZWQ6IGZhbHNlLFxuICAgICAgICAgICAgc3R5bGVzOiB7XG4gICAgICAgICAgICAgIG1hcmdpbkxlZnQ6ICdhdXRvJyxcbiAgICAgICAgICAgICAgbWFyZ2luUmlnaHQ6ICdhdXRvJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByZXZpZXc6ICdmb250LWZhbWlseSBmb250LXNpemUnXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzZWxlY3RvcjogJy5tY2UtcHJldmlldy1vYmplY3QnLFxuICAgICAgICAgICAgY2VGYWxzZU92ZXJyaWRlOiB0cnVlLFxuICAgICAgICAgICAgc3R5bGVzOiB7XG4gICAgICAgICAgICAgIGRpc3BsYXk6ICd0YWJsZScsXG4gICAgICAgICAgICAgIG1hcmdpbkxlZnQ6ICdhdXRvJyxcbiAgICAgICAgICAgICAgbWFyZ2luUmlnaHQ6ICdhdXRvJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByZXZpZXc6IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ1tkYXRhLWVwaG94LWVtYmVkLWlyaV0nLFxuICAgICAgICAgICAgY2VGYWxzZU92ZXJyaWRlOiB0cnVlLFxuICAgICAgICAgICAgc3R5bGVzOiB7XG4gICAgICAgICAgICAgIG1hcmdpbkxlZnQ6ICdhdXRvJyxcbiAgICAgICAgICAgICAgbWFyZ2luUmlnaHQ6ICdhdXRvJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByZXZpZXc6IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBhbGlnbnJpZ2h0OiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdmaWd1cmUuaW1hZ2UnLFxuICAgICAgICAgICAgY29sbGFwc2VkOiBmYWxzZSxcbiAgICAgICAgICAgIGNsYXNzZXM6ICdhbGlnbi1yaWdodCcsXG4gICAgICAgICAgICBjZUZhbHNlT3ZlcnJpZGU6IHRydWUsXG4gICAgICAgICAgICBwcmV2aWV3OiAnZm9udC1mYW1pbHkgZm9udC1zaXplJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdmaWd1cmUscCxoMSxoMixoMyxoNCxoNSxoNix0ZCx0aCx0cixkaXYsdWwsb2wsbGkscHJlJyxcbiAgICAgICAgICAgIHN0eWxlczogeyB0ZXh0QWxpZ246ICdyaWdodCcgfSxcbiAgICAgICAgICAgIGluaGVyaXQ6IGZhbHNlLFxuICAgICAgICAgICAgcHJldmlldzogJ2ZvbnQtZmFtaWx5IGZvbnQtc2l6ZSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnaW1nLGF1ZGlvLHZpZGVvJyxcbiAgICAgICAgICAgIGNvbGxhcHNlZDogZmFsc2UsXG4gICAgICAgICAgICBzdHlsZXM6IHsgZmxvYXQ6ICdyaWdodCcgfSxcbiAgICAgICAgICAgIHByZXZpZXc6ICdmb250LWZhbWlseSBmb250LXNpemUnXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ3RhYmxlJyxcbiAgICAgICAgICAgIGNvbGxhcHNlZDogZmFsc2UsXG4gICAgICAgICAgICBzdHlsZXM6IHtcbiAgICAgICAgICAgICAgbWFyZ2luUmlnaHQ6ICcwcHgnLFxuICAgICAgICAgICAgICBtYXJnaW5MZWZ0OiAnYXV0bydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbmZvcm1hdDogdGFibGUgPT4ge1xuICAgICAgICAgICAgICBkb20uc2V0U3R5bGUodGFibGUsICdmbG9hdCcsIG51bGwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByZXZpZXc6ICdmb250LWZhbWlseSBmb250LXNpemUnXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzZWxlY3RvcjogJy5tY2UtcHJldmlldy1vYmplY3QsW2RhdGEtZXBob3gtZW1iZWQtaXJpXScsXG4gICAgICAgICAgICBjZUZhbHNlT3ZlcnJpZGU6IHRydWUsXG4gICAgICAgICAgICBzdHlsZXM6IHsgZmxvYXQ6ICdyaWdodCcgfSxcbiAgICAgICAgICAgIHByZXZpZXc6IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBhbGlnbmp1c3RpZnk6IFt7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ2ZpZ3VyZSxwLGgxLGgyLGgzLGg0LGg1LGg2LHRkLHRoLHRyLGRpdix1bCxvbCxsaSxwcmUnLFxuICAgICAgICAgICAgc3R5bGVzOiB7IHRleHRBbGlnbjogJ2p1c3RpZnknIH0sXG4gICAgICAgICAgICBpbmhlcml0OiBmYWxzZSxcbiAgICAgICAgICAgIHByZXZpZXc6ICdmb250LWZhbWlseSBmb250LXNpemUnXG4gICAgICAgICAgfV0sXG4gICAgICAgIGJvbGQ6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpbmxpbmU6ICdzdHJvbmcnLFxuICAgICAgICAgICAgcmVtb3ZlOiAnYWxsJyxcbiAgICAgICAgICAgIHByZXNlcnZlX2F0dHJpYnV0ZXM6IFtcbiAgICAgICAgICAgICAgJ2NsYXNzJyxcbiAgICAgICAgICAgICAgJ3N0eWxlJ1xuICAgICAgICAgICAgXVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaW5saW5lOiAnc3BhbicsXG4gICAgICAgICAgICBzdHlsZXM6IHsgZm9udFdlaWdodDogJ2JvbGQnIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlubGluZTogJ2InLFxuICAgICAgICAgICAgcmVtb3ZlOiAnYWxsJyxcbiAgICAgICAgICAgIHByZXNlcnZlX2F0dHJpYnV0ZXM6IFtcbiAgICAgICAgICAgICAgJ2NsYXNzJyxcbiAgICAgICAgICAgICAgJ3N0eWxlJ1xuICAgICAgICAgICAgXVxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgaXRhbGljOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgaW5saW5lOiAnZW0nLFxuICAgICAgICAgICAgcmVtb3ZlOiAnYWxsJyxcbiAgICAgICAgICAgIHByZXNlcnZlX2F0dHJpYnV0ZXM6IFtcbiAgICAgICAgICAgICAgJ2NsYXNzJyxcbiAgICAgICAgICAgICAgJ3N0eWxlJ1xuICAgICAgICAgICAgXVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaW5saW5lOiAnc3BhbicsXG4gICAgICAgICAgICBzdHlsZXM6IHsgZm9udFN0eWxlOiAnaXRhbGljJyB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpbmxpbmU6ICdpJyxcbiAgICAgICAgICAgIHJlbW92ZTogJ2FsbCcsXG4gICAgICAgICAgICBwcmVzZXJ2ZV9hdHRyaWJ1dGVzOiBbXG4gICAgICAgICAgICAgICdjbGFzcycsXG4gICAgICAgICAgICAgICdzdHlsZSdcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHVuZGVybGluZTogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlubGluZTogJ3NwYW4nLFxuICAgICAgICAgICAgc3R5bGVzOiB7IHRleHREZWNvcmF0aW9uOiAndW5kZXJsaW5lJyB9LFxuICAgICAgICAgICAgZXhhY3Q6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlubGluZTogJ3UnLFxuICAgICAgICAgICAgcmVtb3ZlOiAnYWxsJyxcbiAgICAgICAgICAgIHByZXNlcnZlX2F0dHJpYnV0ZXM6IFtcbiAgICAgICAgICAgICAgJ2NsYXNzJyxcbiAgICAgICAgICAgICAgJ3N0eWxlJ1xuICAgICAgICAgICAgXVxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgc3RyaWtldGhyb3VnaDogKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBzcGFuID0ge1xuICAgICAgICAgICAgaW5saW5lOiAnc3BhbicsXG4gICAgICAgICAgICBzdHlsZXM6IHsgdGV4dERlY29yYXRpb246ICdsaW5lLXRocm91Z2gnIH0sXG4gICAgICAgICAgICBleGFjdDogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3Qgc3RyaWtlID0ge1xuICAgICAgICAgICAgaW5saW5lOiAnc3RyaWtlJyxcbiAgICAgICAgICAgIHJlbW92ZTogJ2FsbCcsXG4gICAgICAgICAgICBwcmVzZXJ2ZV9hdHRyaWJ1dGVzOiBbXG4gICAgICAgICAgICAgICdjbGFzcycsXG4gICAgICAgICAgICAgICdzdHlsZSdcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IHMgPSB7XG4gICAgICAgICAgICBpbmxpbmU6ICdzJyxcbiAgICAgICAgICAgIHJlbW92ZTogJ2FsbCcsXG4gICAgICAgICAgICBwcmVzZXJ2ZV9hdHRyaWJ1dGVzOiBbXG4gICAgICAgICAgICAgICdjbGFzcycsXG4gICAgICAgICAgICAgICdzdHlsZSdcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBzY2hlbWFUeXBlICE9PSAnaHRtbDQnID8gW1xuICAgICAgICAgICAgcyxcbiAgICAgICAgICAgIHNwYW4sXG4gICAgICAgICAgICBzdHJpa2VcbiAgICAgICAgICBdIDogW1xuICAgICAgICAgICAgc3BhbixcbiAgICAgICAgICAgIHMsXG4gICAgICAgICAgICBzdHJpa2VcbiAgICAgICAgICBdO1xuICAgICAgICB9KSgpLFxuICAgICAgICBmb3JlY29sb3I6IHtcbiAgICAgICAgICBpbmxpbmU6ICdzcGFuJyxcbiAgICAgICAgICBzdHlsZXM6IHsgY29sb3I6ICcldmFsdWUnIH0sXG4gICAgICAgICAgbGlua3M6IHRydWUsXG4gICAgICAgICAgcmVtb3ZlX3NpbWlsYXI6IHRydWUsXG4gICAgICAgICAgY2xlYXJfY2hpbGRfc3R5bGVzOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGhpbGl0ZWNvbG9yOiB7XG4gICAgICAgICAgaW5saW5lOiAnc3BhbicsXG4gICAgICAgICAgc3R5bGVzOiB7IGJhY2tncm91bmRDb2xvcjogJyV2YWx1ZScgfSxcbiAgICAgICAgICBsaW5rczogdHJ1ZSxcbiAgICAgICAgICByZW1vdmVfc2ltaWxhcjogdHJ1ZSxcbiAgICAgICAgICBjbGVhcl9jaGlsZF9zdHlsZXM6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgZm9udG5hbWU6IHtcbiAgICAgICAgICBpbmxpbmU6ICdzcGFuJyxcbiAgICAgICAgICB0b2dnbGU6IGZhbHNlLFxuICAgICAgICAgIHN0eWxlczogeyBmb250RmFtaWx5OiAnJXZhbHVlJyB9LFxuICAgICAgICAgIGNsZWFyX2NoaWxkX3N0eWxlczogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBmb250c2l6ZToge1xuICAgICAgICAgIGlubGluZTogJ3NwYW4nLFxuICAgICAgICAgIHRvZ2dsZTogZmFsc2UsXG4gICAgICAgICAgc3R5bGVzOiB7IGZvbnRTaXplOiAnJXZhbHVlJyB9LFxuICAgICAgICAgIGNsZWFyX2NoaWxkX3N0eWxlczogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBsaW5laGVpZ2h0OiB7XG4gICAgICAgICAgc2VsZWN0b3I6ICdoMSxoMixoMyxoNCxoNSxoNixwLGxpLHRkLHRoLGRpdicsXG4gICAgICAgICAgc3R5bGVzOiB7IGxpbmVIZWlnaHQ6ICcldmFsdWUnIH1cbiAgICAgICAgfSxcbiAgICAgICAgZm9udHNpemVfY2xhc3M6IHtcbiAgICAgICAgICBpbmxpbmU6ICdzcGFuJyxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB7IGNsYXNzOiAnJXZhbHVlJyB9XG4gICAgICAgIH0sXG4gICAgICAgIGJsb2NrcXVvdGU6IHtcbiAgICAgICAgICBibG9jazogJ2Jsb2NrcXVvdGUnLFxuICAgICAgICAgIHdyYXBwZXI6IHRydWUsXG4gICAgICAgICAgcmVtb3ZlOiAnYWxsJ1xuICAgICAgICB9LFxuICAgICAgICBzdWJzY3JpcHQ6IHsgaW5saW5lOiAnc3ViJyB9LFxuICAgICAgICBzdXBlcnNjcmlwdDogeyBpbmxpbmU6ICdzdXAnIH0sXG4gICAgICAgIGNvZGU6IHsgaW5saW5lOiAnY29kZScgfSxcbiAgICAgICAgbGluazoge1xuICAgICAgICAgIGlubGluZTogJ2EnLFxuICAgICAgICAgIHNlbGVjdG9yOiAnYScsXG4gICAgICAgICAgcmVtb3ZlOiAnYWxsJyxcbiAgICAgICAgICBzcGxpdDogdHJ1ZSxcbiAgICAgICAgICBkZWVwOiB0cnVlLFxuICAgICAgICAgIG9ubWF0Y2g6IChub2RlLCBfZm10LCBfaXRlbU5hbWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBpc0VsZW1lbnQkNihub2RlKSAmJiBub2RlLmhhc0F0dHJpYnV0ZSgnaHJlZicpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25mb3JtYXQ6IChlbG0sIF9mbXQsIHZhcnMpID0+IHtcbiAgICAgICAgICAgIFRvb2xzLmVhY2godmFycywgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgZG9tLnNldEF0dHJpYihlbG0sIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsYW5nOiB7XG4gICAgICAgICAgaW5saW5lOiAnc3BhbicsXG4gICAgICAgICAgY2xlYXJfY2hpbGRfc3R5bGVzOiB0cnVlLFxuICAgICAgICAgIHJlbW92ZV9zaW1pbGFyOiB0cnVlLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICdsYW5nJzogJyV2YWx1ZScsXG4gICAgICAgICAgICAnZGF0YS1tY2UtbGFuZyc6IHZhcnMgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgIHJldHVybiAoX2EgPSB2YXJzID09PSBudWxsIHx8IHZhcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhcnMuY3VzdG9tVmFsdWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZW1vdmVmb3JtYXQ6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ2Isc3Ryb25nLGVtLGksZm9udCx1LHN0cmlrZSxzLHN1YixzdXAsZGZuLGNvZGUsc2FtcCxrYmQsdmFyLGNpdGUsbWFyayxxLGRlbCxpbnMsc21hbGwnLFxuICAgICAgICAgICAgcmVtb3ZlOiAnYWxsJyxcbiAgICAgICAgICAgIHNwbGl0OiB0cnVlLFxuICAgICAgICAgICAgZXhwYW5kOiBmYWxzZSxcbiAgICAgICAgICAgIGJsb2NrX2V4cGFuZDogdHJ1ZSxcbiAgICAgICAgICAgIGRlZXA6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnc3BhbicsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBbXG4gICAgICAgICAgICAgICdzdHlsZScsXG4gICAgICAgICAgICAgICdjbGFzcydcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICByZW1vdmU6ICdlbXB0eScsXG4gICAgICAgICAgICBzcGxpdDogdHJ1ZSxcbiAgICAgICAgICAgIGV4cGFuZDogZmFsc2UsXG4gICAgICAgICAgICBkZWVwOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzZWxlY3RvcjogJyonLFxuICAgICAgICAgICAgYXR0cmlidXRlczogW1xuICAgICAgICAgICAgICAnc3R5bGUnLFxuICAgICAgICAgICAgICAnY2xhc3MnXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgc3BsaXQ6IGZhbHNlLFxuICAgICAgICAgICAgZXhwYW5kOiBmYWxzZSxcbiAgICAgICAgICAgIGRlZXA6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH07XG4gICAgICBUb29scy5lYWNoKCdwIGgxIGgyIGgzIGg0IGg1IGg2IGRpdiBhZGRyZXNzIHByZSBkdCBkZCBzYW1wJy5zcGxpdCgvXFxzLyksIG5hbWUgPT4ge1xuICAgICAgICBmb3JtYXRzW25hbWVdID0ge1xuICAgICAgICAgIGJsb2NrOiBuYW1lLFxuICAgICAgICAgIHJlbW92ZTogJ2FsbCdcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZvcm1hdHM7XG4gICAgfTtcblxuICAgIGNvbnN0IGdlbmVyaWNCYXNlID0ge1xuICAgICAgcmVtb3ZlX3NpbWlsYXI6IHRydWUsXG4gICAgICBpbmhlcml0OiBmYWxzZVxuICAgIH07XG4gICAgY29uc3QgY2VsbEJhc2UgPSB7XG4gICAgICBzZWxlY3RvcjogJ3RkLHRoJyxcbiAgICAgIC4uLmdlbmVyaWNCYXNlXG4gICAgfTtcbiAgICBjb25zdCBjZWxsRm9ybWF0cyA9IHtcbiAgICAgIHRhYmxlY2VsbGJhY2tncm91bmRjb2xvcjoge1xuICAgICAgICBzdHlsZXM6IHsgYmFja2dyb3VuZENvbG9yOiAnJXZhbHVlJyB9LFxuICAgICAgICAuLi5jZWxsQmFzZVxuICAgICAgfSxcbiAgICAgIHRhYmxlY2VsbHZlcnRpY2FsYWxpZ246IHtcbiAgICAgICAgc3R5bGVzOiB7ICd2ZXJ0aWNhbC1hbGlnbic6ICcldmFsdWUnIH0sXG4gICAgICAgIC4uLmNlbGxCYXNlXG4gICAgICB9LFxuICAgICAgdGFibGVjZWxsYm9yZGVyY29sb3I6IHtcbiAgICAgICAgc3R5bGVzOiB7IGJvcmRlckNvbG9yOiAnJXZhbHVlJyB9LFxuICAgICAgICAuLi5jZWxsQmFzZVxuICAgICAgfSxcbiAgICAgIHRhYmxlY2VsbGNsYXNzOiB7XG4gICAgICAgIGNsYXNzZXM6IFsnJXZhbHVlJ10sXG4gICAgICAgIC4uLmNlbGxCYXNlXG4gICAgICB9LFxuICAgICAgdGFibGVjbGFzczoge1xuICAgICAgICBzZWxlY3RvcjogJ3RhYmxlJyxcbiAgICAgICAgY2xhc3NlczogWycldmFsdWUnXSxcbiAgICAgICAgLi4uZ2VuZXJpY0Jhc2VcbiAgICAgIH0sXG4gICAgICB0YWJsZWNlbGxib3JkZXJzdHlsZToge1xuICAgICAgICBzdHlsZXM6IHsgYm9yZGVyU3R5bGU6ICcldmFsdWUnIH0sXG4gICAgICAgIC4uLmNlbGxCYXNlXG4gICAgICB9LFxuICAgICAgdGFibGVjZWxsYm9yZGVyd2lkdGg6IHtcbiAgICAgICAgc3R5bGVzOiB7IGJvcmRlcldpZHRoOiAnJXZhbHVlJyB9LFxuICAgICAgICAuLi5jZWxsQmFzZVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZ2V0ID0gY29uc3RhbnQoY2VsbEZvcm1hdHMpO1xuXG4gICAgY29uc3QgRm9ybWF0UmVnaXN0cnkgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgZm9ybWF0cyA9IHt9O1xuICAgICAgY29uc3QgZ2V0JDIgPSBuYW1lID0+IGlzTm9uTnVsbGFibGUobmFtZSkgPyBmb3JtYXRzW25hbWVdIDogZm9ybWF0cztcbiAgICAgIGNvbnN0IGhhcyA9IG5hbWUgPT4gaGFzJDIoZm9ybWF0cywgbmFtZSk7XG4gICAgICBjb25zdCByZWdpc3RlciA9IChuYW1lLCBmb3JtYXQpID0+IHtcbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICBpZiAoIWlzU3RyaW5nKG5hbWUpKSB7XG4gICAgICAgICAgICBlYWNoJGQobmFtZSwgKGZvcm1hdCwgbmFtZSkgPT4ge1xuICAgICAgICAgICAgICByZWdpc3RlcihuYW1lLCBmb3JtYXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaXNBcnJheSQxKGZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgZm9ybWF0ID0gW2Zvcm1hdF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlYWNoJGUoZm9ybWF0LCBmb3JtYXQgPT4ge1xuICAgICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoZm9ybWF0LmRlZXApKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0LmRlZXAgPSAhaXNTZWxlY3RvckZvcm1hdChmb3JtYXQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChmb3JtYXQuc3BsaXQpKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0LnNwbGl0ID0gIWlzU2VsZWN0b3JGb3JtYXQoZm9ybWF0KSB8fCBpc0lubGluZUZvcm1hdChmb3JtYXQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChmb3JtYXQucmVtb3ZlKSAmJiBpc1NlbGVjdG9yRm9ybWF0KGZvcm1hdCkgJiYgIWlzSW5saW5lRm9ybWF0KGZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICBmb3JtYXQucmVtb3ZlID0gJ25vbmUnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpc1NlbGVjdG9yRm9ybWF0KGZvcm1hdCkgJiYgaXNJbmxpbmVGb3JtYXQoZm9ybWF0KSkge1xuICAgICAgICAgICAgICAgIGZvcm1hdC5taXhlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9ybWF0LmJsb2NrX2V4cGFuZCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGZvcm1hdC5jbGFzc2VzKSkge1xuICAgICAgICAgICAgICAgIGZvcm1hdC5jbGFzc2VzID0gZm9ybWF0LmNsYXNzZXMuc3BsaXQoL1xccysvKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3JtYXRzW25hbWVdID0gZm9ybWF0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHVucmVnaXN0ZXIgPSBuYW1lID0+IHtcbiAgICAgICAgaWYgKG5hbWUgJiYgZm9ybWF0c1tuYW1lXSkge1xuICAgICAgICAgIGRlbGV0ZSBmb3JtYXRzW25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXRzO1xuICAgICAgfTtcbiAgICAgIHJlZ2lzdGVyKGdldCQxKGVkaXRvcikpO1xuICAgICAgcmVnaXN0ZXIoZ2V0KCkpO1xuICAgICAgcmVnaXN0ZXIoZ2V0Rm9ybWF0cyhlZGl0b3IpKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGdldDogZ2V0JDIsXG4gICAgICAgIGhhcyxcbiAgICAgICAgcmVnaXN0ZXIsXG4gICAgICAgIHVucmVnaXN0ZXJcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IGVhY2gkMyA9IFRvb2xzLmVhY2g7XG4gICAgY29uc3QgZG9tID0gRE9NVXRpbHMuRE9NO1xuICAgIGNvbnN0IGlzUHJldmlld0l0ZW0gPSBpdGVtID0+IGlzTm9uTnVsbGFibGUoaXRlbSkgJiYgaXNPYmplY3QoaXRlbSk7XG4gICAgY29uc3QgcGFyc2VkU2VsZWN0b3JUb0h0bWwgPSAoYW5jZXN0cnksIGVkaXRvcikgPT4ge1xuICAgICAgY29uc3Qgc2NoZW1hID0gZWRpdG9yICYmIGVkaXRvci5zY2hlbWEgfHwgU2NoZW1hKHt9KTtcbiAgICAgIGNvbnN0IGRlY29yYXRlID0gKGVsbSwgaXRlbSkgPT4ge1xuICAgICAgICBpZiAoaXRlbS5jbGFzc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBkb20uYWRkQ2xhc3MoZWxtLCBpdGVtLmNsYXNzZXMuam9pbignICcpKTtcbiAgICAgICAgfVxuICAgICAgICBkb20uc2V0QXR0cmlicyhlbG0sIGl0ZW0uYXR0cnMpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGNyZWF0ZUVsZW1lbnQgPSBzSXRlbSA9PiB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBpc1N0cmluZyhzSXRlbSkgPyB7XG4gICAgICAgICAgbmFtZTogc0l0ZW0sXG4gICAgICAgICAgY2xhc3NlczogW10sXG4gICAgICAgICAgYXR0cnM6IHt9XG4gICAgICAgIH0gOiBzSXRlbTtcbiAgICAgICAgY29uc3QgZWxtID0gZG9tLmNyZWF0ZShpdGVtLm5hbWUpO1xuICAgICAgICBkZWNvcmF0ZShlbG0sIGl0ZW0pO1xuICAgICAgICByZXR1cm4gZWxtO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldFJlcXVpcmVkUGFyZW50ID0gKGVsbSwgY2FuZGlkYXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsbVJ1bGUgPSBzY2hlbWEuZ2V0RWxlbWVudFJ1bGUoZWxtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBjb25zdCBwYXJlbnRzUmVxdWlyZWQgPSBlbG1SdWxlID09PSBudWxsIHx8IGVsbVJ1bGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsbVJ1bGUucGFyZW50c1JlcXVpcmVkO1xuICAgICAgICBpZiAocGFyZW50c1JlcXVpcmVkICYmIHBhcmVudHNSZXF1aXJlZC5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIGNvbnRhaW5zJDIocGFyZW50c1JlcXVpcmVkLCBjYW5kaWRhdGUpID8gY2FuZGlkYXRlIDogcGFyZW50c1JlcXVpcmVkWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHdyYXBJbkh0bWwgPSAoZWxtLCBhbmNlc3RvcnMsIHNpYmxpbmdzKSA9PiB7XG4gICAgICAgIGxldCBwYXJlbnRDYW5kaWRhdGU7XG4gICAgICAgIGNvbnN0IGFuY2VzdG9yID0gYW5jZXN0b3JzWzBdO1xuICAgICAgICBjb25zdCBhbmNlc3Rvck5hbWUgPSBpc1ByZXZpZXdJdGVtKGFuY2VzdG9yKSA/IGFuY2VzdG9yLm5hbWUgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHBhcmVudFJlcXVpcmVkID0gZ2V0UmVxdWlyZWRQYXJlbnQoZWxtLCBhbmNlc3Rvck5hbWUpO1xuICAgICAgICBpZiAocGFyZW50UmVxdWlyZWQpIHtcbiAgICAgICAgICBpZiAoYW5jZXN0b3JOYW1lID09PSBwYXJlbnRSZXF1aXJlZCkge1xuICAgICAgICAgICAgcGFyZW50Q2FuZGlkYXRlID0gYW5jZXN0b3I7XG4gICAgICAgICAgICBhbmNlc3RvcnMgPSBhbmNlc3RvcnMuc2xpY2UoMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudENhbmRpZGF0ZSA9IHBhcmVudFJlcXVpcmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChhbmNlc3Rvcikge1xuICAgICAgICAgIHBhcmVudENhbmRpZGF0ZSA9IGFuY2VzdG9yO1xuICAgICAgICAgIGFuY2VzdG9ycyA9IGFuY2VzdG9ycy5zbGljZSgxKTtcbiAgICAgICAgfSBlbHNlIGlmICghc2libGluZ3MpIHtcbiAgICAgICAgICByZXR1cm4gZWxtO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHBhcmVudENhbmRpZGF0ZSA/IGNyZWF0ZUVsZW1lbnQocGFyZW50Q2FuZGlkYXRlKSA6IGRvbS5jcmVhdGUoJ2RpdicpO1xuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZWxtKTtcbiAgICAgICAgaWYgKHNpYmxpbmdzKSB7XG4gICAgICAgICAgVG9vbHMuZWFjaChzaWJsaW5ncywgc2libGluZyA9PiB7XG4gICAgICAgICAgICBjb25zdCBzaWJsaW5nRWxtID0gY3JlYXRlRWxlbWVudChzaWJsaW5nKTtcbiAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoc2libGluZ0VsbSwgZWxtKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJlbnRTaWJsaW5ncyA9IGlzUHJldmlld0l0ZW0ocGFyZW50Q2FuZGlkYXRlKSA/IHBhcmVudENhbmRpZGF0ZS5zaWJsaW5ncyA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHdyYXBJbkh0bWwocGFyZW50LCBhbmNlc3RvcnMsIHBhcmVudFNpYmxpbmdzKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBmcmFnbWVudCA9IGRvbS5jcmVhdGUoJ2RpdicpO1xuICAgICAgaWYgKGFuY2VzdHJ5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGFuY2VzdHJ5WzBdO1xuICAgICAgICBjb25zdCBlbG0gPSBjcmVhdGVFbGVtZW50KGl0ZW0pO1xuICAgICAgICBjb25zdCBzaWJsaW5ncyA9IGlzUHJldmlld0l0ZW0oaXRlbSkgPyBpdGVtLnNpYmxpbmdzIDogdW5kZWZpbmVkO1xuICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZCh3cmFwSW5IdG1sKGVsbSwgYW5jZXN0cnkuc2xpY2UoMSksIHNpYmxpbmdzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgfTtcbiAgICBjb25zdCBwYXJzZVNlbGVjdG9ySXRlbSA9IGl0ZW0gPT4ge1xuICAgICAgaXRlbSA9IFRvb2xzLnRyaW0oaXRlbSk7XG4gICAgICBsZXQgdGFnTmFtZSA9ICdkaXYnO1xuICAgICAgY29uc3Qgb2JqID0ge1xuICAgICAgICBuYW1lOiB0YWdOYW1lLFxuICAgICAgICBjbGFzc2VzOiBbXSxcbiAgICAgICAgYXR0cnM6IHt9LFxuICAgICAgICBzZWxlY3RvcjogaXRlbVxuICAgICAgfTtcbiAgICAgIGlmIChpdGVtICE9PSAnKicpIHtcbiAgICAgICAgdGFnTmFtZSA9IGl0ZW0ucmVwbGFjZSgvKD86KFsjXFwuXXw6Oj8pKFtcXHdcXC1dKyl8KFxcWykoW15cXF1dKylcXF0/KS9nLCAoJDAsICQxLCAkMiwgJDMsICQ0KSA9PiB7XG4gICAgICAgICAgc3dpdGNoICgkMSkge1xuICAgICAgICAgIGNhc2UgJyMnOlxuICAgICAgICAgICAgb2JqLmF0dHJzLmlkID0gJDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICcuJzpcbiAgICAgICAgICAgIG9iai5jbGFzc2VzLnB1c2goJDIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnOic6XG4gICAgICAgICAgICBpZiAoVG9vbHMuaW5BcnJheSgnY2hlY2tlZCBkaXNhYmxlZCBlbmFibGVkIHJlYWQtb25seSByZXF1aXJlZCcuc3BsaXQoJyAnKSwgJDIpICE9PSAtMSkge1xuICAgICAgICAgICAgICBvYmouYXR0cnNbJDJdID0gJDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCQzID09PSAnWycpIHtcbiAgICAgICAgICAgIGNvbnN0IG0gPSAkNC5tYXRjaCgvKFtcXHdcXC1dKykoPzpcXD1cXFwiKFteXFxcIl0rKSk/Lyk7XG4gICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICBvYmouYXR0cnNbbVsxXV0gPSBtWzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgb2JqLm5hbWUgPSB0YWdOYW1lIHx8ICdkaXYnO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICAgIGNvbnN0IHBhcnNlU2VsZWN0b3IgPSBzZWxlY3RvciA9PiB7XG4gICAgICBpZiAoIWlzU3RyaW5nKHNlbGVjdG9yKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnNwbGl0KC9cXHMqLFxccyovKVswXTtcbiAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZSgvXFxzKih+XFwrfH58XFwrfD4pXFxzKi9nLCAnJDEnKTtcbiAgICAgIHJldHVybiBUb29scy5tYXAoc2VsZWN0b3Iuc3BsaXQoLyg/Oj58XFxzKyg/IVteXFxbXFxdXStcXF0pKS8pLCBpdGVtID0+IHtcbiAgICAgICAgY29uc3Qgc2libGluZ3MgPSBUb29scy5tYXAoaXRlbS5zcGxpdCgvKD86flxcK3x+fFxcKykvKSwgcGFyc2VTZWxlY3Rvckl0ZW0pO1xuICAgICAgICBjb25zdCBvYmogPSBzaWJsaW5ncy5wb3AoKTtcbiAgICAgICAgaWYgKHNpYmxpbmdzLmxlbmd0aCkge1xuICAgICAgICAgIG9iai5zaWJsaW5ncyA9IHNpYmxpbmdzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9KS5yZXZlcnNlKCk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRDc3NUZXh0ID0gKGVkaXRvciwgZm9ybWF0KSA9PiB7XG4gICAgICBsZXQgcHJldmlld0NzcyA9ICcnO1xuICAgICAgbGV0IHByZXZpZXdTdHlsZXMgPSBnZXRQcmV2aWV3U3R5bGVzKGVkaXRvcik7XG4gICAgICBpZiAocHJldmlld1N0eWxlcyA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVtb3ZlVmFycyA9IHZhbCA9PiB7XG4gICAgICAgIHJldHVybiBpc1N0cmluZyh2YWwpID8gdmFsLnJlcGxhY2UoLyUoXFx3KykvZywgJycpIDogJyc7XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0Q29tcHV0ZWRTdHlsZSA9IChuYW1lLCBlbG0pID0+IHtcbiAgICAgICAgcmV0dXJuIGRvbS5nZXRTdHlsZShlbG0gIT09IG51bGwgJiYgZWxtICE9PSB2b2lkIDAgPyBlbG0gOiBlZGl0b3IuZ2V0Qm9keSgpLCBuYW1lLCB0cnVlKTtcbiAgICAgIH07XG4gICAgICBpZiAoaXNTdHJpbmcoZm9ybWF0KSkge1xuICAgICAgICBjb25zdCBmb3JtYXRzID0gZWRpdG9yLmZvcm1hdHRlci5nZXQoZm9ybWF0KTtcbiAgICAgICAgaWYgKCFmb3JtYXRzKSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdHNbMF07XG4gICAgICB9XG4gICAgICBpZiAoJ3ByZXZpZXcnIGluIGZvcm1hdCkge1xuICAgICAgICBjb25zdCBwcmV2aWV3ID0gZm9ybWF0LnByZXZpZXc7XG4gICAgICAgIGlmIChwcmV2aWV3ID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aWV3U3R5bGVzID0gcHJldmlldyB8fCBwcmV2aWV3U3R5bGVzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgbmFtZSA9IGZvcm1hdC5ibG9jayB8fCBmb3JtYXQuaW5saW5lIHx8ICdzcGFuJztcbiAgICAgIGxldCBwcmV2aWV3RnJhZztcbiAgICAgIGNvbnN0IGl0ZW1zID0gcGFyc2VTZWxlY3Rvcihmb3JtYXQuc2VsZWN0b3IpO1xuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKCFpdGVtc1swXS5uYW1lKSB7XG4gICAgICAgICAgaXRlbXNbMF0ubmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgbmFtZSA9IGZvcm1hdC5zZWxlY3RvcjtcbiAgICAgICAgcHJldmlld0ZyYWcgPSBwYXJzZWRTZWxlY3RvclRvSHRtbChpdGVtcywgZWRpdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXZpZXdGcmFnID0gcGFyc2VkU2VsZWN0b3JUb0h0bWwoW25hbWVdLCBlZGl0b3IpO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJldmlld0VsbSA9IGRvbS5zZWxlY3QobmFtZSwgcHJldmlld0ZyYWcpWzBdIHx8IHByZXZpZXdGcmFnLmZpcnN0Q2hpbGQ7XG4gICAgICBlYWNoJDMoZm9ybWF0LnN0eWxlcywgKHZhbHVlLCBuYW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gcmVtb3ZlVmFycyh2YWx1ZSk7XG4gICAgICAgIGlmIChuZXdWYWx1ZSkge1xuICAgICAgICAgIGRvbS5zZXRTdHlsZShwcmV2aWV3RWxtLCBuYW1lLCBuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZWFjaCQzKGZvcm1hdC5hdHRyaWJ1dGVzLCAodmFsdWUsIG5hbWUpID0+IHtcbiAgICAgICAgY29uc3QgbmV3VmFsdWUgPSByZW1vdmVWYXJzKHZhbHVlKTtcbiAgICAgICAgaWYgKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgZG9tLnNldEF0dHJpYihwcmV2aWV3RWxtLCBuYW1lLCBuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZWFjaCQzKGZvcm1hdC5jbGFzc2VzLCB2YWx1ZSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gcmVtb3ZlVmFycyh2YWx1ZSk7XG4gICAgICAgIGlmICghZG9tLmhhc0NsYXNzKHByZXZpZXdFbG0sIG5ld1ZhbHVlKSkge1xuICAgICAgICAgIGRvbS5hZGRDbGFzcyhwcmV2aWV3RWxtLCBuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLmRpc3BhdGNoKCdQcmV2aWV3Rm9ybWF0cycpO1xuICAgICAgZG9tLnNldFN0eWxlcyhwcmV2aWV3RnJhZywge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgbGVmdDogLTY1NTM1XG4gICAgICB9KTtcbiAgICAgIGVkaXRvci5nZXRCb2R5KCkuYXBwZW5kQ2hpbGQocHJldmlld0ZyYWcpO1xuICAgICAgY29uc3QgcmF3UGFyZW50Rm9udFNpemUgPSBnZXRDb21wdXRlZFN0eWxlKCdmb250U2l6ZScpO1xuICAgICAgY29uc3QgcGFyZW50Rm9udFNpemUgPSAvcHgkLy50ZXN0KHJhd1BhcmVudEZvbnRTaXplKSA/IHBhcnNlSW50KHJhd1BhcmVudEZvbnRTaXplLCAxMCkgOiAwO1xuICAgICAgZWFjaCQzKHByZXZpZXdTdHlsZXMuc3BsaXQoJyAnKSwgbmFtZSA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGdldENvbXB1dGVkU3R5bGUobmFtZSwgcHJldmlld0VsbSk7XG4gICAgICAgIGlmIChuYW1lID09PSAnYmFja2dyb3VuZC1jb2xvcicgJiYgL3RyYW5zcGFyZW50fHJnYmFcXHMqXFwoW14pXSssXFxzKjBcXCkvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUgPSBnZXRDb21wdXRlZFN0eWxlKG5hbWUpO1xuICAgICAgICAgIGlmIChyZ2JhVG9IZXhTdHJpbmcodmFsdWUpLnRvTG93ZXJDYXNlKCkgPT09ICcjZmZmZmZmJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZSA9PT0gJ2NvbG9yJykge1xuICAgICAgICAgIGlmIChyZ2JhVG9IZXhTdHJpbmcodmFsdWUpLnRvTG93ZXJDYXNlKCkgPT09ICcjMDAwMDAwJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZSA9PT0gJ2ZvbnQtc2l6ZScpIHtcbiAgICAgICAgICBpZiAoL2VtfCUkLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKHBhcmVudEZvbnRTaXplID09PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG51bVZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSkgLyAoLyUkLy50ZXN0KHZhbHVlKSA/IDEwMCA6IDEpO1xuICAgICAgICAgICAgdmFsdWUgPSBudW1WYWx1ZSAqIHBhcmVudEZvbnRTaXplICsgJ3B4JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgPT09ICdib3JkZXInICYmIHZhbHVlKSB7XG4gICAgICAgICAgcHJldmlld0NzcyArPSAncGFkZGluZzowIDJweDsnO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpZXdDc3MgKz0gbmFtZSArICc6JyArIHZhbHVlICsgJzsnO1xuICAgICAgfSk7XG4gICAgICBlZGl0b3IuZGlzcGF0Y2goJ0FmdGVyUHJldmlld0Zvcm1hdHMnKTtcbiAgICAgIGRvbS5yZW1vdmUocHJldmlld0ZyYWcpO1xuICAgICAgcmV0dXJuIHByZXZpZXdDc3M7XG4gICAgfTtcblxuICAgIGNvbnN0IHNldHVwJHIgPSBlZGl0b3IgPT4ge1xuICAgICAgZWRpdG9yLmFkZFNob3J0Y3V0KCdtZXRhK2InLCAnJywgJ0JvbGQnKTtcbiAgICAgIGVkaXRvci5hZGRTaG9ydGN1dCgnbWV0YStpJywgJycsICdJdGFsaWMnKTtcbiAgICAgIGVkaXRvci5hZGRTaG9ydGN1dCgnbWV0YSt1JywgJycsICdVbmRlcmxpbmUnKTtcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IDY7IGkrKykge1xuICAgICAgICBlZGl0b3IuYWRkU2hvcnRjdXQoJ2FjY2VzcysnICsgaSwgJycsIFtcbiAgICAgICAgICAnRm9ybWF0QmxvY2snLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICdoJyArIGlcbiAgICAgICAgXSk7XG4gICAgICB9XG4gICAgICBlZGl0b3IuYWRkU2hvcnRjdXQoJ2FjY2Vzcys3JywgJycsIFtcbiAgICAgICAgJ0Zvcm1hdEJsb2NrJyxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgICdwJ1xuICAgICAgXSk7XG4gICAgICBlZGl0b3IuYWRkU2hvcnRjdXQoJ2FjY2Vzcys4JywgJycsIFtcbiAgICAgICAgJ0Zvcm1hdEJsb2NrJyxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgICdkaXYnXG4gICAgICBdKTtcbiAgICAgIGVkaXRvci5hZGRTaG9ydGN1dCgnYWNjZXNzKzknLCAnJywgW1xuICAgICAgICAnRm9ybWF0QmxvY2snLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgJ2FkZHJlc3MnXG4gICAgICBdKTtcbiAgICB9O1xuXG4gICAgY29uc3QgRm9ybWF0dGVyID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGZvcm1hdHMgPSBGb3JtYXRSZWdpc3RyeShlZGl0b3IpO1xuICAgICAgY29uc3QgZm9ybWF0Q2hhbmdlU3RhdGUgPSBDZWxsKHt9KTtcbiAgICAgIHNldHVwJHIoZWRpdG9yKTtcbiAgICAgIHNldHVwJHUoZWRpdG9yKTtcbiAgICAgIGlmICghaXNSdGMoZWRpdG9yKSkge1xuICAgICAgICBzZXR1cCR0KGZvcm1hdENoYW5nZVN0YXRlLCBlZGl0b3IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0OiBmb3JtYXRzLmdldCxcbiAgICAgICAgaGFzOiBmb3JtYXRzLmhhcyxcbiAgICAgICAgcmVnaXN0ZXI6IGZvcm1hdHMucmVnaXN0ZXIsXG4gICAgICAgIHVucmVnaXN0ZXI6IGZvcm1hdHMudW5yZWdpc3RlcixcbiAgICAgICAgYXBwbHk6IChuYW1lLCB2YXJzLCBub2RlKSA9PiB7XG4gICAgICAgICAgYXBwbHlGb3JtYXQoZWRpdG9yLCBuYW1lLCB2YXJzLCBub2RlKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlOiAobmFtZSwgdmFycywgbm9kZSwgc2ltaWxhcikgPT4ge1xuICAgICAgICAgIHJlbW92ZUZvcm1hdChlZGl0b3IsIG5hbWUsIHZhcnMsIG5vZGUsIHNpbWlsYXIpO1xuICAgICAgICB9LFxuICAgICAgICB0b2dnbGU6IChuYW1lLCB2YXJzLCBub2RlKSA9PiB7XG4gICAgICAgICAgdG9nZ2xlRm9ybWF0KGVkaXRvciwgbmFtZSwgdmFycywgbm9kZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG1hdGNoOiAobmFtZSwgdmFycywgbm9kZSwgc2ltaWxhcikgPT4gbWF0Y2hGb3JtYXQoZWRpdG9yLCBuYW1lLCB2YXJzLCBub2RlLCBzaW1pbGFyKSxcbiAgICAgICAgY2xvc2VzdDogbmFtZXMgPT4gY2xvc2VzdEZvcm1hdChlZGl0b3IsIG5hbWVzKSxcbiAgICAgICAgbWF0Y2hBbGw6IChuYW1lcywgdmFycykgPT4gbWF0Y2hBbGxGb3JtYXRzKGVkaXRvciwgbmFtZXMsIHZhcnMpLFxuICAgICAgICBtYXRjaE5vZGU6IChub2RlLCBuYW1lLCB2YXJzLCBzaW1pbGFyKSA9PiBtYXRjaE5vZGVGb3JtYXQoZWRpdG9yLCBub2RlLCBuYW1lLCB2YXJzLCBzaW1pbGFyKSxcbiAgICAgICAgY2FuQXBwbHk6IG5hbWUgPT4gY2FuQXBwbHlGb3JtYXQoZWRpdG9yLCBuYW1lKSxcbiAgICAgICAgZm9ybWF0Q2hhbmdlZDogKGZvcm1hdHMsIGNhbGxiYWNrLCBzaW1pbGFyLCB2YXJzKSA9PiBmb3JtYXRDaGFuZ2VkKGVkaXRvciwgZm9ybWF0Q2hhbmdlU3RhdGUsIGZvcm1hdHMsIGNhbGxiYWNrLCBzaW1pbGFyLCB2YXJzKSxcbiAgICAgICAgZ2V0Q3NzVGV4dDogY3VycnkoZ2V0Q3NzVGV4dCwgZWRpdG9yKVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3Qgc2hvdWxkSWdub3JlQ29tbWFuZCA9IGNtZCA9PiB7XG4gICAgICBzd2l0Y2ggKGNtZC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICBjYXNlICd1bmRvJzpcbiAgICAgIGNhc2UgJ3JlZG8nOlxuICAgICAgY2FzZSAnbWNlZm9jdXMnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlZ2lzdGVyRXZlbnRzID0gKGVkaXRvciwgdW5kb01hbmFnZXIsIGxvY2tzKSA9PiB7XG4gICAgICBjb25zdCBpc0ZpcnN0VHlwZWRDaGFyYWN0ZXIgPSBDZWxsKGZhbHNlKTtcbiAgICAgIGNvbnN0IGFkZE5vblR5cGluZ1VuZG9MZXZlbCA9IGUgPT4ge1xuICAgICAgICBzZXRUeXBpbmcodW5kb01hbmFnZXIsIGZhbHNlLCBsb2Nrcyk7XG4gICAgICAgIHVuZG9NYW5hZ2VyLmFkZCh7fSwgZSk7XG4gICAgICB9O1xuICAgICAgZWRpdG9yLm9uKCdpbml0JywgKCkgPT4ge1xuICAgICAgICB1bmRvTWFuYWdlci5hZGQoKTtcbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm9uKCdCZWZvcmVFeGVjQ29tbWFuZCcsIGUgPT4ge1xuICAgICAgICBjb25zdCBjbWQgPSBlLmNvbW1hbmQ7XG4gICAgICAgIGlmICghc2hvdWxkSWdub3JlQ29tbWFuZChjbWQpKSB7XG4gICAgICAgICAgZW5kVHlwaW5nKHVuZG9NYW5hZ2VyLCBsb2Nrcyk7XG4gICAgICAgICAgdW5kb01hbmFnZXIuYmVmb3JlQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm9uKCdFeGVjQ29tbWFuZCcsIGUgPT4ge1xuICAgICAgICBjb25zdCBjbWQgPSBlLmNvbW1hbmQ7XG4gICAgICAgIGlmICghc2hvdWxkSWdub3JlQ29tbWFuZChjbWQpKSB7XG4gICAgICAgICAgYWRkTm9uVHlwaW5nVW5kb0xldmVsKGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGVkaXRvci5vbignT2JqZWN0UmVzaXplU3RhcnQgY3V0JywgKCkgPT4ge1xuICAgICAgICB1bmRvTWFuYWdlci5iZWZvcmVDaGFuZ2UoKTtcbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm9uKCdTYXZlQ29udGVudCBPYmplY3RSZXNpemVkIGJsdXInLCBhZGROb25UeXBpbmdVbmRvTGV2ZWwpO1xuICAgICAgZWRpdG9yLm9uKCdkcmFnZW5kJywgYWRkTm9uVHlwaW5nVW5kb0xldmVsKTtcbiAgICAgIGVkaXRvci5vbigna2V5dXAnLCBlID0+IHtcbiAgICAgICAgY29uc3Qga2V5Q29kZSA9IGUua2V5Q29kZTtcbiAgICAgICAgaWYgKGUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleUNvZGUgPj0gMzMgJiYga2V5Q29kZSA8PSAzNiB8fCBrZXlDb2RlID49IDM3ICYmIGtleUNvZGUgPD0gNDAgfHwga2V5Q29kZSA9PT0gNDUgfHwgZS5jdHJsS2V5KSB7XG4gICAgICAgICAgYWRkTm9uVHlwaW5nVW5kb0xldmVsKCk7XG4gICAgICAgICAgZWRpdG9yLm5vZGVDaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleUNvZGUgPT09IDQ2IHx8IGtleUNvZGUgPT09IDgpIHtcbiAgICAgICAgICBlZGl0b3Iubm9kZUNoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNGaXJzdFR5cGVkQ2hhcmFjdGVyLmdldCgpICYmIHVuZG9NYW5hZ2VyLnR5cGluZyAmJiAhaXNFcSQxKGNyZWF0ZUZyb21FZGl0b3IoZWRpdG9yKSwgdW5kb01hbmFnZXIuZGF0YVswXSkpIHtcbiAgICAgICAgICBpZiAoIWVkaXRvci5pc0RpcnR5KCkpIHtcbiAgICAgICAgICAgIGVkaXRvci5zZXREaXJ0eSh0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWRpdG9yLmRpc3BhdGNoKCdUeXBpbmdVbmRvJyk7XG4gICAgICAgICAgaXNGaXJzdFR5cGVkQ2hhcmFjdGVyLnNldChmYWxzZSk7XG4gICAgICAgICAgZWRpdG9yLm5vZGVDaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm9uKCdrZXlkb3duJywgZSA9PiB7XG4gICAgICAgIGNvbnN0IGtleUNvZGUgPSBlLmtleUNvZGU7XG4gICAgICAgIGlmIChlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXlDb2RlID49IDMzICYmIGtleUNvZGUgPD0gMzYgfHwga2V5Q29kZSA+PSAzNyAmJiBrZXlDb2RlIDw9IDQwIHx8IGtleUNvZGUgPT09IDQ1KSB7XG4gICAgICAgICAgaWYgKHVuZG9NYW5hZ2VyLnR5cGluZykge1xuICAgICAgICAgICAgYWRkTm9uVHlwaW5nVW5kb0xldmVsKGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW9kS2V5ID0gZS5jdHJsS2V5ICYmICFlLmFsdEtleSB8fCBlLm1ldGFLZXk7XG4gICAgICAgIGlmICgoa2V5Q29kZSA8IDE2IHx8IGtleUNvZGUgPiAyMCkgJiYga2V5Q29kZSAhPT0gMjI0ICYmIGtleUNvZGUgIT09IDkxICYmICF1bmRvTWFuYWdlci50eXBpbmcgJiYgIW1vZEtleSkge1xuICAgICAgICAgIHVuZG9NYW5hZ2VyLmJlZm9yZUNoYW5nZSgpO1xuICAgICAgICAgIHNldFR5cGluZyh1bmRvTWFuYWdlciwgdHJ1ZSwgbG9ja3MpO1xuICAgICAgICAgIHVuZG9NYW5hZ2VyLmFkZCh7fSwgZSk7XG4gICAgICAgICAgaXNGaXJzdFR5cGVkQ2hhcmFjdGVyLnNldCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlZGl0b3Iub24oJ21vdXNlZG93bicsIGUgPT4ge1xuICAgICAgICBpZiAodW5kb01hbmFnZXIudHlwaW5nKSB7XG4gICAgICAgICAgYWRkTm9uVHlwaW5nVW5kb0xldmVsKGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGlzSW5zZXJ0UmVwbGFjZW1lbnRUZXh0ID0gZXZlbnQgPT4gZXZlbnQuaW5wdXRUeXBlID09PSAnaW5zZXJ0UmVwbGFjZW1lbnRUZXh0JztcbiAgICAgIGNvbnN0IGlzSW5zZXJ0VGV4dERhdGFOdWxsID0gZXZlbnQgPT4gZXZlbnQuaW5wdXRUeXBlID09PSAnaW5zZXJ0VGV4dCcgJiYgZXZlbnQuZGF0YSA9PT0gbnVsbDtcbiAgICAgIGNvbnN0IGlzSW5zZXJ0RnJvbVBhc3RlT3JEcm9wID0gZXZlbnQgPT4gZXZlbnQuaW5wdXRUeXBlID09PSAnaW5zZXJ0RnJvbVBhc3RlJyB8fCBldmVudC5pbnB1dFR5cGUgPT09ICdpbnNlcnRGcm9tRHJvcCc7XG4gICAgICBlZGl0b3Iub24oJ2lucHV0JywgZSA9PiB7XG4gICAgICAgIGlmIChlLmlucHV0VHlwZSAmJiAoaXNJbnNlcnRSZXBsYWNlbWVudFRleHQoZSkgfHwgaXNJbnNlcnRUZXh0RGF0YU51bGwoZSkgfHwgaXNJbnNlcnRGcm9tUGFzdGVPckRyb3AoZSkpKSB7XG4gICAgICAgICAgYWRkTm9uVHlwaW5nVW5kb0xldmVsKGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGVkaXRvci5vbignQWRkVW5kbyBVbmRvIFJlZG8gQ2xlYXJVbmRvcycsIGUgPT4ge1xuICAgICAgICBpZiAoIWUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICBlZGl0b3Iubm9kZUNoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBhZGRLZXlib2FyZFNob3J0Y3V0cyA9IGVkaXRvciA9PiB7XG4gICAgICBlZGl0b3IuYWRkU2hvcnRjdXQoJ21ldGEreicsICcnLCAnVW5kbycpO1xuICAgICAgZWRpdG9yLmFkZFNob3J0Y3V0KCdtZXRhK3ksbWV0YStzaGlmdCt6JywgJycsICdSZWRvJyk7XG4gICAgfTtcblxuICAgIGNvbnN0IFVuZG9NYW5hZ2VyID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGJlZm9yZUJvb2ttYXJrID0gdmFsdWUkMigpO1xuICAgICAgY29uc3QgbG9ja3MgPSBDZWxsKDApO1xuICAgICAgY29uc3QgaW5kZXggPSBDZWxsKDApO1xuICAgICAgY29uc3QgdW5kb01hbmFnZXIgPSB7XG4gICAgICAgIGRhdGE6IFtdLFxuICAgICAgICB0eXBpbmc6IGZhbHNlLFxuICAgICAgICBiZWZvcmVDaGFuZ2U6ICgpID0+IHtcbiAgICAgICAgICBiZWZvcmVDaGFuZ2UoZWRpdG9yLCBsb2NrcywgYmVmb3JlQm9va21hcmspO1xuICAgICAgICB9LFxuICAgICAgICBhZGQ6IChsZXZlbCwgZXZlbnQpID0+IHtcbiAgICAgICAgICByZXR1cm4gYWRkVW5kb0xldmVsKGVkaXRvciwgdW5kb01hbmFnZXIsIGluZGV4LCBsb2NrcywgYmVmb3JlQm9va21hcmssIGxldmVsLCBldmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRpc3BhdGNoQ2hhbmdlOiAoKSA9PiB7XG4gICAgICAgICAgZWRpdG9yLnNldERpcnR5KHRydWUpO1xuICAgICAgICAgIGNvbnN0IGxldmVsID0gY3JlYXRlRnJvbUVkaXRvcihlZGl0b3IpO1xuICAgICAgICAgIGxldmVsLmJvb2ttYXJrID0gZ2V0VW5kb0Jvb2ttYXJrKGVkaXRvci5zZWxlY3Rpb24pO1xuICAgICAgICAgIGVkaXRvci5kaXNwYXRjaCgnY2hhbmdlJywge1xuICAgICAgICAgICAgbGV2ZWwsXG4gICAgICAgICAgICBsYXN0TGV2ZWw6IGdldCRiKHVuZG9NYW5hZ2VyLmRhdGEsIGluZGV4LmdldCgpKS5nZXRPclVuZGVmaW5lZCgpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVuZG86ICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gdW5kbyhlZGl0b3IsIHVuZG9NYW5hZ2VyLCBsb2NrcywgaW5kZXgpO1xuICAgICAgICB9LFxuICAgICAgICByZWRvOiAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHJlZG8oZWRpdG9yLCBpbmRleCwgdW5kb01hbmFnZXIuZGF0YSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFyOiAoKSA9PiB7XG4gICAgICAgICAgY2xlYXIoZWRpdG9yLCB1bmRvTWFuYWdlciwgaW5kZXgpO1xuICAgICAgICB9LFxuICAgICAgICByZXNldDogKCkgPT4ge1xuICAgICAgICAgIHJlc2V0KGVkaXRvciwgdW5kb01hbmFnZXIpO1xuICAgICAgICB9LFxuICAgICAgICBoYXNVbmRvOiAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGhhc1VuZG8oZWRpdG9yLCB1bmRvTWFuYWdlciwgaW5kZXgpO1xuICAgICAgICB9LFxuICAgICAgICBoYXNSZWRvOiAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGhhc1JlZG8oZWRpdG9yLCB1bmRvTWFuYWdlciwgaW5kZXgpO1xuICAgICAgICB9LFxuICAgICAgICB0cmFuc2FjdDogY2FsbGJhY2sgPT4ge1xuICAgICAgICAgIHJldHVybiB0cmFuc2FjdChlZGl0b3IsIHVuZG9NYW5hZ2VyLCBsb2NrcywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuICAgICAgICBpZ25vcmU6IGNhbGxiYWNrID0+IHtcbiAgICAgICAgICBpZ25vcmUoZWRpdG9yLCBsb2NrcywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuICAgICAgICBleHRyYTogKGNhbGxiYWNrMSwgY2FsbGJhY2syKSA9PiB7XG4gICAgICAgICAgZXh0cmEoZWRpdG9yLCB1bmRvTWFuYWdlciwgaW5kZXgsIGNhbGxiYWNrMSwgY2FsbGJhY2syKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmICghaXNSdGMoZWRpdG9yKSkge1xuICAgICAgICByZWdpc3RlckV2ZW50cyhlZGl0b3IsIHVuZG9NYW5hZ2VyLCBsb2Nrcyk7XG4gICAgICB9XG4gICAgICBhZGRLZXlib2FyZFNob3J0Y3V0cyhlZGl0b3IpO1xuICAgICAgcmV0dXJuIHVuZG9NYW5hZ2VyO1xuICAgIH07XG5cbiAgICBjb25zdCBub25UeXBpbmdLZXljb2RlcyA9IFtcbiAgICAgIDksXG4gICAgICAyNyxcbiAgICAgIFZLLkhPTUUsXG4gICAgICBWSy5FTkQsXG4gICAgICAxOSxcbiAgICAgIDIwLFxuICAgICAgNDQsXG4gICAgICAxNDQsXG4gICAgICAxNDUsXG4gICAgICAzMyxcbiAgICAgIDM0LFxuICAgICAgNDUsXG4gICAgICAxNixcbiAgICAgIDE3LFxuICAgICAgMTgsXG4gICAgICA5MSxcbiAgICAgIDkyLFxuICAgICAgOTMsXG4gICAgICBWSy5ET1dOLFxuICAgICAgVksuVVAsXG4gICAgICBWSy5MRUZULFxuICAgICAgVksuUklHSFRcbiAgICBdLmNvbmNhdChFbnYuYnJvd3Nlci5pc0ZpcmVmb3goKSA/IFsyMjRdIDogW10pO1xuICAgIGNvbnN0IHBsYWNlaG9sZGVyQXR0ciA9ICdkYXRhLW1jZS1wbGFjZWhvbGRlcic7XG4gICAgY29uc3QgaXNLZXlib2FyZEV2ZW50ID0gZSA9PiBlLnR5cGUgPT09ICdrZXlkb3duJyB8fCBlLnR5cGUgPT09ICdrZXl1cCc7XG4gICAgY29uc3QgaXNEZWxldGVFdmVudCA9IGUgPT4ge1xuICAgICAgY29uc3Qga2V5Q29kZSA9IGUua2V5Q29kZTtcbiAgICAgIHJldHVybiBrZXlDb2RlID09PSBWSy5CQUNLU1BBQ0UgfHwga2V5Q29kZSA9PT0gVksuREVMRVRFO1xuICAgIH07XG4gICAgY29uc3QgaXNOb25UeXBpbmdLZXlib2FyZEV2ZW50ID0gZSA9PiB7XG4gICAgICBpZiAoaXNLZXlib2FyZEV2ZW50KGUpKSB7XG4gICAgICAgIGNvbnN0IGtleUNvZGUgPSBlLmtleUNvZGU7XG4gICAgICAgIHJldHVybiAhaXNEZWxldGVFdmVudChlKSAmJiAoVksubWV0YUtleVByZXNzZWQoZSkgfHwgZS5hbHRLZXkgfHwga2V5Q29kZSA+PSAxMTIgJiYga2V5Q29kZSA8PSAxMjMgfHwgY29udGFpbnMkMihub25UeXBpbmdLZXljb2Rlcywga2V5Q29kZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaXNUeXBpbmdLZXlib2FyZEV2ZW50ID0gZSA9PiBpc0tleWJvYXJkRXZlbnQoZSkgJiYgIShpc0RlbGV0ZUV2ZW50KGUpIHx8IGUudHlwZSA9PT0gJ2tleXVwJyAmJiBlLmtleUNvZGUgPT09IDIyOSk7XG4gICAgY29uc3QgaXNWaXN1YWxseUVtcHR5ID0gKGRvbSwgcm9vdEVsbSwgZm9yY2VkUm9vdEJsb2NrKSA9PiB7XG4gICAgICBpZiAoaXNFbXB0eSQyKFN1Z2FyRWxlbWVudC5mcm9tRG9tKHJvb3RFbG0pLCBmYWxzZSkpIHtcbiAgICAgICAgY29uc3QgZmlyc3RFbGVtZW50ID0gcm9vdEVsbS5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICAgICAgaWYgKCFmaXJzdEVsZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChkb20uZ2V0U3R5bGUocm9vdEVsbS5maXJzdEVsZW1lbnRDaGlsZCwgJ3BhZGRpbmctbGVmdCcpIHx8IGRvbS5nZXRTdHlsZShyb290RWxtLmZpcnN0RWxlbWVudENoaWxkLCAncGFkZGluZy1yaWdodCcpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmb3JjZWRSb290QmxvY2sgPT09IGZpcnN0RWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzZXR1cCRxID0gZWRpdG9yID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb207XG4gICAgICBjb25zdCByb290QmxvY2sgPSBnZXRGb3JjZWRSb290QmxvY2soZWRpdG9yKTtcbiAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gKF9hID0gZ2V0UGxhY2Vob2xkZXIoZWRpdG9yKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJyc7XG4gICAgICBjb25zdCB1cGRhdGVQbGFjZWhvbGRlciA9IChlLCBpbml0aWFsKSA9PiB7XG4gICAgICAgIGlmIChpc05vblR5cGluZ0tleWJvYXJkRXZlbnQoZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm9keSA9IGVkaXRvci5nZXRCb2R5KCk7XG4gICAgICAgIGNvbnN0IHNob3dQbGFjZWhvbGRlciA9IGlzVHlwaW5nS2V5Ym9hcmRFdmVudChlKSA/IGZhbHNlIDogaXNWaXN1YWxseUVtcHR5KGRvbSwgYm9keSwgcm9vdEJsb2NrKTtcbiAgICAgICAgY29uc3QgaXNQbGFjZWhvbGRlclNob3duID0gZG9tLmdldEF0dHJpYihib2R5LCBwbGFjZWhvbGRlckF0dHIpICE9PSAnJztcbiAgICAgICAgaWYgKGlzUGxhY2Vob2xkZXJTaG93biAhPT0gc2hvd1BsYWNlaG9sZGVyIHx8IGluaXRpYWwpIHtcbiAgICAgICAgICBkb20uc2V0QXR0cmliKGJvZHksIHBsYWNlaG9sZGVyQXR0ciwgc2hvd1BsYWNlaG9sZGVyID8gcGxhY2Vob2xkZXIgOiBudWxsKTtcbiAgICAgICAgICBkb20uc2V0QXR0cmliKGJvZHksICdhcmlhLXBsYWNlaG9sZGVyJywgc2hvd1BsYWNlaG9sZGVyID8gcGxhY2Vob2xkZXIgOiBudWxsKTtcbiAgICAgICAgICBmaXJlUGxhY2Vob2xkZXJUb2dnbGUoZWRpdG9yLCBzaG93UGxhY2Vob2xkZXIpO1xuICAgICAgICAgIGVkaXRvci5vbihzaG93UGxhY2Vob2xkZXIgPyAna2V5ZG93bicgOiAna2V5dXAnLCB1cGRhdGVQbGFjZWhvbGRlcik7XG4gICAgICAgICAgZWRpdG9yLm9mZihzaG93UGxhY2Vob2xkZXIgPyAna2V5dXAnIDogJ2tleWRvd24nLCB1cGRhdGVQbGFjZWhvbGRlcik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoaXNOb3RFbXB0eShwbGFjZWhvbGRlcikpIHtcbiAgICAgICAgZWRpdG9yLm9uKCdpbml0JywgZSA9PiB7XG4gICAgICAgICAgdXBkYXRlUGxhY2Vob2xkZXIoZSwgdHJ1ZSk7XG4gICAgICAgICAgZWRpdG9yLm9uKCdjaGFuZ2UgU2V0Q29udGVudCBFeGVjQ29tbWFuZCcsIHVwZGF0ZVBsYWNlaG9sZGVyKTtcbiAgICAgICAgICBlZGl0b3Iub24oJ3Bhc3RlJywgZSA9PiBEZWxheS5zZXRFZGl0b3JUaW1lb3V0KGVkaXRvciwgKCkgPT4gdXBkYXRlUGxhY2Vob2xkZXIoZSkpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGJsb2NrUG9zaXRpb24gPSAoYmxvY2ssIHBvc2l0aW9uKSA9PiAoe1xuICAgICAgYmxvY2ssXG4gICAgICBwb3NpdGlvblxuICAgIH0pO1xuICAgIGNvbnN0IGJsb2NrQm91bmRhcnkgPSAoZnJvbSwgdG8pID0+ICh7XG4gICAgICBmcm9tLFxuICAgICAgdG9cbiAgICB9KTtcbiAgICBjb25zdCBnZXRCbG9ja1Bvc2l0aW9uID0gKHJvb3ROb2RlLCBwb3MpID0+IHtcbiAgICAgIGNvbnN0IHJvb3RFbG0gPSBTdWdhckVsZW1lbnQuZnJvbURvbShyb290Tm9kZSk7XG4gICAgICBjb25zdCBjb250YWluZXJFbG0gPSBTdWdhckVsZW1lbnQuZnJvbURvbShwb3MuY29udGFpbmVyKCkpO1xuICAgICAgcmV0dXJuIGdldFBhcmVudEJsb2NrJDIocm9vdEVsbSwgY29udGFpbmVyRWxtKS5tYXAoYmxvY2sgPT4gYmxvY2tQb3NpdGlvbihibG9jaywgcG9zKSk7XG4gICAgfTtcbiAgICBjb25zdCBpc0RpZmZlcmVudEJsb2NrcyA9IGJsb2NrQm91bmRhcnkgPT4gIWVxKGJsb2NrQm91bmRhcnkuZnJvbS5ibG9jaywgYmxvY2tCb3VuZGFyeS50by5ibG9jayk7XG4gICAgY29uc3QgZ2V0Q2xvc2VzdEhvc3QgPSAocm9vdCwgc2NvcGUpID0+IHtcbiAgICAgIGNvbnN0IGlzUm9vdCA9IG5vZGUgPT4gZXEobm9kZSwgcm9vdCk7XG4gICAgICBjb25zdCBpc0hvc3QgPSBub2RlID0+IGlzVGFibGVDZWxsJDIobm9kZSkgfHwgaXNDb250ZW50RWRpdGFibGVUcnVlJDMobm9kZS5kb20pO1xuICAgICAgcmV0dXJuIGNsb3Nlc3QkNChzY29wZSwgaXNIb3N0LCBpc1Jvb3QpLmZpbHRlcihpc0VsZW1lbnQkNykuZ2V0T3Iocm9vdCk7XG4gICAgfTtcbiAgICBjb25zdCBoYXNTYW1lSG9zdCA9IChyb290Tm9kZSwgYmxvY2tCb3VuZGFyeSkgPT4ge1xuICAgICAgY29uc3Qgcm9vdCA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKHJvb3ROb2RlKTtcbiAgICAgIHJldHVybiBlcShnZXRDbG9zZXN0SG9zdChyb290LCBibG9ja0JvdW5kYXJ5LmZyb20uYmxvY2spLCBnZXRDbG9zZXN0SG9zdChyb290LCBibG9ja0JvdW5kYXJ5LnRvLmJsb2NrKSk7XG4gICAgfTtcbiAgICBjb25zdCBpc0VkaXRhYmxlJDEgPSBibG9ja0JvdW5kYXJ5ID0+IGlzQ29udGVudEVkaXRhYmxlRmFsc2UkYihibG9ja0JvdW5kYXJ5LmZyb20uYmxvY2suZG9tKSA9PT0gZmFsc2UgJiYgaXNDb250ZW50RWRpdGFibGVGYWxzZSRiKGJsb2NrQm91bmRhcnkudG8uYmxvY2suZG9tKSA9PT0gZmFsc2U7XG4gICAgY29uc3QgaGFzVmFsaWRCbG9ja3MgPSBibG9ja0JvdW5kYXJ5ID0+IHtcbiAgICAgIGNvbnN0IGlzVmFsaWRCbG9jayA9IGJsb2NrID0+IGlzVGV4dEJsb2NrJDIoYmxvY2spIHx8IGhhc0Jsb2NrQXR0cihibG9jay5kb20pO1xuICAgICAgcmV0dXJuIGlzVmFsaWRCbG9jayhibG9ja0JvdW5kYXJ5LmZyb20uYmxvY2spICYmIGlzVmFsaWRCbG9jayhibG9ja0JvdW5kYXJ5LnRvLmJsb2NrKTtcbiAgICB9O1xuICAgIGNvbnN0IHNraXBMYXN0QnIgPSAocm9vdE5vZGUsIGZvcndhcmQsIGJsb2NrUG9zaXRpb24pID0+IHtcbiAgICAgIGlmIChpc0JyJDYoYmxvY2tQb3NpdGlvbi5wb3NpdGlvbi5nZXROb2RlKCkpICYmICFpc0VtcHR5JDIoYmxvY2tQb3NpdGlvbi5ibG9jaykpIHtcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uSW4oZmFsc2UsIGJsb2NrUG9zaXRpb24uYmxvY2suZG9tKS5iaW5kKGxhc3RQb3NpdGlvbkluQmxvY2sgPT4ge1xuICAgICAgICAgIGlmIChsYXN0UG9zaXRpb25JbkJsb2NrLmlzRXF1YWwoYmxvY2tQb3NpdGlvbi5wb3NpdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tUG9zaXRpb24oZm9yd2FyZCwgcm9vdE5vZGUsIGxhc3RQb3NpdGlvbkluQmxvY2spLmJpbmQodG8gPT4gZ2V0QmxvY2tQb3NpdGlvbihyb290Tm9kZSwgdG8pKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoYmxvY2tQb3NpdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9KS5nZXRPcihibG9ja1Bvc2l0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBibG9ja1Bvc2l0aW9uO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmVhZEZyb21SYW5nZSA9IChyb290Tm9kZSwgZm9yd2FyZCwgcm5nKSA9PiB7XG4gICAgICBjb25zdCBmcm9tQmxvY2tQb3MgPSBnZXRCbG9ja1Bvc2l0aW9uKHJvb3ROb2RlLCBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KHJuZykpO1xuICAgICAgY29uc3QgdG9CbG9ja1BvcyA9IGZyb21CbG9ja1Bvcy5iaW5kKGJsb2NrUG9zID0+IGZyb21Qb3NpdGlvbihmb3J3YXJkLCByb290Tm9kZSwgYmxvY2tQb3MucG9zaXRpb24pLmJpbmQodG8gPT4gZ2V0QmxvY2tQb3NpdGlvbihyb290Tm9kZSwgdG8pLm1hcChibG9ja1BvcyA9PiBza2lwTGFzdEJyKHJvb3ROb2RlLCBmb3J3YXJkLCBibG9ja1BvcykpKSk7XG4gICAgICByZXR1cm4gbGlmdDIoZnJvbUJsb2NrUG9zLCB0b0Jsb2NrUG9zLCBibG9ja0JvdW5kYXJ5KS5maWx0ZXIoYmxvY2tCb3VuZGFyeSA9PiBpc0RpZmZlcmVudEJsb2NrcyhibG9ja0JvdW5kYXJ5KSAmJiBoYXNTYW1lSG9zdChyb290Tm9kZSwgYmxvY2tCb3VuZGFyeSkgJiYgaXNFZGl0YWJsZSQxKGJsb2NrQm91bmRhcnkpICYmIGhhc1ZhbGlkQmxvY2tzKGJsb2NrQm91bmRhcnkpKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlYWQkMSA9IChyb290Tm9kZSwgZm9yd2FyZCwgcm5nKSA9PiBybmcuY29sbGFwc2VkID8gcmVhZEZyb21SYW5nZShyb290Tm9kZSwgZm9yd2FyZCwgcm5nKSA6IE9wdGlvbmFsLm5vbmUoKTtcblxuICAgIGNvbnN0IGdldENoaWxkcmVuVW50aWxCbG9ja0JvdW5kYXJ5ID0gYmxvY2sgPT4ge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBjaGlsZHJlbiQxKGJsb2NrKTtcbiAgICAgIHJldHVybiBmaW5kSW5kZXgkMihjaGlsZHJlbiwgaXNCbG9jayQyKS5mb2xkKGNvbnN0YW50KGNoaWxkcmVuKSwgaW5kZXggPT4gY2hpbGRyZW4uc2xpY2UoMCwgaW5kZXgpKTtcbiAgICB9O1xuICAgIGNvbnN0IGV4dHJhY3RDaGlsZHJlbiA9IGJsb2NrID0+IHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gZ2V0Q2hpbGRyZW5VbnRpbEJsb2NrQm91bmRhcnkoYmxvY2spO1xuICAgICAgZWFjaCRlKGNoaWxkcmVuLCByZW1vdmUkNik7XG4gICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVFbXB0eVJvb3QgPSAocm9vdE5vZGUsIGJsb2NrKSA9PiB7XG4gICAgICBjb25zdCBwYXJlbnRzID0gcGFyZW50c0FuZFNlbGYoYmxvY2ssIHJvb3ROb2RlKTtcbiAgICAgIHJldHVybiBmaW5kJDIocGFyZW50cy5yZXZlcnNlKCksIGVsZW1lbnQgPT4gaXNFbXB0eSQyKGVsZW1lbnQpKS5lYWNoKHJlbW92ZSQ2KTtcbiAgICB9O1xuICAgIGNvbnN0IGlzRW1wdHlCZWZvcmUgPSBlbCA9PiBmaWx0ZXIkNShwcmV2U2libGluZ3MoZWwpLCBlbCA9PiAhaXNFbXB0eSQyKGVsKSkubGVuZ3RoID09PSAwO1xuICAgIGNvbnN0IG5lc3RlZEJsb2NrTWVyZ2UgPSAocm9vdE5vZGUsIGZyb21CbG9jaywgdG9CbG9jaywgaW5zZXJ0aW9uUG9pbnQpID0+IHtcbiAgICAgIGlmIChpc0VtcHR5JDIodG9CbG9jaykpIHtcbiAgICAgICAgZmlsbFdpdGhQYWRkaW5nQnIodG9CbG9jayk7XG4gICAgICAgIHJldHVybiBmaXJzdFBvc2l0aW9uSW4odG9CbG9jay5kb20pO1xuICAgICAgfVxuICAgICAgaWYgKGlzRW1wdHlCZWZvcmUoaW5zZXJ0aW9uUG9pbnQpICYmIGlzRW1wdHkkMihmcm9tQmxvY2spKSB7XG4gICAgICAgIGJlZm9yZSQzKGluc2VydGlvblBvaW50LCBTdWdhckVsZW1lbnQuZnJvbVRhZygnYnInKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHByZXZQb3NpdGlvbih0b0Jsb2NrLmRvbSwgQ2FyZXRQb3NpdGlvbi5iZWZvcmUoaW5zZXJ0aW9uUG9pbnQuZG9tKSk7XG4gICAgICBlYWNoJGUoZXh0cmFjdENoaWxkcmVuKGZyb21CbG9jayksIGNoaWxkID0+IHtcbiAgICAgICAgYmVmb3JlJDMoaW5zZXJ0aW9uUG9pbnQsIGNoaWxkKTtcbiAgICAgIH0pO1xuICAgICAgcmVtb3ZlRW1wdHlSb290KHJvb3ROb2RlLCBmcm9tQmxvY2spO1xuICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgIH07XG4gICAgY29uc3Qgc2lkZWxvbmdCbG9ja01lcmdlID0gKHJvb3ROb2RlLCBmcm9tQmxvY2ssIHRvQmxvY2spID0+IHtcbiAgICAgIGlmIChpc0VtcHR5JDIodG9CbG9jaykpIHtcbiAgICAgICAgaWYgKGlzRW1wdHkkMihmcm9tQmxvY2spKSB7XG4gICAgICAgICAgY29uc3QgZ2V0SW5saW5lVG9CbG9ja0Rlc2NlbmRhbnRzID0gZWwgPT4ge1xuICAgICAgICAgICAgY29uc3QgaGVscGVyID0gKG5vZGUsIGVsZW1lbnRzKSA9PiBmaXJzdENoaWxkKG5vZGUpLmZvbGQoKCkgPT4gZWxlbWVudHMsIGNoaWxkID0+IGlzSW5saW5lJDEoY2hpbGQpID8gaGVscGVyKGNoaWxkLCBlbGVtZW50cy5jb25jYXQoc2hhbGxvdyQxKGNoaWxkKSkpIDogZWxlbWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIGhlbHBlcihlbCwgW10pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgbmV3RnJvbUJsb2NrRGVzY2VuZGFudHMgPSBmb2xkcihnZXRJbmxpbmVUb0Jsb2NrRGVzY2VuZGFudHModG9CbG9jayksIChlbGVtZW50LCBkZXNjZW5kYW50KSA9PiB7XG4gICAgICAgICAgICB3cmFwJDIoZWxlbWVudCwgZGVzY2VuZGFudCk7XG4gICAgICAgICAgICByZXR1cm4gZGVzY2VuZGFudDtcbiAgICAgICAgICB9LCBjcmVhdGVQYWRkaW5nQnIoKSk7XG4gICAgICAgICAgZW1wdHkoZnJvbUJsb2NrKTtcbiAgICAgICAgICBhcHBlbmQkMShmcm9tQmxvY2ssIG5ld0Zyb21CbG9ja0Rlc2NlbmRhbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZW1vdmUkNih0b0Jsb2NrKTtcbiAgICAgICAgcmV0dXJuIGZpcnN0UG9zaXRpb25Jbihmcm9tQmxvY2suZG9tKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gbGFzdFBvc2l0aW9uSW4odG9CbG9jay5kb20pO1xuICAgICAgZWFjaCRlKGV4dHJhY3RDaGlsZHJlbihmcm9tQmxvY2spLCBjaGlsZCA9PiB7XG4gICAgICAgIGFwcGVuZCQxKHRvQmxvY2ssIGNoaWxkKTtcbiAgICAgIH0pO1xuICAgICAgcmVtb3ZlRW1wdHlSb290KHJvb3ROb2RlLCBmcm9tQmxvY2spO1xuICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgIH07XG4gICAgY29uc3QgZmluZEluc2VydGlvblBvaW50ID0gKHRvQmxvY2ssIGJsb2NrKSA9PiB7XG4gICAgICBjb25zdCBwYXJlbnRzQW5kU2VsZiQxID0gcGFyZW50c0FuZFNlbGYoYmxvY2ssIHRvQmxvY2spO1xuICAgICAgcmV0dXJuIE9wdGlvbmFsLmZyb20ocGFyZW50c0FuZFNlbGYkMVtwYXJlbnRzQW5kU2VsZiQxLmxlbmd0aCAtIDFdKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldEluc2VydGlvblBvaW50ID0gKGZyb21CbG9jaywgdG9CbG9jaykgPT4gY29udGFpbnModG9CbG9jaywgZnJvbUJsb2NrKSA/IGZpbmRJbnNlcnRpb25Qb2ludCh0b0Jsb2NrLCBmcm9tQmxvY2spIDogT3B0aW9uYWwubm9uZSgpO1xuICAgIGNvbnN0IHRyaW1CciA9IChmaXJzdCwgYmxvY2spID0+IHtcbiAgICAgIHBvc2l0aW9uSW4oZmlyc3QsIGJsb2NrLmRvbSkuYmluZChwb3NpdGlvbiA9PiBPcHRpb25hbC5mcm9tKHBvc2l0aW9uLmdldE5vZGUoKSkpLm1hcChTdWdhckVsZW1lbnQuZnJvbURvbSkuZmlsdGVyKGlzQnIkNSkuZWFjaChyZW1vdmUkNik7XG4gICAgfTtcbiAgICBjb25zdCBtZXJnZUJsb2NrSW50byA9IChyb290Tm9kZSwgZnJvbUJsb2NrLCB0b0Jsb2NrKSA9PiB7XG4gICAgICB0cmltQnIodHJ1ZSwgZnJvbUJsb2NrKTtcbiAgICAgIHRyaW1CcihmYWxzZSwgdG9CbG9jayk7XG4gICAgICByZXR1cm4gZ2V0SW5zZXJ0aW9uUG9pbnQoZnJvbUJsb2NrLCB0b0Jsb2NrKS5mb2xkKGN1cnJ5KHNpZGVsb25nQmxvY2tNZXJnZSwgcm9vdE5vZGUsIGZyb21CbG9jaywgdG9CbG9jayksIGN1cnJ5KG5lc3RlZEJsb2NrTWVyZ2UsIHJvb3ROb2RlLCBmcm9tQmxvY2ssIHRvQmxvY2spKTtcbiAgICB9O1xuICAgIGNvbnN0IG1lcmdlQmxvY2tzID0gKHJvb3ROb2RlLCBmb3J3YXJkLCBibG9jazEsIGJsb2NrMikgPT4gZm9yd2FyZCA/IG1lcmdlQmxvY2tJbnRvKHJvb3ROb2RlLCBibG9jazIsIGJsb2NrMSkgOiBtZXJnZUJsb2NrSW50byhyb290Tm9kZSwgYmxvY2sxLCBibG9jazIpO1xuXG4gICAgY29uc3QgYmFja3NwYWNlRGVsZXRlJDggPSAoZWRpdG9yLCBmb3J3YXJkKSA9PiB7XG4gICAgICBjb25zdCByb290Tm9kZSA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRCb2R5KCkpO1xuICAgICAgY29uc3QgcG9zaXRpb24gPSByZWFkJDEocm9vdE5vZGUuZG9tLCBmb3J3YXJkLCBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpKS5tYXAoYmxvY2tCb3VuZGFyeSA9PiAoKSA9PiB7XG4gICAgICAgIG1lcmdlQmxvY2tzKHJvb3ROb2RlLCBmb3J3YXJkLCBibG9ja0JvdW5kYXJ5LmZyb20uYmxvY2ssIGJsb2NrQm91bmRhcnkudG8uYmxvY2spLmVhY2gocG9zID0+IHtcbiAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFJuZyhwb3MudG9SYW5nZSgpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICB9O1xuXG4gICAgY29uc3QgZGVsZXRlUmFuZ2VNZXJnZUJsb2NrcyA9IChyb290Tm9kZSwgc2VsZWN0aW9uKSA9PiB7XG4gICAgICBjb25zdCBybmcgPSBzZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICByZXR1cm4gbGlmdDIoZ2V0UGFyZW50QmxvY2skMihyb290Tm9kZSwgU3VnYXJFbGVtZW50LmZyb21Eb20ocm5nLnN0YXJ0Q29udGFpbmVyKSksIGdldFBhcmVudEJsb2NrJDIocm9vdE5vZGUsIFN1Z2FyRWxlbWVudC5mcm9tRG9tKHJuZy5lbmRDb250YWluZXIpKSwgKGJsb2NrMSwgYmxvY2syKSA9PiB7XG4gICAgICAgIGlmICghZXEoYmxvY2sxLCBibG9jazIpKSB7XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoKCkgPT4ge1xuICAgICAgICAgICAgcm5nLmRlbGV0ZUNvbnRlbnRzKCk7XG4gICAgICAgICAgICBtZXJnZUJsb2Nrcyhyb290Tm9kZSwgdHJ1ZSwgYmxvY2sxLCBibG9jazIpLmVhY2gocG9zID0+IHtcbiAgICAgICAgICAgICAgc2VsZWN0aW9uLnNldFJuZyhwb3MudG9SYW5nZSgpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICAgIH1cbiAgICAgIH0pLmdldE9yKE9wdGlvbmFsLm5vbmUoKSk7XG4gICAgfTtcbiAgICBjb25zdCBpc1Jhd05vZGVJblRhYmxlID0gKHJvb3QsIHJhd05vZGUpID0+IHtcbiAgICAgIGNvbnN0IG5vZGUgPSBTdWdhckVsZW1lbnQuZnJvbURvbShyYXdOb2RlKTtcbiAgICAgIGNvbnN0IGlzUm9vdCA9IGN1cnJ5KGVxLCByb290KTtcbiAgICAgIHJldHVybiBhbmNlc3RvciQ0KG5vZGUsIGlzVGFibGVDZWxsJDIsIGlzUm9vdCkuaXNTb21lKCk7XG4gICAgfTtcbiAgICBjb25zdCBpc1NlbGVjdGlvbkluVGFibGUgPSAocm9vdCwgcm5nKSA9PiBpc1Jhd05vZGVJblRhYmxlKHJvb3QsIHJuZy5zdGFydENvbnRhaW5lcikgfHwgaXNSYXdOb2RlSW5UYWJsZShyb290LCBybmcuZW5kQ29udGFpbmVyKTtcbiAgICBjb25zdCBpc0V2ZXJ5dGhpbmdTZWxlY3RlZCA9IChyb290LCBybmcpID0+IHtcbiAgICAgIGNvbnN0IG5vUHJldmlvdXMgPSBwcmV2UG9zaXRpb24ocm9vdC5kb20sIENhcmV0UG9zaXRpb24uZnJvbVJhbmdlU3RhcnQocm5nKSkuaXNOb25lKCk7XG4gICAgICBjb25zdCBub05leHQgPSBuZXh0UG9zaXRpb24ocm9vdC5kb20sIENhcmV0UG9zaXRpb24uZnJvbVJhbmdlRW5kKHJuZykpLmlzTm9uZSgpO1xuICAgICAgcmV0dXJuICFpc1NlbGVjdGlvbkluVGFibGUocm9vdCwgcm5nKSAmJiBub1ByZXZpb3VzICYmIG5vTmV4dDtcbiAgICB9O1xuICAgIGNvbnN0IGVtcHR5RWRpdG9yID0gZWRpdG9yID0+IHtcbiAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKCgpID0+IHtcbiAgICAgICAgZWRpdG9yLnNldENvbnRlbnQoJycpO1xuICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldEN1cnNvckxvY2F0aW9uKCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGRlbGV0ZVJhbmdlJDIgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3Qgcm9vdE5vZGUgPSBTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3IuZ2V0Qm9keSgpKTtcbiAgICAgIGNvbnN0IHJuZyA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICByZXR1cm4gaXNFdmVyeXRoaW5nU2VsZWN0ZWQocm9vdE5vZGUsIHJuZykgPyBlbXB0eUVkaXRvcihlZGl0b3IpIDogZGVsZXRlUmFuZ2VNZXJnZUJsb2Nrcyhyb290Tm9kZSwgZWRpdG9yLnNlbGVjdGlvbik7XG4gICAgfTtcbiAgICBjb25zdCBiYWNrc3BhY2VEZWxldGUkNyA9IChlZGl0b3IsIF9mb3J3YXJkKSA9PiBlZGl0b3Iuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgPyBPcHRpb25hbC5ub25lKCkgOiBkZWxldGVSYW5nZSQyKGVkaXRvcik7XG5cbiAgICBjb25zdCBzaG93Q2FyZXQgPSAoZGlyZWN0aW9uLCBlZGl0b3IsIG5vZGUsIGJlZm9yZSwgc2Nyb2xsSW50b1ZpZXcpID0+IE9wdGlvbmFsLmZyb20oZWRpdG9yLl9zZWxlY3Rpb25PdmVycmlkZXMuc2hvd0NhcmV0KGRpcmVjdGlvbiwgbm9kZSwgYmVmb3JlLCBzY3JvbGxJbnRvVmlldykpO1xuICAgIGNvbnN0IGdldE5vZGVSYW5nZSA9IG5vZGUgPT4ge1xuICAgICAgY29uc3Qgcm5nID0gbm9kZS5vd25lckRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICBybmcuc2VsZWN0Tm9kZShub2RlKTtcbiAgICAgIHJldHVybiBybmc7XG4gICAgfTtcbiAgICBjb25zdCBzZWxlY3ROb2RlID0gKGVkaXRvciwgbm9kZSkgPT4ge1xuICAgICAgY29uc3QgZSA9IGVkaXRvci5kaXNwYXRjaCgnQmVmb3JlT2JqZWN0U2VsZWN0ZWQnLCB7IHRhcmdldDogbm9kZSB9KTtcbiAgICAgIGlmIChlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShnZXROb2RlUmFuZ2Uobm9kZSkpO1xuICAgIH07XG4gICAgY29uc3QgcmVuZGVyQ2FyZXRBdFJhbmdlID0gKGVkaXRvciwgcmFuZ2UsIHNjcm9sbEludG9WaWV3KSA9PiB7XG4gICAgICBjb25zdCBub3JtYWxpemVkUmFuZ2UgPSBub3JtYWxpemVSYW5nZSgxLCBlZGl0b3IuZ2V0Qm9keSgpLCByYW5nZSk7XG4gICAgICBjb25zdCBjYXJldFBvc2l0aW9uID0gQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChub3JtYWxpemVkUmFuZ2UpO1xuICAgICAgY29uc3QgY2FyZXRQb3NpdGlvbk5vZGUgPSBjYXJldFBvc2l0aW9uLmdldE5vZGUoKTtcbiAgICAgIGlmIChpc0lubGluZUZha2VDYXJldFRhcmdldChjYXJldFBvc2l0aW9uTm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIHNob3dDYXJldCgxLCBlZGl0b3IsIGNhcmV0UG9zaXRpb25Ob2RlLCAhY2FyZXRQb3NpdGlvbi5pc0F0RW5kKCksIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNhcmV0UG9zaXRpb25CZWZvcmVOb2RlID0gY2FyZXRQb3NpdGlvbi5nZXROb2RlKHRydWUpO1xuICAgICAgaWYgKGlzSW5saW5lRmFrZUNhcmV0VGFyZ2V0KGNhcmV0UG9zaXRpb25CZWZvcmVOb2RlKSkge1xuICAgICAgICByZXR1cm4gc2hvd0NhcmV0KDEsIGVkaXRvciwgY2FyZXRQb3NpdGlvbkJlZm9yZU5vZGUsIGZhbHNlLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBjZVJvb3QgPSBnZXRDb250ZW50RWRpdGFibGVSb290JDEoZWRpdG9yLmRvbS5nZXRSb290KCksIGNhcmV0UG9zaXRpb24uZ2V0Tm9kZSgpKTtcbiAgICAgIGlmIChpc0lubGluZUZha2VDYXJldFRhcmdldChjZVJvb3QpKSB7XG4gICAgICAgIHJldHVybiBzaG93Q2FyZXQoMSwgZWRpdG9yLCBjZVJvb3QsIGZhbHNlLCBzY3JvbGxJbnRvVmlldyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgIH07XG4gICAgY29uc3QgcmVuZGVyUmFuZ2VDYXJldCA9IChlZGl0b3IsIHJhbmdlLCBzY3JvbGxJbnRvVmlldykgPT4gcmFuZ2UuY29sbGFwc2VkID8gcmVuZGVyQ2FyZXRBdFJhbmdlKGVkaXRvciwgcmFuZ2UsIHNjcm9sbEludG9WaWV3KS5nZXRPcihyYW5nZSkgOiByYW5nZTtcblxuICAgIGNvbnN0IGlzQmVmb3JlQm91bmRhcnkgPSBwb3MgPT4gaXNCZWZvcmVDb250ZW50RWRpdGFibGVGYWxzZShwb3MpIHx8IGlzQmVmb3JlTWVkaWEocG9zKTtcbiAgICBjb25zdCBpc0FmdGVyQm91bmRhcnkgPSBwb3MgPT4gaXNBZnRlckNvbnRlbnRFZGl0YWJsZUZhbHNlKHBvcykgfHwgaXNBZnRlck1lZGlhKHBvcyk7XG4gICAgY29uc3QgdHJpbUVtcHR5VGV4dE5vZGUgPSAoZG9tLCBub2RlKSA9PiB7XG4gICAgICBpZiAoaXNUZXh0JGEobm9kZSkgJiYgbm9kZS5kYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkb20ucmVtb3ZlKG5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZGVsZXRlQ29udGVudEFuZFNob3dDYXJldCA9IChlZGl0b3IsIHJhbmdlLCBub2RlLCBkaXJlY3Rpb24sIGZvcndhcmQsIHBlZWtDYXJldFBvc2l0aW9uKSA9PiB7XG4gICAgICBzaG93Q2FyZXQoZGlyZWN0aW9uLCBlZGl0b3IsIHBlZWtDYXJldFBvc2l0aW9uLmdldE5vZGUoIWZvcndhcmQpLCBmb3J3YXJkLCB0cnVlKS5lYWNoKGNhcmV0UmFuZ2UgPT4ge1xuICAgICAgICBpZiAocmFuZ2UuY29sbGFwc2VkKSB7XG4gICAgICAgICAgY29uc3QgZGVsZXRlUmFuZ2UgPSByYW5nZS5jbG9uZVJhbmdlKCk7XG4gICAgICAgICAgaWYgKGZvcndhcmQpIHtcbiAgICAgICAgICAgIGRlbGV0ZVJhbmdlLnNldEVuZChjYXJldFJhbmdlLnN0YXJ0Q29udGFpbmVyLCBjYXJldFJhbmdlLnN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlUmFuZ2Uuc2V0U3RhcnQoY2FyZXRSYW5nZS5lbmRDb250YWluZXIsIGNhcmV0UmFuZ2UuZW5kT2Zmc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVsZXRlUmFuZ2UuZGVsZXRlQ29udGVudHMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByYW5nZS5kZWxldGVDb250ZW50cygpO1xuICAgICAgICB9XG4gICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Um5nKGNhcmV0UmFuZ2UpO1xuICAgICAgfSk7XG4gICAgICB0cmltRW1wdHlUZXh0Tm9kZShlZGl0b3IuZG9tLCBub2RlKTtcbiAgICB9O1xuICAgIGNvbnN0IGRlbGV0ZUJvdW5kYXJ5VGV4dCA9IChlZGl0b3IsIGZvcndhcmQpID0+IHtcbiAgICAgIGNvbnN0IHJhbmdlID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgIGlmICghaXNUZXh0JGEocmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXIpKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSBmb3J3YXJkID8gSERpcmVjdGlvbi5Gb3J3YXJkcyA6IEhEaXJlY3Rpb24uQmFja3dhcmRzO1xuICAgICAgY29uc3QgY2FyZXRXYWxrZXIgPSBDYXJldFdhbGtlcihlZGl0b3IuZ2V0Qm9keSgpKTtcbiAgICAgIGNvbnN0IGdldE5leHRQb3NGbiA9IGN1cnJ5KGdldFZpc3VhbENhcmV0UG9zaXRpb24sIGZvcndhcmQgPyBjYXJldFdhbGtlci5uZXh0IDogY2FyZXRXYWxrZXIucHJldik7XG4gICAgICBjb25zdCBpc0JlZm9yZUZuID0gZm9yd2FyZCA/IGlzQmVmb3JlQm91bmRhcnkgOiBpc0FmdGVyQm91bmRhcnk7XG4gICAgICBjb25zdCBjYXJldFBvc2l0aW9uID0gZ2V0Tm9ybWFsaXplZFJhbmdlRW5kUG9pbnQoZGlyZWN0aW9uLCBlZGl0b3IuZ2V0Qm9keSgpLCByYW5nZSk7XG4gICAgICBjb25zdCBuZXh0Q2FyZXRQb3NpdGlvbiA9IGdldE5leHRQb3NGbihjYXJldFBvc2l0aW9uKTtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWROZXh0Q2FyZXRQb3NpdGlvbiA9IG5leHRDYXJldFBvc2l0aW9uID8gbm9ybWFsaXplUG9zaXRpb24oZm9yd2FyZCwgbmV4dENhcmV0UG9zaXRpb24pIDogbmV4dENhcmV0UG9zaXRpb247XG4gICAgICBpZiAoIW5vcm1hbGl6ZWROZXh0Q2FyZXRQb3NpdGlvbiB8fCAhaXNNb3ZlSW5zaWRlU2FtZUJsb2NrKGNhcmV0UG9zaXRpb24sIG5vcm1hbGl6ZWROZXh0Q2FyZXRQb3NpdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNCZWZvcmVGbihub3JtYWxpemVkTmV4dENhcmV0UG9zaXRpb24pKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKCgpID0+IGRlbGV0ZUNvbnRlbnRBbmRTaG93Q2FyZXQoZWRpdG9yLCByYW5nZSwgY2FyZXRQb3NpdGlvbi5nZXROb2RlKCksIGRpcmVjdGlvbiwgZm9yd2FyZCwgbm9ybWFsaXplZE5leHRDYXJldFBvc2l0aW9uKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwZWVrQ2FyZXRQb3NpdGlvbiA9IGdldE5leHRQb3NGbihub3JtYWxpemVkTmV4dENhcmV0UG9zaXRpb24pO1xuICAgICAgaWYgKHBlZWtDYXJldFBvc2l0aW9uICYmIGlzQmVmb3JlRm4ocGVla0NhcmV0UG9zaXRpb24pKSB7XG4gICAgICAgIGlmIChpc01vdmVJbnNpZGVTYW1lQmxvY2sobm9ybWFsaXplZE5leHRDYXJldFBvc2l0aW9uLCBwZWVrQ2FyZXRQb3NpdGlvbikpIHtcbiAgICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZSgoKSA9PiBkZWxldGVDb250ZW50QW5kU2hvd0NhcmV0KGVkaXRvciwgcmFuZ2UsIGNhcmV0UG9zaXRpb24uZ2V0Tm9kZSgpLCBkaXJlY3Rpb24sIGZvcndhcmQsIHBlZWtDYXJldFBvc2l0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgfTtcbiAgICBjb25zdCBiYWNrc3BhY2VEZWxldGUkNiA9IChlZGl0b3IsIGZvcndhcmQpID0+IGRlbGV0ZUJvdW5kYXJ5VGV4dChlZGl0b3IsIGZvcndhcmQpO1xuXG4gICAgY29uc3QgZ2V0RWRnZUNlZlBvc2l0aW9uID0gKGVkaXRvciwgYXRTdGFydCkgPT4ge1xuICAgICAgY29uc3Qgcm9vdCA9IGVkaXRvci5nZXRCb2R5KCk7XG4gICAgICByZXR1cm4gYXRTdGFydCA/IGZpcnN0UG9zaXRpb25Jbihyb290KS5maWx0ZXIoaXNCZWZvcmVDb250ZW50RWRpdGFibGVGYWxzZSkgOiBsYXN0UG9zaXRpb25Jbihyb290KS5maWx0ZXIoaXNBZnRlckNvbnRlbnRFZGl0YWJsZUZhbHNlKTtcbiAgICB9O1xuICAgIGNvbnN0IGlzQ2VmQXRFZGdlU2VsZWN0ZWQgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3Qgcm5nID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgIHJldHVybiAhcm5nLmNvbGxhcHNlZCAmJiAoZ2V0RWRnZUNlZlBvc2l0aW9uKGVkaXRvciwgdHJ1ZSkuZXhpc3RzKHBvcyA9PiBwb3MuaXNFcXVhbChDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KHJuZykpKSB8fCBnZXRFZGdlQ2VmUG9zaXRpb24oZWRpdG9yLCBmYWxzZSkuZXhpc3RzKHBvcyA9PiBwb3MuaXNFcXVhbChDYXJldFBvc2l0aW9uLmZyb21SYW5nZUVuZChybmcpKSkpO1xuICAgIH07XG5cbiAgICBjb25zdCBpc0NvbXBvdW5kRWxlbWVudCA9IG5vZGUgPT4gaXNOb25OdWxsYWJsZShub2RlKSAmJiAoaXNUYWJsZUNlbGwkMihTdWdhckVsZW1lbnQuZnJvbURvbShub2RlKSkgfHwgaXNMaXN0SXRlbSQxKFN1Z2FyRWxlbWVudC5mcm9tRG9tKG5vZGUpKSk7XG4gICAgY29uc3QgRGVsZXRlQWN0aW9uID0gQWR0LmdlbmVyYXRlKFtcbiAgICAgIHsgcmVtb3ZlOiBbJ2VsZW1lbnQnXSB9LFxuICAgICAgeyBtb3ZlVG9FbGVtZW50OiBbJ2VsZW1lbnQnXSB9LFxuICAgICAgeyBtb3ZlVG9Qb3NpdGlvbjogWydwb3NpdGlvbiddIH1cbiAgICBdKTtcbiAgICBjb25zdCBpc0F0Q29udGVudEVkaXRhYmxlQmxvY2tDYXJldCA9IChmb3J3YXJkLCBmcm9tKSA9PiB7XG4gICAgICBjb25zdCBlbG0gPSBmcm9tLmdldE5vZGUoIWZvcndhcmQpO1xuICAgICAgY29uc3QgY2FyZXRMb2NhdGlvbiA9IGZvcndhcmQgPyAnYWZ0ZXInIDogJ2JlZm9yZSc7XG4gICAgICByZXR1cm4gaXNFbGVtZW50JDYoZWxtKSAmJiBlbG0uZ2V0QXR0cmlidXRlKCdkYXRhLW1jZS1jYXJldCcpID09PSBjYXJldExvY2F0aW9uO1xuICAgIH07XG4gICAgY29uc3QgaXNEZWxldGVGcm9tQ2VmRGlmZmVyZW50QmxvY2tzID0gKHJvb3QsIGZvcndhcmQsIGZyb20sIHRvKSA9PiB7XG4gICAgICBjb25zdCBpblNhbWVCbG9jayA9IGVsbSA9PiBpc0lubGluZSQxKFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVsbSkpICYmICFpc0luU2FtZUJsb2NrKGZyb20sIHRvLCByb290KTtcbiAgICAgIHJldHVybiBnZXRSZWxhdGl2ZUNlZkVsbSghZm9yd2FyZCwgZnJvbSkuZm9sZCgoKSA9PiBnZXRSZWxhdGl2ZUNlZkVsbShmb3J3YXJkLCB0bykuZm9sZChuZXZlciwgaW5TYW1lQmxvY2spLCBpblNhbWVCbG9jayk7XG4gICAgfTtcbiAgICBjb25zdCBkZWxldGVFbXB0eUJsb2NrT3JNb3ZlVG9DZWYgPSAocm9vdCwgZm9yd2FyZCwgZnJvbSwgdG8pID0+IHtcbiAgICAgIGNvbnN0IHRvQ2VmRWxtID0gdG8uZ2V0Tm9kZSghZm9yd2FyZCk7XG4gICAgICByZXR1cm4gZ2V0UGFyZW50QmxvY2skMihTdWdhckVsZW1lbnQuZnJvbURvbShyb290KSwgU3VnYXJFbGVtZW50LmZyb21Eb20oZnJvbS5nZXROb2RlKCkpKS5tYXAoYmxvY2tFbG0gPT4gaXNFbXB0eSQyKGJsb2NrRWxtKSA/IERlbGV0ZUFjdGlvbi5yZW1vdmUoYmxvY2tFbG0uZG9tKSA6IERlbGV0ZUFjdGlvbi5tb3ZlVG9FbGVtZW50KHRvQ2VmRWxtKSkub3JUaHVuaygoKSA9PiBPcHRpb25hbC5zb21lKERlbGV0ZUFjdGlvbi5tb3ZlVG9FbGVtZW50KHRvQ2VmRWxtKSkpO1xuICAgIH07XG4gICAgY29uc3QgZmluZENlZlBvc2l0aW9uID0gKHJvb3QsIGZvcndhcmQsIGZyb20pID0+IGZyb21Qb3NpdGlvbihmb3J3YXJkLCByb290LCBmcm9tKS5iaW5kKHRvID0+IHtcbiAgICAgIGlmIChpc0NvbXBvdW5kRWxlbWVudCh0by5nZXROb2RlKCkpKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVsZXRlRnJvbUNlZkRpZmZlcmVudEJsb2Nrcyhyb290LCBmb3J3YXJkLCBmcm9tLCB0bykpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH0gZWxzZSBpZiAoZm9yd2FyZCAmJiBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJGIodG8uZ2V0Tm9kZSgpKSkge1xuICAgICAgICByZXR1cm4gZGVsZXRlRW1wdHlCbG9ja09yTW92ZVRvQ2VmKHJvb3QsIGZvcndhcmQsIGZyb20sIHRvKTtcbiAgICAgIH0gZWxzZSBpZiAoIWZvcndhcmQgJiYgaXNDb250ZW50RWRpdGFibGVGYWxzZSRiKHRvLmdldE5vZGUodHJ1ZSkpKSB7XG4gICAgICAgIHJldHVybiBkZWxldGVFbXB0eUJsb2NrT3JNb3ZlVG9DZWYocm9vdCwgZm9yd2FyZCwgZnJvbSwgdG8pO1xuICAgICAgfSBlbHNlIGlmIChmb3J3YXJkICYmIGlzQWZ0ZXJDb250ZW50RWRpdGFibGVGYWxzZShmcm9tKSkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShEZWxldGVBY3Rpb24ubW92ZVRvUG9zaXRpb24odG8pKTtcbiAgICAgIH0gZWxzZSBpZiAoIWZvcndhcmQgJiYgaXNCZWZvcmVDb250ZW50RWRpdGFibGVGYWxzZShmcm9tKSkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShEZWxldGVBY3Rpb24ubW92ZVRvUG9zaXRpb24odG8pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgZ2V0Q29udGVudEVkaXRhYmxlQmxvY2tBY3Rpb24gPSAoZm9yd2FyZCwgZWxtKSA9PiB7XG4gICAgICBpZiAoaXNOdWxsYWJsZShlbG0pKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9IGVsc2UgaWYgKGZvcndhcmQgJiYgaXNDb250ZW50RWRpdGFibGVGYWxzZSRiKGVsbS5uZXh0U2libGluZykpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoRGVsZXRlQWN0aW9uLm1vdmVUb0VsZW1lbnQoZWxtLm5leHRTaWJsaW5nKSk7XG4gICAgICB9IGVsc2UgaWYgKCFmb3J3YXJkICYmIGlzQ29udGVudEVkaXRhYmxlRmFsc2UkYihlbG0ucHJldmlvdXNTaWJsaW5nKSkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShEZWxldGVBY3Rpb24ubW92ZVRvRWxlbWVudChlbG0ucHJldmlvdXNTaWJsaW5nKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc2tpcE1vdmVUb0FjdGlvbkZyb21JbmxpbmVDZWZUb0NvbnRlbnQgPSAocm9vdCwgZnJvbSwgZGVsZXRlQWN0aW9uKSA9PiBkZWxldGVBY3Rpb24uZm9sZChlbG0gPT4gT3B0aW9uYWwuc29tZShEZWxldGVBY3Rpb24ucmVtb3ZlKGVsbSkpLCBlbG0gPT4gT3B0aW9uYWwuc29tZShEZWxldGVBY3Rpb24ubW92ZVRvRWxlbWVudChlbG0pKSwgdG8gPT4ge1xuICAgICAgaWYgKGlzSW5TYW1lQmxvY2soZnJvbSwgdG8sIHJvb3QpKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShEZWxldGVBY3Rpb24ubW92ZVRvUG9zaXRpb24odG8pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBnZXRDb250ZW50RWRpdGFibGVBY3Rpb24gPSAocm9vdCwgZm9yd2FyZCwgZnJvbSkgPT4ge1xuICAgICAgaWYgKGlzQXRDb250ZW50RWRpdGFibGVCbG9ja0NhcmV0KGZvcndhcmQsIGZyb20pKSB7XG4gICAgICAgIHJldHVybiBnZXRDb250ZW50RWRpdGFibGVCbG9ja0FjdGlvbihmb3J3YXJkLCBmcm9tLmdldE5vZGUoIWZvcndhcmQpKS5vclRodW5rKCgpID0+IGZpbmRDZWZQb3NpdGlvbihyb290LCBmb3J3YXJkLCBmcm9tKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmluZENlZlBvc2l0aW9uKHJvb3QsIGZvcndhcmQsIGZyb20pLmJpbmQoZGVsZXRlQWN0aW9uID0+IHNraXBNb3ZlVG9BY3Rpb25Gcm9tSW5saW5lQ2VmVG9Db250ZW50KHJvb3QsIGZyb20sIGRlbGV0ZUFjdGlvbikpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmVhZCA9IChyb290LCBmb3J3YXJkLCBybmcpID0+IHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRSYW5nZSA9IG5vcm1hbGl6ZVJhbmdlKGZvcndhcmQgPyAxIDogLTEsIHJvb3QsIHJuZyk7XG4gICAgICBjb25zdCBmcm9tID0gQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChub3JtYWxpemVkUmFuZ2UpO1xuICAgICAgY29uc3Qgcm9vdEVsZW1lbnQgPSBTdWdhckVsZW1lbnQuZnJvbURvbShyb290KTtcbiAgICAgIGlmICghZm9yd2FyZCAmJiBpc0FmdGVyQ29udGVudEVkaXRhYmxlRmFsc2UoZnJvbSkpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoRGVsZXRlQWN0aW9uLnJlbW92ZShmcm9tLmdldE5vZGUodHJ1ZSkpKTtcbiAgICAgIH0gZWxzZSBpZiAoZm9yd2FyZCAmJiBpc0JlZm9yZUNvbnRlbnRFZGl0YWJsZUZhbHNlKGZyb20pKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKERlbGV0ZUFjdGlvbi5yZW1vdmUoZnJvbS5nZXROb2RlKCkpKTtcbiAgICAgIH0gZWxzZSBpZiAoIWZvcndhcmQgJiYgaXNCZWZvcmVDb250ZW50RWRpdGFibGVGYWxzZShmcm9tKSAmJiBpc0FmdGVyQnIocm9vdEVsZW1lbnQsIGZyb20pKSB7XG4gICAgICAgIHJldHVybiBmaW5kUHJldmlvdXNCcihyb290RWxlbWVudCwgZnJvbSkubWFwKGJyID0+IERlbGV0ZUFjdGlvbi5yZW1vdmUoYnIuZ2V0Tm9kZSgpKSk7XG4gICAgICB9IGVsc2UgaWYgKGZvcndhcmQgJiYgaXNBZnRlckNvbnRlbnRFZGl0YWJsZUZhbHNlKGZyb20pICYmIGlzQmVmb3JlQnIkMShyb290RWxlbWVudCwgZnJvbSkpIHtcbiAgICAgICAgcmV0dXJuIGZpbmROZXh0QnIocm9vdEVsZW1lbnQsIGZyb20pLm1hcChiciA9PiBEZWxldGVBY3Rpb24ucmVtb3ZlKGJyLmdldE5vZGUoKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGdldENvbnRlbnRFZGl0YWJsZUFjdGlvbihyb290LCBmb3J3YXJkLCBmcm9tKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgZGVsZXRlRWxlbWVudCQxID0gKGVkaXRvciwgZm9yd2FyZCkgPT4gZWxlbWVudCA9PiB7XG4gICAgICBlZGl0b3IuX3NlbGVjdGlvbk92ZXJyaWRlcy5oaWRlRmFrZUNhcmV0KCk7XG4gICAgICBkZWxldGVFbGVtZW50JDIoZWRpdG9yLCBmb3J3YXJkLCBTdWdhckVsZW1lbnQuZnJvbURvbShlbGVtZW50KSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIGNvbnN0IG1vdmVUb0VsZW1lbnQgPSAoZWRpdG9yLCBmb3J3YXJkKSA9PiBlbGVtZW50ID0+IHtcbiAgICAgIGNvbnN0IHBvcyA9IGZvcndhcmQgPyBDYXJldFBvc2l0aW9uLmJlZm9yZShlbGVtZW50KSA6IENhcmV0UG9zaXRpb24uYWZ0ZXIoZWxlbWVudCk7XG4gICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFJuZyhwb3MudG9SYW5nZSgpKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgY29uc3QgbW92ZVRvUG9zaXRpb24gPSBlZGl0b3IgPT4gcG9zID0+IHtcbiAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Um5nKHBvcy50b1JhbmdlKCkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBjb25zdCBnZXRBbmNlc3RvckNlID0gKGVkaXRvciwgbm9kZSkgPT4gT3B0aW9uYWwuZnJvbShnZXRDb250ZW50RWRpdGFibGVSb290JDEoZWRpdG9yLmdldEJvZHkoKSwgbm9kZSkpO1xuICAgIGNvbnN0IGJhY2tzcGFjZURlbGV0ZUNhcmV0ID0gKGVkaXRvciwgZm9yd2FyZCkgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0ZWROb2RlID0gZWRpdG9yLnNlbGVjdGlvbi5nZXROb2RlKCk7XG4gICAgICByZXR1cm4gZ2V0QW5jZXN0b3JDZShlZGl0b3IsIHNlbGVjdGVkTm9kZSkuZmlsdGVyKGlzQ29udGVudEVkaXRhYmxlRmFsc2UkYikuZm9sZCgoKSA9PiByZWFkKGVkaXRvci5nZXRCb2R5KCksIGZvcndhcmQsIGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCkpLm1hcChkZWxldGVBY3Rpb24gPT4gKCkgPT4gZGVsZXRlQWN0aW9uLmZvbGQoZGVsZXRlRWxlbWVudCQxKGVkaXRvciwgZm9yd2FyZCksIG1vdmVUb0VsZW1lbnQoZWRpdG9yLCBmb3J3YXJkKSwgbW92ZVRvUG9zaXRpb24oZWRpdG9yKSkpLCAoKSA9PiBPcHRpb25hbC5zb21lKG5vb3ApKTtcbiAgICB9O1xuICAgIGNvbnN0IGRlbGV0ZU9mZnNjcmVlblNlbGVjdGlvbiA9IHJvb3RFbGVtZW50ID0+IHtcbiAgICAgIGVhY2gkZShkZXNjZW5kYW50cyhyb290RWxlbWVudCwgJy5tY2Utb2Zmc2NyZWVuLXNlbGVjdGlvbicpLCByZW1vdmUkNik7XG4gICAgfTtcbiAgICBjb25zdCBiYWNrc3BhY2VEZWxldGVSYW5nZSA9IChlZGl0b3IsIGZvcndhcmQpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkTm9kZSA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Tm9kZSgpO1xuICAgICAgaWYgKGlzQ29udGVudEVkaXRhYmxlRmFsc2UkYihzZWxlY3RlZE5vZGUpICYmICFpc1RhYmxlQ2VsbCQzKHNlbGVjdGVkTm9kZSkpIHtcbiAgICAgICAgY29uc3QgaGFzQ2VmQW5jZXN0b3IgPSBnZXRBbmNlc3RvckNlKGVkaXRvciwgc2VsZWN0ZWROb2RlLnBhcmVudE5vZGUpLmZpbHRlcihpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJGIpO1xuICAgICAgICByZXR1cm4gaGFzQ2VmQW5jZXN0b3IuZm9sZCgoKSA9PiBPcHRpb25hbC5zb21lKCgpID0+IHtcbiAgICAgICAgICBkZWxldGVPZmZzY3JlZW5TZWxlY3Rpb24oU3VnYXJFbGVtZW50LmZyb21Eb20oZWRpdG9yLmdldEJvZHkoKSkpO1xuICAgICAgICAgIGRlbGV0ZUVsZW1lbnQkMihlZGl0b3IsIGZvcndhcmQsIFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5zZWxlY3Rpb24uZ2V0Tm9kZSgpKSk7XG4gICAgICAgICAgcGFkZEVtcHR5Qm9keShlZGl0b3IpO1xuICAgICAgICB9KSwgKCkgPT4gT3B0aW9uYWwuc29tZShub29wKSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNDZWZBdEVkZ2VTZWxlY3RlZChlZGl0b3IpKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKCgpID0+IHtcbiAgICAgICAgICBkZWxldGVSYW5nZUNvbnRlbnRzKGVkaXRvciwgZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKSwgU3VnYXJFbGVtZW50LmZyb21Eb20oZWRpdG9yLmdldEJvZHkoKSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgfTtcbiAgICBjb25zdCBwYWRkRW1wdHlFbGVtZW50ID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb20sIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgICBjb25zdCBjZVJvb3QgPSBnZXRDb250ZW50RWRpdGFibGVSb290JDEoZWRpdG9yLmdldEJvZHkoKSwgc2VsZWN0aW9uLmdldE5vZGUoKSk7XG4gICAgICBpZiAoaXNDb250ZW50RWRpdGFibGVUcnVlJDMoY2VSb290KSAmJiBkb20uaXNCbG9jayhjZVJvb3QpICYmIGRvbS5pc0VtcHR5KGNlUm9vdCkpIHtcbiAgICAgICAgY29uc3QgYnIgPSBkb20uY3JlYXRlKCdicicsIHsgJ2RhdGEtbWNlLWJvZ3VzJzogJzEnIH0pO1xuICAgICAgICBkb20uc2V0SFRNTChjZVJvb3QsICcnKTtcbiAgICAgICAgY2VSb290LmFwcGVuZENoaWxkKGJyKTtcbiAgICAgICAgc2VsZWN0aW9uLnNldFJuZyhDYXJldFBvc2l0aW9uLmJlZm9yZShicikudG9SYW5nZSgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgY29uc3QgYmFja3NwYWNlRGVsZXRlJDUgPSAoZWRpdG9yLCBmb3J3YXJkKSA9PiB7XG4gICAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICAgIHJldHVybiBiYWNrc3BhY2VEZWxldGVDYXJldChlZGl0b3IsIGZvcndhcmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGJhY2tzcGFjZURlbGV0ZVJhbmdlKGVkaXRvciwgZm9yd2FyZCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGRlbGV0ZUNhcmV0JDIgPSAoZWRpdG9yLCBmb3J3YXJkKSA9PiB7XG4gICAgICBjb25zdCBmcm9tUG9zID0gQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpKTtcbiAgICAgIHJldHVybiBmcm9tUG9zaXRpb24oZm9yd2FyZCwgZWRpdG9yLmdldEJvZHkoKSwgZnJvbVBvcykuZmlsdGVyKHBvcyA9PiBmb3J3YXJkID8gaXNCZWZvcmVJbWFnZUJsb2NrKHBvcykgOiBpc0FmdGVySW1hZ2VCbG9jayhwb3MpKS5iaW5kKHBvcyA9PiBnZXRDaGlsZE5vZGVBdFJlbGF0aXZlT2Zmc2V0KGZvcndhcmQgPyAwIDogLTEsIHBvcykpLm1hcChlbG0gPT4gKCkgPT4gZWRpdG9yLnNlbGVjdGlvbi5zZWxlY3QoZWxtKSk7XG4gICAgfTtcbiAgICBjb25zdCBiYWNrc3BhY2VEZWxldGUkNCA9IChlZGl0b3IsIGZvcndhcmQpID0+IGVkaXRvci5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSA/IGRlbGV0ZUNhcmV0JDIoZWRpdG9yLCBmb3J3YXJkKSA6IE9wdGlvbmFsLm5vbmUoKTtcblxuICAgIGNvbnN0IGlzVGV4dCQyID0gaXNUZXh0JGE7XG4gICAgY29uc3Qgc3RhcnRzV2l0aENhcmV0Q29udGFpbmVyID0gbm9kZSA9PiBpc1RleHQkMihub2RlKSAmJiBub2RlLmRhdGFbMF0gPT09IFpXU1AkMTtcbiAgICBjb25zdCBlbmRzV2l0aENhcmV0Q29udGFpbmVyID0gbm9kZSA9PiBpc1RleHQkMihub2RlKSAmJiBub2RlLmRhdGFbbm9kZS5kYXRhLmxlbmd0aCAtIDFdID09PSBaV1NQJDE7XG4gICAgY29uc3QgY3JlYXRlWndzcCA9IG5vZGUgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgZG9jID0gKF9hID0gbm9kZS5vd25lckRvY3VtZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkb2N1bWVudDtcbiAgICAgIHJldHVybiBkb2MuY3JlYXRlVGV4dE5vZGUoWldTUCQxKTtcbiAgICB9O1xuICAgIGNvbnN0IGluc2VydEJlZm9yZSA9IG5vZGUgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKGlzVGV4dCQyKG5vZGUucHJldmlvdXNTaWJsaW5nKSkge1xuICAgICAgICBpZiAoZW5kc1dpdGhDYXJldENvbnRhaW5lcihub2RlLnByZXZpb3VzU2libGluZykpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5wcmV2aW91c1NpYmxpbmcuYXBwZW5kRGF0YShaV1NQJDEpO1xuICAgICAgICAgIHJldHVybiBub2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc1RleHQkMihub2RlKSkge1xuICAgICAgICBpZiAoc3RhcnRzV2l0aENhcmV0Q29udGFpbmVyKG5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5pbnNlcnREYXRhKDAsIFpXU1AkMSk7XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5ld05vZGUgPSBjcmVhdGVad3NwKG5vZGUpO1xuICAgICAgICAoX2EgPSBub2RlLnBhcmVudE5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgbm9kZSk7XG4gICAgICAgIHJldHVybiBuZXdOb2RlO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaW5zZXJ0QWZ0ZXIgPSBub2RlID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBpZiAoaXNUZXh0JDIobm9kZS5uZXh0U2libGluZykpIHtcbiAgICAgICAgaWYgKHN0YXJ0c1dpdGhDYXJldENvbnRhaW5lcihub2RlLm5leHRTaWJsaW5nKSkge1xuICAgICAgICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUubmV4dFNpYmxpbmcuaW5zZXJ0RGF0YSgwLCBaV1NQJDEpO1xuICAgICAgICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzVGV4dCQyKG5vZGUpKSB7XG4gICAgICAgIGlmIChlbmRzV2l0aENhcmV0Q29udGFpbmVyKG5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5hcHBlbmREYXRhKFpXU1AkMSk7XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5ld05vZGUgPSBjcmVhdGVad3NwKG5vZGUpO1xuICAgICAgICBpZiAobm9kZS5uZXh0U2libGluZykge1xuICAgICAgICAgIChfYSA9IG5vZGUucGFyZW50Tm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluc2VydEJlZm9yZShuZXdOb2RlLCBub2RlLm5leHRTaWJsaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAoX2IgPSBub2RlLnBhcmVudE5vZGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hcHBlbmRDaGlsZChuZXdOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3Tm9kZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGluc2VydElubGluZSA9IChiZWZvcmUsIG5vZGUpID0+IGJlZm9yZSA/IGluc2VydEJlZm9yZShub2RlKSA6IGluc2VydEFmdGVyKG5vZGUpO1xuICAgIGNvbnN0IGluc2VydElubGluZUJlZm9yZSA9IGN1cnJ5KGluc2VydElubGluZSwgdHJ1ZSk7XG4gICAgY29uc3QgaW5zZXJ0SW5saW5lQWZ0ZXIgPSBjdXJyeShpbnNlcnRJbmxpbmUsIGZhbHNlKTtcblxuICAgIGNvbnN0IGluc2VydElubGluZVBvcyA9IChwb3MsIGJlZm9yZSkgPT4ge1xuICAgICAgaWYgKGlzVGV4dCRhKHBvcy5jb250YWluZXIoKSkpIHtcbiAgICAgICAgcmV0dXJuIGluc2VydElubGluZShiZWZvcmUsIHBvcy5jb250YWluZXIoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaW5zZXJ0SW5saW5lKGJlZm9yZSwgcG9zLmdldE5vZGUoKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpc1Bvc0NhcmV0Q29udGFpbmVyID0gKHBvcywgY2FyZXQpID0+IHtcbiAgICAgIGNvbnN0IGNhcmV0Tm9kZSA9IGNhcmV0LmdldCgpO1xuICAgICAgcmV0dXJuIGNhcmV0Tm9kZSAmJiBwb3MuY29udGFpbmVyKCkgPT09IGNhcmV0Tm9kZSAmJiBpc0NhcmV0Q29udGFpbmVySW5saW5lKGNhcmV0Tm9kZSk7XG4gICAgfTtcbiAgICBjb25zdCByZW5kZXJDYXJldCA9IChjYXJldCwgbG9jYXRpb24pID0+IGxvY2F0aW9uLmZvbGQoZWxlbWVudCA9PiB7XG4gICAgICByZW1vdmUkNChjYXJldC5nZXQoKSk7XG4gICAgICBjb25zdCB0ZXh0ID0gaW5zZXJ0SW5saW5lQmVmb3JlKGVsZW1lbnQpO1xuICAgICAgY2FyZXQuc2V0KHRleHQpO1xuICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoQ2FyZXRQb3NpdGlvbih0ZXh0LCB0ZXh0Lmxlbmd0aCAtIDEpKTtcbiAgICB9LCBlbGVtZW50ID0+IGZpcnN0UG9zaXRpb25JbihlbGVtZW50KS5tYXAocG9zID0+IHtcbiAgICAgIGlmICghaXNQb3NDYXJldENvbnRhaW5lcihwb3MsIGNhcmV0KSkge1xuICAgICAgICByZW1vdmUkNChjYXJldC5nZXQoKSk7XG4gICAgICAgIGNvbnN0IHRleHQgPSBpbnNlcnRJbmxpbmVQb3MocG9zLCB0cnVlKTtcbiAgICAgICAgY2FyZXQuc2V0KHRleHQpO1xuICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbih0ZXh0LCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBjYXJldC5nZXQoKTtcbiAgICAgICAgcmV0dXJuIENhcmV0UG9zaXRpb24obm9kZSwgMSk7XG4gICAgICB9XG4gICAgfSksIGVsZW1lbnQgPT4gbGFzdFBvc2l0aW9uSW4oZWxlbWVudCkubWFwKHBvcyA9PiB7XG4gICAgICBpZiAoIWlzUG9zQ2FyZXRDb250YWluZXIocG9zLCBjYXJldCkpIHtcbiAgICAgICAgcmVtb3ZlJDQoY2FyZXQuZ2V0KCkpO1xuICAgICAgICBjb25zdCB0ZXh0ID0gaW5zZXJ0SW5saW5lUG9zKHBvcywgZmFsc2UpO1xuICAgICAgICBjYXJldC5zZXQodGV4dCk7XG4gICAgICAgIHJldHVybiBDYXJldFBvc2l0aW9uKHRleHQsIHRleHQubGVuZ3RoIC0gMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBub2RlID0gY2FyZXQuZ2V0KCk7XG4gICAgICAgIHJldHVybiBDYXJldFBvc2l0aW9uKG5vZGUsIG5vZGUubGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgfSksIGVsZW1lbnQgPT4ge1xuICAgICAgcmVtb3ZlJDQoY2FyZXQuZ2V0KCkpO1xuICAgICAgY29uc3QgdGV4dCA9IGluc2VydElubGluZUFmdGVyKGVsZW1lbnQpO1xuICAgICAgY2FyZXQuc2V0KHRleHQpO1xuICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoQ2FyZXRQb3NpdGlvbih0ZXh0LCAxKSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBldmFsdWF0ZVVudGlsID0gKGZucywgYXJncykgPT4ge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZm5zW2ldLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICBpZiAocmVzdWx0LmlzU29tZSgpKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgTG9jYXRpb24gPSBBZHQuZ2VuZXJhdGUoW1xuICAgICAgeyBiZWZvcmU6IFsnZWxlbWVudCddIH0sXG4gICAgICB7IHN0YXJ0OiBbJ2VsZW1lbnQnXSB9LFxuICAgICAgeyBlbmQ6IFsnZWxlbWVudCddIH0sXG4gICAgICB7IGFmdGVyOiBbJ2VsZW1lbnQnXSB9XG4gICAgXSk7XG4gICAgY29uc3QgcmVzY29wZSQxID0gKHJvb3ROb2RlLCBub2RlKSA9PiB7XG4gICAgICBjb25zdCBwYXJlbnRCbG9jayA9IGdldFBhcmVudEJsb2NrJDMobm9kZSwgcm9vdE5vZGUpO1xuICAgICAgcmV0dXJuIHBhcmVudEJsb2NrID8gcGFyZW50QmxvY2sgOiByb290Tm9kZTtcbiAgICB9O1xuICAgIGNvbnN0IGJlZm9yZSA9IChpc0lubGluZVRhcmdldCwgcm9vdE5vZGUsIHBvcykgPT4ge1xuICAgICAgY29uc3QgblBvcyA9IG5vcm1hbGl6ZUZvcndhcmRzKHBvcyk7XG4gICAgICBjb25zdCBzY29wZSA9IHJlc2NvcGUkMShyb290Tm9kZSwgblBvcy5jb250YWluZXIoKSk7XG4gICAgICByZXR1cm4gZmluZFJvb3RJbmxpbmUoaXNJbmxpbmVUYXJnZXQsIHNjb3BlLCBuUG9zKS5mb2xkKCgpID0+IG5leHRQb3NpdGlvbihzY29wZSwgblBvcykuYmluZChjdXJyeShmaW5kUm9vdElubGluZSwgaXNJbmxpbmVUYXJnZXQsIHNjb3BlKSkubWFwKGlubGluZSA9PiBMb2NhdGlvbi5iZWZvcmUoaW5saW5lKSksIE9wdGlvbmFsLm5vbmUpO1xuICAgIH07XG4gICAgY29uc3QgaXNOb3RJbnNpZGVGb3JtYXRDYXJldENvbnRhaW5lciA9IChyb290Tm9kZSwgZWxtKSA9PiBnZXRQYXJlbnRDYXJldENvbnRhaW5lcihyb290Tm9kZSwgZWxtKSA9PT0gbnVsbDtcbiAgICBjb25zdCBmaW5kSW5zaWRlUm9vdElubGluZSA9IChpc0lubGluZVRhcmdldCwgcm9vdE5vZGUsIHBvcykgPT4gZmluZFJvb3RJbmxpbmUoaXNJbmxpbmVUYXJnZXQsIHJvb3ROb2RlLCBwb3MpLmZpbHRlcihjdXJyeShpc05vdEluc2lkZUZvcm1hdENhcmV0Q29udGFpbmVyLCByb290Tm9kZSkpO1xuICAgIGNvbnN0IHN0YXJ0JDEgPSAoaXNJbmxpbmVUYXJnZXQsIHJvb3ROb2RlLCBwb3MpID0+IHtcbiAgICAgIGNvbnN0IG5Qb3MgPSBub3JtYWxpemVCYWNrd2FyZHMocG9zKTtcbiAgICAgIHJldHVybiBmaW5kSW5zaWRlUm9vdElubGluZShpc0lubGluZVRhcmdldCwgcm9vdE5vZGUsIG5Qb3MpLmJpbmQoaW5saW5lID0+IHtcbiAgICAgICAgY29uc3QgcHJldlBvcyA9IHByZXZQb3NpdGlvbihpbmxpbmUsIG5Qb3MpO1xuICAgICAgICByZXR1cm4gcHJldlBvcy5pc05vbmUoKSA/IE9wdGlvbmFsLnNvbWUoTG9jYXRpb24uc3RhcnQoaW5saW5lKSkgOiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGVuZCA9IChpc0lubGluZVRhcmdldCwgcm9vdE5vZGUsIHBvcykgPT4ge1xuICAgICAgY29uc3QgblBvcyA9IG5vcm1hbGl6ZUZvcndhcmRzKHBvcyk7XG4gICAgICByZXR1cm4gZmluZEluc2lkZVJvb3RJbmxpbmUoaXNJbmxpbmVUYXJnZXQsIHJvb3ROb2RlLCBuUG9zKS5iaW5kKGlubGluZSA9PiB7XG4gICAgICAgIGNvbnN0IG5leHRQb3MgPSBuZXh0UG9zaXRpb24oaW5saW5lLCBuUG9zKTtcbiAgICAgICAgcmV0dXJuIG5leHRQb3MuaXNOb25lKCkgPyBPcHRpb25hbC5zb21lKExvY2F0aW9uLmVuZChpbmxpbmUpKSA6IE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgYWZ0ZXIgPSAoaXNJbmxpbmVUYXJnZXQsIHJvb3ROb2RlLCBwb3MpID0+IHtcbiAgICAgIGNvbnN0IG5Qb3MgPSBub3JtYWxpemVCYWNrd2FyZHMocG9zKTtcbiAgICAgIGNvbnN0IHNjb3BlID0gcmVzY29wZSQxKHJvb3ROb2RlLCBuUG9zLmNvbnRhaW5lcigpKTtcbiAgICAgIHJldHVybiBmaW5kUm9vdElubGluZShpc0lubGluZVRhcmdldCwgc2NvcGUsIG5Qb3MpLmZvbGQoKCkgPT4gcHJldlBvc2l0aW9uKHNjb3BlLCBuUG9zKS5iaW5kKGN1cnJ5KGZpbmRSb290SW5saW5lLCBpc0lubGluZVRhcmdldCwgc2NvcGUpKS5tYXAoaW5saW5lID0+IExvY2F0aW9uLmFmdGVyKGlubGluZSkpLCBPcHRpb25hbC5ub25lKTtcbiAgICB9O1xuICAgIGNvbnN0IGlzVmFsaWRMb2NhdGlvbiA9IGxvY2F0aW9uID0+ICFpc1J0bChnZXRFbGVtZW50KGxvY2F0aW9uKSk7XG4gICAgY29uc3QgcmVhZExvY2F0aW9uID0gKGlzSW5saW5lVGFyZ2V0LCByb290Tm9kZSwgcG9zKSA9PiB7XG4gICAgICBjb25zdCBsb2NhdGlvbiA9IGV2YWx1YXRlVW50aWwoW1xuICAgICAgICBiZWZvcmUsXG4gICAgICAgIHN0YXJ0JDEsXG4gICAgICAgIGVuZCxcbiAgICAgICAgYWZ0ZXJcbiAgICAgIF0sIFtcbiAgICAgICAgaXNJbmxpbmVUYXJnZXQsXG4gICAgICAgIHJvb3ROb2RlLFxuICAgICAgICBwb3NcbiAgICAgIF0pO1xuICAgICAgcmV0dXJuIGxvY2F0aW9uLmZpbHRlcihpc1ZhbGlkTG9jYXRpb24pO1xuICAgIH07XG4gICAgY29uc3QgZ2V0RWxlbWVudCA9IGxvY2F0aW9uID0+IGxvY2F0aW9uLmZvbGQoaWRlbnRpdHksIGlkZW50aXR5LCBpZGVudGl0eSwgaWRlbnRpdHkpO1xuICAgIGNvbnN0IGdldE5hbWUgPSBsb2NhdGlvbiA9PiBsb2NhdGlvbi5mb2xkKGNvbnN0YW50KCdiZWZvcmUnKSwgY29uc3RhbnQoJ3N0YXJ0JyksIGNvbnN0YW50KCdlbmQnKSwgY29uc3RhbnQoJ2FmdGVyJykpO1xuICAgIGNvbnN0IG91dHNpZGUgPSBsb2NhdGlvbiA9PiBsb2NhdGlvbi5mb2xkKExvY2F0aW9uLmJlZm9yZSwgTG9jYXRpb24uYmVmb3JlLCBMb2NhdGlvbi5hZnRlciwgTG9jYXRpb24uYWZ0ZXIpO1xuICAgIGNvbnN0IGluc2lkZSA9IGxvY2F0aW9uID0+IGxvY2F0aW9uLmZvbGQoTG9jYXRpb24uc3RhcnQsIExvY2F0aW9uLnN0YXJ0LCBMb2NhdGlvbi5lbmQsIExvY2F0aW9uLmVuZCk7XG4gICAgY29uc3QgaXNFcSA9IChsb2NhdGlvbjEsIGxvY2F0aW9uMikgPT4gZ2V0TmFtZShsb2NhdGlvbjEpID09PSBnZXROYW1lKGxvY2F0aW9uMikgJiYgZ2V0RWxlbWVudChsb2NhdGlvbjEpID09PSBnZXRFbGVtZW50KGxvY2F0aW9uMik7XG4gICAgY29uc3QgYmV0d2VlbklubGluZXMgPSAoZm9yd2FyZCwgaXNJbmxpbmVUYXJnZXQsIHJvb3ROb2RlLCBmcm9tLCB0bywgbG9jYXRpb24pID0+IGxpZnQyKGZpbmRSb290SW5saW5lKGlzSW5saW5lVGFyZ2V0LCByb290Tm9kZSwgZnJvbSksIGZpbmRSb290SW5saW5lKGlzSW5saW5lVGFyZ2V0LCByb290Tm9kZSwgdG8pLCAoZnJvbUlubGluZSwgdG9JbmxpbmUpID0+IHtcbiAgICAgIGlmIChmcm9tSW5saW5lICE9PSB0b0lubGluZSAmJiBoYXNTYW1lUGFyZW50QmxvY2socm9vdE5vZGUsIGZyb21JbmxpbmUsIHRvSW5saW5lKSkge1xuICAgICAgICByZXR1cm4gTG9jYXRpb24uYWZ0ZXIoZm9yd2FyZCA/IGZyb21JbmxpbmUgOiB0b0lubGluZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbG9jYXRpb247XG4gICAgICB9XG4gICAgfSkuZ2V0T3IobG9jYXRpb24pO1xuICAgIGNvbnN0IHNraXBOb01vdmVtZW50ID0gKGZyb21Mb2NhdGlvbiwgdG9Mb2NhdGlvbikgPT4gZnJvbUxvY2F0aW9uLmZvbGQoYWx3YXlzLCBmcm9tTG9jYXRpb24gPT4gIWlzRXEoZnJvbUxvY2F0aW9uLCB0b0xvY2F0aW9uKSk7XG4gICAgY29uc3QgZmluZExvY2F0aW9uVHJhdmVyc2UgPSAoZm9yd2FyZCwgaXNJbmxpbmVUYXJnZXQsIHJvb3ROb2RlLCBmcm9tTG9jYXRpb24sIHBvcykgPT4ge1xuICAgICAgY29uc3QgZnJvbSA9IG5vcm1hbGl6ZVBvc2l0aW9uKGZvcndhcmQsIHBvcyk7XG4gICAgICBjb25zdCB0byA9IGZyb21Qb3NpdGlvbihmb3J3YXJkLCByb290Tm9kZSwgZnJvbSkubWFwKGN1cnJ5KG5vcm1hbGl6ZVBvc2l0aW9uLCBmb3J3YXJkKSk7XG4gICAgICBjb25zdCBsb2NhdGlvbiA9IHRvLmZvbGQoKCkgPT4gZnJvbUxvY2F0aW9uLm1hcChvdXRzaWRlKSwgdG8gPT4gcmVhZExvY2F0aW9uKGlzSW5saW5lVGFyZ2V0LCByb290Tm9kZSwgdG8pLm1hcChjdXJyeShiZXR3ZWVuSW5saW5lcywgZm9yd2FyZCwgaXNJbmxpbmVUYXJnZXQsIHJvb3ROb2RlLCBmcm9tLCB0bykpLmZpbHRlcihjdXJyeShza2lwTm9Nb3ZlbWVudCwgZnJvbUxvY2F0aW9uKSkpO1xuICAgICAgcmV0dXJuIGxvY2F0aW9uLmZpbHRlcihpc1ZhbGlkTG9jYXRpb24pO1xuICAgIH07XG4gICAgY29uc3QgZmluZExvY2F0aW9uU2ltcGxlID0gKGZvcndhcmQsIGxvY2F0aW9uKSA9PiB7XG4gICAgICBpZiAoZm9yd2FyZCkge1xuICAgICAgICByZXR1cm4gbG9jYXRpb24uZm9sZChjb21wb3NlKE9wdGlvbmFsLnNvbWUsIExvY2F0aW9uLnN0YXJ0KSwgT3B0aW9uYWwubm9uZSwgY29tcG9zZShPcHRpb25hbC5zb21lLCBMb2NhdGlvbi5hZnRlciksIE9wdGlvbmFsLm5vbmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGxvY2F0aW9uLmZvbGQoT3B0aW9uYWwubm9uZSwgY29tcG9zZShPcHRpb25hbC5zb21lLCBMb2NhdGlvbi5iZWZvcmUpLCBPcHRpb25hbC5ub25lLCBjb21wb3NlKE9wdGlvbmFsLnNvbWUsIExvY2F0aW9uLmVuZCkpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZmluZExvY2F0aW9uJDEgPSAoZm9yd2FyZCwgaXNJbmxpbmVUYXJnZXQsIHJvb3ROb2RlLCBwb3MpID0+IHtcbiAgICAgIGNvbnN0IGZyb20gPSBub3JtYWxpemVQb3NpdGlvbihmb3J3YXJkLCBwb3MpO1xuICAgICAgY29uc3QgZnJvbUxvY2F0aW9uID0gcmVhZExvY2F0aW9uKGlzSW5saW5lVGFyZ2V0LCByb290Tm9kZSwgZnJvbSk7XG4gICAgICByZXR1cm4gcmVhZExvY2F0aW9uKGlzSW5saW5lVGFyZ2V0LCByb290Tm9kZSwgZnJvbSkuYmluZChjdXJyeShmaW5kTG9jYXRpb25TaW1wbGUsIGZvcndhcmQpKS5vclRodW5rKCgpID0+IGZpbmRMb2NhdGlvblRyYXZlcnNlKGZvcndhcmQsIGlzSW5saW5lVGFyZ2V0LCByb290Tm9kZSwgZnJvbUxvY2F0aW9uLCBwb3MpKTtcbiAgICB9O1xuXG4gICAgY29uc3QgaGFzU2VsZWN0aW9uTW9kaWZ5QXBpID0gZWRpdG9yID0+IHtcbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKGVkaXRvci5zZWxlY3Rpb24uZ2V0U2VsKCkubW9kaWZ5KTtcbiAgICB9O1xuICAgIGNvbnN0IG1vdmVSZWwgPSAoZm9yd2FyZCwgc2VsZWN0aW9uLCBwb3MpID0+IHtcbiAgICAgIGNvbnN0IGRlbHRhID0gZm9yd2FyZCA/IDEgOiAtMTtcbiAgICAgIHNlbGVjdGlvbi5zZXRSbmcoQ2FyZXRQb3NpdGlvbihwb3MuY29udGFpbmVyKCksIHBvcy5vZmZzZXQoKSArIGRlbHRhKS50b1JhbmdlKCkpO1xuICAgICAgc2VsZWN0aW9uLmdldFNlbCgpLm1vZGlmeSgnbW92ZScsIGZvcndhcmQgPyAnZm9yd2FyZCcgOiAnYmFja3dhcmQnLCAnd29yZCcpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBjb25zdCBtb3ZlQnlXb3JkID0gKGZvcndhcmQsIGVkaXRvcikgPT4ge1xuICAgICAgY29uc3Qgcm5nID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgIGNvbnN0IHBvcyA9IGZvcndhcmQgPyBDYXJldFBvc2l0aW9uLmZyb21SYW5nZUVuZChybmcpIDogQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChybmcpO1xuICAgICAgaWYgKCFoYXNTZWxlY3Rpb25Nb2RpZnlBcGkoZWRpdG9yKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGZvcndhcmQgJiYgaXNCZWZvcmVJbmxpbmUocG9zKSkge1xuICAgICAgICByZXR1cm4gbW92ZVJlbCh0cnVlLCBlZGl0b3Iuc2VsZWN0aW9uLCBwb3MpO1xuICAgICAgfSBlbHNlIGlmICghZm9yd2FyZCAmJiBpc0FmdGVySW5saW5lKHBvcykpIHtcbiAgICAgICAgcmV0dXJuIG1vdmVSZWwoZmFsc2UsIGVkaXRvci5zZWxlY3Rpb24sIHBvcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBCcmVha1R5cGU7XG4gICAgKGZ1bmN0aW9uIChCcmVha1R5cGUpIHtcbiAgICAgIEJyZWFrVHlwZVtCcmVha1R5cGVbJ0JyJ10gPSAwXSA9ICdCcic7XG4gICAgICBCcmVha1R5cGVbQnJlYWtUeXBlWydCbG9jayddID0gMV0gPSAnQmxvY2snO1xuICAgICAgQnJlYWtUeXBlW0JyZWFrVHlwZVsnV3JhcCddID0gMl0gPSAnV3JhcCc7XG4gICAgICBCcmVha1R5cGVbQnJlYWtUeXBlWydFb2wnXSA9IDNdID0gJ0VvbCc7XG4gICAgfShCcmVha1R5cGUgfHwgKEJyZWFrVHlwZSA9IHt9KSkpO1xuICAgIGNvbnN0IGZsaXAgPSAoZGlyZWN0aW9uLCBwb3NpdGlvbnMpID0+IGRpcmVjdGlvbiA9PT0gSERpcmVjdGlvbi5CYWNrd2FyZHMgPyByZXZlcnNlKHBvc2l0aW9ucykgOiBwb3NpdGlvbnM7XG4gICAgY29uc3Qgd2FsayQxID0gKGRpcmVjdGlvbiwgY2FyZXRXYWxrZXIsIHBvcykgPT4gZGlyZWN0aW9uID09PSBIRGlyZWN0aW9uLkZvcndhcmRzID8gY2FyZXRXYWxrZXIubmV4dChwb3MpIDogY2FyZXRXYWxrZXIucHJldihwb3MpO1xuICAgIGNvbnN0IGdldEJyZWFrVHlwZSA9IChzY29wZSwgZGlyZWN0aW9uLCBjdXJyZW50UG9zLCBuZXh0UG9zKSA9PiB7XG4gICAgICBpZiAoaXNCciQ2KG5leHRQb3MuZ2V0Tm9kZShkaXJlY3Rpb24gPT09IEhEaXJlY3Rpb24uRm9yd2FyZHMpKSkge1xuICAgICAgICByZXR1cm4gQnJlYWtUeXBlLkJyO1xuICAgICAgfSBlbHNlIGlmIChpc0luU2FtZUJsb2NrKGN1cnJlbnRQb3MsIG5leHRQb3MpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gQnJlYWtUeXBlLkJsb2NrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIEJyZWFrVHlwZS5XcmFwO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZ2V0UG9zaXRpb25zVW50aWwgPSAocHJlZGljYXRlLCBkaXJlY3Rpb24sIHNjb3BlLCBzdGFydCkgPT4ge1xuICAgICAgY29uc3QgY2FyZXRXYWxrZXIgPSBDYXJldFdhbGtlcihzY29wZSk7XG4gICAgICBsZXQgY3VycmVudFBvcyA9IHN0YXJ0O1xuICAgICAgY29uc3QgcG9zaXRpb25zID0gW107XG4gICAgICB3aGlsZSAoY3VycmVudFBvcykge1xuICAgICAgICBjb25zdCBuZXh0UG9zID0gd2FsayQxKGRpcmVjdGlvbiwgY2FyZXRXYWxrZXIsIGN1cnJlbnRQb3MpO1xuICAgICAgICBpZiAoIW5leHRQb3MpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNCciQ2KG5leHRQb3MuZ2V0Tm9kZShmYWxzZSkpKSB7XG4gICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gSERpcmVjdGlvbi5Gb3J3YXJkcykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgcG9zaXRpb25zOiBmbGlwKGRpcmVjdGlvbiwgcG9zaXRpb25zKS5jb25jYXQoW25leHRQb3NdKSxcbiAgICAgICAgICAgICAgYnJlYWtUeXBlOiBCcmVha1R5cGUuQnIsXG4gICAgICAgICAgICAgIGJyZWFrQXQ6IE9wdGlvbmFsLnNvbWUobmV4dFBvcylcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHBvc2l0aW9uczogZmxpcChkaXJlY3Rpb24sIHBvc2l0aW9ucyksXG4gICAgICAgICAgICAgIGJyZWFrVHlwZTogQnJlYWtUeXBlLkJyLFxuICAgICAgICAgICAgICBicmVha0F0OiBPcHRpb25hbC5zb21lKG5leHRQb3MpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5leHRQb3MuaXNWaXNpYmxlKCkpIHtcbiAgICAgICAgICBjdXJyZW50UG9zID0gbmV4dFBvcztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJlZGljYXRlKGN1cnJlbnRQb3MsIG5leHRQb3MpKSB7XG4gICAgICAgICAgY29uc3QgYnJlYWtUeXBlID0gZ2V0QnJlYWtUeXBlKHNjb3BlLCBkaXJlY3Rpb24sIGN1cnJlbnRQb3MsIG5leHRQb3MpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwb3NpdGlvbnM6IGZsaXAoZGlyZWN0aW9uLCBwb3NpdGlvbnMpLFxuICAgICAgICAgICAgYnJlYWtUeXBlLFxuICAgICAgICAgICAgYnJlYWtBdDogT3B0aW9uYWwuc29tZShuZXh0UG9zKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcG9zaXRpb25zLnB1c2gobmV4dFBvcyk7XG4gICAgICAgIGN1cnJlbnRQb3MgPSBuZXh0UG9zO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcG9zaXRpb25zOiBmbGlwKGRpcmVjdGlvbiwgcG9zaXRpb25zKSxcbiAgICAgICAgYnJlYWtUeXBlOiBCcmVha1R5cGUuRW9sLFxuICAgICAgICBicmVha0F0OiBPcHRpb25hbC5ub25lKClcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBnZXRBZGphY2VudExpbmVQb3NpdGlvbnMgPSAoZGlyZWN0aW9uLCBnZXRQb3NpdGlvbnNVbnRpbEJyZWFrLCBzY29wZSwgc3RhcnQpID0+IGdldFBvc2l0aW9uc1VudGlsQnJlYWsoc2NvcGUsIHN0YXJ0KS5icmVha0F0Lm1hcChwb3MgPT4ge1xuICAgICAgY29uc3QgcG9zaXRpb25zID0gZ2V0UG9zaXRpb25zVW50aWxCcmVhayhzY29wZSwgcG9zKS5wb3NpdGlvbnM7XG4gICAgICByZXR1cm4gZGlyZWN0aW9uID09PSBIRGlyZWN0aW9uLkJhY2t3YXJkcyA/IHBvc2l0aW9ucy5jb25jYXQocG9zKSA6IFtwb3NdLmNvbmNhdChwb3NpdGlvbnMpO1xuICAgIH0pLmdldE9yKFtdKTtcbiAgICBjb25zdCBmaW5kQ2xvc2VzdEhvcml6b250YWxQb3NpdGlvbkZyb21Qb2ludCA9IChwb3NpdGlvbnMsIHgpID0+IGZvbGRsKHBvc2l0aW9ucywgKGFjYywgbmV3UG9zKSA9PiBhY2MuZm9sZCgoKSA9PiBPcHRpb25hbC5zb21lKG5ld1BvcyksIGxhc3RQb3MgPT4gbGlmdDIoaGVhZChsYXN0UG9zLmdldENsaWVudFJlY3RzKCkpLCBoZWFkKG5ld1Bvcy5nZXRDbGllbnRSZWN0cygpKSwgKGxhc3RSZWN0LCBuZXdSZWN0KSA9PiB7XG4gICAgICBjb25zdCBsYXN0RGlzdCA9IE1hdGguYWJzKHggLSBsYXN0UmVjdC5sZWZ0KTtcbiAgICAgIGNvbnN0IG5ld0Rpc3QgPSBNYXRoLmFicyh4IC0gbmV3UmVjdC5sZWZ0KTtcbiAgICAgIHJldHVybiBuZXdEaXN0IDw9IGxhc3REaXN0ID8gbmV3UG9zIDogbGFzdFBvcztcbiAgICB9KS5vcihhY2MpKSwgT3B0aW9uYWwubm9uZSgpKTtcbiAgICBjb25zdCBmaW5kQ2xvc2VzdEhvcml6b250YWxQb3NpdGlvbiA9IChwb3NpdGlvbnMsIHBvcykgPT4gaGVhZChwb3MuZ2V0Q2xpZW50UmVjdHMoKSkuYmluZCh0YXJnZXRSZWN0ID0+IGZpbmRDbG9zZXN0SG9yaXpvbnRhbFBvc2l0aW9uRnJvbVBvaW50KHBvc2l0aW9ucywgdGFyZ2V0UmVjdC5sZWZ0KSk7XG4gICAgY29uc3QgZ2V0UG9zaXRpb25zVW50aWxQcmV2aW91c0xpbmUgPSBjdXJyeShnZXRQb3NpdGlvbnNVbnRpbCwgQ2FyZXRQb3NpdGlvbi5pc0Fib3ZlLCAtMSk7XG4gICAgY29uc3QgZ2V0UG9zaXRpb25zVW50aWxOZXh0TGluZSA9IGN1cnJ5KGdldFBvc2l0aW9uc1VudGlsLCBDYXJldFBvc2l0aW9uLmlzQmVsb3csIDEpO1xuICAgIGNvbnN0IGdldFBvc2l0aW9uc0Fib3ZlID0gY3VycnkoZ2V0QWRqYWNlbnRMaW5lUG9zaXRpb25zLCAtMSwgZ2V0UG9zaXRpb25zVW50aWxQcmV2aW91c0xpbmUpO1xuICAgIGNvbnN0IGdldFBvc2l0aW9uc0JlbG93ID0gY3VycnkoZ2V0QWRqYWNlbnRMaW5lUG9zaXRpb25zLCAxLCBnZXRQb3NpdGlvbnNVbnRpbE5leHRMaW5lKTtcbiAgICBjb25zdCBpc0F0Rmlyc3RMaW5lID0gKHNjb3BlLCBwb3MpID0+IGdldFBvc2l0aW9uc1VudGlsUHJldmlvdXNMaW5lKHNjb3BlLCBwb3MpLmJyZWFrQXQuaXNOb25lKCk7XG4gICAgY29uc3QgaXNBdExhc3RMaW5lID0gKHNjb3BlLCBwb3MpID0+IGdldFBvc2l0aW9uc1VudGlsTmV4dExpbmUoc2NvcGUsIHBvcykuYnJlYWtBdC5pc05vbmUoKTtcbiAgICBjb25zdCBnZXRGaXJzdExpbmVQb3NpdGlvbnMgPSBzY29wZSA9PiBmaXJzdFBvc2l0aW9uSW4oc2NvcGUpLm1hcChwb3MgPT4gW3Bvc10uY29uY2F0KGdldFBvc2l0aW9uc1VudGlsTmV4dExpbmUoc2NvcGUsIHBvcykucG9zaXRpb25zKSkuZ2V0T3IoW10pO1xuICAgIGNvbnN0IGdldExhc3RMaW5lUG9zaXRpb25zID0gc2NvcGUgPT4gbGFzdFBvc2l0aW9uSW4oc2NvcGUpLm1hcChwb3MgPT4gZ2V0UG9zaXRpb25zVW50aWxQcmV2aW91c0xpbmUoc2NvcGUsIHBvcykucG9zaXRpb25zLmNvbmNhdChwb3MpKS5nZXRPcihbXSk7XG4gICAgY29uc3QgZ2V0Q2xvc2VzdFBvc2l0aW9uQWJvdmUgPSAoc2NvcGUsIHBvcykgPT4gZmluZENsb3Nlc3RIb3Jpem9udGFsUG9zaXRpb24oZ2V0UG9zaXRpb25zQWJvdmUoc2NvcGUsIHBvcyksIHBvcyk7XG4gICAgY29uc3QgZ2V0Q2xvc2VzdFBvc2l0aW9uQmVsb3cgPSAoc2NvcGUsIHBvcykgPT4gZmluZENsb3Nlc3RIb3Jpem9udGFsUG9zaXRpb24oZ2V0UG9zaXRpb25zQmVsb3coc2NvcGUsIHBvcyksIHBvcyk7XG5cbiAgICBjb25zdCBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJDQgPSBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJGI7XG4gICAgY29uc3QgZGlzdGFuY2VUb1JlY3RMZWZ0JDEgPSAoY2xpZW50UmVjdCwgY2xpZW50WCkgPT4gTWF0aC5hYnMoY2xpZW50UmVjdC5sZWZ0IC0gY2xpZW50WCk7XG4gICAgY29uc3QgZGlzdGFuY2VUb1JlY3RSaWdodCQxID0gKGNsaWVudFJlY3QsIGNsaWVudFgpID0+IE1hdGguYWJzKGNsaWVudFJlY3QucmlnaHQgLSBjbGllbnRYKTtcbiAgICBjb25zdCBpc05vZGVDbGllbnRSZWN0ID0gcmVjdCA9PiBoYXNOb25OdWxsYWJsZUtleShyZWN0LCAnbm9kZScpO1xuICAgIGNvbnN0IGZpbmRDbG9zZXN0Q2xpZW50UmVjdCA9IChjbGllbnRSZWN0cywgY2xpZW50WCkgPT4gcmVkdWNlKGNsaWVudFJlY3RzLCAob2xkQ2xpZW50UmVjdCwgY2xpZW50UmVjdCkgPT4ge1xuICAgICAgY29uc3Qgb2xkRGlzdGFuY2UgPSBNYXRoLm1pbihkaXN0YW5jZVRvUmVjdExlZnQkMShvbGRDbGllbnRSZWN0LCBjbGllbnRYKSwgZGlzdGFuY2VUb1JlY3RSaWdodCQxKG9sZENsaWVudFJlY3QsIGNsaWVudFgpKTtcbiAgICAgIGNvbnN0IG5ld0Rpc3RhbmNlID0gTWF0aC5taW4oZGlzdGFuY2VUb1JlY3RMZWZ0JDEoY2xpZW50UmVjdCwgY2xpZW50WCksIGRpc3RhbmNlVG9SZWN0UmlnaHQkMShjbGllbnRSZWN0LCBjbGllbnRYKSk7XG4gICAgICBpZiAobmV3RGlzdGFuY2UgPT09IG9sZERpc3RhbmNlICYmIGlzTm9kZUNsaWVudFJlY3QoY2xpZW50UmVjdCkgJiYgaXNDb250ZW50RWRpdGFibGVGYWxzZSQ0KGNsaWVudFJlY3Qubm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGNsaWVudFJlY3Q7XG4gICAgICB9XG4gICAgICBpZiAobmV3RGlzdGFuY2UgPCBvbGREaXN0YW5jZSkge1xuICAgICAgICByZXR1cm4gY2xpZW50UmVjdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvbGRDbGllbnRSZWN0O1xuICAgIH0pO1xuXG4gICAgY29uc3QgZ2V0Tm9kZUNsaWVudFJlY3RzID0gbm9kZSA9PiB7XG4gICAgICBjb25zdCB0b0FycmF5V2l0aE5vZGUgPSBjbGllbnRSZWN0cyA9PiB7XG4gICAgICAgIHJldHVybiBtYXAkMyhjbGllbnRSZWN0cywgcmVjdCA9PiB7XG4gICAgICAgICAgY29uc3QgY2xpZW50UmVjdCA9IGNsb25lJDEocmVjdCk7XG4gICAgICAgICAgY2xpZW50UmVjdC5ub2RlID0gbm9kZTtcbiAgICAgICAgICByZXR1cm4gY2xpZW50UmVjdDtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgaWYgKGlzRWxlbWVudCQ2KG5vZGUpKSB7XG4gICAgICAgIHJldHVybiB0b0FycmF5V2l0aE5vZGUobm9kZS5nZXRDbGllbnRSZWN0cygpKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNUZXh0JGEobm9kZSkpIHtcbiAgICAgICAgY29uc3Qgcm5nID0gbm9kZS5vd25lckRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIHJuZy5zZXRTdGFydChub2RlLCAwKTtcbiAgICAgICAgcm5nLnNldEVuZChub2RlLCBub2RlLmRhdGEubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHRvQXJyYXlXaXRoTm9kZShybmcuZ2V0Q2xpZW50UmVjdHMoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBnZXRDbGllbnRSZWN0cyA9IG5vZGVzID0+IGJpbmQkMyhub2RlcywgZ2V0Tm9kZUNsaWVudFJlY3RzKTtcblxuICAgIHZhciBWRGlyZWN0aW9uO1xuICAgIChmdW5jdGlvbiAoVkRpcmVjdGlvbikge1xuICAgICAgVkRpcmVjdGlvbltWRGlyZWN0aW9uWydVcCddID0gLTFdID0gJ1VwJztcbiAgICAgIFZEaXJlY3Rpb25bVkRpcmVjdGlvblsnRG93biddID0gMV0gPSAnRG93bic7XG4gICAgfShWRGlyZWN0aW9uIHx8IChWRGlyZWN0aW9uID0ge30pKSk7XG4gICAgY29uc3QgZmluZFVudGlsID0gKGRpcmVjdGlvbiwgcm9vdCwgcHJlZGljYXRlRm4sIG5vZGUpID0+IHtcbiAgICAgIGxldCBjdXJyZW50Tm9kZSA9IG5vZGU7XG4gICAgICB3aGlsZSAoY3VycmVudE5vZGUgPSBmaW5kTm9kZShjdXJyZW50Tm9kZSwgZGlyZWN0aW9uLCBpc0VkaXRhYmxlQ2FyZXRDYW5kaWRhdGUkMSwgcm9vdCkpIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZUZuKGN1cnJlbnROb2RlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgd2Fsa1VudGlsID0gKGRpcmVjdGlvbiwgaXNBYm92ZUZuLCBpc0JlZmxvd0ZuLCByb290LCBwcmVkaWNhdGVGbiwgY2FyZXRQb3NpdGlvbikgPT4ge1xuICAgICAgbGV0IGxpbmUgPSAwO1xuICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICBjb25zdCBhZGQgPSBub2RlID0+IHtcbiAgICAgICAgbGV0IGNsaWVudFJlY3RzID0gZ2V0Q2xpZW50UmVjdHMoW25vZGVdKTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gLTEpIHtcbiAgICAgICAgICBjbGllbnRSZWN0cyA9IGNsaWVudFJlY3RzLnJldmVyc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsaWVudFJlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgY2xpZW50UmVjdCA9IGNsaWVudFJlY3RzW2ldO1xuICAgICAgICAgIGlmIChpc0JlZmxvd0ZuKGNsaWVudFJlY3QsIHRhcmdldENsaWVudFJlY3QpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwICYmIGlzQWJvdmVGbihjbGllbnRSZWN0LCBsYXN0JDIocmVzdWx0KSkpIHtcbiAgICAgICAgICAgIGxpbmUrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2xpZW50UmVjdC5saW5lID0gbGluZTtcbiAgICAgICAgICBpZiAocHJlZGljYXRlRm4oY2xpZW50UmVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaChjbGllbnRSZWN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgICAgY29uc3QgdGFyZ2V0Q2xpZW50UmVjdCA9IGxhc3QkMihjYXJldFBvc2l0aW9uLmdldENsaWVudFJlY3RzKCkpO1xuICAgICAgaWYgKCF0YXJnZXRDbGllbnRSZWN0KSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBjb25zdCBub2RlID0gY2FyZXRQb3NpdGlvbi5nZXROb2RlKCk7XG4gICAgICBpZiAobm9kZSkge1xuICAgICAgICBhZGQobm9kZSk7XG4gICAgICAgIGZpbmRVbnRpbChkaXJlY3Rpb24sIHJvb3QsIGFkZCwgbm9kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgY29uc3QgYWJvdmVMaW5lTnVtYmVyID0gKGxpbmVOdW1iZXIsIGNsaWVudFJlY3QpID0+IGNsaWVudFJlY3QubGluZSA+IGxpbmVOdW1iZXI7XG4gICAgY29uc3QgaXNMaW5lTnVtYmVyID0gKGxpbmVOdW1iZXIsIGNsaWVudFJlY3QpID0+IGNsaWVudFJlY3QubGluZSA9PT0gbGluZU51bWJlcjtcbiAgICBjb25zdCB1cFVudGlsID0gY3Vycnkod2Fsa1VudGlsLCBWRGlyZWN0aW9uLlVwLCBpc0Fib3ZlJDEsIGlzQmVsb3ckMSk7XG4gICAgY29uc3QgZG93blVudGlsID0gY3Vycnkod2Fsa1VudGlsLCBWRGlyZWN0aW9uLkRvd24sIGlzQmVsb3ckMSwgaXNBYm92ZSQxKTtcbiAgICBjb25zdCBnZXRMYXN0Q2xpZW50UmVjdCA9IGNhcmV0UG9zaXRpb24gPT4ge1xuICAgICAgcmV0dXJuIGxhc3QkMihjYXJldFBvc2l0aW9uLmdldENsaWVudFJlY3RzKCkpO1xuICAgIH07XG4gICAgY29uc3QgcG9zaXRpb25zVW50aWwgPSAoZGlyZWN0aW9uLCByb290LCBwcmVkaWNhdGVGbiwgbm9kZSkgPT4ge1xuICAgICAgY29uc3QgY2FyZXRXYWxrZXIgPSBDYXJldFdhbGtlcihyb290KTtcbiAgICAgIGxldCB3YWxrRm47XG4gICAgICBsZXQgaXNCZWxvd0ZuO1xuICAgICAgbGV0IGlzQWJvdmVGbjtcbiAgICAgIGxldCBjYXJldFBvc2l0aW9uO1xuICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICBsZXQgbGluZSA9IDA7XG4gICAgICBpZiAoZGlyZWN0aW9uID09PSAxKSB7XG4gICAgICAgIHdhbGtGbiA9IGNhcmV0V2Fsa2VyLm5leHQ7XG4gICAgICAgIGlzQmVsb3dGbiA9IGlzQmVsb3ckMTtcbiAgICAgICAgaXNBYm92ZUZuID0gaXNBYm92ZSQxO1xuICAgICAgICBjYXJldFBvc2l0aW9uID0gQ2FyZXRQb3NpdGlvbi5hZnRlcihub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhbGtGbiA9IGNhcmV0V2Fsa2VyLnByZXY7XG4gICAgICAgIGlzQmVsb3dGbiA9IGlzQWJvdmUkMTtcbiAgICAgICAgaXNBYm92ZUZuID0gaXNCZWxvdyQxO1xuICAgICAgICBjYXJldFBvc2l0aW9uID0gQ2FyZXRQb3NpdGlvbi5iZWZvcmUobm9kZSk7XG4gICAgICB9XG4gICAgICBjb25zdCB0YXJnZXRDbGllbnRSZWN0ID0gZ2V0TGFzdENsaWVudFJlY3QoY2FyZXRQb3NpdGlvbik7XG4gICAgICBkbyB7XG4gICAgICAgIGlmICghY2FyZXRQb3NpdGlvbi5pc1Zpc2libGUoKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlY3QgPSBnZXRMYXN0Q2xpZW50UmVjdChjYXJldFBvc2l0aW9uKTtcbiAgICAgICAgaWYgKGlzQWJvdmVGbihyZWN0LCB0YXJnZXRDbGllbnRSZWN0KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiBpc0JlbG93Rm4ocmVjdCwgbGFzdCQyKHJlc3VsdCkpKSB7XG4gICAgICAgICAgbGluZSsrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsaWVudFJlY3QgPSBjbG9uZSQxKHJlY3QpO1xuICAgICAgICBjbGllbnRSZWN0LnBvc2l0aW9uID0gY2FyZXRQb3NpdGlvbjtcbiAgICAgICAgY2xpZW50UmVjdC5saW5lID0gbGluZTtcbiAgICAgICAgaWYgKHByZWRpY2F0ZUZuKGNsaWVudFJlY3QpKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaChjbGllbnRSZWN0KTtcbiAgICAgIH0gd2hpbGUgKGNhcmV0UG9zaXRpb24gPSB3YWxrRm4oY2FyZXRQb3NpdGlvbikpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIGNvbnN0IGlzQWJvdmVMaW5lID0gbGluZU51bWJlciA9PiBjbGllbnRSZWN0ID0+IGFib3ZlTGluZU51bWJlcihsaW5lTnVtYmVyLCBjbGllbnRSZWN0KTtcbiAgICBjb25zdCBpc0xpbmUgPSBsaW5lTnVtYmVyID0+IGNsaWVudFJlY3QgPT4gaXNMaW5lTnVtYmVyKGxpbmVOdW1iZXIsIGNsaWVudFJlY3QpO1xuXG4gICAgY29uc3QgbW92ZVRvUmFuZ2UgPSAoZWRpdG9yLCBybmcpID0+IHtcbiAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Um5nKHJuZyk7XG4gICAgICBzY3JvbGxSYW5nZUludG9WaWV3KGVkaXRvciwgZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKSk7XG4gICAgfTtcbiAgICBjb25zdCByZW5kZXJSYW5nZUNhcmV0T3B0ID0gKGVkaXRvciwgcmFuZ2UsIHNjcm9sbEludG9WaWV3KSA9PiBPcHRpb25hbC5zb21lKHJlbmRlclJhbmdlQ2FyZXQoZWRpdG9yLCByYW5nZSwgc2Nyb2xsSW50b1ZpZXcpKTtcbiAgICBjb25zdCBtb3ZlSG9yaXpvbnRhbGx5ID0gKGVkaXRvciwgZGlyZWN0aW9uLCByYW5nZSwgaXNCZWZvcmUsIGlzQWZ0ZXIsIGlzRWxlbWVudCkgPT4ge1xuICAgICAgY29uc3QgZm9yd2FyZHMgPSBkaXJlY3Rpb24gPT09IEhEaXJlY3Rpb24uRm9yd2FyZHM7XG4gICAgICBjb25zdCBjYXJldFdhbGtlciA9IENhcmV0V2Fsa2VyKGVkaXRvci5nZXRCb2R5KCkpO1xuICAgICAgY29uc3QgZ2V0TmV4dFBvc0ZuID0gY3VycnkoZ2V0VmlzdWFsQ2FyZXRQb3NpdGlvbiwgZm9yd2FyZHMgPyBjYXJldFdhbGtlci5uZXh0IDogY2FyZXRXYWxrZXIucHJldik7XG4gICAgICBjb25zdCBpc0JlZm9yZUZuID0gZm9yd2FyZHMgPyBpc0JlZm9yZSA6IGlzQWZ0ZXI7XG4gICAgICBpZiAoIXJhbmdlLmNvbGxhcHNlZCkge1xuICAgICAgICBjb25zdCBub2RlID0gZ2V0U2VsZWN0ZWROb2RlKHJhbmdlKTtcbiAgICAgICAgaWYgKGlzRWxlbWVudChub2RlKSkge1xuICAgICAgICAgIHJldHVybiBzaG93Q2FyZXQoZGlyZWN0aW9uLCBlZGl0b3IsIG5vZGUsIGRpcmVjdGlvbiA9PT0gSERpcmVjdGlvbi5CYWNrd2FyZHMsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0NlZkF0RWRnZVNlbGVjdGVkKGVkaXRvcikpIHtcbiAgICAgICAgICBjb25zdCBuZXdSYW5nZSA9IHJhbmdlLmNsb25lUmFuZ2UoKTtcbiAgICAgICAgICBuZXdSYW5nZS5jb2xsYXBzZShkaXJlY3Rpb24gPT09IEhEaXJlY3Rpb24uQmFja3dhcmRzKTtcbiAgICAgICAgICByZXR1cm4gT3B0aW9uYWwuZnJvbShuZXdSYW5nZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGNhcmV0UG9zaXRpb24gPSBnZXROb3JtYWxpemVkUmFuZ2VFbmRQb2ludChkaXJlY3Rpb24sIGVkaXRvci5nZXRCb2R5KCksIHJhbmdlKTtcbiAgICAgIGlmIChpc0JlZm9yZUZuKGNhcmV0UG9zaXRpb24pKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3ROb2RlKGVkaXRvciwgY2FyZXRQb3NpdGlvbi5nZXROb2RlKCFmb3J3YXJkcykpO1xuICAgICAgfVxuICAgICAgbGV0IG5leHRDYXJldFBvc2l0aW9uID0gZ2V0TmV4dFBvc0ZuKGNhcmV0UG9zaXRpb24pO1xuICAgICAgY29uc3QgcmFuZ2VJc0luQ29udGFpbmVyQmxvY2sgPSBpc1JhbmdlSW5DYXJldENvbnRhaW5lckJsb2NrKHJhbmdlKTtcbiAgICAgIGlmICghbmV4dENhcmV0UG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlSXNJbkNvbnRhaW5lckJsb2NrID8gT3B0aW9uYWwuc29tZShyYW5nZSkgOiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0Q2FyZXRQb3NpdGlvbiA9IG5vcm1hbGl6ZVBvc2l0aW9uKGZvcndhcmRzLCBuZXh0Q2FyZXRQb3NpdGlvbik7XG4gICAgICB9XG4gICAgICBpZiAoaXNCZWZvcmVGbihuZXh0Q2FyZXRQb3NpdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIHNob3dDYXJldChkaXJlY3Rpb24sIGVkaXRvciwgbmV4dENhcmV0UG9zaXRpb24uZ2V0Tm9kZSghZm9yd2FyZHMpLCBmb3J3YXJkcywgZmFsc2UpO1xuICAgICAgfVxuICAgICAgY29uc3QgcGVla0NhcmV0UG9zaXRpb24gPSBnZXROZXh0UG9zRm4obmV4dENhcmV0UG9zaXRpb24pO1xuICAgICAgaWYgKHBlZWtDYXJldFBvc2l0aW9uICYmIGlzQmVmb3JlRm4ocGVla0NhcmV0UG9zaXRpb24pKSB7XG4gICAgICAgIGlmIChpc01vdmVJbnNpZGVTYW1lQmxvY2sobmV4dENhcmV0UG9zaXRpb24sIHBlZWtDYXJldFBvc2l0aW9uKSkge1xuICAgICAgICAgIHJldHVybiBzaG93Q2FyZXQoZGlyZWN0aW9uLCBlZGl0b3IsIHBlZWtDYXJldFBvc2l0aW9uLmdldE5vZGUoIWZvcndhcmRzKSwgZm9yd2FyZHMsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJhbmdlSXNJbkNvbnRhaW5lckJsb2NrKSB7XG4gICAgICAgIHJldHVybiByZW5kZXJSYW5nZUNhcmV0T3B0KGVkaXRvciwgbmV4dENhcmV0UG9zaXRpb24udG9SYW5nZSgpLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgIH07XG4gICAgY29uc3QgbW92ZVZlcnRpY2FsbHkgPSAoZWRpdG9yLCBkaXJlY3Rpb24sIHJhbmdlLCBpc0JlZm9yZSwgaXNBZnRlciwgaXNFbGVtZW50KSA9PiB7XG4gICAgICBjb25zdCBjYXJldFBvc2l0aW9uID0gZ2V0Tm9ybWFsaXplZFJhbmdlRW5kUG9pbnQoZGlyZWN0aW9uLCBlZGl0b3IuZ2V0Qm9keSgpLCByYW5nZSk7XG4gICAgICBjb25zdCBjYXJldENsaWVudFJlY3QgPSBsYXN0JDIoY2FyZXRQb3NpdGlvbi5nZXRDbGllbnRSZWN0cygpKTtcbiAgICAgIGNvbnN0IGZvcndhcmRzID0gZGlyZWN0aW9uID09PSBWRGlyZWN0aW9uLkRvd247XG4gICAgICBjb25zdCByb290ID0gZWRpdG9yLmdldEJvZHkoKTtcbiAgICAgIGlmICghY2FyZXRDbGllbnRSZWN0KSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNDZWZBdEVkZ2VTZWxlY3RlZChlZGl0b3IpKSB7XG4gICAgICAgIGNvbnN0IGNhcmV0UG9zaXRpb24gPSBmb3J3YXJkcyA/IENhcmV0UG9zaXRpb24uZnJvbVJhbmdlRW5kKHJhbmdlKSA6IENhcmV0UG9zaXRpb24uZnJvbVJhbmdlU3RhcnQocmFuZ2UpO1xuICAgICAgICBjb25zdCBnZXRDbG9zZXN0Rm4gPSAhZm9yd2FyZHMgPyBnZXRDbG9zZXN0UG9zaXRpb25BYm92ZSA6IGdldENsb3Nlc3RQb3NpdGlvbkJlbG93O1xuICAgICAgICByZXR1cm4gZ2V0Q2xvc2VzdEZuKHJvb3QsIGNhcmV0UG9zaXRpb24pLm9yVGh1bmsoKCkgPT4gT3B0aW9uYWwuZnJvbShjYXJldFBvc2l0aW9uKSkubWFwKHBvcyA9PiBwb3MudG9SYW5nZSgpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdhbGtlckZuID0gZm9yd2FyZHMgPyBkb3duVW50aWwgOiB1cFVudGlsO1xuICAgICAgY29uc3QgbGluZVBvc2l0aW9ucyA9IHdhbGtlckZuKHJvb3QsIGlzQWJvdmVMaW5lKDEpLCBjYXJldFBvc2l0aW9uKTtcbiAgICAgIGNvbnN0IG5leHRMaW5lUG9zaXRpb25zID0gZmlsdGVyJDUobGluZVBvc2l0aW9ucywgaXNMaW5lKDEpKTtcbiAgICAgIGNvbnN0IGNsaWVudFggPSBjYXJldENsaWVudFJlY3QubGVmdDtcbiAgICAgIGNvbnN0IG5leHRMaW5lUmVjdCA9IGZpbmRDbG9zZXN0Q2xpZW50UmVjdChuZXh0TGluZVBvc2l0aW9ucywgY2xpZW50WCk7XG4gICAgICBpZiAobmV4dExpbmVSZWN0ICYmIGlzRWxlbWVudChuZXh0TGluZVJlY3Qubm9kZSkpIHtcbiAgICAgICAgY29uc3QgZGlzdDEgPSBNYXRoLmFicyhjbGllbnRYIC0gbmV4dExpbmVSZWN0LmxlZnQpO1xuICAgICAgICBjb25zdCBkaXN0MiA9IE1hdGguYWJzKGNsaWVudFggLSBuZXh0TGluZVJlY3QucmlnaHQpO1xuICAgICAgICByZXR1cm4gc2hvd0NhcmV0KGRpcmVjdGlvbiwgZWRpdG9yLCBuZXh0TGluZVJlY3Qubm9kZSwgZGlzdDEgPCBkaXN0MiwgZmFsc2UpO1xuICAgICAgfVxuICAgICAgbGV0IGN1cnJlbnROb2RlO1xuICAgICAgaWYgKGlzQmVmb3JlKGNhcmV0UG9zaXRpb24pKSB7XG4gICAgICAgIGN1cnJlbnROb2RlID0gY2FyZXRQb3NpdGlvbi5nZXROb2RlKCk7XG4gICAgICB9IGVsc2UgaWYgKGlzQWZ0ZXIoY2FyZXRQb3NpdGlvbikpIHtcbiAgICAgICAgY3VycmVudE5vZGUgPSBjYXJldFBvc2l0aW9uLmdldE5vZGUodHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50Tm9kZSA9IGdldFNlbGVjdGVkTm9kZShyYW5nZSk7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudE5vZGUpIHtcbiAgICAgICAgY29uc3QgY2FyZXRQb3NpdGlvbnMgPSBwb3NpdGlvbnNVbnRpbChkaXJlY3Rpb24sIHJvb3QsIGlzQWJvdmVMaW5lKDEpLCBjdXJyZW50Tm9kZSk7XG4gICAgICAgIGxldCBjbG9zZXN0TmV4dExpbmVSZWN0ID0gZmluZENsb3Nlc3RDbGllbnRSZWN0KGZpbHRlciQ1KGNhcmV0UG9zaXRpb25zLCBpc0xpbmUoMSkpLCBjbGllbnRYKTtcbiAgICAgICAgaWYgKGNsb3Nlc3ROZXh0TGluZVJlY3QpIHtcbiAgICAgICAgICByZXR1cm4gcmVuZGVyUmFuZ2VDYXJldE9wdChlZGl0b3IsIGNsb3Nlc3ROZXh0TGluZVJlY3QucG9zaXRpb24udG9SYW5nZSgpLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2xvc2VzdE5leHRMaW5lUmVjdCA9IGxhc3QkMihmaWx0ZXIkNShjYXJldFBvc2l0aW9ucywgaXNMaW5lKDApKSk7XG4gICAgICAgIGlmIChjbG9zZXN0TmV4dExpbmVSZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlbmRlclJhbmdlQ2FyZXRPcHQoZWRpdG9yLCBjbG9zZXN0TmV4dExpbmVSZWN0LnBvc2l0aW9uLnRvUmFuZ2UoKSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobmV4dExpbmVQb3NpdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBnZXRMaW5lRW5kUG9pbnQoZWRpdG9yLCBmb3J3YXJkcykuZmlsdGVyKGZvcndhcmRzID8gaXNBZnRlciA6IGlzQmVmb3JlKS5tYXAocG9zID0+IHJlbmRlclJhbmdlQ2FyZXQoZWRpdG9yLCBwb3MudG9SYW5nZSgpLCBmYWxzZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldExpbmVFbmRQb2ludCA9IChlZGl0b3IsIGZvcndhcmQpID0+IHtcbiAgICAgIGNvbnN0IHJuZyA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICBjb25zdCBmcm9tID0gZm9yd2FyZCA/IENhcmV0UG9zaXRpb24uZnJvbVJhbmdlRW5kKHJuZykgOiBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KHJuZyk7XG4gICAgICBjb25zdCBob3N0ID0gZ2V0RWRpdGluZ0hvc3QoZnJvbS5jb250YWluZXIoKSwgZWRpdG9yLmdldEJvZHkoKSk7XG4gICAgICBpZiAoZm9yd2FyZCkge1xuICAgICAgICBjb25zdCBsaW5lSW5mbyA9IGdldFBvc2l0aW9uc1VudGlsTmV4dExpbmUoaG9zdCwgZnJvbSk7XG4gICAgICAgIHJldHVybiBsYXN0JDMobGluZUluZm8ucG9zaXRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGxpbmVJbmZvID0gZ2V0UG9zaXRpb25zVW50aWxQcmV2aW91c0xpbmUoaG9zdCwgZnJvbSk7XG4gICAgICAgIHJldHVybiBoZWFkKGxpbmVJbmZvLnBvc2l0aW9ucyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBtb3ZlVG9MaW5lRW5kUG9pbnQkMyA9IChlZGl0b3IsIGZvcndhcmQsIGlzRWxlbWVudFBvc2l0aW9uKSA9PiBnZXRMaW5lRW5kUG9pbnQoZWRpdG9yLCBmb3J3YXJkKS5maWx0ZXIoaXNFbGVtZW50UG9zaXRpb24pLmV4aXN0cyhwb3MgPT4ge1xuICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRSbmcocG9zLnRvUmFuZ2UoKSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHNldENhcmV0UG9zaXRpb24gPSAoZWRpdG9yLCBwb3MpID0+IHtcbiAgICAgIGNvbnN0IHJuZyA9IGVkaXRvci5kb20uY3JlYXRlUm5nKCk7XG4gICAgICBybmcuc2V0U3RhcnQocG9zLmNvbnRhaW5lcigpLCBwb3Mub2Zmc2V0KCkpO1xuICAgICAgcm5nLnNldEVuZChwb3MuY29udGFpbmVyKCksIHBvcy5vZmZzZXQoKSk7XG4gICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFJuZyhybmcpO1xuICAgIH07XG4gICAgY29uc3Qgc2V0U2VsZWN0ZWQgPSAoc3RhdGUsIGVsbSkgPT4ge1xuICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtbWNlLXNlbGVjdGVkJywgJ2lubGluZS1ib3VuZGFyeScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1tY2Utc2VsZWN0ZWQnKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlbmRlckNhcmV0TG9jYXRpb24gPSAoZWRpdG9yLCBjYXJldCwgbG9jYXRpb24pID0+IHJlbmRlckNhcmV0KGNhcmV0LCBsb2NhdGlvbikubWFwKHBvcyA9PiB7XG4gICAgICBzZXRDYXJldFBvc2l0aW9uKGVkaXRvciwgcG9zKTtcbiAgICAgIHJldHVybiBsb2NhdGlvbjtcbiAgICB9KTtcbiAgICBjb25zdCBnZXRQb3NpdGlvbkZyb21SYW5nZSA9IChyYW5nZSwgcm9vdCwgZm9yd2FyZCkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnQgPSBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KHJhbmdlKTtcbiAgICAgIGlmIChyYW5nZS5jb2xsYXBzZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YXJ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZW5kID0gQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VFbmQocmFuZ2UpO1xuICAgICAgICByZXR1cm4gZm9yd2FyZCA/IHByZXZQb3NpdGlvbihyb290LCBlbmQpLmdldE9yKGVuZCkgOiBuZXh0UG9zaXRpb24ocm9vdCwgc3RhcnQpLmdldE9yKHN0YXJ0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGZpbmRMb2NhdGlvbiA9IChlZGl0b3IsIGNhcmV0LCBmb3J3YXJkKSA9PiB7XG4gICAgICBjb25zdCByb290Tm9kZSA9IGVkaXRvci5nZXRCb2R5KCk7XG4gICAgICBjb25zdCBmcm9tID0gZ2V0UG9zaXRpb25Gcm9tUmFuZ2UoZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKSwgcm9vdE5vZGUsIGZvcndhcmQpO1xuICAgICAgY29uc3QgaXNJbmxpbmVUYXJnZXQkMSA9IGN1cnJ5KGlzSW5saW5lVGFyZ2V0LCBlZGl0b3IpO1xuICAgICAgY29uc3QgbG9jYXRpb24gPSBmaW5kTG9jYXRpb24kMShmb3J3YXJkLCBpc0lubGluZVRhcmdldCQxLCByb290Tm9kZSwgZnJvbSk7XG4gICAgICByZXR1cm4gbG9jYXRpb24uYmluZChsb2NhdGlvbiA9PiByZW5kZXJDYXJldExvY2F0aW9uKGVkaXRvciwgY2FyZXQsIGxvY2F0aW9uKSk7XG4gICAgfTtcbiAgICBjb25zdCB0b2dnbGVJbmxpbmVzID0gKGlzSW5saW5lVGFyZ2V0LCBkb20sIGVsbXMpID0+IHtcbiAgICAgIGNvbnN0IGlubGluZUJvdW5kYXJpZXMgPSBtYXAkMyhkZXNjZW5kYW50cyhTdWdhckVsZW1lbnQuZnJvbURvbShkb20uZ2V0Um9vdCgpKSwgJypbZGF0YS1tY2Utc2VsZWN0ZWQ9XCJpbmxpbmUtYm91bmRhcnlcIl0nKSwgZSA9PiBlLmRvbSk7XG4gICAgICBjb25zdCBzZWxlY3RlZElubGluZXMgPSBmaWx0ZXIkNShpbmxpbmVCb3VuZGFyaWVzLCBpc0lubGluZVRhcmdldCk7XG4gICAgICBjb25zdCB0YXJnZXRJbmxpbmVzID0gZmlsdGVyJDUoZWxtcywgaXNJbmxpbmVUYXJnZXQpO1xuICAgICAgZWFjaCRlKGRpZmZlcmVuY2Uoc2VsZWN0ZWRJbmxpbmVzLCB0YXJnZXRJbmxpbmVzKSwgY3Vycnkoc2V0U2VsZWN0ZWQsIGZhbHNlKSk7XG4gICAgICBlYWNoJGUoZGlmZmVyZW5jZSh0YXJnZXRJbmxpbmVzLCBzZWxlY3RlZElubGluZXMpLCBjdXJyeShzZXRTZWxlY3RlZCwgdHJ1ZSkpO1xuICAgIH07XG4gICAgY29uc3Qgc2FmZVJlbW92ZUNhcmV0Q29udGFpbmVyID0gKGVkaXRvciwgY2FyZXQpID0+IHtcbiAgICAgIGNvbnN0IGNhcmV0VmFsdWUgPSBjYXJldC5nZXQoKTtcbiAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgJiYgIWVkaXRvci5jb21wb3NpbmcgJiYgY2FyZXRWYWx1ZSkge1xuICAgICAgICBjb25zdCBwb3MgPSBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCkpO1xuICAgICAgICBpZiAoQ2FyZXRQb3NpdGlvbi5pc1RleHRQb3NpdGlvbihwb3MpICYmICFpc0F0WndzcChwb3MpKSB7XG4gICAgICAgICAgc2V0Q2FyZXRQb3NpdGlvbihlZGl0b3IsIHJlbW92ZUFuZFJlcG9zaXRpb24oY2FyZXRWYWx1ZSwgcG9zKSk7XG4gICAgICAgICAgY2FyZXQuc2V0KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZW5kZXJJbnNpZGVJbmxpbmVDYXJldCA9IChpc0lubGluZVRhcmdldCwgZWRpdG9yLCBjYXJldCwgZWxtcykgPT4ge1xuICAgICAgaWYgKGVkaXRvci5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgICBjb25zdCBpbmxpbmVzID0gZmlsdGVyJDUoZWxtcywgaXNJbmxpbmVUYXJnZXQpO1xuICAgICAgICBlYWNoJGUoaW5saW5lcywgX2lubGluZSA9PiB7XG4gICAgICAgICAgY29uc3QgcG9zID0gQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpKTtcbiAgICAgICAgICByZWFkTG9jYXRpb24oaXNJbmxpbmVUYXJnZXQsIGVkaXRvci5nZXRCb2R5KCksIHBvcykuYmluZChsb2NhdGlvbiA9PiByZW5kZXJDYXJldExvY2F0aW9uKGVkaXRvciwgY2FyZXQsIGxvY2F0aW9uKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbW92ZSQyID0gKGVkaXRvciwgY2FyZXQsIGZvcndhcmQpID0+IGlzSW5saW5lQm91bmRhcmllc0VuYWJsZWQoZWRpdG9yKSA/IGZpbmRMb2NhdGlvbihlZGl0b3IsIGNhcmV0LCBmb3J3YXJkKS5pc1NvbWUoKSA6IGZhbHNlO1xuICAgIGNvbnN0IG1vdmVXb3JkID0gKGZvcndhcmQsIGVkaXRvciwgX2NhcmV0KSA9PiBpc0lubGluZUJvdW5kYXJpZXNFbmFibGVkKGVkaXRvcikgPyBtb3ZlQnlXb3JkKGZvcndhcmQsIGVkaXRvcikgOiBmYWxzZTtcbiAgICBjb25zdCBzZXR1cFNlbGVjdGVkU3RhdGUgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgY2FyZXQgPSBDZWxsKG51bGwpO1xuICAgICAgY29uc3QgaXNJbmxpbmVUYXJnZXQkMSA9IGN1cnJ5KGlzSW5saW5lVGFyZ2V0LCBlZGl0b3IpO1xuICAgICAgZWRpdG9yLm9uKCdOb2RlQ2hhbmdlJywgZSA9PiB7XG4gICAgICAgIGlmIChpc0lubGluZUJvdW5kYXJpZXNFbmFibGVkKGVkaXRvcikpIHtcbiAgICAgICAgICB0b2dnbGVJbmxpbmVzKGlzSW5saW5lVGFyZ2V0JDEsIGVkaXRvci5kb20sIGUucGFyZW50cyk7XG4gICAgICAgICAgc2FmZVJlbW92ZUNhcmV0Q29udGFpbmVyKGVkaXRvciwgY2FyZXQpO1xuICAgICAgICAgIHJlbmRlckluc2lkZUlubGluZUNhcmV0KGlzSW5saW5lVGFyZ2V0JDEsIGVkaXRvciwgY2FyZXQsIGUucGFyZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNhcmV0O1xuICAgIH07XG4gICAgY29uc3QgbW92ZU5leHRXb3JkID0gY3VycnkobW92ZVdvcmQsIHRydWUpO1xuICAgIGNvbnN0IG1vdmVQcmV2V29yZCA9IGN1cnJ5KG1vdmVXb3JkLCBmYWxzZSk7XG4gICAgY29uc3QgbW92ZVRvTGluZUVuZFBvaW50JDIgPSAoZWRpdG9yLCBmb3J3YXJkLCBjYXJldCkgPT4ge1xuICAgICAgaWYgKGlzSW5saW5lQm91bmRhcmllc0VuYWJsZWQoZWRpdG9yKSkge1xuICAgICAgICBjb25zdCBsaW5lUG9pbnQgPSBnZXRMaW5lRW5kUG9pbnQoZWRpdG9yLCBmb3J3YXJkKS5nZXRPclRodW5rKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBybmcgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgICAgIHJldHVybiBmb3J3YXJkID8gQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VFbmQocm5nKSA6IENhcmV0UG9zaXRpb24uZnJvbVJhbmdlU3RhcnQocm5nKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZWFkTG9jYXRpb24oY3VycnkoaXNJbmxpbmVUYXJnZXQsIGVkaXRvciksIGVkaXRvci5nZXRCb2R5KCksIGxpbmVQb2ludCkuZXhpc3RzKGxvYyA9PiB7XG4gICAgICAgICAgY29uc3Qgb3V0c2lkZUxvYyA9IG91dHNpZGUobG9jKTtcbiAgICAgICAgICByZXR1cm4gcmVuZGVyQ2FyZXQoY2FyZXQsIG91dHNpZGVMb2MpLmV4aXN0cyhwb3MgPT4ge1xuICAgICAgICAgICAgc2V0Q2FyZXRQb3NpdGlvbihlZGl0b3IsIHBvcyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHJhbmdlRnJvbVBvc2l0aW9ucyA9IChmcm9tLCB0bykgPT4ge1xuICAgICAgY29uc3QgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgcmFuZ2Uuc2V0U3RhcnQoZnJvbS5jb250YWluZXIoKSwgZnJvbS5vZmZzZXQoKSk7XG4gICAgICByYW5nZS5zZXRFbmQodG8uY29udGFpbmVyKCksIHRvLm9mZnNldCgpKTtcbiAgICAgIHJldHVybiByYW5nZTtcbiAgICB9O1xuICAgIGNvbnN0IGhhc09ubHlUd29Pckxlc3NQb3NpdGlvbnNMZWZ0ID0gZWxtID0+IGxpZnQyKGZpcnN0UG9zaXRpb25JbihlbG0pLCBsYXN0UG9zaXRpb25JbihlbG0pLCAoZmlyc3RQb3MsIGxhc3RQb3MpID0+IHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRGaXJzdFBvcyA9IG5vcm1hbGl6ZVBvc2l0aW9uKHRydWUsIGZpcnN0UG9zKTtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRMYXN0UG9zID0gbm9ybWFsaXplUG9zaXRpb24oZmFsc2UsIGxhc3RQb3MpO1xuICAgICAgcmV0dXJuIG5leHRQb3NpdGlvbihlbG0sIG5vcm1hbGl6ZWRGaXJzdFBvcykuZm9yYWxsKHBvcyA9PiBwb3MuaXNFcXVhbChub3JtYWxpemVkTGFzdFBvcykpO1xuICAgIH0pLmdldE9yKHRydWUpO1xuICAgIGNvbnN0IHNldENhcmV0TG9jYXRpb24gPSAoZWRpdG9yLCBjYXJldCkgPT4gbG9jYXRpb24gPT4gcmVuZGVyQ2FyZXQoY2FyZXQsIGxvY2F0aW9uKS5tYXAocG9zID0+ICgpID0+IHNldENhcmV0UG9zaXRpb24oZWRpdG9yLCBwb3MpKTtcbiAgICBjb25zdCBkZWxldGVGcm9tVG8gPSAoZWRpdG9yLCBjYXJldCwgZnJvbSwgdG8pID0+IHtcbiAgICAgIGNvbnN0IHJvb3ROb2RlID0gZWRpdG9yLmdldEJvZHkoKTtcbiAgICAgIGNvbnN0IGlzSW5saW5lVGFyZ2V0JDEgPSBjdXJyeShpc0lubGluZVRhcmdldCwgZWRpdG9yKTtcbiAgICAgIGVkaXRvci51bmRvTWFuYWdlci5pZ25vcmUoKCkgPT4ge1xuICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFJuZyhyYW5nZUZyb21Qb3NpdGlvbnMoZnJvbSwgdG8pKTtcbiAgICAgICAgZXhlY05hdGl2ZURlbGV0ZUNvbW1hbmQoZWRpdG9yKTtcbiAgICAgICAgcmVhZExvY2F0aW9uKGlzSW5saW5lVGFyZ2V0JDEsIHJvb3ROb2RlLCBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCkpKS5tYXAoaW5zaWRlKS5iaW5kKHNldENhcmV0TG9jYXRpb24oZWRpdG9yLCBjYXJldCkpLmVhY2goY2FsbCk7XG4gICAgICB9KTtcbiAgICAgIGVkaXRvci5ub2RlQ2hhbmdlZCgpO1xuICAgIH07XG4gICAgY29uc3QgcmVzY29wZSA9IChyb290Tm9kZSwgbm9kZSkgPT4ge1xuICAgICAgY29uc3QgcGFyZW50QmxvY2sgPSBnZXRQYXJlbnRCbG9jayQzKG5vZGUsIHJvb3ROb2RlKTtcbiAgICAgIHJldHVybiBwYXJlbnRCbG9jayA/IHBhcmVudEJsb2NrIDogcm9vdE5vZGU7XG4gICAgfTtcbiAgICBjb25zdCBiYWNrc3BhY2VEZWxldGVDb2xsYXBzZWQgPSAoZWRpdG9yLCBjYXJldCwgZm9yd2FyZCwgZnJvbSkgPT4ge1xuICAgICAgY29uc3Qgcm9vdE5vZGUgPSByZXNjb3BlKGVkaXRvci5nZXRCb2R5KCksIGZyb20uY29udGFpbmVyKCkpO1xuICAgICAgY29uc3QgaXNJbmxpbmVUYXJnZXQkMSA9IGN1cnJ5KGlzSW5saW5lVGFyZ2V0LCBlZGl0b3IpO1xuICAgICAgY29uc3QgZnJvbUxvY2F0aW9uID0gcmVhZExvY2F0aW9uKGlzSW5saW5lVGFyZ2V0JDEsIHJvb3ROb2RlLCBmcm9tKTtcbiAgICAgIGNvbnN0IGxvY2F0aW9uID0gZnJvbUxvY2F0aW9uLmJpbmQobG9jYXRpb24gPT4ge1xuICAgICAgICBpZiAoZm9yd2FyZCkge1xuICAgICAgICAgIHJldHVybiBsb2NhdGlvbi5mb2xkKGNvbnN0YW50KE9wdGlvbmFsLnNvbWUoaW5zaWRlKGxvY2F0aW9uKSkpLCBPcHRpb25hbC5ub25lLCBjb25zdGFudChPcHRpb25hbC5zb21lKG91dHNpZGUobG9jYXRpb24pKSksIE9wdGlvbmFsLm5vbmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBsb2NhdGlvbi5mb2xkKE9wdGlvbmFsLm5vbmUsIGNvbnN0YW50KE9wdGlvbmFsLnNvbWUob3V0c2lkZShsb2NhdGlvbikpKSwgT3B0aW9uYWwubm9uZSwgY29uc3RhbnQoT3B0aW9uYWwuc29tZShpbnNpZGUobG9jYXRpb24pKSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBsb2NhdGlvbi5tYXAoc2V0Q2FyZXRMb2NhdGlvbihlZGl0b3IsIGNhcmV0KSkuZ2V0T3JUaHVuaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRvUG9zaXRpb24gPSBuYXZpZ2F0ZShmb3J3YXJkLCByb290Tm9kZSwgZnJvbSk7XG4gICAgICAgIGNvbnN0IHRvTG9jYXRpb24gPSB0b1Bvc2l0aW9uLmJpbmQocG9zID0+IHJlYWRMb2NhdGlvbihpc0lubGluZVRhcmdldCQxLCByb290Tm9kZSwgcG9zKSk7XG4gICAgICAgIHJldHVybiBsaWZ0Mihmcm9tTG9jYXRpb24sIHRvTG9jYXRpb24sICgpID0+IGZpbmRSb290SW5saW5lKGlzSW5saW5lVGFyZ2V0JDEsIHJvb3ROb2RlLCBmcm9tKS5iaW5kKGVsbSA9PiB7XG4gICAgICAgICAgaWYgKGhhc09ubHlUd29Pckxlc3NQb3NpdGlvbnNMZWZ0KGVsbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKCgpID0+IHtcbiAgICAgICAgICAgICAgZGVsZXRlRWxlbWVudCQyKGVkaXRvciwgZm9yd2FyZCwgU3VnYXJFbGVtZW50LmZyb21Eb20oZWxtKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKS5nZXRPclRodW5rKCgpID0+IHRvTG9jYXRpb24uYmluZCgoKSA9PiB0b1Bvc2l0aW9uLm1hcCh0byA9PiB7XG4gICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGlmIChmb3J3YXJkKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZUZyb21UbyhlZGl0b3IsIGNhcmV0LCBmcm9tLCB0byk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkZWxldGVGcm9tVG8oZWRpdG9yLCBjYXJldCwgdG8sIGZyb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0pKSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGJhY2tzcGFjZURlbGV0ZSQzID0gKGVkaXRvciwgY2FyZXQsIGZvcndhcmQpID0+IHtcbiAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgJiYgaXNJbmxpbmVCb3VuZGFyaWVzRW5hYmxlZChlZGl0b3IpKSB7XG4gICAgICAgIGNvbnN0IGZyb20gPSBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCkpO1xuICAgICAgICByZXR1cm4gYmFja3NwYWNlRGVsZXRlQ29sbGFwc2VkKGVkaXRvciwgY2FyZXQsIGZvcndhcmQsIGZyb20pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgaGFzTXVsdGlwbGVDaGlsZHJlbiA9IGVsbSA9PiBjaGlsZE5vZGVzQ291bnQoZWxtKSA+IDE7XG4gICAgY29uc3QgZ2V0UGFyZW50c1VudGlsID0gKGVkaXRvciwgcHJlZCkgPT4ge1xuICAgICAgY29uc3Qgcm9vdEVsbSA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRCb2R5KCkpO1xuICAgICAgY29uc3Qgc3RhcnRFbG0gPSBTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3Iuc2VsZWN0aW9uLmdldFN0YXJ0KCkpO1xuICAgICAgY29uc3QgcGFyZW50cyA9IHBhcmVudHNBbmRTZWxmKHN0YXJ0RWxtLCByb290RWxtKTtcbiAgICAgIHJldHVybiBmaW5kSW5kZXgkMihwYXJlbnRzLCBwcmVkKS5mb2xkKGNvbnN0YW50KHBhcmVudHMpLCBpbmRleCA9PiBwYXJlbnRzLnNsaWNlKDAsIGluZGV4KSk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRQYXJlbnRJbmxpbmVzVW50aWxNdWx0aWNoaWxkSW5saW5lID0gZWRpdG9yID0+IGdldFBhcmVudHNVbnRpbChlZGl0b3IsIGVsbSA9PiBpc0Jsb2NrJDIoZWxtKSB8fCBoYXNNdWx0aXBsZUNoaWxkcmVuKGVsbSkpO1xuICAgIGNvbnN0IGdldFBhcmVudElubGluZXMgPSBlZGl0b3IgPT4gZ2V0UGFyZW50c1VudGlsKGVkaXRvciwgaXNCbG9jayQyKTtcbiAgICBjb25zdCBnZXRGb3JtYXROb2RlcyA9IChlZGl0b3IsIHBhcmVudElubGluZXMpID0+IHtcbiAgICAgIGNvbnN0IGlzRm9ybWF0RWxlbWVudCQxID0gY3VycnkoaXNGb3JtYXRFbGVtZW50LCBlZGl0b3IpO1xuICAgICAgcmV0dXJuIGJpbmQkMyhwYXJlbnRJbmxpbmVzLCBlbG0gPT4gaXNGb3JtYXRFbGVtZW50JDEoZWxtKSA/IFtlbG0uZG9tXSA6IFtdKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldEZvcm1hdE5vZGVzQXRTdGFydCA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBwYXJlbnRJbmxpbmVzID0gZ2V0UGFyZW50SW5saW5lcyhlZGl0b3IpO1xuICAgICAgcmV0dXJuIGdldEZvcm1hdE5vZGVzKGVkaXRvciwgcGFyZW50SW5saW5lcyk7XG4gICAgfTtcbiAgICBjb25zdCBkZWxldGVMYXN0UG9zaXRpb24gPSAoZm9yd2FyZCwgZWRpdG9yLCB0YXJnZXQsIHBhcmVudElubGluZXMpID0+IHtcbiAgICAgIGNvbnN0IGZvcm1hdE5vZGVzID0gZ2V0Rm9ybWF0Tm9kZXMoZWRpdG9yLCBwYXJlbnRJbmxpbmVzKTtcbiAgICAgIGlmIChmb3JtYXROb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZGVsZXRlRWxlbWVudCQyKGVkaXRvciwgZm9yd2FyZCwgdGFyZ2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHBvcyA9IHJlcGxhY2VXaXRoQ2FyZXRGb3JtYXQodGFyZ2V0LmRvbSwgZm9ybWF0Tm9kZXMpO1xuICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFJuZyhwb3MudG9SYW5nZSgpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGRlbGV0ZUNhcmV0JDEgPSAoZWRpdG9yLCBmb3J3YXJkKSA9PiB7XG4gICAgICBjb25zdCBwYXJlbnRJbmxpbmVzID0gZ2V0UGFyZW50SW5saW5lc1VudGlsTXVsdGljaGlsZElubGluZShlZGl0b3IpO1xuICAgICAgcmV0dXJuIGxhc3QkMyhwYXJlbnRJbmxpbmVzKS5iaW5kKHRhcmdldCA9PiB7XG4gICAgICAgIGNvbnN0IGZyb21Qb3MgPSBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCkpO1xuICAgICAgICBpZiAod2lsbERlbGV0ZUxhc3RQb3NpdGlvbkluRWxlbWVudChmb3J3YXJkLCBmcm9tUG9zLCB0YXJnZXQuZG9tKSAmJiAhaXNFbXB0eUNhcmV0Rm9ybWF0RWxlbWVudCh0YXJnZXQpKSB7XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoKCkgPT4gZGVsZXRlTGFzdFBvc2l0aW9uKGZvcndhcmQsIGVkaXRvciwgdGFyZ2V0LCBwYXJlbnRJbmxpbmVzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBpc0JySW5FbXB0eUVsZW1lbnQgPSAoZWRpdG9yLCBlbG0pID0+IHtcbiAgICAgIGNvbnN0IHBhcmVudEVsbSA9IGVsbS5wYXJlbnRFbGVtZW50O1xuICAgICAgcmV0dXJuIGlzQnIkNihlbG0pICYmICFpc051bGwocGFyZW50RWxtKSAmJiBlZGl0b3IuZG9tLmlzRW1wdHkocGFyZW50RWxtKTtcbiAgICB9O1xuICAgIGNvbnN0IGlzRW1wdHlDYXJldCA9IGVsbSA9PiBpc0VtcHR5Q2FyZXRGb3JtYXRFbGVtZW50KFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVsbSkpO1xuICAgIGNvbnN0IGNyZWF0ZUNhcmV0Rm9ybWF0QXRTdGFydCA9IChlZGl0b3IsIGZvcm1hdE5vZGVzKSA9PiB7XG4gICAgICBjb25zdCBzdGFydEVsbSA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0U3RhcnQoKTtcbiAgICAgIGNvbnN0IHBvcyA9IGlzQnJJbkVtcHR5RWxlbWVudChlZGl0b3IsIHN0YXJ0RWxtKSB8fCBpc0VtcHR5Q2FyZXQoc3RhcnRFbG0pID8gcmVwbGFjZVdpdGhDYXJldEZvcm1hdChzdGFydEVsbSwgZm9ybWF0Tm9kZXMpIDogY3JlYXRlQ2FyZXRGb3JtYXRBdFN0YXJ0JDEoZWRpdG9yLCBmb3JtYXROb2Rlcyk7XG4gICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFJuZyhwb3MudG9SYW5nZSgpKTtcbiAgICB9O1xuICAgIGNvbnN0IHVwZGF0ZUNhcmV0Rm9ybWF0ID0gKGVkaXRvciwgdXBkYXRlRm9ybWF0cykgPT4ge1xuICAgICAgY29uc3QgbWlzc2luZ0Zvcm1hdHMgPSBkaWZmZXJlbmNlKHVwZGF0ZUZvcm1hdHMsIGdldEZvcm1hdE5vZGVzQXRTdGFydChlZGl0b3IpKTtcbiAgICAgIGlmIChtaXNzaW5nRm9ybWF0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNyZWF0ZUNhcmV0Rm9ybWF0QXRTdGFydChlZGl0b3IsIG1pc3NpbmdGb3JtYXRzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJhbmdlU3RhcnRzQXRUZXh0Q29udGFpbmVyID0gcm5nID0+IGlzVGV4dCRhKHJuZy5zdGFydENvbnRhaW5lcik7XG4gICAgY29uc3QgcmFuZ2VTdGFydHNBdFN0YXJ0T2ZUZXh0Q29udGFpbmVyID0gcm5nID0+IHJuZy5zdGFydE9mZnNldCA9PT0gMCAmJiByYW5nZVN0YXJ0c0F0VGV4dENvbnRhaW5lcihybmcpO1xuICAgIGNvbnN0IHJhbmdlU3RhcnRQYXJlbnRJc0Zvcm1hdEVsZW1lbnQgPSAoZWRpdG9yLCBybmcpID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0UGFyZW50ID0gcm5nLnN0YXJ0Q29udGFpbmVyLnBhcmVudEVsZW1lbnQ7XG4gICAgICByZXR1cm4gIWlzTnVsbChzdGFydFBhcmVudCkgJiYgaXNGb3JtYXRFbGVtZW50KGVkaXRvciwgU3VnYXJFbGVtZW50LmZyb21Eb20oc3RhcnRQYXJlbnQpKTtcbiAgICB9O1xuICAgIGNvbnN0IHJhbmdlU3RhcnRBbmRFbmRIYXZlU2FtZVBhcmVudCA9IHJuZyA9PiB7XG4gICAgICBjb25zdCBzdGFydFBhcmVudCA9IHJuZy5zdGFydENvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgICAgY29uc3QgZW5kUGFyZW50ID0gcm5nLmVuZENvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgICAgcmV0dXJuICFpc051bGwoc3RhcnRQYXJlbnQpICYmICFpc051bGwoZW5kUGFyZW50KSAmJiBzdGFydFBhcmVudC5pc0VxdWFsTm9kZShlbmRQYXJlbnQpO1xuICAgIH07XG4gICAgY29uc3QgcmFuZ2VFbmRzQXRFbmRPZkVuZENvbnRhaW5lciA9IHJuZyA9PiB7XG4gICAgICBjb25zdCBlbmRDb250YWluZXIgPSBybmcuZW5kQ29udGFpbmVyO1xuICAgICAgcmV0dXJuIHJuZy5lbmRPZmZzZXQgPT09IChpc1RleHQkYShlbmRDb250YWluZXIpID8gZW5kQ29udGFpbmVyLmxlbmd0aCA6IGVuZENvbnRhaW5lci5jaGlsZE5vZGVzLmxlbmd0aCk7XG4gICAgfTtcbiAgICBjb25zdCByYW5nZUVuZHNBdEVuZE9mU3RhcnRDb250YWluZXIgPSBybmcgPT4gcmFuZ2VTdGFydEFuZEVuZEhhdmVTYW1lUGFyZW50KHJuZykgJiYgcmFuZ2VFbmRzQXRFbmRPZkVuZENvbnRhaW5lcihybmcpO1xuICAgIGNvbnN0IHJhbmdlRW5kc0FmdGVyRW5kT2ZTdGFydENvbnRhaW5lciA9IHJuZyA9PiAhcm5nLmVuZENvbnRhaW5lci5pc0VxdWFsTm9kZShybmcuY29tbW9uQW5jZXN0b3JDb250YWluZXIpO1xuICAgIGNvbnN0IHJhbmdlRW5kc0F0T3JBZnRlckVuZE9mU3RhcnRDb250YWluZXIgPSBybmcgPT4gcmFuZ2VFbmRzQXRFbmRPZlN0YXJ0Q29udGFpbmVyKHJuZykgfHwgcmFuZ2VFbmRzQWZ0ZXJFbmRPZlN0YXJ0Q29udGFpbmVyKHJuZyk7XG4gICAgY29uc3QgcmVxdWlyZXNEZWxldGVSYW5nZU92ZXJyaWRlID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IHJuZyA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICByZXR1cm4gcmFuZ2VTdGFydHNBdFN0YXJ0T2ZUZXh0Q29udGFpbmVyKHJuZykgJiYgcmFuZ2VTdGFydFBhcmVudElzRm9ybWF0RWxlbWVudChlZGl0b3IsIHJuZykgJiYgcmFuZ2VFbmRzQXRPckFmdGVyRW5kT2ZTdGFydENvbnRhaW5lcihybmcpO1xuICAgIH07XG4gICAgY29uc3QgZGVsZXRlUmFuZ2UkMSA9IGVkaXRvciA9PiB7XG4gICAgICBpZiAocmVxdWlyZXNEZWxldGVSYW5nZU92ZXJyaWRlKGVkaXRvcikpIHtcbiAgICAgICAgY29uc3QgZm9ybWF0Tm9kZXMgPSBnZXRGb3JtYXROb2Rlc0F0U3RhcnQoZWRpdG9yKTtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoKCkgPT4ge1xuICAgICAgICAgIGV4ZWNOYXRpdmVEZWxldGVDb21tYW5kKGVkaXRvcik7XG4gICAgICAgICAgdXBkYXRlQ2FyZXRGb3JtYXQoZWRpdG9yLCBmb3JtYXROb2Rlcyk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGJhY2tzcGFjZURlbGV0ZSQyID0gKGVkaXRvciwgZm9yd2FyZCkgPT4gZWRpdG9yLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpID8gZGVsZXRlQ2FyZXQkMShlZGl0b3IsIGZvcndhcmQpIDogZGVsZXRlUmFuZ2UkMShlZGl0b3IpO1xuICAgIGNvbnN0IGhhc0FuY2VzdG9ySW5saW5lQ2FyZXQgPSBlbG0gPT4gYW5jZXN0b3IkMShlbG0sIG5vZGUgPT4gaXNDYXJldE5vZGUobm9kZS5kb20pLCBpc0Jsb2NrJDIpO1xuICAgIGNvbnN0IGhhc0FuY2VzdG9ySW5saW5lQ2FyZXRBdFN0YXJ0ID0gZWRpdG9yID0+IGhhc0FuY2VzdG9ySW5saW5lQ2FyZXQoU3VnYXJFbGVtZW50LmZyb21Eb20oZWRpdG9yLnNlbGVjdGlvbi5nZXRTdGFydCgpKSk7XG4gICAgY29uc3QgcmVxdWlyZXNSZWZyZXNoQ2FyZXRPdmVycmlkZSA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBybmcgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgcmV0dXJuIHJuZy5jb2xsYXBzZWQgJiYgKHJhbmdlU3RhcnRzQXRUZXh0Q29udGFpbmVyKHJuZykgfHwgZWRpdG9yLmRvbS5pc0VtcHR5KHJuZy5zdGFydENvbnRhaW5lcikpICYmICFoYXNBbmNlc3RvcklubGluZUNhcmV0QXRTdGFydChlZGl0b3IpO1xuICAgIH07XG4gICAgY29uc3QgcmVmcmVzaENhcmV0ID0gZWRpdG9yID0+IHtcbiAgICAgIGlmIChyZXF1aXJlc1JlZnJlc2hDYXJldE92ZXJyaWRlKGVkaXRvcikpIHtcbiAgICAgICAgY3JlYXRlQ2FyZXRGb3JtYXRBdFN0YXJ0KGVkaXRvciwgW10pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIGNvbnN0IGRlbGV0ZUVsZW1lbnQgPSAoZWRpdG9yLCBmb3J3YXJkLCBlbGVtZW50KSA9PiB7XG4gICAgICBpZiAoaXNOb25OdWxsYWJsZShlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZSgoKSA9PiB7XG4gICAgICAgICAgZWRpdG9yLl9zZWxlY3Rpb25PdmVycmlkZXMuaGlkZUZha2VDYXJldCgpO1xuICAgICAgICAgIGRlbGV0ZUVsZW1lbnQkMihlZGl0b3IsIGZvcndhcmQsIFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVsZW1lbnQpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZGVsZXRlQ2FyZXQgPSAoZWRpdG9yLCBmb3J3YXJkKSA9PiB7XG4gICAgICBjb25zdCBpc05lYXJNZWRpYSA9IGZvcndhcmQgPyBpc0JlZm9yZU1lZGlhIDogaXNBZnRlck1lZGlhO1xuICAgICAgY29uc3QgZGlyZWN0aW9uID0gZm9yd2FyZCA/IEhEaXJlY3Rpb24uRm9yd2FyZHMgOiBIRGlyZWN0aW9uLkJhY2t3YXJkcztcbiAgICAgIGNvbnN0IGZyb21Qb3MgPSBnZXROb3JtYWxpemVkUmFuZ2VFbmRQb2ludChkaXJlY3Rpb24sIGVkaXRvci5nZXRCb2R5KCksIGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCkpO1xuICAgICAgaWYgKGlzTmVhck1lZGlhKGZyb21Qb3MpKSB7XG4gICAgICAgIHJldHVybiBkZWxldGVFbGVtZW50KGVkaXRvciwgZm9yd2FyZCwgZnJvbVBvcy5nZXROb2RlKCFmb3J3YXJkKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuZnJvbShub3JtYWxpemVQb3NpdGlvbihmb3J3YXJkLCBmcm9tUG9zKSkuZmlsdGVyKHBvcyA9PiBpc05lYXJNZWRpYShwb3MpICYmIGlzTW92ZUluc2lkZVNhbWVCbG9jayhmcm9tUG9zLCBwb3MpKS5iaW5kKHBvcyA9PiBkZWxldGVFbGVtZW50KGVkaXRvciwgZm9yd2FyZCwgcG9zLmdldE5vZGUoIWZvcndhcmQpKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBkZWxldGVSYW5nZSA9IChlZGl0b3IsIGZvcndhcmQpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkTm9kZSA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Tm9kZSgpO1xuICAgICAgcmV0dXJuIGlzTWVkaWEkMihzZWxlY3RlZE5vZGUpID8gZGVsZXRlRWxlbWVudChlZGl0b3IsIGZvcndhcmQsIHNlbGVjdGVkTm9kZSkgOiBPcHRpb25hbC5ub25lKCk7XG4gICAgfTtcbiAgICBjb25zdCBiYWNrc3BhY2VEZWxldGUkMSA9IChlZGl0b3IsIGZvcndhcmQpID0+IGVkaXRvci5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSA/IGRlbGV0ZUNhcmV0KGVkaXRvciwgZm9yd2FyZCkgOiBkZWxldGVSYW5nZShlZGl0b3IsIGZvcndhcmQpO1xuXG4gICAgY29uc3QgaXNFZGl0YWJsZSA9IHRhcmdldCA9PiBjbG9zZXN0JDQodGFyZ2V0LCBlbG0gPT4gaXNDb250ZW50RWRpdGFibGVUcnVlJDMoZWxtLmRvbSkgfHwgaXNDb250ZW50RWRpdGFibGVGYWxzZSRiKGVsbS5kb20pKS5leGlzdHMoZWxtID0+IGlzQ29udGVudEVkaXRhYmxlVHJ1ZSQzKGVsbS5kb20pKTtcbiAgICBjb25zdCBwYXJzZUluZGVudFZhbHVlID0gdmFsdWUgPT4gdG9JbnQodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMCA/IHZhbHVlIDogJycpLmdldE9yKDApO1xuICAgIGNvbnN0IGdldEluZGVudFN0eWxlTmFtZSA9ICh1c2VNYXJnaW4sIGVsZW1lbnQpID0+IHtcbiAgICAgIGNvbnN0IGluZGVudFN0eWxlTmFtZSA9IHVzZU1hcmdpbiB8fCBpc1RhYmxlJDEoZWxlbWVudCkgPyAnbWFyZ2luJyA6ICdwYWRkaW5nJztcbiAgICAgIGNvbnN0IHN1ZmZpeCA9IGdldCQ3KGVsZW1lbnQsICdkaXJlY3Rpb24nKSA9PT0gJ3J0bCcgPyAnLXJpZ2h0JyA6ICctbGVmdCc7XG4gICAgICByZXR1cm4gaW5kZW50U3R5bGVOYW1lICsgc3VmZml4O1xuICAgIH07XG4gICAgY29uc3QgaW5kZW50RWxlbWVudCA9IChkb20sIGNvbW1hbmQsIHVzZU1hcmdpbiwgdmFsdWUsIHVuaXQsIGVsZW1lbnQpID0+IHtcbiAgICAgIGNvbnN0IGluZGVudFN0eWxlTmFtZSA9IGdldEluZGVudFN0eWxlTmFtZSh1c2VNYXJnaW4sIFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVsZW1lbnQpKTtcbiAgICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gcGFyc2VJbmRlbnRWYWx1ZShkb20uZ2V0U3R5bGUoZWxlbWVudCwgaW5kZW50U3R5bGVOYW1lKSk7XG4gICAgICBpZiAoY29tbWFuZCA9PT0gJ291dGRlbnQnKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlVmFsdWUgPSBNYXRoLm1heCgwLCBwYXJzZWRWYWx1ZSAtIHZhbHVlKTtcbiAgICAgICAgZG9tLnNldFN0eWxlKGVsZW1lbnQsIGluZGVudFN0eWxlTmFtZSwgc3R5bGVWYWx1ZSA/IHN0eWxlVmFsdWUgKyB1bml0IDogJycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc3R5bGVWYWx1ZSA9IHBhcnNlZFZhbHVlICsgdmFsdWUgKyB1bml0O1xuICAgICAgICBkb20uc2V0U3R5bGUoZWxlbWVudCwgaW5kZW50U3R5bGVOYW1lLCBzdHlsZVZhbHVlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHZhbGlkYXRlQmxvY2tzID0gKGVkaXRvciwgYmxvY2tzKSA9PiBmb3JhbGwoYmxvY2tzLCBibG9jayA9PiB7XG4gICAgICBjb25zdCBpbmRlbnRTdHlsZU5hbWUgPSBnZXRJbmRlbnRTdHlsZU5hbWUoc2hvdWxkSW5kZW50VXNlTWFyZ2luKGVkaXRvciksIGJsb2NrKTtcbiAgICAgIGNvbnN0IGludGVudFZhbHVlID0gZ2V0UmF3KGJsb2NrLCBpbmRlbnRTdHlsZU5hbWUpLm1hcChwYXJzZUluZGVudFZhbHVlKS5nZXRPcigwKTtcbiAgICAgIGNvbnN0IGNvbnRlbnRFZGl0YWJsZSA9IGVkaXRvci5kb20uZ2V0Q29udGVudEVkaXRhYmxlKGJsb2NrLmRvbSk7XG4gICAgICByZXR1cm4gY29udGVudEVkaXRhYmxlICE9PSAnZmFsc2UnICYmIGludGVudFZhbHVlID4gMDtcbiAgICB9KTtcbiAgICBjb25zdCBjYW5PdXRkZW50ID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGJsb2NrcyA9IGdldEJsb2Nrc1RvSW5kZW50KGVkaXRvcik7XG4gICAgICByZXR1cm4gIWVkaXRvci5tb2RlLmlzUmVhZE9ubHkoKSAmJiAoYmxvY2tzLmxlbmd0aCA+IDEgfHwgdmFsaWRhdGVCbG9ja3MoZWRpdG9yLCBibG9ja3MpKTtcbiAgICB9O1xuICAgIGNvbnN0IGlzTGlzdENvbXBvbmVudCA9IGVsID0+IGlzTGlzdChlbCkgfHwgaXNMaXN0SXRlbSQxKGVsKTtcbiAgICBjb25zdCBwYXJlbnRJc0xpc3RDb21wb25lbnQgPSBlbCA9PiBwYXJlbnQoZWwpLmV4aXN0cyhpc0xpc3RDb21wb25lbnQpO1xuICAgIGNvbnN0IGdldEJsb2Nrc1RvSW5kZW50ID0gZWRpdG9yID0+IGZpbHRlciQ1KGZyb21Eb20kMShlZGl0b3Iuc2VsZWN0aW9uLmdldFNlbGVjdGVkQmxvY2tzKCkpLCBlbCA9PiAhaXNMaXN0Q29tcG9uZW50KGVsKSAmJiAhcGFyZW50SXNMaXN0Q29tcG9uZW50KGVsKSAmJiBpc0VkaXRhYmxlKGVsKSk7XG4gICAgY29uc3QgaGFuZGxlID0gKGVkaXRvciwgY29tbWFuZCkgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGNvbnN0IHtkb219ID0gZWRpdG9yO1xuICAgICAgY29uc3QgaW5kZW50YXRpb24gPSBnZXRJbmRlbnRhdGlvbihlZGl0b3IpO1xuICAgICAgY29uc3QgaW5kZW50VW5pdCA9IChfYiA9IChfYSA9IC9bYS16JV0rJC9pLmV4ZWMoaW5kZW50YXRpb24pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICdweCc7XG4gICAgICBjb25zdCBpbmRlbnRWYWx1ZSA9IHBhcnNlSW5kZW50VmFsdWUoaW5kZW50YXRpb24pO1xuICAgICAgY29uc3QgdXNlTWFyZ2luID0gc2hvdWxkSW5kZW50VXNlTWFyZ2luKGVkaXRvcik7XG4gICAgICBlYWNoJGUoZ2V0QmxvY2tzVG9JbmRlbnQoZWRpdG9yKSwgYmxvY2sgPT4ge1xuICAgICAgICBpbmRlbnRFbGVtZW50KGRvbSwgY29tbWFuZCwgdXNlTWFyZ2luLCBpbmRlbnRWYWx1ZSwgaW5kZW50VW5pdCwgYmxvY2suZG9tKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgaW5kZW50ID0gZWRpdG9yID0+IGhhbmRsZShlZGl0b3IsICdpbmRlbnQnKTtcbiAgICBjb25zdCBvdXRkZW50ID0gZWRpdG9yID0+IGhhbmRsZShlZGl0b3IsICdvdXRkZW50Jyk7XG5cbiAgICBjb25zdCBiYWNrc3BhY2VEZWxldGUgPSBlZGl0b3IgPT4ge1xuICAgICAgaWYgKGVkaXRvci5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSAmJiBjYW5PdXRkZW50KGVkaXRvcikpIHtcbiAgICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbTtcbiAgICAgICAgY29uc3Qgcm5nID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgICAgY29uc3QgcG9zID0gQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChybmcpO1xuICAgICAgICBjb25zdCBibG9jayA9IGRvbS5nZXRQYXJlbnQocm5nLnN0YXJ0Q29udGFpbmVyLCBkb20uaXNCbG9jayk7XG4gICAgICAgIGlmIChibG9jayAhPT0gbnVsbCAmJiBpc0F0U3RhcnRPZkJsb2NrKFN1Z2FyRWxlbWVudC5mcm9tRG9tKGJsb2NrKSwgcG9zKSkge1xuICAgICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKCgpID0+IG91dGRlbnQoZWRpdG9yKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgfTtcblxuICAgIGNvbnN0IGZpbmRBY3Rpb24gPSAoZWRpdG9yLCBjYXJldCwgZm9yd2FyZCkgPT4gZmluZE1hcChbXG4gICAgICBiYWNrc3BhY2VEZWxldGUsXG4gICAgICBiYWNrc3BhY2VEZWxldGUkNSxcbiAgICAgIGJhY2tzcGFjZURlbGV0ZSQ2LFxuICAgICAgKGVkaXRvciwgZm9yd2FyZCkgPT4gYmFja3NwYWNlRGVsZXRlJDMoZWRpdG9yLCBjYXJldCwgZm9yd2FyZCksXG4gICAgICBiYWNrc3BhY2VEZWxldGUkOCxcbiAgICAgIGJhY2tzcGFjZURlbGV0ZSQ5LFxuICAgICAgYmFja3NwYWNlRGVsZXRlJDQsXG4gICAgICBiYWNrc3BhY2VEZWxldGUkMSxcbiAgICAgIGJhY2tzcGFjZURlbGV0ZSQ3LFxuICAgICAgYmFja3NwYWNlRGVsZXRlJDJcbiAgICBdLCBpdGVtID0+IGl0ZW0oZWRpdG9yLCBmb3J3YXJkKSkuZmlsdGVyKF8gPT4gZWRpdG9yLnNlbGVjdGlvbi5pc0VkaXRhYmxlKCkpO1xuICAgIGNvbnN0IGRlbGV0ZUNvbW1hbmQgPSAoZWRpdG9yLCBjYXJldCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZmluZEFjdGlvbihlZGl0b3IsIGNhcmV0LCBmYWxzZSk7XG4gICAgICByZXN1bHQuZm9sZCgoKSA9PiB7XG4gICAgICAgIGV4ZWNOYXRpdmVEZWxldGVDb21tYW5kKGVkaXRvcik7XG4gICAgICAgIHBhZGRFbXB0eUJvZHkoZWRpdG9yKTtcbiAgICAgIH0sIGNhbGwpO1xuICAgIH07XG4gICAgY29uc3QgZm9yd2FyZERlbGV0ZUNvbW1hbmQgPSAoZWRpdG9yLCBjYXJldCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZmluZEFjdGlvbihlZGl0b3IsIGNhcmV0LCB0cnVlKTtcbiAgICAgIHJlc3VsdC5mb2xkKCgpID0+IGV4ZWNOYXRpdmVGb3J3YXJkRGVsZXRlQ29tbWFuZChlZGl0b3IpLCBjYWxsKTtcbiAgICB9O1xuICAgIGNvbnN0IHNldHVwJHAgPSAoZWRpdG9yLCBjYXJldCkgPT4ge1xuICAgICAgZWRpdG9yLmFkZENvbW1hbmQoJ2RlbGV0ZScsICgpID0+IHtcbiAgICAgICAgZGVsZXRlQ29tbWFuZChlZGl0b3IsIGNhcmV0KTtcbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLmFkZENvbW1hbmQoJ2ZvcndhcmREZWxldGUnLCAoKSA9PiB7XG4gICAgICAgIGZvcndhcmREZWxldGVDb21tYW5kKGVkaXRvciwgY2FyZXQpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IFNJR05JRklDQU5UX01PVkUgPSA1O1xuICAgIGNvbnN0IExPTkdQUkVTU19ERUxBWSA9IDQwMDtcbiAgICBjb25zdCBnZXRUb3VjaCA9IGV2ZW50ID0+IHtcbiAgICAgIGlmIChldmVudC50b3VjaGVzID09PSB1bmRlZmluZWQgfHwgZXZlbnQudG91Y2hlcy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKGV2ZW50LnRvdWNoZXNbMF0pO1xuICAgIH07XG4gICAgY29uc3QgaXNGYXJFbm91Z2ggPSAodG91Y2gsIGRhdGEpID0+IHtcbiAgICAgIGNvbnN0IGRpc3RYID0gTWF0aC5hYnModG91Y2guY2xpZW50WCAtIGRhdGEueCk7XG4gICAgICBjb25zdCBkaXN0WSA9IE1hdGguYWJzKHRvdWNoLmNsaWVudFkgLSBkYXRhLnkpO1xuICAgICAgcmV0dXJuIGRpc3RYID4gU0lHTklGSUNBTlRfTU9WRSB8fCBkaXN0WSA+IFNJR05JRklDQU5UX01PVkU7XG4gICAgfTtcbiAgICBjb25zdCBzZXR1cCRvID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0RGF0YSA9IHZhbHVlJDIoKTtcbiAgICAgIGNvbnN0IGxvbmdwcmVzc0ZpcmVkID0gQ2VsbChmYWxzZSk7XG4gICAgICBjb25zdCBkZWJvdW5jZUxvbmdwcmVzcyA9IGxhc3QkMShlID0+IHtcbiAgICAgICAgZWRpdG9yLmRpc3BhdGNoKCdsb25ncHJlc3MnLCB7XG4gICAgICAgICAgLi4uZSxcbiAgICAgICAgICB0eXBlOiAnbG9uZ3ByZXNzJ1xuICAgICAgICB9KTtcbiAgICAgICAgbG9uZ3ByZXNzRmlyZWQuc2V0KHRydWUpO1xuICAgICAgfSwgTE9OR1BSRVNTX0RFTEFZKTtcbiAgICAgIGVkaXRvci5vbigndG91Y2hzdGFydCcsIGUgPT4ge1xuICAgICAgICBnZXRUb3VjaChlKS5lYWNoKHRvdWNoID0+IHtcbiAgICAgICAgICBkZWJvdW5jZUxvbmdwcmVzcy5jYW5jZWwoKTtcbiAgICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgeDogdG91Y2guY2xpZW50WCxcbiAgICAgICAgICAgIHk6IHRvdWNoLmNsaWVudFksXG4gICAgICAgICAgICB0YXJnZXQ6IGUudGFyZ2V0XG4gICAgICAgICAgfTtcbiAgICAgICAgICBkZWJvdW5jZUxvbmdwcmVzcy50aHJvdHRsZShlKTtcbiAgICAgICAgICBsb25ncHJlc3NGaXJlZC5zZXQoZmFsc2UpO1xuICAgICAgICAgIHN0YXJ0RGF0YS5zZXQoZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgfSwgdHJ1ZSk7XG4gICAgICBlZGl0b3Iub24oJ3RvdWNobW92ZScsIGUgPT4ge1xuICAgICAgICBkZWJvdW5jZUxvbmdwcmVzcy5jYW5jZWwoKTtcbiAgICAgICAgZ2V0VG91Y2goZSkuZWFjaCh0b3VjaCA9PiB7XG4gICAgICAgICAgc3RhcnREYXRhLm9uKGRhdGEgPT4ge1xuICAgICAgICAgICAgaWYgKGlzRmFyRW5vdWdoKHRvdWNoLCBkYXRhKSkge1xuICAgICAgICAgICAgICBzdGFydERhdGEuY2xlYXIoKTtcbiAgICAgICAgICAgICAgbG9uZ3ByZXNzRmlyZWQuc2V0KGZhbHNlKTtcbiAgICAgICAgICAgICAgZWRpdG9yLmRpc3BhdGNoKCdsb25ncHJlc3NjYW5jZWwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9LCB0cnVlKTtcbiAgICAgIGVkaXRvci5vbigndG91Y2hlbmQgdG91Y2hjYW5jZWwnLCBlID0+IHtcbiAgICAgICAgZGVib3VuY2VMb25ncHJlc3MuY2FuY2VsKCk7XG4gICAgICAgIGlmIChlLnR5cGUgPT09ICd0b3VjaGNhbmNlbCcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnREYXRhLmdldCgpLmZpbHRlcihkYXRhID0+IGRhdGEudGFyZ2V0LmlzRXF1YWxOb2RlKGUudGFyZ2V0KSkuZWFjaCgoKSA9PiB7XG4gICAgICAgICAgaWYgKGxvbmdwcmVzc0ZpcmVkLmdldCgpKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVkaXRvci5kaXNwYXRjaCgndGFwJywge1xuICAgICAgICAgICAgICAuLi5lLFxuICAgICAgICAgICAgICB0eXBlOiAndGFwJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sIHRydWUpO1xuICAgIH07XG5cbiAgICBjb25zdCBpc0Jsb2NrRWxlbWVudCA9IChibG9ja0VsZW1lbnRzLCBub2RlKSA9PiBoYXMkMihibG9ja0VsZW1lbnRzLCBub2RlLm5vZGVOYW1lKTtcbiAgICBjb25zdCBpc1ZhbGlkVGFyZ2V0ID0gKHNjaGVtYSwgbm9kZSkgPT4ge1xuICAgICAgaWYgKGlzVGV4dCRhKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChpc0VsZW1lbnQkNihub2RlKSkge1xuICAgICAgICByZXR1cm4gIWlzQmxvY2tFbGVtZW50KHNjaGVtYS5nZXRCbG9ja0VsZW1lbnRzKCksIG5vZGUpICYmICFpc0Jvb2ttYXJrTm9kZSQxKG5vZGUpICYmICFpc1RyYW5zcGFyZW50QmxvY2soc2NoZW1hLCBub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGhhc0Jsb2NrUGFyZW50ID0gKGJsb2NrRWxlbWVudHMsIHJvb3QsIG5vZGUpID0+IHtcbiAgICAgIHJldHVybiBleGlzdHMocGFyZW50cyhTdWdhckVsZW1lbnQuZnJvbURvbShub2RlKSwgU3VnYXJFbGVtZW50LmZyb21Eb20ocm9vdCkpLCBlbG0gPT4ge1xuICAgICAgICByZXR1cm4gaXNCbG9ja0VsZW1lbnQoYmxvY2tFbGVtZW50cywgZWxtLmRvbSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHNob3VsZFJlbW92ZVRleHROb2RlID0gKGJsb2NrRWxlbWVudHMsIG5vZGUpID0+IHtcbiAgICAgIGlmIChpc1RleHQkYShub2RlKSkge1xuICAgICAgICBpZiAobm9kZS5kYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKC9eXFxzKyQvLnRlc3Qobm9kZS5kYXRhKSAmJiAoIW5vZGUubmV4dFNpYmxpbmcgfHwgaXNCbG9ja0VsZW1lbnQoYmxvY2tFbGVtZW50cywgbm9kZS5uZXh0U2libGluZykpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZVJvb3RCbG9jayA9IGVkaXRvciA9PiBlZGl0b3IuZG9tLmNyZWF0ZShnZXRGb3JjZWRSb290QmxvY2soZWRpdG9yKSwgZ2V0Rm9yY2VkUm9vdEJsb2NrQXR0cnMoZWRpdG9yKSk7XG4gICAgY29uc3QgYWRkUm9vdEJsb2NrcyA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBkb20gPSBlZGl0b3IuZG9tLCBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICAgICAgY29uc3Qgc2NoZW1hID0gZWRpdG9yLnNjaGVtYTtcbiAgICAgIGNvbnN0IGJsb2NrRWxlbWVudHMgPSBzY2hlbWEuZ2V0QmxvY2tFbGVtZW50cygpO1xuICAgICAgY29uc3Qgc3RhcnROb2RlID0gc2VsZWN0aW9uLmdldFN0YXJ0KCk7XG4gICAgICBjb25zdCByb290Tm9kZSA9IGVkaXRvci5nZXRCb2R5KCk7XG4gICAgICBsZXQgcm9vdEJsb2NrTm9kZTtcbiAgICAgIGxldCB0ZW1wTm9kZTtcbiAgICAgIGxldCB3cmFwcGVkID0gZmFsc2U7XG4gICAgICBjb25zdCBmb3JjZWRSb290QmxvY2sgPSBnZXRGb3JjZWRSb290QmxvY2soZWRpdG9yKTtcbiAgICAgIGlmICghc3RhcnROb2RlIHx8ICFpc0VsZW1lbnQkNihzdGFydE5vZGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJvb3ROb2RlTmFtZSA9IHJvb3ROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoIXNjaGVtYS5pc1ZhbGlkQ2hpbGQocm9vdE5vZGVOYW1lLCBmb3JjZWRSb290QmxvY2sudG9Mb3dlckNhc2UoKSkgfHwgaGFzQmxvY2tQYXJlbnQoYmxvY2tFbGVtZW50cywgcm9vdE5vZGUsIHN0YXJ0Tm9kZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgcm5nID0gc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgY29uc3Qge3N0YXJ0Q29udGFpbmVyLCBzdGFydE9mZnNldCwgZW5kQ29udGFpbmVyLCBlbmRPZmZzZXR9ID0gcm5nO1xuICAgICAgY29uc3QgcmVzdG9yZVNlbGVjdGlvbiA9IGhhc0ZvY3VzKGVkaXRvcik7XG4gICAgICBsZXQgbm9kZSA9IHJvb3ROb2RlLmZpcnN0Q2hpbGQ7XG4gICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBpZiAoaXNFbGVtZW50JDYobm9kZSkpIHtcbiAgICAgICAgICB1cGRhdGVFbGVtZW50KHNjaGVtYSwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVmFsaWRUYXJnZXQoc2NoZW1hLCBub2RlKSkge1xuICAgICAgICAgIGlmIChzaG91bGRSZW1vdmVUZXh0Tm9kZShibG9ja0VsZW1lbnRzLCBub2RlKSkge1xuICAgICAgICAgICAgdGVtcE5vZGUgPSBub2RlO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBkb20ucmVtb3ZlKHRlbXBOb2RlKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJvb3RCbG9ja05vZGUpIHtcbiAgICAgICAgICAgIHJvb3RCbG9ja05vZGUgPSBjcmVhdGVSb290QmxvY2soZWRpdG9yKTtcbiAgICAgICAgICAgIHJvb3ROb2RlLmluc2VydEJlZm9yZShyb290QmxvY2tOb2RlLCBub2RlKTtcbiAgICAgICAgICAgIHdyYXBwZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0ZW1wTm9kZSA9IG5vZGU7XG4gICAgICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgcm9vdEJsb2NrTm9kZS5hcHBlbmRDaGlsZCh0ZW1wTm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm9vdEJsb2NrTm9kZSA9IG51bGw7XG4gICAgICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh3cmFwcGVkICYmIHJlc3RvcmVTZWxlY3Rpb24pIHtcbiAgICAgICAgcm5nLnNldFN0YXJ0KHN0YXJ0Q29udGFpbmVyLCBzdGFydE9mZnNldCk7XG4gICAgICAgIHJuZy5zZXRFbmQoZW5kQ29udGFpbmVyLCBlbmRPZmZzZXQpO1xuICAgICAgICBzZWxlY3Rpb24uc2V0Um5nKHJuZyk7XG4gICAgICAgIGVkaXRvci5ub2RlQ2hhbmdlZCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaW5zZXJ0RW1wdHlMaW5lID0gKGVkaXRvciwgcm9vdCwgaW5zZXJ0QmxvY2spID0+IHtcbiAgICAgIGNvbnN0IGJsb2NrID0gU3VnYXJFbGVtZW50LmZyb21Eb20oY3JlYXRlUm9vdEJsb2NrKGVkaXRvcikpO1xuICAgICAgY29uc3QgYnIgPSBjcmVhdGVQYWRkaW5nQnIoKTtcbiAgICAgIGFwcGVuZCQxKGJsb2NrLCBicik7XG4gICAgICBpbnNlcnRCbG9jayhyb290LCBibG9jayk7XG4gICAgICBjb25zdCBybmcgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgcm5nLnNldFN0YXJ0QmVmb3JlKGJyLmRvbSk7XG4gICAgICBybmcuc2V0RW5kQmVmb3JlKGJyLmRvbSk7XG4gICAgICByZXR1cm4gcm5nO1xuICAgIH07XG4gICAgY29uc3Qgc2V0dXAkbiA9IGVkaXRvciA9PiB7XG4gICAgICBlZGl0b3Iub24oJ05vZGVDaGFuZ2UnLCBjdXJyeShhZGRSb290QmxvY2tzLCBlZGl0b3IpKTtcbiAgICB9O1xuXG4gICAgY29uc3QgaGFzQ2xhc3MgPSBjaGVja0NsYXNzTmFtZSA9PiBub2RlID0+ICgnICcgKyBub2RlLmF0dHIoJ2NsYXNzJykgKyAnICcpLmluZGV4T2YoY2hlY2tDbGFzc05hbWUpICE9PSAtMTtcbiAgICBjb25zdCByZXBsYWNlTWF0Y2hXaXRoU3BhbiA9IChlZGl0b3IsIGNvbnRlbnQsIGNscykgPT4ge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICBjb25zdCBhcmdzID0gYXJndW1lbnRzLCBpbmRleCA9IGFyZ3NbYXJncy5sZW5ndGggLSAyXTtcbiAgICAgICAgY29uc3QgcHJldkNoYXIgPSBpbmRleCA+IDAgPyBjb250ZW50LmNoYXJBdChpbmRleCAtIDEpIDogJyc7XG4gICAgICAgIGlmIChwcmV2Q2hhciA9PT0gJ1wiJykge1xuICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldkNoYXIgPT09ICc+Jykge1xuICAgICAgICAgIGNvbnN0IGZpbmRTdGFydFRhZ0luZGV4ID0gY29udGVudC5sYXN0SW5kZXhPZignPCcsIGluZGV4KTtcbiAgICAgICAgICBpZiAoZmluZFN0YXJ0VGFnSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCB0YWdIdG1sID0gY29udGVudC5zdWJzdHJpbmcoZmluZFN0YXJ0VGFnSW5kZXgsIGluZGV4KTtcbiAgICAgICAgICAgIGlmICh0YWdIdG1sLmluZGV4T2YoJ2NvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCInKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJzxzcGFuIGNsYXNzPVwiJyArIGNscyArICdcIiBkYXRhLW1jZS1jb250ZW50PVwiJyArIGVkaXRvci5kb20uZW5jb2RlKGFyZ3NbMF0pICsgJ1wiPicgKyBlZGl0b3IuZG9tLmVuY29kZSh0eXBlb2YgYXJnc1sxXSA9PT0gJ3N0cmluZycgPyBhcmdzWzFdIDogYXJnc1swXSkgKyAnPC9zcGFuPic7XG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgY29udmVydFJlZ0V4cHNUb05vbkVkaXRhYmxlID0gKGVkaXRvciwgbm9uRWRpdGFibGVSZWdFeHBzLCBlKSA9PiB7XG4gICAgICBsZXQgaSA9IG5vbkVkaXRhYmxlUmVnRXhwcy5sZW5ndGgsIGNvbnRlbnQgPSBlLmNvbnRlbnQ7XG4gICAgICBpZiAoZS5mb3JtYXQgPT09ICdyYXcnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZShub25FZGl0YWJsZVJlZ0V4cHNbaV0sIHJlcGxhY2VNYXRjaFdpdGhTcGFuKGVkaXRvciwgY29udGVudCwgZ2V0Tm9uRWRpdGFibGVDbGFzcyhlZGl0b3IpKSk7XG4gICAgICB9XG4gICAgICBlLmNvbnRlbnQgPSBjb250ZW50O1xuICAgIH07XG4gICAgY29uc3Qgc2V0dXAkbSA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBjb250ZW50RWRpdGFibGVBdHRyTmFtZSA9ICdjb250ZW50ZWRpdGFibGUnO1xuICAgICAgY29uc3QgZWRpdENsYXNzID0gJyAnICsgVG9vbHMudHJpbShnZXRFZGl0YWJsZUNsYXNzKGVkaXRvcikpICsgJyAnO1xuICAgICAgY29uc3Qgbm9uRWRpdENsYXNzID0gJyAnICsgVG9vbHMudHJpbShnZXROb25FZGl0YWJsZUNsYXNzKGVkaXRvcikpICsgJyAnO1xuICAgICAgY29uc3QgaGFzRWRpdENsYXNzID0gaGFzQ2xhc3MoZWRpdENsYXNzKTtcbiAgICAgIGNvbnN0IGhhc05vbkVkaXRDbGFzcyA9IGhhc0NsYXNzKG5vbkVkaXRDbGFzcyk7XG4gICAgICBjb25zdCBub25FZGl0YWJsZVJlZ0V4cHMgPSBnZXROb25FZGl0YWJsZVJlZ0V4cHMoZWRpdG9yKTtcbiAgICAgIGlmIChub25FZGl0YWJsZVJlZ0V4cHMubGVuZ3RoID4gMCkge1xuICAgICAgICBlZGl0b3Iub24oJ0JlZm9yZVNldENvbnRlbnQnLCBlID0+IHtcbiAgICAgICAgICBjb252ZXJ0UmVnRXhwc1RvTm9uRWRpdGFibGUoZWRpdG9yLCBub25FZGl0YWJsZVJlZ0V4cHMsIGUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGVkaXRvci5wYXJzZXIuYWRkQXR0cmlidXRlRmlsdGVyKCdjbGFzcycsIG5vZGVzID0+IHtcbiAgICAgICAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgaWYgKGhhc0VkaXRDbGFzcyhub2RlKSkge1xuICAgICAgICAgICAgbm9kZS5hdHRyKGNvbnRlbnRFZGl0YWJsZUF0dHJOYW1lLCAndHJ1ZScpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzTm9uRWRpdENsYXNzKG5vZGUpKSB7XG4gICAgICAgICAgICBub2RlLmF0dHIoY29udGVudEVkaXRhYmxlQXR0ck5hbWUsICdmYWxzZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlZGl0b3Iuc2VyaWFsaXplci5hZGRBdHRyaWJ1dGVGaWx0ZXIoY29udGVudEVkaXRhYmxlQXR0ck5hbWUsIG5vZGVzID0+IHtcbiAgICAgICAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgaWYgKCFoYXNFZGl0Q2xhc3Mobm9kZSkgJiYgIWhhc05vbkVkaXRDbGFzcyhub2RlKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChub25FZGl0YWJsZVJlZ0V4cHMubGVuZ3RoID4gMCAmJiBub2RlLmF0dHIoJ2RhdGEtbWNlLWNvbnRlbnQnKSkge1xuICAgICAgICAgICAgbm9kZS5uYW1lID0gJyN0ZXh0JztcbiAgICAgICAgICAgIG5vZGUudHlwZSA9IDM7XG4gICAgICAgICAgICBub2RlLnJhdyA9IHRydWU7XG4gICAgICAgICAgICBub2RlLnZhbHVlID0gbm9kZS5hdHRyKCdkYXRhLW1jZS1jb250ZW50Jyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUuYXR0cihjb250ZW50RWRpdGFibGVBdHRyTmFtZSwgbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgZmluZEJsb2NrQ2FyZXRDb250YWluZXIgPSBlZGl0b3IgPT4gZGVzY2VuZGFudChTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3IuZ2V0Qm9keSgpKSwgJypbZGF0YS1tY2UtY2FyZXRdJykubWFwKGVsbSA9PiBlbG0uZG9tKS5nZXRPck51bGwoKTtcbiAgICBjb25zdCBzaG93QmxvY2tDYXJldENvbnRhaW5lciA9IChlZGl0b3IsIGJsb2NrQ2FyZXRDb250YWluZXIpID0+IHtcbiAgICAgIGlmIChibG9ja0NhcmV0Q29udGFpbmVyLmhhc0F0dHJpYnV0ZSgnZGF0YS1tY2UtY2FyZXQnKSkge1xuICAgICAgICBzaG93Q2FyZXRDb250YWluZXJCbG9jayhibG9ja0NhcmV0Q29udGFpbmVyKTtcbiAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRSbmcoZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKSk7XG4gICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2Nyb2xsSW50b1ZpZXcoYmxvY2tDYXJldENvbnRhaW5lcik7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVCbG9ja0NvbnRhaW5lciA9IChlZGl0b3IsIGUpID0+IHtcbiAgICAgIGNvbnN0IGJsb2NrQ2FyZXRDb250YWluZXIgPSBmaW5kQmxvY2tDYXJldENvbnRhaW5lcihlZGl0b3IpO1xuICAgICAgaWYgKCFibG9ja0NhcmV0Q29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChlLnR5cGUgPT09ICdjb21wb3NpdGlvbnN0YXJ0Jykge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHNob3dCbG9ja0NhcmV0Q29udGFpbmVyKGVkaXRvciwgYmxvY2tDYXJldENvbnRhaW5lcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNDb250ZW50KGJsb2NrQ2FyZXRDb250YWluZXIpKSB7XG4gICAgICAgIHNob3dCbG9ja0NhcmV0Q29udGFpbmVyKGVkaXRvciwgYmxvY2tDYXJldENvbnRhaW5lcik7XG4gICAgICAgIGVkaXRvci51bmRvTWFuYWdlci5hZGQoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNldHVwJGwgPSBlZGl0b3IgPT4ge1xuICAgICAgZWRpdG9yLm9uKCdrZXl1cCBjb21wb3NpdGlvbnN0YXJ0JywgY3VycnkoaGFuZGxlQmxvY2tDb250YWluZXIsIGVkaXRvcikpO1xuICAgIH07XG5cbiAgICBjb25zdCBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJDMgPSBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJGI7XG4gICAgY29uc3QgbW92ZVRvQ2VGYWxzZUhvcml6b250YWxseSA9IChkaXJlY3Rpb24sIGVkaXRvciwgcmFuZ2UpID0+IG1vdmVIb3Jpem9udGFsbHkoZWRpdG9yLCBkaXJlY3Rpb24sIHJhbmdlLCBpc0JlZm9yZUNvbnRlbnRFZGl0YWJsZUZhbHNlLCBpc0FmdGVyQ29udGVudEVkaXRhYmxlRmFsc2UsIGlzQ29udGVudEVkaXRhYmxlRmFsc2UkMyk7XG4gICAgY29uc3QgbW92ZVRvQ2VGYWxzZVZlcnRpY2FsbHkgPSAoZGlyZWN0aW9uLCBlZGl0b3IsIHJhbmdlKSA9PiB7XG4gICAgICBjb25zdCBpc0JlZm9yZSA9IGNhcmV0UG9zaXRpb24gPT4gaXNCZWZvcmVDb250ZW50RWRpdGFibGVGYWxzZShjYXJldFBvc2l0aW9uKSB8fCBpc0JlZm9yZVRhYmxlKGNhcmV0UG9zaXRpb24pO1xuICAgICAgY29uc3QgaXNBZnRlciA9IGNhcmV0UG9zaXRpb24gPT4gaXNBZnRlckNvbnRlbnRFZGl0YWJsZUZhbHNlKGNhcmV0UG9zaXRpb24pIHx8IGlzQWZ0ZXJUYWJsZShjYXJldFBvc2l0aW9uKTtcbiAgICAgIHJldHVybiBtb3ZlVmVydGljYWxseShlZGl0b3IsIGRpcmVjdGlvbiwgcmFuZ2UsIGlzQmVmb3JlLCBpc0FmdGVyLCBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJDMpO1xuICAgIH07XG4gICAgY29uc3QgY3JlYXRlVGV4dEJsb2NrID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IHRleHRCbG9jayA9IGVkaXRvci5kb20uY3JlYXRlKGdldEZvcmNlZFJvb3RCbG9jayhlZGl0b3IpKTtcbiAgICAgIHRleHRCbG9jay5pbm5lckhUTUwgPSAnPGJyIGRhdGEtbWNlLWJvZ3VzPVwiMVwiPic7XG4gICAgICByZXR1cm4gdGV4dEJsb2NrO1xuICAgIH07XG4gICAgY29uc3QgZXhpdFByZUJsb2NrID0gKGVkaXRvciwgZGlyZWN0aW9uLCByYW5nZSkgPT4ge1xuICAgICAgY29uc3QgY2FyZXRXYWxrZXIgPSBDYXJldFdhbGtlcihlZGl0b3IuZ2V0Qm9keSgpKTtcbiAgICAgIGNvbnN0IGdldFZpc3VhbENhcmV0UG9zaXRpb24kMSA9IGN1cnJ5KGdldFZpc3VhbENhcmV0UG9zaXRpb24sIGRpcmVjdGlvbiA9PT0gMSA/IGNhcmV0V2Fsa2VyLm5leHQgOiBjYXJldFdhbGtlci5wcmV2KTtcbiAgICAgIGlmIChyYW5nZS5jb2xsYXBzZWQpIHtcbiAgICAgICAgY29uc3QgcHJlID0gZWRpdG9yLmRvbS5nZXRQYXJlbnQocmFuZ2Uuc3RhcnRDb250YWluZXIsICdQUkUnKTtcbiAgICAgICAgaWYgKCFwcmUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FyZXRQb3MgPSBnZXRWaXN1YWxDYXJldFBvc2l0aW9uJDEoQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChyYW5nZSkpO1xuICAgICAgICBpZiAoIWNhcmV0UG9zKSB7XG4gICAgICAgICAgY29uc3QgbmV3QmxvY2sgPSBTdWdhckVsZW1lbnQuZnJvbURvbShjcmVhdGVUZXh0QmxvY2soZWRpdG9yKSk7XG4gICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gMSkge1xuICAgICAgICAgICAgYWZ0ZXIkNChTdWdhckVsZW1lbnQuZnJvbURvbShwcmUpLCBuZXdCbG9jayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJlZm9yZSQzKFN1Z2FyRWxlbWVudC5mcm9tRG9tKHByZSksIG5ld0Jsb2NrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZWxlY3QobmV3QmxvY2suZG9tLCB0cnVlKTtcbiAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLmNvbGxhcHNlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGdldEhvcml6b250YWxSYW5nZSA9IChlZGl0b3IsIGZvcndhcmQpID0+IHtcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGZvcndhcmQgPyBIRGlyZWN0aW9uLkZvcndhcmRzIDogSERpcmVjdGlvbi5CYWNrd2FyZHM7XG4gICAgICBjb25zdCByYW5nZSA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICByZXR1cm4gbW92ZVRvQ2VGYWxzZUhvcml6b250YWxseShkaXJlY3Rpb24sIGVkaXRvciwgcmFuZ2UpLm9yVGh1bmsoKCkgPT4ge1xuICAgICAgICBleGl0UHJlQmxvY2soZWRpdG9yLCBkaXJlY3Rpb24sIHJhbmdlKTtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgZ2V0VmVydGljYWxSYW5nZSA9IChlZGl0b3IsIGRvd24pID0+IHtcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGRvd24gPyAxIDogLTE7XG4gICAgICBjb25zdCByYW5nZSA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICByZXR1cm4gbW92ZVRvQ2VGYWxzZVZlcnRpY2FsbHkoZGlyZWN0aW9uLCBlZGl0b3IsIHJhbmdlKS5vclRodW5rKCgpID0+IHtcbiAgICAgICAgZXhpdFByZUJsb2NrKGVkaXRvciwgZGlyZWN0aW9uLCByYW5nZSk7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IG1vdmVIJDIgPSAoZWRpdG9yLCBmb3J3YXJkKSA9PiBnZXRIb3Jpem9udGFsUmFuZ2UoZWRpdG9yLCBmb3J3YXJkKS5leGlzdHMobmV3UmFuZ2UgPT4ge1xuICAgICAgbW92ZVRvUmFuZ2UoZWRpdG9yLCBuZXdSYW5nZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICBjb25zdCBtb3ZlViQzID0gKGVkaXRvciwgZG93bikgPT4gZ2V0VmVydGljYWxSYW5nZShlZGl0b3IsIGRvd24pLmV4aXN0cyhuZXdSYW5nZSA9PiB7XG4gICAgICBtb3ZlVG9SYW5nZShlZGl0b3IsIG5ld1JhbmdlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIGNvbnN0IG1vdmVUb0xpbmVFbmRQb2ludCQxID0gKGVkaXRvciwgZm9yd2FyZCkgPT4ge1xuICAgICAgY29uc3QgaXNDZWZQb3NpdGlvbiA9IGZvcndhcmQgPyBpc0FmdGVyQ29udGVudEVkaXRhYmxlRmFsc2UgOiBpc0JlZm9yZUNvbnRlbnRFZGl0YWJsZUZhbHNlO1xuICAgICAgcmV0dXJuIG1vdmVUb0xpbmVFbmRQb2ludCQzKGVkaXRvciwgZm9yd2FyZCwgaXNDZWZQb3NpdGlvbik7XG4gICAgfTtcbiAgICBjb25zdCBzZWxlY3RUb0VuZFBvaW50ID0gKGVkaXRvciwgZm9yd2FyZCkgPT4gZ2V0RWRnZUNlZlBvc2l0aW9uKGVkaXRvciwgIWZvcndhcmQpLm1hcChwb3MgPT4ge1xuICAgICAgY29uc3Qgcm5nID0gcG9zLnRvUmFuZ2UoKTtcbiAgICAgIGNvbnN0IGN1clJuZyA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICBpZiAoZm9yd2FyZCkge1xuICAgICAgICBybmcuc2V0U3RhcnQoY3VyUm5nLnN0YXJ0Q29udGFpbmVyLCBjdXJSbmcuc3RhcnRPZmZzZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm5nLnNldEVuZChjdXJSbmcuZW5kQ29udGFpbmVyLCBjdXJSbmcuZW5kT2Zmc2V0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBybmc7XG4gICAgfSkuZXhpc3RzKHJuZyA9PiB7XG4gICAgICBtb3ZlVG9SYW5nZShlZGl0b3IsIHJuZyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGlzVGFyZ2V0ID0gbm9kZSA9PiBjb250YWlucyQyKFsnZmlnY2FwdGlvbiddLCBuYW1lKG5vZGUpKTtcbiAgICBjb25zdCBnZXRDbG9zZXN0VGFyZ2V0QmxvY2sgPSAocG9zLCByb290KSA9PiB7XG4gICAgICBjb25zdCBpc1Jvb3QgPSBjdXJyeShlcSwgcm9vdCk7XG4gICAgICByZXR1cm4gY2xvc2VzdCQ0KFN1Z2FyRWxlbWVudC5mcm9tRG9tKHBvcy5jb250YWluZXIoKSksIGlzQmxvY2skMiwgaXNSb290KS5maWx0ZXIoaXNUYXJnZXQpO1xuICAgIH07XG4gICAgY29uc3QgaXNBdEZpcnN0T3JMYXN0TGluZSA9IChyb290LCBmb3J3YXJkLCBwb3MpID0+IGZvcndhcmQgPyBpc0F0TGFzdExpbmUocm9vdC5kb20sIHBvcykgOiBpc0F0Rmlyc3RMaW5lKHJvb3QuZG9tLCBwb3MpO1xuICAgIGNvbnN0IG1vdmVDYXJldFRvTmV3RW1wdHlMaW5lID0gKGVkaXRvciwgZm9yd2FyZCkgPT4ge1xuICAgICAgY29uc3Qgcm9vdCA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRCb2R5KCkpO1xuICAgICAgY29uc3QgcG9zID0gQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpKTtcbiAgICAgIHJldHVybiBnZXRDbG9zZXN0VGFyZ2V0QmxvY2socG9zLCByb290KS5leGlzdHMoKCkgPT4ge1xuICAgICAgICBpZiAoaXNBdEZpcnN0T3JMYXN0TGluZShyb290LCBmb3J3YXJkLCBwb3MpKSB7XG4gICAgICAgICAgY29uc3QgaW5zZXJ0Rm4gPSBmb3J3YXJkID8gYXBwZW5kJDEgOiBwcmVwZW5kO1xuICAgICAgICAgIGNvbnN0IHJuZyA9IGluc2VydEVtcHR5TGluZShlZGl0b3IsIHJvb3QsIGluc2VydEZuKTtcbiAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFJuZyhybmcpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBtb3ZlViQyID0gKGVkaXRvciwgZm9yd2FyZCkgPT4ge1xuICAgICAgaWYgKGVkaXRvci5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgICByZXR1cm4gbW92ZUNhcmV0VG9OZXdFbXB0eUxpbmUoZWRpdG9yLCBmb3J3YXJkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgYmFzZUtleVBhdHRlcm4gPSB7XG4gICAgICBzaGlmdEtleTogZmFsc2UsXG4gICAgICBhbHRLZXk6IGZhbHNlLFxuICAgICAgY3RybEtleTogZmFsc2UsXG4gICAgICBtZXRhS2V5OiBmYWxzZSxcbiAgICAgIGtleUNvZGU6IDBcbiAgICB9O1xuICAgIGNvbnN0IGRlZmF1bHRQYXR0ZXJucyA9IHBhdHRlcm5zID0+IG1hcCQzKHBhdHRlcm5zLCBwYXR0ZXJuID0+ICh7XG4gICAgICAuLi5iYXNlS2V5UGF0dGVybixcbiAgICAgIC4uLnBhdHRlcm5cbiAgICB9KSk7XG4gICAgY29uc3QgZGVmYXVsdERlbGF5ZWRQYXR0ZXJucyA9IHBhdHRlcm5zID0+IG1hcCQzKHBhdHRlcm5zLCBwYXR0ZXJuID0+ICh7XG4gICAgICAuLi5iYXNlS2V5UGF0dGVybixcbiAgICAgIC4uLnBhdHRlcm5cbiAgICB9KSk7XG4gICAgY29uc3QgbWF0Y2hlc0V2ZW50ID0gKHBhdHRlcm4sIGV2dCkgPT4gZXZ0LmtleUNvZGUgPT09IHBhdHRlcm4ua2V5Q29kZSAmJiBldnQuc2hpZnRLZXkgPT09IHBhdHRlcm4uc2hpZnRLZXkgJiYgZXZ0LmFsdEtleSA9PT0gcGF0dGVybi5hbHRLZXkgJiYgZXZ0LmN0cmxLZXkgPT09IHBhdHRlcm4uY3RybEtleSAmJiBldnQubWV0YUtleSA9PT0gcGF0dGVybi5tZXRhS2V5O1xuICAgIGNvbnN0IG1hdGNoJDEgPSAocGF0dGVybnMsIGV2dCkgPT4gYmluZCQzKGRlZmF1bHRQYXR0ZXJucyhwYXR0ZXJucyksIHBhdHRlcm4gPT4gbWF0Y2hlc0V2ZW50KHBhdHRlcm4sIGV2dCkgPyBbcGF0dGVybl0gOiBbXSk7XG4gICAgY29uc3QgbWF0Y2hEZWxheWVkID0gKHBhdHRlcm5zLCBldnQpID0+IGJpbmQkMyhkZWZhdWx0RGVsYXllZFBhdHRlcm5zKHBhdHRlcm5zKSwgcGF0dGVybiA9PiBtYXRjaGVzRXZlbnQocGF0dGVybiwgZXZ0KSA/IFtwYXR0ZXJuXSA6IFtdKTtcbiAgICBjb25zdCBhY3Rpb24gPSAoZiwgLi4ueCkgPT4gKCkgPT4gZi5hcHBseShudWxsLCB4KTtcbiAgICBjb25zdCBleGVjdXRlID0gKHBhdHRlcm5zLCBldnQpID0+IGZpbmQkMihtYXRjaCQxKHBhdHRlcm5zLCBldnQpLCBwYXR0ZXJuID0+IHBhdHRlcm4uYWN0aW9uKCkpO1xuICAgIGNvbnN0IGV4ZWN1dGVXaXRoRGVsYXllZEFjdGlvbiA9IChwYXR0ZXJucywgZXZ0KSA9PiBmaW5kTWFwKG1hdGNoRGVsYXllZChwYXR0ZXJucywgZXZ0KSwgcGF0dGVybiA9PiBwYXR0ZXJuLmFjdGlvbigpKTtcblxuICAgIGNvbnN0IG1vdmVIJDEgPSAoZWRpdG9yLCBmb3J3YXJkKSA9PiB7XG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSBmb3J3YXJkID8gSERpcmVjdGlvbi5Gb3J3YXJkcyA6IEhEaXJlY3Rpb24uQmFja3dhcmRzO1xuICAgICAgY29uc3QgcmFuZ2UgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgcmV0dXJuIG1vdmVIb3Jpem9udGFsbHkoZWRpdG9yLCBkaXJlY3Rpb24sIHJhbmdlLCBpc0JlZm9yZU1lZGlhLCBpc0FmdGVyTWVkaWEsIGlzTWVkaWEkMikuZXhpc3RzKG5ld1JhbmdlID0+IHtcbiAgICAgICAgbW92ZVRvUmFuZ2UoZWRpdG9yLCBuZXdSYW5nZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBtb3ZlViQxID0gKGVkaXRvciwgZG93bikgPT4ge1xuICAgICAgY29uc3QgZGlyZWN0aW9uID0gZG93biA/IDEgOiAtMTtcbiAgICAgIGNvbnN0IHJhbmdlID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgIHJldHVybiBtb3ZlVmVydGljYWxseShlZGl0b3IsIGRpcmVjdGlvbiwgcmFuZ2UsIGlzQmVmb3JlTWVkaWEsIGlzQWZ0ZXJNZWRpYSwgaXNNZWRpYSQyKS5leGlzdHMobmV3UmFuZ2UgPT4ge1xuICAgICAgICBtb3ZlVG9SYW5nZShlZGl0b3IsIG5ld1JhbmdlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IG1vdmVUb0xpbmVFbmRQb2ludCA9IChlZGl0b3IsIGZvcndhcmQpID0+IHtcbiAgICAgIGNvbnN0IGlzTmVhck1lZGlhID0gZm9yd2FyZCA/IGlzQWZ0ZXJNZWRpYSA6IGlzQmVmb3JlTWVkaWE7XG4gICAgICByZXR1cm4gbW92ZVRvTGluZUVuZFBvaW50JDMoZWRpdG9yLCBmb3J3YXJkLCBpc05lYXJNZWRpYSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGFkdCA9IEFkdC5nZW5lcmF0ZShbXG4gICAgICB7IG5vbmU6IFsnY3VycmVudCddIH0sXG4gICAgICB7IGZpcnN0OiBbJ2N1cnJlbnQnXSB9LFxuICAgICAge1xuICAgICAgICBtaWRkbGU6IFtcbiAgICAgICAgICAnY3VycmVudCcsXG4gICAgICAgICAgJ3RhcmdldCdcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIHsgbGFzdDogWydjdXJyZW50J10gfVxuICAgIF0pO1xuICAgIGNvbnN0IG5vbmUgPSBjdXJyZW50ID0+IGFkdC5ub25lKGN1cnJlbnQpO1xuICAgIGNvbnN0IENlbGxMb2NhdGlvbiA9IHtcbiAgICAgIC4uLmFkdCxcbiAgICAgIG5vbmVcbiAgICB9O1xuXG4gICAgY29uc3QgZmlyc3RMYXllciA9IChzY29wZSwgc2VsZWN0b3IpID0+IHtcbiAgICAgIHJldHVybiBmaWx0ZXJGaXJzdExheWVyKHNjb3BlLCBzZWxlY3RvciwgYWx3YXlzKTtcbiAgICB9O1xuICAgIGNvbnN0IGZpbHRlckZpcnN0TGF5ZXIgPSAoc2NvcGUsIHNlbGVjdG9yLCBwcmVkaWNhdGUpID0+IHtcbiAgICAgIHJldHVybiBiaW5kJDMoY2hpbGRyZW4kMShzY29wZSksIHggPT4ge1xuICAgICAgICBpZiAoaXMkMSh4LCBzZWxlY3RvcikpIHtcbiAgICAgICAgICByZXR1cm4gcHJlZGljYXRlKHgpID8gW3hdIDogW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZpbHRlckZpcnN0TGF5ZXIoeCwgc2VsZWN0b3IsIHByZWRpY2F0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBsb29rdXAkMSA9ICh0YWdzLCBlbGVtZW50LCBpc1Jvb3QgPSBuZXZlcikgPT4ge1xuICAgICAgaWYgKGlzUm9vdChlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnRhaW5zJDIodGFncywgbmFtZShlbGVtZW50KSkpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoZWxlbWVudCk7XG4gICAgICB9XG4gICAgICBjb25zdCBpc1Jvb3RPclVwcGVyVGFibGUgPSBlbG0gPT4gaXMkMShlbG0sICd0YWJsZScpIHx8IGlzUm9vdChlbG0pO1xuICAgICAgcmV0dXJuIGFuY2VzdG9yJDMoZWxlbWVudCwgdGFncy5qb2luKCcsJyksIGlzUm9vdE9yVXBwZXJUYWJsZSk7XG4gICAgfTtcbiAgICBjb25zdCBjZWxsID0gKGVsZW1lbnQsIGlzUm9vdCkgPT4gbG9va3VwJDEoW1xuICAgICAgJ3RkJyxcbiAgICAgICd0aCdcbiAgICBdLCBlbGVtZW50LCBpc1Jvb3QpO1xuICAgIGNvbnN0IGNlbGxzID0gYW5jZXN0b3IgPT4gZmlyc3RMYXllcihhbmNlc3RvciwgJ3RoLHRkJyk7XG4gICAgY29uc3QgdGFibGUgPSAoZWxlbWVudCwgaXNSb290KSA9PiBjbG9zZXN0JDMoZWxlbWVudCwgJ3RhYmxlJywgaXNSb290KTtcblxuICAgIGNvbnN0IHdhbGsgPSAoYWxsLCBjdXJyZW50LCBpbmRleCwgZGlyZWN0aW9uLCBpc0VsaWdpYmxlID0gYWx3YXlzKSA9PiB7XG4gICAgICBjb25zdCBmb3J3YXJkcyA9IGRpcmVjdGlvbiA9PT0gMTtcbiAgICAgIGlmICghZm9yd2FyZHMgJiYgaW5kZXggPD0gMCkge1xuICAgICAgICByZXR1cm4gQ2VsbExvY2F0aW9uLmZpcnN0KGFsbFswXSk7XG4gICAgICB9IGVsc2UgaWYgKGZvcndhcmRzICYmIGluZGV4ID49IGFsbC5sZW5ndGggLSAxKSB7XG4gICAgICAgIHJldHVybiBDZWxsTG9jYXRpb24ubGFzdChhbGxbYWxsLmxlbmd0aCAtIDFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5ld0luZGV4ID0gaW5kZXggKyBkaXJlY3Rpb247XG4gICAgICAgIGNvbnN0IGVsZW0gPSBhbGxbbmV3SW5kZXhdO1xuICAgICAgICByZXR1cm4gaXNFbGlnaWJsZShlbGVtKSA/IENlbGxMb2NhdGlvbi5taWRkbGUoY3VycmVudCwgZWxlbSkgOiB3YWxrKGFsbCwgY3VycmVudCwgbmV3SW5kZXgsIGRpcmVjdGlvbiwgaXNFbGlnaWJsZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBkZXRlY3QgPSAoY3VycmVudCwgaXNSb290KSA9PiB7XG4gICAgICByZXR1cm4gdGFibGUoY3VycmVudCwgaXNSb290KS5iaW5kKHRhYmxlID0+IHtcbiAgICAgICAgY29uc3QgYWxsID0gY2VsbHModGFibGUpO1xuICAgICAgICBjb25zdCBpbmRleCA9IGZpbmRJbmRleCQyKGFsbCwgeCA9PiBlcShjdXJyZW50LCB4KSk7XG4gICAgICAgIHJldHVybiBpbmRleC5tYXAoaW5kZXggPT4gKHtcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICBhbGxcbiAgICAgICAgfSkpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBuZXh0ID0gKGN1cnJlbnQsIGlzRWxpZ2libGUsIGlzUm9vdCkgPT4ge1xuICAgICAgY29uc3QgZGV0ZWN0aW9uID0gZGV0ZWN0KGN1cnJlbnQsIGlzUm9vdCk7XG4gICAgICByZXR1cm4gZGV0ZWN0aW9uLmZvbGQoKCkgPT4ge1xuICAgICAgICByZXR1cm4gQ2VsbExvY2F0aW9uLm5vbmUoY3VycmVudCk7XG4gICAgICB9LCBpbmZvID0+IHtcbiAgICAgICAgcmV0dXJuIHdhbGsoaW5mby5hbGwsIGN1cnJlbnQsIGluZm8uaW5kZXgsIDEsIGlzRWxpZ2libGUpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBwcmV2ID0gKGN1cnJlbnQsIGlzRWxpZ2libGUsIGlzUm9vdCkgPT4ge1xuICAgICAgY29uc3QgZGV0ZWN0aW9uID0gZGV0ZWN0KGN1cnJlbnQsIGlzUm9vdCk7XG4gICAgICByZXR1cm4gZGV0ZWN0aW9uLmZvbGQoKCkgPT4ge1xuICAgICAgICByZXR1cm4gQ2VsbExvY2F0aW9uLm5vbmUoKTtcbiAgICAgIH0sIGluZm8gPT4ge1xuICAgICAgICByZXR1cm4gd2FsayhpbmZvLmFsbCwgY3VycmVudCwgaW5mby5pbmRleCwgLTEsIGlzRWxpZ2libGUpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGRlZmxhdGUgPSAocmVjdCwgZGVsdGEpID0+ICh7XG4gICAgICBsZWZ0OiByZWN0LmxlZnQgLSBkZWx0YSxcbiAgICAgIHRvcDogcmVjdC50b3AgLSBkZWx0YSxcbiAgICAgIHJpZ2h0OiByZWN0LnJpZ2h0ICsgZGVsdGEgKiAyLFxuICAgICAgYm90dG9tOiByZWN0LmJvdHRvbSArIGRlbHRhICogMixcbiAgICAgIHdpZHRoOiByZWN0LndpZHRoICsgZGVsdGEsXG4gICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0ICsgZGVsdGFcbiAgICB9KTtcbiAgICBjb25zdCBnZXRDb3JuZXJzID0gKGdldFlBeGlzVmFsdWUsIHRkcykgPT4gYmluZCQzKHRkcywgdGQgPT4ge1xuICAgICAgY29uc3QgcmVjdCA9IGRlZmxhdGUoY2xvbmUkMSh0ZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSksIC0xKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICB4OiByZWN0LmxlZnQsXG4gICAgICAgICAgeTogZ2V0WUF4aXNWYWx1ZShyZWN0KSxcbiAgICAgICAgICBjZWxsOiB0ZFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgeDogcmVjdC5yaWdodCxcbiAgICAgICAgICB5OiBnZXRZQXhpc1ZhbHVlKHJlY3QpLFxuICAgICAgICAgIGNlbGw6IHRkXG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgfSk7XG4gICAgY29uc3QgZmluZENsb3Nlc3RDb3JuZXIgPSAoY29ybmVycywgeCwgeSkgPT4gZm9sZGwoY29ybmVycywgKGFjYywgbmV3Q29ybmVyKSA9PiBhY2MuZm9sZCgoKSA9PiBPcHRpb25hbC5zb21lKG5ld0Nvcm5lciksIG9sZENvcm5lciA9PiB7XG4gICAgICBjb25zdCBvbGREaXN0ID0gTWF0aC5zcXJ0KE1hdGguYWJzKG9sZENvcm5lci54IC0geCkgKyBNYXRoLmFicyhvbGRDb3JuZXIueSAtIHkpKTtcbiAgICAgIGNvbnN0IG5ld0Rpc3QgPSBNYXRoLnNxcnQoTWF0aC5hYnMobmV3Q29ybmVyLnggLSB4KSArIE1hdGguYWJzKG5ld0Nvcm5lci55IC0geSkpO1xuICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUobmV3RGlzdCA8IG9sZERpc3QgPyBuZXdDb3JuZXIgOiBvbGRDb3JuZXIpO1xuICAgIH0pLCBPcHRpb25hbC5ub25lKCkpO1xuICAgIGNvbnN0IGdldENsb3Nlc3RDZWxsID0gKGdldFlBeGlzVmFsdWUsIGlzVGFyZ2V0Q29ybmVyLCB0YWJsZSwgeCwgeSkgPT4ge1xuICAgICAgY29uc3QgY2VsbHMgPSBkZXNjZW5kYW50cyhTdWdhckVsZW1lbnQuZnJvbURvbSh0YWJsZSksICd0ZCx0aCxjYXB0aW9uJykubWFwKGUgPT4gZS5kb20pO1xuICAgICAgY29uc3QgY29ybmVycyA9IGZpbHRlciQ1KGdldENvcm5lcnMoZ2V0WUF4aXNWYWx1ZSwgY2VsbHMpLCBjb3JuZXIgPT4gaXNUYXJnZXRDb3JuZXIoY29ybmVyLCB5KSk7XG4gICAgICByZXR1cm4gZmluZENsb3Nlc3RDb3JuZXIoY29ybmVycywgeCwgeSkubWFwKGNvcm5lciA9PiBjb3JuZXIuY2VsbCk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRCb3R0b21WYWx1ZSA9IHJlY3QgPT4gcmVjdC5ib3R0b207XG4gICAgY29uc3QgZ2V0VG9wVmFsdWUgPSByZWN0ID0+IHJlY3QudG9wO1xuICAgIGNvbnN0IGlzQWJvdmUgPSAoY29ybmVyLCB5KSA9PiBjb3JuZXIueSA8IHk7XG4gICAgY29uc3QgaXNCZWxvdyA9IChjb3JuZXIsIHkpID0+IGNvcm5lci55ID4geTtcbiAgICBjb25zdCBnZXRDbG9zZXN0Q2VsbEFib3ZlID0gY3VycnkoZ2V0Q2xvc2VzdENlbGwsIGdldEJvdHRvbVZhbHVlLCBpc0Fib3ZlKTtcbiAgICBjb25zdCBnZXRDbG9zZXN0Q2VsbEJlbG93ID0gY3VycnkoZ2V0Q2xvc2VzdENlbGwsIGdldFRvcFZhbHVlLCBpc0JlbG93KTtcbiAgICBjb25zdCBmaW5kQ2xvc2VzdFBvc2l0aW9uSW5BYm92ZUNlbGwgPSAodGFibGUsIHBvcykgPT4gaGVhZChwb3MuZ2V0Q2xpZW50UmVjdHMoKSkuYmluZChyZWN0ID0+IGdldENsb3Nlc3RDZWxsQWJvdmUodGFibGUsIHJlY3QubGVmdCwgcmVjdC50b3ApKS5iaW5kKGNlbGwgPT4gZmluZENsb3Nlc3RIb3Jpem9udGFsUG9zaXRpb24oZ2V0TGFzdExpbmVQb3NpdGlvbnMoY2VsbCksIHBvcykpO1xuICAgIGNvbnN0IGZpbmRDbG9zZXN0UG9zaXRpb25JbkJlbG93Q2VsbCA9ICh0YWJsZSwgcG9zKSA9PiBsYXN0JDMocG9zLmdldENsaWVudFJlY3RzKCkpLmJpbmQocmVjdCA9PiBnZXRDbG9zZXN0Q2VsbEJlbG93KHRhYmxlLCByZWN0LmxlZnQsIHJlY3QudG9wKSkuYmluZChjZWxsID0+IGZpbmRDbG9zZXN0SG9yaXpvbnRhbFBvc2l0aW9uKGdldEZpcnN0TGluZVBvc2l0aW9ucyhjZWxsKSwgcG9zKSk7XG5cbiAgICBjb25zdCBoYXNOZXh0QnJlYWsgPSAoZ2V0UG9zaXRpb25zVW50aWwsIHNjb3BlLCBsaW5lSW5mbykgPT4gbGluZUluZm8uYnJlYWtBdC5leGlzdHMoYnJlYWtQb3MgPT4gZ2V0UG9zaXRpb25zVW50aWwoc2NvcGUsIGJyZWFrUG9zKS5icmVha0F0LmlzU29tZSgpKTtcbiAgICBjb25zdCBzdGFydHNXaXRoV3JhcEJyZWFrID0gbGluZUluZm8gPT4gbGluZUluZm8uYnJlYWtUeXBlID09PSBCcmVha1R5cGUuV3JhcCAmJiBsaW5lSW5mby5wb3NpdGlvbnMubGVuZ3RoID09PSAwO1xuICAgIGNvbnN0IHN0YXJ0c1dpdGhCckJyZWFrID0gbGluZUluZm8gPT4gbGluZUluZm8uYnJlYWtUeXBlID09PSBCcmVha1R5cGUuQnIgJiYgbGluZUluZm8ucG9zaXRpb25zLmxlbmd0aCA9PT0gMTtcbiAgICBjb25zdCBpc0F0VGFibGVDZWxsTGluZSA9IChnZXRQb3NpdGlvbnNVbnRpbCwgc2NvcGUsIHBvcykgPT4ge1xuICAgICAgY29uc3QgbGluZUluZm8gPSBnZXRQb3NpdGlvbnNVbnRpbChzY29wZSwgcG9zKTtcbiAgICAgIGlmIChzdGFydHNXaXRoV3JhcEJyZWFrKGxpbmVJbmZvKSB8fCAhaXNCciQ2KHBvcy5nZXROb2RlKCkpICYmIHN0YXJ0c1dpdGhCckJyZWFrKGxpbmVJbmZvKSkge1xuICAgICAgICByZXR1cm4gIWhhc05leHRCcmVhayhnZXRQb3NpdGlvbnNVbnRpbCwgc2NvcGUsIGxpbmVJbmZvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBsaW5lSW5mby5icmVha0F0LmlzTm9uZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaXNBdEZpcnN0VGFibGVDZWxsTGluZSA9IGN1cnJ5KGlzQXRUYWJsZUNlbGxMaW5lLCBnZXRQb3NpdGlvbnNVbnRpbFByZXZpb3VzTGluZSk7XG4gICAgY29uc3QgaXNBdExhc3RUYWJsZUNlbGxMaW5lID0gY3VycnkoaXNBdFRhYmxlQ2VsbExpbmUsIGdldFBvc2l0aW9uc1VudGlsTmV4dExpbmUpO1xuICAgIGNvbnN0IGlzQ2FyZXRBdFN0YXJ0T3JFbmRPZlRhYmxlID0gKGZvcndhcmQsIHJuZywgdGFibGUpID0+IHtcbiAgICAgIGNvbnN0IGNhcmV0UG9zID0gQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChybmcpO1xuICAgICAgcmV0dXJuIHBvc2l0aW9uSW4oIWZvcndhcmQsIHRhYmxlKS5leGlzdHMocG9zID0+IHBvcy5pc0VxdWFsKGNhcmV0UG9zKSk7XG4gICAgfTtcbiAgICBjb25zdCBuYXZpZ2F0ZUhvcml6b250YWxseSA9IChlZGl0b3IsIGZvcndhcmQsIHRhYmxlLCBfdGQpID0+IHtcbiAgICAgIGNvbnN0IHJuZyA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSBmb3J3YXJkID8gMSA6IC0xO1xuICAgICAgaWYgKGlzRmFrZUNhcmV0VGFibGVCcm93c2VyKCkgJiYgaXNDYXJldEF0U3RhcnRPckVuZE9mVGFibGUoZm9yd2FyZCwgcm5nLCB0YWJsZSkpIHtcbiAgICAgICAgc2hvd0NhcmV0KGRpcmVjdGlvbiwgZWRpdG9yLCB0YWJsZSwgIWZvcndhcmQsIGZhbHNlKS5lYWNoKG5ld1JuZyA9PiB7XG4gICAgICAgICAgbW92ZVRvUmFuZ2UoZWRpdG9yLCBuZXdSbmcpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBjb25zdCBnZXRDbG9zZXN0QWJvdmVQb3NpdGlvbiA9IChyb290LCB0YWJsZSwgc3RhcnQpID0+IGZpbmRDbG9zZXN0UG9zaXRpb25JbkFib3ZlQ2VsbCh0YWJsZSwgc3RhcnQpLm9yVGh1bmsoKCkgPT4gaGVhZChzdGFydC5nZXRDbGllbnRSZWN0cygpKS5iaW5kKHJlY3QgPT4gZmluZENsb3Nlc3RIb3Jpem9udGFsUG9zaXRpb25Gcm9tUG9pbnQoZ2V0UG9zaXRpb25zQWJvdmUocm9vdCwgQ2FyZXRQb3NpdGlvbi5iZWZvcmUodGFibGUpKSwgcmVjdC5sZWZ0KSkpLmdldE9yKENhcmV0UG9zaXRpb24uYmVmb3JlKHRhYmxlKSk7XG4gICAgY29uc3QgZ2V0Q2xvc2VzdEJlbG93UG9zaXRpb24gPSAocm9vdCwgdGFibGUsIHN0YXJ0KSA9PiBmaW5kQ2xvc2VzdFBvc2l0aW9uSW5CZWxvd0NlbGwodGFibGUsIHN0YXJ0KS5vclRodW5rKCgpID0+IGhlYWQoc3RhcnQuZ2V0Q2xpZW50UmVjdHMoKSkuYmluZChyZWN0ID0+IGZpbmRDbG9zZXN0SG9yaXpvbnRhbFBvc2l0aW9uRnJvbVBvaW50KGdldFBvc2l0aW9uc0JlbG93KHJvb3QsIENhcmV0UG9zaXRpb24uYWZ0ZXIodGFibGUpKSwgcmVjdC5sZWZ0KSkpLmdldE9yKENhcmV0UG9zaXRpb24uYWZ0ZXIodGFibGUpKTtcbiAgICBjb25zdCBnZXRUYWJsZSA9IChwcmV2aW91cywgcG9zKSA9PiB7XG4gICAgICBjb25zdCBub2RlID0gcG9zLmdldE5vZGUocHJldmlvdXMpO1xuICAgICAgcmV0dXJuIGlzVGFibGUkMihub2RlKSA/IE9wdGlvbmFsLnNvbWUobm9kZSkgOiBPcHRpb25hbC5ub25lKCk7XG4gICAgfTtcbiAgICBjb25zdCByZW5kZXJCbG9jayA9IChkb3duLCBlZGl0b3IsIHRhYmxlKSA9PiB7XG4gICAgICBlZGl0b3IudW5kb01hbmFnZXIudHJhbnNhY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBpbnNlcnRGbiA9IGRvd24gPyBhZnRlciQ0IDogYmVmb3JlJDM7XG4gICAgICAgIGNvbnN0IHJuZyA9IGluc2VydEVtcHR5TGluZShlZGl0b3IsIFN1Z2FyRWxlbWVudC5mcm9tRG9tKHRhYmxlKSwgaW5zZXJ0Rm4pO1xuICAgICAgICBtb3ZlVG9SYW5nZShlZGl0b3IsIHJuZyk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IG1vdmVDYXJldCA9IChlZGl0b3IsIGRvd24sIHBvcykgPT4ge1xuICAgICAgY29uc3QgdGFibGUgPSBkb3duID8gZ2V0VGFibGUodHJ1ZSwgcG9zKSA6IGdldFRhYmxlKGZhbHNlLCBwb3MpO1xuICAgICAgY29uc3QgbGFzdCA9IGRvd24gPT09IGZhbHNlO1xuICAgICAgdGFibGUuZm9sZCgoKSA9PiBtb3ZlVG9SYW5nZShlZGl0b3IsIHBvcy50b1JhbmdlKCkpLCB0YWJsZSA9PiBwb3NpdGlvbkluKGxhc3QsIGVkaXRvci5nZXRCb2R5KCkpLmZpbHRlcihsYXN0UG9zID0+IGxhc3RQb3MuaXNFcXVhbChwb3MpKS5mb2xkKCgpID0+IG1vdmVUb1JhbmdlKGVkaXRvciwgcG9zLnRvUmFuZ2UoKSksIF8gPT4gcmVuZGVyQmxvY2soZG93biwgZWRpdG9yLCB0YWJsZSkpKTtcbiAgICB9O1xuICAgIGNvbnN0IG5hdmlnYXRlVmVydGljYWxseSA9IChlZGl0b3IsIGRvd24sIHRhYmxlLCB0ZCkgPT4ge1xuICAgICAgY29uc3Qgcm5nID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgIGNvbnN0IHBvcyA9IENhcmV0UG9zaXRpb24uZnJvbVJhbmdlU3RhcnQocm5nKTtcbiAgICAgIGNvbnN0IHJvb3QgPSBlZGl0b3IuZ2V0Qm9keSgpO1xuICAgICAgaWYgKCFkb3duICYmIGlzQXRGaXJzdFRhYmxlQ2VsbExpbmUodGQsIHBvcykpIHtcbiAgICAgICAgY29uc3QgbmV3UG9zID0gZ2V0Q2xvc2VzdEFib3ZlUG9zaXRpb24ocm9vdCwgdGFibGUsIHBvcyk7XG4gICAgICAgIG1vdmVDYXJldChlZGl0b3IsIGRvd24sIG5ld1Bvcyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChkb3duICYmIGlzQXRMYXN0VGFibGVDZWxsTGluZSh0ZCwgcG9zKSkge1xuICAgICAgICBjb25zdCBuZXdQb3MgPSBnZXRDbG9zZXN0QmVsb3dQb3NpdGlvbihyb290LCB0YWJsZSwgcG9zKTtcbiAgICAgICAgbW92ZUNhcmV0KGVkaXRvciwgZG93biwgbmV3UG9zKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBtb3ZlJDEgPSAoZWRpdG9yLCBmb3J3YXJkLCBtb3ZlcikgPT4gT3B0aW9uYWwuZnJvbShlZGl0b3IuZG9tLmdldFBhcmVudChlZGl0b3Iuc2VsZWN0aW9uLmdldE5vZGUoKSwgJ3RkLHRoJykpLmJpbmQodGQgPT4gT3B0aW9uYWwuZnJvbShlZGl0b3IuZG9tLmdldFBhcmVudCh0ZCwgJ3RhYmxlJykpLm1hcCh0YWJsZSA9PiBtb3ZlcihlZGl0b3IsIGZvcndhcmQsIHRhYmxlLCB0ZCkpKS5nZXRPcihmYWxzZSk7XG4gICAgY29uc3QgbW92ZUggPSAoZWRpdG9yLCBmb3J3YXJkKSA9PiBtb3ZlJDEoZWRpdG9yLCBmb3J3YXJkLCBuYXZpZ2F0ZUhvcml6b250YWxseSk7XG4gICAgY29uc3QgbW92ZVYgPSAoZWRpdG9yLCBmb3J3YXJkKSA9PiBtb3ZlJDEoZWRpdG9yLCBmb3J3YXJkLCBuYXZpZ2F0ZVZlcnRpY2FsbHkpO1xuICAgIGNvbnN0IGdldENlbGxGaXJzdEN1cnNvclBvc2l0aW9uID0gY2VsbCA9PiB7XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSBTaW1TZWxlY3Rpb24uZXhhY3QoY2VsbCwgMCwgY2VsbCwgMCk7XG4gICAgICByZXR1cm4gdG9OYXRpdmUoc2VsZWN0aW9uKTtcbiAgICB9O1xuICAgIGNvbnN0IHRhYkdvID0gKGVkaXRvciwgaXNSb290LCBjZWxsKSA9PiB7XG4gICAgICByZXR1cm4gY2VsbC5mb2xkKE9wdGlvbmFsLm5vbmUsIE9wdGlvbmFsLm5vbmUsIChfY3VycmVudCwgbmV4dCkgPT4ge1xuICAgICAgICByZXR1cm4gZmlyc3QobmV4dCkubWFwKGNlbGwgPT4ge1xuICAgICAgICAgIHJldHVybiBnZXRDZWxsRmlyc3RDdXJzb3JQb3NpdGlvbihjZWxsKTtcbiAgICAgICAgfSk7XG4gICAgICB9LCBjdXJyZW50ID0+IHtcbiAgICAgICAgZWRpdG9yLmV4ZWNDb21tYW5kKCdtY2VUYWJsZUluc2VydFJvd0FmdGVyJyk7XG4gICAgICAgIHJldHVybiB0YWJGb3J3YXJkKGVkaXRvciwgaXNSb290LCBjdXJyZW50KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgdGFiRm9yd2FyZCA9IChlZGl0b3IsIGlzUm9vdCwgY2VsbCkgPT4gdGFiR28oZWRpdG9yLCBpc1Jvb3QsIG5leHQoY2VsbCwgaXNFZGl0YWJsZSQzKSk7XG4gICAgY29uc3QgdGFiQmFja3dhcmQgPSAoZWRpdG9yLCBpc1Jvb3QsIGNlbGwpID0+IHRhYkdvKGVkaXRvciwgaXNSb290LCBwcmV2KGNlbGwsIGlzRWRpdGFibGUkMykpO1xuICAgIGNvbnN0IGhhbmRsZVRhYiA9IChlZGl0b3IsIGZvcndhcmQpID0+IHtcbiAgICAgIGNvbnN0IHJvb3RFbGVtZW50cyA9IFtcbiAgICAgICAgJ3RhYmxlJyxcbiAgICAgICAgJ2xpJyxcbiAgICAgICAgJ2RsJ1xuICAgICAgXTtcbiAgICAgIGNvbnN0IGJvZHkgPSBTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3IuZ2V0Qm9keSgpKTtcbiAgICAgIGNvbnN0IGlzUm9vdCA9IGVsZW1lbnQgPT4ge1xuICAgICAgICBjb25zdCBuYW1lJDEgPSBuYW1lKGVsZW1lbnQpO1xuICAgICAgICByZXR1cm4gZXEoZWxlbWVudCwgYm9keSkgfHwgY29udGFpbnMkMihyb290RWxlbWVudHMsIG5hbWUkMSk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgcm5nID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKCFmb3J3YXJkID8gcm5nLnN0YXJ0Q29udGFpbmVyIDogcm5nLmVuZENvbnRhaW5lcik7XG4gICAgICByZXR1cm4gY2VsbChjb250YWluZXIsIGlzUm9vdCkubWFwKGNlbGwgPT4ge1xuICAgICAgICB0YWJsZShjZWxsLCBpc1Jvb3QpLmVhY2godGFibGUgPT4ge1xuICAgICAgICAgIGVkaXRvci5tb2RlbC50YWJsZS5jbGVhclNlbGVjdGVkQ2VsbHModGFibGUuZG9tKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVkaXRvci5zZWxlY3Rpb24uY29sbGFwc2UoIWZvcndhcmQpO1xuICAgICAgICBjb25zdCBuYXZpZ2F0aW9uID0gIWZvcndhcmQgPyB0YWJCYWNrd2FyZCA6IHRhYkZvcndhcmQ7XG4gICAgICAgIGNvbnN0IHJuZyA9IG5hdmlnYXRpb24oZWRpdG9yLCBpc1Jvb3QsIGNlbGwpO1xuICAgICAgICBybmcuZWFjaChyYW5nZSA9PiB7XG4gICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRSbmcocmFuZ2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KS5nZXRPcihmYWxzZSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGV4ZWN1dGVLZXlkb3duT3ZlcnJpZGUkNCA9IChlZGl0b3IsIGNhcmV0LCBldnQpID0+IHtcbiAgICAgIGNvbnN0IGlzTWFjID0gRW52Lm9zLmlzTWFjT1MoKSB8fCBFbnYub3MuaXNpT1MoKTtcbiAgICAgIGV4ZWN1dGUoW1xuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuUklHSFQsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24obW92ZUgkMiwgZWRpdG9yLCB0cnVlKVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuTEVGVCxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihtb3ZlSCQyLCBlZGl0b3IsIGZhbHNlKVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuVVAsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24obW92ZVYkMywgZWRpdG9yLCBmYWxzZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkRPV04sXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24obW92ZVYkMywgZWRpdG9yLCB0cnVlKVxuICAgICAgICB9LFxuICAgICAgICAuLi5pc01hYyA/IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBrZXlDb2RlOiBWSy5VUCxcbiAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uKHNlbGVjdFRvRW5kUG9pbnQsIGVkaXRvciwgZmFsc2UpLFxuICAgICAgICAgICAgbWV0YUtleTogdHJ1ZSxcbiAgICAgICAgICAgIHNoaWZ0S2V5OiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBrZXlDb2RlOiBWSy5ET1dOLFxuICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24oc2VsZWN0VG9FbmRQb2ludCwgZWRpdG9yLCB0cnVlKSxcbiAgICAgICAgICAgIG1ldGFLZXk6IHRydWUsXG4gICAgICAgICAgICBzaGlmdEtleTogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgXSA6IFtdLFxuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuUklHSFQsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24obW92ZUgsIGVkaXRvciwgdHJ1ZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkxFRlQsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24obW92ZUgsIGVkaXRvciwgZmFsc2UpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5VUCxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihtb3ZlViwgZWRpdG9yLCBmYWxzZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkRPV04sXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24obW92ZVYsIGVkaXRvciwgdHJ1ZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLlJJR0hULFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKG1vdmVIJDEsIGVkaXRvciwgdHJ1ZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkxFRlQsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24obW92ZUgkMSwgZWRpdG9yLCBmYWxzZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLlVQLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKG1vdmVWJDEsIGVkaXRvciwgZmFsc2UpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5ET1dOLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKG1vdmVWJDEsIGVkaXRvciwgdHJ1ZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLlJJR0hULFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKG1vdmUkMiwgZWRpdG9yLCBjYXJldCwgdHJ1ZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkxFRlQsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24obW92ZSQyLCBlZGl0b3IsIGNhcmV0LCBmYWxzZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLlJJR0hULFxuICAgICAgICAgIGN0cmxLZXk6ICFpc01hYyxcbiAgICAgICAgICBhbHRLZXk6IGlzTWFjLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKG1vdmVOZXh0V29yZCwgZWRpdG9yLCBjYXJldClcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkxFRlQsXG4gICAgICAgICAgY3RybEtleTogIWlzTWFjLFxuICAgICAgICAgIGFsdEtleTogaXNNYWMsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24obW92ZVByZXZXb3JkLCBlZGl0b3IsIGNhcmV0KVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuVVAsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24obW92ZVYkMiwgZWRpdG9yLCBmYWxzZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkRPV04sXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24obW92ZVYkMiwgZWRpdG9yLCB0cnVlKVxuICAgICAgICB9XG4gICAgICBdLCBldnQpLmVhY2goXyA9PiB7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBzZXR1cCRrID0gKGVkaXRvciwgY2FyZXQpID0+IHtcbiAgICAgIGVkaXRvci5vbigna2V5ZG93bicsIGV2dCA9PiB7XG4gICAgICAgIGlmICghZXZ0LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgZXhlY3V0ZUtleWRvd25PdmVycmlkZSQ0KGVkaXRvciwgY2FyZXQsIGV2dCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBwb2ludCA9IChjb250YWluZXIsIG9mZnNldCkgPT4gKHtcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIG9mZnNldFxuICAgIH0pO1xuXG4gICAgY29uc3QgRE9NJDcgPSBET01VdGlscy5ET007XG4gICAgY29uc3QgYWx3YXlzTmV4dCA9IHN0YXJ0Tm9kZSA9PiBub2RlID0+IHN0YXJ0Tm9kZSA9PT0gbm9kZSA/IC0xIDogMDtcbiAgICBjb25zdCBpc0JvdW5kYXJ5ID0gZG9tID0+IG5vZGUgPT4gZG9tLmlzQmxvY2sobm9kZSkgfHwgY29udGFpbnMkMihbXG4gICAgICAnQlInLFxuICAgICAgJ0lNRycsXG4gICAgICAnSFInLFxuICAgICAgJ0lOUFVUJ1xuICAgIF0sIG5vZGUubm9kZU5hbWUpIHx8IGRvbS5nZXRDb250ZW50RWRpdGFibGUobm9kZSkgPT09ICdmYWxzZSc7XG4gICAgY29uc3QgdGV4dEJlZm9yZSA9IChub2RlLCBvZmZzZXQsIHJvb3ROb2RlKSA9PiB7XG4gICAgICBpZiAoaXNUZXh0JGEobm9kZSkgJiYgb2Zmc2V0ID49IDApIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUocG9pbnQobm9kZSwgb2Zmc2V0KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0ZXh0U2Vla2VyID0gVGV4dFNlZWtlcihET00kNyk7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5mcm9tKHRleHRTZWVrZXIuYmFja3dhcmRzKG5vZGUsIG9mZnNldCwgYWx3YXlzTmV4dChub2RlKSwgcm9vdE5vZGUpKS5tYXAocHJldiA9PiBwb2ludChwcmV2LmNvbnRhaW5lciwgcHJldi5jb250YWluZXIuZGF0YS5sZW5ndGgpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHRleHRBZnRlciA9IChub2RlLCBvZmZzZXQsIHJvb3ROb2RlKSA9PiB7XG4gICAgICBpZiAoaXNUZXh0JGEobm9kZSkgJiYgb2Zmc2V0ID49IG5vZGUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKHBvaW50KG5vZGUsIG9mZnNldCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdGV4dFNlZWtlciA9IFRleHRTZWVrZXIoRE9NJDcpO1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuZnJvbSh0ZXh0U2Vla2VyLmZvcndhcmRzKG5vZGUsIG9mZnNldCwgYWx3YXlzTmV4dChub2RlKSwgcm9vdE5vZGUpKS5tYXAocHJldiA9PiBwb2ludChwcmV2LmNvbnRhaW5lciwgMCkpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc2NhbkxlZnQgPSAobm9kZSwgb2Zmc2V0LCByb290Tm9kZSkgPT4ge1xuICAgICAgaWYgKCFpc1RleHQkYShub2RlKSkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfVxuICAgICAgY29uc3QgdGV4dCA9IG5vZGUuZGF0YTtcbiAgICAgIGlmIChvZmZzZXQgPj0gMCAmJiBvZmZzZXQgPD0gdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUocG9pbnQobm9kZSwgb2Zmc2V0KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0ZXh0U2Vla2VyID0gVGV4dFNlZWtlcihET00kNyk7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5mcm9tKHRleHRTZWVrZXIuYmFja3dhcmRzKG5vZGUsIG9mZnNldCwgYWx3YXlzTmV4dChub2RlKSwgcm9vdE5vZGUpKS5iaW5kKHByZXYgPT4ge1xuICAgICAgICAgIGNvbnN0IHByZXZUZXh0ID0gcHJldi5jb250YWluZXIuZGF0YTtcbiAgICAgICAgICByZXR1cm4gc2NhbkxlZnQocHJldi5jb250YWluZXIsIG9mZnNldCArIHByZXZUZXh0Lmxlbmd0aCwgcm9vdE5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNjYW5SaWdodCA9IChub2RlLCBvZmZzZXQsIHJvb3ROb2RlKSA9PiB7XG4gICAgICBpZiAoIWlzVGV4dCRhKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9XG4gICAgICBjb25zdCB0ZXh0ID0gbm9kZS5kYXRhO1xuICAgICAgaWYgKG9mZnNldCA8PSB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShwb2ludChub2RlLCBvZmZzZXQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHRleHRTZWVrZXIgPSBUZXh0U2Vla2VyKERPTSQ3KTtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLmZyb20odGV4dFNlZWtlci5mb3J3YXJkcyhub2RlLCBvZmZzZXQsIGFsd2F5c05leHQobm9kZSksIHJvb3ROb2RlKSkuYmluZChuZXh0ID0+IHNjYW5SaWdodChuZXh0LmNvbnRhaW5lciwgb2Zmc2V0IC0gdGV4dC5sZW5ndGgsIHJvb3ROb2RlKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZXBlYXRMZWZ0ID0gKGRvbSwgbm9kZSwgb2Zmc2V0LCBwcm9jZXNzLCByb290Tm9kZSkgPT4ge1xuICAgICAgY29uc3Qgc2VhcmNoID0gVGV4dFNlZWtlcihkb20sIGlzQm91bmRhcnkoZG9tKSk7XG4gICAgICByZXR1cm4gT3B0aW9uYWwuZnJvbShzZWFyY2guYmFja3dhcmRzKG5vZGUsIG9mZnNldCwgcHJvY2Vzcywgcm9vdE5vZGUpKTtcbiAgICB9O1xuXG4gICAgY29uc3QgaXNWYWxpZFRleHRSYW5nZSA9IHJuZyA9PiBybmcuY29sbGFwc2VkICYmIGlzVGV4dCRhKHJuZy5zdGFydENvbnRhaW5lcik7XG4gICAgY29uc3QgZ2V0VGV4dCA9IHJuZyA9PiB0cmltJDEocm5nLnRvU3RyaW5nKCkucmVwbGFjZSgvXFx1MDBBMC9nLCAnICcpKTtcbiAgICBjb25zdCBpc1doaXRlc3BhY2UgPSBjaHIgPT4gY2hyICE9PSAnJyAmJiAnIFxceEEwXFxmXFxuXFxyXFx0XFx4MEInLmluZGV4T2YoY2hyKSAhPT0gLTE7XG5cbiAgICBjb25zdCBzdHJpcFRyaWdnZXIgPSAodGV4dCwgdHJpZ2dlcikgPT4gdGV4dC5zdWJzdHJpbmcodHJpZ2dlci5sZW5ndGgpO1xuICAgIGNvbnN0IGZpbmRUcmlnZ2VyID0gKHRleHQsIGluZGV4LCB0cmlnZ2VyKSA9PiB7XG4gICAgICBsZXQgaTtcbiAgICAgIGNvbnN0IGZpcnN0Q2hhciA9IHRyaWdnZXIuY2hhckF0KDApO1xuICAgICAgZm9yIChpID0gaW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBjaGFyID0gdGV4dC5jaGFyQXQoaSk7XG4gICAgICAgIGlmIChpc1doaXRlc3BhY2UoY2hhcikpIHtcbiAgICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaXJzdENoYXIgPT09IGNoYXIgJiYgY29udGFpbnMkMSh0ZXh0LCB0cmlnZ2VyLCBpLCBpbmRleCkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoaSk7XG4gICAgfTtcbiAgICBjb25zdCBmaW5kU3RhcnQgPSAoZG9tLCBpbml0UmFuZ2UsIHRyaWdnZXIsIG1pbkNoYXJzID0gMCkgPT4ge1xuICAgICAgaWYgKCFpc1ZhbGlkVGV4dFJhbmdlKGluaXRSYW5nZSkpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJ1ZmZlciA9IHtcbiAgICAgICAgdGV4dDogJycsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfTtcbiAgICAgIGNvbnN0IGZpbmRUcmlnZ2VySW5kZXggPSAoZWxlbWVudCwgb2Zmc2V0LCB0ZXh0KSA9PiB7XG4gICAgICAgIGJ1ZmZlci50ZXh0ID0gdGV4dCArIGJ1ZmZlci50ZXh0O1xuICAgICAgICBidWZmZXIub2Zmc2V0ICs9IG9mZnNldDtcbiAgICAgICAgcmV0dXJuIGZpbmRUcmlnZ2VyKGJ1ZmZlci50ZXh0LCBidWZmZXIub2Zmc2V0LCB0cmlnZ2VyKS5nZXRPcihvZmZzZXQpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHJvb3QgPSBkb20uZ2V0UGFyZW50KGluaXRSYW5nZS5zdGFydENvbnRhaW5lciwgZG9tLmlzQmxvY2spIHx8IGRvbS5nZXRSb290KCk7XG4gICAgICByZXR1cm4gcmVwZWF0TGVmdChkb20sIGluaXRSYW5nZS5zdGFydENvbnRhaW5lciwgaW5pdFJhbmdlLnN0YXJ0T2Zmc2V0LCBmaW5kVHJpZ2dlckluZGV4LCByb290KS5iaW5kKHNwb3QgPT4ge1xuICAgICAgICBjb25zdCByYW5nZSA9IGluaXRSYW5nZS5jbG9uZVJhbmdlKCk7XG4gICAgICAgIHJhbmdlLnNldFN0YXJ0KHNwb3QuY29udGFpbmVyLCBzcG90Lm9mZnNldCk7XG4gICAgICAgIHJhbmdlLnNldEVuZChpbml0UmFuZ2UuZW5kQ29udGFpbmVyLCBpbml0UmFuZ2UuZW5kT2Zmc2V0KTtcbiAgICAgICAgaWYgKHJhbmdlLmNvbGxhcHNlZCkge1xuICAgICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGV4dCA9IGdldFRleHQocmFuZ2UpO1xuICAgICAgICBjb25zdCB0cmlnZ2VySW5kZXggPSB0ZXh0Lmxhc3RJbmRleE9mKHRyaWdnZXIpO1xuICAgICAgICBpZiAodHJpZ2dlckluZGV4ICE9PSAwIHx8IHN0cmlwVHJpZ2dlcih0ZXh0LCB0cmlnZ2VyKS5sZW5ndGggPCBtaW5DaGFycykge1xuICAgICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoe1xuICAgICAgICAgICAgdGV4dDogc3RyaXBUcmlnZ2VyKHRleHQsIHRyaWdnZXIpLFxuICAgICAgICAgICAgcmFuZ2UsXG4gICAgICAgICAgICB0cmlnZ2VyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgZ2V0Q29udGV4dCA9IChkb20sIGluaXRSYW5nZSwgdHJpZ2dlciwgbWluQ2hhcnMgPSAwKSA9PiBkZXRlY3QkMShTdWdhckVsZW1lbnQuZnJvbURvbShpbml0UmFuZ2Uuc3RhcnRDb250YWluZXIpKS5mb2xkKCgpID0+IGZpbmRTdGFydChkb20sIGluaXRSYW5nZSwgdHJpZ2dlciwgbWluQ2hhcnMpLCBlbG0gPT4ge1xuICAgICAgY29uc3QgcmFuZ2UgPSBkb20uY3JlYXRlUm5nKCk7XG4gICAgICByYW5nZS5zZWxlY3ROb2RlKGVsbS5kb20pO1xuICAgICAgY29uc3QgdGV4dCA9IGdldFRleHQocmFuZ2UpO1xuICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoe1xuICAgICAgICByYW5nZSxcbiAgICAgICAgdGV4dDogc3RyaXBUcmlnZ2VyKHRleHQsIHRyaWdnZXIpLFxuICAgICAgICB0cmlnZ2VyXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGlzVGV4dCQxID0gbm9kZSA9PiBub2RlLm5vZGVUeXBlID09PSBURVhUO1xuICAgIGNvbnN0IGlzRWxlbWVudCA9IG5vZGUgPT4gbm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVDtcbiAgICBjb25zdCB0b0xhc3QgPSBub2RlID0+IHtcbiAgICAgIGlmIChpc1RleHQkMShub2RlKSkge1xuICAgICAgICByZXR1cm4gcG9pbnQobm9kZSwgbm9kZS5kYXRhLmxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGROb2RlcztcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuLmxlbmd0aCA+IDAgPyB0b0xhc3QoY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0pIDogcG9pbnQobm9kZSwgY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHRvTGVhZiA9IChub2RlLCBvZmZzZXQpID0+IHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZE5vZGVzO1xuICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDAgJiYgb2Zmc2V0IDwgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0b0xlYWYoY2hpbGRyZW5bb2Zmc2V0XSwgMCk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDAgJiYgaXNFbGVtZW50KG5vZGUpICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0b0xhc3QoY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBvaW50KG5vZGUsIG9mZnNldCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGlzUHJldmlvdXNDaGFyQ29udGVudCA9IChkb20sIGxlYWYpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IHJvb3QgPSAoX2EgPSBkb20uZ2V0UGFyZW50KGxlYWYuY29udGFpbmVyLCBkb20uaXNCbG9jaykpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRvbS5nZXRSb290KCk7XG4gICAgICByZXR1cm4gcmVwZWF0TGVmdChkb20sIGxlYWYuY29udGFpbmVyLCBsZWFmLm9mZnNldCwgKF9lbGVtZW50LCBvZmZzZXQpID0+IG9mZnNldCA9PT0gMCA/IC0xIDogb2Zmc2V0LCByb290KS5maWx0ZXIoc3BvdCA9PiB7XG4gICAgICAgIGNvbnN0IGNoYXIgPSBzcG90LmNvbnRhaW5lci5kYXRhLmNoYXJBdChzcG90Lm9mZnNldCAtIDEpO1xuICAgICAgICByZXR1cm4gIWlzV2hpdGVzcGFjZShjaGFyKTtcbiAgICAgIH0pLmlzU29tZSgpO1xuICAgIH07XG4gICAgY29uc3QgaXNTdGFydE9mV29yZCA9IGRvbSA9PiBybmcgPT4ge1xuICAgICAgY29uc3QgbGVhZiA9IHRvTGVhZihybmcuc3RhcnRDb250YWluZXIsIHJuZy5zdGFydE9mZnNldCk7XG4gICAgICByZXR1cm4gIWlzUHJldmlvdXNDaGFyQ29udGVudChkb20sIGxlYWYpO1xuICAgIH07XG4gICAgY29uc3QgZ2V0VHJpZ2dlckNvbnRleHQgPSAoZG9tLCBpbml0UmFuZ2UsIGRhdGFiYXNlKSA9PiBmaW5kTWFwKGRhdGFiYXNlLnRyaWdnZXJzLCB0cmlnZ2VyID0+IGdldENvbnRleHQoZG9tLCBpbml0UmFuZ2UsIHRyaWdnZXIpKTtcbiAgICBjb25zdCBsb29rdXAgPSAoZWRpdG9yLCBnZXREYXRhYmFzZSkgPT4ge1xuICAgICAgY29uc3QgZGF0YWJhc2UgPSBnZXREYXRhYmFzZSgpO1xuICAgICAgY29uc3Qgcm5nID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgIHJldHVybiBnZXRUcmlnZ2VyQ29udGV4dChlZGl0b3IuZG9tLCBybmcsIGRhdGFiYXNlKS5iaW5kKGNvbnRleHQgPT4gbG9va3VwV2l0aENvbnRleHQoZWRpdG9yLCBnZXREYXRhYmFzZSwgY29udGV4dCkpO1xuICAgIH07XG4gICAgY29uc3QgbG9va3VwV2l0aENvbnRleHQgPSAoZWRpdG9yLCBnZXREYXRhYmFzZSwgY29udGV4dCwgZmV0Y2hPcHRpb25zID0ge30pID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IGRhdGFiYXNlID0gZ2V0RGF0YWJhc2UoKTtcbiAgICAgIGNvbnN0IHJuZyA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICBjb25zdCBzdGFydFRleHQgPSAoX2EgPSBybmcuc3RhcnRDb250YWluZXIubm9kZVZhbHVlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJztcbiAgICAgIGNvbnN0IGF1dG9jb21wbGV0ZXJzID0gZmlsdGVyJDUoZGF0YWJhc2UubG9va3VwQnlUcmlnZ2VyKGNvbnRleHQudHJpZ2dlciksIGF1dG9jb21wbGV0ZXIgPT4gY29udGV4dC50ZXh0Lmxlbmd0aCA+PSBhdXRvY29tcGxldGVyLm1pbkNoYXJzICYmIGF1dG9jb21wbGV0ZXIubWF0Y2hlcy5nZXRPclRodW5rKCgpID0+IGlzU3RhcnRPZldvcmQoZWRpdG9yLmRvbSkpKGNvbnRleHQucmFuZ2UsIHN0YXJ0VGV4dCwgY29udGV4dC50ZXh0KSk7XG4gICAgICBpZiAoYXV0b2NvbXBsZXRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBsb29rdXBEYXRhID0gUHJvbWlzZS5hbGwobWFwJDMoYXV0b2NvbXBsZXRlcnMsIGFjID0+IHtcbiAgICAgICAgY29uc3QgZmV0Y2hSZXN1bHQgPSBhYy5mZXRjaChjb250ZXh0LnRleHQsIGFjLm1heFJlc3VsdHMsIGZldGNoT3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBmZXRjaFJlc3VsdC50aGVuKHJlc3VsdHMgPT4gKHtcbiAgICAgICAgICBtYXRjaFRleHQ6IGNvbnRleHQudGV4dCxcbiAgICAgICAgICBpdGVtczogcmVzdWx0cyxcbiAgICAgICAgICBjb2x1bW5zOiBhYy5jb2x1bW5zLFxuICAgICAgICAgIG9uQWN0aW9uOiBhYy5vbkFjdGlvbixcbiAgICAgICAgICBoaWdobGlnaHRPbjogYWMuaGlnaGxpZ2h0T25cbiAgICAgICAgfSkpO1xuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoe1xuICAgICAgICBsb29rdXBEYXRhLFxuICAgICAgICBjb250ZXh0XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIFNpbXBsZVJlc3VsdFR5cGU7XG4gICAgKGZ1bmN0aW9uIChTaW1wbGVSZXN1bHRUeXBlKSB7XG4gICAgICBTaW1wbGVSZXN1bHRUeXBlW1NpbXBsZVJlc3VsdFR5cGVbJ0Vycm9yJ10gPSAwXSA9ICdFcnJvcic7XG4gICAgICBTaW1wbGVSZXN1bHRUeXBlW1NpbXBsZVJlc3VsdFR5cGVbJ1ZhbHVlJ10gPSAxXSA9ICdWYWx1ZSc7XG4gICAgfShTaW1wbGVSZXN1bHRUeXBlIHx8IChTaW1wbGVSZXN1bHRUeXBlID0ge30pKSk7XG4gICAgY29uc3QgZm9sZCQxID0gKHJlcywgb25FcnJvciwgb25WYWx1ZSkgPT4gcmVzLnN0eXBlID09PSBTaW1wbGVSZXN1bHRUeXBlLkVycm9yID8gb25FcnJvcihyZXMuc2Vycm9yKSA6IG9uVmFsdWUocmVzLnN2YWx1ZSk7XG4gICAgY29uc3QgcGFydGl0aW9uID0gcmVzdWx0cyA9PiB7XG4gICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgZWFjaCRlKHJlc3VsdHMsIG9iaiA9PiB7XG4gICAgICAgIGZvbGQkMShvYmosIGVyciA9PiBlcnJvcnMucHVzaChlcnIpLCB2YWwgPT4gdmFsdWVzLnB1c2godmFsKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlcyxcbiAgICAgICAgZXJyb3JzXG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgbWFwRXJyb3IgPSAocmVzLCBmKSA9PiB7XG4gICAgICBpZiAocmVzLnN0eXBlID09PSBTaW1wbGVSZXN1bHRUeXBlLkVycm9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3R5cGU6IFNpbXBsZVJlc3VsdFR5cGUuRXJyb3IsXG4gICAgICAgICAgc2Vycm9yOiBmKHJlcy5zZXJyb3IpXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbWFwID0gKHJlcywgZikgPT4ge1xuICAgICAgaWYgKHJlcy5zdHlwZSA9PT0gU2ltcGxlUmVzdWx0VHlwZS5WYWx1ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0eXBlOiBTaW1wbGVSZXN1bHRUeXBlLlZhbHVlLFxuICAgICAgICAgIHN2YWx1ZTogZihyZXMuc3ZhbHVlKVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGJpbmQkMSA9IChyZXMsIGYpID0+IHtcbiAgICAgIGlmIChyZXMuc3R5cGUgPT09IFNpbXBsZVJlc3VsdFR5cGUuVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGYocmVzLnN2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgYmluZEVycm9yID0gKHJlcywgZikgPT4ge1xuICAgICAgaWYgKHJlcy5zdHlwZSA9PT0gU2ltcGxlUmVzdWx0VHlwZS5FcnJvcikge1xuICAgICAgICByZXR1cm4gZihyZXMuc2Vycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzdmFsdWUgPSB2ID0+ICh7XG4gICAgICBzdHlwZTogU2ltcGxlUmVzdWx0VHlwZS5WYWx1ZSxcbiAgICAgIHN2YWx1ZTogdlxuICAgIH0pO1xuICAgIGNvbnN0IHNlcnJvciA9IGUgPT4gKHtcbiAgICAgIHN0eXBlOiBTaW1wbGVSZXN1bHRUeXBlLkVycm9yLFxuICAgICAgc2Vycm9yOiBlXG4gICAgfSk7XG4gICAgY29uc3QgdG9SZXN1bHQgPSByZXMgPT4gZm9sZCQxKHJlcywgUmVzdWx0LmVycm9yLCBSZXN1bHQudmFsdWUpO1xuICAgIGNvbnN0IGZyb21SZXN1bHQgPSByZXMgPT4gcmVzLmZvbGQoc2Vycm9yLCBzdmFsdWUpO1xuICAgIGNvbnN0IFNpbXBsZVJlc3VsdCA9IHtcbiAgICAgIGZyb21SZXN1bHQsXG4gICAgICB0b1Jlc3VsdCxcbiAgICAgIHN2YWx1ZSxcbiAgICAgIHBhcnRpdGlvbixcbiAgICAgIHNlcnJvcixcbiAgICAgIGJpbmQ6IGJpbmQkMSxcbiAgICAgIGJpbmRFcnJvcixcbiAgICAgIG1hcCxcbiAgICAgIG1hcEVycm9yLFxuICAgICAgZm9sZDogZm9sZCQxXG4gICAgfTtcblxuICAgIGNvbnN0IGZvcm1hdE9iaiA9IGlucHV0ID0+IHtcbiAgICAgIHJldHVybiBpc09iamVjdChpbnB1dCkgJiYga2V5cyhpbnB1dCkubGVuZ3RoID4gMTAwID8gJyByZW1vdmVkIGR1ZSB0byBzaXplJyA6IEpTT04uc3RyaW5naWZ5KGlucHV0LCBudWxsLCAyKTtcbiAgICB9O1xuICAgIGNvbnN0IGZvcm1hdEVycm9ycyA9IGVycm9ycyA9PiB7XG4gICAgICBjb25zdCBlcyA9IGVycm9ycy5sZW5ndGggPiAxMCA/IGVycm9ycy5zbGljZSgwLCAxMCkuY29uY2F0KFt7XG4gICAgICAgICAgcGF0aDogW10sXG4gICAgICAgICAgZ2V0RXJyb3JJbmZvOiBjb25zdGFudCgnLi4uIChvbmx5IHNob3dpbmcgZmlyc3QgdGVuIGZhaWx1cmVzKScpXG4gICAgICAgIH1dKSA6IGVycm9ycztcbiAgICAgIHJldHVybiBtYXAkMyhlcywgZSA9PiB7XG4gICAgICAgIHJldHVybiAnRmFpbGVkIHBhdGg6ICgnICsgZS5wYXRoLmpvaW4oJyA+ICcpICsgJylcXG4nICsgZS5nZXRFcnJvckluZm8oKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBudSA9IChwYXRoLCBnZXRFcnJvckluZm8pID0+IHtcbiAgICAgIHJldHVybiBTaW1wbGVSZXN1bHQuc2Vycm9yKFt7XG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBnZXRFcnJvckluZm9cbiAgICAgICAgfV0pO1xuICAgIH07XG4gICAgY29uc3QgbWlzc2luZ1JlcXVpcmVkID0gKHBhdGgsIGtleSwgb2JqKSA9PiBudShwYXRoLCAoKSA9PiAnQ291bGQgbm90IGZpbmQgdmFsaWQgKnJlcXVpcmVkKiB2YWx1ZSBmb3IgXCInICsga2V5ICsgJ1wiIGluICcgKyBmb3JtYXRPYmoob2JqKSk7XG4gICAgY29uc3QgbWlzc2luZ0tleSA9IChwYXRoLCBrZXkpID0+IG51KHBhdGgsICgpID0+ICdDaG9pY2Ugc2NoZW1hIGRpZCBub3QgY29udGFpbiBjaG9pY2Uga2V5OiBcIicgKyBrZXkgKyAnXCInKTtcbiAgICBjb25zdCBtaXNzaW5nQnJhbmNoID0gKHBhdGgsIGJyYW5jaGVzLCBicmFuY2gpID0+IG51KHBhdGgsICgpID0+ICdUaGUgY2hvc2VuIHNjaGVtYTogXCInICsgYnJhbmNoICsgJ1wiIGRpZCBub3QgZXhpc3QgaW4gYnJhbmNoZXM6ICcgKyBmb3JtYXRPYmooYnJhbmNoZXMpKTtcbiAgICBjb25zdCBjdXN0b20gPSAocGF0aCwgZXJyKSA9PiBudShwYXRoLCBjb25zdGFudChlcnIpKTtcblxuICAgIGNvbnN0IGNob29zZUZyb20gPSAocGF0aCwgaW5wdXQsIGJyYW5jaGVzLCBjaCkgPT4ge1xuICAgICAgY29uc3QgZmllbGRzID0gZ2V0JGEoYnJhbmNoZXMsIGNoKTtcbiAgICAgIHJldHVybiBmaWVsZHMuZm9sZCgoKSA9PiBtaXNzaW5nQnJhbmNoKHBhdGgsIGJyYW5jaGVzLCBjaCksIHZwID0+IHZwLmV4dHJhY3QocGF0aC5jb25jYXQoWydicmFuY2g6ICcgKyBjaF0pLCBpbnB1dCkpO1xuICAgIH07XG4gICAgY29uc3QgY2hvb3NlJDEgPSAoa2V5LCBicmFuY2hlcykgPT4ge1xuICAgICAgY29uc3QgZXh0cmFjdCA9IChwYXRoLCBpbnB1dCkgPT4ge1xuICAgICAgICBjb25zdCBjaG9pY2UgPSBnZXQkYShpbnB1dCwga2V5KTtcbiAgICAgICAgcmV0dXJuIGNob2ljZS5mb2xkKCgpID0+IG1pc3NpbmdLZXkocGF0aCwga2V5KSwgY2hvc2VuID0+IGNob29zZUZyb20ocGF0aCwgaW5wdXQsIGJyYW5jaGVzLCBjaG9zZW4pKTtcbiAgICAgIH07XG4gICAgICBjb25zdCB0b1N0cmluZyA9ICgpID0+ICdjaG9vc2VPbignICsga2V5ICsgJykuIFBvc3NpYmxlIHZhbHVlczogJyArIGtleXMoYnJhbmNoZXMpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXh0cmFjdCxcbiAgICAgICAgdG9TdHJpbmdcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IHNoYWxsb3cgPSAob2xkLCBudSkgPT4ge1xuICAgICAgcmV0dXJuIG51O1xuICAgIH07XG4gICAgY29uc3QgZGVlcCA9IChvbGQsIG51KSA9PiB7XG4gICAgICBjb25zdCBib3RoT2JqZWN0cyA9IGlzUGxhaW5PYmplY3Qob2xkKSAmJiBpc1BsYWluT2JqZWN0KG51KTtcbiAgICAgIHJldHVybiBib3RoT2JqZWN0cyA/IGRlZXBNZXJnZShvbGQsIG51KSA6IG51O1xuICAgIH07XG4gICAgY29uc3QgYmFzZU1lcmdlID0gbWVyZ2VyID0+IHtcbiAgICAgIHJldHVybiAoLi4ub2JqZWN0cykgPT4ge1xuICAgICAgICBpZiAob2JqZWN0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IG1lcmdlIHplcm8gb2JqZWN0c2ApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG9iamVjdHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBjdXJPYmplY3QgPSBvYmplY3RzW2pdO1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGN1ck9iamVjdCkge1xuICAgICAgICAgICAgaWYgKGhhcyQyKGN1ck9iamVjdCwga2V5KSkge1xuICAgICAgICAgICAgICByZXRba2V5XSA9IG1lcmdlcihyZXRba2V5XSwgY3VyT2JqZWN0W2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGRlZXBNZXJnZSA9IGJhc2VNZXJnZShkZWVwKTtcbiAgICBjb25zdCBtZXJnZSA9IGJhc2VNZXJnZShzaGFsbG93KTtcblxuICAgIGNvbnN0IHJlcXVpcmVkID0gKCkgPT4gKHtcbiAgICAgIHRhZzogJ3JlcXVpcmVkJyxcbiAgICAgIHByb2Nlc3M6IHt9XG4gICAgfSk7XG4gICAgY29uc3QgZGVmYXVsdGVkVGh1bmsgPSBmYWxsYmFja1RodW5rID0+ICh7XG4gICAgICB0YWc6ICdkZWZhdWx0ZWRUaHVuaycsXG4gICAgICBwcm9jZXNzOiBmYWxsYmFja1RodW5rXG4gICAgfSk7XG4gICAgY29uc3QgZGVmYXVsdGVkJDEgPSBmYWxsYmFjayA9PiBkZWZhdWx0ZWRUaHVuayhjb25zdGFudChmYWxsYmFjaykpO1xuICAgIGNvbnN0IGFzT3B0aW9uID0gKCkgPT4gKHtcbiAgICAgIHRhZzogJ29wdGlvbicsXG4gICAgICBwcm9jZXNzOiB7fVxuICAgIH0pO1xuXG4gICAgY29uc3QgbWVyZ2VWYWx1ZXMgPSAodmFsdWVzLCBiYXNlKSA9PiB2YWx1ZXMubGVuZ3RoID4gMCA/IFNpbXBsZVJlc3VsdC5zdmFsdWUoZGVlcE1lcmdlKGJhc2UsIG1lcmdlLmFwcGx5KHVuZGVmaW5lZCwgdmFsdWVzKSkpIDogU2ltcGxlUmVzdWx0LnN2YWx1ZShiYXNlKTtcbiAgICBjb25zdCBtZXJnZUVycm9ycyA9IGVycm9ycyA9PiBjb21wb3NlKFNpbXBsZVJlc3VsdC5zZXJyb3IsIGZsYXR0ZW4pKGVycm9ycyk7XG4gICAgY29uc3QgY29uc29saWRhdGVPYmogPSAob2JqZWN0cywgYmFzZSkgPT4ge1xuICAgICAgY29uc3QgcGFydGl0aW9uID0gU2ltcGxlUmVzdWx0LnBhcnRpdGlvbihvYmplY3RzKTtcbiAgICAgIHJldHVybiBwYXJ0aXRpb24uZXJyb3JzLmxlbmd0aCA+IDAgPyBtZXJnZUVycm9ycyhwYXJ0aXRpb24uZXJyb3JzKSA6IG1lcmdlVmFsdWVzKHBhcnRpdGlvbi52YWx1ZXMsIGJhc2UpO1xuICAgIH07XG4gICAgY29uc3QgY29uc29saWRhdGVBcnIgPSBvYmplY3RzID0+IHtcbiAgICAgIGNvbnN0IHBhcnRpdGlvbnMgPSBTaW1wbGVSZXN1bHQucGFydGl0aW9uKG9iamVjdHMpO1xuICAgICAgcmV0dXJuIHBhcnRpdGlvbnMuZXJyb3JzLmxlbmd0aCA+IDAgPyBtZXJnZUVycm9ycyhwYXJ0aXRpb25zLmVycm9ycykgOiBTaW1wbGVSZXN1bHQuc3ZhbHVlKHBhcnRpdGlvbnMudmFsdWVzKTtcbiAgICB9O1xuICAgIGNvbnN0IFJlc3VsdENvbWJpbmUgPSB7XG4gICAgICBjb25zb2xpZGF0ZU9iaixcbiAgICAgIGNvbnNvbGlkYXRlQXJyXG4gICAgfTtcblxuICAgIGNvbnN0IGZpZWxkJDEgPSAoa2V5LCBuZXdLZXksIHByZXNlbmNlLCBwcm9wKSA9PiAoe1xuICAgICAgdGFnOiAnZmllbGQnLFxuICAgICAga2V5LFxuICAgICAgbmV3S2V5LFxuICAgICAgcHJlc2VuY2UsXG4gICAgICBwcm9wXG4gICAgfSk7XG4gICAgY29uc3QgY3VzdG9tRmllbGQkMSA9IChuZXdLZXksIGluc3RhbnRpYXRvcikgPT4gKHtcbiAgICAgIHRhZzogJ2N1c3RvbScsXG4gICAgICBuZXdLZXksXG4gICAgICBpbnN0YW50aWF0b3JcbiAgICB9KTtcbiAgICBjb25zdCBmb2xkID0gKHZhbHVlLCBpZkZpZWxkLCBpZkN1c3RvbSkgPT4ge1xuICAgICAgc3dpdGNoICh2YWx1ZS50YWcpIHtcbiAgICAgIGNhc2UgJ2ZpZWxkJzpcbiAgICAgICAgcmV0dXJuIGlmRmllbGQodmFsdWUua2V5LCB2YWx1ZS5uZXdLZXksIHZhbHVlLnByZXNlbmNlLCB2YWx1ZS5wcm9wKTtcbiAgICAgIGNhc2UgJ2N1c3RvbSc6XG4gICAgICAgIHJldHVybiBpZkN1c3RvbSh2YWx1ZS5uZXdLZXksIHZhbHVlLmluc3RhbnRpYXRvcik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHZhbHVlID0gdmFsaWRhdG9yID0+IHtcbiAgICAgIGNvbnN0IGV4dHJhY3QgPSAocGF0aCwgdmFsKSA9PiB7XG4gICAgICAgIHJldHVybiBTaW1wbGVSZXN1bHQuYmluZEVycm9yKHZhbGlkYXRvcih2YWwpLCBlcnIgPT4gY3VzdG9tKHBhdGgsIGVycikpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHRvU3RyaW5nID0gY29uc3RhbnQoJ3ZhbCcpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXh0cmFjdCxcbiAgICAgICAgdG9TdHJpbmdcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBhbnlWYWx1ZSQxID0gdmFsdWUoU2ltcGxlUmVzdWx0LnN2YWx1ZSk7XG5cbiAgICBjb25zdCByZXF1aXJlZEFjY2VzcyA9IChwYXRoLCBvYmosIGtleSwgYnVuZGxlKSA9PiBnZXQkYShvYmosIGtleSkuZm9sZCgoKSA9PiBtaXNzaW5nUmVxdWlyZWQocGF0aCwga2V5LCBvYmopLCBidW5kbGUpO1xuICAgIGNvbnN0IGZhbGxiYWNrQWNjZXNzID0gKG9iaiwga2V5LCBmYWxsYmFjaywgYnVuZGxlKSA9PiB7XG4gICAgICBjb25zdCB2ID0gZ2V0JGEob2JqLCBrZXkpLmdldE9yVGh1bmsoKCkgPT4gZmFsbGJhY2sob2JqKSk7XG4gICAgICByZXR1cm4gYnVuZGxlKHYpO1xuICAgIH07XG4gICAgY29uc3Qgb3B0aW9uQWNjZXNzID0gKG9iaiwga2V5LCBidW5kbGUpID0+IGJ1bmRsZShnZXQkYShvYmosIGtleSkpO1xuICAgIGNvbnN0IG9wdGlvbkRlZmF1bHRlZEFjY2VzcyA9IChvYmosIGtleSwgZmFsbGJhY2ssIGJ1bmRsZSkgPT4ge1xuICAgICAgY29uc3Qgb3B0ID0gZ2V0JGEob2JqLCBrZXkpLm1hcCh2YWwgPT4gdmFsID09PSB0cnVlID8gZmFsbGJhY2sob2JqKSA6IHZhbCk7XG4gICAgICByZXR1cm4gYnVuZGxlKG9wdCk7XG4gICAgfTtcbiAgICBjb25zdCBleHRyYWN0RmllbGQgPSAoZmllbGQsIHBhdGgsIG9iaiwga2V5LCBwcm9wKSA9PiB7XG4gICAgICBjb25zdCBidW5kbGUgPSBhdiA9PiBwcm9wLmV4dHJhY3QocGF0aC5jb25jYXQoW2tleV0pLCBhdik7XG4gICAgICBjb25zdCBidW5kbGVBc09wdGlvbiA9IG9wdFZhbHVlID0+IG9wdFZhbHVlLmZvbGQoKCkgPT4gU2ltcGxlUmVzdWx0LnN2YWx1ZShPcHRpb25hbC5ub25lKCkpLCBvdiA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHByb3AuZXh0cmFjdChwYXRoLmNvbmNhdChba2V5XSksIG92KTtcbiAgICAgICAgcmV0dXJuIFNpbXBsZVJlc3VsdC5tYXAocmVzdWx0LCBPcHRpb25hbC5zb21lKTtcbiAgICAgIH0pO1xuICAgICAgc3dpdGNoIChmaWVsZC50YWcpIHtcbiAgICAgIGNhc2UgJ3JlcXVpcmVkJzpcbiAgICAgICAgcmV0dXJuIHJlcXVpcmVkQWNjZXNzKHBhdGgsIG9iaiwga2V5LCBidW5kbGUpO1xuICAgICAgY2FzZSAnZGVmYXVsdGVkVGh1bmsnOlxuICAgICAgICByZXR1cm4gZmFsbGJhY2tBY2Nlc3Mob2JqLCBrZXksIGZpZWxkLnByb2Nlc3MsIGJ1bmRsZSk7XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICByZXR1cm4gb3B0aW9uQWNjZXNzKG9iaiwga2V5LCBidW5kbGVBc09wdGlvbik7XG4gICAgICBjYXNlICdkZWZhdWx0ZWRPcHRpb25UaHVuayc6XG4gICAgICAgIHJldHVybiBvcHRpb25EZWZhdWx0ZWRBY2Nlc3Mob2JqLCBrZXksIGZpZWxkLnByb2Nlc3MsIGJ1bmRsZUFzT3B0aW9uKTtcbiAgICAgIGNhc2UgJ21lcmdlV2l0aFRodW5rJzoge1xuICAgICAgICAgIHJldHVybiBmYWxsYmFja0FjY2VzcyhvYmosIGtleSwgY29uc3RhbnQoe30pLCB2ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGRlZXBNZXJnZShmaWVsZC5wcm9jZXNzKG9iaiksIHYpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1bmRsZShyZXN1bHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBleHRyYWN0RmllbGRzID0gKHBhdGgsIG9iaiwgZmllbGRzKSA9PiB7XG4gICAgICBjb25zdCBzdWNjZXNzID0ge307XG4gICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgZmllbGRzKSB7XG4gICAgICAgIGZvbGQoZmllbGQsIChrZXksIG5ld0tleSwgcHJlc2VuY2UsIHByb3ApID0+IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBleHRyYWN0RmllbGQocHJlc2VuY2UsIHBhdGgsIG9iaiwga2V5LCBwcm9wKTtcbiAgICAgICAgICBTaW1wbGVSZXN1bHQuZm9sZChyZXN1bHQsIGVyciA9PiB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCguLi5lcnIpO1xuICAgICAgICAgIH0sIHJlcyA9PiB7XG4gICAgICAgICAgICBzdWNjZXNzW25ld0tleV0gPSByZXM7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIChuZXdLZXksIGluc3RhbnRpYXRvcikgPT4ge1xuICAgICAgICAgIHN1Y2Nlc3NbbmV3S2V5XSA9IGluc3RhbnRpYXRvcihvYmopO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlcnJvcnMubGVuZ3RoID4gMCA/IFNpbXBsZVJlc3VsdC5zZXJyb3IoZXJyb3JzKSA6IFNpbXBsZVJlc3VsdC5zdmFsdWUoc3VjY2Vzcyk7XG4gICAgfTtcbiAgICBjb25zdCBvYmpPZiA9IHZhbHVlcyA9PiB7XG4gICAgICBjb25zdCBleHRyYWN0ID0gKHBhdGgsIG8pID0+IGV4dHJhY3RGaWVsZHMocGF0aCwgbywgdmFsdWVzKTtcbiAgICAgIGNvbnN0IHRvU3RyaW5nID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBmaWVsZFN0cmluZ3MgPSBtYXAkMyh2YWx1ZXMsIHZhbHVlID0+IGZvbGQodmFsdWUsIChrZXksIF9va2V5LCBfcHJlc2VuY2UsIHByb3ApID0+IGtleSArICcgLT4gJyArIHByb3AudG9TdHJpbmcoKSwgKG5ld0tleSwgX2luc3RhbnRpYXRvcikgPT4gJ3N0YXRlKCcgKyBuZXdLZXkgKyAnKScpKTtcbiAgICAgICAgcmV0dXJuICdvYmp7XFxuJyArIGZpZWxkU3RyaW5ncy5qb2luKCdcXG4nKSArICd9JztcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBleHRyYWN0LFxuICAgICAgICB0b1N0cmluZ1xuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGFyck9mID0gcHJvcCA9PiB7XG4gICAgICBjb25zdCBleHRyYWN0ID0gKHBhdGgsIGFycmF5KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBtYXAkMyhhcnJheSwgKGEsIGkpID0+IHByb3AuZXh0cmFjdChwYXRoLmNvbmNhdChbJ1snICsgaSArICddJ10pLCBhKSk7XG4gICAgICAgIHJldHVybiBSZXN1bHRDb21iaW5lLmNvbnNvbGlkYXRlQXJyKHJlc3VsdHMpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHRvU3RyaW5nID0gKCkgPT4gJ2FycmF5KCcgKyBwcm9wLnRvU3RyaW5nKCkgKyAnKSc7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBleHRyYWN0LFxuICAgICAgICB0b1N0cmluZ1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgdmFsdWVPZiA9IHZhbGlkYXRvciA9PiB2YWx1ZSh2ID0+IHZhbGlkYXRvcih2KS5mb2xkKFNpbXBsZVJlc3VsdC5zZXJyb3IsIFNpbXBsZVJlc3VsdC5zdmFsdWUpKTtcbiAgICBjb25zdCBleHRyYWN0VmFsdWUgPSAobGFiZWwsIHByb3AsIG9iaikgPT4ge1xuICAgICAgY29uc3QgcmVzID0gcHJvcC5leHRyYWN0KFtsYWJlbF0sIG9iaik7XG4gICAgICByZXR1cm4gU2ltcGxlUmVzdWx0Lm1hcEVycm9yKHJlcywgZXJycyA9PiAoe1xuICAgICAgICBpbnB1dDogb2JqLFxuICAgICAgICBlcnJvcnM6IGVycnNcbiAgICAgIH0pKTtcbiAgICB9O1xuICAgIGNvbnN0IGFzUmF3ID0gKGxhYmVsLCBwcm9wLCBvYmopID0+IFNpbXBsZVJlc3VsdC50b1Jlc3VsdChleHRyYWN0VmFsdWUobGFiZWwsIHByb3AsIG9iaikpO1xuICAgIGNvbnN0IGZvcm1hdEVycm9yID0gZXJySW5mbyA9PiB7XG4gICAgICByZXR1cm4gJ0Vycm9yczogXFxuJyArIGZvcm1hdEVycm9ycyhlcnJJbmZvLmVycm9ycykuam9pbignXFxuJykgKyAnXFxuXFxuSW5wdXQgb2JqZWN0OiAnICsgZm9ybWF0T2JqKGVyckluZm8uaW5wdXQpO1xuICAgIH07XG4gICAgY29uc3QgY2hvb3NlID0gKGtleSwgYnJhbmNoZXMpID0+IGNob29zZSQxKGtleSwgbWFwJDIoYnJhbmNoZXMsIG9iak9mKSk7XG5cbiAgICBjb25zdCBhbnlWYWx1ZSA9IGNvbnN0YW50KGFueVZhbHVlJDEpO1xuICAgIGNvbnN0IHR5cGVkVmFsdWUgPSAodmFsaWRhdG9yLCBleHBlY3RlZFR5cGUpID0+IHZhbHVlKGEgPT4ge1xuICAgICAgY29uc3QgYWN0dWFsVHlwZSA9IHR5cGVvZiBhO1xuICAgICAgcmV0dXJuIHZhbGlkYXRvcihhKSA/IFNpbXBsZVJlc3VsdC5zdmFsdWUoYSkgOiBTaW1wbGVSZXN1bHQuc2Vycm9yKGBFeHBlY3RlZCB0eXBlOiAkeyBleHBlY3RlZFR5cGUgfSBidXQgZ290OiAkeyBhY3R1YWxUeXBlIH1gKTtcbiAgICB9KTtcbiAgICBjb25zdCBudW1iZXIgPSB0eXBlZFZhbHVlKGlzTnVtYmVyLCAnbnVtYmVyJyk7XG4gICAgY29uc3Qgc3RyaW5nID0gdHlwZWRWYWx1ZShpc1N0cmluZywgJ3N0cmluZycpO1xuICAgIGNvbnN0IGJvb2xlYW4gPSB0eXBlZFZhbHVlKGlzQm9vbGVhbiwgJ2Jvb2xlYW4nKTtcbiAgICBjb25zdCBmdW5jdGlvblByb2Nlc3NvciA9IHR5cGVkVmFsdWUoaXNGdW5jdGlvbiwgJ2Z1bmN0aW9uJyk7XG5cbiAgICBjb25zdCBmaWVsZCA9IGZpZWxkJDE7XG4gICAgY29uc3QgY3VzdG9tRmllbGQgPSBjdXN0b21GaWVsZCQxO1xuICAgIGNvbnN0IHZhbGlkYXRlRW51bSA9IHZhbHVlcyA9PiB2YWx1ZU9mKHZhbHVlID0+IGNvbnRhaW5zJDIodmFsdWVzLCB2YWx1ZSkgPyBSZXN1bHQudmFsdWUodmFsdWUpIDogUmVzdWx0LmVycm9yKGBVbnN1cHBvcnRlZCB2YWx1ZTogXCIkeyB2YWx1ZSB9XCIsIGNob29zZSBvbmUgb2YgXCIkeyB2YWx1ZXMuam9pbignLCAnKSB9XCIuYCkpO1xuICAgIGNvbnN0IHJlcXVpcmVkT2YgPSAoa2V5LCBzY2hlbWEpID0+IGZpZWxkKGtleSwga2V5LCByZXF1aXJlZCgpLCBzY2hlbWEpO1xuICAgIGNvbnN0IHJlcXVpcmVkU3RyaW5nID0ga2V5ID0+IHJlcXVpcmVkT2Yoa2V5LCBzdHJpbmcpO1xuICAgIGNvbnN0IHJlcXVpcmVkRnVuY3Rpb24gPSBrZXkgPT4gcmVxdWlyZWRPZihrZXksIGZ1bmN0aW9uUHJvY2Vzc29yKTtcbiAgICBjb25zdCByZXF1aXJlZEFycmF5T2YgPSAoa2V5LCBzY2hlbWEpID0+IGZpZWxkKGtleSwga2V5LCByZXF1aXJlZCgpLCBhcnJPZihzY2hlbWEpKTtcbiAgICBjb25zdCBvcHRpb25PZiA9IChrZXksIHNjaGVtYSkgPT4gZmllbGQoa2V5LCBrZXksIGFzT3B0aW9uKCksIHNjaGVtYSk7XG4gICAgY29uc3Qgb3B0aW9uU3RyaW5nID0ga2V5ID0+IG9wdGlvbk9mKGtleSwgc3RyaW5nKTtcbiAgICBjb25zdCBvcHRpb25GdW5jdGlvbiA9IGtleSA9PiBvcHRpb25PZihrZXksIGZ1bmN0aW9uUHJvY2Vzc29yKTtcbiAgICBjb25zdCBkZWZhdWx0ZWQgPSAoa2V5LCBmYWxsYmFjaykgPT4gZmllbGQoa2V5LCBrZXksIGRlZmF1bHRlZCQxKGZhbGxiYWNrKSwgYW55VmFsdWUoKSk7XG4gICAgY29uc3QgZGVmYXVsdGVkT2YgPSAoa2V5LCBmYWxsYmFjaywgc2NoZW1hKSA9PiBmaWVsZChrZXksIGtleSwgZGVmYXVsdGVkJDEoZmFsbGJhY2spLCBzY2hlbWEpO1xuICAgIGNvbnN0IGRlZmF1bHRlZE51bWJlciA9IChrZXksIGZhbGxiYWNrKSA9PiBkZWZhdWx0ZWRPZihrZXksIGZhbGxiYWNrLCBudW1iZXIpO1xuICAgIGNvbnN0IGRlZmF1bHRlZFN0cmluZyA9IChrZXksIGZhbGxiYWNrKSA9PiBkZWZhdWx0ZWRPZihrZXksIGZhbGxiYWNrLCBzdHJpbmcpO1xuICAgIGNvbnN0IGRlZmF1bHRlZFN0cmluZ0VudW0gPSAoa2V5LCBmYWxsYmFjaywgdmFsdWVzKSA9PiBkZWZhdWx0ZWRPZihrZXksIGZhbGxiYWNrLCB2YWxpZGF0ZUVudW0odmFsdWVzKSk7XG4gICAgY29uc3QgZGVmYXVsdGVkQm9vbGVhbiA9IChrZXksIGZhbGxiYWNrKSA9PiBkZWZhdWx0ZWRPZihrZXksIGZhbGxiYWNrLCBib29sZWFuKTtcbiAgICBjb25zdCBkZWZhdWx0ZWRGdW5jdGlvbiA9IChrZXksIGZhbGxiYWNrKSA9PiBkZWZhdWx0ZWRPZihrZXksIGZhbGxiYWNrLCBmdW5jdGlvblByb2Nlc3Nvcik7XG4gICAgY29uc3QgZGVmYXVsdGVkQXJyYXlPZiA9IChrZXksIGZhbGxiYWNrLCBzY2hlbWEpID0+IGRlZmF1bHRlZE9mKGtleSwgZmFsbGJhY2ssIGFyck9mKHNjaGVtYSkpO1xuXG4gICAgY29uc3QgdHlwZSA9IHJlcXVpcmVkU3RyaW5nKCd0eXBlJyk7XG4gICAgY29uc3QgZmV0Y2gkMSA9IHJlcXVpcmVkRnVuY3Rpb24oJ2ZldGNoJyk7XG4gICAgY29uc3Qgb25BY3Rpb24gPSByZXF1aXJlZEZ1bmN0aW9uKCdvbkFjdGlvbicpO1xuICAgIGNvbnN0IG9uU2V0dXAgPSBkZWZhdWx0ZWRGdW5jdGlvbignb25TZXR1cCcsICgpID0+IG5vb3ApO1xuICAgIGNvbnN0IG9wdGlvbmFsVGV4dCA9IG9wdGlvblN0cmluZygndGV4dCcpO1xuICAgIGNvbnN0IG9wdGlvbmFsSWNvbiA9IG9wdGlvblN0cmluZygnaWNvbicpO1xuICAgIGNvbnN0IG9wdGlvbmFsVG9vbHRpcCA9IG9wdGlvblN0cmluZygndG9vbHRpcCcpO1xuICAgIGNvbnN0IG9wdGlvbmFsTGFiZWwgPSBvcHRpb25TdHJpbmcoJ2xhYmVsJyk7XG4gICAgY29uc3QgYWN0aXZlID0gZGVmYXVsdGVkQm9vbGVhbignYWN0aXZlJywgZmFsc2UpO1xuICAgIGNvbnN0IGVuYWJsZWQgPSBkZWZhdWx0ZWRCb29sZWFuKCdlbmFibGVkJywgdHJ1ZSk7XG4gICAgY29uc3QgcHJpbWFyeSA9IGRlZmF1bHRlZEJvb2xlYW4oJ3ByaW1hcnknLCBmYWxzZSk7XG4gICAgY29uc3QgZGVmYXVsdGVkQ29sdW1ucyA9IG51bSA9PiBkZWZhdWx0ZWQoJ2NvbHVtbnMnLCBudW0pO1xuICAgIGNvbnN0IGRlZmF1bHRlZFR5cGUgPSB0eXBlID0+IGRlZmF1bHRlZFN0cmluZygndHlwZScsIHR5cGUpO1xuXG4gICAgY29uc3QgYXV0b2NvbXBsZXRlclNjaGVtYSA9IG9iak9mKFtcbiAgICAgIHR5cGUsXG4gICAgICByZXF1aXJlZFN0cmluZygndHJpZ2dlcicpLFxuICAgICAgZGVmYXVsdGVkTnVtYmVyKCdtaW5DaGFycycsIDEpLFxuICAgICAgZGVmYXVsdGVkQ29sdW1ucygxKSxcbiAgICAgIGRlZmF1bHRlZE51bWJlcignbWF4UmVzdWx0cycsIDEwKSxcbiAgICAgIG9wdGlvbkZ1bmN0aW9uKCdtYXRjaGVzJyksXG4gICAgICBmZXRjaCQxLFxuICAgICAgb25BY3Rpb24sXG4gICAgICBkZWZhdWx0ZWRBcnJheU9mKCdoaWdobGlnaHRPbicsIFtdLCBzdHJpbmcpXG4gICAgXSk7XG4gICAgY29uc3QgY3JlYXRlQXV0b2NvbXBsZXRlciA9IHNwZWMgPT4gYXNSYXcoJ0F1dG9jb21wbGV0ZXInLCBhdXRvY29tcGxldGVyU2NoZW1hLCB7XG4gICAgICB0cmlnZ2VyOiBzcGVjLmNoLFxuICAgICAgLi4uc3BlY1xuICAgIH0pO1xuXG4gICAgY29uc3QgYmFzZVRvb2xiYXJCdXR0b25GaWVsZHMgPSBbXG4gICAgICBlbmFibGVkLFxuICAgICAgb3B0aW9uYWxUb29sdGlwLFxuICAgICAgb3B0aW9uYWxJY29uLFxuICAgICAgb3B0aW9uYWxUZXh0LFxuICAgICAgb25TZXR1cFxuICAgIF07XG5cbiAgICBjb25zdCBiYXNlVG9vbGJhclRvZ2dsZUJ1dHRvbkZpZWxkcyA9IFthY3RpdmVdLmNvbmNhdChiYXNlVG9vbGJhckJ1dHRvbkZpZWxkcyk7XG5cbiAgICBjb25zdCBjb250ZXh0QmFyRmllbGRzID0gW1xuICAgICAgZGVmYXVsdGVkRnVuY3Rpb24oJ3ByZWRpY2F0ZScsIG5ldmVyKSxcbiAgICAgIGRlZmF1bHRlZFN0cmluZ0VudW0oJ3Njb3BlJywgJ25vZGUnLCBbXG4gICAgICAgICdub2RlJyxcbiAgICAgICAgJ2VkaXRvcidcbiAgICAgIF0pLFxuICAgICAgZGVmYXVsdGVkU3RyaW5nRW51bSgncG9zaXRpb24nLCAnc2VsZWN0aW9uJywgW1xuICAgICAgICAnbm9kZScsXG4gICAgICAgICdzZWxlY3Rpb24nLFxuICAgICAgICAnbGluZSdcbiAgICAgIF0pXG4gICAgXTtcblxuICAgIGNvbnN0IGNvbnRleHRCdXR0b25GaWVsZHMgPSBiYXNlVG9vbGJhckJ1dHRvbkZpZWxkcy5jb25jYXQoW1xuICAgICAgZGVmYXVsdGVkVHlwZSgnY29udGV4dGZvcm1idXR0b24nKSxcbiAgICAgIHByaW1hcnksXG4gICAgICBvbkFjdGlvbixcbiAgICAgIGN1c3RvbUZpZWxkKCdvcmlnaW5hbCcsIGlkZW50aXR5KVxuICAgIF0pO1xuICAgIGNvbnN0IGNvbnRleHRUb2dnbGVCdXR0b25GaWVsZHMgPSBiYXNlVG9vbGJhclRvZ2dsZUJ1dHRvbkZpZWxkcy5jb25jYXQoW1xuICAgICAgZGVmYXVsdGVkVHlwZSgnY29udGV4dGZvcm1idXR0b24nKSxcbiAgICAgIHByaW1hcnksXG4gICAgICBvbkFjdGlvbixcbiAgICAgIGN1c3RvbUZpZWxkKCdvcmlnaW5hbCcsIGlkZW50aXR5KVxuICAgIF0pO1xuICAgIGNvbnN0IGxhdW5jaEJ1dHRvbkZpZWxkcyA9IGJhc2VUb29sYmFyQnV0dG9uRmllbGRzLmNvbmNhdChbZGVmYXVsdGVkVHlwZSgnY29udGV4dGZvcm1idXR0b24nKV0pO1xuICAgIGNvbnN0IGxhdW5jaFRvZ2dsZUJ1dHRvbkZpZWxkcyA9IGJhc2VUb29sYmFyVG9nZ2xlQnV0dG9uRmllbGRzLmNvbmNhdChbZGVmYXVsdGVkVHlwZSgnY29udGV4dGZvcm10b2dnbGVidXR0b24nKV0pO1xuICAgIGNvbnN0IHRvZ2dsZU9yTm9ybWFsID0gY2hvb3NlKCd0eXBlJywge1xuICAgICAgY29udGV4dGZvcm1idXR0b246IGNvbnRleHRCdXR0b25GaWVsZHMsXG4gICAgICBjb250ZXh0Zm9ybXRvZ2dsZWJ1dHRvbjogY29udGV4dFRvZ2dsZUJ1dHRvbkZpZWxkc1xuICAgIH0pO1xuICAgIG9iak9mKFtcbiAgICAgIGRlZmF1bHRlZFR5cGUoJ2NvbnRleHRmb3JtJyksXG4gICAgICBkZWZhdWx0ZWRGdW5jdGlvbignaW5pdFZhbHVlJywgY29uc3RhbnQoJycpKSxcbiAgICAgIG9wdGlvbmFsTGFiZWwsXG4gICAgICByZXF1aXJlZEFycmF5T2YoJ2NvbW1hbmRzJywgdG9nZ2xlT3JOb3JtYWwpLFxuICAgICAgb3B0aW9uT2YoJ2xhdW5jaCcsIGNob29zZSgndHlwZScsIHtcbiAgICAgICAgY29udGV4dGZvcm1idXR0b246IGxhdW5jaEJ1dHRvbkZpZWxkcyxcbiAgICAgICAgY29udGV4dGZvcm10b2dnbGVidXR0b246IGxhdW5jaFRvZ2dsZUJ1dHRvbkZpZWxkc1xuICAgICAgfSkpXG4gICAgXS5jb25jYXQoY29udGV4dEJhckZpZWxkcykpO1xuXG4gICAgY29uc3QgcmVnaXN0ZXIkMiA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBwb3B1cHMgPSBlZGl0b3IudWkucmVnaXN0cnkuZ2V0QWxsKCkucG9wdXBzO1xuICAgICAgY29uc3QgZGF0YXNldCA9IG1hcCQyKHBvcHVwcywgcG9wdXAgPT4gY3JlYXRlQXV0b2NvbXBsZXRlcihwb3B1cCkuZm9sZChlcnIgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZm9ybWF0RXJyb3IoZXJyKSk7XG4gICAgICB9LCBpZGVudGl0eSkpO1xuICAgICAgY29uc3QgdHJpZ2dlcnMgPSBzdHJpbmdBcnJheShtYXBUb0FycmF5KGRhdGFzZXQsIHYgPT4gdi50cmlnZ2VyKSk7XG4gICAgICBjb25zdCBkYXRhc2V0VmFsdWVzID0gdmFsdWVzKGRhdGFzZXQpO1xuICAgICAgY29uc3QgbG9va3VwQnlUcmlnZ2VyID0gdHJpZ2dlciA9PiBmaWx0ZXIkNShkYXRhc2V0VmFsdWVzLCBkdiA9PiBkdi50cmlnZ2VyID09PSB0cmlnZ2VyKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGFzZXQsXG4gICAgICAgIHRyaWdnZXJzLFxuICAgICAgICBsb29rdXBCeVRyaWdnZXJcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IHNldHVwRWRpdG9ySW5wdXQgPSAoZWRpdG9yLCBhcGkpID0+IHtcbiAgICAgIGNvbnN0IHVwZGF0ZSA9IGxhc3QkMShhcGkubG9hZCwgNTApO1xuICAgICAgZWRpdG9yLm9uKCdrZXlwcmVzcyBjb21wb3NpdGlvbmVuZCcsIGUgPT4ge1xuICAgICAgICBpZiAoZS53aGljaCA9PT0gMjcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlLnRocm90dGxlKCk7XG4gICAgICB9KTtcbiAgICAgIGVkaXRvci5vbigna2V5ZG93bicsIGUgPT4ge1xuICAgICAgICBjb25zdCBrZXlDb2RlID0gZS53aGljaDtcbiAgICAgICAgaWYgKGtleUNvZGUgPT09IDgpIHtcbiAgICAgICAgICB1cGRhdGUudGhyb3R0bGUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXlDb2RlID09PSAyNykge1xuICAgICAgICAgIGFwaS5jYW5jZWxJZk5lY2Vzc2FyeSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGVkaXRvci5vbigncmVtb3ZlJywgdXBkYXRlLmNhbmNlbCk7XG4gICAgfTtcbiAgICBjb25zdCBzZXR1cCRqID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGFjdGl2ZUF1dG9jb21wbGV0ZXIgPSB2YWx1ZSQyKCk7XG4gICAgICBjb25zdCB1aUFjdGl2ZSA9IENlbGwoZmFsc2UpO1xuICAgICAgY29uc3QgaXNBY3RpdmUgPSBhY3RpdmVBdXRvY29tcGxldGVyLmlzU2V0O1xuICAgICAgY29uc3QgY2FuY2VsSWZOZWNlc3NhcnkgPSAoKSA9PiB7XG4gICAgICAgIGlmIChpc0FjdGl2ZSgpKSB7XG4gICAgICAgICAgcmVtb3ZlQXV0b2NvbXBsZXRlckRlY29yYXRpb24oZWRpdG9yKTtcbiAgICAgICAgICBmaXJlQXV0b2NvbXBsZXRlckVuZChlZGl0b3IpO1xuICAgICAgICAgIHVpQWN0aXZlLnNldChmYWxzZSk7XG4gICAgICAgICAgYWN0aXZlQXV0b2NvbXBsZXRlci5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgY29tbWVuY2VJZk5lY2Vzc2FyeSA9IGNvbnRleHQgPT4ge1xuICAgICAgICBpZiAoIWlzQWN0aXZlKCkpIHtcbiAgICAgICAgICBhZGRBdXRvY29tcGxldGVyRGVjb3JhdGlvbihlZGl0b3IsIGNvbnRleHQucmFuZ2UpO1xuICAgICAgICAgIGFjdGl2ZUF1dG9jb21wbGV0ZXIuc2V0KHtcbiAgICAgICAgICAgIHRyaWdnZXI6IGNvbnRleHQudHJpZ2dlcixcbiAgICAgICAgICAgIG1hdGNoTGVuZ3RoOiBjb250ZXh0LnRleHQubGVuZ3RoXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBnZXRBdXRvY29tcGxldGVycyA9IGNhY2hlZCgoKSA9PiByZWdpc3RlciQyKGVkaXRvcikpO1xuICAgICAgY29uc3QgZG9Mb29rdXAgPSBmZXRjaE9wdGlvbnMgPT4gYWN0aXZlQXV0b2NvbXBsZXRlci5nZXQoKS5tYXAoYWMgPT4gZ2V0Q29udGV4dChlZGl0b3IuZG9tLCBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpLCBhYy50cmlnZ2VyKS5iaW5kKG5ld0NvbnRleHQgPT4gbG9va3VwV2l0aENvbnRleHQoZWRpdG9yLCBnZXRBdXRvY29tcGxldGVycywgbmV3Q29udGV4dCwgZmV0Y2hPcHRpb25zKSkpLmdldE9yVGh1bmsoKCkgPT4gbG9va3VwKGVkaXRvciwgZ2V0QXV0b2NvbXBsZXRlcnMpKTtcbiAgICAgIGNvbnN0IGxvYWQgPSBmZXRjaE9wdGlvbnMgPT4ge1xuICAgICAgICBkb0xvb2t1cChmZXRjaE9wdGlvbnMpLmZvbGQoY2FuY2VsSWZOZWNlc3NhcnksIGxvb2t1cEluZm8gPT4ge1xuICAgICAgICAgIGNvbW1lbmNlSWZOZWNlc3NhcnkobG9va3VwSW5mby5jb250ZXh0KTtcbiAgICAgICAgICBsb29rdXBJbmZvLmxvb2t1cERhdGEudGhlbihsb29rdXBEYXRhID0+IHtcbiAgICAgICAgICAgIGFjdGl2ZUF1dG9jb21wbGV0ZXIuZ2V0KCkubWFwKGFjID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IGxvb2t1cEluZm8uY29udGV4dDtcbiAgICAgICAgICAgICAgaWYgKGFjLnRyaWdnZXIgPT09IGNvbnRleHQudHJpZ2dlcikge1xuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LnRleHQubGVuZ3RoIC0gYWMubWF0Y2hMZW5ndGggPj0gMTApIHtcbiAgICAgICAgICAgICAgICAgIGNhbmNlbElmTmVjZXNzYXJ5KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGFjdGl2ZUF1dG9jb21wbGV0ZXIuc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgLi4uYWMsXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoTGVuZ3RoOiBjb250ZXh0LnRleHQubGVuZ3RoXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGlmICh1aUFjdGl2ZS5nZXQoKSkge1xuICAgICAgICAgICAgICAgICAgICBmaXJlQXV0b2NvbXBsZXRlclVwZGF0ZShlZGl0b3IsIHsgbG9va3VwRGF0YSB9KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHVpQWN0aXZlLnNldCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgZmlyZUF1dG9jb21wbGV0ZXJTdGFydChlZGl0b3IsIHsgbG9va3VwRGF0YSB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBlZGl0b3IuYWRkQ29tbWFuZCgnbWNlQXV0b2NvbXBsZXRlclJlbG9hZCcsIChfdWksIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IGZldGNoT3B0aW9ucyA9IGlzT2JqZWN0KHZhbHVlKSA/IHZhbHVlLmZldGNoT3B0aW9ucyA6IHt9O1xuICAgICAgICBsb2FkKGZldGNoT3B0aW9ucyk7XG4gICAgICB9KTtcbiAgICAgIGVkaXRvci5hZGRDb21tYW5kKCdtY2VBdXRvY29tcGxldGVyQ2xvc2UnLCBjYW5jZWxJZk5lY2Vzc2FyeSk7XG4gICAgICBzZXR1cEVkaXRvcklucHV0KGVkaXRvciwge1xuICAgICAgICBjYW5jZWxJZk5lY2Vzc2FyeSxcbiAgICAgICAgbG9hZFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGNyZWF0ZUFuZEZpcmVJbnB1dEV2ZW50ID0gZXZlbnRUeXBlID0+IChlZGl0b3IsIGlucHV0VHlwZSwgc3BlY2lmaWNzID0ge30pID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGVkaXRvci5nZXRCb2R5KCk7XG4gICAgICBjb25zdCBvdmVycmlkZXMgPSB7XG4gICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgIGNvbXBvc2VkOiB0cnVlLFxuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICBpc0NvbXBvc2luZzogZmFsc2UsXG4gICAgICAgIGRldGFpbDogMCxcbiAgICAgICAgdmlldzogbnVsbCxcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBjdXJyZW50VGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgIGV2ZW50UGhhc2U6IEV2ZW50LkFUX1RBUkdFVCxcbiAgICAgICAgb3JpZ2luYWxUYXJnZXQ6IHRhcmdldCxcbiAgICAgICAgZXhwbGljaXRPcmlnaW5hbFRhcmdldDogdGFyZ2V0LFxuICAgICAgICBpc1RydXN0ZWQ6IGZhbHNlLFxuICAgICAgICBzcmNFbGVtZW50OiB0YXJnZXQsXG4gICAgICAgIGNhbmNlbGFibGU6IGZhbHNlLFxuICAgICAgICBwcmV2ZW50RGVmYXVsdDogbm9vcCxcbiAgICAgICAgaW5wdXRUeXBlXG4gICAgICB9O1xuICAgICAgY29uc3QgaW5wdXQgPSBjbG9uZSQzKG5ldyBJbnB1dEV2ZW50KGV2ZW50VHlwZSkpO1xuICAgICAgcmV0dXJuIGVkaXRvci5kaXNwYXRjaChldmVudFR5cGUsIHtcbiAgICAgICAgLi4uaW5wdXQsXG4gICAgICAgIC4uLm92ZXJyaWRlcyxcbiAgICAgICAgLi4uc3BlY2lmaWNzXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGZpcmVGYWtlSW5wdXRFdmVudCA9IGNyZWF0ZUFuZEZpcmVJbnB1dEV2ZW50KCdpbnB1dCcpO1xuICAgIGNvbnN0IGZpcmVGYWtlQmVmb3JlSW5wdXRFdmVudCA9IGNyZWF0ZUFuZEZpcmVJbnB1dEV2ZW50KCdiZWZvcmVpbnB1dCcpO1xuXG4gICAgY29uc3QgZXhlY3V0ZUtleWRvd25PdmVycmlkZSQzID0gKGVkaXRvciwgY2FyZXQsIGV2dCkgPT4ge1xuICAgICAgY29uc3QgaW5wdXRUeXBlID0gZXZ0LmtleUNvZGUgPT09IFZLLkJBQ0tTUEFDRSA/ICdkZWxldGVDb250ZW50QmFja3dhcmQnIDogJ2RlbGV0ZUNvbnRlbnRGb3J3YXJkJztcbiAgICAgIGV4ZWN1dGVXaXRoRGVsYXllZEFjdGlvbihbXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5CQUNLU1BBQ0UsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24oYmFja3NwYWNlRGVsZXRlLCBlZGl0b3IpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5CQUNLU1BBQ0UsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24oYmFja3NwYWNlRGVsZXRlJDUsIGVkaXRvciwgZmFsc2UpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5ERUxFVEUsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24oYmFja3NwYWNlRGVsZXRlJDUsIGVkaXRvciwgdHJ1ZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkJBQ0tTUEFDRSxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihiYWNrc3BhY2VEZWxldGUkNiwgZWRpdG9yLCBmYWxzZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkRFTEVURSxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihiYWNrc3BhY2VEZWxldGUkNiwgZWRpdG9yLCB0cnVlKVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuQkFDS1NQQUNFLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKGJhY2tzcGFjZURlbGV0ZSQzLCBlZGl0b3IsIGNhcmV0LCBmYWxzZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkRFTEVURSxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihiYWNrc3BhY2VEZWxldGUkMywgZWRpdG9yLCBjYXJldCwgdHJ1ZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkJBQ0tTUEFDRSxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihiYWNrc3BhY2VEZWxldGUkOSwgZWRpdG9yLCBmYWxzZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkRFTEVURSxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihiYWNrc3BhY2VEZWxldGUkOSwgZWRpdG9yLCB0cnVlKVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuQkFDS1NQQUNFLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKGJhY2tzcGFjZURlbGV0ZSQ0LCBlZGl0b3IsIGZhbHNlKVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuREVMRVRFLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKGJhY2tzcGFjZURlbGV0ZSQ0LCBlZGl0b3IsIHRydWUpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5CQUNLU1BBQ0UsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24oYmFja3NwYWNlRGVsZXRlJDEsIGVkaXRvciwgZmFsc2UpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5ERUxFVEUsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24oYmFja3NwYWNlRGVsZXRlJDEsIGVkaXRvciwgdHJ1ZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkJBQ0tTUEFDRSxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihiYWNrc3BhY2VEZWxldGUkNywgZWRpdG9yLCBmYWxzZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkRFTEVURSxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihiYWNrc3BhY2VEZWxldGUkNywgZWRpdG9yLCB0cnVlKVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuQkFDS1NQQUNFLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKGJhY2tzcGFjZURlbGV0ZSQ4LCBlZGl0b3IsIGZhbHNlKVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuREVMRVRFLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKGJhY2tzcGFjZURlbGV0ZSQ4LCBlZGl0b3IsIHRydWUpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5CQUNLU1BBQ0UsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24oYmFja3NwYWNlRGVsZXRlJDIsIGVkaXRvciwgZmFsc2UpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5ERUxFVEUsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24oYmFja3NwYWNlRGVsZXRlJDIsIGVkaXRvciwgdHJ1ZSlcbiAgICAgICAgfVxuICAgICAgXSwgZXZ0KS5maWx0ZXIoXyA9PiBlZGl0b3Iuc2VsZWN0aW9uLmlzRWRpdGFibGUoKSkuZWFjaChhcHBseUFjdGlvbiA9PiB7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBjb25zdCBiZWZvcmVJbnB1dCA9IGZpcmVGYWtlQmVmb3JlSW5wdXRFdmVudChlZGl0b3IsIGlucHV0VHlwZSk7XG4gICAgICAgIGlmICghYmVmb3JlSW5wdXQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICBhcHBseUFjdGlvbigpO1xuICAgICAgICAgIGZpcmVGYWtlSW5wdXRFdmVudChlZGl0b3IsIGlucHV0VHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgZXhlY3V0ZUtleXVwT3ZlcnJpZGUgPSAoZWRpdG9yLCBldnQsIGlzQmFja3NwYWNlS2V5ZG93bikgPT4ge1xuICAgICAgY29uc3QgcGxhdGZvcm0gPSBkZXRlY3QkMigpO1xuICAgICAgY29uc3Qgb3MgPSBwbGF0Zm9ybS5vcztcbiAgICAgIGNvbnN0IGJyb3dzZXIgPSBwbGF0Zm9ybS5icm93c2VyO1xuICAgICAgY29uc3QgbXVsdGlEZWxldGVLZXlQYXR0ZXJucyA9IG9zLmlzTWFjT1MoKSA/IFtcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkJBQ0tTUEFDRSxcbiAgICAgICAgICBhbHRLZXk6IHRydWUsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24ocmVmcmVzaENhcmV0LCBlZGl0b3IpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5ERUxFVEUsXG4gICAgICAgICAgYWx0S2V5OiB0cnVlLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKHJlZnJlc2hDYXJldCwgZWRpdG9yKVxuICAgICAgICB9XG4gICAgICBdIDogW1xuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuQkFDS1NQQUNFLFxuICAgICAgICAgIGN0cmxLZXk6IHRydWUsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24ocmVmcmVzaENhcmV0LCBlZGl0b3IpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5ERUxFVEUsXG4gICAgICAgICAgY3RybEtleTogdHJ1ZSxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihyZWZyZXNoQ2FyZXQsIGVkaXRvcilcbiAgICAgICAgfVxuICAgICAgXTtcbiAgICAgIGlmIChvcy5pc01hY09TKCkgJiYgaXNCYWNrc3BhY2VLZXlkb3duKSB7XG4gICAgICAgIG11bHRpRGVsZXRlS2V5UGF0dGVybnMucHVzaCh7XG4gICAgICAgICAga2V5Q29kZTogYnJvd3Nlci5pc0ZpcmVmb3goKSA/IDIyNCA6IDkxLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKHJlZnJlc2hDYXJldCwgZWRpdG9yKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGV4ZWN1dGUoW1xuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuQkFDS1NQQUNFLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKHBhZGRFbXB0eUVsZW1lbnQsIGVkaXRvcilcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkRFTEVURSxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihwYWRkRW1wdHlFbGVtZW50LCBlZGl0b3IpXG4gICAgICAgIH0sXG4gICAgICAgIC4uLm11bHRpRGVsZXRlS2V5UGF0dGVybnNcbiAgICAgIF0sIGV2dCk7XG4gICAgfTtcbiAgICBjb25zdCBzZXR1cCRpID0gKGVkaXRvciwgY2FyZXQpID0+IHtcbiAgICAgIGxldCBpc0JhY2tzcGFjZUtleWRvd24gPSBmYWxzZTtcbiAgICAgIGVkaXRvci5vbigna2V5ZG93bicsIGV2dCA9PiB7XG4gICAgICAgIGlzQmFja3NwYWNlS2V5ZG93biA9IGV2dC5rZXlDb2RlID09PSBWSy5CQUNLU1BBQ0U7XG4gICAgICAgIGlmICghZXZ0LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgZXhlY3V0ZUtleWRvd25PdmVycmlkZSQzKGVkaXRvciwgY2FyZXQsIGV2dCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm9uKCdrZXl1cCcsIGV2dCA9PiB7XG4gICAgICAgIGlmICghZXZ0LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgZXhlY3V0ZUtleXVwT3ZlcnJpZGUoZWRpdG9yLCBldnQsIGlzQmFja3NwYWNlS2V5ZG93bik7XG4gICAgICAgIH1cbiAgICAgICAgaXNCYWNrc3BhY2VLZXlkb3duID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgZmlyc3ROb25XaGl0ZVNwYWNlTm9kZVNpYmxpbmcgPSBub2RlID0+IHtcbiAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGlmIChpc0VsZW1lbnQkNihub2RlKSB8fCBpc1RleHQkYShub2RlKSAmJiBub2RlLmRhdGEgJiYgL1tcXHJcXG5cXHNdLy50ZXN0KG5vZGUuZGF0YSkpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgY29uc3QgbW92ZVRvQ2FyZXRQb3NpdGlvbiA9IChlZGl0b3IsIHJvb3QpID0+IHtcbiAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb207XG4gICAgICBjb25zdCBtb3ZlQ2FyZXRCZWZvcmVPbkVudGVyRWxlbWVudHNNYXAgPSBlZGl0b3Iuc2NoZW1hLmdldE1vdmVDYXJldEJlZm9yZU9uRW50ZXJFbGVtZW50cygpO1xuICAgICAgaWYgKCFyb290KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICgvXihMSXxEVHxERCkkLy50ZXN0KHJvb3Qubm9kZU5hbWUpKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBmaXJzdE5vbldoaXRlU3BhY2VOb2RlU2libGluZyhyb290LmZpcnN0Q2hpbGQpO1xuICAgICAgICBpZiAoZmlyc3RDaGlsZCAmJiAvXihVTHxPTHxETCkkLy50ZXN0KGZpcnN0Q2hpbGQubm9kZU5hbWUpKSB7XG4gICAgICAgICAgcm9vdC5pbnNlcnRCZWZvcmUoZG9tLmRvYy5jcmVhdGVUZXh0Tm9kZShuYnNwKSwgcm9vdC5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgcm5nID0gZG9tLmNyZWF0ZVJuZygpO1xuICAgICAgcm9vdC5ub3JtYWxpemUoKTtcbiAgICAgIGlmIChyb290Lmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICBjb25zdCB3YWxrZXIgPSBuZXcgRG9tVHJlZVdhbGtlcihyb290LCByb290KTtcbiAgICAgICAgbGV0IGxhc3ROb2RlID0gcm9vdDtcbiAgICAgICAgbGV0IG5vZGU7XG4gICAgICAgIHdoaWxlIChub2RlID0gd2Fsa2VyLmN1cnJlbnQoKSkge1xuICAgICAgICAgIGlmIChpc1RleHQkYShub2RlKSkge1xuICAgICAgICAgICAgcm5nLnNldFN0YXJ0KG5vZGUsIDApO1xuICAgICAgICAgICAgcm5nLnNldEVuZChub2RlLCAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW92ZUNhcmV0QmVmb3JlT25FbnRlckVsZW1lbnRzTWFwW25vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKV0pIHtcbiAgICAgICAgICAgIHJuZy5zZXRTdGFydEJlZm9yZShub2RlKTtcbiAgICAgICAgICAgIHJuZy5zZXRFbmRCZWZvcmUobm9kZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgbGFzdE5vZGUgPSBub2RlO1xuICAgICAgICAgIG5vZGUgPSB3YWxrZXIubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgIHJuZy5zZXRTdGFydChsYXN0Tm9kZSwgMCk7XG4gICAgICAgICAgcm5nLnNldEVuZChsYXN0Tm9kZSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc0JyJDYocm9vdCkpIHtcbiAgICAgICAgICBpZiAocm9vdC5uZXh0U2libGluZyAmJiBkb20uaXNCbG9jayhyb290Lm5leHRTaWJsaW5nKSkge1xuICAgICAgICAgICAgcm5nLnNldFN0YXJ0QmVmb3JlKHJvb3QpO1xuICAgICAgICAgICAgcm5nLnNldEVuZEJlZm9yZShyb290KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcm5nLnNldFN0YXJ0QWZ0ZXIocm9vdCk7XG4gICAgICAgICAgICBybmcuc2V0RW5kQWZ0ZXIocm9vdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJuZy5zZXRTdGFydChyb290LCAwKTtcbiAgICAgICAgICBybmcuc2V0RW5kKHJvb3QsIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFJuZyhybmcpO1xuICAgICAgc2Nyb2xsUmFuZ2VJbnRvVmlldyhlZGl0b3IsIHJuZyk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRFZGl0YWJsZVJvb3QgPSAoZG9tLCBub2RlKSA9PiB7XG4gICAgICBjb25zdCByb290ID0gZG9tLmdldFJvb3QoKTtcbiAgICAgIGxldCBlZGl0YWJsZVJvb3Q7XG4gICAgICBsZXQgcGFyZW50ID0gbm9kZTtcbiAgICAgIHdoaWxlIChwYXJlbnQgIT09IHJvb3QgJiYgcGFyZW50ICYmIGRvbS5nZXRDb250ZW50RWRpdGFibGUocGFyZW50KSAhPT0gJ2ZhbHNlJykge1xuICAgICAgICBpZiAoZG9tLmdldENvbnRlbnRFZGl0YWJsZShwYXJlbnQpID09PSAndHJ1ZScpIHtcbiAgICAgICAgICBlZGl0YWJsZVJvb3QgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyZW50ICE9PSByb290ID8gZWRpdGFibGVSb290IDogcm9vdDtcbiAgICB9O1xuICAgIGNvbnN0IGdldFBhcmVudEJsb2NrJDEgPSBlZGl0b3IgPT4ge1xuICAgICAgcmV0dXJuIE9wdGlvbmFsLmZyb20oZWRpdG9yLmRvbS5nZXRQYXJlbnQoZWRpdG9yLnNlbGVjdGlvbi5nZXRTdGFydCh0cnVlKSwgZWRpdG9yLmRvbS5pc0Jsb2NrKSk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRQYXJlbnRCbG9ja05hbWUgPSBlZGl0b3IgPT4ge1xuICAgICAgcmV0dXJuIGdldFBhcmVudEJsb2NrJDEoZWRpdG9yKS5mb2xkKGNvbnN0YW50KCcnKSwgcGFyZW50QmxvY2sgPT4ge1xuICAgICAgICByZXR1cm4gcGFyZW50QmxvY2subm9kZU5hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgaXNMaXN0SXRlbVBhcmVudEJsb2NrID0gZWRpdG9yID0+IHtcbiAgICAgIHJldHVybiBnZXRQYXJlbnRCbG9jayQxKGVkaXRvcikuZmlsdGVyKGVsbSA9PiB7XG4gICAgICAgIHJldHVybiBpc0xpc3RJdGVtJDEoU3VnYXJFbGVtZW50LmZyb21Eb20oZWxtKSk7XG4gICAgICB9KS5pc1NvbWUoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgaGFzRmlyc3RDaGlsZCA9IChlbG0sIG5hbWUpID0+IHtcbiAgICAgIHJldHVybiBlbG0uZmlyc3RDaGlsZCAmJiBlbG0uZmlyc3RDaGlsZC5ub2RlTmFtZSA9PT0gbmFtZTtcbiAgICB9O1xuICAgIGNvbnN0IGlzRmlyc3RDaGlsZCA9IGVsbSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gKChfYSA9IGVsbS5wYXJlbnROb2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmlyc3RDaGlsZCkgPT09IGVsbTtcbiAgICB9O1xuICAgIGNvbnN0IGhhc1BhcmVudCA9IChlbG0sIHBhcmVudE5hbWUpID0+IHtcbiAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBlbG0gPT09IG51bGwgfHwgZWxtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbG0ucGFyZW50Tm9kZTtcbiAgICAgIHJldHVybiBpc05vbk51bGxhYmxlKHBhcmVudE5vZGUpICYmIHBhcmVudE5vZGUubm9kZU5hbWUgPT09IHBhcmVudE5hbWU7XG4gICAgfTtcbiAgICBjb25zdCBpc0xpc3RCbG9jayA9IGVsbSA9PiB7XG4gICAgICByZXR1cm4gaXNOb25OdWxsYWJsZShlbG0pICYmIC9eKE9MfFVMfExJKSQvLnRlc3QoZWxtLm5vZGVOYW1lKTtcbiAgICB9O1xuICAgIGNvbnN0IGlzTGlzdEl0ZW0gPSBlbG0gPT4ge1xuICAgICAgcmV0dXJuIGlzTm9uTnVsbGFibGUoZWxtKSAmJiAvXihMSXxEVHxERCkkLy50ZXN0KGVsbS5ub2RlTmFtZSk7XG4gICAgfTtcbiAgICBjb25zdCBpc05lc3RlZExpc3QgPSBlbG0gPT4ge1xuICAgICAgcmV0dXJuIGlzTGlzdEJsb2NrKGVsbSkgJiYgaXNMaXN0QmxvY2soZWxtLnBhcmVudE5vZGUpO1xuICAgIH07XG4gICAgY29uc3QgZ2V0Q29udGFpbmVyQmxvY2sgPSBjb250YWluZXJCbG9jayA9PiB7XG4gICAgICBjb25zdCBjb250YWluZXJCbG9ja1BhcmVudCA9IGNvbnRhaW5lckJsb2NrLnBhcmVudE5vZGU7XG4gICAgICByZXR1cm4gaXNMaXN0SXRlbShjb250YWluZXJCbG9ja1BhcmVudCkgPyBjb250YWluZXJCbG9ja1BhcmVudCA6IGNvbnRhaW5lckJsb2NrO1xuICAgIH07XG4gICAgY29uc3QgaXNGaXJzdE9yTGFzdExpID0gKGNvbnRhaW5lckJsb2NrLCBwYXJlbnRCbG9jaywgZmlyc3QpID0+IHtcbiAgICAgIGxldCBub2RlID0gY29udGFpbmVyQmxvY2tbZmlyc3QgPyAnZmlyc3RDaGlsZCcgOiAnbGFzdENoaWxkJ107XG4gICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBpZiAoaXNFbGVtZW50JDYobm9kZSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZVtmaXJzdCA/ICduZXh0U2libGluZycgOiAncHJldmlvdXNTaWJsaW5nJ107XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZSA9PT0gcGFyZW50QmxvY2s7XG4gICAgfTtcbiAgICBjb25zdCBpbnNlcnQkMyA9IChlZGl0b3IsIGNyZWF0ZU5ld0Jsb2NrLCBjb250YWluZXJCbG9jaywgcGFyZW50QmxvY2ssIG5ld0Jsb2NrTmFtZSkgPT4ge1xuICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbTtcbiAgICAgIGNvbnN0IHJuZyA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICBjb25zdCBjb250YWluZXJQYXJlbnQgPSBjb250YWluZXJCbG9jay5wYXJlbnROb2RlO1xuICAgICAgaWYgKGNvbnRhaW5lckJsb2NrID09PSBlZGl0b3IuZ2V0Qm9keSgpIHx8ICFjb250YWluZXJQYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzTmVzdGVkTGlzdChjb250YWluZXJCbG9jaykpIHtcbiAgICAgICAgbmV3QmxvY2tOYW1lID0gJ0xJJztcbiAgICAgIH1cbiAgICAgIGxldCBuZXdCbG9jayA9IGNyZWF0ZU5ld0Jsb2NrKG5ld0Jsb2NrTmFtZSk7XG4gICAgICBpZiAoaXNGaXJzdE9yTGFzdExpKGNvbnRhaW5lckJsb2NrLCBwYXJlbnRCbG9jaywgdHJ1ZSkgJiYgaXNGaXJzdE9yTGFzdExpKGNvbnRhaW5lckJsb2NrLCBwYXJlbnRCbG9jaywgZmFsc2UpKSB7XG4gICAgICAgIGlmIChoYXNQYXJlbnQoY29udGFpbmVyQmxvY2ssICdMSScpKSB7XG4gICAgICAgICAgY29uc3QgY29udGFpbmVyQmxvY2tQYXJlbnQgPSBnZXRDb250YWluZXJCbG9jayhjb250YWluZXJCbG9jayk7XG4gICAgICAgICAgZG9tLmluc2VydEFmdGVyKG5ld0Jsb2NrLCBjb250YWluZXJCbG9ja1BhcmVudCk7XG4gICAgICAgICAgaWYgKGlzRmlyc3RDaGlsZChjb250YWluZXJCbG9jaykpIHtcbiAgICAgICAgICAgIGRvbS5yZW1vdmUoY29udGFpbmVyQmxvY2tQYXJlbnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb20ucmVtb3ZlKGNvbnRhaW5lckJsb2NrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9tLnJlcGxhY2UobmV3QmxvY2ssIGNvbnRhaW5lckJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0ZpcnN0T3JMYXN0TGkoY29udGFpbmVyQmxvY2ssIHBhcmVudEJsb2NrLCB0cnVlKSkge1xuICAgICAgICBpZiAoaGFzUGFyZW50KGNvbnRhaW5lckJsb2NrLCAnTEknKSkge1xuICAgICAgICAgIGRvbS5pbnNlcnRBZnRlcihuZXdCbG9jaywgZ2V0Q29udGFpbmVyQmxvY2soY29udGFpbmVyQmxvY2spKTtcbiAgICAgICAgICBuZXdCbG9jay5hcHBlbmRDaGlsZChkb20uZG9jLmNyZWF0ZVRleHROb2RlKCcgJykpO1xuICAgICAgICAgIG5ld0Jsb2NrLmFwcGVuZENoaWxkKGNvbnRhaW5lckJsb2NrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250YWluZXJQYXJlbnQuaW5zZXJ0QmVmb3JlKG5ld0Jsb2NrLCBjb250YWluZXJCbG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgZG9tLnJlbW92ZShwYXJlbnRCbG9jayk7XG4gICAgICB9IGVsc2UgaWYgKGlzRmlyc3RPckxhc3RMaShjb250YWluZXJCbG9jaywgcGFyZW50QmxvY2ssIGZhbHNlKSkge1xuICAgICAgICBkb20uaW5zZXJ0QWZ0ZXIobmV3QmxvY2ssIGdldENvbnRhaW5lckJsb2NrKGNvbnRhaW5lckJsb2NrKSk7XG4gICAgICAgIGRvbS5yZW1vdmUocGFyZW50QmxvY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyQmxvY2sgPSBnZXRDb250YWluZXJCbG9jayhjb250YWluZXJCbG9jayk7XG4gICAgICAgIGNvbnN0IHRtcFJuZyA9IHJuZy5jbG9uZVJhbmdlKCk7XG4gICAgICAgIHRtcFJuZy5zZXRTdGFydEFmdGVyKHBhcmVudEJsb2NrKTtcbiAgICAgICAgdG1wUm5nLnNldEVuZEFmdGVyKGNvbnRhaW5lckJsb2NrKTtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0bXBSbmcuZXh0cmFjdENvbnRlbnRzKCk7XG4gICAgICAgIGlmIChuZXdCbG9ja05hbWUgPT09ICdMSScgJiYgaGFzRmlyc3RDaGlsZChmcmFnbWVudCwgJ0xJJykpIHtcbiAgICAgICAgICBuZXdCbG9jayA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgZG9tLmluc2VydEFmdGVyKGZyYWdtZW50LCBjb250YWluZXJCbG9jayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9tLmluc2VydEFmdGVyKGZyYWdtZW50LCBjb250YWluZXJCbG9jayk7XG4gICAgICAgICAgZG9tLmluc2VydEFmdGVyKG5ld0Jsb2NrLCBjb250YWluZXJCbG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgZG9tLnJlbW92ZShwYXJlbnRCbG9jayk7XG4gICAgICB9XG4gICAgICBtb3ZlVG9DYXJldFBvc2l0aW9uKGVkaXRvciwgbmV3QmxvY2spO1xuICAgIH07XG5cbiAgICBjb25zdCB0cmltWndzcCA9IGZyYWdtZW50ID0+IHtcbiAgICAgIGVhY2gkZShkZXNjZW5kYW50cyQxKFN1Z2FyRWxlbWVudC5mcm9tRG9tKGZyYWdtZW50KSwgaXNUZXh0JGIpLCB0ZXh0ID0+IHtcbiAgICAgICAgY29uc3QgcmF3Tm9kZSA9IHRleHQuZG9tO1xuICAgICAgICByYXdOb2RlLm5vZGVWYWx1ZSA9IHRyaW0kMShyYXdOb2RlLmRhdGEpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBpc1dpdGhpbk5vbkVkaXRhYmxlTGlzdCA9IChlZGl0b3IsIG5vZGUpID0+IHtcbiAgICAgIGNvbnN0IHBhcmVudExpc3QgPSBlZGl0b3IuZG9tLmdldFBhcmVudChub2RlLCAnb2wsdWwsZGwnKTtcbiAgICAgIHJldHVybiBwYXJlbnRMaXN0ICE9PSBudWxsICYmIGVkaXRvci5kb20uZ2V0Q29udGVudEVkaXRhYmxlUGFyZW50KHBhcmVudExpc3QpID09PSAnZmFsc2UnO1xuICAgIH07XG4gICAgY29uc3QgaXNFbXB0eUFuY2hvciA9IChkb20sIGVsbSkgPT4ge1xuICAgICAgcmV0dXJuIGVsbSAmJiBlbG0ubm9kZU5hbWUgPT09ICdBJyAmJiBkb20uaXNFbXB0eShlbG0pO1xuICAgIH07XG4gICAgY29uc3QgZW1wdHlCbG9jayA9IGVsbSA9PiB7XG4gICAgICBlbG0uaW5uZXJIVE1MID0gJzxiciBkYXRhLW1jZS1ib2d1cz1cIjFcIj4nO1xuICAgIH07XG4gICAgY29uc3QgY29udGFpbmVyQW5kU2libGluZ05hbWUgPSAoY29udGFpbmVyLCBub2RlTmFtZSkgPT4ge1xuICAgICAgcmV0dXJuIGNvbnRhaW5lci5ub2RlTmFtZSA9PT0gbm9kZU5hbWUgfHwgY29udGFpbmVyLnByZXZpb3VzU2libGluZyAmJiBjb250YWluZXIucHJldmlvdXNTaWJsaW5nLm5vZGVOYW1lID09PSBub2RlTmFtZTtcbiAgICB9O1xuICAgIGNvbnN0IGNhblNwbGl0QmxvY2sgPSAoZG9tLCBub2RlKSA9PiB7XG4gICAgICByZXR1cm4gaXNOb25OdWxsYWJsZShub2RlKSAmJiBkb20uaXNCbG9jayhub2RlKSAmJiAhL14oVER8VEh8Q0FQVElPTnxGT1JNKSQvLnRlc3Qobm9kZS5ub2RlTmFtZSkgJiYgIS9eKGZpeGVkfGFic29sdXRlKS9pLnRlc3Qobm9kZS5zdHlsZS5wb3NpdGlvbikgJiYgZG9tLmlzRWRpdGFibGUobm9kZS5wYXJlbnROb2RlKSAmJiBkb20uZ2V0Q29udGVudEVkaXRhYmxlKG5vZGUpICE9PSAnZmFsc2UnO1xuICAgIH07XG4gICAgY29uc3QgdHJpbUlubGluZUVsZW1lbnRzT25MZWZ0U2lkZU9mQmxvY2sgPSAoZG9tLCBub25FbXB0eUVsZW1lbnRzTWFwLCBibG9jaykgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgZmlyc3RDaGlsZHMgPSBbXTtcbiAgICAgIGlmICghYmxvY2spIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IGN1cnJlbnROb2RlID0gYmxvY2s7XG4gICAgICB3aGlsZSAoY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgIGlmIChkb20uaXNCbG9jayhjdXJyZW50Tm9kZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRWxlbWVudCQ2KGN1cnJlbnROb2RlKSAmJiAhbm9uRW1wdHlFbGVtZW50c01hcFtjdXJyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXSkge1xuICAgICAgICAgIGZpcnN0Q2hpbGRzLnB1c2goY3VycmVudE5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgaSA9IGZpcnN0Q2hpbGRzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgY3VycmVudE5vZGUgPSBmaXJzdENoaWxkc1tpXTtcbiAgICAgICAgaWYgKCFjdXJyZW50Tm9kZS5oYXNDaGlsZE5vZGVzKCkgfHwgY3VycmVudE5vZGUuZmlyc3RDaGlsZCA9PT0gY3VycmVudE5vZGUubGFzdENoaWxkICYmICgoX2EgPSBjdXJyZW50Tm9kZS5maXJzdENoaWxkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eubm9kZVZhbHVlKSA9PT0gJycpIHtcbiAgICAgICAgICBkb20ucmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaXNFbXB0eUFuY2hvcihkb20sIGN1cnJlbnROb2RlKSkge1xuICAgICAgICAgICAgZG9tLnJlbW92ZShjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBub3JtYWxpemVad3NwT2Zmc2V0ID0gKHN0YXJ0LCBjb250YWluZXIsIG9mZnNldCkgPT4ge1xuICAgICAgaWYgKCFpc1RleHQkYShjb250YWluZXIpKSB7XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0KSB7XG4gICAgICAgIHJldHVybiBvZmZzZXQgPT09IDEgJiYgY29udGFpbmVyLmRhdGEuY2hhckF0KG9mZnNldCAtIDEpID09PSBaV1NQJDEgPyAwIDogb2Zmc2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9mZnNldCA9PT0gY29udGFpbmVyLmRhdGEubGVuZ3RoIC0gMSAmJiBjb250YWluZXIuZGF0YS5jaGFyQXQob2Zmc2V0KSA9PT0gWldTUCQxID8gY29udGFpbmVyLmRhdGEubGVuZ3RoIDogb2Zmc2V0O1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaW5jbHVkZVp3c3BJblJhbmdlID0gcm5nID0+IHtcbiAgICAgIGNvbnN0IG5ld1JuZyA9IHJuZy5jbG9uZVJhbmdlKCk7XG4gICAgICBuZXdSbmcuc2V0U3RhcnQocm5nLnN0YXJ0Q29udGFpbmVyLCBub3JtYWxpemVad3NwT2Zmc2V0KHRydWUsIHJuZy5zdGFydENvbnRhaW5lciwgcm5nLnN0YXJ0T2Zmc2V0KSk7XG4gICAgICBuZXdSbmcuc2V0RW5kKHJuZy5lbmRDb250YWluZXIsIG5vcm1hbGl6ZVp3c3BPZmZzZXQoZmFsc2UsIHJuZy5lbmRDb250YWluZXIsIHJuZy5lbmRPZmZzZXQpKTtcbiAgICAgIHJldHVybiBuZXdSbmc7XG4gICAgfTtcbiAgICBjb25zdCB0cmltTGVhZGluZ0xpbmVCcmVha3MgPSBub2RlID0+IHtcbiAgICAgIGxldCBjdXJyZW50Tm9kZSA9IG5vZGU7XG4gICAgICBkbyB7XG4gICAgICAgIGlmIChpc1RleHQkYShjdXJyZW50Tm9kZSkpIHtcbiAgICAgICAgICBjdXJyZW50Tm9kZS5kYXRhID0gY3VycmVudE5vZGUuZGF0YS5yZXBsYWNlKC9eW1xcclxcbl0rLywgJycpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUuZmlyc3RDaGlsZDtcbiAgICAgIH0gd2hpbGUgKGN1cnJlbnROb2RlKTtcbiAgICB9O1xuICAgIGNvbnN0IGFwcGx5QXR0cmlidXRlcyA9IChlZGl0b3IsIG5vZGUsIGZvcmNlZFJvb3RCbG9ja0F0dHJzKSA9PiB7XG4gICAgICBjb25zdCBkb20gPSBlZGl0b3IuZG9tO1xuICAgICAgT3B0aW9uYWwuZnJvbShmb3JjZWRSb290QmxvY2tBdHRycy5zdHlsZSkubWFwKGRvbS5wYXJzZVN0eWxlKS5lYWNoKGF0dHJTdHlsZXMgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50U3R5bGVzID0gZ2V0QWxsUmF3KFN1Z2FyRWxlbWVudC5mcm9tRG9tKG5vZGUpKTtcbiAgICAgICAgY29uc3QgbmV3U3R5bGVzID0ge1xuICAgICAgICAgIC4uLmN1cnJlbnRTdHlsZXMsXG4gICAgICAgICAgLi4uYXR0clN0eWxlc1xuICAgICAgICB9O1xuICAgICAgICBkb20uc2V0U3R5bGVzKG5vZGUsIG5ld1N0eWxlcyk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGF0dHJDbGFzc2VzT3B0ID0gT3B0aW9uYWwuZnJvbShmb3JjZWRSb290QmxvY2tBdHRycy5jbGFzcykubWFwKGF0dHJDbGFzc2VzID0+IGF0dHJDbGFzc2VzLnNwbGl0KC9cXHMrLykpO1xuICAgICAgY29uc3QgY3VycmVudENsYXNzZXNPcHQgPSBPcHRpb25hbC5mcm9tKG5vZGUuY2xhc3NOYW1lKS5tYXAoY3VycmVudENsYXNzZXMgPT4gZmlsdGVyJDUoY3VycmVudENsYXNzZXMuc3BsaXQoL1xccysvKSwgY2xhenogPT4gY2xhenogIT09ICcnKSk7XG4gICAgICBsaWZ0MihhdHRyQ2xhc3Nlc09wdCwgY3VycmVudENsYXNzZXNPcHQsIChhdHRyQ2xhc3NlcywgY3VycmVudENsYXNzZXMpID0+IHtcbiAgICAgICAgY29uc3QgZmlsdGVyZWRDbGFzc2VzID0gZmlsdGVyJDUoY3VycmVudENsYXNzZXMsIGNsYXp6ID0+ICFjb250YWlucyQyKGF0dHJDbGFzc2VzLCBjbGF6eikpO1xuICAgICAgICBjb25zdCBuZXdDbGFzc2VzID0gW1xuICAgICAgICAgIC4uLmF0dHJDbGFzc2VzLFxuICAgICAgICAgIC4uLmZpbHRlcmVkQ2xhc3Nlc1xuICAgICAgICBdO1xuICAgICAgICBkb20uc2V0QXR0cmliKG5vZGUsICdjbGFzcycsIG5ld0NsYXNzZXMuam9pbignICcpKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgYXBwbGllZEF0dHJzID0gW1xuICAgICAgICAnc3R5bGUnLFxuICAgICAgICAnY2xhc3MnXG4gICAgICBdO1xuICAgICAgY29uc3QgcmVtYWluaW5nQXR0cnMgPSBmaWx0ZXIkNChmb3JjZWRSb290QmxvY2tBdHRycywgKF8sIGF0dHJzKSA9PiAhY29udGFpbnMkMihhcHBsaWVkQXR0cnMsIGF0dHJzKSk7XG4gICAgICBkb20uc2V0QXR0cmlicyhub2RlLCByZW1haW5pbmdBdHRycyk7XG4gICAgfTtcbiAgICBjb25zdCBzZXRGb3JjZWRCbG9ja0F0dHJzID0gKGVkaXRvciwgbm9kZSkgPT4ge1xuICAgICAgY29uc3QgZm9yY2VkUm9vdEJsb2NrTmFtZSA9IGdldEZvcmNlZFJvb3RCbG9jayhlZGl0b3IpO1xuICAgICAgaWYgKGZvcmNlZFJvb3RCbG9ja05hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgY29uc3QgZm9yY2VkUm9vdEJsb2NrQXR0cnMgPSBnZXRGb3JjZWRSb290QmxvY2tBdHRycyhlZGl0b3IpO1xuICAgICAgICBhcHBseUF0dHJpYnV0ZXMoZWRpdG9yLCBub2RlLCBmb3JjZWRSb290QmxvY2tBdHRycyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB3cmFwU2VsZkFuZFNpYmxpbmdzSW5EZWZhdWx0QmxvY2sgPSAoZWRpdG9yLCBuZXdCbG9ja05hbWUsIHJuZywgY29udGFpbmVyLCBvZmZzZXQpID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBjb25zdCBkb20gPSBlZGl0b3IuZG9tO1xuICAgICAgY29uc3QgZWRpdGFibGVSb290ID0gKF9hID0gZ2V0RWRpdGFibGVSb290KGRvbSwgY29udGFpbmVyKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZG9tLmdldFJvb3QoKTtcbiAgICAgIGxldCBwYXJlbnRCbG9jayA9IGRvbS5nZXRQYXJlbnQoY29udGFpbmVyLCBkb20uaXNCbG9jayk7XG4gICAgICBpZiAoIXBhcmVudEJsb2NrIHx8ICFjYW5TcGxpdEJsb2NrKGRvbSwgcGFyZW50QmxvY2spKSB7XG4gICAgICAgIHBhcmVudEJsb2NrID0gcGFyZW50QmxvY2sgfHwgZWRpdGFibGVSb290O1xuICAgICAgICBpZiAoIXBhcmVudEJsb2NrLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgIGNvbnN0IG5ld0Jsb2NrID0gZG9tLmNyZWF0ZShuZXdCbG9ja05hbWUpO1xuICAgICAgICAgIHNldEZvcmNlZEJsb2NrQXR0cnMoZWRpdG9yLCBuZXdCbG9jayk7XG4gICAgICAgICAgcGFyZW50QmxvY2suYXBwZW5kQ2hpbGQobmV3QmxvY2spO1xuICAgICAgICAgIHJuZy5zZXRTdGFydChuZXdCbG9jaywgMCk7XG4gICAgICAgICAgcm5nLnNldEVuZChuZXdCbG9jaywgMCk7XG4gICAgICAgICAgcmV0dXJuIG5ld0Jsb2NrO1xuICAgICAgICB9XG4gICAgICAgIGxldCBub2RlID0gY29udGFpbmVyO1xuICAgICAgICB3aGlsZSAobm9kZSAmJiBub2RlLnBhcmVudE5vZGUgIT09IHBhcmVudEJsb2NrKSB7XG4gICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnROb2RlO1xuICAgICAgICB3aGlsZSAobm9kZSAmJiAhZG9tLmlzQmxvY2sobm9kZSkpIHtcbiAgICAgICAgICBzdGFydE5vZGUgPSBub2RlO1xuICAgICAgICAgIG5vZGUgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFydE5vZGVOYW1lID0gKF9iID0gc3RhcnROb2RlID09PSBudWxsIHx8IHN0YXJ0Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RhcnROb2RlLnBhcmVudEVsZW1lbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5ub2RlTmFtZTtcbiAgICAgICAgaWYgKHN0YXJ0Tm9kZSAmJiBzdGFydE5vZGVOYW1lICYmIGVkaXRvci5zY2hlbWEuaXNWYWxpZENoaWxkKHN0YXJ0Tm9kZU5hbWUsIG5ld0Jsb2NrTmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgIGNvbnN0IHN0YXJ0Tm9kZVBhcmVudCA9IHN0YXJ0Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgIGNvbnN0IG5ld0Jsb2NrID0gZG9tLmNyZWF0ZShuZXdCbG9ja05hbWUpO1xuICAgICAgICAgIHNldEZvcmNlZEJsb2NrQXR0cnMoZWRpdG9yLCBuZXdCbG9jayk7XG4gICAgICAgICAgc3RhcnROb2RlUGFyZW50Lmluc2VydEJlZm9yZShuZXdCbG9jaywgc3RhcnROb2RlKTtcbiAgICAgICAgICBub2RlID0gc3RhcnROb2RlO1xuICAgICAgICAgIHdoaWxlIChub2RlICYmICFkb20uaXNCbG9jayhub2RlKSkge1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBuZXdCbG9jay5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgIG5vZGUgPSBuZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBybmcuc2V0U3RhcnQoY29udGFpbmVyLCBvZmZzZXQpO1xuICAgICAgICAgIHJuZy5zZXRFbmQoY29udGFpbmVyLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH07XG4gICAgY29uc3QgYWRkQnJUb0Jsb2NrSWZOZWVkZWQgPSAoZG9tLCBibG9jaykgPT4ge1xuICAgICAgYmxvY2subm9ybWFsaXplKCk7XG4gICAgICBjb25zdCBsYXN0Q2hpbGQgPSBibG9jay5sYXN0Q2hpbGQ7XG4gICAgICBpZiAoIWxhc3RDaGlsZCB8fCBpc0VsZW1lbnQkNihsYXN0Q2hpbGQpICYmIC9eKGxlZnR8cmlnaHQpJC9naS50ZXN0KGRvbS5nZXRTdHlsZShsYXN0Q2hpbGQsICdmbG9hdCcsIHRydWUpKSkge1xuICAgICAgICBkb20uYWRkKGJsb2NrLCAnYnInKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNob3VsZEVuZENvbnRhaW5lciA9IChlZGl0b3IsIGNvbnRhaW5lcikgPT4ge1xuICAgICAgY29uc3Qgb3B0aW9uVmFsdWUgPSBzaG91bGRFbmRDb250YWluZXJPbkVtcHR5QmxvY2soZWRpdG9yKTtcbiAgICAgIGlmIChpc051bGxhYmxlKGNvbnRhaW5lcikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpc1N0cmluZyhvcHRpb25WYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5zJDIoVG9vbHMuZXhwbG9kZShvcHRpb25WYWx1ZSksIGNvbnRhaW5lci5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvcHRpb25WYWx1ZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGluc2VydCQyID0gKGVkaXRvciwgZXZ0KSA9PiB7XG4gICAgICBsZXQgY29udGFpbmVyO1xuICAgICAgbGV0IG9mZnNldDtcbiAgICAgIGxldCBwYXJlbnRCbG9ja05hbWU7XG4gICAgICBsZXQgY29udGFpbmVyQmxvY2s7XG4gICAgICBsZXQgaXNBZnRlckxhc3ROb2RlSW5Db250YWluZXIgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb207XG4gICAgICBjb25zdCBzY2hlbWEgPSBlZGl0b3Iuc2NoZW1hLCBub25FbXB0eUVsZW1lbnRzTWFwID0gc2NoZW1hLmdldE5vbkVtcHR5RWxlbWVudHMoKTtcbiAgICAgIGNvbnN0IHJuZyA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICBjb25zdCBuZXdCbG9ja05hbWUgPSBnZXRGb3JjZWRSb290QmxvY2soZWRpdG9yKTtcbiAgICAgIGNvbnN0IGNyZWF0ZU5ld0Jsb2NrID0gbmFtZSA9PiB7XG4gICAgICAgIGxldCBub2RlID0gY29udGFpbmVyO1xuICAgICAgICBjb25zdCB0ZXh0SW5saW5lRWxlbWVudHMgPSBzY2hlbWEuZ2V0VGV4dElubGluZUVsZW1lbnRzKCk7XG4gICAgICAgIGxldCBibG9jaztcbiAgICAgICAgaWYgKG5hbWUgfHwgcGFyZW50QmxvY2tOYW1lID09PSAnVEFCTEUnIHx8IHBhcmVudEJsb2NrTmFtZSA9PT0gJ0hSJykge1xuICAgICAgICAgIGJsb2NrID0gZG9tLmNyZWF0ZShuYW1lIHx8IG5ld0Jsb2NrTmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmxvY2sgPSBwYXJlbnRCbG9jay5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjYXJldE5vZGUgPSBibG9jaztcbiAgICAgICAgaWYgKHNob3VsZEtlZXBTdHlsZXMoZWRpdG9yKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBkb20uc2V0QXR0cmliKGJsb2NrLCAnc3R5bGUnLCBudWxsKTtcbiAgICAgICAgICBkb20uc2V0QXR0cmliKGJsb2NrLCAnY2xhc3MnLCBudWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAodGV4dElubGluZUVsZW1lbnRzW25vZGUubm9kZU5hbWVdKSB7XG4gICAgICAgICAgICAgIGlmIChpc0NhcmV0Tm9kZShub2RlKSB8fCBpc0Jvb2ttYXJrTm9kZSQxKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgY2xvbmVkTm9kZSA9IG5vZGUuY2xvbmVOb2RlKGZhbHNlKTtcbiAgICAgICAgICAgICAgZG9tLnNldEF0dHJpYihjbG9uZWROb2RlLCAnaWQnLCAnJyk7XG4gICAgICAgICAgICAgIGlmIChibG9jay5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICAgICAgICBjbG9uZWROb2RlLmFwcGVuZENoaWxkKGJsb2NrLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKGNsb25lZE5vZGUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhcmV0Tm9kZSA9IGNsb25lZE5vZGU7XG4gICAgICAgICAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQoY2xvbmVkTm9kZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlICgobm9kZSA9IG5vZGUucGFyZW50Tm9kZSkgJiYgbm9kZSAhPT0gZWRpdGFibGVSb290KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRGb3JjZWRCbG9ja0F0dHJzKGVkaXRvciwgYmxvY2spO1xuICAgICAgICBlbXB0eUJsb2NrKGNhcmV0Tm9kZSk7XG4gICAgICAgIHJldHVybiBibG9jaztcbiAgICAgIH07XG4gICAgICBjb25zdCBpc0NhcmV0QXRTdGFydE9yRW5kT2ZCbG9jayA9IHN0YXJ0ID0+IHtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZE9mZnNldCA9IG5vcm1hbGl6ZVp3c3BPZmZzZXQoc3RhcnQsIGNvbnRhaW5lciwgb2Zmc2V0KTtcbiAgICAgICAgaWYgKGlzVGV4dCRhKGNvbnRhaW5lcikgJiYgKHN0YXJ0ID8gbm9ybWFsaXplZE9mZnNldCA+IDAgOiBub3JtYWxpemVkT2Zmc2V0IDwgY29udGFpbmVyLmRhdGEubGVuZ3RoKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGFpbmVyLnBhcmVudE5vZGUgPT09IHBhcmVudEJsb2NrICYmIGlzQWZ0ZXJMYXN0Tm9kZUluQ29udGFpbmVyICYmICFzdGFydCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCAmJiBpc0VsZW1lbnQkNihjb250YWluZXIpICYmIGNvbnRhaW5lciA9PT0gcGFyZW50QmxvY2suZmlyc3RDaGlsZCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250YWluZXJBbmRTaWJsaW5nTmFtZShjb250YWluZXIsICdUQUJMRScpIHx8IGNvbnRhaW5lckFuZFNpYmxpbmdOYW1lKGNvbnRhaW5lciwgJ0hSJykpIHtcbiAgICAgICAgICByZXR1cm4gaXNBZnRlckxhc3ROb2RlSW5Db250YWluZXIgJiYgIXN0YXJ0IHx8ICFpc0FmdGVyTGFzdE5vZGVJbkNvbnRhaW5lciAmJiBzdGFydDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3YWxrZXIgPSBuZXcgRG9tVHJlZVdhbGtlcihjb250YWluZXIsIHBhcmVudEJsb2NrKTtcbiAgICAgICAgaWYgKGlzVGV4dCRhKGNvbnRhaW5lcikpIHtcbiAgICAgICAgICBpZiAoc3RhcnQgJiYgbm9ybWFsaXplZE9mZnNldCA9PT0gMCkge1xuICAgICAgICAgICAgd2Fsa2VyLnByZXYoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFzdGFydCAmJiBub3JtYWxpemVkT2Zmc2V0ID09PSBjb250YWluZXIuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHdhbGtlci5uZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBub2RlO1xuICAgICAgICB3aGlsZSAobm9kZSA9IHdhbGtlci5jdXJyZW50KCkpIHtcbiAgICAgICAgICBpZiAoaXNFbGVtZW50JDYobm9kZSkpIHtcbiAgICAgICAgICAgIGlmICghbm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtbWNlLWJvZ3VzJykpIHtcbiAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgaWYgKG5vbkVtcHR5RWxlbWVudHNNYXBbbmFtZV0gJiYgbmFtZSAhPT0gJ2JyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNUZXh0JGEobm9kZSkgJiYgIWlzV2hpdGVzcGFjZVRleHQobm9kZS5kYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICAgIHdhbGtlci5wcmV2KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdhbGtlci5uZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGluc2VydE5ld0Jsb2NrQWZ0ZXIgPSAoKSA9PiB7XG4gICAgICAgIGxldCBibG9jaztcbiAgICAgICAgaWYgKC9eKEhbMS02XXxQUkV8RklHVVJFKSQvLnRlc3QocGFyZW50QmxvY2tOYW1lKSAmJiBjb250YWluZXJCbG9ja05hbWUgIT09ICdIR1JPVVAnKSB7XG4gICAgICAgICAgYmxvY2sgPSBjcmVhdGVOZXdCbG9jayhuZXdCbG9ja05hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJsb2NrID0gY3JlYXRlTmV3QmxvY2soKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkRW5kQ29udGFpbmVyKGVkaXRvciwgY29udGFpbmVyQmxvY2spICYmIGNhblNwbGl0QmxvY2soZG9tLCBjb250YWluZXJCbG9jaykgJiYgZG9tLmlzRW1wdHkocGFyZW50QmxvY2spKSB7XG4gICAgICAgICAgYmxvY2sgPSBkb20uc3BsaXQoY29udGFpbmVyQmxvY2ssIHBhcmVudEJsb2NrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb20uaW5zZXJ0QWZ0ZXIoYmxvY2ssIHBhcmVudEJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBtb3ZlVG9DYXJldFBvc2l0aW9uKGVkaXRvciwgYmxvY2spO1xuICAgICAgICByZXR1cm4gYmxvY2s7XG4gICAgICB9O1xuICAgICAgbm9ybWFsaXplJDIoZG9tLCBybmcpLmVhY2gobm9ybVJuZyA9PiB7XG4gICAgICAgIHJuZy5zZXRTdGFydChub3JtUm5nLnN0YXJ0Q29udGFpbmVyLCBub3JtUm5nLnN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgcm5nLnNldEVuZChub3JtUm5nLmVuZENvbnRhaW5lciwgbm9ybVJuZy5lbmRPZmZzZXQpO1xuICAgICAgfSk7XG4gICAgICBjb250YWluZXIgPSBybmcuc3RhcnRDb250YWluZXI7XG4gICAgICBvZmZzZXQgPSBybmcuc3RhcnRPZmZzZXQ7XG4gICAgICBjb25zdCBzaGlmdEtleSA9ICEhKGV2dCAmJiBldnQuc2hpZnRLZXkpO1xuICAgICAgY29uc3QgY3RybEtleSA9ICEhKGV2dCAmJiBldnQuY3RybEtleSk7XG4gICAgICBpZiAoaXNFbGVtZW50JDYoY29udGFpbmVyKSAmJiBjb250YWluZXIuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgIGlzQWZ0ZXJMYXN0Tm9kZUluQ29udGFpbmVyID0gb2Zmc2V0ID4gY29udGFpbmVyLmNoaWxkTm9kZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgY29udGFpbmVyID0gY29udGFpbmVyLmNoaWxkTm9kZXNbTWF0aC5taW4ob2Zmc2V0LCBjb250YWluZXIuY2hpbGROb2Rlcy5sZW5ndGggLSAxKV0gfHwgY29udGFpbmVyO1xuICAgICAgICBpZiAoaXNBZnRlckxhc3ROb2RlSW5Db250YWluZXIgJiYgaXNUZXh0JGEoY29udGFpbmVyKSkge1xuICAgICAgICAgIG9mZnNldCA9IGNvbnRhaW5lci5kYXRhLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBlZGl0YWJsZVJvb3QgPSBnZXRFZGl0YWJsZVJvb3QoZG9tLCBjb250YWluZXIpO1xuICAgICAgaWYgKCFlZGl0YWJsZVJvb3QgfHwgaXNXaXRoaW5Ob25FZGl0YWJsZUxpc3QoZWRpdG9yLCBjb250YWluZXIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghc2hpZnRLZXkpIHtcbiAgICAgICAgY29udGFpbmVyID0gd3JhcFNlbGZBbmRTaWJsaW5nc0luRGVmYXVsdEJsb2NrKGVkaXRvciwgbmV3QmxvY2tOYW1lLCBybmcsIGNvbnRhaW5lciwgb2Zmc2V0KTtcbiAgICAgIH1cbiAgICAgIGxldCBwYXJlbnRCbG9jayA9IGRvbS5nZXRQYXJlbnQoY29udGFpbmVyLCBkb20uaXNCbG9jaykgfHwgZG9tLmdldFJvb3QoKTtcbiAgICAgIGNvbnRhaW5lckJsb2NrID0gaXNOb25OdWxsYWJsZShwYXJlbnRCbG9jayA9PT0gbnVsbCB8fCBwYXJlbnRCbG9jayA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50QmxvY2sucGFyZW50Tm9kZSkgPyBkb20uZ2V0UGFyZW50KHBhcmVudEJsb2NrLnBhcmVudE5vZGUsIGRvbS5pc0Jsb2NrKSA6IG51bGw7XG4gICAgICBwYXJlbnRCbG9ja05hbWUgPSBwYXJlbnRCbG9jayA/IHBhcmVudEJsb2NrLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgOiAnJztcbiAgICAgIGNvbnN0IGNvbnRhaW5lckJsb2NrTmFtZSA9IGNvbnRhaW5lckJsb2NrID8gY29udGFpbmVyQmxvY2subm9kZU5hbWUudG9VcHBlckNhc2UoKSA6ICcnO1xuICAgICAgaWYgKGNvbnRhaW5lckJsb2NrTmFtZSA9PT0gJ0xJJyAmJiAhY3RybEtleSkge1xuICAgICAgICBjb25zdCBsaUJsb2NrID0gY29udGFpbmVyQmxvY2s7XG4gICAgICAgIHBhcmVudEJsb2NrID0gbGlCbG9jaztcbiAgICAgICAgY29udGFpbmVyQmxvY2sgPSBsaUJsb2NrLnBhcmVudE5vZGU7XG4gICAgICAgIHBhcmVudEJsb2NrTmFtZSA9IGNvbnRhaW5lckJsb2NrTmFtZTtcbiAgICAgIH1cbiAgICAgIGlmICgvXihMSXxEVHxERCkkLy50ZXN0KHBhcmVudEJsb2NrTmFtZSkgJiYgaXNFbGVtZW50JDYoY29udGFpbmVyQmxvY2spKSB7XG4gICAgICAgIGlmIChkb20uaXNFbXB0eShwYXJlbnRCbG9jaykpIHtcbiAgICAgICAgICBpbnNlcnQkMyhlZGl0b3IsIGNyZWF0ZU5ld0Jsb2NrLCBjb250YWluZXJCbG9jaywgcGFyZW50QmxvY2ssIG5ld0Jsb2NrTmFtZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50QmxvY2sgPT09IGVkaXRvci5nZXRCb2R5KCkgfHwgIWNhblNwbGl0QmxvY2soZG9tLCBwYXJlbnRCbG9jaykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFyZW50QmxvY2tQYXJlbnQgPSBwYXJlbnRCbG9jay5wYXJlbnROb2RlO1xuICAgICAgbGV0IG5ld0Jsb2NrO1xuICAgICAgaWYgKGlzQ2FyZXRDb250YWluZXJCbG9jayQxKHBhcmVudEJsb2NrKSkge1xuICAgICAgICBuZXdCbG9jayA9IHNob3dDYXJldENvbnRhaW5lckJsb2NrKHBhcmVudEJsb2NrKTtcbiAgICAgICAgaWYgKGRvbS5pc0VtcHR5KHBhcmVudEJsb2NrKSkge1xuICAgICAgICAgIGVtcHR5QmxvY2socGFyZW50QmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIHNldEZvcmNlZEJsb2NrQXR0cnMoZWRpdG9yLCBuZXdCbG9jayk7XG4gICAgICAgIG1vdmVUb0NhcmV0UG9zaXRpb24oZWRpdG9yLCBuZXdCbG9jayk7XG4gICAgICB9IGVsc2UgaWYgKGlzQ2FyZXRBdFN0YXJ0T3JFbmRPZkJsb2NrKGZhbHNlKSkge1xuICAgICAgICBuZXdCbG9jayA9IGluc2VydE5ld0Jsb2NrQWZ0ZXIoKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNDYXJldEF0U3RhcnRPckVuZE9mQmxvY2sodHJ1ZSkgJiYgcGFyZW50QmxvY2tQYXJlbnQpIHtcbiAgICAgICAgbmV3QmxvY2sgPSBwYXJlbnRCbG9ja1BhcmVudC5pbnNlcnRCZWZvcmUoY3JlYXRlTmV3QmxvY2soKSwgcGFyZW50QmxvY2spO1xuICAgICAgICBtb3ZlVG9DYXJldFBvc2l0aW9uKGVkaXRvciwgY29udGFpbmVyQW5kU2libGluZ05hbWUocGFyZW50QmxvY2ssICdIUicpID8gbmV3QmxvY2sgOiBwYXJlbnRCbG9jayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0bXBSbmcgPSBpbmNsdWRlWndzcEluUmFuZ2Uocm5nKS5jbG9uZVJhbmdlKCk7XG4gICAgICAgIHRtcFJuZy5zZXRFbmRBZnRlcihwYXJlbnRCbG9jayk7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdG1wUm5nLmV4dHJhY3RDb250ZW50cygpO1xuICAgICAgICB0cmltWndzcChmcmFnbWVudCk7XG4gICAgICAgIHRyaW1MZWFkaW5nTGluZUJyZWFrcyhmcmFnbWVudCk7XG4gICAgICAgIG5ld0Jsb2NrID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgZG9tLmluc2VydEFmdGVyKGZyYWdtZW50LCBwYXJlbnRCbG9jayk7XG4gICAgICAgIHRyaW1JbmxpbmVFbGVtZW50c09uTGVmdFNpZGVPZkJsb2NrKGRvbSwgbm9uRW1wdHlFbGVtZW50c01hcCwgbmV3QmxvY2spO1xuICAgICAgICBhZGRCclRvQmxvY2tJZk5lZWRlZChkb20sIHBhcmVudEJsb2NrKTtcbiAgICAgICAgaWYgKGRvbS5pc0VtcHR5KHBhcmVudEJsb2NrKSkge1xuICAgICAgICAgIGVtcHR5QmxvY2socGFyZW50QmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIG5ld0Jsb2NrLm5vcm1hbGl6ZSgpO1xuICAgICAgICBpZiAoZG9tLmlzRW1wdHkobmV3QmxvY2spKSB7XG4gICAgICAgICAgZG9tLnJlbW92ZShuZXdCbG9jayk7XG4gICAgICAgICAgaW5zZXJ0TmV3QmxvY2tBZnRlcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldEZvcmNlZEJsb2NrQXR0cnMoZWRpdG9yLCBuZXdCbG9jayk7XG4gICAgICAgICAgbW92ZVRvQ2FyZXRQb3NpdGlvbihlZGl0b3IsIG5ld0Jsb2NrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZG9tLnNldEF0dHJpYihuZXdCbG9jaywgJ2lkJywgJycpO1xuICAgICAgZWRpdG9yLmRpc3BhdGNoKCdOZXdCbG9jaycsIHsgbmV3QmxvY2sgfSk7XG4gICAgfTtcbiAgICBjb25zdCBmYWtlRXZlbnROYW1lJDEgPSAnaW5zZXJ0UGFyYWdyYXBoJztcbiAgICBjb25zdCBibG9ja2JyZWFrID0ge1xuICAgICAgaW5zZXJ0OiBpbnNlcnQkMixcbiAgICAgIGZha2VFdmVudE5hbWU6IGZha2VFdmVudE5hbWUkMVxuICAgIH07XG5cbiAgICBjb25zdCBoYXNSaWdodFNpZGVDb250ZW50ID0gKHNjaGVtYSwgY29udGFpbmVyLCBwYXJlbnRCbG9jaykgPT4ge1xuICAgICAgY29uc3Qgd2Fsa2VyID0gbmV3IERvbVRyZWVXYWxrZXIoY29udGFpbmVyLCBwYXJlbnRCbG9jayk7XG4gICAgICBsZXQgbm9kZTtcbiAgICAgIGNvbnN0IG5vbkVtcHR5RWxlbWVudHNNYXAgPSBzY2hlbWEuZ2V0Tm9uRW1wdHlFbGVtZW50cygpO1xuICAgICAgd2hpbGUgKG5vZGUgPSB3YWxrZXIubmV4dCgpKSB7XG4gICAgICAgIGlmIChub25FbXB0eUVsZW1lbnRzTWFwW25vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKV0gfHwgaXNUZXh0JGEobm9kZSkgJiYgbm9kZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGNvbnN0IG1vdmVTZWxlY3Rpb25Ub0JyID0gKGVkaXRvciwgYnJFbG0sIGV4dHJhQnIpID0+IHtcbiAgICAgIGNvbnN0IHJuZyA9IGVkaXRvci5kb20uY3JlYXRlUm5nKCk7XG4gICAgICBpZiAoIWV4dHJhQnIpIHtcbiAgICAgICAgcm5nLnNldFN0YXJ0QWZ0ZXIoYnJFbG0pO1xuICAgICAgICBybmcuc2V0RW5kQWZ0ZXIoYnJFbG0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm5nLnNldFN0YXJ0QmVmb3JlKGJyRWxtKTtcbiAgICAgICAgcm5nLnNldEVuZEJlZm9yZShickVsbSk7XG4gICAgICB9XG4gICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFJuZyhybmcpO1xuICAgICAgc2Nyb2xsUmFuZ2VJbnRvVmlldyhlZGl0b3IsIHJuZyk7XG4gICAgfTtcbiAgICBjb25zdCBpbnNlcnRCckF0Q2FyZXQgPSAoZWRpdG9yLCBldnQpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgICBjb25zdCBkb20gPSBlZGl0b3IuZG9tO1xuICAgICAgY29uc3Qgcm5nID0gc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgbGV0IGJyRWxtO1xuICAgICAgbGV0IGV4dHJhQnIgPSBmYWxzZTtcbiAgICAgIG5vcm1hbGl6ZSQyKGRvbSwgcm5nKS5lYWNoKG5vcm1SbmcgPT4ge1xuICAgICAgICBybmcuc2V0U3RhcnQobm9ybVJuZy5zdGFydENvbnRhaW5lciwgbm9ybVJuZy5zdGFydE9mZnNldCk7XG4gICAgICAgIHJuZy5zZXRFbmQobm9ybVJuZy5lbmRDb250YWluZXIsIG5vcm1SbmcuZW5kT2Zmc2V0KTtcbiAgICAgIH0pO1xuICAgICAgbGV0IG9mZnNldCA9IHJuZy5zdGFydE9mZnNldDtcbiAgICAgIGxldCBjb250YWluZXIgPSBybmcuc3RhcnRDb250YWluZXI7XG4gICAgICBpZiAoaXNFbGVtZW50JDYoY29udGFpbmVyKSAmJiBjb250YWluZXIuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgIGNvbnN0IGlzQWZ0ZXJMYXN0Tm9kZUluQ29udGFpbmVyID0gb2Zmc2V0ID4gY29udGFpbmVyLmNoaWxkTm9kZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgY29udGFpbmVyID0gY29udGFpbmVyLmNoaWxkTm9kZXNbTWF0aC5taW4ob2Zmc2V0LCBjb250YWluZXIuY2hpbGROb2Rlcy5sZW5ndGggLSAxKV0gfHwgY29udGFpbmVyO1xuICAgICAgICBpZiAoaXNBZnRlckxhc3ROb2RlSW5Db250YWluZXIgJiYgaXNUZXh0JGEoY29udGFpbmVyKSkge1xuICAgICAgICAgIG9mZnNldCA9IGNvbnRhaW5lci5kYXRhLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgcGFyZW50QmxvY2sgPSBkb20uZ2V0UGFyZW50KGNvbnRhaW5lciwgZG9tLmlzQmxvY2spO1xuICAgICAgY29uc3QgY29udGFpbmVyQmxvY2sgPSBwYXJlbnRCbG9jayAmJiBwYXJlbnRCbG9jay5wYXJlbnROb2RlID8gZG9tLmdldFBhcmVudChwYXJlbnRCbG9jay5wYXJlbnROb2RlLCBkb20uaXNCbG9jaykgOiBudWxsO1xuICAgICAgY29uc3QgY29udGFpbmVyQmxvY2tOYW1lID0gY29udGFpbmVyQmxvY2sgPyBjb250YWluZXJCbG9jay5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpIDogJyc7XG4gICAgICBjb25zdCBpc0NvbnRyb2xLZXkgPSAhIShldnQgJiYgZXZ0LmN0cmxLZXkpO1xuICAgICAgaWYgKGNvbnRhaW5lckJsb2NrTmFtZSA9PT0gJ0xJJyAmJiAhaXNDb250cm9sS2V5KSB7XG4gICAgICAgIHBhcmVudEJsb2NrID0gY29udGFpbmVyQmxvY2s7XG4gICAgICB9XG4gICAgICBpZiAoaXNUZXh0JGEoY29udGFpbmVyKSAmJiBvZmZzZXQgPj0gY29udGFpbmVyLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGlmICghaGFzUmlnaHRTaWRlQ29udGVudChlZGl0b3Iuc2NoZW1hLCBjb250YWluZXIsIHBhcmVudEJsb2NrIHx8IGRvbS5nZXRSb290KCkpKSB7XG4gICAgICAgICAgYnJFbG0gPSBkb20uY3JlYXRlKCdicicpO1xuICAgICAgICAgIHJuZy5pbnNlcnROb2RlKGJyRWxtKTtcbiAgICAgICAgICBybmcuc2V0U3RhcnRBZnRlcihickVsbSk7XG4gICAgICAgICAgcm5nLnNldEVuZEFmdGVyKGJyRWxtKTtcbiAgICAgICAgICBleHRyYUJyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJFbG0gPSBkb20uY3JlYXRlKCdicicpO1xuICAgICAgcmFuZ2VJbnNlcnROb2RlKGRvbSwgcm5nLCBickVsbSk7XG4gICAgICBtb3ZlU2VsZWN0aW9uVG9CcihlZGl0b3IsIGJyRWxtLCBleHRyYUJyKTtcbiAgICAgIGVkaXRvci51bmRvTWFuYWdlci5hZGQoKTtcbiAgICB9O1xuICAgIGNvbnN0IGluc2VydEJyQmVmb3JlID0gKGVkaXRvciwgaW5saW5lKSA9PiB7XG4gICAgICBjb25zdCBiciA9IFN1Z2FyRWxlbWVudC5mcm9tVGFnKCdicicpO1xuICAgICAgYmVmb3JlJDMoU3VnYXJFbGVtZW50LmZyb21Eb20oaW5saW5lKSwgYnIpO1xuICAgICAgZWRpdG9yLnVuZG9NYW5hZ2VyLmFkZCgpO1xuICAgIH07XG4gICAgY29uc3QgaW5zZXJ0QnJBZnRlciA9IChlZGl0b3IsIGlubGluZSkgPT4ge1xuICAgICAgaWYgKCFoYXNCckFmdGVyKGVkaXRvci5nZXRCb2R5KCksIGlubGluZSkpIHtcbiAgICAgICAgYWZ0ZXIkNChTdWdhckVsZW1lbnQuZnJvbURvbShpbmxpbmUpLCBTdWdhckVsZW1lbnQuZnJvbVRhZygnYnInKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBiciA9IFN1Z2FyRWxlbWVudC5mcm9tVGFnKCdicicpO1xuICAgICAgYWZ0ZXIkNChTdWdhckVsZW1lbnQuZnJvbURvbShpbmxpbmUpLCBicik7XG4gICAgICBtb3ZlU2VsZWN0aW9uVG9CcihlZGl0b3IsIGJyLmRvbSwgZmFsc2UpO1xuICAgICAgZWRpdG9yLnVuZG9NYW5hZ2VyLmFkZCgpO1xuICAgIH07XG4gICAgY29uc3QgaXNCZWZvcmVCciA9IHBvcyA9PiB7XG4gICAgICByZXR1cm4gaXNCciQ2KHBvcy5nZXROb2RlKCkpO1xuICAgIH07XG4gICAgY29uc3QgaGFzQnJBZnRlciA9IChyb290Tm9kZSwgc3RhcnROb2RlKSA9PiB7XG4gICAgICBpZiAoaXNCZWZvcmVCcihDYXJldFBvc2l0aW9uLmFmdGVyKHN0YXJ0Tm9kZSkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5leHRQb3NpdGlvbihyb290Tm9kZSwgQ2FyZXRQb3NpdGlvbi5hZnRlcihzdGFydE5vZGUpKS5tYXAocG9zID0+IHtcbiAgICAgICAgICByZXR1cm4gaXNCciQ2KHBvcy5nZXROb2RlKCkpO1xuICAgICAgICB9KS5nZXRPcihmYWxzZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpc0FuY2hvckxpbmsgPSBlbG0gPT4ge1xuICAgICAgcmV0dXJuIGVsbSAmJiBlbG0ubm9kZU5hbWUgPT09ICdBJyAmJiAnaHJlZicgaW4gZWxtO1xuICAgIH07XG4gICAgY29uc3QgaXNJbnNpZGVBbmNob3IgPSBsb2NhdGlvbiA9PiB7XG4gICAgICByZXR1cm4gbG9jYXRpb24uZm9sZChuZXZlciwgaXNBbmNob3JMaW5rLCBpc0FuY2hvckxpbmssIG5ldmVyKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlYWRJbmxpbmVBbmNob3JMb2NhdGlvbiA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBpc0lubGluZVRhcmdldCQxID0gY3VycnkoaXNJbmxpbmVUYXJnZXQsIGVkaXRvcik7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IENhcmV0UG9zaXRpb24uZnJvbVJhbmdlU3RhcnQoZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKSk7XG4gICAgICByZXR1cm4gcmVhZExvY2F0aW9uKGlzSW5saW5lVGFyZ2V0JDEsIGVkaXRvci5nZXRCb2R5KCksIHBvc2l0aW9uKS5maWx0ZXIoaXNJbnNpZGVBbmNob3IpO1xuICAgIH07XG4gICAgY29uc3QgaW5zZXJ0QnJPdXRzaWRlQW5jaG9yID0gKGVkaXRvciwgbG9jYXRpb24pID0+IHtcbiAgICAgIGxvY2F0aW9uLmZvbGQobm9vcCwgY3VycnkoaW5zZXJ0QnJCZWZvcmUsIGVkaXRvciksIGN1cnJ5KGluc2VydEJyQWZ0ZXIsIGVkaXRvciksIG5vb3ApO1xuICAgIH07XG4gICAgY29uc3QgaW5zZXJ0JDEgPSAoZWRpdG9yLCBldnQpID0+IHtcbiAgICAgIGNvbnN0IGFuY2hvckxvY2F0aW9uID0gcmVhZElubGluZUFuY2hvckxvY2F0aW9uKGVkaXRvcik7XG4gICAgICBpZiAoYW5jaG9yTG9jYXRpb24uaXNTb21lKCkpIHtcbiAgICAgICAgYW5jaG9yTG9jYXRpb24uZWFjaChjdXJyeShpbnNlcnRCck91dHNpZGVBbmNob3IsIGVkaXRvcikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5zZXJ0QnJBdENhcmV0KGVkaXRvciwgZXZ0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGZha2VFdmVudE5hbWUgPSAnaW5zZXJ0TGluZUJyZWFrJztcbiAgICBjb25zdCBsaW5lYnJlYWsgPSB7XG4gICAgICBpbnNlcnQ6IGluc2VydCQxLFxuICAgICAgZmFrZUV2ZW50TmFtZVxuICAgIH07XG5cbiAgICBjb25zdCBtYXRjaGVzU2VsZWN0b3IgPSAoZWRpdG9yLCBzZWxlY3RvcikgPT4ge1xuICAgICAgcmV0dXJuIGdldFBhcmVudEJsb2NrJDEoZWRpdG9yKS5maWx0ZXIocGFyZW50QmxvY2sgPT4ge1xuICAgICAgICByZXR1cm4gc2VsZWN0b3IubGVuZ3RoID4gMCAmJiBpcyQxKFN1Z2FyRWxlbWVudC5mcm9tRG9tKHBhcmVudEJsb2NrKSwgc2VsZWN0b3IpO1xuICAgICAgfSkuaXNTb21lKCk7XG4gICAgfTtcbiAgICBjb25zdCBzaG91bGRJbnNlcnRCciA9IGVkaXRvciA9PiB7XG4gICAgICByZXR1cm4gbWF0Y2hlc1NlbGVjdG9yKGVkaXRvciwgZ2V0QnJOZXdMaW5lU2VsZWN0b3IoZWRpdG9yKSk7XG4gICAgfTtcbiAgICBjb25zdCBzaG91bGRCbG9ja05ld0xpbmUkMSA9IGVkaXRvciA9PiB7XG4gICAgICByZXR1cm4gbWF0Y2hlc1NlbGVjdG9yKGVkaXRvciwgZ2V0Tm9OZXdMaW5lU2VsZWN0b3IoZWRpdG9yKSk7XG4gICAgfTtcblxuICAgIGNvbnN0IG5ld0xpbmVBY3Rpb24gPSBBZHQuZ2VuZXJhdGUoW1xuICAgICAgeyBicjogW10gfSxcbiAgICAgIHsgYmxvY2s6IFtdIH0sXG4gICAgICB7IG5vbmU6IFtdIH1cbiAgICBdKTtcbiAgICBjb25zdCBzaG91bGRCbG9ja05ld0xpbmUgPSAoZWRpdG9yLCBfc2hpZnRLZXkpID0+IHtcbiAgICAgIHJldHVybiBzaG91bGRCbG9ja05ld0xpbmUkMShlZGl0b3IpO1xuICAgIH07XG4gICAgY29uc3QgaW5MaXN0QmxvY2sgPSByZXF1aXJlZFN0YXRlID0+IHtcbiAgICAgIHJldHVybiAoZWRpdG9yLCBfc2hpZnRLZXkpID0+IHtcbiAgICAgICAgcmV0dXJuIGlzTGlzdEl0ZW1QYXJlbnRCbG9jayhlZGl0b3IpID09PSByZXF1aXJlZFN0YXRlO1xuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGluQmxvY2sgPSAoYmxvY2tOYW1lLCByZXF1aXJlZFN0YXRlKSA9PiAoZWRpdG9yLCBfc2hpZnRLZXkpID0+IHtcbiAgICAgIGNvbnN0IHN0YXRlID0gZ2V0UGFyZW50QmxvY2tOYW1lKGVkaXRvcikgPT09IGJsb2NrTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgcmV0dXJuIHN0YXRlID09PSByZXF1aXJlZFN0YXRlO1xuICAgIH07XG4gICAgY29uc3QgaW5DZWZCbG9jayA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBlZGl0YWJsZVJvb3QgPSBnZXRFZGl0YWJsZVJvb3QoZWRpdG9yLmRvbSwgZWRpdG9yLnNlbGVjdGlvbi5nZXRTdGFydCgpKTtcbiAgICAgIHJldHVybiBpc051bGxhYmxlKGVkaXRhYmxlUm9vdCk7XG4gICAgfTtcbiAgICBjb25zdCBpblByZUJsb2NrID0gcmVxdWlyZWRTdGF0ZSA9PiBpbkJsb2NrKCdwcmUnLCByZXF1aXJlZFN0YXRlKTtcbiAgICBjb25zdCBpblN1bW1hcnlCbG9jayA9ICgpID0+IGluQmxvY2soJ3N1bW1hcnknLCB0cnVlKTtcbiAgICBjb25zdCBzaG91bGRQdXRCckluUHJlID0gcmVxdWlyZWRTdGF0ZSA9PiB7XG4gICAgICByZXR1cm4gKGVkaXRvciwgX3NoaWZ0S2V5KSA9PiB7XG4gICAgICAgIHJldHVybiBzaG91bGRQdXRCckluUHJlJDEoZWRpdG9yKSA9PT0gcmVxdWlyZWRTdGF0ZTtcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBpbkJyQ29udGV4dCA9IChlZGl0b3IsIF9zaGlmdEtleSkgPT4ge1xuICAgICAgcmV0dXJuIHNob3VsZEluc2VydEJyKGVkaXRvcik7XG4gICAgfTtcbiAgICBjb25zdCBoYXNTaGlmdEtleSA9IChfZWRpdG9yLCBzaGlmdEtleSkgPT4ge1xuICAgICAgcmV0dXJuIHNoaWZ0S2V5O1xuICAgIH07XG4gICAgY29uc3QgY2FuSW5zZXJ0SW50b0VkaXRhYmxlUm9vdCA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBmb3JjZWRSb290QmxvY2sgPSBnZXRGb3JjZWRSb290QmxvY2soZWRpdG9yKTtcbiAgICAgIGNvbnN0IHJvb3RFZGl0YWJsZSA9IGdldEVkaXRhYmxlUm9vdChlZGl0b3IuZG9tLCBlZGl0b3Iuc2VsZWN0aW9uLmdldFN0YXJ0KCkpO1xuICAgICAgcmV0dXJuIGlzTm9uTnVsbGFibGUocm9vdEVkaXRhYmxlKSAmJiBlZGl0b3Iuc2NoZW1hLmlzVmFsaWRDaGlsZChyb290RWRpdGFibGUubm9kZU5hbWUsIGZvcmNlZFJvb3RCbG9jayk7XG4gICAgfTtcbiAgICBjb25zdCBtYXRjaCA9IChwcmVkaWNhdGVzLCBhY3Rpb24pID0+IHtcbiAgICAgIHJldHVybiAoZWRpdG9yLCBzaGlmdEtleSkgPT4ge1xuICAgICAgICBjb25zdCBpc01hdGNoID0gZm9sZGwocHJlZGljYXRlcywgKHJlcywgcCkgPT4ge1xuICAgICAgICAgIHJldHVybiByZXMgJiYgcChlZGl0b3IsIHNoaWZ0S2V5KTtcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBpc01hdGNoID8gT3B0aW9uYWwuc29tZShhY3Rpb24pIDogT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGdldEFjdGlvbiA9IChlZGl0b3IsIGV2dCkgPT4ge1xuICAgICAgcmV0dXJuIGV2YWx1YXRlVW50aWwoW1xuICAgICAgICBtYXRjaChbc2hvdWxkQmxvY2tOZXdMaW5lXSwgbmV3TGluZUFjdGlvbi5ub25lKCkpLFxuICAgICAgICBtYXRjaChbXG4gICAgICAgICAgaW5QcmVCbG9jayh0cnVlKSxcbiAgICAgICAgICBpbkNlZkJsb2NrXG4gICAgICAgIF0sIG5ld0xpbmVBY3Rpb24ubm9uZSgpKSxcbiAgICAgICAgbWF0Y2goW2luU3VtbWFyeUJsb2NrKCldLCBuZXdMaW5lQWN0aW9uLmJyKCkpLFxuICAgICAgICBtYXRjaChbXG4gICAgICAgICAgaW5QcmVCbG9jayh0cnVlKSxcbiAgICAgICAgICBzaG91bGRQdXRCckluUHJlKGZhbHNlKSxcbiAgICAgICAgICBoYXNTaGlmdEtleVxuICAgICAgICBdLCBuZXdMaW5lQWN0aW9uLmJyKCkpLFxuICAgICAgICBtYXRjaChbXG4gICAgICAgICAgaW5QcmVCbG9jayh0cnVlKSxcbiAgICAgICAgICBzaG91bGRQdXRCckluUHJlKGZhbHNlKVxuICAgICAgICBdLCBuZXdMaW5lQWN0aW9uLmJsb2NrKCkpLFxuICAgICAgICBtYXRjaChbXG4gICAgICAgICAgaW5QcmVCbG9jayh0cnVlKSxcbiAgICAgICAgICBzaG91bGRQdXRCckluUHJlKHRydWUpLFxuICAgICAgICAgIGhhc1NoaWZ0S2V5XG4gICAgICAgIF0sIG5ld0xpbmVBY3Rpb24uYmxvY2soKSksXG4gICAgICAgIG1hdGNoKFtcbiAgICAgICAgICBpblByZUJsb2NrKHRydWUpLFxuICAgICAgICAgIHNob3VsZFB1dEJySW5QcmUodHJ1ZSlcbiAgICAgICAgXSwgbmV3TGluZUFjdGlvbi5icigpKSxcbiAgICAgICAgbWF0Y2goW1xuICAgICAgICAgIGluTGlzdEJsb2NrKHRydWUpLFxuICAgICAgICAgIGhhc1NoaWZ0S2V5XG4gICAgICAgIF0sIG5ld0xpbmVBY3Rpb24uYnIoKSksXG4gICAgICAgIG1hdGNoKFtpbkxpc3RCbG9jayh0cnVlKV0sIG5ld0xpbmVBY3Rpb24uYmxvY2soKSksXG4gICAgICAgIG1hdGNoKFtpbkJyQ29udGV4dF0sIG5ld0xpbmVBY3Rpb24uYnIoKSksXG4gICAgICAgIG1hdGNoKFtoYXNTaGlmdEtleV0sIG5ld0xpbmVBY3Rpb24uYnIoKSksXG4gICAgICAgIG1hdGNoKFtjYW5JbnNlcnRJbnRvRWRpdGFibGVSb290XSwgbmV3TGluZUFjdGlvbi5ibG9jaygpKVxuICAgICAgXSwgW1xuICAgICAgICBlZGl0b3IsXG4gICAgICAgICEhKGV2dCAmJiBldnQuc2hpZnRLZXkpXG4gICAgICBdKS5nZXRPcihuZXdMaW5lQWN0aW9uLm5vbmUoKSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGluc2VydEJyZWFrID0gKGJyZWFrVHlwZSwgZWRpdG9yLCBldnQpID0+IHtcbiAgICAgIGlmICghZWRpdG9yLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICAgIGV4ZWNFZGl0b3JEZWxldGVDb21tYW5kKGVkaXRvcik7XG4gICAgICB9XG4gICAgICBpZiAoaXNOb25OdWxsYWJsZShldnQpKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gZmlyZUZha2VCZWZvcmVJbnB1dEV2ZW50KGVkaXRvciwgYnJlYWtUeXBlLmZha2VFdmVudE5hbWUpO1xuICAgICAgICBpZiAoZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrVHlwZS5pbnNlcnQoZWRpdG9yLCBldnQpO1xuICAgICAgaWYgKGlzTm9uTnVsbGFibGUoZXZ0KSkge1xuICAgICAgICBmaXJlRmFrZUlucHV0RXZlbnQoZWRpdG9yLCBicmVha1R5cGUuZmFrZUV2ZW50TmFtZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpbnNlcnQgPSAoZWRpdG9yLCBldnQpID0+IHtcbiAgICAgIGNvbnN0IGJyID0gKCkgPT4gaW5zZXJ0QnJlYWsobGluZWJyZWFrLCBlZGl0b3IsIGV2dCk7XG4gICAgICBjb25zdCBibG9jayA9ICgpID0+IGluc2VydEJyZWFrKGJsb2NrYnJlYWssIGVkaXRvciwgZXZ0KTtcbiAgICAgIGNvbnN0IGxvZ2ljYWxBY3Rpb24gPSBnZXRBY3Rpb24oZWRpdG9yLCBldnQpO1xuICAgICAgc3dpdGNoIChnZXROZXdsaW5lQmVoYXZpb3IoZWRpdG9yKSkge1xuICAgICAgY2FzZSAnbGluZWJyZWFrJzpcbiAgICAgICAgbG9naWNhbEFjdGlvbi5mb2xkKGJyLCBiciwgbm9vcCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYmxvY2snOlxuICAgICAgICBsb2dpY2FsQWN0aW9uLmZvbGQoYmxvY2ssIGJsb2NrLCBub29wKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpbnZlcnQnOlxuICAgICAgICBsb2dpY2FsQWN0aW9uLmZvbGQoYmxvY2ssIGJyLCBub29wKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBsb2dpY2FsQWN0aW9uLmZvbGQoYnIsIGJsb2NrLCBub29wKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGhhbmRsZUVudGVyS2V5RXZlbnQgPSAoZWRpdG9yLCBldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBlbmRUeXBpbmdMZXZlbElnbm9yZUxvY2tzKGVkaXRvci51bmRvTWFuYWdlcik7XG4gICAgICBlZGl0b3IudW5kb01hbmFnZXIudHJhbnNhY3QoKCkgPT4ge1xuICAgICAgICBpbnNlcnQoZWRpdG9yLCBldmVudCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHNldHVwJGggPSBlZGl0b3IgPT4ge1xuICAgICAgZWRpdG9yLm9uKCdrZXlkb3duJywgZXZlbnQgPT4ge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gVksuRU5URVIpIHtcbiAgICAgICAgICBoYW5kbGVFbnRlcktleUV2ZW50KGVkaXRvciwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgZXhlY3V0ZUtleWRvd25PdmVycmlkZSQyID0gKGVkaXRvciwgY2FyZXQsIGV2dCkgPT4ge1xuICAgICAgY29uc3QgaXNNYWMgPSBFbnYub3MuaXNNYWNPUygpIHx8IEVudi5vcy5pc2lPUygpO1xuICAgICAgZXhlY3V0ZShbXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5FTkQsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24obW92ZVRvTGluZUVuZFBvaW50JDEsIGVkaXRvciwgdHJ1ZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkhPTUUsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24obW92ZVRvTGluZUVuZFBvaW50JDEsIGVkaXRvciwgZmFsc2UpXG4gICAgICAgIH0sXG4gICAgICAgIC4uLiFpc01hYyA/IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBrZXlDb2RlOiBWSy5IT01FLFxuICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24oc2VsZWN0VG9FbmRQb2ludCwgZWRpdG9yLCBmYWxzZSksXG4gICAgICAgICAgICBjdHJsS2V5OiB0cnVlLFxuICAgICAgICAgICAgc2hpZnRLZXk6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGtleUNvZGU6IFZLLkVORCxcbiAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uKHNlbGVjdFRvRW5kUG9pbnQsIGVkaXRvciwgdHJ1ZSksXG4gICAgICAgICAgICBjdHJsS2V5OiB0cnVlLFxuICAgICAgICAgICAgc2hpZnRLZXk6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIF0gOiBbXSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkVORCxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihtb3ZlVG9MaW5lRW5kUG9pbnQsIGVkaXRvciwgdHJ1ZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkhPTUUsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24obW92ZVRvTGluZUVuZFBvaW50LCBlZGl0b3IsIGZhbHNlKVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuRU5ELFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKG1vdmVUb0xpbmVFbmRQb2ludCQyLCBlZGl0b3IsIHRydWUsIGNhcmV0KVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuSE9NRSxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihtb3ZlVG9MaW5lRW5kUG9pbnQkMiwgZWRpdG9yLCBmYWxzZSwgY2FyZXQpXG4gICAgICAgIH1cbiAgICAgIF0sIGV2dCkuZWFjaChfID0+IHtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHNldHVwJGcgPSAoZWRpdG9yLCBjYXJldCkgPT4ge1xuICAgICAgZWRpdG9yLm9uKCdrZXlkb3duJywgZXZ0ID0+IHtcbiAgICAgICAgaWYgKCFldnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICBleGVjdXRlS2V5ZG93bk92ZXJyaWRlJDIoZWRpdG9yLCBjYXJldCwgZXZ0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHNldHVwJGYgPSBlZGl0b3IgPT4ge1xuICAgICAgZWRpdG9yLm9uKCdpbnB1dCcsIGUgPT4ge1xuICAgICAgICBpZiAoIWUuaXNDb21wb3NpbmcpIHtcbiAgICAgICAgICBub3JtYWxpemVOYnNwc0luRWRpdG9yKGVkaXRvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBwbGF0Zm9ybSA9IGRldGVjdCQyKCk7XG4gICAgY29uc3QgZXhlY3V0ZUtleXVwQWN0aW9uID0gKGVkaXRvciwgY2FyZXQsIGV2dCkgPT4ge1xuICAgICAgZXhlY3V0ZShbXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5QQUdFX1VQLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKG1vdmVUb0xpbmVFbmRQb2ludCQyLCBlZGl0b3IsIGZhbHNlLCBjYXJldClcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLlBBR0VfRE9XTixcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihtb3ZlVG9MaW5lRW5kUG9pbnQkMiwgZWRpdG9yLCB0cnVlLCBjYXJldClcbiAgICAgICAgfVxuICAgICAgXSwgZXZ0KTtcbiAgICB9O1xuICAgIGNvbnN0IHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9IGUgPT4gZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICBjb25zdCBpc1BhZ2VVcERvd24gPSBldnQgPT4gZXZ0LmtleUNvZGUgPT09IFZLLlBBR0VfVVAgfHwgZXZ0LmtleUNvZGUgPT09IFZLLlBBR0VfRE9XTjtcbiAgICBjb25zdCBzZXROb2RlQ2hhbmdlQmxvY2tlciA9IChibG9ja2VkLCBlZGl0b3IsIGJsb2NrKSA9PiB7XG4gICAgICBpZiAoYmxvY2sgJiYgIWJsb2NrZWQuZ2V0KCkpIHtcbiAgICAgICAgZWRpdG9yLm9uKCdOb2RlQ2hhbmdlJywgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoIWJsb2NrICYmIGJsb2NrZWQuZ2V0KCkpIHtcbiAgICAgICAgZWRpdG9yLm9mZignTm9kZUNoYW5nZScsIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbik7XG4gICAgICB9XG4gICAgICBibG9ja2VkLnNldChibG9jayk7XG4gICAgfTtcbiAgICBjb25zdCBzZXR1cCRlID0gKGVkaXRvciwgY2FyZXQpID0+IHtcbiAgICAgIGlmIChwbGF0Zm9ybS5vcy5pc01hY09TKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgYmxvY2tlZCA9IENlbGwoZmFsc2UpO1xuICAgICAgZWRpdG9yLm9uKCdrZXlkb3duJywgZXZ0ID0+IHtcbiAgICAgICAgaWYgKGlzUGFnZVVwRG93bihldnQpKSB7XG4gICAgICAgICAgc2V0Tm9kZUNoYW5nZUJsb2NrZXIoYmxvY2tlZCwgZWRpdG9yLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlZGl0b3Iub24oJ2tleXVwJywgZXZ0ID0+IHtcbiAgICAgICAgaWYgKCFldnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICBleGVjdXRlS2V5dXBBY3Rpb24oZWRpdG9yLCBjYXJldCwgZXZ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQYWdlVXBEb3duKGV2dCkgJiYgYmxvY2tlZC5nZXQoKSkge1xuICAgICAgICAgIHNldE5vZGVDaGFuZ2VCbG9ja2VyKGJsb2NrZWQsIGVkaXRvciwgZmFsc2UpO1xuICAgICAgICAgIGVkaXRvci5ub2RlQ2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgaW5zZXJ0VGV4dEF0UG9zaXRpb24gPSAodGV4dCwgcG9zKSA9PiB7XG4gICAgICBjb25zdCBjb250YWluZXIgPSBwb3MuY29udGFpbmVyKCk7XG4gICAgICBjb25zdCBvZmZzZXQgPSBwb3Mub2Zmc2V0KCk7XG4gICAgICBpZiAoaXNUZXh0JGEoY29udGFpbmVyKSkge1xuICAgICAgICBjb250YWluZXIuaW5zZXJ0RGF0YShvZmZzZXQsIHRleHQpO1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShDYXJldFBvc2l0aW9uKGNvbnRhaW5lciwgb2Zmc2V0ICsgdGV4dC5sZW5ndGgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBnZXRFbGVtZW50RnJvbVBvc2l0aW9uKHBvcykubWFwKGVsbSA9PiB7XG4gICAgICAgICAgY29uc3QgdGV4dE5vZGUgPSBTdWdhckVsZW1lbnQuZnJvbVRleHQodGV4dCk7XG4gICAgICAgICAgaWYgKHBvcy5pc0F0RW5kKCkpIHtcbiAgICAgICAgICAgIGFmdGVyJDQoZWxtLCB0ZXh0Tm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJlZm9yZSQzKGVsbSwgdGV4dE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbih0ZXh0Tm9kZS5kb20sIHRleHQubGVuZ3RoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpbnNlcnROYnNwQXRQb3NpdGlvbiA9IGN1cnJ5KGluc2VydFRleHRBdFBvc2l0aW9uLCBuYnNwKTtcbiAgICBjb25zdCBpbnNlcnRTcGFjZUF0UG9zaXRpb24gPSBjdXJyeShpbnNlcnRUZXh0QXRQb3NpdGlvbiwgJyAnKTtcblxuICAgIGNvbnN0IGxvY2F0aW9uVG9DYXJldFBvc2l0aW9uID0gcm9vdCA9PiBsb2NhdGlvbiA9PiBsb2NhdGlvbi5mb2xkKGVsZW1lbnQgPT4gcHJldlBvc2l0aW9uKHJvb3QuZG9tLCBDYXJldFBvc2l0aW9uLmJlZm9yZShlbGVtZW50KSksIGVsZW1lbnQgPT4gZmlyc3RQb3NpdGlvbkluKGVsZW1lbnQpLCBlbGVtZW50ID0+IGxhc3RQb3NpdGlvbkluKGVsZW1lbnQpLCBlbGVtZW50ID0+IG5leHRQb3NpdGlvbihyb290LmRvbSwgQ2FyZXRQb3NpdGlvbi5hZnRlcihlbGVtZW50KSkpO1xuICAgIGNvbnN0IGluc2VydElubGluZUJvdW5kYXJ5U3BhY2VPck5ic3AgPSAocm9vdCwgcG9zKSA9PiBjaGVja1BvcyA9PiBuZWVkc1RvSGF2ZU5ic3Aocm9vdCwgY2hlY2tQb3MpID8gaW5zZXJ0TmJzcEF0UG9zaXRpb24ocG9zKSA6IGluc2VydFNwYWNlQXRQb3NpdGlvbihwb3MpO1xuICAgIGNvbnN0IHNldFNlbGVjdGlvbiA9IGVkaXRvciA9PiBwb3MgPT4ge1xuICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRSbmcocG9zLnRvUmFuZ2UoKSk7XG4gICAgICBlZGl0b3Iubm9kZUNoYW5nZWQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgY29uc3QgaW5zZXJ0U3BhY2VPck5ic3BBdFNlbGVjdGlvbiA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBwb3MgPSBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCkpO1xuICAgICAgY29uc3Qgcm9vdCA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRCb2R5KCkpO1xuICAgICAgaWYgKGVkaXRvci5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgICBjb25zdCBpc0lubGluZVRhcmdldCQxID0gY3VycnkoaXNJbmxpbmVUYXJnZXQsIGVkaXRvcik7XG4gICAgICAgIGNvbnN0IGNhcmV0UG9zaXRpb24gPSBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCkpO1xuICAgICAgICByZXR1cm4gcmVhZExvY2F0aW9uKGlzSW5saW5lVGFyZ2V0JDEsIGVkaXRvci5nZXRCb2R5KCksIGNhcmV0UG9zaXRpb24pLmJpbmQobG9jYXRpb25Ub0NhcmV0UG9zaXRpb24ocm9vdCkpLm1hcChjaGVja1BvcyA9PiAoKSA9PiBpbnNlcnRJbmxpbmVCb3VuZGFyeVNwYWNlT3JOYnNwKHJvb3QsIHBvcykoY2hlY2tQb3MpLmVhY2goc2V0U2VsZWN0aW9uKGVkaXRvcikpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGV4ZWN1dGVLZXlkb3duT3ZlcnJpZGUkMSA9IChlZGl0b3IsIGV2dCkgPT4ge1xuICAgICAgZXhlY3V0ZVdpdGhEZWxheWVkQWN0aW9uKFt7XG4gICAgICAgICAga2V5Q29kZTogVksuU1BBQ0VCQVIsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24oaW5zZXJ0U3BhY2VPck5ic3BBdFNlbGVjdGlvbiwgZWRpdG9yKVxuICAgICAgICB9XSwgZXZ0KS5lYWNoKGFwcGx5QWN0aW9uID0+IHtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gZmlyZUZha2VCZWZvcmVJbnB1dEV2ZW50KGVkaXRvciwgJ2luc2VydFRleHQnLCB7IGRhdGE6ICcgJyB9KTtcbiAgICAgICAgaWYgKCFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgIGFwcGx5QWN0aW9uKCk7XG4gICAgICAgICAgZmlyZUZha2VJbnB1dEV2ZW50KGVkaXRvciwgJ2luc2VydFRleHQnLCB7IGRhdGE6ICcgJyB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBzZXR1cCRkID0gZWRpdG9yID0+IHtcbiAgICAgIGVkaXRvci5vbigna2V5ZG93bicsIGV2dCA9PiB7XG4gICAgICAgIGlmICghZXZ0LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgZXhlY3V0ZUtleWRvd25PdmVycmlkZSQxKGVkaXRvciwgZXZ0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHRhYmxlVGFiTmF2aWdhdGlvbiA9IGVkaXRvciA9PiB7XG4gICAgICBpZiAoaGFzVGFibGVUYWJOYXZpZ2F0aW9uKGVkaXRvcikpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBrZXlDb2RlOiBWSy5UQUIsXG4gICAgICAgICAgICBhY3Rpb246IGFjdGlvbihoYW5kbGVUYWIsIGVkaXRvciwgdHJ1ZSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGtleUNvZGU6IFZLLlRBQixcbiAgICAgICAgICAgIHNoaWZ0S2V5OiB0cnVlLFxuICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24oaGFuZGxlVGFiLCBlZGl0b3IsIGZhbHNlKVxuICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGV4ZWN1dGVLZXlkb3duT3ZlcnJpZGUgPSAoZWRpdG9yLCBldnQpID0+IHtcbiAgICAgIGV4ZWN1dGUoWy4uLnRhYmxlVGFiTmF2aWdhdGlvbihlZGl0b3IpXSwgZXZ0KS5lYWNoKF8gPT4ge1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3Qgc2V0dXAkYyA9IGVkaXRvciA9PiB7XG4gICAgICBlZGl0b3Iub24oJ2tleWRvd24nLCBldnQgPT4ge1xuICAgICAgICBpZiAoIWV2dC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgIGV4ZWN1dGVLZXlkb3duT3ZlcnJpZGUoZWRpdG9yLCBldnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3Qgc2V0dXAkYiA9IGVkaXRvciA9PiB7XG4gICAgICBlZGl0b3IuYWRkU2hvcnRjdXQoJ01ldGErUCcsICcnLCAnbWNlUHJpbnQnKTtcbiAgICAgIHNldHVwJGooZWRpdG9yKTtcbiAgICAgIGlmIChpc1J0YyhlZGl0b3IpKSB7XG4gICAgICAgIHJldHVybiBDZWxsKG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY2FyZXQgPSBzZXR1cFNlbGVjdGVkU3RhdGUoZWRpdG9yKTtcbiAgICAgICAgc2V0dXAkbChlZGl0b3IpO1xuICAgICAgICBzZXR1cCRrKGVkaXRvciwgY2FyZXQpO1xuICAgICAgICBzZXR1cCRpKGVkaXRvciwgY2FyZXQpO1xuICAgICAgICBzZXR1cCRoKGVkaXRvcik7XG4gICAgICAgIHNldHVwJGQoZWRpdG9yKTtcbiAgICAgICAgc2V0dXAkZihlZGl0b3IpO1xuICAgICAgICBzZXR1cCRjKGVkaXRvcik7XG4gICAgICAgIHNldHVwJGcoZWRpdG9yLCBjYXJldCk7XG4gICAgICAgIHNldHVwJGUoZWRpdG9yLCBjYXJldCk7XG4gICAgICAgIHJldHVybiBjYXJldDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY2xhc3MgTm9kZUNoYW5nZSB7XG4gICAgICBjb25zdHJ1Y3RvcihlZGl0b3IpIHtcbiAgICAgICAgdGhpcy5sYXN0UGF0aCA9IFtdO1xuICAgICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgbGV0IGxhc3RSbmc7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoISgnb25zZWxlY3Rpb25jaGFuZ2UnIGluIGVkaXRvci5nZXREb2MoKSkpIHtcbiAgICAgICAgICBlZGl0b3Iub24oJ05vZGVDaGFuZ2UgY2xpY2sgbW91c2V1cCBrZXl1cCBmb2N1cycsIGUgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmF0aXZlUm5nID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgICAgICAgIGNvbnN0IGZha2VSbmcgPSB7XG4gICAgICAgICAgICAgIHN0YXJ0Q29udGFpbmVyOiBuYXRpdmVSbmcuc3RhcnRDb250YWluZXIsXG4gICAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiBuYXRpdmVSbmcuc3RhcnRPZmZzZXQsXG4gICAgICAgICAgICAgIGVuZENvbnRhaW5lcjogbmF0aXZlUm5nLmVuZENvbnRhaW5lcixcbiAgICAgICAgICAgICAgZW5kT2Zmc2V0OiBuYXRpdmVSbmcuZW5kT2Zmc2V0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gJ25vZGVjaGFuZ2UnIHx8ICFpc0VxJDQoZmFrZVJuZywgbGFzdFJuZykpIHtcbiAgICAgICAgICAgICAgZWRpdG9yLmRpc3BhdGNoKCdTZWxlY3Rpb25DaGFuZ2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RSbmcgPSBmYWtlUm5nO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVkaXRvci5vbignY29udGV4dG1lbnUnLCAoKSA9PiB7XG4gICAgICAgICAgZWRpdG9yLmRpc3BhdGNoKCdTZWxlY3Rpb25DaGFuZ2UnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVkaXRvci5vbignU2VsZWN0aW9uQ2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0YXJ0RWxtID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRTdGFydCh0cnVlKTtcbiAgICAgICAgICBpZiAoIXN0YXJ0RWxtKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYXNBbnlSYW5nZXMoZWRpdG9yKSAmJiAhc2VsZi5pc1NhbWVFbGVtZW50UGF0aChzdGFydEVsbSkgJiYgZWRpdG9yLmRvbS5pc0NoaWxkT2Yoc3RhcnRFbG0sIGVkaXRvci5nZXRCb2R5KCkpKSB7XG4gICAgICAgICAgICBlZGl0b3Iubm9kZUNoYW5nZWQoeyBzZWxlY3Rpb25DaGFuZ2U6IHRydWUgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZWRpdG9yLm9uKCdtb3VzZXVwJywgZSA9PiB7XG4gICAgICAgICAgaWYgKCFlLmlzRGVmYXVsdFByZXZlbnRlZCgpICYmIGhhc0FueVJhbmdlcyhlZGl0b3IpKSB7XG4gICAgICAgICAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbi5nZXROb2RlKCkubm9kZU5hbWUgPT09ICdJTUcnKSB7XG4gICAgICAgICAgICAgIERlbGF5LnNldEVkaXRvclRpbWVvdXQoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZWRpdG9yLm5vZGVDaGFuZ2VkKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWRpdG9yLm5vZGVDaGFuZ2VkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIG5vZGVDaGFuZ2VkKGFyZ3MgPSB7fSkge1xuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSB0aGlzLmVkaXRvci5zZWxlY3Rpb247XG4gICAgICAgIGxldCBub2RlO1xuICAgICAgICBpZiAodGhpcy5lZGl0b3IuaW5pdGlhbGl6ZWQgJiYgc2VsZWN0aW9uICYmICFzaG91bGREaXNhYmxlTm9kZUNoYW5nZSh0aGlzLmVkaXRvcikgJiYgIXRoaXMuZWRpdG9yLm1vZGUuaXNSZWFkT25seSgpKSB7XG4gICAgICAgICAgY29uc3Qgcm9vdCA9IHRoaXMuZWRpdG9yLmdldEJvZHkoKTtcbiAgICAgICAgICBub2RlID0gc2VsZWN0aW9uLmdldFN0YXJ0KHRydWUpIHx8IHJvb3Q7XG4gICAgICAgICAgaWYgKG5vZGUub3duZXJEb2N1bWVudCAhPT0gdGhpcy5lZGl0b3IuZ2V0RG9jKCkgfHwgIXRoaXMuZWRpdG9yLmRvbS5pc0NoaWxkT2Yobm9kZSwgcm9vdCkpIHtcbiAgICAgICAgICAgIG5vZGUgPSByb290O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBwYXJlbnRzID0gW107XG4gICAgICAgICAgdGhpcy5lZGl0b3IuZG9tLmdldFBhcmVudChub2RlLCBub2RlID0+IHtcbiAgICAgICAgICAgIGlmIChub2RlID09PSByb290KSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGFyZW50cy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5lZGl0b3IuZGlzcGF0Y2goJ05vZGVDaGFuZ2UnLCB7XG4gICAgICAgICAgICAuLi5hcmdzLFxuICAgICAgICAgICAgZWxlbWVudDogbm9kZSxcbiAgICAgICAgICAgIHBhcmVudHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaXNTYW1lRWxlbWVudFBhdGgoc3RhcnRFbG0pIHtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgICAgICBjb25zdCBjdXJyZW50UGF0aCA9IHJldmVyc2UoZWRpdG9yLmRvbS5nZXRQYXJlbnRzKHN0YXJ0RWxtLCBhbHdheXMsIGVkaXRvci5nZXRCb2R5KCkpKTtcbiAgICAgICAgaWYgKGN1cnJlbnRQYXRoLmxlbmd0aCA9PT0gdGhpcy5sYXN0UGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKGkgPSBjdXJyZW50UGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFBhdGhbaV0gIT09IHRoaXMubGFzdFBhdGhbaV0pIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5sYXN0UGF0aCA9IGN1cnJlbnRQYXRoO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdFBhdGggPSBjdXJyZW50UGF0aDtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGludGVybmFsTWltZVR5cGUgPSAneC10aW55bWNlL2h0bWwnO1xuICAgIGNvbnN0IGludGVybmFsSHRtbE1pbWUgPSBjb25zdGFudChpbnRlcm5hbE1pbWVUeXBlKTtcbiAgICBjb25zdCBpbnRlcm5hbE1hcmsgPSAnPCEtLSAnICsgaW50ZXJuYWxNaW1lVHlwZSArICcgLS0+JztcbiAgICBjb25zdCBtYXJrID0gaHRtbCA9PiBpbnRlcm5hbE1hcmsgKyBodG1sO1xuICAgIGNvbnN0IHVubWFyayA9IGh0bWwgPT4gaHRtbC5yZXBsYWNlKGludGVybmFsTWFyaywgJycpO1xuICAgIGNvbnN0IGlzTWFya2VkID0gaHRtbCA9PiBodG1sLmluZGV4T2YoaW50ZXJuYWxNYXJrKSAhPT0gLTE7XG5cbiAgICBjb25zdCBpc1BsYWluVGV4dCA9IHRleHQgPT4ge1xuICAgICAgcmV0dXJuICEvPCg/OlxcLz8oPyEoPzpkaXZ8cHxicnxzcGFuKT4pXFx3K3woPzooPyEoPzpzcGFuIHN0eWxlPVwid2hpdGUtc3BhY2U6XFxzP3ByZTs/XCI+KXxiclxccz9cXC8+KSlcXHcrXFxzW14+XSspPi9pLnRlc3QodGV4dCk7XG4gICAgfTtcbiAgICBjb25zdCBvcGVuQ29udGFpbmVyID0gKHJvb3RUYWcsIHJvb3RBdHRycykgPT4ge1xuICAgICAgbGV0IHRhZyA9ICc8JyArIHJvb3RUYWc7XG4gICAgICBjb25zdCBhdHRycyA9IG1hcFRvQXJyYXkocm9vdEF0dHJzLCAodmFsdWUsIGtleSkgPT4ga2V5ICsgJz1cIicgKyBFbnRpdGllcy5lbmNvZGVBbGxSYXcodmFsdWUpICsgJ1wiJyk7XG4gICAgICBpZiAoYXR0cnMubGVuZ3RoKSB7XG4gICAgICAgIHRhZyArPSAnICcgKyBhdHRycy5qb2luKCcgJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFnICsgJz4nO1xuICAgIH07XG4gICAgY29uc3QgdG9CbG9ja0VsZW1lbnRzID0gKHRleHQsIHJvb3RUYWcsIHJvb3RBdHRycykgPT4ge1xuICAgICAgY29uc3QgYmxvY2tzID0gdGV4dC5zcGxpdCgvXFxuXFxuLyk7XG4gICAgICBjb25zdCB0YWdPcGVuID0gb3BlbkNvbnRhaW5lcihyb290VGFnLCByb290QXR0cnMpO1xuICAgICAgY29uc3QgdGFnQ2xvc2UgPSAnPC8nICsgcm9vdFRhZyArICc+JztcbiAgICAgIGNvbnN0IHBhcmFncmFwaHMgPSBtYXAkMyhibG9ja3MsIHAgPT4ge1xuICAgICAgICByZXR1cm4gcC5zcGxpdCgvXFxuLykuam9pbignPGJyIC8+Jyk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHN0aXRjaCA9IHAgPT4ge1xuICAgICAgICByZXR1cm4gdGFnT3BlbiArIHAgKyB0YWdDbG9zZTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gcGFyYWdyYXBocy5sZW5ndGggPT09IDEgPyBwYXJhZ3JhcGhzWzBdIDogbWFwJDMocGFyYWdyYXBocywgc3RpdGNoKS5qb2luKCcnKTtcbiAgICB9O1xuXG4gICAgY29uc3QgcGFzdGVCaW5EZWZhdWx0Q29udGVudCA9ICclTUNFUEFTVEVCSU4lJztcbiAgICBjb25zdCBjcmVhdGUkNiA9IChlZGl0b3IsIGxhc3RSbmdDZWxsKSA9PiB7XG4gICAgICBjb25zdCB7ZG9tLCBzZWxlY3Rpb259ID0gZWRpdG9yO1xuICAgICAgY29uc3QgYm9keSA9IGVkaXRvci5nZXRCb2R5KCk7XG4gICAgICBsYXN0Um5nQ2VsbC5zZXQoc2VsZWN0aW9uLmdldFJuZygpKTtcbiAgICAgIGNvbnN0IHBhc3RlQmluRWxtID0gZG9tLmFkZChlZGl0b3IuZ2V0Qm9keSgpLCAnZGl2Jywge1xuICAgICAgICAnaWQnOiAnbWNlcGFzdGViaW4nLFxuICAgICAgICAnY2xhc3MnOiAnbWNlLXBhc3RlYmluJyxcbiAgICAgICAgJ2NvbnRlbnRFZGl0YWJsZSc6IHRydWUsXG4gICAgICAgICdkYXRhLW1jZS1ib2d1cyc6ICdhbGwnLFxuICAgICAgICAnc3R5bGUnOiAncG9zaXRpb246IGZpeGVkOyB0b3A6IDUwJTsgd2lkdGg6IDEwcHg7IGhlaWdodDogMTBweDsgb3ZlcmZsb3c6IGhpZGRlbjsgb3BhY2l0eTogMCdcbiAgICAgIH0sIHBhc3RlQmluRGVmYXVsdENvbnRlbnQpO1xuICAgICAgaWYgKEVudi5icm93c2VyLmlzRmlyZWZveCgpKSB7XG4gICAgICAgIGRvbS5zZXRTdHlsZShwYXN0ZUJpbkVsbSwgJ2xlZnQnLCBkb20uZ2V0U3R5bGUoYm9keSwgJ2RpcmVjdGlvbicsIHRydWUpID09PSAncnRsJyA/IDY1NTM1IDogLTY1NTM1KTtcbiAgICAgIH1cbiAgICAgIGRvbS5iaW5kKHBhc3RlQmluRWxtLCAnYmVmb3JlZGVhY3RpdmF0ZSBmb2N1c2luIGZvY3Vzb3V0JywgZSA9PiB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9KTtcbiAgICAgIHBhc3RlQmluRWxtLmZvY3VzKCk7XG4gICAgICBzZWxlY3Rpb24uc2VsZWN0KHBhc3RlQmluRWxtLCB0cnVlKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZSA9IChlZGl0b3IsIGxhc3RSbmdDZWxsKSA9PiB7XG4gICAgICBjb25zdCBkb20gPSBlZGl0b3IuZG9tO1xuICAgICAgaWYgKGdldEVsKGVkaXRvcikpIHtcbiAgICAgICAgbGV0IHBhc3RlQmluQ2xvbmU7XG4gICAgICAgIGNvbnN0IGxhc3RSbmcgPSBsYXN0Um5nQ2VsbC5nZXQoKTtcbiAgICAgICAgd2hpbGUgKHBhc3RlQmluQ2xvbmUgPSBnZXRFbChlZGl0b3IpKSB7XG4gICAgICAgICAgZG9tLnJlbW92ZShwYXN0ZUJpbkNsb25lKTtcbiAgICAgICAgICBkb20udW5iaW5kKHBhc3RlQmluQ2xvbmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0Um5nKSB7XG4gICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRSbmcobGFzdFJuZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxhc3RSbmdDZWxsLnNldChudWxsKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldEVsID0gZWRpdG9yID0+IGVkaXRvci5kb20uZ2V0KCdtY2VwYXN0ZWJpbicpO1xuICAgIGNvbnN0IGlzUGFzdGVCaW4gPSBlbG0gPT4gaXNOb25OdWxsYWJsZShlbG0pICYmIGVsbS5pZCA9PT0gJ21jZXBhc3RlYmluJztcbiAgICBjb25zdCBnZXRIdG1sID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb207XG4gICAgICBjb25zdCBjb3B5QW5kUmVtb3ZlID0gKHRvRWxtLCBmcm9tRWxtKSA9PiB7XG4gICAgICAgIHRvRWxtLmFwcGVuZENoaWxkKGZyb21FbG0pO1xuICAgICAgICBkb20ucmVtb3ZlKGZyb21FbG0sIHRydWUpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IFtwYXN0ZUJpbkVsbSwgLi4ucGFzdGVCaW5DbG9uZXNdID0gZmlsdGVyJDUoZWRpdG9yLmdldEJvZHkoKS5jaGlsZE5vZGVzLCBpc1Bhc3RlQmluKTtcbiAgICAgIGVhY2gkZShwYXN0ZUJpbkNsb25lcywgcGFzdGVCaW5DbG9uZSA9PiB7XG4gICAgICAgIGNvcHlBbmRSZW1vdmUocGFzdGVCaW5FbG0sIHBhc3RlQmluQ2xvbmUpO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBkaXJ0eVdyYXBwZXJzID0gZG9tLnNlbGVjdCgnZGl2W2lkPW1jZXBhc3RlYmluXScsIHBhc3RlQmluRWxtKTtcbiAgICAgIGZvciAobGV0IGkgPSBkaXJ0eVdyYXBwZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGNsZWFuV3JhcHBlciA9IGRvbS5jcmVhdGUoJ2RpdicpO1xuICAgICAgICBwYXN0ZUJpbkVsbS5pbnNlcnRCZWZvcmUoY2xlYW5XcmFwcGVyLCBkaXJ0eVdyYXBwZXJzW2ldKTtcbiAgICAgICAgY29weUFuZFJlbW92ZShjbGVhbldyYXBwZXIsIGRpcnR5V3JhcHBlcnNbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhc3RlQmluRWxtID8gcGFzdGVCaW5FbG0uaW5uZXJIVE1MIDogJyc7XG4gICAgfTtcbiAgICBjb25zdCBpc0RlZmF1bHRQYXN0ZUJpbkNvbnRlbnQgPSBjb250ZW50ID0+IGNvbnRlbnQgPT09IHBhc3RlQmluRGVmYXVsdENvbnRlbnQ7XG4gICAgY29uc3QgUGFzdGVCaW4gPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgbGFzdFJuZyA9IENlbGwobnVsbCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjcmVhdGU6ICgpID0+IGNyZWF0ZSQ2KGVkaXRvciwgbGFzdFJuZyksXG4gICAgICAgIHJlbW92ZTogKCkgPT4gcmVtb3ZlKGVkaXRvciwgbGFzdFJuZyksXG4gICAgICAgIGdldEVsOiAoKSA9PiBnZXRFbChlZGl0b3IpLFxuICAgICAgICBnZXRIdG1sOiAoKSA9PiBnZXRIdG1sKGVkaXRvciksXG4gICAgICAgIGdldExhc3RSbmc6IGxhc3RSbmcuZ2V0XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBmaWx0ZXIkMSA9IChjb250ZW50LCBpdGVtcykgPT4ge1xuICAgICAgVG9vbHMuZWFjaChpdGVtcywgdiA9PiB7XG4gICAgICAgIGlmIChpcyQ0KHYsIFJlZ0V4cCkpIHtcbiAgICAgICAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKHYsICcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKHZbMF0sIHZbMV0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH07XG4gICAgY29uc3QgaW5uZXJUZXh0ID0gaHRtbCA9PiB7XG4gICAgICBjb25zdCBzY2hlbWEgPSBTY2hlbWEoKTtcbiAgICAgIGNvbnN0IGRvbVBhcnNlciA9IERvbVBhcnNlcih7fSwgc2NoZW1hKTtcbiAgICAgIGxldCB0ZXh0ID0gJyc7XG4gICAgICBjb25zdCB2b2lkRWxlbWVudHMgPSBzY2hlbWEuZ2V0Vm9pZEVsZW1lbnRzKCk7XG4gICAgICBjb25zdCBpZ25vcmVFbGVtZW50cyA9IFRvb2xzLm1ha2VNYXAoJ3NjcmlwdCBub3NjcmlwdCBzdHlsZSB0ZXh0YXJlYSB2aWRlbyBhdWRpbyBpZnJhbWUgb2JqZWN0JywgJyAnKTtcbiAgICAgIGNvbnN0IGJsb2NrRWxlbWVudHMgPSBzY2hlbWEuZ2V0QmxvY2tFbGVtZW50cygpO1xuICAgICAgY29uc3Qgd2FsayA9IG5vZGUgPT4ge1xuICAgICAgICBjb25zdCBuYW1lID0gbm9kZS5uYW1lLCBjdXJyZW50Tm9kZSA9IG5vZGU7XG4gICAgICAgIGlmIChuYW1lID09PSAnYnInKSB7XG4gICAgICAgICAgdGV4dCArPSAnXFxuJztcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgPT09ICd3YnInKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2b2lkRWxlbWVudHNbbmFtZV0pIHtcbiAgICAgICAgICB0ZXh0ICs9ICcgJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWdub3JlRWxlbWVudHNbbmFtZV0pIHtcbiAgICAgICAgICB0ZXh0ICs9ICcgJztcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gMykge1xuICAgICAgICAgIHRleHQgKz0gbm9kZS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShub2RlLm5hbWUgaW4gc2NoZW1hLmdldFZvaWRFbGVtZW50cygpKSkge1xuICAgICAgICAgIGxldCBjdXJyZW50Tm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICBpZiAoY3VycmVudE5vZGUpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgd2FsayhjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICB9IHdoaWxlIChjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLm5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYmxvY2tFbGVtZW50c1tuYW1lXSAmJiBjdXJyZW50Tm9kZS5uZXh0KSB7XG4gICAgICAgICAgdGV4dCArPSAnXFxuJztcbiAgICAgICAgICBpZiAobmFtZSA9PT0gJ3AnKSB7XG4gICAgICAgICAgICB0ZXh0ICs9ICdcXG4nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGh0bWwgPSBmaWx0ZXIkMShodG1sLCBbLzwhXFxbW15cXF1dK1xcXT4vZ10pO1xuICAgICAgd2Fsayhkb21QYXJzZXIucGFyc2UoaHRtbCkpO1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcbiAgICBjb25zdCB0cmltSHRtbCA9IGh0bWwgPT4ge1xuICAgICAgY29uc3QgdHJpbVNwYWNlcyA9IChhbGwsIHMxLCBzMikgPT4ge1xuICAgICAgICBpZiAoIXMxICYmICFzMikge1xuICAgICAgICAgIHJldHVybiAnICc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ic3A7XG4gICAgICB9O1xuICAgICAgaHRtbCA9IGZpbHRlciQxKGh0bWwsIFtcbiAgICAgICAgL15bXFxzXFxTXSo8Ym9keVtePl0qPlxccyp8XFxzKjxcXC9ib2R5W14+XSo+W1xcc1xcU10qJC9pZyxcbiAgICAgICAgLzwhLS1TdGFydEZyYWdtZW50LS0+fDwhLS1FbmRGcmFnbWVudC0tPi9nLFxuICAgICAgICBbXG4gICAgICAgICAgLyggPyk8c3BhbiBjbGFzcz1cIkFwcGxlLWNvbnZlcnRlZC1zcGFjZVwiPlxcdTAwYTA8XFwvc3Bhbj4oID8pL2csXG4gICAgICAgICAgdHJpbVNwYWNlc1xuICAgICAgICBdLFxuICAgICAgICAvPGJyIGNsYXNzPVwiQXBwbGUtaW50ZXJjaGFuZ2UtbmV3bGluZVwiPi9nLFxuICAgICAgICAvPGJyPiQvaVxuICAgICAgXSk7XG4gICAgICByZXR1cm4gaHRtbDtcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZUlkR2VuZXJhdG9yID0gcHJlZml4ID0+IHtcbiAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICByZXR1cm4gcHJlZml4ICsgY291bnQrKztcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBnZXRJbWFnZU1pbWVUeXBlID0gZXh0ID0+IHtcbiAgICAgIGNvbnN0IGxvd2VyRXh0ID0gZXh0LnRvTG93ZXJDYXNlKCk7XG4gICAgICBjb25zdCBtaW1lT3ZlcnJpZGVzID0ge1xuICAgICAgICBqcGc6ICdqcGVnJyxcbiAgICAgICAganBlOiAnanBlZycsXG4gICAgICAgIGpmaTogJ2pwZWcnLFxuICAgICAgICBqaWY6ICdqcGVnJyxcbiAgICAgICAgamZpZjogJ2pwZWcnLFxuICAgICAgICBwanBlZzogJ2pwZWcnLFxuICAgICAgICBwanA6ICdqcGVnJyxcbiAgICAgICAgc3ZnOiAnc3ZnK3htbCdcbiAgICAgIH07XG4gICAgICByZXR1cm4gVG9vbHMuaGFzT3duKG1pbWVPdmVycmlkZXMsIGxvd2VyRXh0KSA/ICdpbWFnZS8nICsgbWltZU92ZXJyaWRlc1tsb3dlckV4dF0gOiAnaW1hZ2UvJyArIGxvd2VyRXh0O1xuICAgIH07XG5cbiAgICBjb25zdCBwcmVQcm9jZXNzID0gKGVkaXRvciwgaHRtbCkgPT4ge1xuICAgICAgY29uc3QgcGFyc2VyID0gRG9tUGFyc2VyKHsgc2FuaXRpemU6IHNob3VsZFNhbml0aXplWHNzKGVkaXRvcikgfSwgZWRpdG9yLnNjaGVtYSk7XG4gICAgICBwYXJzZXIuYWRkTm9kZUZpbHRlcignbWV0YScsIG5vZGVzID0+IHtcbiAgICAgICAgVG9vbHMuZWFjaChub2Rlcywgbm9kZSA9PiB7XG4gICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGZyYWdtZW50ID0gcGFyc2VyLnBhcnNlKGh0bWwsIHtcbiAgICAgICAgZm9yY2VkX3Jvb3RfYmxvY2s6IGZhbHNlLFxuICAgICAgICBpc1Jvb3RDb250ZW50OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBIdG1sU2VyaWFsaXplcih7IHZhbGlkYXRlOiB0cnVlIH0sIGVkaXRvci5zY2hlbWEpLnNlcmlhbGl6ZShmcmFnbWVudCk7XG4gICAgfTtcbiAgICBjb25zdCBwcm9jZXNzUmVzdWx0ID0gKGNvbnRlbnQsIGNhbmNlbGxlZCkgPT4gKHtcbiAgICAgIGNvbnRlbnQsXG4gICAgICBjYW5jZWxsZWRcbiAgICB9KTtcbiAgICBjb25zdCBwb3N0UHJvY2Vzc0ZpbHRlciA9IChlZGl0b3IsIGh0bWwsIGludGVybmFsKSA9PiB7XG4gICAgICBjb25zdCB0ZW1wQm9keSA9IGVkaXRvci5kb20uY3JlYXRlKCdkaXYnLCB7IHN0eWxlOiAnZGlzcGxheTpub25lJyB9LCBodG1sKTtcbiAgICAgIGNvbnN0IHBvc3RQcm9jZXNzQXJncyA9IGZpcmVQYXN0ZVBvc3RQcm9jZXNzKGVkaXRvciwgdGVtcEJvZHksIGludGVybmFsKTtcbiAgICAgIHJldHVybiBwcm9jZXNzUmVzdWx0KHBvc3RQcm9jZXNzQXJncy5ub2RlLmlubmVySFRNTCwgcG9zdFByb2Nlc3NBcmdzLmlzRGVmYXVsdFByZXZlbnRlZCgpKTtcbiAgICB9O1xuICAgIGNvbnN0IGZpbHRlckNvbnRlbnQgPSAoZWRpdG9yLCBjb250ZW50LCBpbnRlcm5hbCkgPT4ge1xuICAgICAgY29uc3QgcHJlUHJvY2Vzc0FyZ3MgPSBmaXJlUGFzdGVQcmVQcm9jZXNzKGVkaXRvciwgY29udGVudCwgaW50ZXJuYWwpO1xuICAgICAgY29uc3QgZmlsdGVyZWRDb250ZW50ID0gcHJlUHJvY2VzcyhlZGl0b3IsIHByZVByb2Nlc3NBcmdzLmNvbnRlbnQpO1xuICAgICAgaWYgKGVkaXRvci5oYXNFdmVudExpc3RlbmVycygnUGFzdGVQb3N0UHJvY2VzcycpICYmICFwcmVQcm9jZXNzQXJncy5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICByZXR1cm4gcG9zdFByb2Nlc3NGaWx0ZXIoZWRpdG9yLCBmaWx0ZXJlZENvbnRlbnQsIGludGVybmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwcm9jZXNzUmVzdWx0KGZpbHRlcmVkQ29udGVudCwgcHJlUHJvY2Vzc0FyZ3MuaXNEZWZhdWx0UHJldmVudGVkKCkpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcHJvY2VzcyA9IChlZGl0b3IsIGh0bWwsIGludGVybmFsKSA9PiB7XG4gICAgICByZXR1cm4gZmlsdGVyQ29udGVudChlZGl0b3IsIGh0bWwsIGludGVybmFsKTtcbiAgICB9O1xuXG4gICAgY29uc3QgcGFzdGVIdG1sJDEgPSAoZWRpdG9yLCBodG1sKSA9PiB7XG4gICAgICBlZGl0b3IuaW5zZXJ0Q29udGVudChodG1sLCB7XG4gICAgICAgIG1lcmdlOiBzaG91bGRQYXN0ZU1lcmdlRm9ybWF0cyhlZGl0b3IpLFxuICAgICAgICBwYXN0ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIGNvbnN0IGlzQWJzb2x1dGVVcmwgPSB1cmwgPT4gL15odHRwcz86XFwvXFwvW1xcd1xcLVxcLys9LiwhOzomJUBefigpe30/I10rJC9pLnRlc3QodXJsKTtcbiAgICBjb25zdCBpc0ltYWdlVXJsID0gKGVkaXRvciwgdXJsKSA9PiB7XG4gICAgICByZXR1cm4gaXNBYnNvbHV0ZVVybCh1cmwpICYmIGV4aXN0cyhnZXRBbGxvd2VkSW1hZ2VGaWxlVHlwZXMoZWRpdG9yKSwgdHlwZSA9PiBlbmRzV2l0aCh1cmwudG9Mb3dlckNhc2UoKSwgYC4keyB0eXBlLnRvTG93ZXJDYXNlKCkgfWApKTtcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZUltYWdlID0gKGVkaXRvciwgdXJsLCBwYXN0ZUh0bWxGbikgPT4ge1xuICAgICAgZWRpdG9yLnVuZG9NYW5hZ2VyLmV4dHJhKCgpID0+IHtcbiAgICAgICAgcGFzdGVIdG1sRm4oZWRpdG9yLCB1cmwpO1xuICAgICAgfSwgKCkgPT4ge1xuICAgICAgICBlZGl0b3IuaW5zZXJ0Q29udGVudCgnPGltZyBzcmM9XCInICsgdXJsICsgJ1wiPicpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZUxpbmsgPSAoZWRpdG9yLCB1cmwsIHBhc3RlSHRtbEZuKSA9PiB7XG4gICAgICBlZGl0b3IudW5kb01hbmFnZXIuZXh0cmEoKCkgPT4ge1xuICAgICAgICBwYXN0ZUh0bWxGbihlZGl0b3IsIHVybCk7XG4gICAgICB9LCAoKSA9PiB7XG4gICAgICAgIGVkaXRvci5leGVjQ29tbWFuZCgnbWNlSW5zZXJ0TGluaycsIGZhbHNlLCB1cmwpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIGNvbnN0IGxpbmtTZWxlY3Rpb24gPSAoZWRpdG9yLCBodG1sLCBwYXN0ZUh0bWxGbikgPT4gIWVkaXRvci5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSAmJiBpc0Fic29sdXRlVXJsKGh0bWwpID8gY3JlYXRlTGluayhlZGl0b3IsIGh0bWwsIHBhc3RlSHRtbEZuKSA6IGZhbHNlO1xuICAgIGNvbnN0IGluc2VydEltYWdlID0gKGVkaXRvciwgaHRtbCwgcGFzdGVIdG1sRm4pID0+IGlzSW1hZ2VVcmwoZWRpdG9yLCBodG1sKSA/IGNyZWF0ZUltYWdlKGVkaXRvciwgaHRtbCwgcGFzdGVIdG1sRm4pIDogZmFsc2U7XG4gICAgY29uc3Qgc21hcnRJbnNlcnRDb250ZW50ID0gKGVkaXRvciwgaHRtbCkgPT4ge1xuICAgICAgVG9vbHMuZWFjaChbXG4gICAgICAgIGxpbmtTZWxlY3Rpb24sXG4gICAgICAgIGluc2VydEltYWdlLFxuICAgICAgICBwYXN0ZUh0bWwkMVxuICAgICAgXSwgYWN0aW9uID0+IHtcbiAgICAgICAgcmV0dXJuICFhY3Rpb24oZWRpdG9yLCBodG1sLCBwYXN0ZUh0bWwkMSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGluc2VydENvbnRlbnQgPSAoZWRpdG9yLCBodG1sLCBwYXN0ZUFzVGV4dCkgPT4ge1xuICAgICAgaWYgKHBhc3RlQXNUZXh0IHx8ICFpc1NtYXJ0UGFzdGVFbmFibGVkKGVkaXRvcikpIHtcbiAgICAgICAgcGFzdGVIdG1sJDEoZWRpdG9yLCBodG1sKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNtYXJ0SW5zZXJ0Q29udGVudChlZGl0b3IsIGh0bWwpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCB1bmlxdWVJZCA9IGNyZWF0ZUlkR2VuZXJhdG9yKCdtY2VjbGlwJyk7XG4gICAgY29uc3QgZG9QYXN0ZSA9IChlZGl0b3IsIGNvbnRlbnQsIGludGVybmFsLCBwYXN0ZUFzVGV4dCkgPT4ge1xuICAgICAgY29uc3QgYXJncyA9IHByb2Nlc3MoZWRpdG9yLCBjb250ZW50LCBpbnRlcm5hbCk7XG4gICAgICBpZiAoIWFyZ3MuY2FuY2VsbGVkKSB7XG4gICAgICAgIGluc2VydENvbnRlbnQoZWRpdG9yLCBhcmdzLmNvbnRlbnQsIHBhc3RlQXNUZXh0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHBhc3RlSHRtbCA9IChlZGl0b3IsIGh0bWwsIGludGVybmFsRmxhZykgPT4ge1xuICAgICAgY29uc3QgaW50ZXJuYWwgPSBpbnRlcm5hbEZsYWcgPyBpbnRlcm5hbEZsYWcgOiBpc01hcmtlZChodG1sKTtcbiAgICAgIGRvUGFzdGUoZWRpdG9yLCB1bm1hcmsoaHRtbCksIGludGVybmFsLCBmYWxzZSk7XG4gICAgfTtcbiAgICBjb25zdCBwYXN0ZVRleHQgPSAoZWRpdG9yLCB0ZXh0KSA9PiB7XG4gICAgICBjb25zdCBlbmNvZGVkVGV4dCA9IGVkaXRvci5kb20uZW5jb2RlKHRleHQpLnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJyk7XG4gICAgICBjb25zdCBub3JtYWxpemVkVGV4dCA9IG5vcm1hbGl6ZSQ0KGVuY29kZWRUZXh0LCBnZXRQYXN0ZVRhYlNwYWNlcyhlZGl0b3IpKTtcbiAgICAgIGNvbnN0IGh0bWwgPSB0b0Jsb2NrRWxlbWVudHMobm9ybWFsaXplZFRleHQsIGdldEZvcmNlZFJvb3RCbG9jayhlZGl0b3IpLCBnZXRGb3JjZWRSb290QmxvY2tBdHRycyhlZGl0b3IpKTtcbiAgICAgIGRvUGFzdGUoZWRpdG9yLCBodG1sLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfTtcbiAgICBjb25zdCBnZXREYXRhVHJhbnNmZXJJdGVtcyA9IGRhdGFUcmFuc2ZlciA9PiB7XG4gICAgICBjb25zdCBpdGVtcyA9IHt9O1xuICAgICAgaWYgKGRhdGFUcmFuc2ZlciAmJiBkYXRhVHJhbnNmZXIudHlwZXMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhVHJhbnNmZXIudHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IGRhdGFUcmFuc2Zlci50eXBlc1tpXTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaXRlbXNbY29udGVudFR5cGVdID0gZGF0YVRyYW5zZmVyLmdldERhdGEoY29udGVudFR5cGUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICBpdGVtc1tjb250ZW50VHlwZV0gPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVtcztcbiAgICB9O1xuICAgIGNvbnN0IGhhc0NvbnRlbnRUeXBlID0gKGNsaXBib2FyZENvbnRlbnQsIG1pbWVUeXBlKSA9PiBtaW1lVHlwZSBpbiBjbGlwYm9hcmRDb250ZW50ICYmIGNsaXBib2FyZENvbnRlbnRbbWltZVR5cGVdLmxlbmd0aCA+IDA7XG4gICAgY29uc3QgaGFzSHRtbE9yVGV4dCA9IGNvbnRlbnQgPT4gaGFzQ29udGVudFR5cGUoY29udGVudCwgJ3RleHQvaHRtbCcpIHx8IGhhc0NvbnRlbnRUeXBlKGNvbnRlbnQsICd0ZXh0L3BsYWluJyk7XG4gICAgY29uc3QgZXh0cmFjdEZpbGVuYW1lID0gKGVkaXRvciwgc3RyKSA9PiB7XG4gICAgICBjb25zdCBtID0gc3RyLm1hdGNoKC8oW1xcc1xcU10rPykoPzpcXC5bYS16MC05Ll0rKSQvaSk7XG4gICAgICByZXR1cm4gaXNOb25OdWxsYWJsZShtKSA/IGVkaXRvci5kb20uZW5jb2RlKG1bMV0pIDogdW5kZWZpbmVkO1xuICAgIH07XG4gICAgY29uc3QgY3JlYXRlQmxvYkluZm8gPSAoZWRpdG9yLCBibG9iQ2FjaGUsIGZpbGUsIGJhc2U2NCkgPT4ge1xuICAgICAgY29uc3QgaWQgPSB1bmlxdWVJZCgpO1xuICAgICAgY29uc3QgdXNlRmlsZU5hbWUgPSBzaG91bGRSZXVzZUZpbGVOYW1lKGVkaXRvcikgJiYgaXNOb25OdWxsYWJsZShmaWxlLm5hbWUpO1xuICAgICAgY29uc3QgbmFtZSA9IHVzZUZpbGVOYW1lID8gZXh0cmFjdEZpbGVuYW1lKGVkaXRvciwgZmlsZS5uYW1lKSA6IGlkO1xuICAgICAgY29uc3QgZmlsZW5hbWUgPSB1c2VGaWxlTmFtZSA/IGZpbGUubmFtZSA6IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IGJsb2JJbmZvID0gYmxvYkNhY2hlLmNyZWF0ZShpZCwgZmlsZSwgYmFzZTY0LCBuYW1lLCBmaWxlbmFtZSk7XG4gICAgICBibG9iQ2FjaGUuYWRkKGJsb2JJbmZvKTtcbiAgICAgIHJldHVybiBibG9iSW5mbztcbiAgICB9O1xuICAgIGNvbnN0IHBhc3RlSW1hZ2UgPSAoZWRpdG9yLCBpbWFnZUl0ZW0pID0+IHtcbiAgICAgIHBhcnNlRGF0YVVyaShpbWFnZUl0ZW0udXJpKS5lYWNoKCh7ZGF0YSwgdHlwZSwgYmFzZTY0RW5jb2RlZH0pID0+IHtcbiAgICAgICAgY29uc3QgYmFzZTY0ID0gYmFzZTY0RW5jb2RlZCA/IGRhdGEgOiBidG9hKGRhdGEpO1xuICAgICAgICBjb25zdCBmaWxlID0gaW1hZ2VJdGVtLmZpbGU7XG4gICAgICAgIGNvbnN0IGJsb2JDYWNoZSA9IGVkaXRvci5lZGl0b3JVcGxvYWQuYmxvYkNhY2hlO1xuICAgICAgICBjb25zdCBleGlzdGluZ0Jsb2JJbmZvID0gYmxvYkNhY2hlLmdldEJ5RGF0YShiYXNlNjQsIHR5cGUpO1xuICAgICAgICBjb25zdCBibG9iSW5mbyA9IGV4aXN0aW5nQmxvYkluZm8gIT09IG51bGwgJiYgZXhpc3RpbmdCbG9iSW5mbyAhPT0gdm9pZCAwID8gZXhpc3RpbmdCbG9iSW5mbyA6IGNyZWF0ZUJsb2JJbmZvKGVkaXRvciwgYmxvYkNhY2hlLCBmaWxlLCBiYXNlNjQpO1xuICAgICAgICBwYXN0ZUh0bWwoZWRpdG9yLCBgPGltZyBzcmM9XCIkeyBibG9iSW5mby5ibG9iVXJpKCkgfVwiPmAsIGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgaXNDbGlwYm9hcmRFdmVudCA9IGV2ZW50ID0+IGV2ZW50LnR5cGUgPT09ICdwYXN0ZSc7XG4gICAgY29uc3QgcmVhZEZpbGVzQXNEYXRhVXJpcyA9IGl0ZW1zID0+IFByb21pc2UuYWxsKG1hcCQzKGl0ZW1zLCBmaWxlID0+IHtcbiAgICAgIHJldHVybiBibG9iVG9EYXRhVXJpKGZpbGUpLnRoZW4odXJpID0+ICh7XG4gICAgICAgIGZpbGUsXG4gICAgICAgIHVyaVxuICAgICAgfSkpO1xuICAgIH0pKTtcbiAgICBjb25zdCBpc0ltYWdlID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGFsbG93ZWRFeHRlbnNpb25zID0gZ2V0QWxsb3dlZEltYWdlRmlsZVR5cGVzKGVkaXRvcik7XG4gICAgICByZXR1cm4gZmlsZSA9PiBzdGFydHNXaXRoKGZpbGUudHlwZSwgJ2ltYWdlLycpICYmIGV4aXN0cyhhbGxvd2VkRXh0ZW5zaW9ucywgZXh0ZW5zaW9uID0+IHtcbiAgICAgICAgcmV0dXJuIGdldEltYWdlTWltZVR5cGUoZXh0ZW5zaW9uKSA9PT0gZmlsZS50eXBlO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRJbWFnZXNGcm9tRGF0YVRyYW5zZmVyID0gKGVkaXRvciwgZGF0YVRyYW5zZmVyKSA9PiB7XG4gICAgICBjb25zdCBpdGVtcyA9IGRhdGFUcmFuc2Zlci5pdGVtcyA/IGJpbmQkMyhmcm9tKGRhdGFUcmFuc2Zlci5pdGVtcyksIGl0ZW0gPT4ge1xuICAgICAgICByZXR1cm4gaXRlbS5raW5kID09PSAnZmlsZScgPyBbaXRlbS5nZXRBc0ZpbGUoKV0gOiBbXTtcbiAgICAgIH0pIDogW107XG4gICAgICBjb25zdCBmaWxlcyA9IGRhdGFUcmFuc2Zlci5maWxlcyA/IGZyb20oZGF0YVRyYW5zZmVyLmZpbGVzKSA6IFtdO1xuICAgICAgcmV0dXJuIGZpbHRlciQ1KGl0ZW1zLmxlbmd0aCA+IDAgPyBpdGVtcyA6IGZpbGVzLCBpc0ltYWdlKGVkaXRvcikpO1xuICAgIH07XG4gICAgY29uc3QgcGFzdGVJbWFnZURhdGEgPSAoZWRpdG9yLCBlLCBybmcpID0+IHtcbiAgICAgIGNvbnN0IGRhdGFUcmFuc2ZlciA9IGlzQ2xpcGJvYXJkRXZlbnQoZSkgPyBlLmNsaXBib2FyZERhdGEgOiBlLmRhdGFUcmFuc2ZlcjtcbiAgICAgIGlmIChzaG91bGRQYXN0ZURhdGFJbWFnZXMoZWRpdG9yKSAmJiBkYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgY29uc3QgaW1hZ2VzID0gZ2V0SW1hZ2VzRnJvbURhdGFUcmFuc2ZlcihlZGl0b3IsIGRhdGFUcmFuc2Zlcik7XG4gICAgICAgIGlmIChpbWFnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICByZWFkRmlsZXNBc0RhdGFVcmlzKGltYWdlcykudGhlbihmaWxlUmVzdWx0cyA9PiB7XG4gICAgICAgICAgICBpZiAocm5nKSB7XG4gICAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Um5nKHJuZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlYWNoJGUoZmlsZVJlc3VsdHMsIHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgIHBhc3RlSW1hZ2UoZWRpdG9yLCByZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGNvbnN0IGlzQnJva2VuQW5kcm9pZENsaXBib2FyZEV2ZW50ID0gZSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgcmV0dXJuIEVudi5vcy5pc0FuZHJvaWQoKSAmJiAoKF9iID0gKF9hID0gZS5jbGlwYm9hcmREYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXRlbXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5sZW5ndGgpID09PSAwO1xuICAgIH07XG4gICAgY29uc3QgaXNLZXlib2FyZFBhc3RlRXZlbnQgPSBlID0+IFZLLm1ldGFLZXlQcmVzc2VkKGUpICYmIGUua2V5Q29kZSA9PT0gODYgfHwgZS5zaGlmdEtleSAmJiBlLmtleUNvZGUgPT09IDQ1O1xuICAgIGNvbnN0IGluc2VydENsaXBib2FyZENvbnRlbnQgPSAoZWRpdG9yLCBjbGlwYm9hcmRDb250ZW50LCBodG1sLCBwbGFpblRleHRNb2RlKSA9PiB7XG4gICAgICBsZXQgY29udGVudCA9IHRyaW1IdG1sKGh0bWwpO1xuICAgICAgY29uc3QgaXNJbnRlcm5hbCA9IGhhc0NvbnRlbnRUeXBlKGNsaXBib2FyZENvbnRlbnQsIGludGVybmFsSHRtbE1pbWUoKSkgfHwgaXNNYXJrZWQoaHRtbCk7XG4gICAgICBjb25zdCBpc1BsYWluVGV4dEh0bWwgPSAhaXNJbnRlcm5hbCAmJiBpc1BsYWluVGV4dChjb250ZW50KTtcbiAgICAgIGNvbnN0IGlzQWJzb2x1dGVVcmwkMSA9IGlzQWJzb2x1dGVVcmwoY29udGVudCk7XG4gICAgICBpZiAoaXNEZWZhdWx0UGFzdGVCaW5Db250ZW50KGNvbnRlbnQpIHx8ICFjb250ZW50Lmxlbmd0aCB8fCBpc1BsYWluVGV4dEh0bWwgJiYgIWlzQWJzb2x1dGVVcmwkMSkge1xuICAgICAgICBwbGFpblRleHRNb2RlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwbGFpblRleHRNb2RlIHx8IGlzQWJzb2x1dGVVcmwkMSkge1xuICAgICAgICBpZiAoaGFzQ29udGVudFR5cGUoY2xpcGJvYXJkQ29udGVudCwgJ3RleHQvcGxhaW4nKSAmJiBpc1BsYWluVGV4dEh0bWwpIHtcbiAgICAgICAgICBjb250ZW50ID0gY2xpcGJvYXJkQ29udGVudFsndGV4dC9wbGFpbiddO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRlbnQgPSBpbm5lclRleHQoY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZmF1bHRQYXN0ZUJpbkNvbnRlbnQoY29udGVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHBsYWluVGV4dE1vZGUpIHtcbiAgICAgICAgcGFzdGVUZXh0KGVkaXRvciwgY29udGVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXN0ZUh0bWwoZWRpdG9yLCBjb250ZW50LCBpc0ludGVybmFsKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlZ2lzdGVyRXZlbnRIYW5kbGVycyA9IChlZGl0b3IsIHBhc3RlQmluLCBwYXN0ZUZvcm1hdCkgPT4ge1xuICAgICAgbGV0IGtleWJvYXJkUGFzdGVQbGFpblRleHRTdGF0ZTtcbiAgICAgIGNvbnN0IGdldExhc3RSbmcgPSAoKSA9PiBwYXN0ZUJpbi5nZXRMYXN0Um5nKCkgfHwgZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgIGVkaXRvci5vbigna2V5ZG93bicsIGUgPT4ge1xuICAgICAgICBpZiAoaXNLZXlib2FyZFBhc3RlRXZlbnQoZSkgJiYgIWUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICBrZXlib2FyZFBhc3RlUGxhaW5UZXh0U3RhdGUgPSBlLnNoaWZ0S2V5ICYmIGUua2V5Q29kZSA9PT0gODY7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm9uKCdwYXN0ZScsIGUgPT4ge1xuICAgICAgICBpZiAoZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCBpc0Jyb2tlbkFuZHJvaWRDbGlwYm9hcmRFdmVudChlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwbGFpblRleHRNb2RlID0gcGFzdGVGb3JtYXQuZ2V0KCkgPT09ICd0ZXh0JyB8fCBrZXlib2FyZFBhc3RlUGxhaW5UZXh0U3RhdGU7XG4gICAgICAgIGtleWJvYXJkUGFzdGVQbGFpblRleHRTdGF0ZSA9IGZhbHNlO1xuICAgICAgICBjb25zdCBjbGlwYm9hcmRDb250ZW50ID0gZ2V0RGF0YVRyYW5zZmVySXRlbXMoZS5jbGlwYm9hcmREYXRhKTtcbiAgICAgICAgaWYgKCFoYXNIdG1sT3JUZXh0KGNsaXBib2FyZENvbnRlbnQpICYmIHBhc3RlSW1hZ2VEYXRhKGVkaXRvciwgZSwgZ2V0TGFzdFJuZygpKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzQ29udGVudFR5cGUoY2xpcGJvYXJkQ29udGVudCwgJ3RleHQvaHRtbCcpKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGluc2VydENsaXBib2FyZENvbnRlbnQoZWRpdG9yLCBjbGlwYm9hcmRDb250ZW50LCBjbGlwYm9hcmRDb250ZW50Wyd0ZXh0L2h0bWwnXSwgcGxhaW5UZXh0TW9kZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaGFzQ29udGVudFR5cGUoY2xpcGJvYXJkQ29udGVudCwgJ3RleHQvcGxhaW4nKSAmJiBoYXNDb250ZW50VHlwZShjbGlwYm9hcmRDb250ZW50LCAndGV4dC91cmktbGlzdCcpKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGluc2VydENsaXBib2FyZENvbnRlbnQoZWRpdG9yLCBjbGlwYm9hcmRDb250ZW50LCBjbGlwYm9hcmRDb250ZW50Wyd0ZXh0L3BsYWluJ10sIHBsYWluVGV4dE1vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhc3RlQmluLmNyZWF0ZSgpO1xuICAgICAgICAgIERlbGF5LnNldEVkaXRvclRpbWVvdXQoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBodG1sID0gcGFzdGVCaW4uZ2V0SHRtbCgpO1xuICAgICAgICAgICAgcGFzdGVCaW4ucmVtb3ZlKCk7XG4gICAgICAgICAgICBpbnNlcnRDbGlwYm9hcmRDb250ZW50KGVkaXRvciwgY2xpcGJvYXJkQ29udGVudCwgaHRtbCwgcGxhaW5UZXh0TW9kZSk7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgcmVnaXN0ZXJEYXRhSW1hZ2VGaWx0ZXIgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgaXNXZWJLaXRGYWtlVXJsID0gc3JjID0+IHN0YXJ0c1dpdGgoc3JjLCAnd2Via2l0LWZha2UtdXJsJyk7XG4gICAgICBjb25zdCBpc0RhdGFVcmkgPSBzcmMgPT4gc3RhcnRzV2l0aChzcmMsICdkYXRhOicpO1xuICAgICAgY29uc3QgaXNQYXN0ZUluc2VydCA9IGFyZ3MgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gYXJncy5kYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGFzdGUpID09PSB0cnVlO1xuICAgICAgfTtcbiAgICAgIGVkaXRvci5wYXJzZXIuYWRkTm9kZUZpbHRlcignaW1nJywgKG5vZGVzLCBuYW1lLCBhcmdzKSA9PiB7XG4gICAgICAgIGlmICghc2hvdWxkUGFzdGVEYXRhSW1hZ2VzKGVkaXRvcikgJiYgaXNQYXN0ZUluc2VydChhcmdzKSkge1xuICAgICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgICAgICAgICAgY29uc3Qgc3JjID0gbm9kZS5hdHRyKCdzcmMnKTtcbiAgICAgICAgICAgIGlmIChpc1N0cmluZyhzcmMpICYmICFub2RlLmF0dHIoJ2RhdGEtbWNlLW9iamVjdCcpICYmIHNyYyAhPT0gRW52LnRyYW5zcGFyZW50U3JjKSB7XG4gICAgICAgICAgICAgIGlmIChpc1dlYktpdEZha2VVcmwoc3JjKSkge1xuICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXNob3VsZEFsbG93SHRtbERhdGFVcmxzKGVkaXRvcikgJiYgaXNEYXRhVXJpKHNyYykpIHtcbiAgICAgICAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHJlZ2lzdGVyRXZlbnRzQW5kRmlsdGVycyA9IChlZGl0b3IsIHBhc3RlQmluLCBwYXN0ZUZvcm1hdCkgPT4ge1xuICAgICAgcmVnaXN0ZXJFdmVudEhhbmRsZXJzKGVkaXRvciwgcGFzdGVCaW4sIHBhc3RlRm9ybWF0KTtcbiAgICAgIHJlZ2lzdGVyRGF0YUltYWdlRmlsdGVyKGVkaXRvcik7XG4gICAgfTtcblxuICAgIGNvbnN0IHRvZ2dsZVBsYWluVGV4dFBhc3RlID0gKGVkaXRvciwgcGFzdGVGb3JtYXQpID0+IHtcbiAgICAgIGlmIChwYXN0ZUZvcm1hdC5nZXQoKSA9PT0gJ3RleHQnKSB7XG4gICAgICAgIHBhc3RlRm9ybWF0LnNldCgnaHRtbCcpO1xuICAgICAgICBmaXJlUGFzdGVQbGFpblRleHRUb2dnbGUoZWRpdG9yLCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXN0ZUZvcm1hdC5zZXQoJ3RleHQnKTtcbiAgICAgICAgZmlyZVBhc3RlUGxhaW5UZXh0VG9nZ2xlKGVkaXRvciwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBlZGl0b3IuZm9jdXMoKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlZ2lzdGVyJDEgPSAoZWRpdG9yLCBwYXN0ZUZvcm1hdCkgPT4ge1xuICAgICAgZWRpdG9yLmFkZENvbW1hbmQoJ21jZVRvZ2dsZVBsYWluVGV4dFBhc3RlJywgKCkgPT4ge1xuICAgICAgICB0b2dnbGVQbGFpblRleHRQYXN0ZShlZGl0b3IsIHBhc3RlRm9ybWF0KTtcbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLmFkZENvbW1hbmQoJ21jZUluc2VydENsaXBib2FyZENvbnRlbnQnLCAodWksIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZS5odG1sKSB7XG4gICAgICAgICAgcGFzdGVIdG1sKGVkaXRvciwgdmFsdWUuaHRtbCwgdmFsdWUuaW50ZXJuYWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS50ZXh0KSB7XG4gICAgICAgICAgcGFzdGVUZXh0KGVkaXRvciwgdmFsdWUudGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBzZXRIdG1sNUNsaXBib2FyZCA9IChjbGlwYm9hcmREYXRhLCBodG1sLCB0ZXh0KSA9PiB7XG4gICAgICBpZiAoY2xpcGJvYXJkRGF0YSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNsaXBib2FyZERhdGEuY2xlYXJEYXRhKCk7XG4gICAgICAgICAgY2xpcGJvYXJkRGF0YS5zZXREYXRhKCd0ZXh0L2h0bWwnLCBodG1sKTtcbiAgICAgICAgICBjbGlwYm9hcmREYXRhLnNldERhdGEoJ3RleHQvcGxhaW4nLCB0ZXh0KTtcbiAgICAgICAgICBjbGlwYm9hcmREYXRhLnNldERhdGEoaW50ZXJuYWxIdG1sTWltZSgpLCBodG1sKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc2V0Q2xpcGJvYXJkRGF0YSA9IChldnQsIGRhdGEsIGZhbGxiYWNrLCBkb25lKSA9PiB7XG4gICAgICBpZiAoc2V0SHRtbDVDbGlwYm9hcmQoZXZ0LmNsaXBib2FyZERhdGEsIGRhdGEuaHRtbCwgZGF0YS50ZXh0KSkge1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmFsbGJhY2soZGF0YS5odG1sLCBkb25lKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGZhbGxiYWNrJDEgPSBlZGl0b3IgPT4gKGh0bWwsIGRvbmUpID0+IHtcbiAgICAgIGNvbnN0IHtkb20sIHNlbGVjdGlvbn0gPSBlZGl0b3I7XG4gICAgICBjb25zdCBvdXRlciA9IGRvbS5jcmVhdGUoJ2RpdicsIHtcbiAgICAgICAgJ2NvbnRlbnRlZGl0YWJsZSc6ICdmYWxzZScsXG4gICAgICAgICdkYXRhLW1jZS1ib2d1cyc6ICdhbGwnXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGlubmVyID0gZG9tLmNyZWF0ZSgnZGl2JywgeyBjb250ZW50ZWRpdGFibGU6ICd0cnVlJyB9LCBodG1sKTtcbiAgICAgIGRvbS5zZXRTdHlsZXMob3V0ZXIsIHtcbiAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICAgIHRvcDogJzAnLFxuICAgICAgICBsZWZ0OiAnLTMwMDBweCcsXG4gICAgICAgIHdpZHRoOiAnMTAwMHB4JyxcbiAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nXG4gICAgICB9KTtcbiAgICAgIG91dGVyLmFwcGVuZENoaWxkKGlubmVyKTtcbiAgICAgIGRvbS5hZGQoZWRpdG9yLmdldEJvZHkoKSwgb3V0ZXIpO1xuICAgICAgY29uc3QgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICBpbm5lci5mb2N1cygpO1xuICAgICAgY29uc3Qgb2Zmc2NyZWVuUmFuZ2UgPSBkb20uY3JlYXRlUm5nKCk7XG4gICAgICBvZmZzY3JlZW5SYW5nZS5zZWxlY3ROb2RlQ29udGVudHMoaW5uZXIpO1xuICAgICAgc2VsZWN0aW9uLnNldFJuZyhvZmZzY3JlZW5SYW5nZSk7XG4gICAgICBEZWxheS5zZXRFZGl0b3JUaW1lb3V0KGVkaXRvciwgKCkgPT4ge1xuICAgICAgICBzZWxlY3Rpb24uc2V0Um5nKHJhbmdlKTtcbiAgICAgICAgZG9tLnJlbW92ZShvdXRlcik7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0sIDApO1xuICAgIH07XG4gICAgY29uc3QgZ2V0RGF0YSA9IGVkaXRvciA9PiAoe1xuICAgICAgaHRtbDogbWFyayhlZGl0b3Iuc2VsZWN0aW9uLmdldENvbnRlbnQoeyBjb250ZXh0dWFsOiB0cnVlIH0pKSxcbiAgICAgIHRleHQ6IGVkaXRvci5zZWxlY3Rpb24uZ2V0Q29udGVudCh7IGZvcm1hdDogJ3RleHQnIH0pXG4gICAgfSk7XG4gICAgY29uc3QgaXNUYWJsZVNlbGVjdGlvbiA9IGVkaXRvciA9PiAhIWVkaXRvci5kb20uZ2V0UGFyZW50KGVkaXRvci5zZWxlY3Rpb24uZ2V0U3RhcnQoKSwgJ3RkW2RhdGEtbWNlLXNlbGVjdGVkXSx0aFtkYXRhLW1jZS1zZWxlY3RlZF0nLCBlZGl0b3IuZ2V0Qm9keSgpKTtcbiAgICBjb25zdCBoYXNTZWxlY3RlZENvbnRlbnQgPSBlZGl0b3IgPT4gIWVkaXRvci5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSB8fCBpc1RhYmxlU2VsZWN0aW9uKGVkaXRvcik7XG4gICAgY29uc3QgY3V0ID0gZWRpdG9yID0+IGV2dCA9PiB7XG4gICAgICBpZiAoIWV2dC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSAmJiBoYXNTZWxlY3RlZENvbnRlbnQoZWRpdG9yKSkge1xuICAgICAgICBzZXRDbGlwYm9hcmREYXRhKGV2dCwgZ2V0RGF0YShlZGl0b3IpLCBmYWxsYmFjayQxKGVkaXRvciksICgpID0+IHtcbiAgICAgICAgICBpZiAoRW52LmJyb3dzZXIuaXNDaHJvbWl1bSgpIHx8IEVudi5icm93c2VyLmlzRmlyZWZveCgpKSB7XG4gICAgICAgICAgICBjb25zdCBybmcgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgICAgICAgRGVsYXkuc2V0RWRpdG9yVGltZW91dChlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRSbmcocm5nKTtcbiAgICAgICAgICAgICAgZWRpdG9yLmV4ZWNDb21tYW5kKCdEZWxldGUnKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlZGl0b3IuZXhlY0NvbW1hbmQoJ0RlbGV0ZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBjb3B5ID0gZWRpdG9yID0+IGV2dCA9PiB7XG4gICAgICBpZiAoIWV2dC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSAmJiBoYXNTZWxlY3RlZENvbnRlbnQoZWRpdG9yKSkge1xuICAgICAgICBzZXRDbGlwYm9hcmREYXRhKGV2dCwgZ2V0RGF0YShlZGl0b3IpLCBmYWxsYmFjayQxKGVkaXRvciksIG5vb3ApO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmVnaXN0ZXIgPSBlZGl0b3IgPT4ge1xuICAgICAgZWRpdG9yLm9uKCdjdXQnLCBjdXQoZWRpdG9yKSk7XG4gICAgICBlZGl0b3Iub24oJ2NvcHknLCBjb3B5KGVkaXRvcikpO1xuICAgIH07XG5cbiAgICBjb25zdCBnZXRDYXJldFJhbmdlRnJvbUV2ZW50ID0gKGVkaXRvciwgZSkgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIHJldHVybiBSYW5nZVV0aWxzLmdldENhcmV0UmFuZ2VGcm9tUG9pbnQoKF9hID0gZS5jbGllbnRYKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwLCAoX2IgPSBlLmNsaWVudFkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDAsIGVkaXRvci5nZXREb2MoKSk7XG4gICAgfTtcbiAgICBjb25zdCBpc1BsYWluVGV4dEZpbGVVcmwgPSBjb250ZW50ID0+IHtcbiAgICAgIGNvbnN0IHBsYWluVGV4dENvbnRlbnQgPSBjb250ZW50Wyd0ZXh0L3BsYWluJ107XG4gICAgICByZXR1cm4gcGxhaW5UZXh0Q29udGVudCA/IHBsYWluVGV4dENvbnRlbnQuaW5kZXhPZignZmlsZTovLycpID09PSAwIDogZmFsc2U7XG4gICAgfTtcbiAgICBjb25zdCBzZXRGb2N1c2VkUmFuZ2UgPSAoZWRpdG9yLCBybmcpID0+IHtcbiAgICAgIGVkaXRvci5mb2N1cygpO1xuICAgICAgaWYgKHJuZykge1xuICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFJuZyhybmcpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaGFzSW1hZ2UgPSBkYXRhVHJhbnNmZXIgPT4gZXhpc3RzKGRhdGFUcmFuc2Zlci5maWxlcywgZmlsZSA9PiAvXmltYWdlXFwvLy50ZXN0KGZpbGUudHlwZSkpO1xuICAgIGNvbnN0IGlzVHJhbnNwYXJlbnRCbG9ja0Ryb3AgPSAoZG9tLCBzY2hlbWEsIHRhcmdldCwgZHJvcENvbnRlbnQpID0+IHtcbiAgICAgIGNvbnN0IHBhcmVudFRyYW5zcGFyZW50ID0gZG9tLmdldFBhcmVudCh0YXJnZXQsIG5vZGUgPT4gaXNUcmFuc3BhcmVudEJsb2NrKHNjaGVtYSwgbm9kZSkpO1xuICAgICAgaWYgKHBhcmVudFRyYW5zcGFyZW50ICYmIGhhcyQyKGRyb3BDb250ZW50LCAndGV4dC9odG1sJykpIHtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKGRyb3BDb250ZW50Wyd0ZXh0L2h0bWwnXSwgJ3RleHQvaHRtbCcpLmJvZHk7XG4gICAgICAgIHJldHVybiAhaXNOdWxsKGZyYWdtZW50LnF1ZXJ5U2VsZWN0b3IocGFyZW50VHJhbnNwYXJlbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc2V0dXAkYSA9IChlZGl0b3IsIGRyYWdnaW5nSW50ZXJuYWxseVN0YXRlKSA9PiB7XG4gICAgICBpZiAoc2hvdWxkUGFzdGVCbG9ja0Ryb3AoZWRpdG9yKSkge1xuICAgICAgICBlZGl0b3Iub24oJ2RyYWdlbmQgZHJhZ292ZXIgZHJhZ2dlc3R1cmUgZHJhZ2Ryb3AgZHJvcCBkcmFnJywgZSA9PiB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCFzaG91bGRQYXN0ZURhdGFJbWFnZXMoZWRpdG9yKSkge1xuICAgICAgICBlZGl0b3Iub24oJ2Ryb3AnLCBlID0+IHtcbiAgICAgICAgICBjb25zdCBkYXRhVHJhbnNmZXIgPSBlLmRhdGFUcmFuc2ZlcjtcbiAgICAgICAgICBpZiAoZGF0YVRyYW5zZmVyICYmIGhhc0ltYWdlKGRhdGFUcmFuc2ZlcikpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZWRpdG9yLm9uKCdkcm9wJywgZSA9PiB7XG4gICAgICAgIGlmIChlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJuZyA9IGdldENhcmV0UmFuZ2VGcm9tRXZlbnQoZWRpdG9yLCBlKTtcbiAgICAgICAgaWYgKGlzTnVsbGFibGUocm5nKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkcm9wQ29udGVudCA9IGdldERhdGFUcmFuc2Zlckl0ZW1zKGUuZGF0YVRyYW5zZmVyKTtcbiAgICAgICAgY29uc3QgaW50ZXJuYWwgPSBoYXNDb250ZW50VHlwZShkcm9wQ29udGVudCwgaW50ZXJuYWxIdG1sTWltZSgpKTtcbiAgICAgICAgaWYgKCghaGFzSHRtbE9yVGV4dChkcm9wQ29udGVudCkgfHwgaXNQbGFpblRleHRGaWxlVXJsKGRyb3BDb250ZW50KSkgJiYgcGFzdGVJbWFnZURhdGEoZWRpdG9yLCBlLCBybmcpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGludGVybmFsQ29udGVudCA9IGRyb3BDb250ZW50W2ludGVybmFsSHRtbE1pbWUoKV07XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBpbnRlcm5hbENvbnRlbnQgfHwgZHJvcENvbnRlbnRbJ3RleHQvaHRtbCddIHx8IGRyb3BDb250ZW50Wyd0ZXh0L3BsYWluJ107XG4gICAgICAgIGNvbnN0IHRyYW5zcGFyZW50RWxlbWVudERyb3AgPSBpc1RyYW5zcGFyZW50QmxvY2tEcm9wKGVkaXRvci5kb20sIGVkaXRvci5zY2hlbWEsIHJuZy5zdGFydENvbnRhaW5lciwgZHJvcENvbnRlbnQpO1xuICAgICAgICBpZiAoZHJhZ2dpbmdJbnRlcm5hbGx5U3RhdGUuZ2V0KCkgJiYgIXRyYW5zcGFyZW50RWxlbWVudERyb3ApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgRGVsYXkuc2V0RWRpdG9yVGltZW91dChlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgIGVkaXRvci51bmRvTWFuYWdlci50cmFuc2FjdCgoKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChpbnRlcm5hbENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBlZGl0b3IuZXhlY0NvbW1hbmQoJ0RlbGV0ZScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNldEZvY3VzZWRSYW5nZShlZGl0b3IsIHJuZyk7XG4gICAgICAgICAgICAgIGNvbnN0IHRyaW1tZWRDb250ZW50ID0gdHJpbUh0bWwoY29udGVudCk7XG4gICAgICAgICAgICAgIGlmIChkcm9wQ29udGVudFsndGV4dC9odG1sJ10pIHtcbiAgICAgICAgICAgICAgICBwYXN0ZUh0bWwoZWRpdG9yLCB0cmltbWVkQ29udGVudCwgaW50ZXJuYWwpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhc3RlVGV4dChlZGl0b3IsIHRyaW1tZWRDb250ZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm9uKCdkcmFnc3RhcnQnLCBfZSA9PiB7XG4gICAgICAgIGRyYWdnaW5nSW50ZXJuYWxseVN0YXRlLnNldCh0cnVlKTtcbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm9uKCdkcmFnb3ZlciBkcmFnZW5kJywgZSA9PiB7XG4gICAgICAgIGlmIChzaG91bGRQYXN0ZURhdGFJbWFnZXMoZWRpdG9yKSAmJiAhZHJhZ2dpbmdJbnRlcm5hbGx5U3RhdGUuZ2V0KCkpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgc2V0Rm9jdXNlZFJhbmdlKGVkaXRvciwgZ2V0Q2FyZXRSYW5nZUZyb21FdmVudChlZGl0b3IsIGUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZS50eXBlID09PSAnZHJhZ2VuZCcpIHtcbiAgICAgICAgICBkcmFnZ2luZ0ludGVybmFsbHlTdGF0ZS5zZXQoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3Qgc2V0dXAkOSA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBwcm9jZXNzRXZlbnQgPSBmID0+IGUgPT4ge1xuICAgICAgICBmKGVkaXRvciwgZSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgcHJlUHJvY2VzcyA9IGdldFBhc3RlUHJlUHJvY2VzcyhlZGl0b3IpO1xuICAgICAgaWYgKGlzRnVuY3Rpb24ocHJlUHJvY2VzcykpIHtcbiAgICAgICAgZWRpdG9yLm9uKCdQYXN0ZVByZVByb2Nlc3MnLCBwcm9jZXNzRXZlbnQocHJlUHJvY2VzcykpO1xuICAgICAgfVxuICAgICAgY29uc3QgcG9zdFByb2Nlc3MgPSBnZXRQYXN0ZVBvc3RQcm9jZXNzKGVkaXRvcik7XG4gICAgICBpZiAoaXNGdW5jdGlvbihwb3N0UHJvY2VzcykpIHtcbiAgICAgICAgZWRpdG9yLm9uKCdQYXN0ZVBvc3RQcm9jZXNzJywgcHJvY2Vzc0V2ZW50KHBvc3RQcm9jZXNzKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGFkZFByZVByb2Nlc3NGaWx0ZXIgPSAoZWRpdG9yLCBmaWx0ZXJGdW5jKSA9PiB7XG4gICAgICBlZGl0b3Iub24oJ1Bhc3RlUHJlUHJvY2VzcycsIGUgPT4ge1xuICAgICAgICBlLmNvbnRlbnQgPSBmaWx0ZXJGdW5jKGVkaXRvciwgZS5jb250ZW50LCBlLmludGVybmFsKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgcmdiUmVnRXhwID0gL3JnYlxccypcXChcXHMqKFswLTldKylcXHMqLFxccyooWzAtOV0rKVxccyosXFxzKihbMC05XSspXFxzKlxcKS9naTtcbiAgICBjb25zdCByZ2JUb0hleCA9IHZhbHVlID0+IFRvb2xzLnRyaW0odmFsdWUpLnJlcGxhY2UocmdiUmVnRXhwLCByZ2JhVG9IZXhTdHJpbmcpLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgcmVtb3ZlV2ViS2l0U3R5bGVzID0gKGVkaXRvciwgY29udGVudCwgaW50ZXJuYWwpID0+IHtcbiAgICAgIGNvbnN0IHdlYktpdFN0eWxlc09wdGlvbiA9IGdldFBhc3RlV2Via2l0U3R5bGVzKGVkaXRvcik7XG4gICAgICBpZiAoaW50ZXJuYWwgfHwgd2ViS2l0U3R5bGVzT3B0aW9uID09PSAnYWxsJyB8fCAhc2hvdWxkUGFzdGVSZW1vdmVXZWJLaXRTdHlsZXMoZWRpdG9yKSkge1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdlYktpdFN0eWxlcyA9IHdlYktpdFN0eWxlc09wdGlvbiA/IHdlYktpdFN0eWxlc09wdGlvbi5zcGxpdCgvWywgXS8pIDogW107XG4gICAgICBpZiAod2ViS2l0U3R5bGVzICYmIHdlYktpdFN0eWxlc09wdGlvbiAhPT0gJ25vbmUnKSB7XG4gICAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb20sIG5vZGUgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldE5vZGUoKTtcbiAgICAgICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgvKDxbXj5dKykgc3R5bGU9XCIoW15cIl0qKVwiKFtePl0qPikvZ2ksIChhbGwsIGJlZm9yZSwgdmFsdWUsIGFmdGVyKSA9PiB7XG4gICAgICAgICAgY29uc3QgaW5wdXRTdHlsZXMgPSBkb20ucGFyc2VTdHlsZShkb20uZGVjb2RlKHZhbHVlKSk7XG4gICAgICAgICAgY29uc3Qgb3V0cHV0U3R5bGVzID0ge307XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3ZWJLaXRTdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0VmFsdWUgPSBpbnB1dFN0eWxlc1t3ZWJLaXRTdHlsZXNbaV1dO1xuICAgICAgICAgICAgbGV0IGNvbXBhcmVJbnB1dCA9IGlucHV0VmFsdWU7XG4gICAgICAgICAgICBsZXQgY3VycmVudFZhbHVlID0gZG9tLmdldFN0eWxlKG5vZGUsIHdlYktpdFN0eWxlc1tpXSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoL2NvbG9yLy50ZXN0KHdlYktpdFN0eWxlc1tpXSkpIHtcbiAgICAgICAgICAgICAgY29tcGFyZUlucHV0ID0gcmdiVG9IZXgoY29tcGFyZUlucHV0KTtcbiAgICAgICAgICAgICAgY3VycmVudFZhbHVlID0gcmdiVG9IZXgoY3VycmVudFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgIT09IGNvbXBhcmVJbnB1dCkge1xuICAgICAgICAgICAgICBvdXRwdXRTdHlsZXNbd2ViS2l0U3R5bGVzW2ldXSA9IGlucHV0VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG91dHB1dFN0eWxlID0gZG9tLnNlcmlhbGl6ZVN0eWxlKG91dHB1dFN0eWxlcywgJ3NwYW4nKTtcbiAgICAgICAgICBpZiAob3V0cHV0U3R5bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBiZWZvcmUgKyAnIHN0eWxlPVwiJyArIG91dHB1dFN0eWxlICsgJ1wiJyArIGFmdGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYmVmb3JlICsgYWZ0ZXI7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgvKDxbXj5dKykgc3R5bGU9XCIoW15cIl0qKVwiKFtePl0qPikvZ2ksICckMSQzJyk7XG4gICAgICB9XG4gICAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC8oPFtePl0rKSBkYXRhLW1jZS1zdHlsZT1cIihbXlwiXSspXCIoW14+XSo+KS9naSwgKGFsbCwgYmVmb3JlLCB2YWx1ZSwgYWZ0ZXIpID0+IHtcbiAgICAgICAgcmV0dXJuIGJlZm9yZSArICcgc3R5bGU9XCInICsgdmFsdWUgKyAnXCInICsgYWZ0ZXI7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH07XG4gICAgY29uc3Qgc2V0dXAkOCA9IGVkaXRvciA9PiB7XG4gICAgICBpZiAoRW52LmJyb3dzZXIuaXNDaHJvbWl1bSgpIHx8IEVudi5icm93c2VyLmlzU2FmYXJpKCkpIHtcbiAgICAgICAgYWRkUHJlUHJvY2Vzc0ZpbHRlcihlZGl0b3IsIHJlbW92ZVdlYktpdFN0eWxlcyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHNldHVwJDcgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgZHJhZ2dpbmdJbnRlcm5hbGx5U3RhdGUgPSBDZWxsKGZhbHNlKTtcbiAgICAgIGNvbnN0IHBhc3RlRm9ybWF0ID0gQ2VsbChpc1Bhc3RlQXNUZXh0RW5hYmxlZChlZGl0b3IpID8gJ3RleHQnIDogJ2h0bWwnKTtcbiAgICAgIGNvbnN0IHBhc3RlQmluID0gUGFzdGVCaW4oZWRpdG9yKTtcbiAgICAgIHNldHVwJDgoZWRpdG9yKTtcbiAgICAgIHJlZ2lzdGVyJDEoZWRpdG9yLCBwYXN0ZUZvcm1hdCk7XG4gICAgICBzZXR1cCQ5KGVkaXRvcik7XG4gICAgICBlZGl0b3Iub24oJ1ByZUluaXQnLCAoKSA9PiB7XG4gICAgICAgIHJlZ2lzdGVyKGVkaXRvcik7XG4gICAgICAgIHNldHVwJGEoZWRpdG9yLCBkcmFnZ2luZ0ludGVybmFsbHlTdGF0ZSk7XG4gICAgICAgIHJlZ2lzdGVyRXZlbnRzQW5kRmlsdGVycyhlZGl0b3IsIHBhc3RlQmluLCBwYXN0ZUZvcm1hdCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgcHJldmVudFN1bW1hcnlUb2dnbGUgPSBlZGl0b3IgPT4ge1xuICAgICAgZWRpdG9yLm9uKCdjbGljaycsIGUgPT4ge1xuICAgICAgICBpZiAoZWRpdG9yLmRvbS5nZXRQYXJlbnQoZS50YXJnZXQsICdkZXRhaWxzJykpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgZmlsdGVyRGV0YWlscyA9IGVkaXRvciA9PiB7XG4gICAgICBlZGl0b3IucGFyc2VyLmFkZE5vZGVGaWx0ZXIoJ2RldGFpbHMnLCBlbG1zID0+IHtcbiAgICAgICAgZWFjaCRlKGVsbXMsIGRldGFpbHMgPT4ge1xuICAgICAgICAgIGRldGFpbHMuYXR0cignZGF0YS1tY2Utb3BlbicsIGRldGFpbHMuYXR0cignb3BlbicpKTtcbiAgICAgICAgICBkZXRhaWxzLmF0dHIoJ29wZW4nLCAnb3BlbicpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLnNlcmlhbGl6ZXIuYWRkTm9kZUZpbHRlcignZGV0YWlscycsIGVsbXMgPT4ge1xuICAgICAgICBlYWNoJGUoZWxtcywgZGV0YWlscyA9PiB7XG4gICAgICAgICAgY29uc3Qgb3BlbiA9IGRldGFpbHMuYXR0cignZGF0YS1tY2Utb3BlbicpO1xuICAgICAgICAgIGRldGFpbHMuYXR0cignb3BlbicsIGlzU3RyaW5nKG9wZW4pID8gb3BlbiA6IG51bGwpO1xuICAgICAgICAgIGRldGFpbHMuYXR0cignZGF0YS1tY2Utb3BlbicsIG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3Qgc2V0dXAkNiA9IGVkaXRvciA9PiB7XG4gICAgICBwcmV2ZW50U3VtbWFyeVRvZ2dsZShlZGl0b3IpO1xuICAgICAgZmlsdGVyRGV0YWlscyhlZGl0b3IpO1xuICAgIH07XG5cbiAgICBjb25zdCBpc0JyID0gaXNCciQ2O1xuICAgIGNvbnN0IGlzVGV4dCA9IGlzVGV4dCRhO1xuICAgIGNvbnN0IGlzQ29udGVudEVkaXRhYmxlRmFsc2UkMiA9IGVsbSA9PiBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJGIoZWxtLmRvbSk7XG4gICAgY29uc3QgaXNDb250ZW50RWRpdGFibGVUcnVlID0gZWxtID0+IGlzQ29udGVudEVkaXRhYmxlVHJ1ZSQzKGVsbS5kb20pO1xuICAgIGNvbnN0IGlzUm9vdCA9IHJvb3ROb2RlID0+IGVsbSA9PiBlcShTdWdhckVsZW1lbnQuZnJvbURvbShyb290Tm9kZSksIGVsbSk7XG4gICAgY29uc3QgZ2V0Q2xvc2VzdFNjb3BlID0gKG5vZGUsIHJvb3ROb2RlKSA9PiBjbG9zZXN0JDQoU3VnYXJFbGVtZW50LmZyb21Eb20obm9kZSksIGVsbSA9PiBpc0NvbnRlbnRFZGl0YWJsZVRydWUoZWxtKSB8fCBpc0Jsb2NrJDIoZWxtKSwgaXNSb290KHJvb3ROb2RlKSkuZ2V0T3IoU3VnYXJFbGVtZW50LmZyb21Eb20ocm9vdE5vZGUpKS5kb207XG4gICAgY29uc3QgZ2V0Q2xvc2VzdENlZiA9IChub2RlLCByb290Tm9kZSkgPT4gY2xvc2VzdCQ0KFN1Z2FyRWxlbWVudC5mcm9tRG9tKG5vZGUpLCBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJDIsIGlzUm9vdChyb290Tm9kZSkpO1xuICAgIGNvbnN0IGZpbmRFZGdlQ2FyZXRDYW5kaWRhdGUgPSAoc3RhcnROb2RlLCBzY29wZSwgZm9yd2FyZCkgPT4ge1xuICAgICAgY29uc3Qgd2Fsa2VyID0gbmV3IERvbVRyZWVXYWxrZXIoc3RhcnROb2RlLCBzY29wZSk7XG4gICAgICBjb25zdCBuZXh0ID0gZm9yd2FyZCA/IHdhbGtlci5uZXh0LmJpbmQod2Fsa2VyKSA6IHdhbGtlci5wcmV2LmJpbmQod2Fsa2VyKTtcbiAgICAgIGxldCByZXN1bHQgPSBzdGFydE5vZGU7XG4gICAgICBmb3IgKGxldCBjdXJyZW50ID0gZm9yd2FyZCA/IHN0YXJ0Tm9kZSA6IG5leHQoKTsgY3VycmVudCAmJiAhaXNCcihjdXJyZW50KTsgY3VycmVudCA9IG5leHQoKSkge1xuICAgICAgICBpZiAoaXNDYXJldENhbmRpZGF0ZSQzKGN1cnJlbnQpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIGNvbnN0IGZpbmRDbG9zZXN0QmxvY2tSYW5nZSA9IChzdGFydFJuZywgcm9vdE5vZGUpID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0UG9zID0gQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChzdGFydFJuZyk7XG4gICAgICBjb25zdCBjbGlja05vZGUgPSBzdGFydFBvcy5nZXROb2RlKCk7XG4gICAgICBjb25zdCBzY29wZSA9IGdldENsb3Nlc3RTY29wZShjbGlja05vZGUsIHJvb3ROb2RlKTtcbiAgICAgIGNvbnN0IHN0YXJ0Tm9kZSA9IGZpbmRFZGdlQ2FyZXRDYW5kaWRhdGUoY2xpY2tOb2RlLCBzY29wZSwgZmFsc2UpO1xuICAgICAgY29uc3QgZW5kTm9kZSA9IGZpbmRFZGdlQ2FyZXRDYW5kaWRhdGUoY2xpY2tOb2RlLCBzY29wZSwgdHJ1ZSk7XG4gICAgICBjb25zdCBybmcgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgZ2V0Q2xvc2VzdENlZihzdGFydE5vZGUsIHNjb3BlKS5mb2xkKCgpID0+IHtcbiAgICAgICAgaWYgKGlzVGV4dChzdGFydE5vZGUpKSB7XG4gICAgICAgICAgcm5nLnNldFN0YXJ0KHN0YXJ0Tm9kZSwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm5nLnNldFN0YXJ0QmVmb3JlKHN0YXJ0Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIGNlZiA9PiBybmcuc2V0U3RhcnRCZWZvcmUoY2VmLmRvbSkpO1xuICAgICAgZ2V0Q2xvc2VzdENlZihlbmROb2RlLCBzY29wZSkuZm9sZCgoKSA9PiB7XG4gICAgICAgIGlmIChpc1RleHQoZW5kTm9kZSkpIHtcbiAgICAgICAgICBybmcuc2V0RW5kKGVuZE5vZGUsIGVuZE5vZGUuZGF0YS5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJuZy5zZXRFbmRBZnRlcihlbmROb2RlKTtcbiAgICAgICAgfVxuICAgICAgfSwgY2VmID0+IHJuZy5zZXRFbmRBZnRlcihjZWYuZG9tKSk7XG4gICAgICByZXR1cm4gcm5nO1xuICAgIH07XG4gICAgY29uc3Qgb25UcmlwbGVDbGlja1NlbGVjdCA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBybmcgPSBmaW5kQ2xvc2VzdEJsb2NrUmFuZ2UoZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKSwgZWRpdG9yLmdldEJvZHkoKSk7XG4gICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFJuZyhub3JtYWxpemUocm5nKSk7XG4gICAgfTtcbiAgICBjb25zdCBzZXR1cCQ1ID0gZWRpdG9yID0+IHtcbiAgICAgIGVkaXRvci5vbignbW91c2Vkb3duJywgZSA9PiB7XG4gICAgICAgIGlmIChlLmRldGFpbCA+PSAzKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIG9uVHJpcGxlQ2xpY2tTZWxlY3QoZWRpdG9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBGYWtlQ2FyZXRQb3NpdGlvbjtcbiAgICAoZnVuY3Rpb24gKEZha2VDYXJldFBvc2l0aW9uKSB7XG4gICAgICBGYWtlQ2FyZXRQb3NpdGlvblsnQmVmb3JlJ10gPSAnYmVmb3JlJztcbiAgICAgIEZha2VDYXJldFBvc2l0aW9uWydBZnRlciddID0gJ2FmdGVyJztcbiAgICB9KEZha2VDYXJldFBvc2l0aW9uIHx8IChGYWtlQ2FyZXRQb3NpdGlvbiA9IHt9KSkpO1xuICAgIGNvbnN0IGRpc3RhbmNlVG9SZWN0TGVmdCA9IChjbGllbnRSZWN0LCBjbGllbnRYKSA9PiBNYXRoLmFicyhjbGllbnRSZWN0LmxlZnQgLSBjbGllbnRYKTtcbiAgICBjb25zdCBkaXN0YW5jZVRvUmVjdFJpZ2h0ID0gKGNsaWVudFJlY3QsIGNsaWVudFgpID0+IE1hdGguYWJzKGNsaWVudFJlY3QucmlnaHQgLSBjbGllbnRYKTtcbiAgICBjb25zdCBpc0luc2lkZVkgPSAoY2xpZW50WSwgY2xpZW50UmVjdCkgPT4gY2xpZW50WSA+PSBjbGllbnRSZWN0LnRvcCAmJiBjbGllbnRZIDw9IGNsaWVudFJlY3QuYm90dG9tO1xuICAgIGNvbnN0IGNvbGxpZGVzWSA9IChyMSwgcjIpID0+IHIxLnRvcCA8IHIyLmJvdHRvbSAmJiByMS5ib3R0b20gPiByMi50b3A7XG4gICAgY29uc3QgaXNPdmVybGFwcGluZyA9IChyMSwgcjIpID0+IHtcbiAgICAgIGNvbnN0IG92ZXJsYXAgPSBvdmVybGFwWShyMSwgcjIpIC8gTWF0aC5taW4ocjEuaGVpZ2h0LCByMi5oZWlnaHQpO1xuICAgICAgcmV0dXJuIGNvbGxpZGVzWShyMSwgcjIpICYmIG92ZXJsYXAgPiAwLjU7XG4gICAgfTtcbiAgICBjb25zdCBzcGxpdFJlY3RzUGVyQXhpcyA9IChyZWN0cywgeSkgPT4ge1xuICAgICAgY29uc3QgaW50ZXJzZWN0aW5nUmVjdHMgPSBmaWx0ZXIkNShyZWN0cywgcmVjdCA9PiBpc0luc2lkZVkoeSwgcmVjdCkpO1xuICAgICAgcmV0dXJuIGJvdW5kaW5nQ2xpZW50UmVjdEZyb21SZWN0cyhpbnRlcnNlY3RpbmdSZWN0cykuZm9sZCgoKSA9PiBbXG4gICAgICAgIFtdLFxuICAgICAgICByZWN0c1xuICAgICAgXSwgYm91bmRpbmdSZWN0ID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHBhc3M6IGhvcml6b250YWwsXG4gICAgICAgICAgZmFpbDogdmVydGljYWxcbiAgICAgICAgfSA9IHBhcnRpdGlvbiQyKHJlY3RzLCByZWN0ID0+IGlzT3ZlcmxhcHBpbmcocmVjdCwgYm91bmRpbmdSZWN0KSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgaG9yaXpvbnRhbCxcbiAgICAgICAgICB2ZXJ0aWNhbFxuICAgICAgICBdO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBjbGllbnRJbmZvID0gKHJlY3QsIGNsaWVudFgpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5vZGU6IHJlY3Qubm9kZSxcbiAgICAgICAgcG9zaXRpb246IGRpc3RhbmNlVG9SZWN0TGVmdChyZWN0LCBjbGllbnRYKSA8IGRpc3RhbmNlVG9SZWN0UmlnaHQocmVjdCwgY2xpZW50WCkgPyBGYWtlQ2FyZXRQb3NpdGlvbi5CZWZvcmUgOiBGYWtlQ2FyZXRQb3NpdGlvbi5BZnRlclxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGhvcml6b250YWxEaXN0YW5jZSA9IChyZWN0LCB4LCBfeSkgPT4geCA+IHJlY3QubGVmdCAmJiB4IDwgcmVjdC5yaWdodCA/IDAgOiBNYXRoLm1pbihNYXRoLmFicyhyZWN0LmxlZnQgLSB4KSwgTWF0aC5hYnMocmVjdC5yaWdodCAtIHgpKTtcbiAgICBjb25zdCBjbG9zZXN0Q2hpbGRDYXJldENhbmRpZGF0ZU5vZGVSZWN0ID0gKGNoaWxkcmVuLCBjbGllbnRYLCBjbGllbnRZKSA9PiB7XG4gICAgICBjb25zdCBjYXJldENhbmRpZGF0ZVJlY3QgPSByZWN0ID0+IHtcbiAgICAgICAgaWYgKGlzQ2FyZXRDYW5kaWRhdGUkMyhyZWN0Lm5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUocmVjdCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNFbGVtZW50JDYocmVjdC5ub2RlKSkge1xuICAgICAgICAgIHJldHVybiBjbG9zZXN0Q2hpbGRDYXJldENhbmRpZGF0ZU5vZGVSZWN0KGZyb20ocmVjdC5ub2RlLmNoaWxkTm9kZXMpLCBjbGllbnRYLCBjbGllbnRZKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0Q2xvc2VzdFRleHROb2RlID0gKHJlY3RzLCBkaXN0YW5jZSkgPT4ge1xuICAgICAgICBpZiAocmVjdHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICBjb25zdCByMSA9IGNhcmV0Q2FuZGlkYXRlUmVjdChyZWN0c1swXSkuZ2V0T3IocmVjdHNbMF0pO1xuICAgICAgICAgIGNvbnN0IHIyID0gY2FyZXRDYW5kaWRhdGVSZWN0KHJlY3RzWzFdKS5nZXRPcihyZWN0c1sxXSk7XG4gICAgICAgICAgY29uc3QgZGVsdGFEaXN0YW5jZSA9IE1hdGguYWJzKGRpc3RhbmNlKHIxLCBjbGllbnRYLCBjbGllbnRZKSAtIGRpc3RhbmNlKHIyLCBjbGllbnRYLCBjbGllbnRZKSk7XG4gICAgICAgICAgaWYgKGRlbHRhRGlzdGFuY2UgPCAyKSB7XG4gICAgICAgICAgICBpZiAoaXNUZXh0JGEocjEubm9kZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUocjEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1RleHQkYShyMi5ub2RlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShyMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZmluZENsb3Nlc3RDYXJldENhbmRpZGF0ZU5vZGVSZWN0ID0gKHJlY3RzLCBkaXN0YW5jZSkgPT4ge1xuICAgICAgICBjb25zdCBzb3J0ZWRSZWN0cyA9IHNvcnQocmVjdHMsIChyMSwgcjIpID0+IGRpc3RhbmNlKHIxLCBjbGllbnRYLCBjbGllbnRZKSAtIGRpc3RhbmNlKHIyLCBjbGllbnRYLCBjbGllbnRZKSk7XG4gICAgICAgIHJldHVybiBnZXRDbG9zZXN0VGV4dE5vZGUoc29ydGVkUmVjdHMsIGRpc3RhbmNlKS5vclRodW5rKCgpID0+IGZpbmRNYXAoc29ydGVkUmVjdHMsIGNhcmV0Q2FuZGlkYXRlUmVjdCkpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IFtob3Jpem9udGFsUmVjdHMsIHZlcnRpY2FsUmVjdHNdID0gc3BsaXRSZWN0c1BlckF4aXMoZ2V0Q2xpZW50UmVjdHMoY2hpbGRyZW4pLCBjbGllbnRZKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFzczogYWJvdmUsXG4gICAgICAgIGZhaWw6IGJlbG93XG4gICAgICB9ID0gcGFydGl0aW9uJDIodmVydGljYWxSZWN0cywgcmVjdCA9PiByZWN0LnRvcCA8IGNsaWVudFkpO1xuICAgICAgcmV0dXJuIGZpbmRDbG9zZXN0Q2FyZXRDYW5kaWRhdGVOb2RlUmVjdChob3Jpem9udGFsUmVjdHMsIGhvcml6b250YWxEaXN0YW5jZSkub3JUaHVuaygoKSA9PiBmaW5kQ2xvc2VzdENhcmV0Q2FuZGlkYXRlTm9kZVJlY3QoYmVsb3csIGRpc3RhbmNlVG9SZWN0RWRnZUZyb21YWSkpLm9yVGh1bmsoKCkgPT4gZmluZENsb3Nlc3RDYXJldENhbmRpZGF0ZU5vZGVSZWN0KGFib3ZlLCBkaXN0YW5jZVRvUmVjdEVkZ2VGcm9tWFkpKTtcbiAgICB9O1xuICAgIGNvbnN0IHRyYXZlcnNlVXAgPSAocm9vdEVsbSwgc2NvcGUsIGNsaWVudFgsIGNsaWVudFkpID0+IHtcbiAgICAgIGNvbnN0IGhlbHBlciA9IChzY29wZSwgcHJldlNjb3BlKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzRHJhZ0dob3N0Q29udGFpbmVyID0gbm9kZSA9PiBpc0VsZW1lbnQkNihub2RlKSAmJiBub2RlLmNsYXNzTGlzdC5jb250YWlucygnbWNlLWRyYWctY29udGFpbmVyJyk7XG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZXNXaXRob3V0R2hvc3QgPSBmaWx0ZXIkNShzY29wZS5kb20uY2hpbGROb2Rlcywgbm90KGlzRHJhZ0dob3N0Q29udGFpbmVyKSk7XG4gICAgICAgIHJldHVybiBwcmV2U2NvcGUuZm9sZCgoKSA9PiBjbG9zZXN0Q2hpbGRDYXJldENhbmRpZGF0ZU5vZGVSZWN0KGNoaWxkTm9kZXNXaXRob3V0R2hvc3QsIGNsaWVudFgsIGNsaWVudFkpLCBwcmV2U2NvcGUgPT4ge1xuICAgICAgICAgIGNvbnN0IHVuY2hlY2tlZENoaWxkcmVuID0gZmlsdGVyJDUoY2hpbGROb2Rlc1dpdGhvdXRHaG9zdCwgbm9kZSA9PiBub2RlICE9PSBwcmV2U2NvcGUuZG9tKTtcbiAgICAgICAgICByZXR1cm4gY2xvc2VzdENoaWxkQ2FyZXRDYW5kaWRhdGVOb2RlUmVjdCh1bmNoZWNrZWRDaGlsZHJlbiwgY2xpZW50WCwgY2xpZW50WSk7XG4gICAgICAgIH0pLm9yVGh1bmsoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHBhcmVudCA9IGVxKHNjb3BlLCByb290RWxtKSA/IE9wdGlvbmFsLm5vbmUoKSA6IHBhcmVudEVsZW1lbnQoc2NvcGUpO1xuICAgICAgICAgIHJldHVybiBwYXJlbnQuYmluZChuZXdTY29wZSA9PiBoZWxwZXIobmV3U2NvcGUsIE9wdGlvbmFsLnNvbWUoc2NvcGUpKSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBoZWxwZXIoc2NvcGUsIE9wdGlvbmFsLm5vbmUoKSk7XG4gICAgfTtcbiAgICBjb25zdCBjbG9zZXN0Q2FyZXRDYW5kaWRhdGVOb2RlUmVjdCA9IChyb290LCBjbGllbnRYLCBjbGllbnRZKSA9PiB7XG4gICAgICBjb25zdCByb290RWxtID0gU3VnYXJFbGVtZW50LmZyb21Eb20ocm9vdCk7XG4gICAgICBjb25zdCBvd25lckRvYyA9IGRvY3VtZW50T3JPd25lcihyb290RWxtKTtcbiAgICAgIGNvbnN0IGVsZW1lbnRBdFBvaW50ID0gU3VnYXJFbGVtZW50LmZyb21Qb2ludChvd25lckRvYywgY2xpZW50WCwgY2xpZW50WSkuZmlsdGVyKGVsbSA9PiBjb250YWlucyhyb290RWxtLCBlbG0pKTtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50QXRQb2ludC5nZXRPcihyb290RWxtKTtcbiAgICAgIHJldHVybiB0cmF2ZXJzZVVwKHJvb3RFbG0sIGVsZW1lbnQsIGNsaWVudFgsIGNsaWVudFkpO1xuICAgIH07XG4gICAgY29uc3QgY2xvc2VzdEZha2VDYXJldENhbmRpZGF0ZSA9IChyb290LCBjbGllbnRYLCBjbGllbnRZKSA9PiBjbG9zZXN0Q2FyZXRDYW5kaWRhdGVOb2RlUmVjdChyb290LCBjbGllbnRYLCBjbGllbnRZKS5maWx0ZXIocmVjdCA9PiBpc0Zha2VDYXJldFRhcmdldChyZWN0Lm5vZGUpKS5tYXAocmVjdCA9PiBjbGllbnRJbmZvKHJlY3QsIGNsaWVudFgpKTtcblxuICAgIGNvbnN0IGdldEFic29sdXRlUG9zaXRpb24gPSBlbG0gPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGNvbnN0IGNsaWVudFJlY3QgPSBlbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBkb2MgPSBlbG0ub3duZXJEb2N1bWVudDtcbiAgICAgIGNvbnN0IGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgY29uc3Qgd2luID0gZG9jLmRlZmF1bHRWaWV3O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiBjbGllbnRSZWN0LnRvcCArICgoX2EgPSB3aW4gPT09IG51bGwgfHwgd2luID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aW4uc2Nyb2xsWSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCkgLSBkb2NFbGVtLmNsaWVudFRvcCxcbiAgICAgICAgbGVmdDogY2xpZW50UmVjdC5sZWZ0ICsgKChfYiA9IHdpbiA9PT0gbnVsbCB8fCB3aW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbi5zY3JvbGxYKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKSAtIGRvY0VsZW0uY2xpZW50TGVmdFxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGdldEJvZHlQb3NpdGlvbiA9IGVkaXRvciA9PiBlZGl0b3IuaW5saW5lID8gZ2V0QWJzb2x1dGVQb3NpdGlvbihlZGl0b3IuZ2V0Qm9keSgpKSA6IHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB0b3A6IDBcbiAgICB9O1xuICAgIGNvbnN0IGdldFNjcm9sbFBvc2l0aW9uID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGJvZHkgPSBlZGl0b3IuZ2V0Qm9keSgpO1xuICAgICAgcmV0dXJuIGVkaXRvci5pbmxpbmUgPyB7XG4gICAgICAgIGxlZnQ6IGJvZHkuc2Nyb2xsTGVmdCxcbiAgICAgICAgdG9wOiBib2R5LnNjcm9sbFRvcFxuICAgICAgfSA6IHtcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgdG9wOiAwXG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgZ2V0Qm9keVNjcm9sbCA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBib2R5ID0gZWRpdG9yLmdldEJvZHkoKSwgZG9jRWxtID0gZWRpdG9yLmdldERvYygpLmRvY3VtZW50RWxlbWVudDtcbiAgICAgIGNvbnN0IGlubGluZVNjcm9sbCA9IHtcbiAgICAgICAgbGVmdDogYm9keS5zY3JvbGxMZWZ0LFxuICAgICAgICB0b3A6IGJvZHkuc2Nyb2xsVG9wXG4gICAgICB9O1xuICAgICAgY29uc3QgaWZyYW1lU2Nyb2xsID0ge1xuICAgICAgICBsZWZ0OiBib2R5LnNjcm9sbExlZnQgfHwgZG9jRWxtLnNjcm9sbExlZnQsXG4gICAgICAgIHRvcDogYm9keS5zY3JvbGxUb3AgfHwgZG9jRWxtLnNjcm9sbFRvcFxuICAgICAgfTtcbiAgICAgIHJldHVybiBlZGl0b3IuaW5saW5lID8gaW5saW5lU2Nyb2xsIDogaWZyYW1lU2Nyb2xsO1xuICAgIH07XG4gICAgY29uc3QgZ2V0TW91c2VQb3NpdGlvbiA9IChlZGl0b3IsIGV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQudGFyZ2V0Lm93bmVyRG9jdW1lbnQgIT09IGVkaXRvci5nZXREb2MoKSkge1xuICAgICAgICBjb25zdCBpZnJhbWVQb3NpdGlvbiA9IGdldEFic29sdXRlUG9zaXRpb24oZWRpdG9yLmdldENvbnRlbnRBcmVhQ29udGFpbmVyKCkpO1xuICAgICAgICBjb25zdCBzY3JvbGxQb3NpdGlvbiA9IGdldEJvZHlTY3JvbGwoZWRpdG9yKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsZWZ0OiBldmVudC5wYWdlWCAtIGlmcmFtZVBvc2l0aW9uLmxlZnQgKyBzY3JvbGxQb3NpdGlvbi5sZWZ0LFxuICAgICAgICAgIHRvcDogZXZlbnQucGFnZVkgLSBpZnJhbWVQb3NpdGlvbi50b3AgKyBzY3JvbGxQb3NpdGlvbi50b3BcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IGV2ZW50LnBhZ2VYLFxuICAgICAgICB0b3A6IGV2ZW50LnBhZ2VZXG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgY2FsY3VsYXRlUG9zaXRpb24gPSAoYm9keVBvc2l0aW9uLCBzY3JvbGxQb3NpdGlvbiwgbW91c2VQb3NpdGlvbikgPT4gKHtcbiAgICAgIHBhZ2VYOiBtb3VzZVBvc2l0aW9uLmxlZnQgLSBib2R5UG9zaXRpb24ubGVmdCArIHNjcm9sbFBvc2l0aW9uLmxlZnQsXG4gICAgICBwYWdlWTogbW91c2VQb3NpdGlvbi50b3AgLSBib2R5UG9zaXRpb24udG9wICsgc2Nyb2xsUG9zaXRpb24udG9wXG4gICAgfSk7XG4gICAgY29uc3QgY2FsYyA9IChlZGl0b3IsIGV2ZW50KSA9PiBjYWxjdWxhdGVQb3NpdGlvbihnZXRCb2R5UG9zaXRpb24oZWRpdG9yKSwgZ2V0U2Nyb2xsUG9zaXRpb24oZWRpdG9yKSwgZ2V0TW91c2VQb3NpdGlvbihlZGl0b3IsIGV2ZW50KSk7XG5cbiAgICBjb25zdCBtYWtlRG5kRXZlbnRGcm9tTW91c2VFdmVudCA9ICh0eXBlLCBtb3VzZUV2ZW50LCBleHRyYSkgPT4gKHtcbiAgICAgIC4uLm1vdXNlRXZlbnQsXG4gICAgICBkYXRhVHJhbnNmZXI6IG51bGwsXG4gICAgICB0eXBlLFxuICAgICAgLi4uZXh0cmFcbiAgICB9KTtcbiAgICBjb25zdCBtYWtlRG5kRXZlbnQgPSAodHlwZSwgcHJvcHMpID0+IHtcbiAgICAgIGNvbnN0IGZhaWwgPSBkaWUoJ0Z1bmN0aW9uIG5vdCBzdXBwb3J0ZWQgb24gc2ltdWxhdGVkIGV2ZW50LicpO1xuICAgICAgY29uc3QgZXZlbnQgPSB7XG4gICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgIGNhbmNlbEJ1YmJsZTogZmFsc2UsXG4gICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICAgIGNvbXBvc2VkOiBmYWxzZSxcbiAgICAgICAgY3VycmVudFRhcmdldDogbnVsbCxcbiAgICAgICAgZGVmYXVsdFByZXZlbnRlZDogZmFsc2UsXG4gICAgICAgIGV2ZW50UGhhc2U6IDAsXG4gICAgICAgIGlzVHJ1c3RlZDogdHJ1ZSxcbiAgICAgICAgcmV0dXJuVmFsdWU6IGZhbHNlLFxuICAgICAgICBzcmNFbGVtZW50OiBudWxsLFxuICAgICAgICB0YXJnZXQ6IG51bGwsXG4gICAgICAgIHRpbWVTdGFtcDogMCxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgY29tcG9zZWRQYXRoOiBmYWlsLFxuICAgICAgICBpbml0RXZlbnQ6IGZhaWwsXG4gICAgICAgIHByZXZlbnREZWZhdWx0OiBub29wLFxuICAgICAgICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IG5vb3AsXG4gICAgICAgIHN0b3BQcm9wYWdhdGlvbjogbm9vcCxcbiAgICAgICAgQVRfVEFSR0VUOiB3aW5kb3cuRXZlbnQuQVRfVEFSR0VULFxuICAgICAgICBCVUJCTElOR19QSEFTRTogd2luZG93LkV2ZW50LkJVQkJMSU5HX1BIQVNFLFxuICAgICAgICBDQVBUVVJJTkdfUEhBU0U6IHdpbmRvdy5FdmVudC5DQVBUVVJJTkdfUEhBU0UsXG4gICAgICAgIE5PTkU6IHdpbmRvdy5FdmVudC5OT05FLFxuICAgICAgICBhbHRLZXk6IGZhbHNlLFxuICAgICAgICBidXR0b246IDAsXG4gICAgICAgIGJ1dHRvbnM6IDAsXG4gICAgICAgIGNsaWVudFg6IDAsXG4gICAgICAgIGNsaWVudFk6IDAsXG4gICAgICAgIGN0cmxLZXk6IGZhbHNlLFxuICAgICAgICBtZXRhS2V5OiBmYWxzZSxcbiAgICAgICAgbW92ZW1lbnRYOiAwLFxuICAgICAgICBtb3ZlbWVudFk6IDAsXG4gICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgIHBhZ2VYOiAwLFxuICAgICAgICBwYWdlWTogMCxcbiAgICAgICAgcmVsYXRlZFRhcmdldDogbnVsbCxcbiAgICAgICAgc2NyZWVuWDogMCxcbiAgICAgICAgc2NyZWVuWTogMCxcbiAgICAgICAgc2hpZnRLZXk6IGZhbHNlLFxuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICBkZXRhaWw6IDAsXG4gICAgICAgIHZpZXc6IG51bGwsXG4gICAgICAgIHdoaWNoOiAwLFxuICAgICAgICBpbml0VUlFdmVudDogZmFpbCxcbiAgICAgICAgaW5pdE1vdXNlRXZlbnQ6IGZhaWwsXG4gICAgICAgIGdldE1vZGlmaWVyU3RhdGU6IGZhaWwsXG4gICAgICAgIGRhdGFUcmFuc2ZlcjogbnVsbCxcbiAgICAgICAgLi4ucHJvcHNcbiAgICAgIH07XG4gICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfTtcbiAgICBjb25zdCBmYWxsYmFjayA9IHRhcmdldCA9PiAoe1xuICAgICAgdGFyZ2V0LFxuICAgICAgc3JjRWxlbWVudDogdGFyZ2V0XG4gICAgfSk7XG4gICAgY29uc3QgZG5kRXZlbnQgPSB0eXBlID0+IHRhcmdldCA9PiBtYWtlRG5kRXZlbnQodHlwZSwgZmFsbGJhY2sodGFyZ2V0KSk7XG4gICAgY29uc3QgZG5kRXZlbnRGcm9tTW91c2VFdmVudCA9IHR5cGUgPT4gKG1vdXNlRXZlbnQsIHRhcmdldCkgPT4gbWFrZURuZEV2ZW50RnJvbU1vdXNlRXZlbnQodHlwZSwgbW91c2VFdmVudCwgZmFsbGJhY2sodGFyZ2V0KSk7XG4gICAgY29uc3QgbWFrZURyYWdzdGFydEV2ZW50RnJvbU1vdXNlRXZlbnQgPSBkbmRFdmVudEZyb21Nb3VzZUV2ZW50KCdkcmFnc3RhcnQnKTtcbiAgICBjb25zdCBtYWtlRHJvcEV2ZW50RnJvbU1vdXNlRXZlbnQgPSBkbmRFdmVudEZyb21Nb3VzZUV2ZW50KCdkcm9wJyk7XG4gICAgY29uc3QgbWFrZURyYWdlbmRFdmVudCA9IGRuZEV2ZW50KCdkcmFnZW5kJyk7XG4gICAgY29uc3QgbWFrZURyYWdlbmRFdmVudEZyb21Nb3VzZUV2ZW50ID0gZG5kRXZlbnRGcm9tTW91c2VFdmVudCgnZHJhZ2VuZCcpO1xuXG4gICAgY29uc3Qgc2Nyb2xsUGl4ZWxzUGVySW50ZXJ2YWwgPSAzMjtcbiAgICBjb25zdCBzY3JvbGxJbnRlcnZhbFZhbHVlID0gMTAwO1xuICAgIGNvbnN0IG1vdXNlUmFuZ2VUb1RyaWdnZXJTY3JvbGxJbnNpZGVFZGl0b3IgPSA4O1xuICAgIGNvbnN0IG1vdXNlUmFuZ2VUb1RyaWdnZXJTY3JvbGxPdXRzaWRlRWRpdG9yID0gMTY7XG4gICAgY29uc3QgaXNDb250ZW50RWRpdGFibGVGYWxzZSQxID0gaXNDb250ZW50RWRpdGFibGVGYWxzZSRiO1xuICAgIGNvbnN0IGlzQ29udGVudEVkaXRhYmxlID0gb3IoaXNDb250ZW50RWRpdGFibGVGYWxzZSQxLCBpc0NvbnRlbnRFZGl0YWJsZVRydWUkMyk7XG4gICAgY29uc3QgaXNEcmFnZ2FibGUgPSAoZG9tLCByb290RWxtLCBlbG0pID0+IGlzQ29udGVudEVkaXRhYmxlRmFsc2UkMShlbG0pICYmIGVsbSAhPT0gcm9vdEVsbSAmJiBkb20uaXNFZGl0YWJsZShlbG0ucGFyZW50RWxlbWVudCk7XG4gICAgY29uc3QgaXNWYWxpZERyb3BUYXJnZXQgPSAoZWRpdG9yLCB0YXJnZXRFbGVtZW50LCBkcmFnRWxlbWVudCkgPT4ge1xuICAgICAgaWYgKGlzTnVsbGFibGUodGFyZ2V0RWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICh0YXJnZXRFbGVtZW50ID09PSBkcmFnRWxlbWVudCB8fCBlZGl0b3IuZG9tLmlzQ2hpbGRPZih0YXJnZXRFbGVtZW50LCBkcmFnRWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVkaXRvci5kb20uaXNFZGl0YWJsZSh0YXJnZXRFbGVtZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGNsb25lRWxlbWVudCA9IGVsbSA9PiB7XG4gICAgICBjb25zdCBjbG9uZUVsbSA9IGVsbS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICBjbG9uZUVsbS5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtbWNlLXNlbGVjdGVkJyk7XG4gICAgICByZXR1cm4gY2xvbmVFbG07XG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGVHaG9zdCA9IChlZGl0b3IsIGVsbSwgd2lkdGgsIGhlaWdodCkgPT4ge1xuICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbTtcbiAgICAgIGNvbnN0IGNsb25lZEVsbSA9IGVsbS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICBkb20uc2V0U3R5bGVzKGNsb25lZEVsbSwge1xuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9KTtcbiAgICAgIGRvbS5zZXRBdHRyaWIoY2xvbmVkRWxtLCAnZGF0YS1tY2Utc2VsZWN0ZWQnLCBudWxsKTtcbiAgICAgIGNvbnN0IGdob3N0RWxtID0gZG9tLmNyZWF0ZSgnZGl2Jywge1xuICAgICAgICAnY2xhc3MnOiAnbWNlLWRyYWctY29udGFpbmVyJyxcbiAgICAgICAgJ2RhdGEtbWNlLWJvZ3VzJzogJ2FsbCcsXG4gICAgICAgICd1bnNlbGVjdGFibGUnOiAnb24nLFxuICAgICAgICAnY29udGVudGVkaXRhYmxlJzogJ2ZhbHNlJ1xuICAgICAgfSk7XG4gICAgICBkb20uc2V0U3R5bGVzKGdob3N0RWxtLCB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICBvcGFjaXR5OiAwLjUsXG4gICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgYm9yZGVyOiAwLFxuICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH0pO1xuICAgICAgZG9tLnNldFN0eWxlcyhjbG9uZWRFbG0sIHtcbiAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94J1xuICAgICAgfSk7XG4gICAgICBnaG9zdEVsbS5hcHBlbmRDaGlsZChjbG9uZWRFbG0pO1xuICAgICAgcmV0dXJuIGdob3N0RWxtO1xuICAgIH07XG4gICAgY29uc3QgYXBwZW5kR2hvc3RUb0JvZHkgPSAoZ2hvc3RFbG0sIGJvZHlFbG0pID0+IHtcbiAgICAgIGlmIChnaG9zdEVsbS5wYXJlbnROb2RlICE9PSBib2R5RWxtKSB7XG4gICAgICAgIGJvZHlFbG0uYXBwZW5kQ2hpbGQoZ2hvc3RFbG0pO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc2Nyb2xsRWRpdG9yID0gKGRpcmVjdGlvbiwgYW1vdW50KSA9PiB3aW4gPT4gKCkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudCA9IGRpcmVjdGlvbiA9PT0gJ2xlZnQnID8gd2luLnNjcm9sbFggOiB3aW4uc2Nyb2xsWTtcbiAgICAgIHdpbi5zY3JvbGwoe1xuICAgICAgICBbZGlyZWN0aW9uXTogY3VycmVudCArIGFtb3VudCxcbiAgICAgICAgYmVoYXZpb3I6ICdzbW9vdGgnXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHNjcm9sbExlZnQgPSBzY3JvbGxFZGl0b3IoJ2xlZnQnLCAtc2Nyb2xsUGl4ZWxzUGVySW50ZXJ2YWwpO1xuICAgIGNvbnN0IHNjcm9sbFJpZ2h0ID0gc2Nyb2xsRWRpdG9yKCdsZWZ0Jywgc2Nyb2xsUGl4ZWxzUGVySW50ZXJ2YWwpO1xuICAgIGNvbnN0IHNjcm9sbFVwID0gc2Nyb2xsRWRpdG9yKCd0b3AnLCAtc2Nyb2xsUGl4ZWxzUGVySW50ZXJ2YWwpO1xuICAgIGNvbnN0IHNjcm9sbERvd24gPSBzY3JvbGxFZGl0b3IoJ3RvcCcsIHNjcm9sbFBpeGVsc1BlckludGVydmFsKTtcbiAgICBjb25zdCBtb3ZlR2hvc3QgPSAoZ2hvc3RFbG0sIHBvc2l0aW9uLCB3aWR0aCwgaGVpZ2h0LCBtYXhYLCBtYXhZLCBtb3VzZVksIG1vdXNlWCwgY29udGVudEFyZWFDb250YWluZXIsIHdpbiwgc3RhdGUsIG1vdXNlRXZlbnRPcmlnaW5hdGVkRnJvbVdpdGhpblRoZUVkaXRvcikgPT4ge1xuICAgICAgbGV0IG92ZXJmbG93WCA9IDAsIG92ZXJmbG93WSA9IDA7XG4gICAgICBnaG9zdEVsbS5zdHlsZS5sZWZ0ID0gcG9zaXRpb24ucGFnZVggKyAncHgnO1xuICAgICAgZ2hvc3RFbG0uc3R5bGUudG9wID0gcG9zaXRpb24ucGFnZVkgKyAncHgnO1xuICAgICAgaWYgKHBvc2l0aW9uLnBhZ2VYICsgd2lkdGggPiBtYXhYKSB7XG4gICAgICAgIG92ZXJmbG93WCA9IHBvc2l0aW9uLnBhZ2VYICsgd2lkdGggLSBtYXhYO1xuICAgICAgfVxuICAgICAgaWYgKHBvc2l0aW9uLnBhZ2VZICsgaGVpZ2h0ID4gbWF4WSkge1xuICAgICAgICBvdmVyZmxvd1kgPSBwb3NpdGlvbi5wYWdlWSArIGhlaWdodCAtIG1heFk7XG4gICAgICB9XG4gICAgICBnaG9zdEVsbS5zdHlsZS53aWR0aCA9IHdpZHRoIC0gb3ZlcmZsb3dYICsgJ3B4JztcbiAgICAgIGdob3N0RWxtLnN0eWxlLmhlaWdodCA9IGhlaWdodCAtIG92ZXJmbG93WSArICdweCc7XG4gICAgICBjb25zdCBjbGllbnRIZWlnaHQgPSBjb250ZW50QXJlYUNvbnRhaW5lci5jbGllbnRIZWlnaHQ7XG4gICAgICBjb25zdCBjbGllbnRXaWR0aCA9IGNvbnRlbnRBcmVhQ29udGFpbmVyLmNsaWVudFdpZHRoO1xuICAgICAgY29uc3Qgb3V0ZXJNb3VzZVkgPSBtb3VzZVkgKyBjb250ZW50QXJlYUNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgICBjb25zdCBvdXRlck1vdXNlWCA9IG1vdXNlWCArIGNvbnRlbnRBcmVhQ29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG4gICAgICBzdGF0ZS5vbihzdGF0ZSA9PiB7XG4gICAgICAgIHN0YXRlLmludGVydmFsSWQuY2xlYXIoKTtcbiAgICAgICAgaWYgKHN0YXRlLmRyYWdnaW5nICYmIG1vdXNlRXZlbnRPcmlnaW5hdGVkRnJvbVdpdGhpblRoZUVkaXRvcikge1xuICAgICAgICAgIGlmIChtb3VzZVkgKyBtb3VzZVJhbmdlVG9UcmlnZ2VyU2Nyb2xsSW5zaWRlRWRpdG9yID49IGNsaWVudEhlaWdodCkge1xuICAgICAgICAgICAgc3RhdGUuaW50ZXJ2YWxJZC5zZXQoc2Nyb2xsRG93bih3aW4pKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG1vdXNlWSAtIG1vdXNlUmFuZ2VUb1RyaWdnZXJTY3JvbGxJbnNpZGVFZGl0b3IgPD0gMCkge1xuICAgICAgICAgICAgc3RhdGUuaW50ZXJ2YWxJZC5zZXQoc2Nyb2xsVXAod2luKSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChtb3VzZVggKyBtb3VzZVJhbmdlVG9UcmlnZ2VyU2Nyb2xsSW5zaWRlRWRpdG9yID49IGNsaWVudFdpZHRoKSB7XG4gICAgICAgICAgICBzdGF0ZS5pbnRlcnZhbElkLnNldChzY3JvbGxSaWdodCh3aW4pKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG1vdXNlWCAtIG1vdXNlUmFuZ2VUb1RyaWdnZXJTY3JvbGxJbnNpZGVFZGl0b3IgPD0gMCkge1xuICAgICAgICAgICAgc3RhdGUuaW50ZXJ2YWxJZC5zZXQoc2Nyb2xsTGVmdCh3aW4pKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG91dGVyTW91c2VZICsgbW91c2VSYW5nZVRvVHJpZ2dlclNjcm9sbE91dHNpZGVFZGl0b3IgPj0gd2luZG93LmlubmVySGVpZ2h0KSB7XG4gICAgICAgICAgICBzdGF0ZS5pbnRlcnZhbElkLnNldChzY3JvbGxEb3duKHdpbmRvdykpO1xuICAgICAgICAgIH0gZWxzZSBpZiAob3V0ZXJNb3VzZVkgLSBtb3VzZVJhbmdlVG9UcmlnZ2VyU2Nyb2xsT3V0c2lkZUVkaXRvciA8PSAwKSB7XG4gICAgICAgICAgICBzdGF0ZS5pbnRlcnZhbElkLnNldChzY3JvbGxVcCh3aW5kb3cpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG91dGVyTW91c2VYICsgbW91c2VSYW5nZVRvVHJpZ2dlclNjcm9sbE91dHNpZGVFZGl0b3IgPj0gd2luZG93LmlubmVyV2lkdGgpIHtcbiAgICAgICAgICAgIHN0YXRlLmludGVydmFsSWQuc2V0KHNjcm9sbFJpZ2h0KHdpbmRvdykpO1xuICAgICAgICAgIH0gZWxzZSBpZiAob3V0ZXJNb3VzZVggLSBtb3VzZVJhbmdlVG9UcmlnZ2VyU2Nyb2xsT3V0c2lkZUVkaXRvciA8PSAwKSB7XG4gICAgICAgICAgICBzdGF0ZS5pbnRlcnZhbElkLnNldChzY3JvbGxMZWZ0KHdpbmRvdykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVFbGVtZW50ID0gZWxtID0+IHtcbiAgICAgIGlmIChlbG0gJiYgZWxtLnBhcmVudE5vZGUpIHtcbiAgICAgICAgZWxtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxtKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZUVsZW1lbnRXaXRoUGFkZGluZyA9IChkb20sIGVsbSkgPT4ge1xuICAgICAgY29uc3QgcGFyZW50QmxvY2sgPSBkb20uZ2V0UGFyZW50KGVsbS5wYXJlbnROb2RlLCBkb20uaXNCbG9jayk7XG4gICAgICByZW1vdmVFbGVtZW50KGVsbSk7XG4gICAgICBpZiAocGFyZW50QmxvY2sgJiYgcGFyZW50QmxvY2sgIT09IGRvbS5nZXRSb290KCkgJiYgZG9tLmlzRW1wdHkocGFyZW50QmxvY2spKSB7XG4gICAgICAgIGZpbGxXaXRoUGFkZGluZ0JyKFN1Z2FyRWxlbWVudC5mcm9tRG9tKHBhcmVudEJsb2NrKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpc0xlZnRNb3VzZUJ1dHRvblByZXNzZWQgPSBlID0+IGUuYnV0dG9uID09PSAwO1xuICAgIGNvbnN0IGFwcGx5UmVsUG9zID0gKHN0YXRlLCBwb3NpdGlvbikgPT4gKHtcbiAgICAgIHBhZ2VYOiBwb3NpdGlvbi5wYWdlWCAtIHN0YXRlLnJlbFgsXG4gICAgICBwYWdlWTogcG9zaXRpb24ucGFnZVkgKyA1XG4gICAgfSk7XG4gICAgY29uc3Qgc3RhcnQgPSAoc3RhdGUsIGVkaXRvcikgPT4gZSA9PiB7XG4gICAgICBpZiAoaXNMZWZ0TW91c2VCdXR0b25QcmVzc2VkKGUpKSB7XG4gICAgICAgIGNvbnN0IGNlRWxtID0gZmluZCQyKGVkaXRvci5kb20uZ2V0UGFyZW50cyhlLnRhcmdldCksIGlzQ29udGVudEVkaXRhYmxlKS5nZXRPcihudWxsKTtcbiAgICAgICAgaWYgKGlzTm9uTnVsbGFibGUoY2VFbG0pICYmIGlzRHJhZ2dhYmxlKGVkaXRvci5kb20sIGVkaXRvci5nZXRCb2R5KCksIGNlRWxtKSkge1xuICAgICAgICAgIGNvbnN0IGVsbVBvcyA9IGVkaXRvci5kb20uZ2V0UG9zKGNlRWxtKTtcbiAgICAgICAgICBjb25zdCBib2R5RWxtID0gZWRpdG9yLmdldEJvZHkoKTtcbiAgICAgICAgICBjb25zdCBkb2NFbG0gPSBlZGl0b3IuZ2V0RG9jKCkuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgIHN0YXRlLnNldCh7XG4gICAgICAgICAgICBlbGVtZW50OiBjZUVsbSxcbiAgICAgICAgICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIHNjcmVlblg6IGUuc2NyZWVuWCxcbiAgICAgICAgICAgIHNjcmVlblk6IGUuc2NyZWVuWSxcbiAgICAgICAgICAgIG1heFg6IChlZGl0b3IuaW5saW5lID8gYm9keUVsbS5zY3JvbGxXaWR0aCA6IGRvY0VsbS5vZmZzZXRXaWR0aCkgLSAyLFxuICAgICAgICAgICAgbWF4WTogKGVkaXRvci5pbmxpbmUgPyBib2R5RWxtLnNjcm9sbEhlaWdodCA6IGRvY0VsbS5vZmZzZXRIZWlnaHQpIC0gMixcbiAgICAgICAgICAgIHJlbFg6IGUucGFnZVggLSBlbG1Qb3MueCxcbiAgICAgICAgICAgIHJlbFk6IGUucGFnZVkgLSBlbG1Qb3MueSxcbiAgICAgICAgICAgIHdpZHRoOiBjZUVsbS5vZmZzZXRXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogY2VFbG0ub2Zmc2V0SGVpZ2h0LFxuICAgICAgICAgICAgZ2hvc3Q6IGNyZWF0ZUdob3N0KGVkaXRvciwgY2VFbG0sIGNlRWxtLm9mZnNldFdpZHRoLCBjZUVsbS5vZmZzZXRIZWlnaHQpLFxuICAgICAgICAgICAgaW50ZXJ2YWxJZDogcmVwZWF0YWJsZShzY3JvbGxJbnRlcnZhbFZhbHVlKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBwbGFjZUNhcmV0QXQgPSAoZWRpdG9yLCBjbGllbnRYLCBjbGllbnRZKSA9PiB7XG4gICAgICBlZGl0b3IuX3NlbGVjdGlvbk92ZXJyaWRlcy5oaWRlRmFrZUNhcmV0KCk7XG4gICAgICBjbG9zZXN0RmFrZUNhcmV0Q2FuZGlkYXRlKGVkaXRvci5nZXRCb2R5KCksIGNsaWVudFgsIGNsaWVudFkpLmZvbGQoKCkgPT4gZWRpdG9yLnNlbGVjdGlvbi5wbGFjZUNhcmV0QXQoY2xpZW50WCwgY2xpZW50WSksIGNhcmV0SW5mbyA9PiB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gZWRpdG9yLl9zZWxlY3Rpb25PdmVycmlkZXMuc2hvd0NhcmV0KDEsIGNhcmV0SW5mby5ub2RlLCBjYXJldEluZm8ucG9zaXRpb24gPT09IEZha2VDYXJldFBvc2l0aW9uLkJlZm9yZSwgZmFsc2UpO1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFJuZyhyYW5nZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5wbGFjZUNhcmV0QXQoY2xpZW50WCwgY2xpZW50WSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgbW92ZSA9IChzdGF0ZSwgZWRpdG9yKSA9PiB7XG4gICAgICBjb25zdCB0aHJvdHRsZWRQbGFjZUNhcmV0QXQgPSBmaXJzdCQxKChjbGllbnRYLCBjbGllbnRZKSA9PiBwbGFjZUNhcmV0QXQoZWRpdG9yLCBjbGllbnRYLCBjbGllbnRZKSwgMCk7XG4gICAgICBlZGl0b3Iub24oJ3JlbW92ZScsIHRocm90dGxlZFBsYWNlQ2FyZXRBdC5jYW5jZWwpO1xuICAgICAgY29uc3Qgc3RhdGVfID0gc3RhdGU7XG4gICAgICByZXR1cm4gZSA9PiBzdGF0ZS5vbihzdGF0ZSA9PiB7XG4gICAgICAgIGNvbnN0IG1vdmVtZW50ID0gTWF0aC5tYXgoTWF0aC5hYnMoZS5zY3JlZW5YIC0gc3RhdGUuc2NyZWVuWCksIE1hdGguYWJzKGUuc2NyZWVuWSAtIHN0YXRlLnNjcmVlblkpKTtcbiAgICAgICAgaWYgKCFzdGF0ZS5kcmFnZ2luZyAmJiBtb3ZlbWVudCA+IDEwKSB7XG4gICAgICAgICAgY29uc3QgYXJncyA9IGVkaXRvci5kaXNwYXRjaCgnZHJhZ3N0YXJ0JywgbWFrZURyYWdzdGFydEV2ZW50RnJvbU1vdXNlRXZlbnQoZSwgc3RhdGUuZWxlbWVudCkpO1xuICAgICAgICAgIGlmIChhcmdzLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXRlLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICBlZGl0b3IuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZHJhZ2dpbmcpIHtcbiAgICAgICAgICBjb25zdCBtb3VzZUV2ZW50T3JpZ2luYXRlZEZyb21XaXRoaW5UaGVFZGl0b3IgPSBlLmN1cnJlbnRUYXJnZXQgPT09IGVkaXRvci5nZXREb2MoKS5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0UG9zID0gYXBwbHlSZWxQb3Moc3RhdGUsIGNhbGMoZWRpdG9yLCBlKSk7XG4gICAgICAgICAgYXBwZW5kR2hvc3RUb0JvZHkoc3RhdGUuZ2hvc3QsIGVkaXRvci5nZXRCb2R5KCkpO1xuICAgICAgICAgIG1vdmVHaG9zdChzdGF0ZS5naG9zdCwgdGFyZ2V0UG9zLCBzdGF0ZS53aWR0aCwgc3RhdGUuaGVpZ2h0LCBzdGF0ZS5tYXhYLCBzdGF0ZS5tYXhZLCBlLmNsaWVudFksIGUuY2xpZW50WCwgZWRpdG9yLmdldENvbnRlbnRBcmVhQ29udGFpbmVyKCksIGVkaXRvci5nZXRXaW4oKSwgc3RhdGVfLCBtb3VzZUV2ZW50T3JpZ2luYXRlZEZyb21XaXRoaW5UaGVFZGl0b3IpO1xuICAgICAgICAgIHRocm90dGxlZFBsYWNlQ2FyZXRBdC50aHJvdHRsZShlLmNsaWVudFgsIGUuY2xpZW50WSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgZ2V0UmF3VGFyZ2V0ID0gc2VsZWN0aW9uID0+IHtcbiAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdGlvbi5nZXRTZWwoKTtcbiAgICAgIGlmIChpc05vbk51bGxhYmxlKHNlbCkpIHtcbiAgICAgICAgY29uc3Qgcm5nID0gc2VsLmdldFJhbmdlQXQoMCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0Q29udGFpbmVyID0gcm5nLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgICByZXR1cm4gaXNUZXh0JGEoc3RhcnRDb250YWluZXIpID8gc3RhcnRDb250YWluZXIucGFyZW50Tm9kZSA6IHN0YXJ0Q29udGFpbmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBkcm9wID0gKHN0YXRlLCBlZGl0b3IpID0+IGUgPT4ge1xuICAgICAgc3RhdGUub24oc3RhdGUgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHN0YXRlLmludGVydmFsSWQuY2xlYXIoKTtcbiAgICAgICAgaWYgKHN0YXRlLmRyYWdnaW5nKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWREcm9wVGFyZ2V0KGVkaXRvciwgZ2V0UmF3VGFyZ2V0KGVkaXRvci5zZWxlY3Rpb24pLCBzdGF0ZS5lbGVtZW50KSkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0Q2xvbmUgPSBjbG9uZUVsZW1lbnQoc3RhdGUuZWxlbWVudCk7XG4gICAgICAgICAgICBjb25zdCBkcm9wVGFyZ2V0ID0gKF9hID0gZWRpdG9yLmdldERvYygpLmVsZW1lbnRGcm9tUG9pbnQoZS5jbGllbnRYLCBlLmNsaWVudFkpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBlZGl0b3IuZ2V0Qm9keSgpO1xuICAgICAgICAgICAgY29uc3QgYXJncyA9IGVkaXRvci5kaXNwYXRjaCgnZHJvcCcsIG1ha2VEcm9wRXZlbnRGcm9tTW91c2VFdmVudChlLCBkcm9wVGFyZ2V0KSk7XG4gICAgICAgICAgICBpZiAoIWFyZ3MuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICAgICAgZWRpdG9yLnVuZG9NYW5hZ2VyLnRyYW5zYWN0KCgpID0+IHtcbiAgICAgICAgICAgICAgICByZW1vdmVFbGVtZW50V2l0aFBhZGRpbmcoZWRpdG9yLmRvbSwgc3RhdGUuZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgZWRpdG9yLmluc2VydENvbnRlbnQoZWRpdG9yLmRvbS5nZXRPdXRlckhUTUwodGFyZ2V0Q2xvbmUpKTtcbiAgICAgICAgICAgICAgICBlZGl0b3IuX3NlbGVjdGlvbk92ZXJyaWRlcy5oaWRlRmFrZUNhcmV0KCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlZGl0b3IuZGlzcGF0Y2goJ2RyYWdlbmQnLCBtYWtlRHJhZ2VuZEV2ZW50RnJvbU1vdXNlRXZlbnQoZSwgZWRpdG9yLmdldEJvZHkoKSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJlbW92ZURyYWdTdGF0ZShzdGF0ZSk7XG4gICAgfTtcbiAgICBjb25zdCBzdG9wRHJhZ2dpbmcgPSAoc3RhdGUsIGVkaXRvciwgZSkgPT4ge1xuICAgICAgc3RhdGUub24oc3RhdGUgPT4ge1xuICAgICAgICBzdGF0ZS5pbnRlcnZhbElkLmNsZWFyKCk7XG4gICAgICAgIGlmIChzdGF0ZS5kcmFnZ2luZykge1xuICAgICAgICAgIGNvbnN0IGV2ZW50ID0gZS5mb2xkKCgpID0+IG1ha2VEcmFnZW5kRXZlbnQoc3RhdGUuZWxlbWVudCksIG1vdXNlRXZlbnQgPT4gbWFrZURyYWdlbmRFdmVudEZyb21Nb3VzZUV2ZW50KG1vdXNlRXZlbnQsIHN0YXRlLmVsZW1lbnQpKTtcbiAgICAgICAgICBlZGl0b3IuZGlzcGF0Y2goJ2RyYWdlbmQnLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmVtb3ZlRHJhZ1N0YXRlKHN0YXRlKTtcbiAgICB9O1xuICAgIGNvbnN0IHN0b3AgPSAoc3RhdGUsIGVkaXRvcikgPT4gZSA9PiBzdG9wRHJhZ2dpbmcoc3RhdGUsIGVkaXRvciwgT3B0aW9uYWwuc29tZShlKSk7XG4gICAgY29uc3QgcmVtb3ZlRHJhZ1N0YXRlID0gc3RhdGUgPT4ge1xuICAgICAgc3RhdGUub24oc3RhdGUgPT4ge1xuICAgICAgICBzdGF0ZS5pbnRlcnZhbElkLmNsZWFyKCk7XG4gICAgICAgIHJlbW92ZUVsZW1lbnQoc3RhdGUuZ2hvc3QpO1xuICAgICAgfSk7XG4gICAgICBzdGF0ZS5jbGVhcigpO1xuICAgIH07XG4gICAgY29uc3QgYmluZEZha2VEcmFnRXZlbnRzID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdmFsdWUkMigpO1xuICAgICAgY29uc3QgcGFnZURvbSA9IERPTVV0aWxzLkRPTTtcbiAgICAgIGNvbnN0IHJvb3REb2N1bWVudCA9IGRvY3VtZW50O1xuICAgICAgY29uc3QgZHJhZ1N0YXJ0SGFuZGxlciA9IHN0YXJ0KHN0YXRlLCBlZGl0b3IpO1xuICAgICAgY29uc3QgZHJhZ0hhbmRsZXIgPSBtb3ZlKHN0YXRlLCBlZGl0b3IpO1xuICAgICAgY29uc3QgZHJvcEhhbmRsZXIgPSBkcm9wKHN0YXRlLCBlZGl0b3IpO1xuICAgICAgY29uc3QgZHJhZ0VuZEhhbmRsZXIgPSBzdG9wKHN0YXRlLCBlZGl0b3IpO1xuICAgICAgZWRpdG9yLm9uKCdtb3VzZWRvd24nLCBkcmFnU3RhcnRIYW5kbGVyKTtcbiAgICAgIGVkaXRvci5vbignbW91c2Vtb3ZlJywgZHJhZ0hhbmRsZXIpO1xuICAgICAgZWRpdG9yLm9uKCdtb3VzZXVwJywgZHJvcEhhbmRsZXIpO1xuICAgICAgcGFnZURvbS5iaW5kKHJvb3REb2N1bWVudCwgJ21vdXNlbW92ZScsIGRyYWdIYW5kbGVyKTtcbiAgICAgIHBhZ2VEb20uYmluZChyb290RG9jdW1lbnQsICdtb3VzZXVwJywgZHJhZ0VuZEhhbmRsZXIpO1xuICAgICAgZWRpdG9yLm9uKCdyZW1vdmUnLCAoKSA9PiB7XG4gICAgICAgIHBhZ2VEb20udW5iaW5kKHJvb3REb2N1bWVudCwgJ21vdXNlbW92ZScsIGRyYWdIYW5kbGVyKTtcbiAgICAgICAgcGFnZURvbS51bmJpbmQocm9vdERvY3VtZW50LCAnbW91c2V1cCcsIGRyYWdFbmRIYW5kbGVyKTtcbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm9uKCdrZXlkb3duJywgZSA9PiB7XG4gICAgICAgIGlmIChlLmtleUNvZGUgPT09IFZLLkVTQykge1xuICAgICAgICAgIHN0b3BEcmFnZ2luZyhzdGF0ZSwgZWRpdG9yLCBPcHRpb25hbC5ub25lKCkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGJsb2NrVW5zdXBwb3J0ZWRGaWxlRHJvcCA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBwcmV2ZW50RmlsZURyb3AgPSBlID0+IHtcbiAgICAgICAgaWYgKCFlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgY29uc3QgZGF0YVRyYW5zZmVyID0gZS5kYXRhVHJhbnNmZXI7XG4gICAgICAgICAgaWYgKGRhdGFUcmFuc2ZlciAmJiAoY29udGFpbnMkMihkYXRhVHJhbnNmZXIudHlwZXMsICdGaWxlcycpIHx8IGRhdGFUcmFuc2Zlci5maWxlcy5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gJ2Ryb3AnKSB7XG4gICAgICAgICAgICAgIGRpc3BsYXlFcnJvcihlZGl0b3IsICdEcm9wcGVkIGZpbGUgdHlwZSBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgcHJldmVudEZpbGVEcm9wSWZVSUVsZW1lbnQgPSBlID0+IHtcbiAgICAgICAgaWYgKGlzVUlFbGVtZW50KGVkaXRvciwgZS50YXJnZXQpKSB7XG4gICAgICAgICAgcHJldmVudEZpbGVEcm9wKGUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2V0dXAgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhZ2VEb20gPSBET01VdGlscy5ET007XG4gICAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb207XG4gICAgICAgIGNvbnN0IGRvYyA9IGRvY3VtZW50O1xuICAgICAgICBjb25zdCBlZGl0b3JSb290ID0gZWRpdG9yLmlubGluZSA/IGVkaXRvci5nZXRCb2R5KCkgOiBlZGl0b3IuZ2V0RG9jKCk7XG4gICAgICAgIGNvbnN0IGV2ZW50TmFtZXMgPSBbXG4gICAgICAgICAgJ2Ryb3AnLFxuICAgICAgICAgICdkcmFnb3ZlcidcbiAgICAgICAgXTtcbiAgICAgICAgZWFjaCRlKGV2ZW50TmFtZXMsIG5hbWUgPT4ge1xuICAgICAgICAgIHBhZ2VEb20uYmluZChkb2MsIG5hbWUsIHByZXZlbnRGaWxlRHJvcElmVUlFbGVtZW50KTtcbiAgICAgICAgICBkb20uYmluZChlZGl0b3JSb290LCBuYW1lLCBwcmV2ZW50RmlsZURyb3ApO1xuICAgICAgICB9KTtcbiAgICAgICAgZWRpdG9yLm9uKCdyZW1vdmUnLCAoKSA9PiB7XG4gICAgICAgICAgZWFjaCRlKGV2ZW50TmFtZXMsIG5hbWUgPT4ge1xuICAgICAgICAgICAgcGFnZURvbS51bmJpbmQoZG9jLCBuYW1lLCBwcmV2ZW50RmlsZURyb3BJZlVJRWxlbWVudCk7XG4gICAgICAgICAgICBkb20udW5iaW5kKGVkaXRvclJvb3QsIG5hbWUsIHByZXZlbnRGaWxlRHJvcCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGVkaXRvci5vbignaW5pdCcsICgpID0+IHtcbiAgICAgICAgRGVsYXkuc2V0RWRpdG9yVGltZW91dChlZGl0b3IsIHNldHVwLCAwKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgaW5pdCQyID0gZWRpdG9yID0+IHtcbiAgICAgIGJpbmRGYWtlRHJhZ0V2ZW50cyhlZGl0b3IpO1xuICAgICAgaWYgKHNob3VsZEJsb2NrVW5zdXBwb3J0ZWREcm9wKGVkaXRvcikpIHtcbiAgICAgICAgYmxvY2tVbnN1cHBvcnRlZEZpbGVEcm9wKGVkaXRvcik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHNldHVwJDQgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgcmVuZGVyRm9jdXNDYXJldCA9IGZpcnN0JDEoKCkgPT4ge1xuICAgICAgICBpZiAoIWVkaXRvci5yZW1vdmVkICYmIGVkaXRvci5nZXRCb2R5KCkuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgICBjb25zdCBybmcgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgICAgIGlmIChybmcuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICBjb25zdCBjYXJldFJhbmdlID0gcmVuZGVyUmFuZ2VDYXJldChlZGl0b3IsIHJuZywgZmFsc2UpO1xuICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRSbmcoY2FyZXRSYW5nZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCAwKTtcbiAgICAgIGVkaXRvci5vbignZm9jdXMnLCAoKSA9PiB7XG4gICAgICAgIHJlbmRlckZvY3VzQ2FyZXQudGhyb3R0bGUoKTtcbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm9uKCdibHVyJywgKCkgPT4ge1xuICAgICAgICByZW5kZXJGb2N1c0NhcmV0LmNhbmNlbCgpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHNldHVwJDMgPSBlZGl0b3IgPT4ge1xuICAgICAgZWRpdG9yLm9uKCdpbml0JywgKCkgPT4ge1xuICAgICAgICBlZGl0b3Iub24oJ2ZvY3VzaW4nLCBlID0+IHtcbiAgICAgICAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgICBpZiAoaXNNZWRpYSQyKHRhcmdldCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNlUm9vdCA9IGdldENvbnRlbnRFZGl0YWJsZVJvb3QkMShlZGl0b3IuZ2V0Qm9keSgpLCB0YXJnZXQpO1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGlzQ29udGVudEVkaXRhYmxlRmFsc2UkYihjZVJvb3QpID8gY2VSb290IDogdGFyZ2V0O1xuICAgICAgICAgICAgaWYgKGVkaXRvci5zZWxlY3Rpb24uZ2V0Tm9kZSgpICE9PSBub2RlKSB7XG4gICAgICAgICAgICAgIHNlbGVjdE5vZGUoZWRpdG9yLCBub2RlKS5lYWNoKHJuZyA9PiBlZGl0b3Iuc2VsZWN0aW9uLnNldFJuZyhybmcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGlzQ29udGVudEVkaXRhYmxlRmFsc2UgPSBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJGI7XG4gICAgY29uc3QgZ2V0Q29udGVudEVkaXRhYmxlUm9vdCA9IChlZGl0b3IsIG5vZGUpID0+IGdldENvbnRlbnRFZGl0YWJsZVJvb3QkMShlZGl0b3IuZ2V0Qm9keSgpLCBub2RlKTtcbiAgICBjb25zdCBTZWxlY3Rpb25PdmVycmlkZXMgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbiwgZG9tID0gZWRpdG9yLmRvbTtcbiAgICAgIGNvbnN0IHJvb3ROb2RlID0gZWRpdG9yLmdldEJvZHkoKTtcbiAgICAgIGNvbnN0IGZha2VDYXJldCA9IEZha2VDYXJldChlZGl0b3IsIHJvb3ROb2RlLCBkb20uaXNCbG9jaywgKCkgPT4gaGFzRm9jdXMoZWRpdG9yKSk7XG4gICAgICBjb25zdCByZWFsU2VsZWN0aW9uSWQgPSAnc2VsLScgKyBkb20udW5pcXVlSWQoKTtcbiAgICAgIGNvbnN0IGVsZW1lbnRTZWxlY3Rpb25BdHRyID0gJ2RhdGEtbWNlLXNlbGVjdGVkJztcbiAgICAgIGxldCBzZWxlY3RlZEVsZW1lbnQ7XG4gICAgICBjb25zdCBpc0Zha2VTZWxlY3Rpb25FbGVtZW50ID0gbm9kZSA9PiBpc05vbk51bGxhYmxlKG5vZGUpICYmIGRvbS5oYXNDbGFzcyhub2RlLCAnbWNlLW9mZnNjcmVlbi1zZWxlY3Rpb24nKTtcbiAgICAgIGNvbnN0IGlzRmFrZVNlbGVjdGlvblRhcmdldEVsZW1lbnQgPSBub2RlID0+IG5vZGUgIT09IHJvb3ROb2RlICYmIChpc0NvbnRlbnRFZGl0YWJsZUZhbHNlKG5vZGUpIHx8IGlzTWVkaWEkMihub2RlKSkgJiYgZG9tLmlzQ2hpbGRPZihub2RlLCByb290Tm9kZSkgJiYgZG9tLmlzRWRpdGFibGUobm9kZS5wYXJlbnROb2RlKTtcbiAgICAgIGNvbnN0IHNldFJhbmdlID0gcmFuZ2UgPT4ge1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICBzZWxlY3Rpb24uc2V0Um5nKHJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNob3dDYXJldCA9IChkaXJlY3Rpb24sIG5vZGUsIGJlZm9yZSwgc2Nyb2xsSW50b1ZpZXcgPSB0cnVlKSA9PiB7XG4gICAgICAgIGNvbnN0IGUgPSBlZGl0b3IuZGlzcGF0Y2goJ1Nob3dDYXJldCcsIHtcbiAgICAgICAgICB0YXJnZXQ6IG5vZGUsXG4gICAgICAgICAgZGlyZWN0aW9uLFxuICAgICAgICAgIGJlZm9yZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Nyb2xsSW50b1ZpZXcpIHtcbiAgICAgICAgICBzZWxlY3Rpb24uc2Nyb2xsSW50b1ZpZXcobm9kZSwgZGlyZWN0aW9uID09PSAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZha2VDYXJldC5zaG93KGJlZm9yZSwgbm9kZSk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2hvd0Jsb2NrQ2FyZXRDb250YWluZXIgPSBibG9ja0NhcmV0Q29udGFpbmVyID0+IHtcbiAgICAgICAgaWYgKGJsb2NrQ2FyZXRDb250YWluZXIuaGFzQXR0cmlidXRlKCdkYXRhLW1jZS1jYXJldCcpKSB7XG4gICAgICAgICAgc2hvd0NhcmV0Q29udGFpbmVyQmxvY2soYmxvY2tDYXJldENvbnRhaW5lcik7XG4gICAgICAgICAgc2VsZWN0aW9uLnNjcm9sbEludG9WaWV3KGJsb2NrQ2FyZXRDb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgcmVnaXN0ZXJFdmVudHMgPSAoKSA9PiB7XG4gICAgICAgIGVkaXRvci5vbignY2xpY2snLCBlID0+IHtcbiAgICAgICAgICBpZiAoIWRvbS5pc0VkaXRhYmxlKGUudGFyZ2V0KSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZWRpdG9yLmZvY3VzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZWRpdG9yLm9uKCdibHVyIE5ld0Jsb2NrJywgcmVtb3ZlRWxlbWVudFNlbGVjdGlvbik7XG4gICAgICAgIGVkaXRvci5vbignUmVzaXplV2luZG93IEZ1bGxzY3JlZW5TdGF0ZUNoYW5nZWQnLCBmYWtlQ2FyZXQucmVwb3NpdGlvbik7XG4gICAgICAgIGVkaXRvci5vbigndGFwJywgZSA9PiB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0RWxtID0gZS50YXJnZXQ7XG4gICAgICAgICAgY29uc3QgY29udGVudEVkaXRhYmxlUm9vdCA9IGdldENvbnRlbnRFZGl0YWJsZVJvb3QoZWRpdG9yLCB0YXJnZXRFbG0pO1xuICAgICAgICAgIGlmIChpc0NvbnRlbnRFZGl0YWJsZUZhbHNlKGNvbnRlbnRFZGl0YWJsZVJvb3QpKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBzZWxlY3ROb2RlKGVkaXRvciwgY29udGVudEVkaXRhYmxlUm9vdCkuZWFjaChzZXRFbGVtZW50U2VsZWN0aW9uKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzRmFrZVNlbGVjdGlvblRhcmdldEVsZW1lbnQodGFyZ2V0RWxtKSkge1xuICAgICAgICAgICAgc2VsZWN0Tm9kZShlZGl0b3IsIHRhcmdldEVsbSkuZWFjaChzZXRFbGVtZW50U2VsZWN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgICBlZGl0b3Iub24oJ21vdXNlZG93bicsIGUgPT4ge1xuICAgICAgICAgIGNvbnN0IHRhcmdldEVsbSA9IGUudGFyZ2V0O1xuICAgICAgICAgIGlmICh0YXJnZXRFbG0gIT09IHJvb3ROb2RlICYmIHRhcmdldEVsbS5ub2RlTmFtZSAhPT0gJ0hUTUwnICYmICFkb20uaXNDaGlsZE9mKHRhcmdldEVsbSwgcm9vdE5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXNYWUluQ29udGVudEFyZWEoZWRpdG9yLCBlLmNsaWVudFgsIGUuY2xpZW50WSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVtb3ZlRWxlbWVudFNlbGVjdGlvbigpO1xuICAgICAgICAgIGhpZGVGYWtlQ2FyZXQoKTtcbiAgICAgICAgICBjb25zdCBjbG9zZXN0Q29udGVudEVkaXRhYmxlID0gZ2V0Q29udGVudEVkaXRhYmxlUm9vdChlZGl0b3IsIHRhcmdldEVsbSk7XG4gICAgICAgICAgaWYgKGlzQ29udGVudEVkaXRhYmxlRmFsc2UoY2xvc2VzdENvbnRlbnRFZGl0YWJsZSkpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHNlbGVjdE5vZGUoZWRpdG9yLCBjbG9zZXN0Q29udGVudEVkaXRhYmxlKS5lYWNoKHNldEVsZW1lbnRTZWxlY3Rpb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbG9zZXN0RmFrZUNhcmV0Q2FuZGlkYXRlKHJvb3ROb2RlLCBlLmNsaWVudFgsIGUuY2xpZW50WSkuZWFjaChjYXJldEluZm8gPT4ge1xuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gc2hvd0NhcmV0KDEsIGNhcmV0SW5mby5ub2RlLCBjYXJldEluZm8ucG9zaXRpb24gPT09IEZha2VDYXJldFBvc2l0aW9uLkJlZm9yZSwgZmFsc2UpO1xuICAgICAgICAgICAgICBzZXRSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgIGlmIChpc0VsZW1lbnQkNihjbG9zZXN0Q29udGVudEVkaXRhYmxlKSkge1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RDb250ZW50RWRpdGFibGUuZm9jdXMoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlZGl0b3IuZ2V0Qm9keSgpLmZvY3VzKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGVkaXRvci5vbigna2V5cHJlc3MnLCBlID0+IHtcbiAgICAgICAgICBpZiAoVksubW9kaWZpZXJQcmVzc2VkKGUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0NvbnRlbnRFZGl0YWJsZUZhbHNlKHNlbGVjdGlvbi5nZXROb2RlKCkpKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZWRpdG9yLm9uKCdHZXRTZWxlY3Rpb25SYW5nZScsIGUgPT4ge1xuICAgICAgICAgIGxldCBybmcgPSBlLnJhbmdlO1xuICAgICAgICAgIGlmIChzZWxlY3RlZEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmICghc2VsZWN0ZWRFbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgc2VsZWN0ZWRFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm5nID0gcm5nLmNsb25lUmFuZ2UoKTtcbiAgICAgICAgICAgIHJuZy5zZWxlY3ROb2RlKHNlbGVjdGVkRWxlbWVudCk7XG4gICAgICAgICAgICBlLnJhbmdlID0gcm5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGVkaXRvci5vbignU2V0U2VsZWN0aW9uUmFuZ2UnLCBlID0+IHtcbiAgICAgICAgICBlLnJhbmdlID0gbm9ybWFsaXplVm9pZEVsZW1lbnRTZWxlY3Rpb24oZS5yYW5nZSk7XG4gICAgICAgICAgY29uc3Qgcm5nID0gc2V0RWxlbWVudFNlbGVjdGlvbihlLnJhbmdlLCBlLmZvcndhcmQpO1xuICAgICAgICAgIGlmIChybmcpIHtcbiAgICAgICAgICAgIGUucmFuZ2UgPSBybmc7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaXNQYXN0ZUJpbiA9IG5vZGUgPT4gaXNFbGVtZW50JDYobm9kZSkgJiYgbm9kZS5pZCA9PT0gJ21jZXBhc3RlYmluJztcbiAgICAgICAgZWRpdG9yLm9uKCdBZnRlclNldFNlbGVjdGlvblJhbmdlJywgZSA9PiB7XG4gICAgICAgICAgY29uc3Qgcm5nID0gZS5yYW5nZTtcbiAgICAgICAgICBjb25zdCBwYXJlbnQgPSBybmcuc3RhcnRDb250YWluZXIucGFyZW50RWxlbWVudDtcbiAgICAgICAgICBpZiAoIWlzUmFuZ2VJbkNhcmV0Q29udGFpbmVyKHJuZykgJiYgIWlzUGFzdGVCaW4ocGFyZW50KSkge1xuICAgICAgICAgICAgaGlkZUZha2VDYXJldCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzRmFrZVNlbGVjdGlvbkVsZW1lbnQocGFyZW50KSkge1xuICAgICAgICAgICAgcmVtb3ZlRWxlbWVudFNlbGVjdGlvbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGluaXQkMihlZGl0b3IpO1xuICAgICAgICBzZXR1cCQ0KGVkaXRvcik7XG4gICAgICAgIHNldHVwJDMoZWRpdG9yKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBpc1dpdGhpbkNhcmV0Q29udGFpbmVyID0gbm9kZSA9PiBpc0NhcmV0Q29udGFpbmVyJDIobm9kZSkgfHwgc3RhcnRzV2l0aENhcmV0Q29udGFpbmVyJDEobm9kZSkgfHwgZW5kc1dpdGhDYXJldENvbnRhaW5lciQxKG5vZGUpO1xuICAgICAgY29uc3QgaXNSYW5nZUluQ2FyZXRDb250YWluZXIgPSBybmcgPT4gaXNXaXRoaW5DYXJldENvbnRhaW5lcihybmcuc3RhcnRDb250YWluZXIpIHx8IGlzV2l0aGluQ2FyZXRDb250YWluZXIocm5nLmVuZENvbnRhaW5lcik7XG4gICAgICBjb25zdCBub3JtYWxpemVWb2lkRWxlbWVudFNlbGVjdGlvbiA9IHJuZyA9PiB7XG4gICAgICAgIGNvbnN0IHZvaWRFbGVtZW50cyA9IGVkaXRvci5zY2hlbWEuZ2V0Vm9pZEVsZW1lbnRzKCk7XG4gICAgICAgIGNvbnN0IG5ld1JuZyA9IGRvbS5jcmVhdGVSbmcoKTtcbiAgICAgICAgY29uc3Qgc3RhcnRDb250YWluZXIgPSBybmcuc3RhcnRDb250YWluZXI7XG4gICAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gcm5nLnN0YXJ0T2Zmc2V0O1xuICAgICAgICBjb25zdCBlbmRDb250YWluZXIgPSBybmcuZW5kQ29udGFpbmVyO1xuICAgICAgICBjb25zdCBlbmRPZmZzZXQgPSBybmcuZW5kT2Zmc2V0O1xuICAgICAgICBpZiAoaGFzJDIodm9pZEVsZW1lbnRzLCBzdGFydENvbnRhaW5lci5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgIGlmIChzdGFydE9mZnNldCA9PT0gMCkge1xuICAgICAgICAgICAgbmV3Um5nLnNldFN0YXJ0QmVmb3JlKHN0YXJ0Q29udGFpbmVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3Um5nLnNldFN0YXJ0QWZ0ZXIoc3RhcnRDb250YWluZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdSbmcuc2V0U3RhcnQoc3RhcnRDb250YWluZXIsIHN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzJDIodm9pZEVsZW1lbnRzLCBlbmRDb250YWluZXIubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICBpZiAoZW5kT2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICBuZXdSbmcuc2V0RW5kQmVmb3JlKGVuZENvbnRhaW5lcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld1JuZy5zZXRFbmRBZnRlcihlbmRDb250YWluZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdSbmcuc2V0RW5kKGVuZENvbnRhaW5lciwgZW5kT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3Um5nO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHNldHVwT2Zmc2NyZWVuU2VsZWN0aW9uID0gKG5vZGUsIHRhcmdldENsb25lKSA9PiB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3IuZ2V0Qm9keSgpKTtcbiAgICAgICAgY29uc3QgZG9jID0gZWRpdG9yLmdldERvYygpO1xuICAgICAgICBjb25zdCByZWFsU2VsZWN0aW9uQ29udGFpbmVyID0gZGVzY2VuZGFudChib2R5LCAnIycgKyByZWFsU2VsZWN0aW9uSWQpLmdldE9yVGh1bmsoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IG5ld0NvbnRhaW5lciA9IFN1Z2FyRWxlbWVudC5mcm9tSHRtbCgnPGRpdiBkYXRhLW1jZS1ib2d1cz1cImFsbFwiIGNsYXNzPVwibWNlLW9mZnNjcmVlbi1zZWxlY3Rpb25cIj48L2Rpdj4nLCBkb2MpO1xuICAgICAgICAgIHNldCQzKG5ld0NvbnRhaW5lciwgJ2lkJywgcmVhbFNlbGVjdGlvbklkKTtcbiAgICAgICAgICBhcHBlbmQkMShib2R5LCBuZXdDb250YWluZXIpO1xuICAgICAgICAgIHJldHVybiBuZXdDb250YWluZXI7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBuZXdSYW5nZSA9IGRvbS5jcmVhdGVSbmcoKTtcbiAgICAgICAgZW1wdHkocmVhbFNlbGVjdGlvbkNvbnRhaW5lcik7XG4gICAgICAgIGFwcGVuZChyZWFsU2VsZWN0aW9uQ29udGFpbmVyLCBbXG4gICAgICAgICAgU3VnYXJFbGVtZW50LmZyb21UZXh0KG5ic3AsIGRvYyksXG4gICAgICAgICAgU3VnYXJFbGVtZW50LmZyb21Eb20odGFyZ2V0Q2xvbmUpLFxuICAgICAgICAgIFN1Z2FyRWxlbWVudC5mcm9tVGV4dChuYnNwLCBkb2MpXG4gICAgICAgIF0pO1xuICAgICAgICBuZXdSYW5nZS5zZXRTdGFydChyZWFsU2VsZWN0aW9uQ29udGFpbmVyLmRvbS5maXJzdENoaWxkLCAxKTtcbiAgICAgICAgbmV3UmFuZ2Uuc2V0RW5kKHJlYWxTZWxlY3Rpb25Db250YWluZXIuZG9tLmxhc3RDaGlsZCwgMCk7XG4gICAgICAgIHNldEFsbChyZWFsU2VsZWN0aW9uQ29udGFpbmVyLCB7IHRvcDogZG9tLmdldFBvcyhub2RlLCBlZGl0b3IuZ2V0Qm9keSgpKS55ICsgJ3B4JyB9KTtcbiAgICAgICAgZm9jdXMkMShyZWFsU2VsZWN0aW9uQ29udGFpbmVyKTtcbiAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0aW9uLmdldFNlbCgpO1xuICAgICAgICBpZiAoc2VsKSB7XG4gICAgICAgICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgIHNlbC5hZGRSYW5nZShuZXdSYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1JhbmdlO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHNlbGVjdEVsZW1lbnQgPSBlbG0gPT4ge1xuICAgICAgICBjb25zdCB0YXJnZXRDbG9uZSA9IGVsbS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgIGNvbnN0IGUgPSBlZGl0b3IuZGlzcGF0Y2goJ09iamVjdFNlbGVjdGVkJywge1xuICAgICAgICAgIHRhcmdldDogZWxtLFxuICAgICAgICAgIHRhcmdldENsb25lXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJhbmdlID0gc2V0dXBPZmZzY3JlZW5TZWxlY3Rpb24oZWxtLCBlLnRhcmdldENsb25lKTtcbiAgICAgICAgY29uc3Qgbm9kZUVsbSA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVsbSk7XG4gICAgICAgIGVhY2gkZShkZXNjZW5kYW50cyhTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3IuZ2V0Qm9keSgpKSwgYCpbJHsgZWxlbWVudFNlbGVjdGlvbkF0dHIgfV1gKSwgZWxtID0+IHtcbiAgICAgICAgICBpZiAoIWVxKG5vZGVFbG0sIGVsbSkpIHtcbiAgICAgICAgICAgIHJlbW92ZSRiKGVsbSwgZWxlbWVudFNlbGVjdGlvbkF0dHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghZG9tLmdldEF0dHJpYihlbG0sIGVsZW1lbnRTZWxlY3Rpb25BdHRyKSkge1xuICAgICAgICAgIGVsbS5zZXRBdHRyaWJ1dGUoZWxlbWVudFNlbGVjdGlvbkF0dHIsICcxJyk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZWN0ZWRFbGVtZW50ID0gZWxtO1xuICAgICAgICBoaWRlRmFrZUNhcmV0KCk7XG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgIH07XG4gICAgICBjb25zdCBzZXRFbGVtZW50U2VsZWN0aW9uID0gKHJhbmdlLCBmb3J3YXJkKSA9PiB7XG4gICAgICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmFuZ2UuY29sbGFwc2VkKSB7XG4gICAgICAgICAgaWYgKCFpc1JhbmdlSW5DYXJldENvbnRhaW5lcihyYW5nZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpciA9IGZvcndhcmQgPyAxIDogLTE7XG4gICAgICAgICAgICBjb25zdCBjYXJldFBvc2l0aW9uID0gZ2V0Tm9ybWFsaXplZFJhbmdlRW5kUG9pbnQoZGlyLCByb290Tm9kZSwgcmFuZ2UpO1xuICAgICAgICAgICAgY29uc3QgYmVmb3JlTm9kZSA9IGNhcmV0UG9zaXRpb24uZ2V0Tm9kZSghZm9yd2FyZCk7XG4gICAgICAgICAgICBpZiAoaXNOb25OdWxsYWJsZShiZWZvcmVOb2RlKSkge1xuICAgICAgICAgICAgICBpZiAoaXNGYWtlQ2FyZXRUYXJnZXQoYmVmb3JlTm9kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2hvd0NhcmV0KGRpciwgYmVmb3JlTm9kZSwgZm9yd2FyZCA/ICFjYXJldFBvc2l0aW9uLmlzQXRFbmQoKSA6IGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGlzQ2FyZXRDb250YWluZXJJbmxpbmUoYmVmb3JlTm9kZSkgJiYgaXNDb250ZW50RWRpdGFibGVGYWxzZSRiKGJlZm9yZU5vZGUubmV4dFNpYmxpbmcpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm5nID0gZG9tLmNyZWF0ZVJuZygpO1xuICAgICAgICAgICAgICAgIHJuZy5zZXRTdGFydChiZWZvcmVOb2RlLCAwKTtcbiAgICAgICAgICAgICAgICBybmcuc2V0RW5kKGJlZm9yZU5vZGUsIDApO1xuICAgICAgICAgICAgICAgIHJldHVybiBybmc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFmdGVyTm9kZSA9IGNhcmV0UG9zaXRpb24uZ2V0Tm9kZShmb3J3YXJkKTtcbiAgICAgICAgICAgIGlmIChpc05vbk51bGxhYmxlKGFmdGVyTm9kZSkpIHtcbiAgICAgICAgICAgICAgaWYgKGlzRmFrZUNhcmV0VGFyZ2V0KGFmdGVyTm9kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2hvd0NhcmV0KGRpciwgYWZ0ZXJOb2RlLCBmb3J3YXJkID8gZmFsc2UgOiAhY2FyZXRQb3NpdGlvbi5pc0F0RW5kKCksIGZhbHNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXNDYXJldENvbnRhaW5lcklubGluZShhZnRlck5vZGUpICYmIGlzQ29udGVudEVkaXRhYmxlRmFsc2UkYihhZnRlck5vZGUucHJldmlvdXNTaWJsaW5nKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJuZyA9IGRvbS5jcmVhdGVSbmcoKTtcbiAgICAgICAgICAgICAgICBybmcuc2V0U3RhcnQoYWZ0ZXJOb2RlLCAxKTtcbiAgICAgICAgICAgICAgICBybmcuc2V0RW5kKGFmdGVyTm9kZSwgMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJuZztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnRDb250YWluZXIgPSByYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICAgICAgbGV0IHN0YXJ0T2Zmc2V0ID0gcmFuZ2Uuc3RhcnRPZmZzZXQ7XG4gICAgICAgIGNvbnN0IGVuZE9mZnNldCA9IHJhbmdlLmVuZE9mZnNldDtcbiAgICAgICAgaWYgKGlzVGV4dCRhKHN0YXJ0Q29udGFpbmVyKSAmJiBzdGFydE9mZnNldCA9PT0gMCAmJiBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlKHN0YXJ0Q29udGFpbmVyLnBhcmVudE5vZGUpKSB7XG4gICAgICAgICAgc3RhcnRDb250YWluZXIgPSBzdGFydENvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgICAgICAgIHN0YXJ0T2Zmc2V0ID0gZG9tLm5vZGVJbmRleChzdGFydENvbnRhaW5lcik7XG4gICAgICAgICAgc3RhcnRDb250YWluZXIgPSBzdGFydENvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNFbGVtZW50JDYoc3RhcnRDb250YWluZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZE9mZnNldCA9PT0gc3RhcnRPZmZzZXQgKyAxICYmIHN0YXJ0Q29udGFpbmVyID09PSByYW5nZS5lbmRDb250YWluZXIpIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gc3RhcnRDb250YWluZXIuY2hpbGROb2Rlc1tzdGFydE9mZnNldF07XG4gICAgICAgICAgaWYgKGlzRmFrZVNlbGVjdGlvblRhcmdldEVsZW1lbnQobm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3RFbGVtZW50KG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBjb25zdCByZW1vdmVFbGVtZW50U2VsZWN0aW9uID0gKCkgPT4ge1xuICAgICAgICBpZiAoc2VsZWN0ZWRFbGVtZW50KSB7XG4gICAgICAgICAgc2VsZWN0ZWRFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShlbGVtZW50U2VsZWN0aW9uQXR0cik7XG4gICAgICAgIH1cbiAgICAgICAgZGVzY2VuZGFudChTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3IuZ2V0Qm9keSgpKSwgJyMnICsgcmVhbFNlbGVjdGlvbklkKS5lYWNoKHJlbW92ZSQ2KTtcbiAgICAgICAgc2VsZWN0ZWRFbGVtZW50ID0gbnVsbDtcbiAgICAgIH07XG4gICAgICBjb25zdCBkZXN0cm95ID0gKCkgPT4ge1xuICAgICAgICBmYWtlQ2FyZXQuZGVzdHJveSgpO1xuICAgICAgICBzZWxlY3RlZEVsZW1lbnQgPSBudWxsO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGhpZGVGYWtlQ2FyZXQgPSAoKSA9PiB7XG4gICAgICAgIGZha2VDYXJldC5oaWRlKCk7XG4gICAgICB9O1xuICAgICAgaWYgKCFpc1J0YyhlZGl0b3IpKSB7XG4gICAgICAgIHJlZ2lzdGVyRXZlbnRzKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzaG93Q2FyZXQsXG4gICAgICAgIHNob3dCbG9ja0NhcmV0Q29udGFpbmVyLFxuICAgICAgICBoaWRlRmFrZUNhcmV0LFxuICAgICAgICBkZXN0cm95XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBnZXROb3JtYWxpemVkVGV4dE9mZnNldCA9IChjb250YWluZXIsIG9mZnNldCkgPT4ge1xuICAgICAgbGV0IG5vcm1hbGl6ZWRPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICBmb3IgKGxldCBub2RlID0gY29udGFpbmVyLnByZXZpb3VzU2libGluZzsgaXNUZXh0JGEobm9kZSk7IG5vZGUgPSBub2RlLnByZXZpb3VzU2libGluZykge1xuICAgICAgICBub3JtYWxpemVkT2Zmc2V0ICs9IG5vZGUuZGF0YS5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9ybWFsaXplZE9mZnNldDtcbiAgICB9O1xuICAgIGNvbnN0IGdlbmVyYXRlUGF0aCA9IChkb20sIHJvb3QsIG5vZGUsIG9mZnNldCwgbm9ybWFsaXplZCkgPT4ge1xuICAgICAgaWYgKGlzVGV4dCRhKG5vZGUpICYmIChvZmZzZXQgPCAwIHx8IG9mZnNldCA+IG5vZGUuZGF0YS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHAgPSBub3JtYWxpemVkICYmIGlzVGV4dCRhKG5vZGUpID8gW2dldE5vcm1hbGl6ZWRUZXh0T2Zmc2V0KG5vZGUsIG9mZnNldCldIDogW29mZnNldF07XG4gICAgICBsZXQgY3VycmVudCA9IG5vZGU7XG4gICAgICB3aGlsZSAoY3VycmVudCAhPT0gcm9vdCAmJiBjdXJyZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgcC5wdXNoKGRvbS5ub2RlSW5kZXgoY3VycmVudCwgbm9ybWFsaXplZCkpO1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGN1cnJlbnQgPT09IHJvb3QgPyBwLnJldmVyc2UoKSA6IFtdO1xuICAgIH07XG4gICAgY29uc3QgZ2VuZXJhdGVQYXRoUmFuZ2UgPSAoZG9tLCByb290LCBzdGFydE5vZGUsIHN0YXJ0T2Zmc2V0LCBlbmROb2RlLCBlbmRPZmZzZXQsIG5vcm1hbGl6ZWQgPSBmYWxzZSkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnQgPSBnZW5lcmF0ZVBhdGgoZG9tLCByb290LCBzdGFydE5vZGUsIHN0YXJ0T2Zmc2V0LCBub3JtYWxpemVkKTtcbiAgICAgIGNvbnN0IGVuZCA9IGdlbmVyYXRlUGF0aChkb20sIHJvb3QsIGVuZE5vZGUsIGVuZE9mZnNldCwgbm9ybWFsaXplZCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGFydCxcbiAgICAgICAgZW5kXG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgcmVzb2x2ZVBhdGggPSAocm9vdCwgcGF0aCkgPT4ge1xuICAgICAgY29uc3Qgbm9kZVBhdGggPSBwYXRoLnNsaWNlKCk7XG4gICAgICBjb25zdCBvZmZzZXQgPSBub2RlUGF0aC5wb3AoKTtcbiAgICAgIGlmICghaXNOdW1iZXIob2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWROb2RlID0gZm9sZGwobm9kZVBhdGgsIChvcHROb2RlLCBpbmRleCkgPT4gb3B0Tm9kZS5iaW5kKG5vZGUgPT4gT3B0aW9uYWwuZnJvbShub2RlLmNoaWxkTm9kZXNbaW5kZXhdKSksIE9wdGlvbmFsLnNvbWUocm9vdCkpO1xuICAgICAgICByZXR1cm4gcmVzb2x2ZWROb2RlLmJpbmQobm9kZSA9PiB7XG4gICAgICAgICAgaWYgKGlzVGV4dCRhKG5vZGUpICYmIChvZmZzZXQgPCAwIHx8IG9mZnNldCA+IG5vZGUuZGF0YS5sZW5ndGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZSh7XG4gICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgIG9mZnNldFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlc29sdmVQYXRoUmFuZ2UgPSAocm9vdCwgcmFuZ2UpID0+IHJlc29sdmVQYXRoKHJvb3QsIHJhbmdlLnN0YXJ0KS5iaW5kKCh7XG4gICAgICBub2RlOiBzdGFydE5vZGUsXG4gICAgICBvZmZzZXQ6IHN0YXJ0T2Zmc2V0XG4gICAgfSkgPT4gcmVzb2x2ZVBhdGgocm9vdCwgcmFuZ2UuZW5kKS5tYXAoKHtcbiAgICAgIG5vZGU6IGVuZE5vZGUsXG4gICAgICBvZmZzZXQ6IGVuZE9mZnNldFxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IHJuZyA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICBybmcuc2V0U3RhcnQoc3RhcnROb2RlLCBzdGFydE9mZnNldCk7XG4gICAgICBybmcuc2V0RW5kKGVuZE5vZGUsIGVuZE9mZnNldCk7XG4gICAgICByZXR1cm4gcm5nO1xuICAgIH0pKTtcbiAgICBjb25zdCBnZW5lcmF0ZVBhdGhSYW5nZUZyb21SYW5nZSA9IChkb20sIHJvb3QsIHJhbmdlLCBub3JtYWxpemVkID0gZmFsc2UpID0+IGdlbmVyYXRlUGF0aFJhbmdlKGRvbSwgcm9vdCwgcmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0LCByYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCwgbm9ybWFsaXplZCk7XG5cbiAgICBjb25zdCBjbGVhbkVtcHR5Tm9kZXMgPSAoZG9tLCBub2RlLCBpc1Jvb3QpID0+IHtcbiAgICAgIGlmIChub2RlICYmIGRvbS5pc0VtcHR5KG5vZGUpICYmICFpc1Jvb3Qobm9kZSkpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICBkb20ucmVtb3ZlKG5vZGUpO1xuICAgICAgICBjbGVhbkVtcHR5Tm9kZXMoZG9tLCBwYXJlbnQsIGlzUm9vdCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBkZWxldGVSbmcgPSAoZG9tLCBybmcsIGlzUm9vdCwgY2xlYW4gPSB0cnVlKSA9PiB7XG4gICAgICBjb25zdCBzdGFydFBhcmVudCA9IHJuZy5zdGFydENvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgICAgY29uc3QgZW5kUGFyZW50ID0gcm5nLmVuZENvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgICAgcm5nLmRlbGV0ZUNvbnRlbnRzKCk7XG4gICAgICBpZiAoY2xlYW4gJiYgIWlzUm9vdChybmcuc3RhcnRDb250YWluZXIpKSB7XG4gICAgICAgIGlmIChpc1RleHQkYShybmcuc3RhcnRDb250YWluZXIpICYmIHJuZy5zdGFydENvbnRhaW5lci5kYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGRvbS5yZW1vdmUocm5nLnN0YXJ0Q29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNUZXh0JGEocm5nLmVuZENvbnRhaW5lcikgJiYgcm5nLmVuZENvbnRhaW5lci5kYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGRvbS5yZW1vdmUocm5nLmVuZENvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgY2xlYW5FbXB0eU5vZGVzKGRvbSwgc3RhcnRQYXJlbnQsIGlzUm9vdCk7XG4gICAgICAgIGlmIChzdGFydFBhcmVudCAhPT0gZW5kUGFyZW50KSB7XG4gICAgICAgICAgY2xlYW5FbXB0eU5vZGVzKGRvbSwgZW5kUGFyZW50LCBpc1Jvb3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBnZXRQYXJlbnRCbG9jayA9IChlZGl0b3IsIHJuZykgPT4gT3B0aW9uYWwuZnJvbShlZGl0b3IuZG9tLmdldFBhcmVudChybmcuc3RhcnRDb250YWluZXIsIGVkaXRvci5kb20uaXNCbG9jaykpO1xuICAgIGNvbnN0IHJlc29sdmVGcm9tRHluYW1pY1BhdHRlcm5zID0gKHBhdHRlcm5TZXQsIGJsb2NrLCBiZWZvcmVUZXh0KSA9PiB7XG4gICAgICBjb25zdCBkeW5hbWljUGF0dGVybnMgPSBwYXR0ZXJuU2V0LmR5bmFtaWNQYXR0ZXJuc0xvb2t1cCh7XG4gICAgICAgIHRleHQ6IGJlZm9yZVRleHQsXG4gICAgICAgIGJsb2NrXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnBhdHRlcm5TZXQsXG4gICAgICAgIGJsb2NrUGF0dGVybnM6IGdldEJsb2NrUGF0dGVybnMoZHluYW1pY1BhdHRlcm5zKS5jb25jYXQocGF0dGVyblNldC5ibG9ja1BhdHRlcm5zKSxcbiAgICAgICAgaW5saW5lUGF0dGVybnM6IGdldElubGluZVBhdHRlcm5zKGR5bmFtaWNQYXR0ZXJucykuY29uY2F0KHBhdHRlcm5TZXQuaW5saW5lUGF0dGVybnMpXG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgZ2V0QmVmb3JlVGV4dCA9IChkb20sIGJsb2NrLCBub2RlLCBvZmZzZXQpID0+IHtcbiAgICAgIGNvbnN0IHJuZyA9IGRvbS5jcmVhdGVSbmcoKTtcbiAgICAgIHJuZy5zZXRTdGFydChibG9jaywgMCk7XG4gICAgICBybmcuc2V0RW5kKG5vZGUsIG9mZnNldCk7XG4gICAgICByZXR1cm4gcm5nLnRvU3RyaW5nKCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHN0YXJ0c1dpdGhTaW5nbGVTcGFjZSA9IHMgPT4gL15cXHNbXlxcc10vLnRlc3Qocyk7XG4gICAgY29uc3Qgc3RyaXBQYXR0ZXJuID0gKGRvbSwgYmxvY2ssIHBhdHRlcm4pID0+IHtcbiAgICAgIGNvbnN0IGZpcnN0VGV4dE5vZGUgPSB0ZXh0QWZ0ZXIoYmxvY2ssIDAsIGJsb2NrKTtcbiAgICAgIGZpcnN0VGV4dE5vZGUuZWFjaChzcG90ID0+IHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHNwb3QuY29udGFpbmVyO1xuICAgICAgICBzY2FuUmlnaHQobm9kZSwgcGF0dGVybi5zdGFydC5sZW5ndGgsIGJsb2NrKS5lYWNoKGVuZCA9PiB7XG4gICAgICAgICAgY29uc3Qgcm5nID0gZG9tLmNyZWF0ZVJuZygpO1xuICAgICAgICAgIHJuZy5zZXRTdGFydChub2RlLCAwKTtcbiAgICAgICAgICBybmcuc2V0RW5kKGVuZC5jb250YWluZXIsIGVuZC5vZmZzZXQpO1xuICAgICAgICAgIGRlbGV0ZVJuZyhkb20sIHJuZywgZSA9PiBlID09PSBibG9jayk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0ZXh0ID0gU3VnYXJFbGVtZW50LmZyb21Eb20obm9kZSk7XG4gICAgICAgIGNvbnN0IHRleHRDb250ZW50ID0gZ2V0JDModGV4dCk7XG4gICAgICAgIGlmIChzdGFydHNXaXRoU2luZ2xlU3BhY2UodGV4dENvbnRlbnQpKSB7XG4gICAgICAgICAgc2V0KHRleHQsIHRleHRDb250ZW50LnNsaWNlKDEpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBhcHBseVBhdHRlcm4kMSA9IChlZGl0b3IsIG1hdGNoKSA9PiB7XG4gICAgICBjb25zdCBkb20gPSBlZGl0b3IuZG9tO1xuICAgICAgY29uc3QgcGF0dGVybiA9IG1hdGNoLnBhdHRlcm47XG4gICAgICBjb25zdCBybmcgPSByZXNvbHZlUGF0aFJhbmdlKGRvbS5nZXRSb290KCksIG1hdGNoLnJhbmdlKS5nZXRPckRpZSgnVW5hYmxlIHRvIHJlc29sdmUgcGF0aCByYW5nZScpO1xuICAgICAgY29uc3QgaXNCbG9ja0Zvcm1hdE5hbWUgPSAobmFtZSwgZm9ybWF0dGVyKSA9PiB7XG4gICAgICAgIGNvbnN0IGZvcm1hdFNldCA9IGZvcm1hdHRlci5nZXQobmFtZSk7XG4gICAgICAgIHJldHVybiBpc0FycmF5JDEoZm9ybWF0U2V0KSAmJiBoZWFkKGZvcm1hdFNldCkuZXhpc3RzKGZvcm1hdCA9PiBoYXMkMihmb3JtYXQsICdibG9jaycpKTtcbiAgICAgIH07XG4gICAgICBnZXRQYXJlbnRCbG9jayhlZGl0b3IsIHJuZykuZWFjaChibG9jayA9PiB7XG4gICAgICAgIGlmIChwYXR0ZXJuLnR5cGUgPT09ICdibG9jay1mb3JtYXQnKSB7XG4gICAgICAgICAgaWYgKGlzQmxvY2tGb3JtYXROYW1lKHBhdHRlcm4uZm9ybWF0LCBlZGl0b3IuZm9ybWF0dGVyKSkge1xuICAgICAgICAgICAgZWRpdG9yLnVuZG9NYW5hZ2VyLnRyYW5zYWN0KCgpID0+IHtcbiAgICAgICAgICAgICAgc3RyaXBQYXR0ZXJuKGVkaXRvci5kb20sIGJsb2NrLCBwYXR0ZXJuKTtcbiAgICAgICAgICAgICAgZWRpdG9yLmZvcm1hdHRlci5hcHBseShwYXR0ZXJuLmZvcm1hdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocGF0dGVybi50eXBlID09PSAnYmxvY2stY29tbWFuZCcpIHtcbiAgICAgICAgICBlZGl0b3IudW5kb01hbmFnZXIudHJhbnNhY3QoKCkgPT4ge1xuICAgICAgICAgICAgc3RyaXBQYXR0ZXJuKGVkaXRvci5kb20sIGJsb2NrLCBwYXR0ZXJuKTtcbiAgICAgICAgICAgIGVkaXRvci5leGVjQ29tbWFuZChwYXR0ZXJuLmNtZCwgZmFsc2UsIHBhdHRlcm4udmFsdWUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgY29uc3Qgc29ydFBhdHRlcm5zJDEgPSBwYXR0ZXJucyA9PiBzb3J0KHBhdHRlcm5zLCAoYSwgYikgPT4gYi5zdGFydC5sZW5ndGggLSBhLnN0YXJ0Lmxlbmd0aCk7XG4gICAgY29uc3QgZmluZFBhdHRlcm4kMSA9IChwYXR0ZXJucywgdGV4dCkgPT4ge1xuICAgICAgY29uc3Qgc29ydGVkUGF0dGVybnMgPSBzb3J0UGF0dGVybnMkMShwYXR0ZXJucyk7XG4gICAgICBjb25zdCBudVRleHQgPSB0ZXh0LnJlcGxhY2UobmJzcCwgJyAnKTtcbiAgICAgIHJldHVybiBmaW5kJDIoc29ydGVkUGF0dGVybnMsIHBhdHRlcm4gPT4gdGV4dC5pbmRleE9mKHBhdHRlcm4uc3RhcnQpID09PSAwIHx8IG51VGV4dC5pbmRleE9mKHBhdHRlcm4uc3RhcnQpID09PSAwKTtcbiAgICB9O1xuICAgIGNvbnN0IGZpbmRQYXR0ZXJucyQxID0gKGVkaXRvciwgYmxvY2ssIHBhdHRlcm5TZXQsIG5vcm1hbGl6ZWRNYXRjaGVzKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBkb20gPSBlZGl0b3IuZG9tO1xuICAgICAgY29uc3QgZm9yY2VkUm9vdEJsb2NrID0gZ2V0Rm9yY2VkUm9vdEJsb2NrKGVkaXRvcik7XG4gICAgICBpZiAoIWRvbS5pcyhibG9jaywgZm9yY2VkUm9vdEJsb2NrKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBjb25zdCBibG9ja1RleHQgPSAoX2EgPSBibG9jay50ZXh0Q29udGVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJyc7XG4gICAgICByZXR1cm4gZmluZFBhdHRlcm4kMShwYXR0ZXJuU2V0LmJsb2NrUGF0dGVybnMsIGJsb2NrVGV4dCkubWFwKHBhdHRlcm4gPT4ge1xuICAgICAgICBpZiAoVG9vbHMudHJpbShibG9ja1RleHQpLmxlbmd0aCA9PT0gcGF0dGVybi5zdGFydC5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgICBwYXR0ZXJuLFxuICAgICAgICAgICAgcmFuZ2U6IGdlbmVyYXRlUGF0aFJhbmdlKGRvbSwgZG9tLmdldFJvb3QoKSwgYmxvY2ssIDAsIGJsb2NrLCAwLCBub3JtYWxpemVkTWF0Y2hlcylcbiAgICAgICAgICB9XTtcbiAgICAgIH0pLmdldE9yKFtdKTtcbiAgICB9O1xuICAgIGNvbnN0IGFwcGx5TWF0Y2hlcyQxID0gKGVkaXRvciwgbWF0Y2hlcykgPT4ge1xuICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJvb2ttYXJrID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRCb29rbWFyaygpO1xuICAgICAgZWFjaCRlKG1hdGNoZXMsIG1hdGNoID0+IGFwcGx5UGF0dGVybiQxKGVkaXRvciwgbWF0Y2gpKTtcbiAgICAgIGVkaXRvci5zZWxlY3Rpb24ubW92ZVRvQm9va21hcmsoYm9va21hcmspO1xuICAgIH07XG5cbiAgICBjb25zdCBuZXdNYXJrZXIgPSAoZG9tLCBpZCkgPT4gZG9tLmNyZWF0ZSgnc3BhbicsIHtcbiAgICAgICdkYXRhLW1jZS10eXBlJzogJ2Jvb2ttYXJrJyxcbiAgICAgIGlkXG4gICAgfSk7XG4gICAgY29uc3QgcmFuZ2VGcm9tTWFya2VyID0gKGRvbSwgbWFya2VyKSA9PiB7XG4gICAgICBjb25zdCBybmcgPSBkb20uY3JlYXRlUm5nKCk7XG4gICAgICBybmcuc2V0U3RhcnRBZnRlcihtYXJrZXIuc3RhcnQpO1xuICAgICAgcm5nLnNldEVuZEJlZm9yZShtYXJrZXIuZW5kKTtcbiAgICAgIHJldHVybiBybmc7XG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGVNYXJrZXIgPSAoZG9tLCBtYXJrZXJQcmVmaXgsIHBhdGhSYW5nZSkgPT4ge1xuICAgICAgY29uc3Qgcm5nID0gcmVzb2x2ZVBhdGhSYW5nZShkb20uZ2V0Um9vdCgpLCBwYXRoUmFuZ2UpLmdldE9yRGllKCdVbmFibGUgdG8gcmVzb2x2ZSBwYXRoIHJhbmdlJyk7XG4gICAgICBjb25zdCBzdGFydE5vZGUgPSBybmcuc3RhcnRDb250YWluZXI7XG4gICAgICBjb25zdCBlbmROb2RlID0gcm5nLmVuZENvbnRhaW5lcjtcbiAgICAgIGNvbnN0IHRleHRFbmQgPSBybmcuZW5kT2Zmc2V0ID09PSAwID8gZW5kTm9kZSA6IGVuZE5vZGUuc3BsaXRUZXh0KHJuZy5lbmRPZmZzZXQpO1xuICAgICAgY29uc3QgdGV4dFN0YXJ0ID0gcm5nLnN0YXJ0T2Zmc2V0ID09PSAwID8gc3RhcnROb2RlIDogc3RhcnROb2RlLnNwbGl0VGV4dChybmcuc3RhcnRPZmZzZXQpO1xuICAgICAgY29uc3Qgc3RhcnRQYXJlbnROb2RlID0gdGV4dFN0YXJ0LnBhcmVudE5vZGU7XG4gICAgICBjb25zdCBlbmRQYXJlbnROb2RlID0gdGV4dEVuZC5wYXJlbnROb2RlO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJlZml4OiBtYXJrZXJQcmVmaXgsXG4gICAgICAgIGVuZDogZW5kUGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3TWFya2VyKGRvbSwgbWFya2VyUHJlZml4ICsgJy1lbmQnKSwgdGV4dEVuZCksXG4gICAgICAgIHN0YXJ0OiBzdGFydFBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld01hcmtlcihkb20sIG1hcmtlclByZWZpeCArICctc3RhcnQnKSwgdGV4dFN0YXJ0KVxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZU1hcmtlciA9IChkb20sIG1hcmtlciwgaXNSb290KSA9PiB7XG4gICAgICBjbGVhbkVtcHR5Tm9kZXMoZG9tLCBkb20uZ2V0KG1hcmtlci5wcmVmaXggKyAnLWVuZCcpLCBpc1Jvb3QpO1xuICAgICAgY2xlYW5FbXB0eU5vZGVzKGRvbSwgZG9tLmdldChtYXJrZXIucHJlZml4ICsgJy1zdGFydCcpLCBpc1Jvb3QpO1xuICAgIH07XG5cbiAgICBjb25zdCBpc1JlcGxhY2VtZW50UGF0dGVybiA9IHBhdHRlcm4gPT4gcGF0dGVybi5zdGFydC5sZW5ndGggPT09IDA7XG4gICAgY29uc3QgbWF0Y2hlc1BhdHRlcm4gPSBwYXR0ZXJuQ29udGVudCA9PiAoZWxlbWVudCwgb2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCB0ZXh0ID0gZWxlbWVudC5kYXRhO1xuICAgICAgY29uc3Qgc2VhcmNoVGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIG9mZnNldCk7XG4gICAgICBjb25zdCBzdGFydEVuZEluZGV4ID0gc2VhcmNoVGV4dC5sYXN0SW5kZXhPZihwYXR0ZXJuQ29udGVudC5jaGFyQXQocGF0dGVybkNvbnRlbnQubGVuZ3RoIC0gMSkpO1xuICAgICAgY29uc3Qgc3RhcnRJbmRleCA9IHNlYXJjaFRleHQubGFzdEluZGV4T2YocGF0dGVybkNvbnRlbnQpO1xuICAgICAgaWYgKHN0YXJ0SW5kZXggIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBzdGFydEluZGV4ICsgcGF0dGVybkNvbnRlbnQubGVuZ3RoO1xuICAgICAgfSBlbHNlIGlmIChzdGFydEVuZEluZGV4ICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gc3RhcnRFbmRJbmRleCArIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBmaW5kUGF0dGVyblN0YXJ0RnJvbVNwb3QgPSAoZG9tLCBwYXR0ZXJuLCBibG9jaywgc3BvdCkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnRQYXR0ZXJuID0gcGF0dGVybi5zdGFydDtcbiAgICAgIGNvbnN0IHN0YXJ0U3BvdCA9IHJlcGVhdExlZnQoZG9tLCBzcG90LmNvbnRhaW5lciwgc3BvdC5vZmZzZXQsIG1hdGNoZXNQYXR0ZXJuKHN0YXJ0UGF0dGVybiksIGJsb2NrKTtcbiAgICAgIHJldHVybiBzdGFydFNwb3QuYmluZChzcG90ID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3Qgc3RhcnRQYXR0ZXJuSW5kZXggPSAoX2IgPSAoX2EgPSBibG9jay50ZXh0Q29udGVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluZGV4T2Yoc3RhcnRQYXR0ZXJuKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogLTE7XG4gICAgICAgIGNvbnN0IGlzQ29tcGxldGVNYXRjaCA9IHN0YXJ0UGF0dGVybkluZGV4ICE9PSAtMSAmJiBzcG90Lm9mZnNldCA+PSBzdGFydFBhdHRlcm5JbmRleCArIHN0YXJ0UGF0dGVybi5sZW5ndGg7XG4gICAgICAgIGlmIChpc0NvbXBsZXRlTWF0Y2gpIHtcbiAgICAgICAgICBjb25zdCBybmcgPSBkb20uY3JlYXRlUm5nKCk7XG4gICAgICAgICAgcm5nLnNldFN0YXJ0KHNwb3QuY29udGFpbmVyLCBzcG90Lm9mZnNldCAtIHN0YXJ0UGF0dGVybi5sZW5ndGgpO1xuICAgICAgICAgIHJuZy5zZXRFbmQoc3BvdC5jb250YWluZXIsIHNwb3Qub2Zmc2V0KTtcbiAgICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShybmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHNwb3Qub2Zmc2V0IC0gc3RhcnRQYXR0ZXJuLmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gc2NhbkxlZnQoc3BvdC5jb250YWluZXIsIG9mZnNldCwgYmxvY2spLm1hcChuZXh0U3BvdCA9PiB7XG4gICAgICAgICAgICBjb25zdCBybmcgPSBkb20uY3JlYXRlUm5nKCk7XG4gICAgICAgICAgICBybmcuc2V0U3RhcnQobmV4dFNwb3QuY29udGFpbmVyLCBuZXh0U3BvdC5vZmZzZXQpO1xuICAgICAgICAgICAgcm5nLnNldEVuZChzcG90LmNvbnRhaW5lciwgc3BvdC5vZmZzZXQpO1xuICAgICAgICAgICAgcmV0dXJuIHJuZztcbiAgICAgICAgICB9KS5maWx0ZXIocm5nID0+IHJuZy50b1N0cmluZygpID09PSBzdGFydFBhdHRlcm4pLm9yVGh1bmsoKCkgPT4gZmluZFBhdHRlcm5TdGFydEZyb21TcG90KGRvbSwgcGF0dGVybiwgYmxvY2ssIHBvaW50KHNwb3QuY29udGFpbmVyLCAwKSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGZpbmRQYXR0ZXJuU3RhcnQgPSAoZG9tLCBwYXR0ZXJuLCBub2RlLCBvZmZzZXQsIGJsb2NrLCByZXF1aXJlR2FwID0gZmFsc2UpID0+IHtcbiAgICAgIGlmIChwYXR0ZXJuLnN0YXJ0Lmxlbmd0aCA9PT0gMCAmJiAhcmVxdWlyZUdhcCkge1xuICAgICAgICBjb25zdCBybmcgPSBkb20uY3JlYXRlUm5nKCk7XG4gICAgICAgIHJuZy5zZXRTdGFydChub2RlLCBvZmZzZXQpO1xuICAgICAgICBybmcuc2V0RW5kKG5vZGUsIG9mZnNldCk7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKHJuZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGV4dEJlZm9yZShub2RlLCBvZmZzZXQsIGJsb2NrKS5iaW5kKHNwb3QgPT4ge1xuICAgICAgICBjb25zdCBzdGFydCA9IGZpbmRQYXR0ZXJuU3RhcnRGcm9tU3BvdChkb20sIHBhdHRlcm4sIGJsb2NrLCBzcG90KTtcbiAgICAgICAgcmV0dXJuIHN0YXJ0LmJpbmQoc3RhcnRSYW5nZSA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIGlmIChyZXF1aXJlR2FwKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnRSYW5nZS5lbmRDb250YWluZXIgPT09IHNwb3QuY29udGFpbmVyICYmIHN0YXJ0UmFuZ2UuZW5kT2Zmc2V0ID09PSBzcG90Lm9mZnNldCkge1xuICAgICAgICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzcG90Lm9mZnNldCA9PT0gMCAmJiAoKF9hID0gc3RhcnRSYW5nZS5lbmRDb250YWluZXIudGV4dENvbnRlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpID09PSBzdGFydFJhbmdlLmVuZE9mZnNldCkge1xuICAgICAgICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShzdGFydFJhbmdlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGZpbmRQYXR0ZXJuID0gKGVkaXRvciwgYmxvY2ssIGRldGFpbHMsIG5vcm1hbGl6ZWRNYXRjaGVzKSA9PiB7XG4gICAgICBjb25zdCBkb20gPSBlZGl0b3IuZG9tO1xuICAgICAgY29uc3Qgcm9vdCA9IGRvbS5nZXRSb290KCk7XG4gICAgICBjb25zdCBwYXR0ZXJuID0gZGV0YWlscy5wYXR0ZXJuO1xuICAgICAgY29uc3QgZW5kTm9kZSA9IGRldGFpbHMucG9zaXRpb24uY29udGFpbmVyO1xuICAgICAgY29uc3QgZW5kT2Zmc2V0ID0gZGV0YWlscy5wb3NpdGlvbi5vZmZzZXQ7XG4gICAgICByZXR1cm4gc2NhbkxlZnQoZW5kTm9kZSwgZW5kT2Zmc2V0IC0gZGV0YWlscy5wYXR0ZXJuLmVuZC5sZW5ndGgsIGJsb2NrKS5iaW5kKHNwb3QgPT4ge1xuICAgICAgICBjb25zdCBlbmRQYXRoUm5nID0gZ2VuZXJhdGVQYXRoUmFuZ2UoZG9tLCByb290LCBzcG90LmNvbnRhaW5lciwgc3BvdC5vZmZzZXQsIGVuZE5vZGUsIGVuZE9mZnNldCwgbm9ybWFsaXplZE1hdGNoZXMpO1xuICAgICAgICBpZiAoaXNSZXBsYWNlbWVudFBhdHRlcm4ocGF0dGVybikpIHtcbiAgICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZSh7XG4gICAgICAgICAgICBtYXRjaGVzOiBbe1xuICAgICAgICAgICAgICAgIHBhdHRlcm4sXG4gICAgICAgICAgICAgICAgc3RhcnRSbmc6IGVuZFBhdGhSbmcsXG4gICAgICAgICAgICAgICAgZW5kUm5nOiBlbmRQYXRoUm5nXG4gICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgcG9zaXRpb246IHNwb3RcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCByZXN1bHRzT3B0ID0gZmluZFBhdHRlcm5zUmVjKGVkaXRvciwgZGV0YWlscy5yZW1haW5pbmdQYXR0ZXJucywgc3BvdC5jb250YWluZXIsIHNwb3Qub2Zmc2V0LCBibG9jaywgbm9ybWFsaXplZE1hdGNoZXMpO1xuICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSByZXN1bHRzT3B0LmdldE9yKHtcbiAgICAgICAgICAgIG1hdGNoZXM6IFtdLFxuICAgICAgICAgICAgcG9zaXRpb246IHNwb3RcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBwb3MgPSByZXN1bHRzLnBvc2l0aW9uO1xuICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gZmluZFBhdHRlcm5TdGFydChkb20sIHBhdHRlcm4sIHBvcy5jb250YWluZXIsIHBvcy5vZmZzZXQsIGJsb2NrLCByZXN1bHRzT3B0LmlzTm9uZSgpKTtcbiAgICAgICAgICByZXR1cm4gc3RhcnQubWFwKHN0YXJ0Um5nID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0UGF0aFJuZyA9IGdlbmVyYXRlUGF0aFJhbmdlRnJvbVJhbmdlKGRvbSwgcm9vdCwgc3RhcnRSbmcsIG5vcm1hbGl6ZWRNYXRjaGVzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIG1hdGNoZXM6IHJlc3VsdHMubWF0Y2hlcy5jb25jYXQoW3tcbiAgICAgICAgICAgICAgICAgIHBhdHRlcm4sXG4gICAgICAgICAgICAgICAgICBzdGFydFJuZzogc3RhcnRQYXRoUm5nLFxuICAgICAgICAgICAgICAgICAgZW5kUm5nOiBlbmRQYXRoUm5nXG4gICAgICAgICAgICAgICAgfV0pLFxuICAgICAgICAgICAgICBwb3NpdGlvbjogcG9pbnQoc3RhcnRSbmcuc3RhcnRDb250YWluZXIsIHN0YXJ0Um5nLnN0YXJ0T2Zmc2V0KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBmaW5kUGF0dGVybnNSZWMgPSAoZWRpdG9yLCBwYXR0ZXJucywgbm9kZSwgb2Zmc2V0LCBibG9jaywgbm9ybWFsaXplZE1hdGNoZXMpID0+IHtcbiAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb207XG4gICAgICByZXR1cm4gdGV4dEJlZm9yZShub2RlLCBvZmZzZXQsIGRvbS5nZXRSb290KCkpLmJpbmQoZW5kU3BvdCA9PiB7XG4gICAgICAgIGNvbnN0IHRleHQgPSBnZXRCZWZvcmVUZXh0KGRvbSwgYmxvY2ssIG5vZGUsIG9mZnNldCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0dGVybnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gcGF0dGVybnNbaV07XG4gICAgICAgICAgaWYgKCFlbmRzV2l0aCh0ZXh0LCBwYXR0ZXJuLmVuZCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBwYXR0ZXJuc1dpdGhvdXRDdXJyZW50ID0gcGF0dGVybnMuc2xpY2UoKTtcbiAgICAgICAgICBwYXR0ZXJuc1dpdGhvdXRDdXJyZW50LnNwbGljZShpLCAxKTtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBmaW5kUGF0dGVybihlZGl0b3IsIGJsb2NrLCB7XG4gICAgICAgICAgICBwYXR0ZXJuLFxuICAgICAgICAgICAgcmVtYWluaW5nUGF0dGVybnM6IHBhdHRlcm5zV2l0aG91dEN1cnJlbnQsXG4gICAgICAgICAgICBwb3NpdGlvbjogZW5kU3BvdFxuICAgICAgICAgIH0sIG5vcm1hbGl6ZWRNYXRjaGVzKTtcbiAgICAgICAgICBpZiAocmVzdWx0LmlzTm9uZSgpICYmIG9mZnNldCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmaW5kUGF0dGVybnNSZWMoZWRpdG9yLCBwYXR0ZXJucywgbm9kZSwgb2Zmc2V0IC0gMSwgYmxvY2ssIG5vcm1hbGl6ZWRNYXRjaGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdC5pc1NvbWUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgYXBwbHlQYXR0ZXJuID0gKGVkaXRvciwgcGF0dGVybiwgcGF0dGVyblJhbmdlKSA9PiB7XG4gICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFJuZyhwYXR0ZXJuUmFuZ2UpO1xuICAgICAgaWYgKHBhdHRlcm4udHlwZSA9PT0gJ2lubGluZS1mb3JtYXQnKSB7XG4gICAgICAgIGVhY2gkZShwYXR0ZXJuLmZvcm1hdCwgZm9ybWF0ID0+IHtcbiAgICAgICAgICBlZGl0b3IuZm9ybWF0dGVyLmFwcGx5KGZvcm1hdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRpdG9yLmV4ZWNDb21tYW5kKHBhdHRlcm4uY21kLCBmYWxzZSwgcGF0dGVybi52YWx1ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBhcHBseVJlcGxhY2VtZW50UGF0dGVybiA9IChlZGl0b3IsIHBhdHRlcm4sIG1hcmtlciwgaXNSb290KSA9PiB7XG4gICAgICBjb25zdCBtYXJrZXJSYW5nZSA9IHJhbmdlRnJvbU1hcmtlcihlZGl0b3IuZG9tLCBtYXJrZXIpO1xuICAgICAgZGVsZXRlUm5nKGVkaXRvci5kb20sIG1hcmtlclJhbmdlLCBpc1Jvb3QpO1xuICAgICAgYXBwbHlQYXR0ZXJuKGVkaXRvciwgcGF0dGVybiwgbWFya2VyUmFuZ2UpO1xuICAgIH07XG4gICAgY29uc3QgYXBwbHlQYXR0ZXJuV2l0aENvbnRlbnQgPSAoZWRpdG9yLCBwYXR0ZXJuLCBzdGFydE1hcmtlciwgZW5kTWFya2VyLCBpc1Jvb3QpID0+IHtcbiAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb207XG4gICAgICBjb25zdCBtYXJrZXJFbmRSYW5nZSA9IHJhbmdlRnJvbU1hcmtlcihkb20sIGVuZE1hcmtlcik7XG4gICAgICBjb25zdCBtYXJrZXJTdGFydFJhbmdlID0gcmFuZ2VGcm9tTWFya2VyKGRvbSwgc3RhcnRNYXJrZXIpO1xuICAgICAgZGVsZXRlUm5nKGRvbSwgbWFya2VyU3RhcnRSYW5nZSwgaXNSb290KTtcbiAgICAgIGRlbGV0ZVJuZyhkb20sIG1hcmtlckVuZFJhbmdlLCBpc1Jvb3QpO1xuICAgICAgY29uc3QgcGF0dGVybk1hcmtlciA9IHtcbiAgICAgICAgcHJlZml4OiBzdGFydE1hcmtlci5wcmVmaXgsXG4gICAgICAgIHN0YXJ0OiBzdGFydE1hcmtlci5lbmQsXG4gICAgICAgIGVuZDogZW5kTWFya2VyLnN0YXJ0XG4gICAgICB9O1xuICAgICAgY29uc3QgcGF0dGVyblJhbmdlID0gcmFuZ2VGcm9tTWFya2VyKGRvbSwgcGF0dGVybk1hcmtlcik7XG4gICAgICBhcHBseVBhdHRlcm4oZWRpdG9yLCBwYXR0ZXJuLCBwYXR0ZXJuUmFuZ2UpO1xuICAgIH07XG4gICAgY29uc3QgYWRkTWFya2VycyA9IChkb20sIG1hdGNoZXMpID0+IHtcbiAgICAgIGNvbnN0IG1hcmtlclByZWZpeCA9IGdlbmVyYXRlJDEoJ21jZV90ZXh0cGF0dGVybicpO1xuICAgICAgY29uc3QgbWF0Y2hlc1dpdGhFbmRzID0gZm9sZHIobWF0Y2hlcywgKGFjYywgbWF0Y2gpID0+IHtcbiAgICAgICAgY29uc3QgZW5kTWFya2VyID0gY3JlYXRlTWFya2VyKGRvbSwgbWFya2VyUHJlZml4ICsgYF9lbmQkeyBhY2MubGVuZ3RoIH1gLCBtYXRjaC5lbmRSbmcpO1xuICAgICAgICByZXR1cm4gYWNjLmNvbmNhdChbe1xuICAgICAgICAgICAgLi4ubWF0Y2gsXG4gICAgICAgICAgICBlbmRNYXJrZXJcbiAgICAgICAgICB9XSk7XG4gICAgICB9LCBbXSk7XG4gICAgICByZXR1cm4gZm9sZHIobWF0Y2hlc1dpdGhFbmRzLCAoYWNjLCBtYXRjaCkgPT4ge1xuICAgICAgICBjb25zdCBpZHggPSBtYXRjaGVzV2l0aEVuZHMubGVuZ3RoIC0gYWNjLmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnN0IHN0YXJ0TWFya2VyID0gaXNSZXBsYWNlbWVudFBhdHRlcm4obWF0Y2gucGF0dGVybikgPyBtYXRjaC5lbmRNYXJrZXIgOiBjcmVhdGVNYXJrZXIoZG9tLCBtYXJrZXJQcmVmaXggKyBgX3N0YXJ0JHsgaWR4IH1gLCBtYXRjaC5zdGFydFJuZyk7XG4gICAgICAgIHJldHVybiBhY2MuY29uY2F0KFt7XG4gICAgICAgICAgICAuLi5tYXRjaCxcbiAgICAgICAgICAgIHN0YXJ0TWFya2VyXG4gICAgICAgICAgfV0pO1xuICAgICAgfSwgW10pO1xuICAgIH07XG4gICAgY29uc3Qgc29ydFBhdHRlcm5zID0gcGF0dGVybnMgPT4gc29ydChwYXR0ZXJucywgKGEsIGIpID0+IGIuZW5kLmxlbmd0aCAtIGEuZW5kLmxlbmd0aCk7XG4gICAgY29uc3QgZ2V0QmVzdE1hdGNoZXMgPSAobWF0Y2hlcywgbWF0Y2hlc1dpdGhTb3J0ZWRQYXR0ZXJucykgPT4ge1xuICAgICAgY29uc3QgaGFzU2FtZU1hdGNoZXMgPSBmb3JhbGwobWF0Y2hlcywgbWF0Y2ggPT4gZXhpc3RzKG1hdGNoZXNXaXRoU29ydGVkUGF0dGVybnMsIHNvcnRlZE1hdGNoID0+IG1hdGNoLnBhdHRlcm4uc3RhcnQgPT09IHNvcnRlZE1hdGNoLnBhdHRlcm4uc3RhcnQgJiYgbWF0Y2gucGF0dGVybi5lbmQgPT09IHNvcnRlZE1hdGNoLnBhdHRlcm4uZW5kKSk7XG4gICAgICBpZiAobWF0Y2hlcy5sZW5ndGggPT09IG1hdGNoZXNXaXRoU29ydGVkUGF0dGVybnMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChoYXNTYW1lTWF0Y2hlcykge1xuICAgICAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBtYXRjaGVzV2l0aFNvcnRlZFBhdHRlcm5zO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2hlcy5sZW5ndGggPiBtYXRjaGVzV2l0aFNvcnRlZFBhdHRlcm5zLmxlbmd0aCA/IG1hdGNoZXMgOiBtYXRjaGVzV2l0aFNvcnRlZFBhdHRlcm5zO1xuICAgIH07XG4gICAgY29uc3QgZmluZFBhdHRlcm5zID0gKGVkaXRvciwgYmxvY2ssIG5vZGUsIG9mZnNldCwgcGF0dGVyblNldCwgbm9ybWFsaXplZE1hdGNoZXMpID0+IHtcbiAgICAgIGNvbnN0IG1hdGNoZXMgPSBmaW5kUGF0dGVybnNSZWMoZWRpdG9yLCBwYXR0ZXJuU2V0LmlubGluZVBhdHRlcm5zLCBub2RlLCBvZmZzZXQsIGJsb2NrLCBub3JtYWxpemVkTWF0Y2hlcykuZm9sZCgoKSA9PiBbXSwgcmVzdWx0ID0+IHJlc3VsdC5tYXRjaGVzKTtcbiAgICAgIGNvbnN0IG1hdGNoZXNXaXRoU29ydGVkUGF0dGVybnMgPSBmaW5kUGF0dGVybnNSZWMoZWRpdG9yLCBzb3J0UGF0dGVybnMocGF0dGVyblNldC5pbmxpbmVQYXR0ZXJucyksIG5vZGUsIG9mZnNldCwgYmxvY2ssIG5vcm1hbGl6ZWRNYXRjaGVzKS5mb2xkKCgpID0+IFtdLCByZXN1bHQgPT4gcmVzdWx0Lm1hdGNoZXMpO1xuICAgICAgcmV0dXJuIGdldEJlc3RNYXRjaGVzKG1hdGNoZXMsIG1hdGNoZXNXaXRoU29ydGVkUGF0dGVybnMpO1xuICAgIH07XG4gICAgY29uc3QgYXBwbHlNYXRjaGVzID0gKGVkaXRvciwgbWF0Y2hlcykgPT4ge1xuICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb207XG4gICAgICBjb25zdCBib29rbWFyayA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Qm9va21hcmsoKTtcbiAgICAgIGNvbnN0IG1hdGNoZXNXaXRoTWFya2VycyA9IGFkZE1hcmtlcnMoZG9tLCBtYXRjaGVzKTtcbiAgICAgIGVhY2gkZShtYXRjaGVzV2l0aE1hcmtlcnMsIG1hdGNoID0+IHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBkb20uZ2V0UGFyZW50KG1hdGNoLnN0YXJ0TWFya2VyLnN0YXJ0LCBkb20uaXNCbG9jayk7XG4gICAgICAgIGNvbnN0IGlzUm9vdCA9IG5vZGUgPT4gbm9kZSA9PT0gYmxvY2s7XG4gICAgICAgIGlmIChpc1JlcGxhY2VtZW50UGF0dGVybihtYXRjaC5wYXR0ZXJuKSkge1xuICAgICAgICAgIGFwcGx5UmVwbGFjZW1lbnRQYXR0ZXJuKGVkaXRvciwgbWF0Y2gucGF0dGVybiwgbWF0Y2guZW5kTWFya2VyLCBpc1Jvb3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFwcGx5UGF0dGVybldpdGhDb250ZW50KGVkaXRvciwgbWF0Y2gucGF0dGVybiwgbWF0Y2guc3RhcnRNYXJrZXIsIG1hdGNoLmVuZE1hcmtlciwgaXNSb290KTtcbiAgICAgICAgfVxuICAgICAgICByZW1vdmVNYXJrZXIoZG9tLCBtYXRjaC5lbmRNYXJrZXIsIGlzUm9vdCk7XG4gICAgICAgIHJlbW92ZU1hcmtlcihkb20sIG1hdGNoLnN0YXJ0TWFya2VyLCBpc1Jvb3QpO1xuICAgICAgfSk7XG4gICAgICBlZGl0b3Iuc2VsZWN0aW9uLm1vdmVUb0Jvb2ttYXJrKGJvb2ttYXJrKTtcbiAgICB9O1xuXG4gICAgY29uc3QgaGFuZGxlRW50ZXIgPSAoZWRpdG9yLCBwYXR0ZXJuU2V0KSA9PiB7XG4gICAgICBjb25zdCBybmcgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgcmV0dXJuIGdldFBhcmVudEJsb2NrKGVkaXRvciwgcm5nKS5tYXAoYmxvY2sgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IE1hdGgubWF4KDAsIHJuZy5zdGFydE9mZnNldCk7XG4gICAgICAgIGNvbnN0IGR5bmFtaWNQYXR0ZXJuU2V0ID0gcmVzb2x2ZUZyb21EeW5hbWljUGF0dGVybnMocGF0dGVyblNldCwgYmxvY2ssIChfYSA9IGJsb2NrLnRleHRDb250ZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJyk7XG4gICAgICAgIGNvbnN0IGlubGluZU1hdGNoZXMgPSBmaW5kUGF0dGVybnMoZWRpdG9yLCBibG9jaywgcm5nLnN0YXJ0Q29udGFpbmVyLCBvZmZzZXQsIGR5bmFtaWNQYXR0ZXJuU2V0LCB0cnVlKTtcbiAgICAgICAgY29uc3QgYmxvY2tNYXRjaGVzID0gZmluZFBhdHRlcm5zJDEoZWRpdG9yLCBibG9jaywgZHluYW1pY1BhdHRlcm5TZXQsIHRydWUpO1xuICAgICAgICBpZiAoYmxvY2tNYXRjaGVzLmxlbmd0aCA+IDAgfHwgaW5saW5lTWF0Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZWRpdG9yLnVuZG9NYW5hZ2VyLmFkZCgpO1xuICAgICAgICAgIGVkaXRvci51bmRvTWFuYWdlci5leHRyYSgoKSA9PiB7XG4gICAgICAgICAgICBlZGl0b3IuZXhlY0NvbW1hbmQoJ21jZUluc2VydE5ld0xpbmUnKTtcbiAgICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgICBlZGl0b3IuaW5zZXJ0Q29udGVudCh6ZXJvV2lkdGgpO1xuICAgICAgICAgICAgYXBwbHlNYXRjaGVzKGVkaXRvciwgaW5saW5lTWF0Y2hlcyk7XG4gICAgICAgICAgICBhcHBseU1hdGNoZXMkMShlZGl0b3IsIGJsb2NrTWF0Y2hlcyk7XG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICAgICAgICBjb25zdCBzcG90ID0gdGV4dEJlZm9yZShyYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2Uuc3RhcnRPZmZzZXQsIGVkaXRvci5kb20uZ2V0Um9vdCgpKTtcbiAgICAgICAgICAgIGVkaXRvci5leGVjQ29tbWFuZCgnbWNlSW5zZXJ0TmV3TGluZScpO1xuICAgICAgICAgICAgc3BvdC5lYWNoKHMgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBub2RlID0gcy5jb250YWluZXI7XG4gICAgICAgICAgICAgIGlmIChub2RlLmRhdGEuY2hhckF0KHMub2Zmc2V0IC0gMSkgPT09IHplcm9XaWR0aCkge1xuICAgICAgICAgICAgICAgIG5vZGUuZGVsZXRlRGF0YShzLm9mZnNldCAtIDEsIDEpO1xuICAgICAgICAgICAgICAgIGNsZWFuRW1wdHlOb2RlcyhlZGl0b3IuZG9tLCBub2RlLnBhcmVudE5vZGUsIGUgPT4gZSA9PT0gZWRpdG9yLmRvbS5nZXRSb290KCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KS5nZXRPcihmYWxzZSk7XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVJbmxpbmVLZXkgPSAoZWRpdG9yLCBwYXR0ZXJuU2V0KSA9PiB7XG4gICAgICBjb25zdCBybmcgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgZ2V0UGFyZW50QmxvY2soZWRpdG9yLCBybmcpLm1hcChibG9jayA9PiB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IE1hdGgubWF4KDAsIHJuZy5zdGFydE9mZnNldCAtIDEpO1xuICAgICAgICBjb25zdCBiZWZvcmVUZXh0ID0gZ2V0QmVmb3JlVGV4dChlZGl0b3IuZG9tLCBibG9jaywgcm5nLnN0YXJ0Q29udGFpbmVyLCBvZmZzZXQpO1xuICAgICAgICBjb25zdCBkeW5hbWljUGF0dGVyblNldCA9IHJlc29sdmVGcm9tRHluYW1pY1BhdHRlcm5zKHBhdHRlcm5TZXQsIGJsb2NrLCBiZWZvcmVUZXh0KTtcbiAgICAgICAgY29uc3QgaW5saW5lTWF0Y2hlcyA9IGZpbmRQYXR0ZXJucyhlZGl0b3IsIGJsb2NrLCBybmcuc3RhcnRDb250YWluZXIsIG9mZnNldCwgZHluYW1pY1BhdHRlcm5TZXQsIGZhbHNlKTtcbiAgICAgICAgaWYgKGlubGluZU1hdGNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGVkaXRvci51bmRvTWFuYWdlci50cmFuc2FjdCgoKSA9PiB7XG4gICAgICAgICAgICBhcHBseU1hdGNoZXMoZWRpdG9yLCBpbmxpbmVNYXRjaGVzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBjaGVja0tleUV2ZW50ID0gKGNvZGVzLCBldmVudCwgcHJlZGljYXRlKSA9PiB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUoY29kZXNbaV0sIGV2ZW50KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBjb25zdCBjaGVja0tleUNvZGUgPSAoY29kZXMsIGV2ZW50KSA9PiBjaGVja0tleUV2ZW50KGNvZGVzLCBldmVudCwgKGNvZGUsIGV2ZW50KSA9PiB7XG4gICAgICByZXR1cm4gY29kZSA9PT0gZXZlbnQua2V5Q29kZSAmJiAhVksubW9kaWZpZXJQcmVzc2VkKGV2ZW50KTtcbiAgICB9KTtcbiAgICBjb25zdCBjaGVja0NoYXJDb2RlID0gKGNoYXJzLCBldmVudCkgPT4gY2hlY2tLZXlFdmVudChjaGFycywgZXZlbnQsIChjaHIsIGV2ZW50KSA9PiB7XG4gICAgICByZXR1cm4gY2hyLmNoYXJDb2RlQXQoMCkgPT09IGV2ZW50LmNoYXJDb2RlO1xuICAgIH0pO1xuXG4gICAgY29uc3Qgc2V0dXAkMiA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBjaGFyQ29kZXMgPSBbXG4gICAgICAgICcsJyxcbiAgICAgICAgJy4nLFxuICAgICAgICAnOycsXG4gICAgICAgICc6JyxcbiAgICAgICAgJyEnLFxuICAgICAgICAnPydcbiAgICAgIF07XG4gICAgICBjb25zdCBrZXlDb2RlcyA9IFszMl07XG4gICAgICBjb25zdCBnZXRQYXR0ZXJuU2V0ID0gKCkgPT4gY3JlYXRlUGF0dGVyblNldChnZXRUZXh0UGF0dGVybnMoZWRpdG9yKSwgZ2V0VGV4dFBhdHRlcm5zTG9va3VwKGVkaXRvcikpO1xuICAgICAgY29uc3QgaGFzRHluYW1pY1BhdHRlcm5zID0gKCkgPT4gaGFzVGV4dFBhdHRlcm5zTG9va3VwKGVkaXRvcik7XG4gICAgICBlZGl0b3Iub24oJ2tleWRvd24nLCBlID0+IHtcbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMTMgJiYgIVZLLm1vZGlmaWVyUHJlc3NlZChlKSAmJiBlZGl0b3Iuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgICBjb25zdCBwYXR0ZXJuU2V0ID0gZ2V0UGF0dGVyblNldCgpO1xuICAgICAgICAgIGNvbnN0IGhhc1BhdHRlcm5zID0gcGF0dGVyblNldC5pbmxpbmVQYXR0ZXJucy5sZW5ndGggPiAwIHx8IHBhdHRlcm5TZXQuYmxvY2tQYXR0ZXJucy5sZW5ndGggPiAwIHx8IGhhc0R5bmFtaWNQYXR0ZXJucygpO1xuICAgICAgICAgIGlmIChoYXNQYXR0ZXJucyAmJiBoYW5kbGVFbnRlcihlZGl0b3IsIHBhdHRlcm5TZXQpKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB0cnVlKTtcbiAgICAgIGNvbnN0IGhhbmRsZUlubGluZVRyaWdnZXIgPSAoKSA9PiB7XG4gICAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgICBjb25zdCBwYXR0ZXJuU2V0ID0gZ2V0UGF0dGVyblNldCgpO1xuICAgICAgICAgIGNvbnN0IGhhc1BhdHRlcm5zID0gcGF0dGVyblNldC5pbmxpbmVQYXR0ZXJucy5sZW5ndGggPiAwIHx8IGhhc0R5bmFtaWNQYXR0ZXJucygpO1xuICAgICAgICAgIGlmIChoYXNQYXR0ZXJucykge1xuICAgICAgICAgICAgaGFuZGxlSW5saW5lS2V5KGVkaXRvciwgcGF0dGVyblNldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZWRpdG9yLm9uKCdrZXl1cCcsIGUgPT4ge1xuICAgICAgICBpZiAoY2hlY2tLZXlDb2RlKGtleUNvZGVzLCBlKSkge1xuICAgICAgICAgIGhhbmRsZUlubGluZVRyaWdnZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlZGl0b3Iub24oJ2tleXByZXNzJywgZSA9PiB7XG4gICAgICAgIGlmIChjaGVja0NoYXJDb2RlKGNoYXJDb2RlcywgZSkpIHtcbiAgICAgICAgICBEZWxheS5zZXRFZGl0b3JUaW1lb3V0KGVkaXRvciwgaGFuZGxlSW5saW5lVHJpZ2dlcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBzZXR1cCQxID0gZWRpdG9yID0+IHtcbiAgICAgIHNldHVwJDIoZWRpdG9yKTtcbiAgICB9O1xuXG4gICAgY29uc3QgUXVpcmtzID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGVhY2ggPSBUb29scy5lYWNoO1xuICAgICAgY29uc3QgQkFDS1NQQUNFID0gVksuQkFDS1NQQUNFLCBERUxFVEUgPSBWSy5ERUxFVEUsIGRvbSA9IGVkaXRvci5kb20sIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb24sIHBhcnNlciA9IGVkaXRvci5wYXJzZXI7XG4gICAgICBjb25zdCBicm93c2VyID0gRW52LmJyb3dzZXI7XG4gICAgICBjb25zdCBpc0dlY2tvID0gYnJvd3Nlci5pc0ZpcmVmb3goKTtcbiAgICAgIGNvbnN0IGlzV2ViS2l0ID0gYnJvd3Nlci5pc0Nocm9taXVtKCkgfHwgYnJvd3Nlci5pc1NhZmFyaSgpO1xuICAgICAgY29uc3QgaXNpT1MgPSBFbnYuZGV2aWNlVHlwZS5pc2lQaG9uZSgpIHx8IEVudi5kZXZpY2VUeXBlLmlzaVBhZCgpO1xuICAgICAgY29uc3QgaXNNYWMgPSBFbnYub3MuaXNNYWNPUygpIHx8IEVudi5vcy5pc2lPUygpO1xuICAgICAgY29uc3Qgc2V0RWRpdG9yQ29tbWFuZFN0YXRlID0gKGNtZCwgc3RhdGUpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBlZGl0b3IuZ2V0RG9jKCkuZXhlY0NvbW1hbmQoY21kLCBmYWxzZSwgU3RyaW5nKHN0YXRlKSk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBpc0RlZmF1bHRQcmV2ZW50ZWQgPSBlID0+IHtcbiAgICAgICAgcmV0dXJuIGUuaXNEZWZhdWx0UHJldmVudGVkKCk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZW1wdHlFZGl0b3JXaGVuRGVsZXRpbmcgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZVJuZyA9IHJuZyA9PiB7XG4gICAgICAgICAgY29uc3QgYm9keSA9IGRvbS5jcmVhdGUoJ2JvZHknKTtcbiAgICAgICAgICBjb25zdCBjb250ZW50cyA9IHJuZy5jbG9uZUNvbnRlbnRzKCk7XG4gICAgICAgICAgYm9keS5hcHBlbmRDaGlsZChjb250ZW50cyk7XG4gICAgICAgICAgcmV0dXJuIHNlbGVjdGlvbi5zZXJpYWxpemVyLnNlcmlhbGl6ZShib2R5LCB7IGZvcm1hdDogJ2h0bWwnIH0pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhbGxDb250ZW50c1NlbGVjdGVkID0gcm5nID0+IHtcbiAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBzZXJpYWxpemVSbmcocm5nKTtcbiAgICAgICAgICBjb25zdCBhbGxSbmcgPSBkb20uY3JlYXRlUm5nKCk7XG4gICAgICAgICAgYWxsUm5nLnNlbGVjdE5vZGUoZWRpdG9yLmdldEJvZHkoKSk7XG4gICAgICAgICAgY29uc3QgYWxsU2VsZWN0aW9uID0gc2VyaWFsaXplUm5nKGFsbFJuZyk7XG4gICAgICAgICAgcmV0dXJuIHNlbGVjdGlvbiA9PT0gYWxsU2VsZWN0aW9uO1xuICAgICAgICB9O1xuICAgICAgICBlZGl0b3Iub24oJ2tleWRvd24nLCBlID0+IHtcbiAgICAgICAgICBjb25zdCBrZXlDb2RlID0gZS5rZXlDb2RlO1xuICAgICAgICAgIGlmICghaXNEZWZhdWx0UHJldmVudGVkKGUpICYmIChrZXlDb2RlID09PSBERUxFVEUgfHwga2V5Q29kZSA9PT0gQkFDS1NQQUNFKSAmJiBlZGl0b3Iuc2VsZWN0aW9uLmlzRWRpdGFibGUoKSkge1xuICAgICAgICAgICAgY29uc3QgaXNDb2xsYXBzZWQgPSBlZGl0b3Iuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCk7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZWRpdG9yLmdldEJvZHkoKTtcbiAgICAgICAgICAgIGlmIChpc0NvbGxhcHNlZCAmJiAhZG9tLmlzRW1wdHkoYm9keSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0NvbGxhcHNlZCAmJiAhYWxsQ29udGVudHNTZWxlY3RlZChlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpKSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlZGl0b3Iuc2V0Q29udGVudCgnJyk7XG4gICAgICAgICAgICBpZiAoYm9keS5maXJzdENoaWxkICYmIGRvbS5pc0Jsb2NrKGJvZHkuZmlyc3RDaGlsZCkpIHtcbiAgICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRDdXJzb3JMb2NhdGlvbihib2R5LmZpcnN0Q2hpbGQsIDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRDdXJzb3JMb2NhdGlvbihib2R5LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVkaXRvci5ub2RlQ2hhbmdlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2VsZWN0QWxsID0gKCkgPT4ge1xuICAgICAgICBlZGl0b3Iuc2hvcnRjdXRzLmFkZCgnbWV0YSthJywgbnVsbCwgJ1NlbGVjdEFsbCcpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGRvY3VtZW50RWxlbWVudEVkaXRpbmdGb2N1cyA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFlZGl0b3IuaW5saW5lKSB7XG4gICAgICAgICAgZG9tLmJpbmQoZWRpdG9yLmdldERvYygpLCAnbW91c2Vkb3duIG1vdXNldXAnLCBlID0+IHtcbiAgICAgICAgICAgIGxldCBybmc7XG4gICAgICAgICAgICBpZiAoZS50YXJnZXQgPT09IGVkaXRvci5nZXREb2MoKS5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgcm5nID0gc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgICAgICAgICBlZGl0b3IuZ2V0Qm9keSgpLmZvY3VzKCk7XG4gICAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZWRvd24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQ2FyZXRDb250YWluZXIkMihybmcuc3RhcnRDb250YWluZXIpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5wbGFjZUNhcmV0QXQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5zZXRSbmcocm5nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgcmVtb3ZlSHJPbkJhY2tzcGFjZSA9ICgpID0+IHtcbiAgICAgICAgZWRpdG9yLm9uKCdrZXlkb3duJywgZSA9PiB7XG4gICAgICAgICAgaWYgKCFpc0RlZmF1bHRQcmV2ZW50ZWQoZSkgJiYgZS5rZXlDb2RlID09PSBCQUNLU1BBQ0UpIHtcbiAgICAgICAgICAgIGlmICghZWRpdG9yLmdldEJvZHkoKS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaHInKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpICYmIHNlbGVjdGlvbi5nZXRSbmcoKS5zdGFydE9mZnNldCA9PT0gMCkge1xuICAgICAgICAgICAgICBjb25zdCBub2RlID0gc2VsZWN0aW9uLmdldE5vZGUoKTtcbiAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNTaWJsaW5nID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09PSAnSFInKSB7XG4gICAgICAgICAgICAgICAgZG9tLnJlbW92ZShub2RlKTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChwcmV2aW91c1NpYmxpbmcgJiYgcHJldmlvdXNTaWJsaW5nLm5vZGVOYW1lICYmIHByZXZpb3VzU2libGluZy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaHInKSB7XG4gICAgICAgICAgICAgICAgZG9tLnJlbW92ZShwcmV2aW91c1NpYmxpbmcpO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZm9jdXNCb2R5ID0gKCkgPT4ge1xuICAgICAgICBpZiAoIVJhbmdlLnByb3RvdHlwZS5nZXRDbGllbnRSZWN0cykge1xuICAgICAgICAgIGVkaXRvci5vbignbW91c2Vkb3duJywgZSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzRGVmYXVsdFByZXZlbnRlZChlKSAmJiBlLnRhcmdldC5ub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBlZGl0b3IuZ2V0Qm9keSgpO1xuICAgICAgICAgICAgICBib2R5LmJsdXIoKTtcbiAgICAgICAgICAgICAgRGVsYXkuc2V0RWRpdG9yVGltZW91dChlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgICAgICBib2R5LmZvY3VzKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2VsZWN0Q29udHJvbEVsZW1lbnRzID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB2aXN1YWxBaWRzQW5jaG9yQ2xhc3MgPSBnZXRWaXN1YWxBaWRzQW5jaG9yQ2xhc3MoZWRpdG9yKTtcbiAgICAgICAgZWRpdG9yLm9uKCdjbGljaycsIGUgPT4ge1xuICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICAgIGlmICgvXihJTUd8SFIpJC8udGVzdCh0YXJnZXQubm9kZU5hbWUpICYmIGRvbS5pc0VkaXRhYmxlKHRhcmdldC5wYXJlbnROb2RlKSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZWxlY3QodGFyZ2V0KTtcbiAgICAgICAgICAgIGVkaXRvci5ub2RlQ2hhbmdlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGFyZ2V0Lm5vZGVOYW1lID09PSAnQScgJiYgZG9tLmhhc0NsYXNzKHRhcmdldCwgdmlzdWFsQWlkc0FuY2hvckNsYXNzKSAmJiB0YXJnZXQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDAgJiYgZG9tLmlzRWRpdGFibGUodGFyZ2V0LnBhcmVudE5vZGUpKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBzZWxlY3Rpb24uc2VsZWN0KHRhcmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCByZW1vdmVTdHlsZXNXaGVuRGVsZXRpbmdBY3Jvc3NCbG9ja0VsZW1lbnRzID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBnZXRBdHRyaWJ1dGVBcHBseUZ1bmN0aW9uID0gKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHRlbXBsYXRlID0gZG9tLmdldEF0dHJpYnMoc2VsZWN0aW9uLmdldFN0YXJ0KCkuY2xvbmVOb2RlKGZhbHNlKSk7XG4gICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHNlbGVjdGlvbi5nZXRTdGFydCgpO1xuICAgICAgICAgICAgaWYgKHRhcmdldCAhPT0gZWRpdG9yLmdldEJvZHkoKSkge1xuICAgICAgICAgICAgICBkb20uc2V0QXR0cmliKHRhcmdldCwgJ3N0eWxlJywgbnVsbCk7XG4gICAgICAgICAgICAgIGVhY2godGVtcGxhdGUsIGF0dHIgPT4ge1xuICAgICAgICAgICAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGVOb2RlKGF0dHIuY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaXNTZWxlY3Rpb25BY3Jvc3NFbGVtZW50cyA9ICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gIXNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpICYmIGRvbS5nZXRQYXJlbnQoc2VsZWN0aW9uLmdldFN0YXJ0KCksIGRvbS5pc0Jsb2NrKSAhPT0gZG9tLmdldFBhcmVudChzZWxlY3Rpb24uZ2V0RW5kKCksIGRvbS5pc0Jsb2NrKTtcbiAgICAgICAgfTtcbiAgICAgICAgZWRpdG9yLm9uKCdrZXlwcmVzcycsIGUgPT4ge1xuICAgICAgICAgIGxldCBhcHBseUF0dHJpYnV0ZXM7XG4gICAgICAgICAgaWYgKCFpc0RlZmF1bHRQcmV2ZW50ZWQoZSkgJiYgKGUua2V5Q29kZSA9PT0gOCB8fCBlLmtleUNvZGUgPT09IDQ2KSAmJiBpc1NlbGVjdGlvbkFjcm9zc0VsZW1lbnRzKCkpIHtcbiAgICAgICAgICAgIGFwcGx5QXR0cmlidXRlcyA9IGdldEF0dHJpYnV0ZUFwcGx5RnVuY3Rpb24oKTtcbiAgICAgICAgICAgIGVkaXRvci5nZXREb2MoKS5leGVjQ29tbWFuZCgnZGVsZXRlJywgZmFsc2UpO1xuICAgICAgICAgICAgYXBwbHlBdHRyaWJ1dGVzKCk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGRvbS5iaW5kKGVkaXRvci5nZXREb2MoKSwgJ2N1dCcsIGUgPT4ge1xuICAgICAgICAgIGlmICghaXNEZWZhdWx0UHJldmVudGVkKGUpICYmIGlzU2VsZWN0aW9uQWNyb3NzRWxlbWVudHMoKSkge1xuICAgICAgICAgICAgY29uc3QgYXBwbHlBdHRyaWJ1dGVzID0gZ2V0QXR0cmlidXRlQXBwbHlGdW5jdGlvbigpO1xuICAgICAgICAgICAgRGVsYXkuc2V0RWRpdG9yVGltZW91dChlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgICAgYXBwbHlBdHRyaWJ1dGVzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGRpc2FibGVCYWNrc3BhY2VJbnRvQVRhYmxlID0gKCkgPT4ge1xuICAgICAgICBlZGl0b3Iub24oJ2tleWRvd24nLCBlID0+IHtcbiAgICAgICAgICBpZiAoIWlzRGVmYXVsdFByZXZlbnRlZChlKSAmJiBlLmtleUNvZGUgPT09IEJBQ0tTUEFDRSkge1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpICYmIHNlbGVjdGlvbi5nZXRSbmcoKS5zdGFydE9mZnNldCA9PT0gMCkge1xuICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c1NpYmxpbmcgPSBzZWxlY3Rpb24uZ2V0Tm9kZSgpLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgICAgaWYgKHByZXZpb3VzU2libGluZyAmJiBwcmV2aW91c1NpYmxpbmcubm9kZU5hbWUgJiYgcHJldmlvdXNTaWJsaW5nLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0YWJsZScpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCByZW1vdmVCbG9ja1F1b3RlT25CYWNrU3BhY2UgPSAoKSA9PiB7XG4gICAgICAgIGVkaXRvci5vbigna2V5ZG93bicsIGUgPT4ge1xuICAgICAgICAgIGlmIChpc0RlZmF1bHRQcmV2ZW50ZWQoZSkgfHwgZS5rZXlDb2RlICE9PSBWSy5CQUNLU1BBQ0UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHJuZyA9IHNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBybmcuc3RhcnRDb250YWluZXI7XG4gICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gcm5nLnN0YXJ0T2Zmc2V0O1xuICAgICAgICAgIGNvbnN0IHJvb3QgPSBkb20uZ2V0Um9vdCgpO1xuICAgICAgICAgIGxldCBwYXJlbnQgPSBjb250YWluZXI7XG4gICAgICAgICAgaWYgKCFybmcuY29sbGFwc2VkIHx8IG9mZnNldCAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAocGFyZW50LnBhcmVudE5vZGUgJiYgcGFyZW50LnBhcmVudE5vZGUuZmlyc3RDaGlsZCA9PT0gcGFyZW50ICYmIHBhcmVudC5wYXJlbnROb2RlICE9PSByb290KSB7XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBhcmVudC5ub2RlTmFtZSA9PT0gJ0JMT0NLUVVPVEUnKSB7XG4gICAgICAgICAgICBlZGl0b3IuZm9ybWF0dGVyLnRvZ2dsZSgnYmxvY2txdW90ZScsIHVuZGVmaW5lZCwgcGFyZW50KTtcbiAgICAgICAgICAgIHJuZyA9IGRvbS5jcmVhdGVSbmcoKTtcbiAgICAgICAgICAgIHJuZy5zZXRTdGFydChjb250YWluZXIsIDApO1xuICAgICAgICAgICAgcm5nLnNldEVuZChjb250YWluZXIsIDApO1xuICAgICAgICAgICAgc2VsZWN0aW9uLnNldFJuZyhybmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2V0R2Vja29FZGl0aW5nT3B0aW9ucyA9ICgpID0+IHtcbiAgICAgICAgY29uc3Qgc2V0T3B0cyA9ICgpID0+IHtcbiAgICAgICAgICBzZXRFZGl0b3JDb21tYW5kU3RhdGUoJ1N0eWxlV2l0aENTUycsIGZhbHNlKTtcbiAgICAgICAgICBzZXRFZGl0b3JDb21tYW5kU3RhdGUoJ2VuYWJsZUlubGluZVRhYmxlRWRpdGluZycsIGZhbHNlKTtcbiAgICAgICAgICBpZiAoIWdldE9iamVjdFJlc2l6aW5nKGVkaXRvcikpIHtcbiAgICAgICAgICAgIHNldEVkaXRvckNvbW1hbmRTdGF0ZSgnZW5hYmxlT2JqZWN0UmVzaXppbmcnLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoIWlzUmVhZE9ubHkkMShlZGl0b3IpKSB7XG4gICAgICAgICAgZWRpdG9yLm9uKCdCZWZvcmVFeGVjQ29tbWFuZCBtb3VzZWRvd24nLCBzZXRPcHRzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGFkZEJyQWZ0ZXJMYXN0TGlua3MgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpeExpbmtzID0gKCkgPT4ge1xuICAgICAgICAgIGVhY2goZG9tLnNlbGVjdCgnYTpub3QoW2RhdGEtbWNlLWJsb2NrXSknKSwgbm9kZSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBsZXQgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBkb20uZ2V0Um9vdCgpO1xuICAgICAgICAgICAgaWYgKChwYXJlbnROb2RlID09PSBudWxsIHx8IHBhcmVudE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudE5vZGUubGFzdENoaWxkKSA9PT0gbm9kZSkge1xuICAgICAgICAgICAgICB3aGlsZSAocGFyZW50Tm9kZSAmJiAhZG9tLmlzQmxvY2socGFyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoKChfYSA9IHBhcmVudE5vZGUucGFyZW50Tm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxhc3RDaGlsZCkgIT09IHBhcmVudE5vZGUgfHwgcGFyZW50Tm9kZSA9PT0gcm9vdCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRvbS5hZGQocGFyZW50Tm9kZSwgJ2JyJywgeyAnZGF0YS1tY2UtYm9ndXMnOiAxIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBlZGl0b3Iub24oJ1NldENvbnRlbnQgRXhlY0NvbW1hbmQnLCBlID0+IHtcbiAgICAgICAgICBpZiAoZS50eXBlID09PSAnc2V0Y29udGVudCcgfHwgZS5jb21tYW5kID09PSAnbWNlSW5zZXJ0TGluaycpIHtcbiAgICAgICAgICAgIGZpeExpbmtzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBzZXREZWZhdWx0QmxvY2tUeXBlID0gKCkgPT4ge1xuICAgICAgICBlZGl0b3Iub24oJ2luaXQnLCAoKSA9PiB7XG4gICAgICAgICAgc2V0RWRpdG9yQ29tbWFuZFN0YXRlKCdEZWZhdWx0UGFyYWdyYXBoU2VwYXJhdG9yJywgZ2V0Rm9yY2VkUm9vdEJsb2NrKGVkaXRvcikpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBpc0FsbENvbnRlbnRTZWxlY3RlZCA9IGVkaXRvciA9PiB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBlZGl0b3IuZ2V0Qm9keSgpO1xuICAgICAgICBjb25zdCBybmcgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgICByZXR1cm4gcm5nLnN0YXJ0Q29udGFpbmVyID09PSBybmcuZW5kQ29udGFpbmVyICYmIHJuZy5zdGFydENvbnRhaW5lciA9PT0gYm9keSAmJiBybmcuc3RhcnRPZmZzZXQgPT09IDAgJiYgcm5nLmVuZE9mZnNldCA9PT0gYm9keS5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgIH07XG4gICAgICBjb25zdCBub3JtYWxpemVTZWxlY3Rpb24gPSAoKSA9PiB7XG4gICAgICAgIGVkaXRvci5vbigna2V5dXAgZm9jdXNpbiBtb3VzZXVwJywgZSA9PiB7XG4gICAgICAgICAgaWYgKCFWSy5tb2RpZmllclByZXNzZWQoZSkgJiYgIWlzQWxsQ29udGVudFNlbGVjdGVkKGVkaXRvcikpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHNob3dCcm9rZW5JbWFnZUljb24gPSAoKSA9PiB7XG4gICAgICAgIGVkaXRvci5jb250ZW50U3R5bGVzLnB1c2goJ2ltZzotbW96LWJyb2tlbiB7JyArICctbW96LWZvcmNlLWJyb2tlbi1pbWFnZS1pY29uOjE7JyArICdtaW4td2lkdGg6MjRweDsnICsgJ21pbi1oZWlnaHQ6MjRweCcgKyAnfScpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlc3RvcmVGb2N1c09uS2V5RG93biA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFlZGl0b3IuaW5saW5lKSB7XG4gICAgICAgICAgZWRpdG9yLm9uKCdrZXlkb3duJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgICAgZWRpdG9yLmdldFdpbigpLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBib2R5SGVpZ2h0ID0gKCkgPT4ge1xuICAgICAgICBpZiAoIWVkaXRvci5pbmxpbmUpIHtcbiAgICAgICAgICBlZGl0b3IuY29udGVudFN0eWxlcy5wdXNoKCdib2R5IHttaW4taGVpZ2h0OiAxNTBweH0nKTtcbiAgICAgICAgICBlZGl0b3Iub24oJ2NsaWNrJywgZSA9PiB7XG4gICAgICAgICAgICBsZXQgcm5nO1xuICAgICAgICAgICAgaWYgKGUudGFyZ2V0Lm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICAgICAgICAgICAgcm5nID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgICAgICAgICAgZWRpdG9yLmdldEJvZHkoKS5mb2N1cygpO1xuICAgICAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFJuZyhybmcpO1xuICAgICAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgICBlZGl0b3Iubm9kZUNoYW5nZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGJsb2NrQ21kQXJyb3dOYXZpZ2F0aW9uID0gKCkgPT4ge1xuICAgICAgICBpZiAoaXNNYWMpIHtcbiAgICAgICAgICBlZGl0b3Iub24oJ2tleWRvd24nLCBlID0+IHtcbiAgICAgICAgICAgIGlmIChWSy5tZXRhS2V5UHJlc3NlZChlKSAmJiAhZS5zaGlmdEtleSAmJiAoZS5rZXlDb2RlID09PSAzNyB8fCBlLmtleUNvZGUgPT09IDM5KSkge1xuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0U2VsKCk7XG4gICAgICAgICAgICAgIHNlbGVjdGlvbi5tb2RpZnkoJ21vdmUnLCBlLmtleUNvZGUgPT09IDM3ID8gJ2JhY2t3YXJkJyA6ICdmb3J3YXJkJywgJ2xpbmVib3VuZGFyeScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgdGFwTGlua3NBbmRJbWFnZXMgPSAoKSA9PiB7XG4gICAgICAgIGVkaXRvci5vbignY2xpY2snLCBlID0+IHtcbiAgICAgICAgICBsZXQgZWxtID0gZS50YXJnZXQ7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGVsbS50YWdOYW1lID09PSAnQScpIHtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAoZWxtID0gZWxtLnBhcmVudE5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgZWRpdG9yLmNvbnRlbnRTdHlsZXMucHVzaCgnLm1jZS1jb250ZW50LWJvZHkgey13ZWJraXQtdG91Y2gtY2FsbG91dDogbm9uZX0nKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBibG9ja0Zvcm1TdWJtaXRJbnNpZGVFZGl0b3IgPSAoKSA9PiB7XG4gICAgICAgIGVkaXRvci5vbignaW5pdCcsICgpID0+IHtcbiAgICAgICAgICBlZGl0b3IuZG9tLmJpbmQoZWRpdG9yLmdldEJvZHkoKSwgJ3N1Ym1pdCcsIGUgPT4ge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCByZW1vdmVBcHBsZUludGVyY2hhbmdlQnJzID0gKCkgPT4ge1xuICAgICAgICBwYXJzZXIuYWRkTm9kZUZpbHRlcignYnInLCBub2RlcyA9PiB7XG4gICAgICAgICAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgaWYgKG5vZGVzW2ldLmF0dHIoJ2NsYXNzJykgPT09ICdBcHBsZS1pbnRlcmNoYW5nZS1uZXdsaW5lJykge1xuICAgICAgICAgICAgICBub2Rlc1tpXS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlZnJlc2hDb250ZW50RWRpdGFibGUgPSBub29wO1xuICAgICAgY29uc3QgaXNIaWRkZW4gPSAoKSA9PiB7XG4gICAgICAgIGlmICghaXNHZWNrbyB8fCBlZGl0b3IucmVtb3ZlZCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWwgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFNlbCgpO1xuICAgICAgICByZXR1cm4gIXNlbCB8fCAhc2VsLnJhbmdlQ291bnQgfHwgc2VsLnJhbmdlQ291bnQgPT09IDA7XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2V0dXBSdGMgPSAoKSA9PiB7XG4gICAgICAgIGlmIChpc1dlYktpdCkge1xuICAgICAgICAgIGRvY3VtZW50RWxlbWVudEVkaXRpbmdGb2N1cygpO1xuICAgICAgICAgIHNlbGVjdENvbnRyb2xFbGVtZW50cygpO1xuICAgICAgICAgIGJsb2NrRm9ybVN1Ym1pdEluc2lkZUVkaXRvcigpO1xuICAgICAgICAgIHNlbGVjdEFsbCgpO1xuICAgICAgICAgIGlmIChpc2lPUykge1xuICAgICAgICAgICAgcmVzdG9yZUZvY3VzT25LZXlEb3duKCk7XG4gICAgICAgICAgICBib2R5SGVpZ2h0KCk7XG4gICAgICAgICAgICB0YXBMaW5rc0FuZEltYWdlcygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNHZWNrbykge1xuICAgICAgICAgIGZvY3VzQm9keSgpO1xuICAgICAgICAgIHNldEdlY2tvRWRpdGluZ09wdGlvbnMoKTtcbiAgICAgICAgICBzaG93QnJva2VuSW1hZ2VJY29uKCk7XG4gICAgICAgICAgYmxvY2tDbWRBcnJvd05hdmlnYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNldHVwID0gKCkgPT4ge1xuICAgICAgICByZW1vdmVCbG9ja1F1b3RlT25CYWNrU3BhY2UoKTtcbiAgICAgICAgZW1wdHlFZGl0b3JXaGVuRGVsZXRpbmcoKTtcbiAgICAgICAgaWYgKCFFbnYud2luZG93c1Bob25lKSB7XG4gICAgICAgICAgbm9ybWFsaXplU2VsZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzV2ViS2l0KSB7XG4gICAgICAgICAgZG9jdW1lbnRFbGVtZW50RWRpdGluZ0ZvY3VzKCk7XG4gICAgICAgICAgc2VsZWN0Q29udHJvbEVsZW1lbnRzKCk7XG4gICAgICAgICAgc2V0RGVmYXVsdEJsb2NrVHlwZSgpO1xuICAgICAgICAgIGJsb2NrRm9ybVN1Ym1pdEluc2lkZUVkaXRvcigpO1xuICAgICAgICAgIGRpc2FibGVCYWNrc3BhY2VJbnRvQVRhYmxlKCk7XG4gICAgICAgICAgcmVtb3ZlQXBwbGVJbnRlcmNoYW5nZUJycygpO1xuICAgICAgICAgIGlmIChpc2lPUykge1xuICAgICAgICAgICAgcmVzdG9yZUZvY3VzT25LZXlEb3duKCk7XG4gICAgICAgICAgICBib2R5SGVpZ2h0KCk7XG4gICAgICAgICAgICB0YXBMaW5rc0FuZEltYWdlcygpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxlY3RBbGwoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzR2Vja28pIHtcbiAgICAgICAgICByZW1vdmVIck9uQmFja3NwYWNlKCk7XG4gICAgICAgICAgZm9jdXNCb2R5KCk7XG4gICAgICAgICAgcmVtb3ZlU3R5bGVzV2hlbkRlbGV0aW5nQWNyb3NzQmxvY2tFbGVtZW50cygpO1xuICAgICAgICAgIHNldEdlY2tvRWRpdGluZ09wdGlvbnMoKTtcbiAgICAgICAgICBhZGRCckFmdGVyTGFzdExpbmtzKCk7XG4gICAgICAgICAgc2hvd0Jyb2tlbkltYWdlSWNvbigpO1xuICAgICAgICAgIGJsb2NrQ21kQXJyb3dOYXZpZ2F0aW9uKCk7XG4gICAgICAgICAgZGlzYWJsZUJhY2tzcGFjZUludG9BVGFibGUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChpc1J0YyhlZGl0b3IpKSB7XG4gICAgICAgIHNldHVwUnRjKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXR1cCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVmcmVzaENvbnRlbnRFZGl0YWJsZSxcbiAgICAgICAgaXNIaWRkZW5cbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IERPTSQ2ID0gRE9NVXRpbHMuRE9NO1xuICAgIGNvbnN0IGFwcGVuZFN0eWxlID0gKGVkaXRvciwgdGV4dCkgPT4ge1xuICAgICAgY29uc3QgYm9keSA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRCb2R5KCkpO1xuICAgICAgY29uc3QgY29udGFpbmVyID0gZ2V0U3R5bGVDb250YWluZXIoZ2V0Um9vdE5vZGUoYm9keSkpO1xuICAgICAgY29uc3Qgc3R5bGUgPSBTdWdhckVsZW1lbnQuZnJvbVRhZygnc3R5bGUnKTtcbiAgICAgIHNldCQzKHN0eWxlLCAndHlwZScsICd0ZXh0L2NzcycpO1xuICAgICAgYXBwZW5kJDEoc3R5bGUsIFN1Z2FyRWxlbWVudC5mcm9tVGV4dCh0ZXh0KSk7XG4gICAgICBhcHBlbmQkMShjb250YWluZXIsIHN0eWxlKTtcbiAgICAgIGVkaXRvci5vbigncmVtb3ZlJywgKCkgPT4ge1xuICAgICAgICByZW1vdmUkNihzdHlsZSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGdldFJvb3ROYW1lID0gZWRpdG9yID0+IGVkaXRvci5pbmxpbmUgPyBlZGl0b3IuZ2V0RWxlbWVudCgpLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgcmVtb3ZlVW5kZWZpbmVkID0gb2JqID0+IGZpbHRlciQ0KG9iaiwgdiA9PiBpc1VuZGVmaW5lZCh2KSA9PT0gZmFsc2UpO1xuICAgIGNvbnN0IG1rUGFyc2VyU2V0dGluZ3MgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgZ2V0T3B0aW9uID0gZWRpdG9yLm9wdGlvbnMuZ2V0O1xuICAgICAgY29uc3QgYmxvYkNhY2hlID0gZWRpdG9yLmVkaXRvclVwbG9hZC5ibG9iQ2FjaGU7XG4gICAgICByZXR1cm4gcmVtb3ZlVW5kZWZpbmVkKHtcbiAgICAgICAgYWxsb3dfY29uZGl0aW9uYWxfY29tbWVudHM6IGdldE9wdGlvbignYWxsb3dfY29uZGl0aW9uYWxfY29tbWVudHMnKSxcbiAgICAgICAgYWxsb3dfaHRtbF9kYXRhX3VybHM6IGdldE9wdGlvbignYWxsb3dfaHRtbF9kYXRhX3VybHMnKSxcbiAgICAgICAgYWxsb3dfc3ZnX2RhdGFfdXJsczogZ2V0T3B0aW9uKCdhbGxvd19zdmdfZGF0YV91cmxzJyksXG4gICAgICAgIGFsbG93X2h0bWxfaW5fbmFtZWRfYW5jaG9yOiBnZXRPcHRpb24oJ2FsbG93X2h0bWxfaW5fbmFtZWRfYW5jaG9yJyksXG4gICAgICAgIGFsbG93X3NjcmlwdF91cmxzOiBnZXRPcHRpb24oJ2FsbG93X3NjcmlwdF91cmxzJyksXG4gICAgICAgIGFsbG93X3Vuc2FmZV9saW5rX3RhcmdldDogZ2V0T3B0aW9uKCdhbGxvd191bnNhZmVfbGlua190YXJnZXQnKSxcbiAgICAgICAgY29udmVydF9mb250c190b19zcGFuczogZ2V0T3B0aW9uKCdjb252ZXJ0X2ZvbnRzX3RvX3NwYW5zJyksXG4gICAgICAgIGZpeF9saXN0X2VsZW1lbnRzOiBnZXRPcHRpb24oJ2ZpeF9saXN0X2VsZW1lbnRzJyksXG4gICAgICAgIGZvbnRfc2l6ZV9sZWdhY3lfdmFsdWVzOiBnZXRPcHRpb24oJ2ZvbnRfc2l6ZV9sZWdhY3lfdmFsdWVzJyksXG4gICAgICAgIGZvcmNlZF9yb290X2Jsb2NrOiBnZXRPcHRpb24oJ2ZvcmNlZF9yb290X2Jsb2NrJyksXG4gICAgICAgIGZvcmNlZF9yb290X2Jsb2NrX2F0dHJzOiBnZXRPcHRpb24oJ2ZvcmNlZF9yb290X2Jsb2NrX2F0dHJzJyksXG4gICAgICAgIHByZXNlcnZlX2NkYXRhOiBnZXRPcHRpb24oJ3ByZXNlcnZlX2NkYXRhJyksXG4gICAgICAgIHJlbW92ZV90cmFpbGluZ19icnM6IGdldE9wdGlvbigncmVtb3ZlX3RyYWlsaW5nX2JycycpLFxuICAgICAgICBpbmxpbmVfc3R5bGVzOiBnZXRPcHRpb24oJ2lubGluZV9zdHlsZXMnKSxcbiAgICAgICAgcm9vdF9uYW1lOiBnZXRSb290TmFtZShlZGl0b3IpLFxuICAgICAgICBzYW5pdGl6ZTogZ2V0T3B0aW9uKCd4c3Nfc2FuaXRpemF0aW9uJyksXG4gICAgICAgIHZhbGlkYXRlOiB0cnVlLFxuICAgICAgICBibG9iX2NhY2hlOiBibG9iQ2FjaGUsXG4gICAgICAgIGRvY3VtZW50OiBlZGl0b3IuZ2V0RG9jKClcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgbWtTY2hlbWFTZXR0aW5ncyA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBnZXRPcHRpb24gPSBlZGl0b3Iub3B0aW9ucy5nZXQ7XG4gICAgICByZXR1cm4gcmVtb3ZlVW5kZWZpbmVkKHtcbiAgICAgICAgY3VzdG9tX2VsZW1lbnRzOiBnZXRPcHRpb24oJ2N1c3RvbV9lbGVtZW50cycpLFxuICAgICAgICBleHRlbmRlZF92YWxpZF9lbGVtZW50czogZ2V0T3B0aW9uKCdleHRlbmRlZF92YWxpZF9lbGVtZW50cycpLFxuICAgICAgICBpbnZhbGlkX2VsZW1lbnRzOiBnZXRPcHRpb24oJ2ludmFsaWRfZWxlbWVudHMnKSxcbiAgICAgICAgaW52YWxpZF9zdHlsZXM6IGdldE9wdGlvbignaW52YWxpZF9zdHlsZXMnKSxcbiAgICAgICAgc2NoZW1hOiBnZXRPcHRpb24oJ3NjaGVtYScpLFxuICAgICAgICB2YWxpZF9jaGlsZHJlbjogZ2V0T3B0aW9uKCd2YWxpZF9jaGlsZHJlbicpLFxuICAgICAgICB2YWxpZF9jbGFzc2VzOiBnZXRPcHRpb24oJ3ZhbGlkX2NsYXNzZXMnKSxcbiAgICAgICAgdmFsaWRfZWxlbWVudHM6IGdldE9wdGlvbigndmFsaWRfZWxlbWVudHMnKSxcbiAgICAgICAgdmFsaWRfc3R5bGVzOiBnZXRPcHRpb24oJ3ZhbGlkX3N0eWxlcycpLFxuICAgICAgICB2ZXJpZnlfaHRtbDogZ2V0T3B0aW9uKCd2ZXJpZnlfaHRtbCcpLFxuICAgICAgICBwYWRkX2VtcHR5X2Jsb2NrX2lubGluZV9jaGlsZHJlbjogZ2V0T3B0aW9uKCdmb3JtYXRfZW1wdHlfbGluZXMnKVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBta1NlcmlhbGl6ZXJTZXR0aW5ncyA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBnZXRPcHRpb24gPSBlZGl0b3Iub3B0aW9ucy5nZXQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5ta1BhcnNlclNldHRpbmdzKGVkaXRvciksXG4gICAgICAgIC4uLm1rU2NoZW1hU2V0dGluZ3MoZWRpdG9yKSxcbiAgICAgICAgLi4ucmVtb3ZlVW5kZWZpbmVkKHtcbiAgICAgICAgICB1cmxfY29udmVydGVyOiBnZXRPcHRpb24oJ3VybF9jb252ZXJ0ZXInKSxcbiAgICAgICAgICB1cmxfY29udmVydGVyX3Njb3BlOiBnZXRPcHRpb24oJ3VybF9jb252ZXJ0ZXJfc2NvcGUnKSxcbiAgICAgICAgICBlbGVtZW50X2Zvcm1hdDogZ2V0T3B0aW9uKCdlbGVtZW50X2Zvcm1hdCcpLFxuICAgICAgICAgIGVudGl0aWVzOiBnZXRPcHRpb24oJ2VudGl0aWVzJyksXG4gICAgICAgICAgZW50aXR5X2VuY29kaW5nOiBnZXRPcHRpb24oJ2VudGl0eV9lbmNvZGluZycpLFxuICAgICAgICAgIGluZGVudDogZ2V0T3B0aW9uKCdpbmRlbnQnKSxcbiAgICAgICAgICBpbmRlbnRfYWZ0ZXI6IGdldE9wdGlvbignaW5kZW50X2FmdGVyJyksXG4gICAgICAgICAgaW5kZW50X2JlZm9yZTogZ2V0T3B0aW9uKCdpbmRlbnRfYmVmb3JlJylcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGVQYXJzZXIgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgcGFyc2VyID0gRG9tUGFyc2VyKG1rUGFyc2VyU2V0dGluZ3MoZWRpdG9yKSwgZWRpdG9yLnNjaGVtYSk7XG4gICAgICBwYXJzZXIuYWRkQXR0cmlidXRlRmlsdGVyKCdzcmMsaHJlZixzdHlsZSx0YWJpbmRleCcsIChub2RlcywgbmFtZSkgPT4ge1xuICAgICAgICBjb25zdCBkb20gPSBlZGl0b3IuZG9tO1xuICAgICAgICBjb25zdCBpbnRlcm5hbE5hbWUgPSAnZGF0YS1tY2UtJyArIG5hbWU7XG4gICAgICAgIGxldCBpID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgIGxldCB2YWx1ZSA9IG5vZGUuYXR0cihuYW1lKTtcbiAgICAgICAgICBpZiAodmFsdWUgJiYgIW5vZGUuYXR0cihpbnRlcm5hbE5hbWUpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUuaW5kZXhPZignZGF0YTonKSA9PT0gMCB8fCB2YWx1ZS5pbmRleE9mKCdibG9iOicpID09PSAwKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBkb20uc2VyaWFsaXplU3R5bGUoZG9tLnBhcnNlU3R5bGUodmFsdWUpLCBub2RlLm5hbWUpO1xuICAgICAgICAgICAgICBpZiAoIXZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBub2RlLmF0dHIoaW50ZXJuYWxOYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIG5vZGUuYXR0cihuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICd0YWJpbmRleCcpIHtcbiAgICAgICAgICAgICAgbm9kZS5hdHRyKGludGVybmFsTmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgICBub2RlLmF0dHIobmFtZSwgbnVsbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBub2RlLmF0dHIoaW50ZXJuYWxOYW1lLCBlZGl0b3IuY29udmVydFVSTCh2YWx1ZSwgbmFtZSwgbm9kZS5uYW1lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHBhcnNlci5hZGROb2RlRmlsdGVyKCdzY3JpcHQnLCBub2RlcyA9PiB7XG4gICAgICAgIGxldCBpID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgIGNvbnN0IHR5cGUgPSBub2RlLmF0dHIoJ3R5cGUnKSB8fCAnbm8vdHlwZSc7XG4gICAgICAgICAgaWYgKHR5cGUuaW5kZXhPZignbWNlLScpICE9PSAwKSB7XG4gICAgICAgICAgICBub2RlLmF0dHIoJ3R5cGUnLCAnbWNlLScgKyB0eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHNob3VsZFByZXNlcnZlQ0RhdGEoZWRpdG9yKSkge1xuICAgICAgICBwYXJzZXIuYWRkTm9kZUZpbHRlcignI2NkYXRhJywgbm9kZXMgPT4ge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICBsZXQgaSA9IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICBub2RlLnR5cGUgPSA4O1xuICAgICAgICAgICAgbm9kZS5uYW1lID0gJyNjb21tZW50JztcbiAgICAgICAgICAgIG5vZGUudmFsdWUgPSAnW0NEQVRBWycgKyBlZGl0b3IuZG9tLmVuY29kZSgoX2EgPSBub2RlLnZhbHVlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJykgKyAnXV0nO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBwYXJzZXIuYWRkTm9kZUZpbHRlcigncCxoMSxoMixoMyxoNCxoNSxoNixkaXYnLCBub2RlcyA9PiB7XG4gICAgICAgIGxldCBpID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICBjb25zdCBub25FbXB0eUVsZW1lbnRzID0gZWRpdG9yLnNjaGVtYS5nZXROb25FbXB0eUVsZW1lbnRzKCk7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgaWYgKG5vZGUuaXNFbXB0eShub25FbXB0eUVsZW1lbnRzKSAmJiBub2RlLmdldEFsbCgnYnInKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIG5vZGUuYXBwZW5kKG5ldyBBc3ROb2RlKCdicicsIDEpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHBhcnNlcjtcbiAgICB9O1xuICAgIGNvbnN0IGF1dG9Gb2N1cyA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBhdXRvRm9jdXMgPSBnZXRBdXRvRm9jdXMoZWRpdG9yKTtcbiAgICAgIGlmIChhdXRvRm9jdXMpIHtcbiAgICAgICAgRGVsYXkuc2V0RWRpdG9yVGltZW91dChlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICBsZXQgZm9jdXNFZGl0b3I7XG4gICAgICAgICAgaWYgKGF1dG9Gb2N1cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgZm9jdXNFZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvY3VzRWRpdG9yID0gZWRpdG9yLmVkaXRvck1hbmFnZXIuZ2V0KGF1dG9Gb2N1cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmb2N1c0VkaXRvciAmJiAhZm9jdXNFZGl0b3IuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICBmb2N1c0VkaXRvci5mb2N1cygpO1xuICAgICAgICAgICAgZm9jdXNFZGl0b3Iuc2VsZWN0aW9uLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAxMDApO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbW92ZVNlbGVjdGlvblRvRmlyc3RDYXJldFBvc2l0aW9uID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IHJvb3QgPSBlZGl0b3IuZG9tLmdldFJvb3QoKTtcbiAgICAgIGlmICghZWRpdG9yLmlubGluZSAmJiAoIWhhc0FueVJhbmdlcyhlZGl0b3IpIHx8IGVkaXRvci5zZWxlY3Rpb24uZ2V0U3RhcnQodHJ1ZSkgPT09IHJvb3QpKSB7XG4gICAgICAgIGZpcnN0UG9zaXRpb25Jbihyb290KS5lYWNoKHBvcyA9PiB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IHBvcy5nZXROb2RlKCk7XG4gICAgICAgICAgY29uc3QgY2FyZXRQb3MgPSBpc1RhYmxlJDIobm9kZSkgPyBmaXJzdFBvc2l0aW9uSW4obm9kZSkuZ2V0T3IocG9zKSA6IHBvcztcbiAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFJuZyhjYXJldFBvcy50b1JhbmdlKCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGluaXRFZGl0b3IgPSBlZGl0b3IgPT4ge1xuICAgICAgZWRpdG9yLmJpbmRQZW5kaW5nRXZlbnREZWxlZ2F0ZXMoKTtcbiAgICAgIGVkaXRvci5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICBmaXJlSW5pdChlZGl0b3IpO1xuICAgICAgZWRpdG9yLmZvY3VzKHRydWUpO1xuICAgICAgbW92ZVNlbGVjdGlvblRvRmlyc3RDYXJldFBvc2l0aW9uKGVkaXRvcik7XG4gICAgICBlZGl0b3Iubm9kZUNoYW5nZWQoeyBpbml0aWFsOiB0cnVlIH0pO1xuICAgICAgY29uc3QgaW5pdEluc3RhbmNlQ2FsbGJhY2sgPSBnZXRJbml0SW5zdGFuY2VDYWxsYmFjayhlZGl0b3IpO1xuICAgICAgaWYgKGlzRnVuY3Rpb24oaW5pdEluc3RhbmNlQ2FsbGJhY2spKSB7XG4gICAgICAgIGluaXRJbnN0YW5jZUNhbGxiYWNrLmNhbGwoZWRpdG9yLCBlZGl0b3IpO1xuICAgICAgfVxuICAgICAgYXV0b0ZvY3VzKGVkaXRvcik7XG4gICAgfTtcbiAgICBjb25zdCBnZXRTdHlsZVNoZWV0TG9hZGVyJDEgPSBlZGl0b3IgPT4gZWRpdG9yLmlubGluZSA/IGVkaXRvci51aS5zdHlsZVNoZWV0TG9hZGVyIDogZWRpdG9yLmRvbS5zdHlsZVNoZWV0TG9hZGVyO1xuICAgIGNvbnN0IG1ha2VTdHlsZXNoZWV0TG9hZGluZ1Byb21pc2VzID0gKGVkaXRvciwgY3NzLCBmcmFtZWRGb250cykgPT4ge1xuICAgICAgY29uc3QgcHJvbWlzZXMgPSBbZ2V0U3R5bGVTaGVldExvYWRlciQxKGVkaXRvcikubG9hZEFsbChjc3MpXTtcbiAgICAgIGlmIChlZGl0b3IuaW5saW5lKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlcy5jb25jYXQoW2VkaXRvci51aS5zdHlsZVNoZWV0TG9hZGVyLmxvYWRBbGwoZnJhbWVkRm9udHMpXSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBsb2FkQ29udGVudENzcyA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBzdHlsZVNoZWV0TG9hZGVyID0gZ2V0U3R5bGVTaGVldExvYWRlciQxKGVkaXRvcik7XG4gICAgICBjb25zdCBmb250Q3NzID0gZ2V0Rm9udENzcyhlZGl0b3IpO1xuICAgICAgY29uc3QgY3NzID0gZWRpdG9yLmNvbnRlbnRDU1M7XG4gICAgICBjb25zdCByZW1vdmVDc3MgPSAoKSA9PiB7XG4gICAgICAgIHN0eWxlU2hlZXRMb2FkZXIudW5sb2FkQWxsKGNzcyk7XG4gICAgICAgIGlmICghZWRpdG9yLmlubGluZSkge1xuICAgICAgICAgIGVkaXRvci51aS5zdHlsZVNoZWV0TG9hZGVyLnVubG9hZEFsbChmb250Q3NzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGxvYWRlZCA9ICgpID0+IHtcbiAgICAgICAgaWYgKGVkaXRvci5yZW1vdmVkKSB7XG4gICAgICAgICAgcmVtb3ZlQ3NzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWRpdG9yLm9uKCdyZW1vdmUnLCByZW1vdmVDc3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKGVkaXRvci5jb250ZW50U3R5bGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbGV0IGNvbnRlbnRDc3NUZXh0ID0gJyc7XG4gICAgICAgIFRvb2xzLmVhY2goZWRpdG9yLmNvbnRlbnRTdHlsZXMsIHN0eWxlID0+IHtcbiAgICAgICAgICBjb250ZW50Q3NzVGV4dCArPSBzdHlsZSArICdcXHJcXG4nO1xuICAgICAgICB9KTtcbiAgICAgICAgZWRpdG9yLmRvbS5hZGRTdHlsZShjb250ZW50Q3NzVGV4dCk7XG4gICAgICB9XG4gICAgICBjb25zdCBhbGxTdHlsZXNoZWV0cyA9IFByb21pc2UuYWxsKG1ha2VTdHlsZXNoZWV0TG9hZGluZ1Byb21pc2VzKGVkaXRvciwgY3NzLCBmb250Q3NzKSkudGhlbihsb2FkZWQpLmNhdGNoKGxvYWRlZCk7XG4gICAgICBjb25zdCBjb250ZW50U3R5bGUgPSBnZXRDb250ZW50U3R5bGUoZWRpdG9yKTtcbiAgICAgIGlmIChjb250ZW50U3R5bGUpIHtcbiAgICAgICAgYXBwZW5kU3R5bGUoZWRpdG9yLCBjb250ZW50U3R5bGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFsbFN0eWxlc2hlZXRzO1xuICAgIH07XG4gICAgY29uc3QgcHJlSW5pdCA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBkb2MgPSBlZGl0b3IuZ2V0RG9jKCksIGJvZHkgPSBlZGl0b3IuZ2V0Qm9keSgpO1xuICAgICAgZmlyZVByZUluaXQoZWRpdG9yKTtcbiAgICAgIGlmICghc2hvdWxkQnJvd3NlclNwZWxsY2hlY2soZWRpdG9yKSkge1xuICAgICAgICBkb2MuYm9keS5zcGVsbGNoZWNrID0gZmFsc2U7XG4gICAgICAgIERPTSQ2LnNldEF0dHJpYihib2R5LCAnc3BlbGxjaGVjaycsICdmYWxzZScpO1xuICAgICAgfVxuICAgICAgZWRpdG9yLnF1aXJrcyA9IFF1aXJrcyhlZGl0b3IpO1xuICAgICAgZmlyZVBvc3RSZW5kZXIoZWRpdG9yKTtcbiAgICAgIGNvbnN0IGRpcmVjdGlvbmFsaXR5ID0gZ2V0RGlyZWN0aW9uYWxpdHkoZWRpdG9yKTtcbiAgICAgIGlmIChkaXJlY3Rpb25hbGl0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGJvZHkuZGlyID0gZGlyZWN0aW9uYWxpdHk7XG4gICAgICB9XG4gICAgICBjb25zdCBwcm90ZWN0ID0gZ2V0UHJvdGVjdChlZGl0b3IpO1xuICAgICAgaWYgKHByb3RlY3QpIHtcbiAgICAgICAgZWRpdG9yLm9uKCdCZWZvcmVTZXRDb250ZW50JywgZSA9PiB7XG4gICAgICAgICAgVG9vbHMuZWFjaChwcm90ZWN0LCBwYXR0ZXJuID0+IHtcbiAgICAgICAgICAgIGUuY29udGVudCA9IGUuY29udGVudC5yZXBsYWNlKHBhdHRlcm4sIHN0ciA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiAnPCEtLW1jZTpwcm90ZWN0ZWQgJyArIGVzY2FwZShzdHIpICsgJy0tPic7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBlZGl0b3Iub24oJ1NldENvbnRlbnQnLCAoKSA9PiB7XG4gICAgICAgIGVkaXRvci5hZGRWaXN1YWwoZWRpdG9yLmdldEJvZHkoKSk7XG4gICAgICB9KTtcbiAgICAgIGVkaXRvci5vbignY29tcG9zaXRpb25zdGFydCBjb21wb3NpdGlvbmVuZCcsIGUgPT4ge1xuICAgICAgICBlZGl0b3IuY29tcG9zaW5nID0gZS50eXBlID09PSAnY29tcG9zaXRpb25zdGFydCc7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGxvYWRJbml0aWFsQ29udGVudCA9IGVkaXRvciA9PiB7XG4gICAgICBpZiAoIWlzUnRjKGVkaXRvcikpIHtcbiAgICAgICAgZWRpdG9yLmxvYWQoe1xuICAgICAgICAgIGluaXRpYWw6IHRydWUsXG4gICAgICAgICAgZm9ybWF0OiAnaHRtbCdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBlZGl0b3Iuc3RhcnRDb250ZW50ID0gZWRpdG9yLmdldENvbnRlbnQoeyBmb3JtYXQ6ICdyYXcnIH0pO1xuICAgIH07XG4gICAgY29uc3QgaW5pdEVkaXRvcldpdGhJbml0aWFsQ29udGVudCA9IGVkaXRvciA9PiB7XG4gICAgICBpZiAoZWRpdG9yLnJlbW92ZWQgIT09IHRydWUpIHtcbiAgICAgICAgbG9hZEluaXRpYWxDb250ZW50KGVkaXRvcik7XG4gICAgICAgIGluaXRFZGl0b3IoZWRpdG9yKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGNvbnRlbnRCb2R5TG9hZGVkID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldEVsbSA9IGVkaXRvci5nZXRFbGVtZW50KCk7XG4gICAgICBsZXQgZG9jID0gZWRpdG9yLmdldERvYygpO1xuICAgICAgaWYgKGVkaXRvci5pbmxpbmUpIHtcbiAgICAgICAgRE9NJDYuYWRkQ2xhc3ModGFyZ2V0RWxtLCAnbWNlLWNvbnRlbnQtYm9keScpO1xuICAgICAgICBlZGl0b3IuY29udGVudERvY3VtZW50ID0gZG9jID0gZG9jdW1lbnQ7XG4gICAgICAgIGVkaXRvci5jb250ZW50V2luZG93ID0gd2luZG93O1xuICAgICAgICBlZGl0b3IuYm9keUVsZW1lbnQgPSB0YXJnZXRFbG07XG4gICAgICAgIGVkaXRvci5jb250ZW50QXJlYUNvbnRhaW5lciA9IHRhcmdldEVsbTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJvZHkgPSBlZGl0b3IuZ2V0Qm9keSgpO1xuICAgICAgYm9keS5kaXNhYmxlZCA9IHRydWU7XG4gICAgICBlZGl0b3IucmVhZG9ubHkgPSBpc1JlYWRPbmx5JDEoZWRpdG9yKTtcbiAgICAgIGlmICghZWRpdG9yLnJlYWRvbmx5KSB7XG4gICAgICAgIGlmIChlZGl0b3IuaW5saW5lICYmIERPTSQ2LmdldFN0eWxlKGJvZHksICdwb3NpdGlvbicsIHRydWUpID09PSAnc3RhdGljJykge1xuICAgICAgICAgIGJvZHkuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICB9XG4gICAgICAgIGJvZHkuY29udGVudEVkaXRhYmxlID0gJ3RydWUnO1xuICAgICAgfVxuICAgICAgYm9keS5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgZWRpdG9yLmVkaXRvclVwbG9hZCA9IEVkaXRvclVwbG9hZChlZGl0b3IpO1xuICAgICAgZWRpdG9yLnNjaGVtYSA9IFNjaGVtYShta1NjaGVtYVNldHRpbmdzKGVkaXRvcikpO1xuICAgICAgZWRpdG9yLmRvbSA9IERPTVV0aWxzKGRvYywge1xuICAgICAgICBrZWVwX3ZhbHVlczogdHJ1ZSxcbiAgICAgICAgdXJsX2NvbnZlcnRlcjogZWRpdG9yLmNvbnZlcnRVUkwsXG4gICAgICAgIHVybF9jb252ZXJ0ZXJfc2NvcGU6IGVkaXRvcixcbiAgICAgICAgdXBkYXRlX3N0eWxlczogdHJ1ZSxcbiAgICAgICAgcm9vdF9lbGVtZW50OiBlZGl0b3IuaW5saW5lID8gZWRpdG9yLmdldEJvZHkoKSA6IG51bGwsXG4gICAgICAgIGNvbGxlY3Q6IGVkaXRvci5pbmxpbmUsXG4gICAgICAgIHNjaGVtYTogZWRpdG9yLnNjaGVtYSxcbiAgICAgICAgY29udGVudENzc0NvcnM6IHNob3VsZFVzZUNvbnRlbnRDc3NDb3JzKGVkaXRvciksXG4gICAgICAgIHJlZmVycmVyUG9saWN5OiBnZXRSZWZlcnJlclBvbGljeShlZGl0b3IpLFxuICAgICAgICBvblNldEF0dHJpYjogZSA9PiB7XG4gICAgICAgICAgZWRpdG9yLmRpc3BhdGNoKCdTZXRBdHRyaWInLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlZGl0b3IucGFyc2VyID0gY3JlYXRlUGFyc2VyKGVkaXRvcik7XG4gICAgICBlZGl0b3Iuc2VyaWFsaXplciA9IERvbVNlcmlhbGl6ZXIobWtTZXJpYWxpemVyU2V0dGluZ3MoZWRpdG9yKSwgZWRpdG9yKTtcbiAgICAgIGVkaXRvci5zZWxlY3Rpb24gPSBFZGl0b3JTZWxlY3Rpb24oZWRpdG9yLmRvbSwgZWRpdG9yLmdldFdpbigpLCBlZGl0b3Iuc2VyaWFsaXplciwgZWRpdG9yKTtcbiAgICAgIGVkaXRvci5hbm5vdGF0b3IgPSBBbm5vdGF0b3IoZWRpdG9yKTtcbiAgICAgIGVkaXRvci5mb3JtYXR0ZXIgPSBGb3JtYXR0ZXIoZWRpdG9yKTtcbiAgICAgIGVkaXRvci51bmRvTWFuYWdlciA9IFVuZG9NYW5hZ2VyKGVkaXRvcik7XG4gICAgICBlZGl0b3IuX25vZGVDaGFuZ2VEaXNwYXRjaGVyID0gbmV3IE5vZGVDaGFuZ2UoZWRpdG9yKTtcbiAgICAgIGVkaXRvci5fc2VsZWN0aW9uT3ZlcnJpZGVzID0gU2VsZWN0aW9uT3ZlcnJpZGVzKGVkaXRvcik7XG4gICAgICBzZXR1cCRvKGVkaXRvcik7XG4gICAgICBzZXR1cCQ2KGVkaXRvcik7XG4gICAgICBzZXR1cCRtKGVkaXRvcik7XG4gICAgICBpZiAoIWlzUnRjKGVkaXRvcikpIHtcbiAgICAgICAgc2V0dXAkNShlZGl0b3IpO1xuICAgICAgICBzZXR1cCQxKGVkaXRvcik7XG4gICAgICB9XG4gICAgICBjb25zdCBjYXJldCA9IHNldHVwJGIoZWRpdG9yKTtcbiAgICAgIHNldHVwJHAoZWRpdG9yLCBjYXJldCk7XG4gICAgICBzZXR1cCRuKGVkaXRvcik7XG4gICAgICBzZXR1cCRxKGVkaXRvcik7XG4gICAgICBzZXR1cCQ3KGVkaXRvcik7XG4gICAgICBjb25zdCBzZXR1cFJ0Y1RodW5rID0gc2V0dXAkcyhlZGl0b3IpO1xuICAgICAgcHJlSW5pdChlZGl0b3IpO1xuICAgICAgc2V0dXBSdGNUaHVuay5mb2xkKCgpID0+IHtcbiAgICAgICAgbG9hZENvbnRlbnRDc3MoZWRpdG9yKS50aGVuKCgpID0+IGluaXRFZGl0b3JXaXRoSW5pdGlhbENvbnRlbnQoZWRpdG9yKSk7XG4gICAgICB9LCBzZXR1cFJ0YyA9PiB7XG4gICAgICAgIGVkaXRvci5zZXRQcm9ncmVzc1N0YXRlKHRydWUpO1xuICAgICAgICBsb2FkQ29udGVudENzcyhlZGl0b3IpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHNldHVwUnRjKCkudGhlbihfcnRjTW9kZSA9PiB7XG4gICAgICAgICAgICBlZGl0b3Iuc2V0UHJvZ3Jlc3NTdGF0ZShmYWxzZSk7XG4gICAgICAgICAgICBpbml0RWRpdG9yV2l0aEluaXRpYWxDb250ZW50KGVkaXRvcik7XG4gICAgICAgICAgICBiaW5kRXZlbnRzKGVkaXRvcik7XG4gICAgICAgICAgfSwgZXJyID0+IHtcbiAgICAgICAgICAgIGVkaXRvci5ub3RpZmljYXRpb25NYW5hZ2VyLm9wZW4oe1xuICAgICAgICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICAgICAgICB0ZXh0OiBTdHJpbmcoZXJyKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpbml0RWRpdG9yV2l0aEluaXRpYWxDb250ZW50KGVkaXRvcik7XG4gICAgICAgICAgICBiaW5kRXZlbnRzKGVkaXRvcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGZpbHRlciA9IGFsd2F5cztcbiAgICBjb25zdCBiaW5kID0gKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyKSA9PiBiaW5kJDIoZWxlbWVudCwgZXZlbnQsIGZpbHRlciwgaGFuZGxlcik7XG5cbiAgICBjb25zdCBET00kNSA9IERPTVV0aWxzLkRPTTtcbiAgICBjb25zdCBjcmVhdGVJZnJhbWVFbGVtZW50ID0gKGlkLCB0aXRsZSwgY3VzdG9tQXR0cnMsIHRhYmluZGV4KSA9PiB7XG4gICAgICBjb25zdCBpZnJhbWUgPSBTdWdhckVsZW1lbnQuZnJvbVRhZygnaWZyYW1lJyk7XG4gICAgICB0YWJpbmRleC5lYWNoKHQgPT4gc2V0JDMoaWZyYW1lLCAndGFiaW5kZXgnLCB0KSk7XG4gICAgICBzZXRBbGwkMShpZnJhbWUsIGN1c3RvbUF0dHJzKTtcbiAgICAgIHNldEFsbCQxKGlmcmFtZSwge1xuICAgICAgICBpZDogaWQgKyAnX2lmcicsXG4gICAgICAgIGZyYW1lQm9yZGVyOiAnMCcsXG4gICAgICAgIGFsbG93VHJhbnNwYXJlbmN5OiAndHJ1ZScsXG4gICAgICAgIHRpdGxlXG4gICAgICB9KTtcbiAgICAgIGFkZCQyKGlmcmFtZSwgJ3RveC1lZGl0LWFyZWFfX2lmcmFtZScpO1xuICAgICAgcmV0dXJuIGlmcmFtZTtcbiAgICB9O1xuICAgIGNvbnN0IGdldElmcmFtZUh0bWwgPSBlZGl0b3IgPT4ge1xuICAgICAgbGV0IGlmcmFtZUhUTUwgPSBnZXREb2NUeXBlKGVkaXRvcikgKyAnPGh0bWw+PGhlYWQ+JztcbiAgICAgIGlmIChnZXREb2N1bWVudEJhc2VVcmwoZWRpdG9yKSAhPT0gZWRpdG9yLmRvY3VtZW50QmFzZVVybCkge1xuICAgICAgICBpZnJhbWVIVE1MICs9ICc8YmFzZSBocmVmPVwiJyArIGVkaXRvci5kb2N1bWVudEJhc2VVUkkuZ2V0VVJJKCkgKyAnXCIgLz4nO1xuICAgICAgfVxuICAgICAgaWZyYW1lSFRNTCArPSAnPG1ldGEgaHR0cC1lcXVpdj1cIkNvbnRlbnQtVHlwZVwiIGNvbnRlbnQ9XCJ0ZXh0L2h0bWw7IGNoYXJzZXQ9VVRGLThcIiAvPic7XG4gICAgICBjb25zdCBib2R5SWQgPSBnZXRCb2R5SWQoZWRpdG9yKTtcbiAgICAgIGNvbnN0IGJvZHlDbGFzcyA9IGdldEJvZHlDbGFzcyhlZGl0b3IpO1xuICAgICAgY29uc3QgdHJhbnNsYXRlZEFyaWFUZXh0ID0gZWRpdG9yLnRyYW5zbGF0ZShnZXRJZnJhbWVBcmlhVGV4dChlZGl0b3IpKTtcbiAgICAgIGlmIChnZXRDb250ZW50U2VjdXJpdHlQb2xpY3koZWRpdG9yKSkge1xuICAgICAgICBpZnJhbWVIVE1MICs9ICc8bWV0YSBodHRwLWVxdWl2PVwiQ29udGVudC1TZWN1cml0eS1Qb2xpY3lcIiBjb250ZW50PVwiJyArIGdldENvbnRlbnRTZWN1cml0eVBvbGljeShlZGl0b3IpICsgJ1wiIC8+JztcbiAgICAgIH1cbiAgICAgIGlmcmFtZUhUTUwgKz0gJzwvaGVhZD4nICsgYDxib2R5IGlkPVwiJHsgYm9keUlkIH1cIiBjbGFzcz1cIm1jZS1jb250ZW50LWJvZHkgJHsgYm9keUNsYXNzIH1cIiBkYXRhLWlkPVwiJHsgZWRpdG9yLmlkIH1cIiBhcmlhLWxhYmVsPVwiJHsgdHJhbnNsYXRlZEFyaWFUZXh0IH1cIj5gICsgJzxicj4nICsgJzwvYm9keT48L2h0bWw+JztcbiAgICAgIHJldHVybiBpZnJhbWVIVE1MO1xuICAgIH07XG4gICAgY29uc3QgY3JlYXRlSWZyYW1lID0gKGVkaXRvciwgYm94SW5mbykgPT4ge1xuICAgICAgY29uc3QgaWZyYW1lVGl0bGUgPSBlZGl0b3IudHJhbnNsYXRlKCdSaWNoIFRleHQgQXJlYScpO1xuICAgICAgY29uc3QgdGFiaW5kZXggPSBnZXRPcHQoU3VnYXJFbGVtZW50LmZyb21Eb20oZWRpdG9yLmdldEVsZW1lbnQoKSksICd0YWJpbmRleCcpLmJpbmQodG9JbnQpO1xuICAgICAgY29uc3QgaWZyID0gY3JlYXRlSWZyYW1lRWxlbWVudChlZGl0b3IuaWQsIGlmcmFtZVRpdGxlLCBnZXRJZnJhbWVBdHRycyhlZGl0b3IpLCB0YWJpbmRleCkuZG9tO1xuICAgICAgaWZyLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgaWZyLm9ubG9hZCA9IG51bGw7XG4gICAgICAgIGVkaXRvci5kaXNwYXRjaCgnbG9hZCcpO1xuICAgICAgfTtcbiAgICAgIGVkaXRvci5jb250ZW50QXJlYUNvbnRhaW5lciA9IGJveEluZm8uaWZyYW1lQ29udGFpbmVyO1xuICAgICAgZWRpdG9yLmlmcmFtZUVsZW1lbnQgPSBpZnI7XG4gICAgICBlZGl0b3IuaWZyYW1lSFRNTCA9IGdldElmcmFtZUh0bWwoZWRpdG9yKTtcbiAgICAgIERPTSQ1LmFkZChib3hJbmZvLmlmcmFtZUNvbnRhaW5lciwgaWZyKTtcbiAgICB9O1xuICAgIGNvbnN0IHNldHVwSWZyYW1lQm9keSA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBpZnJhbWUgPSBlZGl0b3IuaWZyYW1lRWxlbWVudDtcbiAgICAgIGNvbnN0IGJpbmRlciA9IGJpbmQoU3VnYXJFbGVtZW50LmZyb21Eb20oaWZyYW1lKSwgJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgIGJpbmRlci51bmJpbmQoKTtcbiAgICAgICAgZWRpdG9yLmNvbnRlbnREb2N1bWVudCA9IGlmcmFtZS5jb250ZW50RG9jdW1lbnQ7XG4gICAgICAgIGNvbnRlbnRCb2R5TG9hZGVkKGVkaXRvcik7XG4gICAgICB9KTtcbiAgICAgIGlmIChFbnYuYnJvd3Nlci5pc0ZpcmVmb3goKSkge1xuICAgICAgICBjb25zdCBkb2MgPSBlZGl0b3IuZ2V0RG9jKCk7XG4gICAgICAgIGRvYy5vcGVuKCk7XG4gICAgICAgIGRvYy53cml0ZShlZGl0b3IuaWZyYW1lSFRNTCk7XG4gICAgICAgIGRvYy5jbG9zZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWZyYW1lLnNyY2RvYyA9IGVkaXRvci5pZnJhbWVIVE1MO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaW5pdCQxID0gKGVkaXRvciwgYm94SW5mbykgPT4ge1xuICAgICAgY3JlYXRlSWZyYW1lKGVkaXRvciwgYm94SW5mbyk7XG4gICAgICBpZiAoYm94SW5mby5lZGl0b3JDb250YWluZXIpIHtcbiAgICAgICAgYm94SW5mby5lZGl0b3JDb250YWluZXIuc3R5bGUuZGlzcGxheSA9IGVkaXRvci5vcmdEaXNwbGF5O1xuICAgICAgICBlZGl0b3IuaGlkZGVuID0gRE9NJDUuaXNIaWRkZW4oYm94SW5mby5lZGl0b3JDb250YWluZXIpO1xuICAgICAgfVxuICAgICAgZWRpdG9yLmdldEVsZW1lbnQoKS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgRE9NJDUuc2V0QXR0cmliKGVkaXRvci5pZCwgJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICAgIGVkaXRvci5nZXRFbGVtZW50KCkuc3R5bGUudmlzaWJpbGl0eSA9IGVkaXRvci5vcmdWaXNpYmlsaXR5O1xuICAgICAgc2V0dXBJZnJhbWVCb2R5KGVkaXRvcik7XG4gICAgfTtcblxuICAgIGNvbnN0IERPTSQ0ID0gRE9NVXRpbHMuRE9NO1xuICAgIGNvbnN0IGluaXRQbHVnaW4gPSAoZWRpdG9yLCBpbml0aWFsaXplZFBsdWdpbnMsIHBsdWdpbikgPT4ge1xuICAgICAgY29uc3QgUGx1Z2luID0gUGx1Z2luTWFuYWdlci5nZXQocGx1Z2luKTtcbiAgICAgIGNvbnN0IHBsdWdpblVybCA9IFBsdWdpbk1hbmFnZXIudXJsc1twbHVnaW5dIHx8IGVkaXRvci5kb2N1bWVudEJhc2VVcmwucmVwbGFjZSgvXFwvJC8sICcnKTtcbiAgICAgIHBsdWdpbiA9IFRvb2xzLnRyaW0ocGx1Z2luKTtcbiAgICAgIGlmIChQbHVnaW4gJiYgVG9vbHMuaW5BcnJheShpbml0aWFsaXplZFBsdWdpbnMsIHBsdWdpbikgPT09IC0xKSB7XG4gICAgICAgIGlmIChlZGl0b3IucGx1Z2luc1twbHVnaW5dKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcGx1Z2luSW5zdGFuY2UgPSBQbHVnaW4oZWRpdG9yLCBwbHVnaW5VcmwpIHx8IHt9O1xuICAgICAgICAgIGVkaXRvci5wbHVnaW5zW3BsdWdpbl0gPSBwbHVnaW5JbnN0YW5jZTtcbiAgICAgICAgICBpZiAoaXNGdW5jdGlvbihwbHVnaW5JbnN0YW5jZS5pbml0KSkge1xuICAgICAgICAgICAgcGx1Z2luSW5zdGFuY2UuaW5pdChlZGl0b3IsIHBsdWdpblVybCk7XG4gICAgICAgICAgICBpbml0aWFsaXplZFBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHBsdWdpbkluaXRFcnJvcihlZGl0b3IsIHBsdWdpbiwgZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHRyaW1MZWdhY3lQcmVmaXggPSBuYW1lID0+IHtcbiAgICAgIHJldHVybiBuYW1lLnJlcGxhY2UoL15cXC0vLCAnJyk7XG4gICAgfTtcbiAgICBjb25zdCBpbml0UGx1Z2lucyA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBpbml0aWFsaXplZFBsdWdpbnMgPSBbXTtcbiAgICAgIGVhY2gkZShnZXRQbHVnaW5zKGVkaXRvciksIG5hbWUgPT4ge1xuICAgICAgICBpbml0UGx1Z2luKGVkaXRvciwgaW5pdGlhbGl6ZWRQbHVnaW5zLCB0cmltTGVnYWN5UHJlZml4KG5hbWUpKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgaW5pdEljb25zID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGljb25QYWNrTmFtZSA9IFRvb2xzLnRyaW0oZ2V0SWNvblBhY2tOYW1lKGVkaXRvcikpO1xuICAgICAgY29uc3QgY3VycmVudEljb25zID0gZWRpdG9yLnVpLnJlZ2lzdHJ5LmdldEFsbCgpLmljb25zO1xuICAgICAgY29uc3QgbG9hZEljb25zID0ge1xuICAgICAgICAuLi5JY29uTWFuYWdlci5nZXQoJ2RlZmF1bHQnKS5pY29ucyxcbiAgICAgICAgLi4uSWNvbk1hbmFnZXIuZ2V0KGljb25QYWNrTmFtZSkuaWNvbnNcbiAgICAgIH07XG4gICAgICBlYWNoJGQobG9hZEljb25zLCAoc3ZnRGF0YSwgaWNvbikgPT4ge1xuICAgICAgICBpZiAoIWhhcyQyKGN1cnJlbnRJY29ucywgaWNvbikpIHtcbiAgICAgICAgICBlZGl0b3IudWkucmVnaXN0cnkuYWRkSWNvbihpY29uLCBzdmdEYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBpbml0VGhlbWUgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgdGhlbWUgPSBnZXRUaGVtZShlZGl0b3IpO1xuICAgICAgaWYgKGlzU3RyaW5nKHRoZW1lKSkge1xuICAgICAgICBjb25zdCBUaGVtZSA9IFRoZW1lTWFuYWdlci5nZXQodGhlbWUpO1xuICAgICAgICBlZGl0b3IudGhlbWUgPSBUaGVtZShlZGl0b3IsIFRoZW1lTWFuYWdlci51cmxzW3RoZW1lXSkgfHwge307XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGVkaXRvci50aGVtZS5pbml0KSkge1xuICAgICAgICAgIGVkaXRvci50aGVtZS5pbml0KGVkaXRvciwgVGhlbWVNYW5hZ2VyLnVybHNbdGhlbWVdIHx8IGVkaXRvci5kb2N1bWVudEJhc2VVcmwucmVwbGFjZSgvXFwvJC8sICcnKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkaXRvci50aGVtZSA9IHt9O1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaW5pdE1vZGVsID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IG1vZGVsID0gZ2V0TW9kZWwoZWRpdG9yKTtcbiAgICAgIGNvbnN0IE1vZGVsID0gTW9kZWxNYW5hZ2VyLmdldChtb2RlbCk7XG4gICAgICBlZGl0b3IubW9kZWwgPSBNb2RlbChlZGl0b3IsIE1vZGVsTWFuYWdlci51cmxzW21vZGVsXSk7XG4gICAgfTtcbiAgICBjb25zdCByZW5kZXJGcm9tTG9hZGVkVGhlbWUgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgcmVuZGVyID0gZWRpdG9yLnRoZW1lLnJlbmRlclVJO1xuICAgICAgcmV0dXJuIHJlbmRlciA/IHJlbmRlcigpIDogcmVuZGVyVGhlbWVGYWxzZShlZGl0b3IpO1xuICAgIH07XG4gICAgY29uc3QgcmVuZGVyRnJvbVRoZW1lRnVuYyA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBlbG0gPSBlZGl0b3IuZ2V0RWxlbWVudCgpO1xuICAgICAgY29uc3QgdGhlbWUgPSBnZXRUaGVtZShlZGl0b3IpO1xuICAgICAgY29uc3QgaW5mbyA9IHRoZW1lKGVkaXRvciwgZWxtKTtcbiAgICAgIGlmIChpbmZvLmVkaXRvckNvbnRhaW5lci5ub2RlVHlwZSkge1xuICAgICAgICBpbmZvLmVkaXRvckNvbnRhaW5lci5pZCA9IGluZm8uZWRpdG9yQ29udGFpbmVyLmlkIHx8IGVkaXRvci5pZCArICdfcGFyZW50JztcbiAgICAgIH1cbiAgICAgIGlmIChpbmZvLmlmcmFtZUNvbnRhaW5lciAmJiBpbmZvLmlmcmFtZUNvbnRhaW5lci5ub2RlVHlwZSkge1xuICAgICAgICBpbmZvLmlmcmFtZUNvbnRhaW5lci5pZCA9IGluZm8uaWZyYW1lQ29udGFpbmVyLmlkIHx8IGVkaXRvci5pZCArICdfaWZyYW1lY29udGFpbmVyJztcbiAgICAgIH1cbiAgICAgIGluZm8uaGVpZ2h0ID0gaW5mby5pZnJhbWVIZWlnaHQgPyBpbmZvLmlmcmFtZUhlaWdodCA6IGVsbS5vZmZzZXRIZWlnaHQ7XG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZVRoZW1lRmFsc2VSZXN1bHQgPSAoZWxlbWVudCwgaWZyYW1lKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlZGl0b3JDb250YWluZXI6IGVsZW1lbnQsXG4gICAgICAgIGlmcmFtZUNvbnRhaW5lcjogaWZyYW1lLFxuICAgICAgICBhcGk6IHt9XG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgcmVuZGVyVGhlbWVGYWxzZUlmcmFtZSA9IHRhcmdldEVsZW1lbnQgPT4ge1xuICAgICAgY29uc3QgaWZyYW1lQ29udGFpbmVyID0gRE9NJDQuY3JlYXRlKCdkaXYnKTtcbiAgICAgIERPTSQ0Lmluc2VydEFmdGVyKGlmcmFtZUNvbnRhaW5lciwgdGFyZ2V0RWxlbWVudCk7XG4gICAgICByZXR1cm4gY3JlYXRlVGhlbWVGYWxzZVJlc3VsdChpZnJhbWVDb250YWluZXIsIGlmcmFtZUNvbnRhaW5lcik7XG4gICAgfTtcbiAgICBjb25zdCByZW5kZXJUaGVtZUZhbHNlID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldEVsZW1lbnQgPSBlZGl0b3IuZ2V0RWxlbWVudCgpO1xuICAgICAgcmV0dXJuIGVkaXRvci5pbmxpbmUgPyBjcmVhdGVUaGVtZUZhbHNlUmVzdWx0KG51bGwpIDogcmVuZGVyVGhlbWVGYWxzZUlmcmFtZSh0YXJnZXRFbGVtZW50KTtcbiAgICB9O1xuICAgIGNvbnN0IHJlbmRlclRoZW1lVWkgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgZWxtID0gZWRpdG9yLmdldEVsZW1lbnQoKTtcbiAgICAgIGVkaXRvci5vcmdEaXNwbGF5ID0gZWxtLnN0eWxlLmRpc3BsYXk7XG4gICAgICBpZiAoaXNTdHJpbmcoZ2V0VGhlbWUoZWRpdG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlckZyb21Mb2FkZWRUaGVtZShlZGl0b3IpO1xuICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKGdldFRoZW1lKGVkaXRvcikpKSB7XG4gICAgICAgIHJldHVybiByZW5kZXJGcm9tVGhlbWVGdW5jKGVkaXRvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVuZGVyVGhlbWVGYWxzZShlZGl0b3IpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgYXVnbWVudEVkaXRvclVpQXBpID0gKGVkaXRvciwgYXBpKSA9PiB7XG4gICAgICBjb25zdCB1aUFwaUZhY2FkZSA9IHtcbiAgICAgICAgc2hvdzogT3B0aW9uYWwuZnJvbShhcGkuc2hvdykuZ2V0T3Iobm9vcCksXG4gICAgICAgIGhpZGU6IE9wdGlvbmFsLmZyb20oYXBpLmhpZGUpLmdldE9yKG5vb3ApLFxuICAgICAgICBpc0VuYWJsZWQ6IE9wdGlvbmFsLmZyb20oYXBpLmlzRW5hYmxlZCkuZ2V0T3IoYWx3YXlzKSxcbiAgICAgICAgc2V0RW5hYmxlZDogc3RhdGUgPT4ge1xuICAgICAgICAgIGlmICghZWRpdG9yLm1vZGUuaXNSZWFkT25seSgpKSB7XG4gICAgICAgICAgICBPcHRpb25hbC5mcm9tKGFwaS5zZXRFbmFibGVkKS5lYWNoKGYgPT4gZihzdGF0ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGVkaXRvci51aSA9IHtcbiAgICAgICAgLi4uZWRpdG9yLnVpLFxuICAgICAgICAuLi51aUFwaUZhY2FkZVxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGluaXQgPSBhc3luYyBlZGl0b3IgPT4ge1xuICAgICAgZWRpdG9yLmRpc3BhdGNoKCdTY3JpcHRzTG9hZGVkJyk7XG4gICAgICBpbml0SWNvbnMoZWRpdG9yKTtcbiAgICAgIGluaXRUaGVtZShlZGl0b3IpO1xuICAgICAgaW5pdE1vZGVsKGVkaXRvcik7XG4gICAgICBpbml0UGx1Z2lucyhlZGl0b3IpO1xuICAgICAgY29uc3QgcmVuZGVySW5mbyA9IGF3YWl0IHJlbmRlclRoZW1lVWkoZWRpdG9yKTtcbiAgICAgIGF1Z21lbnRFZGl0b3JVaUFwaShlZGl0b3IsIE9wdGlvbmFsLmZyb20ocmVuZGVySW5mby5hcGkpLmdldE9yKHt9KSk7XG4gICAgICBlZGl0b3IuZWRpdG9yQ29udGFpbmVyID0gcmVuZGVySW5mby5lZGl0b3JDb250YWluZXI7XG4gICAgICBhcHBlbmRDb250ZW50Q3NzRnJvbVNldHRpbmdzKGVkaXRvcik7XG4gICAgICBpZiAoZWRpdG9yLmlubGluZSkge1xuICAgICAgICBjb250ZW50Qm9keUxvYWRlZChlZGl0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdCQxKGVkaXRvciwge1xuICAgICAgICAgIGVkaXRvckNvbnRhaW5lcjogcmVuZGVySW5mby5lZGl0b3JDb250YWluZXIsXG4gICAgICAgICAgaWZyYW1lQ29udGFpbmVyOiByZW5kZXJJbmZvLmlmcmFtZUNvbnRhaW5lclxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgRE9NJDMgPSBET01VdGlscy5ET007XG4gICAgY29uc3QgaGFzU2tpcExvYWRQcmVmaXggPSBuYW1lID0+IG5hbWUuY2hhckF0KDApID09PSAnLSc7XG4gICAgY29uc3QgbG9hZExhbmd1YWdlID0gKHNjcmlwdExvYWRlciwgZWRpdG9yKSA9PiB7XG4gICAgICBjb25zdCBsYW5ndWFnZUNvZGUgPSBnZXRMYW5ndWFnZUNvZGUoZWRpdG9yKTtcbiAgICAgIGNvbnN0IGxhbmd1YWdlVXJsID0gZ2V0TGFuZ3VhZ2VVcmwoZWRpdG9yKTtcbiAgICAgIGlmICghSTE4bi5oYXNDb2RlKGxhbmd1YWdlQ29kZSkgJiYgbGFuZ3VhZ2VDb2RlICE9PSAnZW4nKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGlzTm90RW1wdHkobGFuZ3VhZ2VVcmwpID8gbGFuZ3VhZ2VVcmwgOiBgJHsgZWRpdG9yLmVkaXRvck1hbmFnZXIuYmFzZVVSTCB9L2xhbmdzLyR7IGxhbmd1YWdlQ29kZSB9LmpzYDtcbiAgICAgICAgc2NyaXB0TG9hZGVyLmFkZCh1cmwpLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICBsYW5ndWFnZUxvYWRFcnJvcihlZGl0b3IsIHVybCwgbGFuZ3VhZ2VDb2RlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBsb2FkVGhlbWUgPSAoZWRpdG9yLCBzdWZmaXgpID0+IHtcbiAgICAgIGNvbnN0IHRoZW1lID0gZ2V0VGhlbWUoZWRpdG9yKTtcbiAgICAgIGlmIChpc1N0cmluZyh0aGVtZSkgJiYgIWhhc1NraXBMb2FkUHJlZml4KHRoZW1lKSAmJiAhaGFzJDIoVGhlbWVNYW5hZ2VyLnVybHMsIHRoZW1lKSkge1xuICAgICAgICBjb25zdCB0aGVtZVVybCA9IGdldFRoZW1lVXJsKGVkaXRvcik7XG4gICAgICAgIGNvbnN0IHVybCA9IHRoZW1lVXJsID8gZWRpdG9yLmRvY3VtZW50QmFzZVVSSS50b0Fic29sdXRlKHRoZW1lVXJsKSA6IGB0aGVtZXMvJHsgdGhlbWUgfS90aGVtZSR7IHN1ZmZpeCB9LmpzYDtcbiAgICAgICAgVGhlbWVNYW5hZ2VyLmxvYWQodGhlbWUsIHVybCkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgIHRoZW1lTG9hZEVycm9yKGVkaXRvciwgdXJsLCB0aGVtZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbG9hZE1vZGVsID0gKGVkaXRvciwgc3VmZml4KSA9PiB7XG4gICAgICBjb25zdCBtb2RlbCA9IGdldE1vZGVsKGVkaXRvcik7XG4gICAgICBpZiAobW9kZWwgIT09ICdwbHVnaW4nICYmICFoYXMkMihNb2RlbE1hbmFnZXIudXJscywgbW9kZWwpKSB7XG4gICAgICAgIGNvbnN0IG1vZGVsVXJsID0gZ2V0TW9kZWxVcmwoZWRpdG9yKTtcbiAgICAgICAgY29uc3QgdXJsID0gaXNTdHJpbmcobW9kZWxVcmwpID8gZWRpdG9yLmRvY3VtZW50QmFzZVVSSS50b0Fic29sdXRlKG1vZGVsVXJsKSA6IGBtb2RlbHMvJHsgbW9kZWwgfS9tb2RlbCR7IHN1ZmZpeCB9LmpzYDtcbiAgICAgICAgTW9kZWxNYW5hZ2VyLmxvYWQobW9kZWwsIHVybCkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgIG1vZGVsTG9hZEVycm9yKGVkaXRvciwgdXJsLCBtb2RlbCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZ2V0SWNvbnNVcmxNZXRhRnJvbVVybCA9IGVkaXRvciA9PiBPcHRpb25hbC5mcm9tKGdldEljb25zVXJsKGVkaXRvcikpLmZpbHRlcihpc05vdEVtcHR5KS5tYXAodXJsID0+ICh7XG4gICAgICB1cmwsXG4gICAgICBuYW1lOiBPcHRpb25hbC5ub25lKClcbiAgICB9KSk7XG4gICAgY29uc3QgZ2V0SWNvbnNVcmxNZXRhRnJvbU5hbWUgPSAoZWRpdG9yLCBuYW1lLCBzdWZmaXgpID0+IE9wdGlvbmFsLmZyb20obmFtZSkuZmlsdGVyKG5hbWUgPT4gaXNOb3RFbXB0eShuYW1lKSAmJiAhSWNvbk1hbmFnZXIuaGFzKG5hbWUpKS5tYXAobmFtZSA9PiAoe1xuICAgICAgdXJsOiBgJHsgZWRpdG9yLmVkaXRvck1hbmFnZXIuYmFzZVVSTCB9L2ljb25zLyR7IG5hbWUgfS9pY29ucyR7IHN1ZmZpeCB9LmpzYCxcbiAgICAgIG5hbWU6IE9wdGlvbmFsLnNvbWUobmFtZSlcbiAgICB9KSk7XG4gICAgY29uc3QgbG9hZEljb25zID0gKHNjcmlwdExvYWRlciwgZWRpdG9yLCBzdWZmaXgpID0+IHtcbiAgICAgIGNvbnN0IGRlZmF1bHRJY29uc1VybCA9IGdldEljb25zVXJsTWV0YUZyb21OYW1lKGVkaXRvciwgJ2RlZmF1bHQnLCBzdWZmaXgpO1xuICAgICAgY29uc3QgY3VzdG9tSWNvbnNVcmwgPSBnZXRJY29uc1VybE1ldGFGcm9tVXJsKGVkaXRvcikub3JUaHVuaygoKSA9PiBnZXRJY29uc1VybE1ldGFGcm9tTmFtZShlZGl0b3IsIGdldEljb25QYWNrTmFtZShlZGl0b3IpLCAnJykpO1xuICAgICAgZWFjaCRlKGNhdChbXG4gICAgICAgIGRlZmF1bHRJY29uc1VybCxcbiAgICAgICAgY3VzdG9tSWNvbnNVcmxcbiAgICAgIF0pLCB1cmxNZXRhID0+IHtcbiAgICAgICAgc2NyaXB0TG9hZGVyLmFkZCh1cmxNZXRhLnVybCkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgIGljb25zTG9hZEVycm9yKGVkaXRvciwgdXJsTWV0YS51cmwsIHVybE1ldGEubmFtZS5nZXRPclVuZGVmaW5lZCgpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGxvYWRQbHVnaW5zID0gKGVkaXRvciwgc3VmZml4KSA9PiB7XG4gICAgICBjb25zdCBsb2FkUGx1Z2luID0gKG5hbWUsIHVybCkgPT4ge1xuICAgICAgICBQbHVnaW5NYW5hZ2VyLmxvYWQobmFtZSwgdXJsKS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgcGx1Z2luTG9hZEVycm9yKGVkaXRvciwgdXJsLCBuYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgZWFjaCRkKGdldEV4dGVybmFsUGx1Z2lucyQxKGVkaXRvciksICh1cmwsIG5hbWUpID0+IHtcbiAgICAgICAgbG9hZFBsdWdpbihuYW1lLCB1cmwpO1xuICAgICAgICBlZGl0b3Iub3B0aW9ucy5zZXQoJ3BsdWdpbnMnLCBnZXRQbHVnaW5zKGVkaXRvcikuY29uY2F0KG5hbWUpKTtcbiAgICAgIH0pO1xuICAgICAgZWFjaCRlKGdldFBsdWdpbnMoZWRpdG9yKSwgcGx1Z2luID0+IHtcbiAgICAgICAgcGx1Z2luID0gVG9vbHMudHJpbShwbHVnaW4pO1xuICAgICAgICBpZiAocGx1Z2luICYmICFQbHVnaW5NYW5hZ2VyLnVybHNbcGx1Z2luXSAmJiAhaGFzU2tpcExvYWRQcmVmaXgocGx1Z2luKSkge1xuICAgICAgICAgIGxvYWRQbHVnaW4ocGx1Z2luLCBgcGx1Z2lucy8keyBwbHVnaW4gfS9wbHVnaW4keyBzdWZmaXggfS5qc2ApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGlzVGhlbWVMb2FkZWQgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgdGhlbWUgPSBnZXRUaGVtZShlZGl0b3IpO1xuICAgICAgcmV0dXJuICFpc1N0cmluZyh0aGVtZSkgfHwgaXNOb25OdWxsYWJsZShUaGVtZU1hbmFnZXIuZ2V0KHRoZW1lKSk7XG4gICAgfTtcbiAgICBjb25zdCBpc01vZGVsTG9hZGVkID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IG1vZGVsID0gZ2V0TW9kZWwoZWRpdG9yKTtcbiAgICAgIHJldHVybiBpc05vbk51bGxhYmxlKE1vZGVsTWFuYWdlci5nZXQobW9kZWwpKTtcbiAgICB9O1xuICAgIGNvbnN0IGxvYWRTY3JpcHRzID0gKGVkaXRvciwgc3VmZml4KSA9PiB7XG4gICAgICBjb25zdCBzY3JpcHRMb2FkZXIgPSBTY3JpcHRMb2FkZXIuU2NyaXB0TG9hZGVyO1xuICAgICAgY29uc3QgaW5pdEVkaXRvciA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFlZGl0b3IucmVtb3ZlZCAmJiBpc1RoZW1lTG9hZGVkKGVkaXRvcikgJiYgaXNNb2RlbExvYWRlZChlZGl0b3IpKSB7XG4gICAgICAgICAgaW5pdChlZGl0b3IpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgbG9hZFRoZW1lKGVkaXRvciwgc3VmZml4KTtcbiAgICAgIGxvYWRNb2RlbChlZGl0b3IsIHN1ZmZpeCk7XG4gICAgICBsb2FkTGFuZ3VhZ2Uoc2NyaXB0TG9hZGVyLCBlZGl0b3IpO1xuICAgICAgbG9hZEljb25zKHNjcmlwdExvYWRlciwgZWRpdG9yLCBzdWZmaXgpO1xuICAgICAgbG9hZFBsdWdpbnMoZWRpdG9yLCBzdWZmaXgpO1xuICAgICAgc2NyaXB0TG9hZGVyLmxvYWRRdWV1ZSgpLnRoZW4oaW5pdEVkaXRvciwgaW5pdEVkaXRvcik7XG4gICAgfTtcbiAgICBjb25zdCBnZXRTdHlsZVNoZWV0TG9hZGVyID0gKGVsZW1lbnQsIGVkaXRvcikgPT4gaW5zdGFuY2UuZm9yRWxlbWVudChlbGVtZW50LCB7XG4gICAgICBjb250ZW50Q3NzQ29yczogaGFzQ29udGVudENzc0NvcnMoZWRpdG9yKSxcbiAgICAgIHJlZmVycmVyUG9saWN5OiBnZXRSZWZlcnJlclBvbGljeShlZGl0b3IpXG4gICAgfSk7XG4gICAgY29uc3QgcmVuZGVyID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGlkID0gZWRpdG9yLmlkO1xuICAgICAgSTE4bi5zZXRDb2RlKGdldExhbmd1YWdlQ29kZShlZGl0b3IpKTtcbiAgICAgIGNvbnN0IHJlYWR5SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgRE9NJDMudW5iaW5kKHdpbmRvdywgJ3JlYWR5JywgcmVhZHlIYW5kbGVyKTtcbiAgICAgICAgZWRpdG9yLnJlbmRlcigpO1xuICAgICAgfTtcbiAgICAgIGlmICghRXZlbnRVdGlscy5FdmVudC5kb21Mb2FkZWQpIHtcbiAgICAgICAgRE9NJDMuYmluZCh3aW5kb3csICdyZWFkeScsIHJlYWR5SGFuZGxlcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghZWRpdG9yLmdldEVsZW1lbnQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBlbGVtZW50ID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZWRpdG9yLmdldEVsZW1lbnQoKSk7XG4gICAgICBjb25zdCBzbmFwc2hvdCA9IGNsb25lJDQoZWxlbWVudCk7XG4gICAgICBlZGl0b3Iub24oJ3JlbW92ZScsICgpID0+IHtcbiAgICAgICAgZWFjaHIoZWxlbWVudC5kb20uYXR0cmlidXRlcywgYXR0ciA9PiByZW1vdmUkYihlbGVtZW50LCBhdHRyLm5hbWUpKTtcbiAgICAgICAgc2V0QWxsJDEoZWxlbWVudCwgc25hcHNob3QpO1xuICAgICAgfSk7XG4gICAgICBlZGl0b3IudWkuc3R5bGVTaGVldExvYWRlciA9IGdldFN0eWxlU2hlZXRMb2FkZXIoZWxlbWVudCwgZWRpdG9yKTtcbiAgICAgIGlmICghaXNJbmxpbmUoZWRpdG9yKSkge1xuICAgICAgICBlZGl0b3Iub3JnVmlzaWJpbGl0eSA9IGVkaXRvci5nZXRFbGVtZW50KCkuc3R5bGUudmlzaWJpbGl0eTtcbiAgICAgICAgZWRpdG9yLmdldEVsZW1lbnQoKS5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGl0b3IuaW5saW5lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZvcm0gPSBlZGl0b3IuZ2V0RWxlbWVudCgpLmZvcm0gfHwgRE9NJDMuZ2V0UGFyZW50KGlkLCAnZm9ybScpO1xuICAgICAgaWYgKGZvcm0pIHtcbiAgICAgICAgZWRpdG9yLmZvcm1FbGVtZW50ID0gZm9ybTtcbiAgICAgICAgaWYgKGhhc0hpZGRlbklucHV0KGVkaXRvcikgJiYgIWlzVGV4dGFyZWFPcklucHV0KGVkaXRvci5nZXRFbGVtZW50KCkpKSB7XG4gICAgICAgICAgRE9NJDMuaW5zZXJ0QWZ0ZXIoRE9NJDMuY3JlYXRlKCdpbnB1dCcsIHtcbiAgICAgICAgICAgIHR5cGU6ICdoaWRkZW4nLFxuICAgICAgICAgICAgbmFtZTogaWRcbiAgICAgICAgICB9KSwgaWQpO1xuICAgICAgICAgIGVkaXRvci5oYXNIaWRkZW5JbnB1dCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWRpdG9yLmZvcm1FdmVudERlbGVnYXRlID0gZSA9PiB7XG4gICAgICAgICAgZWRpdG9yLmRpc3BhdGNoKGUudHlwZSwgZSk7XG4gICAgICAgIH07XG4gICAgICAgIERPTSQzLmJpbmQoZm9ybSwgJ3N1Ym1pdCByZXNldCcsIGVkaXRvci5mb3JtRXZlbnREZWxlZ2F0ZSk7XG4gICAgICAgIGVkaXRvci5vbigncmVzZXQnLCAoKSA9PiB7XG4gICAgICAgICAgZWRpdG9yLnJlc2V0Q29udGVudCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHNob3VsZFBhdGNoU3VibWl0KGVkaXRvcikgJiYgIWZvcm0uc3VibWl0Lm5vZGVUeXBlICYmICFmb3JtLnN1Ym1pdC5sZW5ndGggJiYgIWZvcm0uX21jZU9sZFN1Ym1pdCkge1xuICAgICAgICAgIGZvcm0uX21jZU9sZFN1Ym1pdCA9IGZvcm0uc3VibWl0O1xuICAgICAgICAgIGZvcm0uc3VibWl0ID0gKCkgPT4ge1xuICAgICAgICAgICAgZWRpdG9yLmVkaXRvck1hbmFnZXIudHJpZ2dlclNhdmUoKTtcbiAgICAgICAgICAgIGVkaXRvci5zZXREaXJ0eShmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gZm9ybS5fbWNlT2xkU3VibWl0KGZvcm0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVkaXRvci53aW5kb3dNYW5hZ2VyID0gV2luZG93TWFuYWdlcihlZGl0b3IpO1xuICAgICAgZWRpdG9yLm5vdGlmaWNhdGlvbk1hbmFnZXIgPSBOb3RpZmljYXRpb25NYW5hZ2VyKGVkaXRvcik7XG4gICAgICBpZiAoaXNFbmNvZGluZ1htbChlZGl0b3IpKSB7XG4gICAgICAgIGVkaXRvci5vbignR2V0Q29udGVudCcsIGUgPT4ge1xuICAgICAgICAgIGlmIChlLnNhdmUpIHtcbiAgICAgICAgICAgIGUuY29udGVudCA9IERPTSQzLmVuY29kZShlLmNvbnRlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkQWRkRm9ybVN1Ym1pdFRyaWdnZXIoZWRpdG9yKSkge1xuICAgICAgICBlZGl0b3Iub24oJ3N1Ym1pdCcsICgpID0+IHtcbiAgICAgICAgICBpZiAoZWRpdG9yLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICBlZGl0b3Iuc2F2ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkQWRkVW5sb2FkVHJpZ2dlcihlZGl0b3IpKSB7XG4gICAgICAgIGVkaXRvci5fYmVmb3JlVW5sb2FkID0gKCkgPT4ge1xuICAgICAgICAgIGlmIChlZGl0b3IuaW5pdGlhbGl6ZWQgJiYgIWVkaXRvci5kZXN0cm95ZWQgJiYgIWVkaXRvci5pc0hpZGRlbigpKSB7XG4gICAgICAgICAgICBlZGl0b3Iuc2F2ZSh7XG4gICAgICAgICAgICAgIGZvcm1hdDogJ3JhdycsXG4gICAgICAgICAgICAgIG5vX2V2ZW50czogdHJ1ZSxcbiAgICAgICAgICAgICAgc2V0X2RpcnR5OiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBlZGl0b3IuZWRpdG9yTWFuYWdlci5vbignQmVmb3JlVW5sb2FkJywgZWRpdG9yLl9iZWZvcmVVbmxvYWQpO1xuICAgICAgfVxuICAgICAgZWRpdG9yLmVkaXRvck1hbmFnZXIuYWRkKGVkaXRvcik7XG4gICAgICBsb2FkU2NyaXB0cyhlZGl0b3IsIGVkaXRvci5zdWZmaXgpO1xuICAgIH07XG5cbiAgICBjb25zdCBzZWN0aW9uUmVzdWx0ID0gKHNlY3Rpb25zLCBzZXR0aW5ncykgPT4gKHtcbiAgICAgIHNlY3Rpb25zOiBjb25zdGFudChzZWN0aW9ucyksXG4gICAgICBvcHRpb25zOiBjb25zdGFudChzZXR0aW5ncylcbiAgICB9KTtcbiAgICBjb25zdCBkZXZpY2VEZXRlY3Rpb24gPSBkZXRlY3QkMigpLmRldmljZVR5cGU7XG4gICAgY29uc3QgaXNQaG9uZSA9IGRldmljZURldGVjdGlvbi5pc1Bob25lKCk7XG4gICAgY29uc3QgaXNUYWJsZXQgPSBkZXZpY2VEZXRlY3Rpb24uaXNUYWJsZXQoKTtcbiAgICBjb25zdCBub3JtYWxpemVQbHVnaW5zID0gcGx1Z2lucyA9PiB7XG4gICAgICBpZiAoaXNOdWxsYWJsZShwbHVnaW5zKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBwbHVnaW5OYW1lcyA9IGlzQXJyYXkkMShwbHVnaW5zKSA/IHBsdWdpbnMgOiBwbHVnaW5zLnNwbGl0KC9bICxdLyk7XG4gICAgICAgIGNvbnN0IHRyaW1tZWRQbHVnaW5zID0gbWFwJDMocGx1Z2luTmFtZXMsIHRyaW0kMyk7XG4gICAgICAgIHJldHVybiBmaWx0ZXIkNSh0cmltbWVkUGx1Z2lucywgaXNOb3RFbXB0eSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBleHRyYWN0U2VjdGlvbnMgPSAoa2V5cywgb3B0aW9ucykgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYmlmaWx0ZXIob3B0aW9ucywgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5zJDIoa2V5cywga2V5KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNlY3Rpb25SZXN1bHQocmVzdWx0LnQsIHJlc3VsdC5mKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldFNlY3Rpb24gPSAoc2VjdGlvblJlc3VsdCwgbmFtZSwgZGVmYXVsdHMgPSB7fSkgPT4ge1xuICAgICAgY29uc3Qgc2VjdGlvbnMgPSBzZWN0aW9uUmVzdWx0LnNlY3Rpb25zKCk7XG4gICAgICBjb25zdCBzZWN0aW9uT3B0aW9ucyA9IGdldCRhKHNlY3Rpb25zLCBuYW1lKS5nZXRPcih7fSk7XG4gICAgICByZXR1cm4gVG9vbHMuZXh0ZW5kKHt9LCBkZWZhdWx0cywgc2VjdGlvbk9wdGlvbnMpO1xuICAgIH07XG4gICAgY29uc3QgaGFzU2VjdGlvbiA9IChzZWN0aW9uUmVzdWx0LCBuYW1lKSA9PiB7XG4gICAgICByZXR1cm4gaGFzJDIoc2VjdGlvblJlc3VsdC5zZWN0aW9ucygpLCBuYW1lKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldFNlY3Rpb25Db25maWcgPSAoc2VjdGlvblJlc3VsdCwgbmFtZSkgPT4ge1xuICAgICAgcmV0dXJuIGhhc1NlY3Rpb24oc2VjdGlvblJlc3VsdCwgbmFtZSkgPyBzZWN0aW9uUmVzdWx0LnNlY3Rpb25zKClbbmFtZV0gOiB7fTtcbiAgICB9O1xuICAgIGNvbnN0IGdldE1vYmlsZU92ZXJyaWRlT3B0aW9ucyA9IChtb2JpbGVPcHRpb25zLCBpc1Bob25lKSA9PiB7XG4gICAgICBjb25zdCBkZWZhdWx0TW9iaWxlT3B0aW9ucyA9IHtcbiAgICAgICAgdGFibGVfZ3JpZDogZmFsc2UsXG4gICAgICAgIG9iamVjdF9yZXNpemluZzogZmFsc2UsXG4gICAgICAgIHJlc2l6ZTogZmFsc2UsXG4gICAgICAgIHRvb2xiYXJfbW9kZTogZ2V0JGEobW9iaWxlT3B0aW9ucywgJ3Rvb2xiYXJfbW9kZScpLmdldE9yKCdzY3JvbGxpbmcnKSxcbiAgICAgICAgdG9vbGJhcl9zdGlja3k6IGZhbHNlXG4gICAgICB9O1xuICAgICAgY29uc3QgZGVmYXVsdFBob25lT3B0aW9ucyA9IHsgbWVudWJhcjogZmFsc2UgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmRlZmF1bHRNb2JpbGVPcHRpb25zLFxuICAgICAgICAuLi5pc1Bob25lID8gZGVmYXVsdFBob25lT3B0aW9ucyA6IHt9XG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgZ2V0RXh0ZXJuYWxQbHVnaW5zID0gKG92ZXJyaWRlT3B0aW9ucywgb3B0aW9ucykgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgdXNlckRlZmluZWRFeHRlcm5hbFBsdWdpbnMgPSAoX2EgPSBvcHRpb25zLmV4dGVybmFsX3BsdWdpbnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9O1xuICAgICAgaWYgKG92ZXJyaWRlT3B0aW9ucyAmJiBvdmVycmlkZU9wdGlvbnMuZXh0ZXJuYWxfcGx1Z2lucykge1xuICAgICAgICByZXR1cm4gVG9vbHMuZXh0ZW5kKHt9LCBvdmVycmlkZU9wdGlvbnMuZXh0ZXJuYWxfcGx1Z2lucywgdXNlckRlZmluZWRFeHRlcm5hbFBsdWdpbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVzZXJEZWZpbmVkRXh0ZXJuYWxQbHVnaW5zO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgY29tYmluZVBsdWdpbnMgPSAoZm9yY2VkUGx1Z2lucywgcGx1Z2lucykgPT4gW1xuICAgICAgLi4ubm9ybWFsaXplUGx1Z2lucyhmb3JjZWRQbHVnaW5zKSxcbiAgICAgIC4uLm5vcm1hbGl6ZVBsdWdpbnMocGx1Z2lucylcbiAgICBdO1xuICAgIGNvbnN0IGdldFBsYXRmb3JtUGx1Z2lucyA9IChpc01vYmlsZURldmljZSwgc2VjdGlvblJlc3VsdCwgZGVza3RvcFBsdWdpbnMsIG1vYmlsZVBsdWdpbnMpID0+IHtcbiAgICAgIGlmIChpc01vYmlsZURldmljZSAmJiBoYXNTZWN0aW9uKHNlY3Rpb25SZXN1bHQsICdtb2JpbGUnKSkge1xuICAgICAgICByZXR1cm4gbW9iaWxlUGx1Z2lucztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZXNrdG9wUGx1Z2lucztcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHByb2Nlc3NQbHVnaW5zID0gKGlzTW9iaWxlRGV2aWNlLCBzZWN0aW9uUmVzdWx0LCBkZWZhdWx0T3ZlcnJpZGVPcHRpb25zLCBvcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBmb3JjZWRQbHVnaW5zID0gbm9ybWFsaXplUGx1Z2lucyhkZWZhdWx0T3ZlcnJpZGVPcHRpb25zLmZvcmNlZF9wbHVnaW5zKTtcbiAgICAgIGNvbnN0IGRlc2t0b3BQbHVnaW5zID0gbm9ybWFsaXplUGx1Z2lucyhvcHRpb25zLnBsdWdpbnMpO1xuICAgICAgY29uc3QgbW9iaWxlQ29uZmlnID0gZ2V0U2VjdGlvbkNvbmZpZyhzZWN0aW9uUmVzdWx0LCAnbW9iaWxlJyk7XG4gICAgICBjb25zdCBtb2JpbGVQbHVnaW5zID0gbW9iaWxlQ29uZmlnLnBsdWdpbnMgPyBub3JtYWxpemVQbHVnaW5zKG1vYmlsZUNvbmZpZy5wbHVnaW5zKSA6IGRlc2t0b3BQbHVnaW5zO1xuICAgICAgY29uc3QgcGxhdGZvcm1QbHVnaW5zID0gZ2V0UGxhdGZvcm1QbHVnaW5zKGlzTW9iaWxlRGV2aWNlLCBzZWN0aW9uUmVzdWx0LCBkZXNrdG9wUGx1Z2lucywgbW9iaWxlUGx1Z2lucyk7XG4gICAgICBjb25zdCBjb21iaW5lZFBsdWdpbnMgPSBjb21iaW5lUGx1Z2lucyhmb3JjZWRQbHVnaW5zLCBwbGF0Zm9ybVBsdWdpbnMpO1xuICAgICAgcmV0dXJuIFRvb2xzLmV4dGVuZChvcHRpb25zLCB7XG4gICAgICAgIGZvcmNlZF9wbHVnaW5zOiBmb3JjZWRQbHVnaW5zLFxuICAgICAgICBwbHVnaW5zOiBjb21iaW5lZFBsdWdpbnNcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgaXNPbk1vYmlsZSA9IChpc01vYmlsZURldmljZSwgc2VjdGlvblJlc3VsdCkgPT4ge1xuICAgICAgcmV0dXJuIGlzTW9iaWxlRGV2aWNlICYmIGhhc1NlY3Rpb24oc2VjdGlvblJlc3VsdCwgJ21vYmlsZScpO1xuICAgIH07XG4gICAgY29uc3QgY29tYmluZU9wdGlvbnMgPSAoaXNNb2JpbGVEZXZpY2UsIGlzUGhvbmUsIGRlZmF1bHRPcHRpb25zLCBkZWZhdWx0T3ZlcnJpZGVPcHRpb25zLCBvcHRpb25zKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBkZXZpY2VPdmVycmlkZU9wdGlvbnMgPSBpc01vYmlsZURldmljZSA/IHsgbW9iaWxlOiBnZXRNb2JpbGVPdmVycmlkZU9wdGlvbnMoKF9hID0gb3B0aW9ucy5tb2JpbGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9LCBpc1Bob25lKSB9IDoge307XG4gICAgICBjb25zdCBzZWN0aW9uUmVzdWx0ID0gZXh0cmFjdFNlY3Rpb25zKFsnbW9iaWxlJ10sIGRlZXBNZXJnZShkZXZpY2VPdmVycmlkZU9wdGlvbnMsIG9wdGlvbnMpKTtcbiAgICAgIGNvbnN0IGV4dGVuZGVkT3B0aW9ucyA9IFRvb2xzLmV4dGVuZChkZWZhdWx0T3B0aW9ucywgZGVmYXVsdE92ZXJyaWRlT3B0aW9ucywgc2VjdGlvblJlc3VsdC5vcHRpb25zKCksIGlzT25Nb2JpbGUoaXNNb2JpbGVEZXZpY2UsIHNlY3Rpb25SZXN1bHQpID8gZ2V0U2VjdGlvbihzZWN0aW9uUmVzdWx0LCAnbW9iaWxlJykgOiB7fSwgeyBleHRlcm5hbF9wbHVnaW5zOiBnZXRFeHRlcm5hbFBsdWdpbnMoZGVmYXVsdE92ZXJyaWRlT3B0aW9ucywgc2VjdGlvblJlc3VsdC5vcHRpb25zKCkpIH0pO1xuICAgICAgcmV0dXJuIHByb2Nlc3NQbHVnaW5zKGlzTW9iaWxlRGV2aWNlLCBzZWN0aW9uUmVzdWx0LCBkZWZhdWx0T3ZlcnJpZGVPcHRpb25zLCBleHRlbmRlZE9wdGlvbnMpO1xuICAgIH07XG4gICAgY29uc3Qgbm9ybWFsaXplT3B0aW9ucyA9IChkZWZhdWx0T3ZlcnJpZGVPcHRpb25zLCBvcHRpb25zKSA9PiBjb21iaW5lT3B0aW9ucyhpc1Bob25lIHx8IGlzVGFibGV0LCBpc1Bob25lLCBvcHRpb25zLCBkZWZhdWx0T3ZlcnJpZGVPcHRpb25zLCBvcHRpb25zKTtcblxuICAgIGNvbnN0IGFkZFZpc3VhbCA9IChlZGl0b3IsIGVsbSkgPT4gYWRkVmlzdWFsJDEoZWRpdG9yLCBlbG0pO1xuXG4gICAgY29uc3QgcmVnaXN0ZXJFeGVjQ29tbWFuZHMkMyA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCB0b2dnbGVGb3JtYXQgPSAobmFtZSwgdmFsdWUpID0+IHtcbiAgICAgICAgZWRpdG9yLmZvcm1hdHRlci50b2dnbGUobmFtZSwgdmFsdWUpO1xuICAgICAgICBlZGl0b3Iubm9kZUNoYW5nZWQoKTtcbiAgICAgIH07XG4gICAgICBjb25zdCB0b2dnbGVBbGlnbiA9IGFsaWduID0+ICgpID0+IHtcbiAgICAgICAgZWFjaCRlKCdsZWZ0LGNlbnRlcixyaWdodCxqdXN0aWZ5Jy5zcGxpdCgnLCcpLCBuYW1lID0+IHtcbiAgICAgICAgICBpZiAoYWxpZ24gIT09IG5hbWUpIHtcbiAgICAgICAgICAgIGVkaXRvci5mb3JtYXR0ZXIucmVtb3ZlKCdhbGlnbicgKyBuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYWxpZ24gIT09ICdub25lJykge1xuICAgICAgICAgIHRvZ2dsZUZvcm1hdCgnYWxpZ24nICsgYWxpZ24pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZWRpdG9yLmVkaXRvckNvbW1hbmRzLmFkZENvbW1hbmRzKHtcbiAgICAgICAgSnVzdGlmeUxlZnQ6IHRvZ2dsZUFsaWduKCdsZWZ0JyksXG4gICAgICAgIEp1c3RpZnlDZW50ZXI6IHRvZ2dsZUFsaWduKCdjZW50ZXInKSxcbiAgICAgICAgSnVzdGlmeVJpZ2h0OiB0b2dnbGVBbGlnbigncmlnaHQnKSxcbiAgICAgICAgSnVzdGlmeUZ1bGw6IHRvZ2dsZUFsaWduKCdqdXN0aWZ5JyksXG4gICAgICAgIEp1c3RpZnlOb25lOiB0b2dnbGVBbGlnbignbm9uZScpXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHJlZ2lzdGVyUXVlcnlTdGF0ZUNvbW1hbmRzJDEgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgYWxpZ25TdGF0ZXMgPSBuYW1lID0+ICgpID0+IHtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSA/IFtlZGl0b3IuZG9tLmdldFBhcmVudChzZWxlY3Rpb24uZ2V0Tm9kZSgpLCBlZGl0b3IuZG9tLmlzQmxvY2spXSA6IHNlbGVjdGlvbi5nZXRTZWxlY3RlZEJsb2NrcygpO1xuICAgICAgICByZXR1cm4gZXhpc3RzKG5vZGVzLCBub2RlID0+IGlzTm9uTnVsbGFibGUoZWRpdG9yLmZvcm1hdHRlci5tYXRjaE5vZGUobm9kZSwgbmFtZSkpKTtcbiAgICAgIH07XG4gICAgICBlZGl0b3IuZWRpdG9yQ29tbWFuZHMuYWRkQ29tbWFuZHMoe1xuICAgICAgICBKdXN0aWZ5TGVmdDogYWxpZ25TdGF0ZXMoJ2FsaWdubGVmdCcpLFxuICAgICAgICBKdXN0aWZ5Q2VudGVyOiBhbGlnblN0YXRlcygnYWxpZ25jZW50ZXInKSxcbiAgICAgICAgSnVzdGlmeVJpZ2h0OiBhbGlnblN0YXRlcygnYWxpZ25yaWdodCcpLFxuICAgICAgICBKdXN0aWZ5RnVsbDogYWxpZ25TdGF0ZXMoJ2FsaWduanVzdGlmeScpXG4gICAgICB9LCAnc3RhdGUnKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlZ2lzdGVyQ29tbWFuZHMkYSA9IGVkaXRvciA9PiB7XG4gICAgICByZWdpc3RlckV4ZWNDb21tYW5kcyQzKGVkaXRvcik7XG4gICAgICByZWdpc3RlclF1ZXJ5U3RhdGVDb21tYW5kcyQxKGVkaXRvcik7XG4gICAgfTtcblxuICAgIGNvbnN0IHJlZ2lzdGVyQ29tbWFuZHMkOSA9IGVkaXRvciA9PiB7XG4gICAgICBlZGl0b3IuZWRpdG9yQ29tbWFuZHMuYWRkQ29tbWFuZHMoe1xuICAgICAgICAnQ3V0LENvcHksUGFzdGUnOiBjb21tYW5kID0+IHtcbiAgICAgICAgICBjb25zdCBkb2MgPSBlZGl0b3IuZ2V0RG9jKCk7XG4gICAgICAgICAgbGV0IGZhaWxlZDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZG9jLmV4ZWNDb21tYW5kKGNvbW1hbmQpO1xuICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICBmYWlsZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29tbWFuZCA9PT0gJ3Bhc3RlJyAmJiAhZG9jLnF1ZXJ5Q29tbWFuZEVuYWJsZWQoY29tbWFuZCkpIHtcbiAgICAgICAgICAgIGZhaWxlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmYWlsZWQgfHwgIWRvYy5xdWVyeUNvbW1hbmRTdXBwb3J0ZWQoY29tbWFuZCkpIHtcbiAgICAgICAgICAgIGxldCBtc2cgPSBlZGl0b3IudHJhbnNsYXRlKGBZb3VyIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IGRpcmVjdCBhY2Nlc3MgdG8gdGhlIGNsaXBib2FyZC4gYCArICdQbGVhc2UgdXNlIHRoZSBDdHJsK1gvQy9WIGtleWJvYXJkIHNob3J0Y3V0cyBpbnN0ZWFkLicpO1xuICAgICAgICAgICAgaWYgKEVudi5vcy5pc01hY09TKCkgfHwgRW52Lm9zLmlzaU9TKCkpIHtcbiAgICAgICAgICAgICAgbXNnID0gbXNnLnJlcGxhY2UoL0N0cmxcXCsvZywgJ1xcdTIzMTgrJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlZGl0b3Iubm90aWZpY2F0aW9uTWFuYWdlci5vcGVuKHtcbiAgICAgICAgICAgICAgdGV4dDogbXNnLFxuICAgICAgICAgICAgICB0eXBlOiAnZXJyb3InXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCB0cmltT3JQYWRMZWZ0UmlnaHQgPSAoZG9tLCBybmcsIGh0bWwpID0+IHtcbiAgICAgIGNvbnN0IHJvb3QgPSBTdWdhckVsZW1lbnQuZnJvbURvbShkb20uZ2V0Um9vdCgpKTtcbiAgICAgIGlmIChuZWVkc1RvQmVOYnNwTGVmdChyb290LCBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KHJuZykpKSB7XG4gICAgICAgIGh0bWwgPSBodG1sLnJlcGxhY2UoL14gLywgJyZuYnNwOycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaHRtbCA9IGh0bWwucmVwbGFjZSgvXiZuYnNwOy8sICcgJyk7XG4gICAgICB9XG4gICAgICBpZiAobmVlZHNUb0JlTmJzcFJpZ2h0KHJvb3QsIENhcmV0UG9zaXRpb24uZnJvbVJhbmdlRW5kKHJuZykpKSB7XG4gICAgICAgIGh0bWwgPSBodG1sLnJlcGxhY2UoLygmbmJzcDt8ICkoPGJyKCBcXC8pPik/JC8sICcmbmJzcDsnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGh0bWwgPSBodG1sLnJlcGxhY2UoLyZuYnNwOyg8YnIoIFxcLyk/Pik/JC8sICcgJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaHRtbDtcbiAgICB9O1xuXG4gICAgY29uc3QgcHJvY2Vzc1ZhbHVlJDEgPSB2YWx1ZSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBkZXRhaWxzID0gVG9vbHMuZXh0ZW5kKHtcbiAgICAgICAgICBwYXN0ZTogdmFsdWUucGFzdGUsXG4gICAgICAgICAgZGF0YTogeyBwYXN0ZTogdmFsdWUucGFzdGUgfVxuICAgICAgICB9LCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY29udGVudDogdmFsdWUuY29udGVudCxcbiAgICAgICAgICBkZXRhaWxzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb250ZW50OiB2YWx1ZSxcbiAgICAgICAgZGV0YWlsczoge31cbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCB0cmltT3JQYWQgPSAoZWRpdG9yLCB2YWx1ZSkgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb207XG4gICAgICBpZiAoL14gfCAkLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdHJpbU9yUGFkTGVmdFJpZ2h0KGRvbSwgc2VsZWN0aW9uLmdldFJuZygpLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpbnNlcnRBdENhcmV0ID0gKGVkaXRvciwgdmFsdWUpID0+IHtcbiAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uLmlzRWRpdGFibGUoKSkge1xuICAgICAgICBjb25zdCB7Y29udGVudCwgZGV0YWlsc30gPSBwcm9jZXNzVmFsdWUkMSh2YWx1ZSk7XG4gICAgICAgIHByZVByb2Nlc3NTZXRDb250ZW50KGVkaXRvciwge1xuICAgICAgICAgIC4uLmRldGFpbHMsXG4gICAgICAgICAgY29udGVudDogdHJpbU9yUGFkKGVkaXRvciwgY29udGVudCksXG4gICAgICAgICAgZm9ybWF0OiAnaHRtbCcsXG4gICAgICAgICAgc2V0OiBmYWxzZSxcbiAgICAgICAgICBzZWxlY3Rpb246IHRydWVcbiAgICAgICAgfSkuZWFjaChhcmdzID0+IHtcbiAgICAgICAgICBjb25zdCBpbnNlcnRlZENvbnRlbnQgPSBpbnNlcnRDb250ZW50JDEoZWRpdG9yLCBhcmdzLmNvbnRlbnQsIGRldGFpbHMpO1xuICAgICAgICAgIHBvc3RQcm9jZXNzU2V0Q29udGVudChlZGl0b3IsIGluc2VydGVkQ29udGVudCwgYXJncyk7XG4gICAgICAgICAgZWRpdG9yLmFkZFZpc3VhbCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgcmVnaXN0ZXJDb21tYW5kcyQ4ID0gZWRpdG9yID0+IHtcbiAgICAgIGVkaXRvci5lZGl0b3JDb21tYW5kcy5hZGRDb21tYW5kcyh7XG4gICAgICAgIG1jZUNsZWFudXA6ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBibSA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Qm9va21hcmsoKTtcbiAgICAgICAgICBlZGl0b3Iuc2V0Q29udGVudChlZGl0b3IuZ2V0Q29udGVudCgpKTtcbiAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLm1vdmVUb0Jvb2ttYXJrKGJtKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5zZXJ0SW1hZ2U6IChfY29tbWFuZCwgX3VpLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgIGluc2VydEF0Q2FyZXQoZWRpdG9yLCBlZGl0b3IuZG9tLmNyZWF0ZUhUTUwoJ2ltZycsIHsgc3JjOiB2YWx1ZSB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIGluc2VydEhvcml6b250YWxSdWxlOiAoKSA9PiB7XG4gICAgICAgICAgZWRpdG9yLmV4ZWNDb21tYW5kKCdtY2VJbnNlcnRDb250ZW50JywgZmFsc2UsICc8aHI+Jyk7XG4gICAgICAgIH0sXG4gICAgICAgIGluc2VydFRleHQ6IChfY29tbWFuZCwgX3VpLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgIGluc2VydEF0Q2FyZXQoZWRpdG9yLCBlZGl0b3IuZG9tLmVuY29kZSh2YWx1ZSkpO1xuICAgICAgICB9LFxuICAgICAgICBpbnNlcnRIVE1MOiAoX2NvbW1hbmQsIF91aSwgdmFsdWUpID0+IHtcbiAgICAgICAgICBpbnNlcnRBdENhcmV0KGVkaXRvciwgdmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBtY2VJbnNlcnRDb250ZW50OiAoX2NvbW1hbmQsIF91aSwgdmFsdWUpID0+IHtcbiAgICAgICAgICBpbnNlcnRBdENhcmV0KGVkaXRvciwgdmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBtY2VTZXRDb250ZW50OiAoX2NvbW1hbmQsIF91aSwgdmFsdWUpID0+IHtcbiAgICAgICAgICBlZGl0b3Iuc2V0Q29udGVudCh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG1jZVJlcGxhY2VDb250ZW50OiAoX2NvbW1hbmQsIF91aSwgdmFsdWUpID0+IHtcbiAgICAgICAgICBlZGl0b3IuZXhlY0NvbW1hbmQoJ21jZUluc2VydENvbnRlbnQnLCBmYWxzZSwgdmFsdWUucmVwbGFjZSgvXFx7XFwkc2VsZWN0aW9uXFx9L2csIGVkaXRvci5zZWxlY3Rpb24uZ2V0Q29udGVudCh7IGZvcm1hdDogJ3RleHQnIH0pKSk7XG4gICAgICAgIH0sXG4gICAgICAgIG1jZU5ld0RvY3VtZW50OiAoKSA9PiB7XG4gICAgICAgICAgZWRpdG9yLnNldENvbnRlbnQoJycpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgbGVnYWN5UHJvcE5hbWVzID0ge1xuICAgICAgJ2ZvbnQtc2l6ZSc6ICdzaXplJyxcbiAgICAgICdmb250LWZhbWlseSc6ICdmYWNlJ1xuICAgIH07XG4gICAgY29uc3QgaXNGb250ID0gaXNUYWcoJ2ZvbnQnKTtcbiAgICBjb25zdCBnZXRTcGVjaWZpZWRGb250UHJvcCA9IChwcm9wTmFtZSwgcm9vdEVsbSwgZWxtKSA9PiB7XG4gICAgICBjb25zdCBnZXRQcm9wZXJ0eSA9IGVsbSA9PiBnZXRSYXcoZWxtLCBwcm9wTmFtZSkub3JUaHVuaygoKSA9PiB7XG4gICAgICAgIGlmIChpc0ZvbnQoZWxtKSkge1xuICAgICAgICAgIHJldHVybiBnZXQkYShsZWdhY3lQcm9wTmFtZXMsIHByb3BOYW1lKS5iaW5kKGxlZ2FjeVByb3BOYW1lID0+IGdldE9wdChlbG0sIGxlZ2FjeVByb3BOYW1lKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCBpc1Jvb3QgPSBlbG0gPT4gZXEoU3VnYXJFbGVtZW50LmZyb21Eb20ocm9vdEVsbSksIGVsbSk7XG4gICAgICByZXR1cm4gY2xvc2VzdCQxKFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVsbSksIGVsbSA9PiBnZXRQcm9wZXJ0eShlbG0pLCBpc1Jvb3QpO1xuICAgIH07XG4gICAgY29uc3Qgbm9ybWFsaXplRm9udEZhbWlseSA9IGZvbnRGYW1pbHkgPT4gZm9udEZhbWlseS5yZXBsYWNlKC9bXFwnXFxcIlxcXFxdL2csICcnKS5yZXBsYWNlKC8sXFxzKy9nLCAnLCcpO1xuICAgIGNvbnN0IGdldENvbXB1dGVkRm9udFByb3AgPSAocHJvcE5hbWUsIGVsbSkgPT4gT3B0aW9uYWwuZnJvbShET01VdGlscy5ET00uZ2V0U3R5bGUoZWxtLCBwcm9wTmFtZSwgdHJ1ZSkpO1xuICAgIGNvbnN0IGdldEZvbnRQcm9wID0gcHJvcE5hbWUgPT4gKHJvb3RFbG0sIGVsbSkgPT4gT3B0aW9uYWwuZnJvbShlbG0pLm1hcChTdWdhckVsZW1lbnQuZnJvbURvbSkuZmlsdGVyKGlzRWxlbWVudCQ3KS5iaW5kKGVsZW1lbnQgPT4gZ2V0U3BlY2lmaWVkRm9udFByb3AocHJvcE5hbWUsIHJvb3RFbG0sIGVsZW1lbnQuZG9tKS5vcihnZXRDb21wdXRlZEZvbnRQcm9wKHByb3BOYW1lLCBlbGVtZW50LmRvbSkpKS5nZXRPcignJyk7XG4gICAgY29uc3QgZ2V0Rm9udFNpemUgPSBnZXRGb250UHJvcCgnZm9udC1zaXplJyk7XG4gICAgY29uc3QgZ2V0Rm9udEZhbWlseSA9IGNvbXBvc2Uobm9ybWFsaXplRm9udEZhbWlseSwgZ2V0Rm9udFByb3AoJ2ZvbnQtZmFtaWx5JykpO1xuXG4gICAgY29uc3QgZmluZEZpcnN0Q2FyZXRFbGVtZW50ID0gZWRpdG9yID0+IGZpcnN0UG9zaXRpb25JbihlZGl0b3IuZ2V0Qm9keSgpKS5iaW5kKGNhcmV0ID0+IHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGNhcmV0LmNvbnRhaW5lcigpO1xuICAgICAgcmV0dXJuIE9wdGlvbmFsLmZyb20oaXNUZXh0JGEoY29udGFpbmVyKSA/IGNvbnRhaW5lci5wYXJlbnROb2RlIDogY29udGFpbmVyKTtcbiAgICB9KTtcbiAgICBjb25zdCBnZXRDYXJldEVsZW1lbnQgPSBlZGl0b3IgPT4gT3B0aW9uYWwuZnJvbShlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpKS5iaW5kKHJuZyA9PiB7XG4gICAgICBjb25zdCByb290ID0gZWRpdG9yLmdldEJvZHkoKTtcbiAgICAgIGNvbnN0IGF0U3RhcnRPZk5vZGUgPSBybmcuc3RhcnRDb250YWluZXIgPT09IHJvb3QgJiYgcm5nLnN0YXJ0T2Zmc2V0ID09PSAwO1xuICAgICAgcmV0dXJuIGF0U3RhcnRPZk5vZGUgPyBPcHRpb25hbC5ub25lKCkgOiBPcHRpb25hbC5mcm9tKGVkaXRvci5zZWxlY3Rpb24uZ2V0U3RhcnQodHJ1ZSkpO1xuICAgIH0pO1xuICAgIGNvbnN0IGJpbmRSYW5nZSA9IChlZGl0b3IsIGJpbmRlcikgPT4gZ2V0Q2FyZXRFbGVtZW50KGVkaXRvcikub3JUaHVuayhjdXJyeShmaW5kRmlyc3RDYXJldEVsZW1lbnQsIGVkaXRvcikpLm1hcChTdWdhckVsZW1lbnQuZnJvbURvbSkuZmlsdGVyKGlzRWxlbWVudCQ3KS5iaW5kKGJpbmRlcik7XG4gICAgY29uc3QgbWFwUmFuZ2UgPSAoZWRpdG9yLCBtYXBwZXIpID0+IGJpbmRSYW5nZShlZGl0b3IsIGNvbXBvc2UxKE9wdGlvbmFsLnNvbWUsIG1hcHBlcikpO1xuXG4gICAgY29uc3QgZnJvbUZvbnRTaXplTnVtYmVyID0gKGVkaXRvciwgdmFsdWUpID0+IHtcbiAgICAgIGlmICgvXlswLTkuXSskLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICBjb25zdCBmb250U2l6ZU51bWJlciA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgICAgIGlmIChmb250U2l6ZU51bWJlciA+PSAxICYmIGZvbnRTaXplTnVtYmVyIDw9IDcpIHtcbiAgICAgICAgICBjb25zdCBmb250U2l6ZXMgPSBnZXRGb250U3R5bGVWYWx1ZXMoZWRpdG9yKTtcbiAgICAgICAgICBjb25zdCBmb250Q2xhc3NlcyA9IGdldEZvbnRTaXplQ2xhc3NlcyhlZGl0b3IpO1xuICAgICAgICAgIGlmIChmb250Q2xhc3Nlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9udENsYXNzZXNbZm9udFNpemVOdW1iZXIgLSAxXSB8fCB2YWx1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZvbnRTaXplc1tmb250U2l6ZU51bWJlciAtIDFdIHx8IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG5vcm1hbGl6ZUZvbnROYW1lcyA9IGZvbnQgPT4ge1xuICAgICAgY29uc3QgZm9udHMgPSBmb250LnNwbGl0KC9cXHMqLFxccyovKTtcbiAgICAgIHJldHVybiBtYXAkMyhmb250cywgZm9udCA9PiB7XG4gICAgICAgIGlmIChmb250LmluZGV4T2YoJyAnKSAhPT0gLTEgJiYgIShzdGFydHNXaXRoKGZvbnQsICdcIicpIHx8IHN0YXJ0c1dpdGgoZm9udCwgYCdgKSkpIHtcbiAgICAgICAgICByZXR1cm4gYCckeyBmb250IH0nYDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZm9udDtcbiAgICAgICAgfVxuICAgICAgfSkuam9pbignLCcpO1xuICAgIH07XG4gICAgY29uc3QgZm9udE5hbWVBY3Rpb24gPSAoZWRpdG9yLCB2YWx1ZSkgPT4ge1xuICAgICAgY29uc3QgZm9udCA9IGZyb21Gb250U2l6ZU51bWJlcihlZGl0b3IsIHZhbHVlKTtcbiAgICAgIGVkaXRvci5mb3JtYXR0ZXIudG9nZ2xlKCdmb250bmFtZScsIHsgdmFsdWU6IG5vcm1hbGl6ZUZvbnROYW1lcyhmb250KSB9KTtcbiAgICAgIGVkaXRvci5ub2RlQ2hhbmdlZCgpO1xuICAgIH07XG4gICAgY29uc3QgZm9udE5hbWVRdWVyeSA9IGVkaXRvciA9PiBtYXBSYW5nZShlZGl0b3IsIGVsbSA9PiBnZXRGb250RmFtaWx5KGVkaXRvci5nZXRCb2R5KCksIGVsbS5kb20pKS5nZXRPcignJyk7XG4gICAgY29uc3QgZm9udFNpemVBY3Rpb24gPSAoZWRpdG9yLCB2YWx1ZSkgPT4ge1xuICAgICAgZWRpdG9yLmZvcm1hdHRlci50b2dnbGUoJ2ZvbnRzaXplJywgeyB2YWx1ZTogZnJvbUZvbnRTaXplTnVtYmVyKGVkaXRvciwgdmFsdWUpIH0pO1xuICAgICAgZWRpdG9yLm5vZGVDaGFuZ2VkKCk7XG4gICAgfTtcbiAgICBjb25zdCBmb250U2l6ZVF1ZXJ5ID0gZWRpdG9yID0+IG1hcFJhbmdlKGVkaXRvciwgZWxtID0+IGdldEZvbnRTaXplKGVkaXRvci5nZXRCb2R5KCksIGVsbS5kb20pKS5nZXRPcignJyk7XG5cbiAgICBjb25zdCBsaW5lSGVpZ2h0UXVlcnkgPSBlZGl0b3IgPT4gbWFwUmFuZ2UoZWRpdG9yLCBlbG0gPT4ge1xuICAgICAgY29uc3Qgcm9vdCA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRCb2R5KCkpO1xuICAgICAgY29uc3Qgc3BlY2lmaWVkU3R5bGUgPSBjbG9zZXN0JDEoZWxtLCBlbG0gPT4gZ2V0UmF3KGVsbSwgJ2xpbmUtaGVpZ2h0JyksIGN1cnJ5KGVxLCByb290KSk7XG4gICAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBsaW5lSGVpZ2h0ID0gcGFyc2VGbG9hdChnZXQkNyhlbG0sICdsaW5lLWhlaWdodCcpKTtcbiAgICAgICAgY29uc3QgZm9udFNpemUgPSBwYXJzZUZsb2F0KGdldCQ3KGVsbSwgJ2ZvbnQtc2l6ZScpKTtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhsaW5lSGVpZ2h0IC8gZm9udFNpemUpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBzcGVjaWZpZWRTdHlsZS5nZXRPclRodW5rKGNvbXB1dGVkU3R5bGUpO1xuICAgIH0pLmdldE9yKCcnKTtcbiAgICBjb25zdCBsaW5lSGVpZ2h0QWN0aW9uID0gKGVkaXRvciwgbGluZUhlaWdodCkgPT4ge1xuICAgICAgZWRpdG9yLmZvcm1hdHRlci50b2dnbGUoJ2xpbmVoZWlnaHQnLCB7IHZhbHVlOiBTdHJpbmcobGluZUhlaWdodCkgfSk7XG4gICAgICBlZGl0b3Iubm9kZUNoYW5nZWQoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgcmVnaXN0ZXJFeGVjQ29tbWFuZHMkMiA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCB0b2dnbGVGb3JtYXQgPSAobmFtZSwgdmFsdWUpID0+IHtcbiAgICAgICAgZWRpdG9yLmZvcm1hdHRlci50b2dnbGUobmFtZSwgdmFsdWUpO1xuICAgICAgICBlZGl0b3Iubm9kZUNoYW5nZWQoKTtcbiAgICAgIH07XG4gICAgICBlZGl0b3IuZWRpdG9yQ29tbWFuZHMuYWRkQ29tbWFuZHMoe1xuICAgICAgICAnQm9sZCxJdGFsaWMsVW5kZXJsaW5lLFN0cmlrZXRocm91Z2gsU3VwZXJzY3JpcHQsU3Vic2NyaXB0JzogY29tbWFuZCA9PiB7XG4gICAgICAgICAgdG9nZ2xlRm9ybWF0KGNvbW1hbmQpO1xuICAgICAgICB9LFxuICAgICAgICAnRm9yZUNvbG9yLEhpbGl0ZUNvbG9yJzogKGNvbW1hbmQsIF91aSwgdmFsdWUpID0+IHtcbiAgICAgICAgICB0b2dnbGVGb3JtYXQoY29tbWFuZCwgeyB2YWx1ZSB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgJ0JhY2tDb2xvcic6IChfY29tbWFuZCwgX3VpLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgIHRvZ2dsZUZvcm1hdCgnaGlsaXRlY29sb3InLCB7IHZhbHVlIH0pO1xuICAgICAgICB9LFxuICAgICAgICAnRm9udE5hbWUnOiAoX2NvbW1hbmQsIF91aSwgdmFsdWUpID0+IHtcbiAgICAgICAgICBmb250TmFtZUFjdGlvbihlZGl0b3IsIHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgJ0ZvbnRTaXplJzogKF9jb21tYW5kLCBfdWksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgZm9udFNpemVBY3Rpb24oZWRpdG9yLCB2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgICdMaW5lSGVpZ2h0JzogKF9jb21tYW5kLCBfdWksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgbGluZUhlaWdodEFjdGlvbihlZGl0b3IsIHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgJ0xhbmcnOiAoY29tbWFuZCwgX3VpLCBsYW5nKSA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIHRvZ2dsZUZvcm1hdChjb21tYW5kLCB7XG4gICAgICAgICAgICB2YWx1ZTogbGFuZy5jb2RlLFxuICAgICAgICAgICAgY3VzdG9tVmFsdWU6IChfYSA9IGxhbmcuY3VzdG9tQ29kZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbFxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAnUmVtb3ZlRm9ybWF0JzogY29tbWFuZCA9PiB7XG4gICAgICAgICAgZWRpdG9yLmZvcm1hdHRlci5yZW1vdmUoY29tbWFuZCk7XG4gICAgICAgIH0sXG4gICAgICAgICdtY2VCbG9ja1F1b3RlJzogKCkgPT4ge1xuICAgICAgICAgIHRvZ2dsZUZvcm1hdCgnYmxvY2txdW90ZScpO1xuICAgICAgICB9LFxuICAgICAgICAnRm9ybWF0QmxvY2snOiAoX2NvbW1hbmQsIF91aSwgdmFsdWUpID0+IHtcbiAgICAgICAgICB0b2dnbGVGb3JtYXQoaXNTdHJpbmcodmFsdWUpID8gdmFsdWUgOiAncCcpO1xuICAgICAgICB9LFxuICAgICAgICAnbWNlVG9nZ2xlRm9ybWF0JzogKF9jb21tYW5kLCBfdWksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgdG9nZ2xlRm9ybWF0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCByZWdpc3RlclF1ZXJ5VmFsdWVDb21tYW5kcyA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBpc0Zvcm1hdE1hdGNoID0gbmFtZSA9PiBlZGl0b3IuZm9ybWF0dGVyLm1hdGNoKG5hbWUpO1xuICAgICAgZWRpdG9yLmVkaXRvckNvbW1hbmRzLmFkZENvbW1hbmRzKHtcbiAgICAgICAgJ0JvbGQsSXRhbGljLFVuZGVybGluZSxTdHJpa2V0aHJvdWdoLFN1cGVyc2NyaXB0LFN1YnNjcmlwdCc6IGNvbW1hbmQgPT4gaXNGb3JtYXRNYXRjaChjb21tYW5kKSxcbiAgICAgICAgJ21jZUJsb2NrUXVvdGUnOiAoKSA9PiBpc0Zvcm1hdE1hdGNoKCdibG9ja3F1b3RlJylcbiAgICAgIH0sICdzdGF0ZScpO1xuICAgICAgZWRpdG9yLmVkaXRvckNvbW1hbmRzLmFkZFF1ZXJ5VmFsdWVIYW5kbGVyKCdGb250TmFtZScsICgpID0+IGZvbnROYW1lUXVlcnkoZWRpdG9yKSk7XG4gICAgICBlZGl0b3IuZWRpdG9yQ29tbWFuZHMuYWRkUXVlcnlWYWx1ZUhhbmRsZXIoJ0ZvbnRTaXplJywgKCkgPT4gZm9udFNpemVRdWVyeShlZGl0b3IpKTtcbiAgICAgIGVkaXRvci5lZGl0b3JDb21tYW5kcy5hZGRRdWVyeVZhbHVlSGFuZGxlcignTGluZUhlaWdodCcsICgpID0+IGxpbmVIZWlnaHRRdWVyeShlZGl0b3IpKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlZ2lzdGVyQ29tbWFuZHMkNyA9IGVkaXRvciA9PiB7XG4gICAgICByZWdpc3RlckV4ZWNDb21tYW5kcyQyKGVkaXRvcik7XG4gICAgICByZWdpc3RlclF1ZXJ5VmFsdWVDb21tYW5kcyhlZGl0b3IpO1xuICAgIH07XG5cbiAgICBjb25zdCByZWdpc3RlckNvbW1hbmRzJDYgPSBlZGl0b3IgPT4ge1xuICAgICAgZWRpdG9yLmVkaXRvckNvbW1hbmRzLmFkZENvbW1hbmRzKHtcbiAgICAgICAgbWNlQWRkVW5kb0xldmVsOiAoKSA9PiB7XG4gICAgICAgICAgZWRpdG9yLnVuZG9NYW5hZ2VyLmFkZCgpO1xuICAgICAgICB9LFxuICAgICAgICBtY2VFbmRVbmRvTGV2ZWw6ICgpID0+IHtcbiAgICAgICAgICBlZGl0b3IudW5kb01hbmFnZXIuYWRkKCk7XG4gICAgICAgIH0sXG4gICAgICAgIFVuZG86ICgpID0+IHtcbiAgICAgICAgICBlZGl0b3IudW5kb01hbmFnZXIudW5kbygpO1xuICAgICAgICB9LFxuICAgICAgICBSZWRvOiAoKSA9PiB7XG4gICAgICAgICAgZWRpdG9yLnVuZG9NYW5hZ2VyLnJlZG8oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHJlZ2lzdGVyQ29tbWFuZHMkNSA9IGVkaXRvciA9PiB7XG4gICAgICBlZGl0b3IuZWRpdG9yQ29tbWFuZHMuYWRkQ29tbWFuZHMoe1xuICAgICAgICBJbmRlbnQ6ICgpID0+IHtcbiAgICAgICAgICBpbmRlbnQoZWRpdG9yKTtcbiAgICAgICAgfSxcbiAgICAgICAgT3V0ZGVudDogKCkgPT4ge1xuICAgICAgICAgIG91dGRlbnQoZWRpdG9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlZGl0b3IuZWRpdG9yQ29tbWFuZHMuYWRkQ29tbWFuZHMoeyBPdXRkZW50OiAoKSA9PiBjYW5PdXRkZW50KGVkaXRvcikgfSwgJ3N0YXRlJyk7XG4gICAgfTtcblxuICAgIGNvbnN0IHJlZ2lzdGVyQ29tbWFuZHMkNCA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBhcHBseUxpbmtUb1NlbGVjdGlvbiA9IChfY29tbWFuZCwgX3VpLCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBsaW5rRGV0YWlscyA9IGlzU3RyaW5nKHZhbHVlKSA/IHsgaHJlZjogdmFsdWUgfSA6IHZhbHVlO1xuICAgICAgICBjb25zdCBhbmNob3IgPSBlZGl0b3IuZG9tLmdldFBhcmVudChlZGl0b3Iuc2VsZWN0aW9uLmdldE5vZGUoKSwgJ2EnKTtcbiAgICAgICAgaWYgKGlzT2JqZWN0KGxpbmtEZXRhaWxzKSAmJiBpc1N0cmluZyhsaW5rRGV0YWlscy5ocmVmKSkge1xuICAgICAgICAgIGxpbmtEZXRhaWxzLmhyZWYgPSBsaW5rRGV0YWlscy5ocmVmLnJlcGxhY2UoLyAvZywgJyUyMCcpO1xuICAgICAgICAgIGlmICghYW5jaG9yIHx8ICFsaW5rRGV0YWlscy5ocmVmKSB7XG4gICAgICAgICAgICBlZGl0b3IuZm9ybWF0dGVyLnJlbW92ZSgnbGluaycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobGlua0RldGFpbHMuaHJlZikge1xuICAgICAgICAgICAgZWRpdG9yLmZvcm1hdHRlci5hcHBseSgnbGluaycsIGxpbmtEZXRhaWxzLCBhbmNob3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGVkaXRvci5lZGl0b3JDb21tYW5kcy5hZGRDb21tYW5kcyh7XG4gICAgICAgIHVubGluazogKCkgPT4ge1xuICAgICAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsbSA9IGVkaXRvci5kb20uZ2V0UGFyZW50KGVkaXRvci5zZWxlY3Rpb24uZ2V0U3RhcnQoKSwgJ2EnKTtcbiAgICAgICAgICAgIGlmIChlbG0pIHtcbiAgICAgICAgICAgICAgZWRpdG9yLmRvbS5yZW1vdmUoZWxtLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWRpdG9yLmZvcm1hdHRlci5yZW1vdmUoJ2xpbmsnKTtcbiAgICAgICAgfSxcbiAgICAgICAgbWNlSW5zZXJ0TGluazogYXBwbHlMaW5rVG9TZWxlY3Rpb24sXG4gICAgICAgIGNyZWF0ZUxpbms6IGFwcGx5TGlua1RvU2VsZWN0aW9uXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgcmVnaXN0ZXJFeGVjQ29tbWFuZHMkMSA9IGVkaXRvciA9PiB7XG4gICAgICBlZGl0b3IuZWRpdG9yQ29tbWFuZHMuYWRkQ29tbWFuZHMoe1xuICAgICAgICAnSW5zZXJ0VW5vcmRlcmVkTGlzdCxJbnNlcnRPcmRlcmVkTGlzdCc6IGNvbW1hbmQgPT4ge1xuICAgICAgICAgIGVkaXRvci5nZXREb2MoKS5leGVjQ29tbWFuZChjb21tYW5kKTtcbiAgICAgICAgICBjb25zdCBsaXN0RWxtID0gZWRpdG9yLmRvbS5nZXRQYXJlbnQoZWRpdG9yLnNlbGVjdGlvbi5nZXROb2RlKCksICdvbCx1bCcpO1xuICAgICAgICAgIGlmIChsaXN0RWxtKSB7XG4gICAgICAgICAgICBjb25zdCBsaXN0UGFyZW50ID0gbGlzdEVsbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgaWYgKGxpc3RQYXJlbnQgJiYgL14oSFsxLTZdfFB8QUREUkVTU3xQUkUpJC8udGVzdChsaXN0UGFyZW50Lm5vZGVOYW1lKSkge1xuICAgICAgICAgICAgICBjb25zdCBibSA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Qm9va21hcmsoKTtcbiAgICAgICAgICAgICAgZWRpdG9yLmRvbS5zcGxpdChsaXN0UGFyZW50LCBsaXN0RWxtKTtcbiAgICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5tb3ZlVG9Cb29rbWFyayhibSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHJlZ2lzdGVyUXVlcnlTdGF0ZUNvbW1hbmRzID0gZWRpdG9yID0+IHtcbiAgICAgIGVkaXRvci5lZGl0b3JDb21tYW5kcy5hZGRDb21tYW5kcyh7XG4gICAgICAgICdJbnNlcnRVbm9yZGVyZWRMaXN0LEluc2VydE9yZGVyZWRMaXN0JzogY29tbWFuZCA9PiB7XG4gICAgICAgICAgY29uc3QgbGlzdCA9IGVkaXRvci5kb20uZ2V0UGFyZW50KGVkaXRvci5zZWxlY3Rpb24uZ2V0Tm9kZSgpLCAndWwsb2wnKTtcbiAgICAgICAgICByZXR1cm4gbGlzdCAmJiAoY29tbWFuZCA9PT0gJ2luc2VydHVub3JkZXJlZGxpc3QnICYmIGxpc3QudGFnTmFtZSA9PT0gJ1VMJyB8fCBjb21tYW5kID09PSAnaW5zZXJ0b3JkZXJlZGxpc3QnICYmIGxpc3QudGFnTmFtZSA9PT0gJ09MJyk7XG4gICAgICAgIH1cbiAgICAgIH0sICdzdGF0ZScpO1xuICAgIH07XG4gICAgY29uc3QgcmVnaXN0ZXJDb21tYW5kcyQzID0gZWRpdG9yID0+IHtcbiAgICAgIHJlZ2lzdGVyRXhlY0NvbW1hbmRzJDEoZWRpdG9yKTtcbiAgICAgIHJlZ2lzdGVyUXVlcnlTdGF0ZUNvbW1hbmRzKGVkaXRvcik7XG4gICAgfTtcblxuICAgIGNvbnN0IHJlZ2lzdGVyQ29tbWFuZHMkMiA9IGVkaXRvciA9PiB7XG4gICAgICBlZGl0b3IuZWRpdG9yQ29tbWFuZHMuYWRkQ29tbWFuZHMoe1xuICAgICAgICBpbnNlcnRQYXJhZ3JhcGg6ICgpID0+IHtcbiAgICAgICAgICBpbnNlcnRCcmVhayhibG9ja2JyZWFrLCBlZGl0b3IpO1xuICAgICAgICB9LFxuICAgICAgICBtY2VJbnNlcnROZXdMaW5lOiAoX2NvbW1hbmQsIF91aSwgdmFsdWUpID0+IHtcbiAgICAgICAgICBpbnNlcnQoZWRpdG9yLCB2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIEluc2VydExpbmVCcmVhazogKF9jb21tYW5kLCBfdWksIF92YWx1ZSkgPT4ge1xuICAgICAgICAgIGluc2VydEJyZWFrKGxpbmVicmVhaywgZWRpdG9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHJlZ2lzdGVyQ29tbWFuZHMkMSA9IGVkaXRvciA9PiB7XG4gICAgICBlZGl0b3IuZWRpdG9yQ29tbWFuZHMuYWRkQ29tbWFuZHMoe1xuICAgICAgICBtY2VTZWxlY3ROb2RlRGVwdGg6IChfY29tbWFuZCwgX3VpLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgIGxldCBjb3VudGVyID0gMDtcbiAgICAgICAgICBlZGl0b3IuZG9tLmdldFBhcmVudChlZGl0b3Iuc2VsZWN0aW9uLmdldE5vZGUoKSwgbm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNFbGVtZW50JDYobm9kZSkgJiYgY291bnRlcisrID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNlbGVjdChub2RlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgZWRpdG9yLmdldEJvZHkoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIG1jZVNlbGVjdE5vZGU6IChfY29tbWFuZCwgX3VpLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2VsZWN0KHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2VsZWN0QWxsOiAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgZWRpdGluZ0hvc3QgPSBlZGl0b3IuZG9tLmdldFBhcmVudChlZGl0b3Iuc2VsZWN0aW9uLmdldFN0YXJ0KCksIGlzQ29udGVudEVkaXRhYmxlVHJ1ZSQzKTtcbiAgICAgICAgICBpZiAoZWRpdGluZ0hvc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHJuZyA9IGVkaXRvci5kb20uY3JlYXRlUm5nKCk7XG4gICAgICAgICAgICBybmcuc2VsZWN0Tm9kZUNvbnRlbnRzKGVkaXRpbmdIb3N0KTtcbiAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Um5nKHJuZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgcmVnaXN0ZXJFeGVjQ29tbWFuZHMgPSBlZGl0b3IgPT4ge1xuICAgICAgZWRpdG9yLmVkaXRvckNvbW1hbmRzLmFkZENvbW1hbmRzKHtcbiAgICAgICAgbWNlUmVtb3ZlTm9kZTogKF9jb21tYW5kLCBfdWksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDAgPyB2YWx1ZSA6IGVkaXRvci5zZWxlY3Rpb24uZ2V0Tm9kZSgpO1xuICAgICAgICAgIGlmIChub2RlICE9PSBlZGl0b3IuZ2V0Qm9keSgpKSB7XG4gICAgICAgICAgICBjb25zdCBibSA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Qm9va21hcmsoKTtcbiAgICAgICAgICAgIGVkaXRvci5kb20ucmVtb3ZlKG5vZGUsIHRydWUpO1xuICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5tb3ZlVG9Cb29rbWFyayhibSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtY2VQcmludDogKCkgPT4ge1xuICAgICAgICAgIGVkaXRvci5nZXRXaW4oKS5wcmludCgpO1xuICAgICAgICB9LFxuICAgICAgICBtY2VGb2N1czogKF9jb21tYW5kLCBfdWksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgZm9jdXMoZWRpdG9yLCB2YWx1ZSA9PT0gdHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG1jZVRvZ2dsZVZpc3VhbEFpZDogKCkgPT4ge1xuICAgICAgICAgIGVkaXRvci5oYXNWaXN1YWwgPSAhZWRpdG9yLmhhc1Zpc3VhbDtcbiAgICAgICAgICBlZGl0b3IuYWRkVmlzdWFsKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgcmVnaXN0ZXJDb21tYW5kcyA9IGVkaXRvciA9PiB7XG4gICAgICByZWdpc3RlckNvbW1hbmRzJGEoZWRpdG9yKTtcbiAgICAgIHJlZ2lzdGVyQ29tbWFuZHMkOShlZGl0b3IpO1xuICAgICAgcmVnaXN0ZXJDb21tYW5kcyQ2KGVkaXRvcik7XG4gICAgICByZWdpc3RlckNvbW1hbmRzJDEoZWRpdG9yKTtcbiAgICAgIHJlZ2lzdGVyQ29tbWFuZHMkOChlZGl0b3IpO1xuICAgICAgcmVnaXN0ZXJDb21tYW5kcyQ0KGVkaXRvcik7XG4gICAgICByZWdpc3RlckNvbW1hbmRzJDUoZWRpdG9yKTtcbiAgICAgIHJlZ2lzdGVyQ29tbWFuZHMkMihlZGl0b3IpO1xuICAgICAgcmVnaXN0ZXJDb21tYW5kcyQzKGVkaXRvcik7XG4gICAgICByZWdpc3RlckNvbW1hbmRzJDcoZWRpdG9yKTtcbiAgICAgIHJlZ2lzdGVyRXhlY0NvbW1hbmRzKGVkaXRvcik7XG4gICAgfTtcblxuICAgIGNvbnN0IHNlbGVjdGlvblNhZmVDb21tYW5kcyA9IFsndG9nZ2xldmlldyddO1xuICAgIGNvbnN0IGlzU2VsZWN0aW9uU2FmZUNvbW1hbmQgPSBjb21tYW5kID0+IGNvbnRhaW5zJDIoc2VsZWN0aW9uU2FmZUNvbW1hbmRzLCBjb21tYW5kLnRvTG93ZXJDYXNlKCkpO1xuICAgIGNsYXNzIEVkaXRvckNvbW1hbmRzIHtcbiAgICAgIGNvbnN0cnVjdG9yKGVkaXRvcikge1xuICAgICAgICB0aGlzLmNvbW1hbmRzID0ge1xuICAgICAgICAgIHN0YXRlOiB7fSxcbiAgICAgICAgICBleGVjOiB7fSxcbiAgICAgICAgICB2YWx1ZToge31cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgICB9XG4gICAgICBleGVjQ29tbWFuZChjb21tYW5kLCB1aSA9IGZhbHNlLCB2YWx1ZSwgYXJncykge1xuICAgICAgICBjb25zdCBlZGl0b3IgPSB0aGlzLmVkaXRvcjtcbiAgICAgICAgY29uc3QgbG93ZXJDYXNlQ29tbWFuZCA9IGNvbW1hbmQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3Qgc2tpcEZvY3VzID0gYXJncyA9PT0gbnVsbCB8fCBhcmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcmdzLnNraXBfZm9jdXM7XG4gICAgICAgIGlmIChlZGl0b3IucmVtb3ZlZCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG93ZXJDYXNlQ29tbWFuZCAhPT0gJ21jZWZvY3VzJykge1xuICAgICAgICAgIGlmICghL14obWNlQWRkVW5kb0xldmVsfG1jZUVuZFVuZG9MZXZlbCkkL2kudGVzdChsb3dlckNhc2VDb21tYW5kKSAmJiAhc2tpcEZvY3VzKSB7XG4gICAgICAgICAgICBlZGl0b3IuZm9jdXMoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdG9yZShlZGl0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBldmVudEFyZ3MgPSBlZGl0b3IuZGlzcGF0Y2goJ0JlZm9yZUV4ZWNDb21tYW5kJywge1xuICAgICAgICAgIGNvbW1hbmQsXG4gICAgICAgICAgdWksXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChldmVudEFyZ3MuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnVuYyA9IHRoaXMuY29tbWFuZHMuZXhlY1tsb3dlckNhc2VDb21tYW5kXTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgICBmdW5jKGxvd2VyQ2FzZUNvbW1hbmQsIHVpLCB2YWx1ZSk7XG4gICAgICAgICAgZWRpdG9yLmRpc3BhdGNoKCdFeGVjQ29tbWFuZCcsIHtcbiAgICAgICAgICAgIGNvbW1hbmQsXG4gICAgICAgICAgICB1aSxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcXVlcnlDb21tYW5kU3RhdGUoY29tbWFuZCkge1xuICAgICAgICBpZiAoIWlzU2VsZWN0aW9uU2FmZUNvbW1hbmQoY29tbWFuZCkgJiYgdGhpcy5lZGl0b3IucXVpcmtzLmlzSGlkZGVuKCkgfHwgdGhpcy5lZGl0b3IucmVtb3ZlZCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsb3dlckNhc2VDb21tYW5kID0gY29tbWFuZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBmdW5jID0gdGhpcy5jb21tYW5kcy5zdGF0ZVtsb3dlckNhc2VDb21tYW5kXTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYyhsb3dlckNhc2VDb21tYW5kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBxdWVyeUNvbW1hbmRWYWx1ZShjb21tYW5kKSB7XG4gICAgICAgIGlmICghaXNTZWxlY3Rpb25TYWZlQ29tbWFuZChjb21tYW5kKSAmJiB0aGlzLmVkaXRvci5xdWlya3MuaXNIaWRkZW4oKSB8fCB0aGlzLmVkaXRvci5yZW1vdmVkKSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxvd2VyQ2FzZUNvbW1hbmQgPSBjb21tYW5kLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGZ1bmMgPSB0aGlzLmNvbW1hbmRzLnZhbHVlW2xvd2VyQ2FzZUNvbW1hbmRdO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICAgIHJldHVybiBmdW5jKGxvd2VyQ2FzZUNvbW1hbmQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIGFkZENvbW1hbmRzKGNvbW1hbmRMaXN0LCB0eXBlID0gJ2V4ZWMnKSB7XG4gICAgICAgIGNvbnN0IGNvbW1hbmRzID0gdGhpcy5jb21tYW5kcztcbiAgICAgICAgZWFjaCRkKGNvbW1hbmRMaXN0LCAoY2FsbGJhY2ssIGNvbW1hbmQpID0+IHtcbiAgICAgICAgICBlYWNoJGUoY29tbWFuZC50b0xvd2VyQ2FzZSgpLnNwbGl0KCcsJyksIGNvbW1hbmQgPT4ge1xuICAgICAgICAgICAgY29tbWFuZHNbdHlwZV1bY29tbWFuZF0gPSBjYWxsYmFjaztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBhZGRDb21tYW5kKGNvbW1hbmQsIGNhbGxiYWNrLCBzY29wZSkge1xuICAgICAgICBjb25zdCBsb3dlckNhc2VDb21tYW5kID0gY29tbWFuZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB0aGlzLmNvbW1hbmRzLmV4ZWNbbG93ZXJDYXNlQ29tbWFuZF0gPSAoX2NvbW1hbmQsIHVpLCB2YWx1ZSkgPT4gY2FsbGJhY2suY2FsbChzY29wZSAhPT0gbnVsbCAmJiBzY29wZSAhPT0gdm9pZCAwID8gc2NvcGUgOiB0aGlzLmVkaXRvciwgdWksIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5Q29tbWFuZFN1cHBvcnRlZChjb21tYW5kKSB7XG4gICAgICAgIGNvbnN0IGxvd2VyQ2FzZUNvbW1hbmQgPSBjb21tYW5kLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICh0aGlzLmNvbW1hbmRzLmV4ZWNbbG93ZXJDYXNlQ29tbWFuZF0pIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFkZFF1ZXJ5U3RhdGVIYW5kbGVyKGNvbW1hbmQsIGNhbGxiYWNrLCBzY29wZSkge1xuICAgICAgICB0aGlzLmNvbW1hbmRzLnN0YXRlW2NvbW1hbmQudG9Mb3dlckNhc2UoKV0gPSAoKSA9PiBjYWxsYmFjay5jYWxsKHNjb3BlICE9PSBudWxsICYmIHNjb3BlICE9PSB2b2lkIDAgPyBzY29wZSA6IHRoaXMuZWRpdG9yKTtcbiAgICAgIH1cbiAgICAgIGFkZFF1ZXJ5VmFsdWVIYW5kbGVyKGNvbW1hbmQsIGNhbGxiYWNrLCBzY29wZSkge1xuICAgICAgICB0aGlzLmNvbW1hbmRzLnZhbHVlW2NvbW1hbmQudG9Mb3dlckNhc2UoKV0gPSAoKSA9PiBjYWxsYmFjay5jYWxsKHNjb3BlICE9PSBudWxsICYmIHNjb3BlICE9PSB2b2lkIDAgPyBzY29wZSA6IHRoaXMuZWRpdG9yKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBpbnRlcm5hbENvbnRlbnRFZGl0YWJsZUF0dHIgPSAnZGF0YS1tY2UtY29udGVudGVkaXRhYmxlJztcbiAgICBjb25zdCB0b2dnbGVDbGFzcyA9IChlbG0sIGNscywgc3RhdGUpID0+IHtcbiAgICAgIGlmIChoYXMoZWxtLCBjbHMpICYmICFzdGF0ZSkge1xuICAgICAgICByZW1vdmUkOChlbG0sIGNscyk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlKSB7XG4gICAgICAgIGFkZCQyKGVsbSwgY2xzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNldEVkaXRvckNvbW1hbmRTdGF0ZSA9IChlZGl0b3IsIGNtZCwgc3RhdGUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGVkaXRvci5nZXREb2MoKS5leGVjQ29tbWFuZChjbWQsIGZhbHNlLCBTdHJpbmcoc3RhdGUpKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzZXRDb250ZW50RWRpdGFibGUgPSAoZWxtLCBzdGF0ZSkgPT4ge1xuICAgICAgZWxtLmRvbS5jb250ZW50RWRpdGFibGUgPSBzdGF0ZSA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gICAgfTtcbiAgICBjb25zdCBzd2l0Y2hPZmZDb250ZW50RWRpdGFibGVUcnVlID0gZWxtID0+IHtcbiAgICAgIGVhY2gkZShkZXNjZW5kYW50cyhlbG0sICcqW2NvbnRlbnRlZGl0YWJsZT1cInRydWVcIl0nKSwgZWxtID0+IHtcbiAgICAgICAgc2V0JDMoZWxtLCBpbnRlcm5hbENvbnRlbnRFZGl0YWJsZUF0dHIsICd0cnVlJyk7XG4gICAgICAgIHNldENvbnRlbnRFZGl0YWJsZShlbG0sIGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3Qgc3dpdGNoT25Db250ZW50RWRpdGFibGVUcnVlID0gZWxtID0+IHtcbiAgICAgIGVhY2gkZShkZXNjZW5kYW50cyhlbG0sIGAqWyR7IGludGVybmFsQ29udGVudEVkaXRhYmxlQXR0ciB9PVwidHJ1ZVwiXWApLCBlbG0gPT4ge1xuICAgICAgICByZW1vdmUkYihlbG0sIGludGVybmFsQ29udGVudEVkaXRhYmxlQXR0cik7XG4gICAgICAgIHNldENvbnRlbnRFZGl0YWJsZShlbG0sIHRydWUpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVGYWtlU2VsZWN0aW9uID0gZWRpdG9yID0+IHtcbiAgICAgIE9wdGlvbmFsLmZyb20oZWRpdG9yLnNlbGVjdGlvbi5nZXROb2RlKCkpLmVhY2goZWxtID0+IHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1tY2Utc2VsZWN0ZWQnKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgcmVzdG9yZUZha2VTZWxlY3Rpb24gPSBlZGl0b3IgPT4ge1xuICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRSbmcoZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKSk7XG4gICAgfTtcbiAgICBjb25zdCB0b2dnbGVSZWFkT25seSA9IChlZGl0b3IsIHN0YXRlKSA9PiB7XG4gICAgICBjb25zdCBib2R5ID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZWRpdG9yLmdldEJvZHkoKSk7XG4gICAgICB0b2dnbGVDbGFzcyhib2R5LCAnbWNlLWNvbnRlbnQtcmVhZG9ubHknLCBzdGF0ZSk7XG4gICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5jb250cm9sU2VsZWN0aW9uLmhpZGVSZXNpemVSZWN0KCk7XG4gICAgICAgIGVkaXRvci5fc2VsZWN0aW9uT3ZlcnJpZGVzLmhpZGVGYWtlQ2FyZXQoKTtcbiAgICAgICAgcmVtb3ZlRmFrZVNlbGVjdGlvbihlZGl0b3IpO1xuICAgICAgICBlZGl0b3IucmVhZG9ubHkgPSB0cnVlO1xuICAgICAgICBzZXRDb250ZW50RWRpdGFibGUoYm9keSwgZmFsc2UpO1xuICAgICAgICBzd2l0Y2hPZmZDb250ZW50RWRpdGFibGVUcnVlKGJvZHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRpdG9yLnJlYWRvbmx5ID0gZmFsc2U7XG4gICAgICAgIHNldENvbnRlbnRFZGl0YWJsZShib2R5LCB0cnVlKTtcbiAgICAgICAgc3dpdGNoT25Db250ZW50RWRpdGFibGVUcnVlKGJvZHkpO1xuICAgICAgICBzZXRFZGl0b3JDb21tYW5kU3RhdGUoZWRpdG9yLCAnU3R5bGVXaXRoQ1NTJywgZmFsc2UpO1xuICAgICAgICBzZXRFZGl0b3JDb21tYW5kU3RhdGUoZWRpdG9yLCAnZW5hYmxlSW5saW5lVGFibGVFZGl0aW5nJywgZmFsc2UpO1xuICAgICAgICBzZXRFZGl0b3JDb21tYW5kU3RhdGUoZWRpdG9yLCAnZW5hYmxlT2JqZWN0UmVzaXppbmcnLCBmYWxzZSk7XG4gICAgICAgIGlmIChoYXNFZGl0b3JPclVpRm9jdXMoZWRpdG9yKSkge1xuICAgICAgICAgIGVkaXRvci5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3RvcmVGYWtlU2VsZWN0aW9uKGVkaXRvcik7XG4gICAgICAgIGVkaXRvci5ub2RlQ2hhbmdlZCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaXNSZWFkT25seSA9IGVkaXRvciA9PiBlZGl0b3IucmVhZG9ubHk7XG4gICAgY29uc3QgcmVnaXN0ZXJGaWx0ZXJzID0gZWRpdG9yID0+IHtcbiAgICAgIGVkaXRvci5wYXJzZXIuYWRkQXR0cmlidXRlRmlsdGVyKCdjb250ZW50ZWRpdGFibGUnLCBub2RlcyA9PiB7XG4gICAgICAgIGlmIChpc1JlYWRPbmx5KGVkaXRvcikpIHtcbiAgICAgICAgICBlYWNoJGUobm9kZXMsIG5vZGUgPT4ge1xuICAgICAgICAgICAgbm9kZS5hdHRyKGludGVybmFsQ29udGVudEVkaXRhYmxlQXR0ciwgbm9kZS5hdHRyKCdjb250ZW50ZWRpdGFibGUnKSk7XG4gICAgICAgICAgICBub2RlLmF0dHIoJ2NvbnRlbnRlZGl0YWJsZScsICdmYWxzZScpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGVkaXRvci5zZXJpYWxpemVyLmFkZEF0dHJpYnV0ZUZpbHRlcihpbnRlcm5hbENvbnRlbnRFZGl0YWJsZUF0dHIsIG5vZGVzID0+IHtcbiAgICAgICAgaWYgKGlzUmVhZE9ubHkoZWRpdG9yKSkge1xuICAgICAgICAgIGVhY2gkZShub2Rlcywgbm9kZSA9PiB7XG4gICAgICAgICAgICBub2RlLmF0dHIoJ2NvbnRlbnRlZGl0YWJsZScsIG5vZGUuYXR0cihpbnRlcm5hbENvbnRlbnRFZGl0YWJsZUF0dHIpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlZGl0b3Iuc2VyaWFsaXplci5hZGRUZW1wQXR0cihpbnRlcm5hbENvbnRlbnRFZGl0YWJsZUF0dHIpO1xuICAgIH07XG4gICAgY29uc3QgcmVnaXN0ZXJSZWFkT25seUNvbnRlbnRGaWx0ZXJzID0gZWRpdG9yID0+IHtcbiAgICAgIGlmIChlZGl0b3Iuc2VyaWFsaXplcikge1xuICAgICAgICByZWdpc3RlckZpbHRlcnMoZWRpdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkaXRvci5vbignUHJlSW5pdCcsICgpID0+IHtcbiAgICAgICAgICByZWdpc3RlckZpbHRlcnMoZWRpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpc0NsaWNrRXZlbnQgPSBlID0+IGUudHlwZSA9PT0gJ2NsaWNrJztcbiAgICBjb25zdCBhbGxvd2VkRXZlbnRzID0gWydjb3B5J107XG4gICAgY29uc3QgaXNSZWFkT25seUFsbG93ZWRFdmVudCA9IGUgPT4gY29udGFpbnMkMihhbGxvd2VkRXZlbnRzLCBlLnR5cGUpO1xuICAgIGNvbnN0IGdldEFuY2hvckhyZWZPcHQgPSAoZWRpdG9yLCBlbG0pID0+IHtcbiAgICAgIGNvbnN0IGlzUm9vdCA9IGVsbSA9PiBlcShlbG0sIFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRCb2R5KCkpKTtcbiAgICAgIHJldHVybiBjbG9zZXN0JDMoZWxtLCAnYScsIGlzUm9vdCkuYmluZChhID0+IGdldE9wdChhLCAnaHJlZicpKTtcbiAgICB9O1xuICAgIGNvbnN0IHByb2Nlc3NSZWFkb25seUV2ZW50cyA9IChlZGl0b3IsIGUpID0+IHtcbiAgICAgIGlmIChpc0NsaWNrRXZlbnQoZSkgJiYgIVZLLm1ldGFLZXlQcmVzc2VkKGUpKSB7XG4gICAgICAgIGNvbnN0IGVsbSA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGUudGFyZ2V0KTtcbiAgICAgICAgZ2V0QW5jaG9ySHJlZk9wdChlZGl0b3IsIGVsbSkuZWFjaChocmVmID0+IHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgaWYgKC9eIy8udGVzdChocmVmKSkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0RWwgPSBlZGl0b3IuZG9tLnNlbGVjdChgJHsgaHJlZiB9LFtuYW1lPVwiJHsgcmVtb3ZlTGVhZGluZyhocmVmLCAnIycpIH1cIl1gKTtcbiAgICAgICAgICAgIGlmICh0YXJnZXRFbC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zY3JvbGxJbnRvVmlldyh0YXJnZXRFbFswXSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpbmRvdy5vcGVuKGhyZWYsICdfYmxhbmsnLCAncmVsPW5vb3BlbmVyIG5vcmVmZXJyZXIsbWVudWJhcj15ZXMsdG9vbGJhcj15ZXMsbG9jYXRpb249eWVzLHN0YXR1cz15ZXMscmVzaXphYmxlPXllcyxzY3JvbGxiYXJzPXllcycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGlzUmVhZE9ubHlBbGxvd2VkRXZlbnQoZSkpIHtcbiAgICAgICAgZWRpdG9yLmRpc3BhdGNoKGUudHlwZSwgZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZWdpc3RlclJlYWRPbmx5U2VsZWN0aW9uQmxvY2tlcnMgPSBlZGl0b3IgPT4ge1xuICAgICAgZWRpdG9yLm9uKCdTaG93Q2FyZXQnLCBlID0+IHtcbiAgICAgICAgaWYgKGlzUmVhZE9ubHkoZWRpdG9yKSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlZGl0b3Iub24oJ09iamVjdFNlbGVjdGVkJywgZSA9PiB7XG4gICAgICAgIGlmIChpc1JlYWRPbmx5KGVkaXRvcikpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBuYXRpdmVFdmVudHMgPSBUb29scy5tYWtlTWFwKCdmb2N1cyBibHVyIGZvY3VzaW4gZm9jdXNvdXQgY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBiZWZvcmVwYXN0ZSBwYXN0ZSBjdXQgY29weSBzZWxlY3Rpb25jaGFuZ2UgJyArICdtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgd2hlZWwga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBpbnB1dCBiZWZvcmVpbnB1dCBjb250ZXh0bWVudSBkcmFnc3RhcnQgZHJhZ2VuZCBkcmFnb3ZlciAnICsgJ2RyYWdnZXN0dXJlIGRyYWdkcm9wIGRyb3AgZHJhZyBzdWJtaXQgJyArICdjb21wb3NpdGlvbnN0YXJ0IGNvbXBvc2l0aW9uZW5kIGNvbXBvc2l0aW9udXBkYXRlIHRvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kIHRvdWNoY2FuY2VsJywgJyAnKTtcbiAgICBjbGFzcyBFdmVudERpc3BhdGNoZXIge1xuICAgICAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5iaW5kaW5ncyA9IHt9O1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3MgfHwge307XG4gICAgICAgIHRoaXMuc2NvcGUgPSB0aGlzLnNldHRpbmdzLnNjb3BlIHx8IHRoaXM7XG4gICAgICAgIHRoaXMudG9nZ2xlRXZlbnQgPSB0aGlzLnNldHRpbmdzLnRvZ2dsZUV2ZW50IHx8IG5ldmVyO1xuICAgICAgfVxuICAgICAgc3RhdGljIGlzTmF0aXZlKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICEhbmF0aXZlRXZlbnRzW25hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgICB9XG4gICAgICBmaXJlKG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2gobmFtZSwgYXJncyk7XG4gICAgICB9XG4gICAgICBkaXNwYXRjaChuYW1lLCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IGxjTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBub3JtYWxpemUkMyhsY05hbWUsIGFyZ3MgIT09IG51bGwgJiYgYXJncyAhPT0gdm9pZCAwID8gYXJncyA6IHt9LCB0aGlzLnNjb3BlKTtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuYmVmb3JlRmlyZSkge1xuICAgICAgICAgIHRoaXMuc2V0dGluZ3MuYmVmb3JlRmlyZShldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFuZGxlcnMgPSB0aGlzLmJpbmRpbmdzW2xjTmFtZV07XG4gICAgICAgIGlmIChoYW5kbGVycykge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IGhhbmRsZXJzW2ldO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrLnJlbW92ZWQpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2sub25jZSkge1xuICAgICAgICAgICAgICB0aGlzLm9mZihsY05hbWUsIGNhbGxiYWNrLmZ1bmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrLmZ1bmMuY2FsbCh0aGlzLnNjb3BlLCBldmVudCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIHJldHVybiBldmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuICAgICAgb24obmFtZSwgY2FsbGJhY2ssIHByZXBlbmQsIGV4dHJhKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBjYWxsYmFjayA9IG5ldmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIGNvbnN0IHdyYXBwZWRDYWxsYmFjayA9IHtcbiAgICAgICAgICAgIGZ1bmM6IGNhbGxiYWNrLFxuICAgICAgICAgICAgcmVtb3ZlZDogZmFsc2VcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChleHRyYSkge1xuICAgICAgICAgICAgVG9vbHMuZXh0ZW5kKHdyYXBwZWRDYWxsYmFjaywgZXh0cmEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBuYW1lcyA9IG5hbWUudG9Mb3dlckNhc2UoKS5zcGxpdCgnICcpO1xuICAgICAgICAgIGxldCBpID0gbmFtZXMubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnROYW1lID0gbmFtZXNbaV07XG4gICAgICAgICAgICBsZXQgaGFuZGxlcnMgPSB0aGlzLmJpbmRpbmdzW2N1cnJlbnROYW1lXTtcbiAgICAgICAgICAgIGlmICghaGFuZGxlcnMpIHtcbiAgICAgICAgICAgICAgaGFuZGxlcnMgPSBbXTtcbiAgICAgICAgICAgICAgdGhpcy50b2dnbGVFdmVudChjdXJyZW50TmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJlcGVuZCkge1xuICAgICAgICAgICAgICBoYW5kbGVycyA9IFtcbiAgICAgICAgICAgICAgICB3cmFwcGVkQ2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgLi4uaGFuZGxlcnNcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGhhbmRsZXJzID0gW1xuICAgICAgICAgICAgICAgIC4uLmhhbmRsZXJzLFxuICAgICAgICAgICAgICAgIHdyYXBwZWRDYWxsYmFja1xuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5iaW5kaW5nc1tjdXJyZW50TmFtZV0gPSBoYW5kbGVycztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBvZmYobmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICBjb25zdCBuYW1lcyA9IG5hbWUudG9Mb3dlckNhc2UoKS5zcGxpdCgnICcpO1xuICAgICAgICAgIGxldCBpID0gbmFtZXMubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnROYW1lID0gbmFtZXNbaV07XG4gICAgICAgICAgICBsZXQgaGFuZGxlcnMgPSB0aGlzLmJpbmRpbmdzW2N1cnJlbnROYW1lXTtcbiAgICAgICAgICAgIGlmICghY3VycmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgZWFjaCRkKHRoaXMuYmluZGluZ3MsIChfdmFsdWUsIGJpbmRpbmdOYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50b2dnbGVFdmVudChiaW5kaW5nTmFtZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmJpbmRpbmdzW2JpbmRpbmdOYW1lXTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhbmRsZXJzKSB7XG4gICAgICAgICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVycy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkSGFuZGxlcnMgPSBwYXJ0aXRpb24kMihoYW5kbGVycywgaGFuZGxlciA9PiBoYW5kbGVyLmZ1bmMgPT09IGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVycyA9IGZpbHRlcmVkSGFuZGxlcnMuZmFpbDtcbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRpbmdzW2N1cnJlbnROYW1lXSA9IGhhbmRsZXJzO1xuICAgICAgICAgICAgICAgIGVhY2gkZShmaWx0ZXJlZEhhbmRsZXJzLnBhc3MsIGhhbmRsZXIgPT4ge1xuICAgICAgICAgICAgICAgICAgaGFuZGxlci5yZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlRXZlbnQobmFtZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmJpbmRpbmdzW2N1cnJlbnROYW1lXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlYWNoJGQodGhpcy5iaW5kaW5ncywgKF92YWx1ZSwgbmFtZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVFdmVudChuYW1lLCBmYWxzZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5iaW5kaW5ncyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgb25jZShuYW1lLCBjYWxsYmFjaywgcHJlcGVuZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vbihuYW1lLCBjYWxsYmFjaywgcHJlcGVuZCwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgfVxuICAgICAgaGFzKG5hbWUpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgYmluZGluZyA9IHRoaXMuYmluZGluZ3NbbmFtZV07XG4gICAgICAgIHJldHVybiAhKCFiaW5kaW5nIHx8IGJpbmRpbmcubGVuZ3RoID09PSAwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBnZXRFdmVudERpc3BhdGNoZXIgPSBvYmogPT4ge1xuICAgICAgaWYgKCFvYmouX2V2ZW50RGlzcGF0Y2hlcikge1xuICAgICAgICBvYmouX2V2ZW50RGlzcGF0Y2hlciA9IG5ldyBFdmVudERpc3BhdGNoZXIoe1xuICAgICAgICAgIHNjb3BlOiBvYmosXG4gICAgICAgICAgdG9nZ2xlRXZlbnQ6IChuYW1lLCBzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKEV2ZW50RGlzcGF0Y2hlci5pc05hdGl2ZShuYW1lKSAmJiBvYmoudG9nZ2xlTmF0aXZlRXZlbnQpIHtcbiAgICAgICAgICAgICAgb2JqLnRvZ2dsZU5hdGl2ZUV2ZW50KG5hbWUsIHN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iai5fZXZlbnREaXNwYXRjaGVyO1xuICAgIH07XG4gICAgY29uc3QgT2JzZXJ2YWJsZSA9IHtcbiAgICAgIGZpcmUobmFtZSwgYXJncywgYnViYmxlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKG5hbWUsIGFyZ3MsIGJ1YmJsZSk7XG4gICAgICB9LFxuICAgICAgZGlzcGF0Y2gobmFtZSwgYXJncywgYnViYmxlKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoc2VsZi5yZW1vdmVkICYmIG5hbWUgIT09ICdyZW1vdmUnICYmIG5hbWUgIT09ICdkZXRhY2gnKSB7XG4gICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZSQzKG5hbWUudG9Mb3dlckNhc2UoKSwgYXJncyAhPT0gbnVsbCAmJiBhcmdzICE9PSB2b2lkIDAgPyBhcmdzIDoge30sIHNlbGYpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpc3BhdGNoZXJBcmdzID0gZ2V0RXZlbnREaXNwYXRjaGVyKHNlbGYpLmRpc3BhdGNoKG5hbWUsIGFyZ3MpO1xuICAgICAgICBpZiAoYnViYmxlICE9PSBmYWxzZSAmJiBzZWxmLnBhcmVudCkge1xuICAgICAgICAgIGxldCBwYXJlbnQgPSBzZWxmLnBhcmVudCgpO1xuICAgICAgICAgIHdoaWxlIChwYXJlbnQgJiYgIWRpc3BhdGNoZXJBcmdzLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgICAgIHBhcmVudC5kaXNwYXRjaChuYW1lLCBkaXNwYXRjaGVyQXJncywgZmFsc2UpO1xuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudCA/IHBhcmVudC5wYXJlbnQoKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoZXJBcmdzO1xuICAgICAgfSxcbiAgICAgIG9uKG5hbWUsIGNhbGxiYWNrLCBwcmVwZW5kKSB7XG4gICAgICAgIHJldHVybiBnZXRFdmVudERpc3BhdGNoZXIodGhpcykub24obmFtZSwgY2FsbGJhY2ssIHByZXBlbmQpO1xuICAgICAgfSxcbiAgICAgIG9mZihuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gZ2V0RXZlbnREaXNwYXRjaGVyKHRoaXMpLm9mZihuYW1lLCBjYWxsYmFjayk7XG4gICAgICB9LFxuICAgICAgb25jZShuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gZ2V0RXZlbnREaXNwYXRjaGVyKHRoaXMpLm9uY2UobmFtZSwgY2FsbGJhY2spO1xuICAgICAgfSxcbiAgICAgIGhhc0V2ZW50TGlzdGVuZXJzKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGdldEV2ZW50RGlzcGF0Y2hlcih0aGlzKS5oYXMobmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IERPTSQyID0gRE9NVXRpbHMuRE9NO1xuICAgIGxldCBjdXN0b21FdmVudFJvb3REZWxlZ2F0ZXM7XG4gICAgY29uc3QgZ2V0RXZlbnRUYXJnZXQgPSAoZWRpdG9yLCBldmVudE5hbWUpID0+IHtcbiAgICAgIGlmIChldmVudE5hbWUgPT09ICdzZWxlY3Rpb25jaGFuZ2UnKSB7XG4gICAgICAgIHJldHVybiBlZGl0b3IuZ2V0RG9jKCk7XG4gICAgICB9XG4gICAgICBpZiAoIWVkaXRvci5pbmxpbmUgJiYgL14oPzptb3VzZXx0b3VjaHxjbGlja3xjb250ZXh0bWVudXxkcm9wfGRyYWdvdmVyfGRyYWdlbmQpLy50ZXN0KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGVkaXRvci5nZXREb2MoKS5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICB9XG4gICAgICBjb25zdCBldmVudFJvb3QgPSBnZXRFdmVudFJvb3QoZWRpdG9yKTtcbiAgICAgIGlmIChldmVudFJvb3QpIHtcbiAgICAgICAgaWYgKCFlZGl0b3IuZXZlbnRSb290KSB7XG4gICAgICAgICAgZWRpdG9yLmV2ZW50Um9vdCA9IERPTSQyLnNlbGVjdChldmVudFJvb3QpWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlZGl0b3IuZXZlbnRSb290O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVkaXRvci5nZXRCb2R5KCk7XG4gICAgfTtcbiAgICBjb25zdCBpc0xpc3RlbmluZyA9IGVkaXRvciA9PiAhZWRpdG9yLmhpZGRlbiAmJiAhaXNSZWFkT25seShlZGl0b3IpO1xuICAgIGNvbnN0IGZpcmVFdmVudCA9IChlZGl0b3IsIGV2ZW50TmFtZSwgZSkgPT4ge1xuICAgICAgaWYgKGlzTGlzdGVuaW5nKGVkaXRvcikpIHtcbiAgICAgICAgZWRpdG9yLmRpc3BhdGNoKGV2ZW50TmFtZSwgZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzUmVhZE9ubHkoZWRpdG9yKSkge1xuICAgICAgICBwcm9jZXNzUmVhZG9ubHlFdmVudHMoZWRpdG9yLCBlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGJpbmRFdmVudERlbGVnYXRlID0gKGVkaXRvciwgZXZlbnROYW1lKSA9PiB7XG4gICAgICBpZiAoIWVkaXRvci5kZWxlZ2F0ZXMpIHtcbiAgICAgICAgZWRpdG9yLmRlbGVnYXRlcyA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKGVkaXRvci5kZWxlZ2F0ZXNbZXZlbnROYW1lXSB8fCBlZGl0b3IucmVtb3ZlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBldmVudFJvb3RFbG0gPSBnZXRFdmVudFRhcmdldChlZGl0b3IsIGV2ZW50TmFtZSk7XG4gICAgICBpZiAoZ2V0RXZlbnRSb290KGVkaXRvcikpIHtcbiAgICAgICAgaWYgKCFjdXN0b21FdmVudFJvb3REZWxlZ2F0ZXMpIHtcbiAgICAgICAgICBjdXN0b21FdmVudFJvb3REZWxlZ2F0ZXMgPSB7fTtcbiAgICAgICAgICBlZGl0b3IuZWRpdG9yTWFuYWdlci5vbigncmVtb3ZlRWRpdG9yJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFlZGl0b3IuZWRpdG9yTWFuYWdlci5hY3RpdmVFZGl0b3IpIHtcbiAgICAgICAgICAgICAgaWYgKGN1c3RvbUV2ZW50Um9vdERlbGVnYXRlcykge1xuICAgICAgICAgICAgICAgIGVhY2gkZChjdXN0b21FdmVudFJvb3REZWxlZ2F0ZXMsIChfdmFsdWUsIG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICAgIGVkaXRvci5kb20udW5iaW5kKGdldEV2ZW50VGFyZ2V0KGVkaXRvciwgbmFtZSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGN1c3RvbUV2ZW50Um9vdERlbGVnYXRlcyA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VzdG9tRXZlbnRSb290RGVsZWdhdGVzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVsZWdhdGUgPSBlID0+IHtcbiAgICAgICAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgICBjb25zdCBlZGl0b3JzID0gZWRpdG9yLmVkaXRvck1hbmFnZXIuZ2V0KCk7XG4gICAgICAgICAgbGV0IGkgPSBlZGl0b3JzLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZWRpdG9yc1tpXS5nZXRCb2R5KCk7XG4gICAgICAgICAgICBpZiAoYm9keSA9PT0gdGFyZ2V0IHx8IERPTSQyLmlzQ2hpbGRPZih0YXJnZXQsIGJvZHkpKSB7XG4gICAgICAgICAgICAgIGZpcmVFdmVudChlZGl0b3JzW2ldLCBldmVudE5hbWUsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY3VzdG9tRXZlbnRSb290RGVsZWdhdGVzW2V2ZW50TmFtZV0gPSBkZWxlZ2F0ZTtcbiAgICAgICAgRE9NJDIuYmluZChldmVudFJvb3RFbG0sIGV2ZW50TmFtZSwgZGVsZWdhdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZGVsZWdhdGUgPSBlID0+IHtcbiAgICAgICAgICBmaXJlRXZlbnQoZWRpdG9yLCBldmVudE5hbWUsIGUpO1xuICAgICAgICB9O1xuICAgICAgICBET00kMi5iaW5kKGV2ZW50Um9vdEVsbSwgZXZlbnROYW1lLCBkZWxlZ2F0ZSk7XG4gICAgICAgIGVkaXRvci5kZWxlZ2F0ZXNbZXZlbnROYW1lXSA9IGRlbGVnYXRlO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgRWRpdG9yT2JzZXJ2YWJsZSA9IHtcbiAgICAgIC4uLk9ic2VydmFibGUsXG4gICAgICBiaW5kUGVuZGluZ0V2ZW50RGVsZWdhdGVzKCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgVG9vbHMuZWFjaChzZWxmLl9wZW5kaW5nTmF0aXZlRXZlbnRzLCBuYW1lID0+IHtcbiAgICAgICAgICBiaW5kRXZlbnREZWxlZ2F0ZShzZWxmLCBuYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgdG9nZ2xlTmF0aXZlRXZlbnQobmFtZSwgc3RhdGUpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmIChuYW1lID09PSAnZm9jdXMnIHx8IG5hbWUgPT09ICdibHVyJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5yZW1vdmVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgIGlmIChzZWxmLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICBiaW5kRXZlbnREZWxlZ2F0ZShzZWxmLCBuYW1lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFzZWxmLl9wZW5kaW5nTmF0aXZlRXZlbnRzKSB7XG4gICAgICAgICAgICAgIHNlbGYuX3BlbmRpbmdOYXRpdmVFdmVudHMgPSBbbmFtZV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZWxmLl9wZW5kaW5nTmF0aXZlRXZlbnRzLnB1c2gobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNlbGYuaW5pdGlhbGl6ZWQgJiYgc2VsZi5kZWxlZ2F0ZXMpIHtcbiAgICAgICAgICBzZWxmLmRvbS51bmJpbmQoZ2V0RXZlbnRUYXJnZXQoc2VsZiwgbmFtZSksIG5hbWUsIHNlbGYuZGVsZWdhdGVzW25hbWVdKTtcbiAgICAgICAgICBkZWxldGUgc2VsZi5kZWxlZ2F0ZXNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1bmJpbmRBbGxOYXRpdmVFdmVudHMoKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBjb25zdCBib2R5ID0gc2VsZi5nZXRCb2R5KCk7XG4gICAgICAgIGNvbnN0IGRvbSA9IHNlbGYuZG9tO1xuICAgICAgICBpZiAoc2VsZi5kZWxlZ2F0ZXMpIHtcbiAgICAgICAgICBlYWNoJGQoc2VsZi5kZWxlZ2F0ZXMsICh2YWx1ZSwgbmFtZSkgPT4ge1xuICAgICAgICAgICAgc2VsZi5kb20udW5iaW5kKGdldEV2ZW50VGFyZ2V0KHNlbGYsIG5hbWUpLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGVsZXRlIHNlbGYuZGVsZWdhdGVzO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2VsZi5pbmxpbmUgJiYgYm9keSAmJiBkb20pIHtcbiAgICAgICAgICBib2R5Lm9ubG9hZCA9IG51bGw7XG4gICAgICAgICAgZG9tLnVuYmluZChzZWxmLmdldFdpbigpKTtcbiAgICAgICAgICBkb20udW5iaW5kKHNlbGYuZ2V0RG9jKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb20pIHtcbiAgICAgICAgICBkb20udW5iaW5kKGJvZHkpO1xuICAgICAgICAgIGRvbS51bmJpbmQoc2VsZi5nZXRDb250YWluZXIoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3Qgc3RyaW5nTGlzdFByb2Nlc3NvciA9IHZhbHVlID0+IHtcbiAgICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogdmFsdWUuc3BsaXQoL1sgLF0vKSxcbiAgICAgICAgICB2YWxpZDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5T2YodmFsdWUsIGlzU3RyaW5nKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIHZhbGlkOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgICBtZXNzYWdlOiBgVGhlIHZhbHVlIG11c3QgYmUgYSBzdHJpbmdbXSBvciBhIGNvbW1hL3NwYWNlIHNlcGFyYXRlZCBzdHJpbmcuYFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZ2V0QnVpbHRJblByb2Nlc3NvciA9IHR5cGUgPT4ge1xuICAgICAgY29uc3QgdmFsaWRhdG9yID0gKCgpID0+IHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgICByZXR1cm4gaXNBcnJheSQxO1xuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICByZXR1cm4gaXNCb29sZWFuO1xuICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb247XG4gICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgcmV0dXJuIGlzTnVtYmVyO1xuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgIHJldHVybiBpc09iamVjdDtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICByZXR1cm4gaXNTdHJpbmc7XG4gICAgICAgIGNhc2UgJ3N0cmluZ1tdJzpcbiAgICAgICAgICByZXR1cm4gc3RyaW5nTGlzdFByb2Nlc3NvcjtcbiAgICAgICAgY2FzZSAnb2JqZWN0W10nOlxuICAgICAgICAgIHJldHVybiB2YWwgPT4gaXNBcnJheU9mKHZhbCwgaXNPYmplY3QpO1xuICAgICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICAgIHJldHVybiB2YWwgPT4gaXMkNCh2YWwsIFJlZ0V4cCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGFsd2F5cztcbiAgICAgICAgfVxuICAgICAgfSkoKTtcbiAgICAgIHJldHVybiB2YWx1ZSA9PiBwcm9jZXNzVmFsdWUodmFsdWUsIHZhbGlkYXRvciwgYFRoZSB2YWx1ZSBtdXN0IGJlIGEgJHsgdHlwZSB9LmApO1xuICAgIH07XG4gICAgY29uc3QgaXNCdWlsdEluU3BlYyA9IHNwZWMgPT4gaXNTdHJpbmcoc3BlYy5wcm9jZXNzb3IpO1xuICAgIGNvbnN0IGdldEVycm9yTWVzc2FnZSA9IChtZXNzYWdlLCByZXN1bHQpID0+IHtcbiAgICAgIGNvbnN0IGFkZGl0aW9uYWxUZXh0ID0gaXNFbXB0eSQzKHJlc3VsdC5tZXNzYWdlKSA/ICcnIDogYC4gJHsgcmVzdWx0Lm1lc3NhZ2UgfWA7XG4gICAgICByZXR1cm4gbWVzc2FnZSArIGFkZGl0aW9uYWxUZXh0O1xuICAgIH07XG4gICAgY29uc3QgaXNWYWxpZFJlc3VsdCA9IHJlc3VsdCA9PiByZXN1bHQudmFsaWQ7XG4gICAgY29uc3QgcHJvY2Vzc1ZhbHVlID0gKHZhbHVlLCBwcm9jZXNzb3IsIG1lc3NhZ2UgPSAnJykgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gcHJvY2Vzc29yKHZhbHVlKTtcbiAgICAgIGlmIChpc0Jvb2xlYW4ocmVzdWx0KSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0ID8ge1xuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICB2YWxpZDogdHJ1ZVxuICAgICAgICB9IDoge1xuICAgICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgICBtZXNzYWdlXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcHJvY2Vzc0RlZmF1bHRWYWx1ZSA9IChuYW1lLCBkZWZhdWx0VmFsdWUsIHByb2Nlc3NvcikgPT4ge1xuICAgICAgaWYgKCFpc1VuZGVmaW5lZChkZWZhdWx0VmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHByb2Nlc3NWYWx1ZShkZWZhdWx0VmFsdWUsIHByb2Nlc3Nvcik7XG4gICAgICAgIGlmIChpc1ZhbGlkUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZ2V0RXJyb3JNZXNzYWdlKGBJbnZhbGlkIGRlZmF1bHQgdmFsdWUgcGFzc2VkIGZvciB0aGUgXCIkeyBuYW1lIH1cIiBvcHRpb25gLCByZXN1bHQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZSQ1ID0gKGVkaXRvciwgaW5pdGlhbE9wdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IHJlZ2lzdHJ5ID0ge307XG4gICAgICBjb25zdCB2YWx1ZXMgPSB7fTtcbiAgICAgIGNvbnN0IHNldFZhbHVlID0gKG5hbWUsIHZhbHVlLCBwcm9jZXNzb3IpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcHJvY2Vzc1ZhbHVlKHZhbHVlLCBwcm9jZXNzb3IpO1xuICAgICAgICBpZiAoaXNWYWxpZFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAgICAgdmFsdWVzW25hbWVdID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybihnZXRFcnJvck1lc3NhZ2UoYEludmFsaWQgdmFsdWUgcGFzc2VkIGZvciB0aGUgJHsgbmFtZSB9IG9wdGlvbmAsIHJlc3VsdCkpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlZ2lzdGVyID0gKG5hbWUsIHNwZWMpID0+IHtcbiAgICAgICAgY29uc3QgcHJvY2Vzc29yID0gaXNCdWlsdEluU3BlYyhzcGVjKSA/IGdldEJ1aWx0SW5Qcm9jZXNzb3Ioc3BlYy5wcm9jZXNzb3IpIDogc3BlYy5wcm9jZXNzb3I7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IHByb2Nlc3NEZWZhdWx0VmFsdWUobmFtZSwgc3BlYy5kZWZhdWx0LCBwcm9jZXNzb3IpO1xuICAgICAgICByZWdpc3RyeVtuYW1lXSA9IHtcbiAgICAgICAgICAuLi5zcGVjLFxuICAgICAgICAgIGRlZmF1bHQ6IGRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICBwcm9jZXNzb3JcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaW5pdFZhbHVlID0gZ2V0JGEodmFsdWVzLCBuYW1lKS5vclRodW5rKCgpID0+IGdldCRhKGluaXRpYWxPcHRpb25zLCBuYW1lKSk7XG4gICAgICAgIGluaXRWYWx1ZS5lYWNoKHZhbHVlID0+IHNldFZhbHVlKG5hbWUsIHZhbHVlLCBwcm9jZXNzb3IpKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBpc1JlZ2lzdGVyZWQgPSBuYW1lID0+IGhhcyQyKHJlZ2lzdHJ5LCBuYW1lKTtcbiAgICAgIGNvbnN0IGdldCA9IG5hbWUgPT4gZ2V0JGEodmFsdWVzLCBuYW1lKS5vclRodW5rKCgpID0+IGdldCRhKHJlZ2lzdHJ5LCBuYW1lKS5tYXAoc3BlYyA9PiBzcGVjLmRlZmF1bHQpKS5nZXRPclVuZGVmaW5lZCgpO1xuICAgICAgY29uc3Qgc2V0ID0gKG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICghaXNSZWdpc3RlcmVkKG5hbWUpKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBcIiR7IG5hbWUgfVwiIGlzIG5vdCBhIHJlZ2lzdGVyZWQgb3B0aW9uLiBFbnN1cmUgdGhlIG9wdGlvbiBoYXMgYmVlbiByZWdpc3RlcmVkIGJlZm9yZSBzZXR0aW5nIGEgdmFsdWUuYCk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHNwZWMgPSByZWdpc3RyeVtuYW1lXTtcbiAgICAgICAgICBpZiAoc3BlYy5pbW11dGFibGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFwiJHsgbmFtZSB9XCIgaXMgYW4gaW1tdXRhYmxlIG9wdGlvbiBhbmQgY2Fubm90IGJlIHVwZGF0ZWRgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNldFZhbHVlKG5hbWUsIHZhbHVlLCBzcGVjLnByb2Nlc3Nvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgdW5zZXQgPSBuYW1lID0+IHtcbiAgICAgICAgY29uc3QgcmVnaXN0ZXJlZCA9IGlzUmVnaXN0ZXJlZChuYW1lKTtcbiAgICAgICAgaWYgKHJlZ2lzdGVyZWQpIHtcbiAgICAgICAgICBkZWxldGUgdmFsdWVzW25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWdpc3RlcmVkO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzU2V0ID0gbmFtZSA9PiBoYXMkMih2YWx1ZXMsIG5hbWUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVnaXN0ZXIsXG4gICAgICAgIGlzUmVnaXN0ZXJlZCxcbiAgICAgICAgZ2V0LFxuICAgICAgICBzZXQsXG4gICAgICAgIHVuc2V0LFxuICAgICAgICBpc1NldFxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgZGVmYXVsdE1vZGVzID0gW1xuICAgICAgJ2Rlc2lnbicsXG4gICAgICAncmVhZG9ubHknXG4gICAgXTtcbiAgICBjb25zdCBzd2l0Y2hUb01vZGUgPSAoZWRpdG9yLCBhY3RpdmVNb2RlLCBhdmFpbGFibGVNb2RlcywgbW9kZSkgPT4ge1xuICAgICAgY29uc3Qgb2xkTW9kZSA9IGF2YWlsYWJsZU1vZGVzW2FjdGl2ZU1vZGUuZ2V0KCldO1xuICAgICAgY29uc3QgbmV3TW9kZSA9IGF2YWlsYWJsZU1vZGVzW21vZGVdO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3TW9kZS5hY3RpdmF0ZSgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBwcm9ibGVtIHdoaWxlIGFjdGl2YXRpbmcgZWRpdG9yIG1vZGUgJHsgbW9kZSB9OmAsIGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBvbGRNb2RlLmRlYWN0aXZhdGUoKTtcbiAgICAgIGlmIChvbGRNb2RlLmVkaXRvclJlYWRPbmx5ICE9PSBuZXdNb2RlLmVkaXRvclJlYWRPbmx5KSB7XG4gICAgICAgIHRvZ2dsZVJlYWRPbmx5KGVkaXRvciwgbmV3TW9kZS5lZGl0b3JSZWFkT25seSk7XG4gICAgICB9XG4gICAgICBhY3RpdmVNb2RlLnNldChtb2RlKTtcbiAgICAgIGZpcmVTd2l0Y2hNb2RlKGVkaXRvciwgbW9kZSk7XG4gICAgfTtcbiAgICBjb25zdCBzZXRNb2RlID0gKGVkaXRvciwgYXZhaWxhYmxlTW9kZXMsIGFjdGl2ZU1vZGUsIG1vZGUpID0+IHtcbiAgICAgIGlmIChtb2RlID09PSBhY3RpdmVNb2RlLmdldCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAoIWhhcyQyKGF2YWlsYWJsZU1vZGVzLCBtb2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVkaXRvciBtb2RlICckeyBtb2RlIH0nIGlzIGludmFsaWRgKTtcbiAgICAgIH1cbiAgICAgIGlmIChlZGl0b3IuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgc3dpdGNoVG9Nb2RlKGVkaXRvciwgYWN0aXZlTW9kZSwgYXZhaWxhYmxlTW9kZXMsIG1vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRpdG9yLm9uKCdpbml0JywgKCkgPT4gc3dpdGNoVG9Nb2RlKGVkaXRvciwgYWN0aXZlTW9kZSwgYXZhaWxhYmxlTW9kZXMsIG1vZGUpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlZ2lzdGVyTW9kZSA9IChhdmFpbGFibGVNb2RlcywgbW9kZSwgYXBpKSA9PiB7XG4gICAgICBpZiAoY29udGFpbnMkMihkZWZhdWx0TW9kZXMsIG1vZGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IG92ZXJyaWRlIGRlZmF1bHQgbW9kZSAkeyBtb2RlIH1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmF2YWlsYWJsZU1vZGVzLFxuICAgICAgICBbbW9kZV06IHtcbiAgICAgICAgICAuLi5hcGksXG4gICAgICAgICAgZGVhY3RpdmF0ZTogKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYXBpLmRlYWN0aXZhdGUoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgcHJvYmxlbSB3aGlsZSBkZWFjdGl2YXRpbmcgZWRpdG9yIG1vZGUgJHsgbW9kZSB9OmAsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgY3JlYXRlJDQgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgYWN0aXZlTW9kZSA9IENlbGwoJ2Rlc2lnbicpO1xuICAgICAgY29uc3QgYXZhaWxhYmxlTW9kZXMgPSBDZWxsKHtcbiAgICAgICAgZGVzaWduOiB7XG4gICAgICAgICAgYWN0aXZhdGU6IG5vb3AsXG4gICAgICAgICAgZGVhY3RpdmF0ZTogbm9vcCxcbiAgICAgICAgICBlZGl0b3JSZWFkT25seTogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgcmVhZG9ubHk6IHtcbiAgICAgICAgICBhY3RpdmF0ZTogbm9vcCxcbiAgICAgICAgICBkZWFjdGl2YXRlOiBub29wLFxuICAgICAgICAgIGVkaXRvclJlYWRPbmx5OiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJSZWFkT25seUNvbnRlbnRGaWx0ZXJzKGVkaXRvcik7XG4gICAgICByZWdpc3RlclJlYWRPbmx5U2VsZWN0aW9uQmxvY2tlcnMoZWRpdG9yKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzUmVhZE9ubHk6ICgpID0+IGlzUmVhZE9ubHkoZWRpdG9yKSxcbiAgICAgICAgc2V0OiBtb2RlID0+IHNldE1vZGUoZWRpdG9yLCBhdmFpbGFibGVNb2Rlcy5nZXQoKSwgYWN0aXZlTW9kZSwgbW9kZSksXG4gICAgICAgIGdldDogKCkgPT4gYWN0aXZlTW9kZS5nZXQoKSxcbiAgICAgICAgcmVnaXN0ZXI6IChtb2RlLCBhcGkpID0+IHtcbiAgICAgICAgICBhdmFpbGFibGVNb2Rlcy5zZXQocmVnaXN0ZXJNb2RlKGF2YWlsYWJsZU1vZGVzLmdldCgpLCBtb2RlLCBhcGkpKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgZWFjaCQyID0gVG9vbHMuZWFjaCwgZXhwbG9kZSA9IFRvb2xzLmV4cGxvZGU7XG4gICAgY29uc3Qga2V5Q29kZUxvb2t1cCA9IHtcbiAgICAgIGYxOiAxMTIsXG4gICAgICBmMjogMTEzLFxuICAgICAgZjM6IDExNCxcbiAgICAgIGY0OiAxMTUsXG4gICAgICBmNTogMTE2LFxuICAgICAgZjY6IDExNyxcbiAgICAgIGY3OiAxMTgsXG4gICAgICBmODogMTE5LFxuICAgICAgZjk6IDEyMCxcbiAgICAgIGYxMDogMTIxLFxuICAgICAgZjExOiAxMjIsXG4gICAgICBmMTI6IDEyM1xuICAgIH07XG4gICAgY29uc3QgbW9kaWZpZXJOYW1lcyA9IFRvb2xzLm1ha2VNYXAoJ2FsdCxjdHJsLHNoaWZ0LG1ldGEsYWNjZXNzJyk7XG4gICAgY29uc3QgaXNNb2RpZmllciA9IGtleSA9PiBrZXkgaW4gbW9kaWZpZXJOYW1lcztcbiAgICBjb25zdCBwYXJzZVNob3J0Y3V0ID0gcGF0dGVybiA9PiB7XG4gICAgICBjb25zdCBzaG9ydGN1dCA9IHt9O1xuICAgICAgY29uc3QgaXNNYWMgPSBFbnYub3MuaXNNYWNPUygpIHx8IEVudi5vcy5pc2lPUygpO1xuICAgICAgZWFjaCQyKGV4cGxvZGUocGF0dGVybi50b0xvd2VyQ2FzZSgpLCAnKycpLCB2YWx1ZSA9PiB7XG4gICAgICAgIGlmIChpc01vZGlmaWVyKHZhbHVlKSkge1xuICAgICAgICAgIHNob3J0Y3V0W3ZhbHVlXSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKC9eWzAtOV17Mix9JC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHNob3J0Y3V0LmtleUNvZGUgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaG9ydGN1dC5jaGFyQ29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICBzaG9ydGN1dC5rZXlDb2RlID0ga2V5Q29kZUxvb2t1cFt2YWx1ZV0gfHwgdmFsdWUudG9VcHBlckNhc2UoKS5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCBpZCA9IFtzaG9ydGN1dC5rZXlDb2RlXTtcbiAgICAgIGxldCBrZXk7XG4gICAgICBmb3IgKGtleSBpbiBtb2RpZmllck5hbWVzKSB7XG4gICAgICAgIGlmIChzaG9ydGN1dFtrZXldKSB7XG4gICAgICAgICAgaWQucHVzaChrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNob3J0Y3V0W2tleV0gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2hvcnRjdXQuaWQgPSBpZC5qb2luKCcsJyk7XG4gICAgICBpZiAoc2hvcnRjdXQuYWNjZXNzKSB7XG4gICAgICAgIHNob3J0Y3V0LmFsdCA9IHRydWU7XG4gICAgICAgIGlmIChpc01hYykge1xuICAgICAgICAgIHNob3J0Y3V0LmN0cmwgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNob3J0Y3V0LnNoaWZ0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNob3J0Y3V0Lm1ldGEpIHtcbiAgICAgICAgaWYgKGlzTWFjKSB7XG4gICAgICAgICAgc2hvcnRjdXQubWV0YSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2hvcnRjdXQuY3RybCA9IHRydWU7XG4gICAgICAgICAgc2hvcnRjdXQubWV0YSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2hvcnRjdXQ7XG4gICAgfTtcbiAgICBjbGFzcyBTaG9ydGN1dHMge1xuICAgICAgY29uc3RydWN0b3IoZWRpdG9yKSB7XG4gICAgICAgIHRoaXMuc2hvcnRjdXRzID0ge307XG4gICAgICAgIHRoaXMucGVuZGluZ1BhdHRlcm5zID0gW107XG4gICAgICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgZWRpdG9yLm9uKCdrZXl1cCBrZXlwcmVzcyBrZXlkb3duJywgZSA9PiB7XG4gICAgICAgICAgaWYgKChzZWxmLmhhc01vZGlmaWVyKGUpIHx8IHNlbGYuaXNGdW5jdGlvbktleShlKSkgJiYgIWUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICAgIGVhY2gkMihzZWxmLnNob3J0Y3V0cywgc2hvcnRjdXQgPT4ge1xuICAgICAgICAgICAgICBpZiAoc2VsZi5tYXRjaFNob3J0Y3V0KGUsIHNob3J0Y3V0KSkge1xuICAgICAgICAgICAgICAgIHNlbGYucGVuZGluZ1BhdHRlcm5zID0gc2hvcnRjdXQuc3VicGF0dGVybnMuc2xpY2UoMCk7XG4gICAgICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gJ2tleWRvd24nKSB7XG4gICAgICAgICAgICAgICAgICBzZWxmLmV4ZWN1dGVTaG9ydGN1dEFjdGlvbihzaG9ydGN1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChzZWxmLm1hdGNoU2hvcnRjdXQoZSwgc2VsZi5wZW5kaW5nUGF0dGVybnNbMF0pKSB7XG4gICAgICAgICAgICAgIGlmIChzZWxmLnBlbmRpbmdQYXR0ZXJucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS50eXBlID09PSAna2V5ZG93bicpIHtcbiAgICAgICAgICAgICAgICAgIHNlbGYuZXhlY3V0ZVNob3J0Y3V0QWN0aW9uKHNlbGYucGVuZGluZ1BhdHRlcm5zWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2VsZi5wZW5kaW5nUGF0dGVybnMuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgYWRkKHBhdHRlcm4sIGRlc2MsIGNtZEZ1bmMsIHNjb3BlKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBjb25zdCBmdW5jID0gc2VsZi5ub3JtYWxpemVDb21tYW5kRnVuYyhjbWRGdW5jKTtcbiAgICAgICAgZWFjaCQyKGV4cGxvZGUoVG9vbHMudHJpbShwYXR0ZXJuKSksIHBhdHRlcm4gPT4ge1xuICAgICAgICAgIGNvbnN0IHNob3J0Y3V0ID0gc2VsZi5jcmVhdGVTaG9ydGN1dChwYXR0ZXJuLCBkZXNjLCBmdW5jLCBzY29wZSk7XG4gICAgICAgICAgc2VsZi5zaG9ydGN1dHNbc2hvcnRjdXQuaWRdID0gc2hvcnRjdXQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJlbW92ZShwYXR0ZXJuKSB7XG4gICAgICAgIGNvbnN0IHNob3J0Y3V0ID0gdGhpcy5jcmVhdGVTaG9ydGN1dChwYXR0ZXJuKTtcbiAgICAgICAgaWYgKHRoaXMuc2hvcnRjdXRzW3Nob3J0Y3V0LmlkXSkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnNob3J0Y3V0c1tzaG9ydGN1dC5pZF07XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgbm9ybWFsaXplQ29tbWFuZEZ1bmMoY21kRnVuYykge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgY29uc3QgY21kID0gY21kRnVuYztcbiAgICAgICAgaWYgKHR5cGVvZiBjbWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHNlbGYuZWRpdG9yLmV4ZWNDb21tYW5kKGNtZCwgZmFsc2UsIG51bGwpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoVG9vbHMuaXNBcnJheShjbWQpKSB7XG4gICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHNlbGYuZWRpdG9yLmV4ZWNDb21tYW5kKGNtZFswXSwgY21kWzFdLCBjbWRbMl0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNtZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3JlYXRlU2hvcnRjdXQocGF0dGVybiwgZGVzYywgY21kRnVuYywgc2NvcGUpIHtcbiAgICAgICAgY29uc3Qgc2hvcnRjdXRzID0gVG9vbHMubWFwKGV4cGxvZGUocGF0dGVybiwgJz4nKSwgcGFyc2VTaG9ydGN1dCk7XG4gICAgICAgIHNob3J0Y3V0c1tzaG9ydGN1dHMubGVuZ3RoIC0gMV0gPSBUb29scy5leHRlbmQoc2hvcnRjdXRzW3Nob3J0Y3V0cy5sZW5ndGggLSAxXSwge1xuICAgICAgICAgIGZ1bmM6IGNtZEZ1bmMsXG4gICAgICAgICAgc2NvcGU6IHNjb3BlIHx8IHRoaXMuZWRpdG9yXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gVG9vbHMuZXh0ZW5kKHNob3J0Y3V0c1swXSwge1xuICAgICAgICAgIGRlc2M6IHRoaXMuZWRpdG9yLnRyYW5zbGF0ZShkZXNjKSxcbiAgICAgICAgICBzdWJwYXR0ZXJuczogc2hvcnRjdXRzLnNsaWNlKDEpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaGFzTW9kaWZpZXIoZSkge1xuICAgICAgICByZXR1cm4gZS5hbHRLZXkgfHwgZS5jdHJsS2V5IHx8IGUubWV0YUtleTtcbiAgICAgIH1cbiAgICAgIGlzRnVuY3Rpb25LZXkoZSkge1xuICAgICAgICByZXR1cm4gZS50eXBlID09PSAna2V5ZG93bicgJiYgZS5rZXlDb2RlID49IDExMiAmJiBlLmtleUNvZGUgPD0gMTIzO1xuICAgICAgfVxuICAgICAgbWF0Y2hTaG9ydGN1dChlLCBzaG9ydGN1dCkge1xuICAgICAgICBpZiAoIXNob3J0Y3V0KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG9ydGN1dC5jdHJsICE9PSBlLmN0cmxLZXkgfHwgc2hvcnRjdXQubWV0YSAhPT0gZS5tZXRhS2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG9ydGN1dC5hbHQgIT09IGUuYWx0S2V5IHx8IHNob3J0Y3V0LnNoaWZ0ICE9PSBlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlLmtleUNvZGUgPT09IHNob3J0Y3V0LmtleUNvZGUgfHwgZS5jaGFyQ29kZSAmJiBlLmNoYXJDb2RlID09PSBzaG9ydGN1dC5jaGFyQ29kZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBleGVjdXRlU2hvcnRjdXRBY3Rpb24oc2hvcnRjdXQpIHtcbiAgICAgICAgcmV0dXJuIHNob3J0Y3V0LmZ1bmMgPyBzaG9ydGN1dC5mdW5jLmNhbGwoc2hvcnRjdXQuc2NvcGUpIDogbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBjcmVhdGUkMyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGJ1dHRvbnMgPSB7fTtcbiAgICAgIGNvbnN0IG1lbnVJdGVtcyA9IHt9O1xuICAgICAgY29uc3QgcG9wdXBzID0ge307XG4gICAgICBjb25zdCBpY29ucyA9IHt9O1xuICAgICAgY29uc3QgY29udGV4dE1lbnVzID0ge307XG4gICAgICBjb25zdCBjb250ZXh0VG9vbGJhcnMgPSB7fTtcbiAgICAgIGNvbnN0IHNpZGViYXJzID0ge307XG4gICAgICBjb25zdCB2aWV3cyA9IHt9O1xuICAgICAgY29uc3QgYWRkID0gKGNvbGxlY3Rpb24sIHR5cGUpID0+IChuYW1lLCBzcGVjKSA9PiB7XG4gICAgICAgIGNvbGxlY3Rpb25bbmFtZS50b0xvd2VyQ2FzZSgpXSA9IHtcbiAgICAgICAgICAuLi5zcGVjLFxuICAgICAgICAgIHR5cGVcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICBjb25zdCBhZGRJY29uID0gKG5hbWUsIHN2Z0RhdGEpID0+IGljb25zW25hbWUudG9Mb3dlckNhc2UoKV0gPSBzdmdEYXRhO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWRkQnV0dG9uOiBhZGQoYnV0dG9ucywgJ2J1dHRvbicpLFxuICAgICAgICBhZGRHcm91cFRvb2xiYXJCdXR0b246IGFkZChidXR0b25zLCAnZ3JvdXB0b29sYmFyYnV0dG9uJyksXG4gICAgICAgIGFkZFRvZ2dsZUJ1dHRvbjogYWRkKGJ1dHRvbnMsICd0b2dnbGVidXR0b24nKSxcbiAgICAgICAgYWRkTWVudUJ1dHRvbjogYWRkKGJ1dHRvbnMsICdtZW51YnV0dG9uJyksXG4gICAgICAgIGFkZFNwbGl0QnV0dG9uOiBhZGQoYnV0dG9ucywgJ3NwbGl0YnV0dG9uJyksXG4gICAgICAgIGFkZE1lbnVJdGVtOiBhZGQobWVudUl0ZW1zLCAnbWVudWl0ZW0nKSxcbiAgICAgICAgYWRkTmVzdGVkTWVudUl0ZW06IGFkZChtZW51SXRlbXMsICduZXN0ZWRtZW51aXRlbScpLFxuICAgICAgICBhZGRUb2dnbGVNZW51SXRlbTogYWRkKG1lbnVJdGVtcywgJ3RvZ2dsZW1lbnVpdGVtJyksXG4gICAgICAgIGFkZEF1dG9jb21wbGV0ZXI6IGFkZChwb3B1cHMsICdhdXRvY29tcGxldGVyJyksXG4gICAgICAgIGFkZENvbnRleHRNZW51OiBhZGQoY29udGV4dE1lbnVzLCAnY29udGV4dG1lbnUnKSxcbiAgICAgICAgYWRkQ29udGV4dFRvb2xiYXI6IGFkZChjb250ZXh0VG9vbGJhcnMsICdjb250ZXh0dG9vbGJhcicpLFxuICAgICAgICBhZGRDb250ZXh0Rm9ybTogYWRkKGNvbnRleHRUb29sYmFycywgJ2NvbnRleHRmb3JtJyksXG4gICAgICAgIGFkZFNpZGViYXI6IGFkZChzaWRlYmFycywgJ3NpZGViYXInKSxcbiAgICAgICAgYWRkVmlldzogYWRkKHZpZXdzLCAndmlld3MnKSxcbiAgICAgICAgYWRkSWNvbixcbiAgICAgICAgZ2V0QWxsOiAoKSA9PiAoe1xuICAgICAgICAgIGJ1dHRvbnMsXG4gICAgICAgICAgbWVudUl0ZW1zLFxuICAgICAgICAgIGljb25zLFxuICAgICAgICAgIHBvcHVwcyxcbiAgICAgICAgICBjb250ZXh0TWVudXMsXG4gICAgICAgICAgY29udGV4dFRvb2xiYXJzLFxuICAgICAgICAgIHNpZGViYXJzLFxuICAgICAgICAgIHZpZXdzXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCByZWdpc3RyeSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGJyaWRnZSA9IGNyZWF0ZSQzKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhZGRBdXRvY29tcGxldGVyOiBicmlkZ2UuYWRkQXV0b2NvbXBsZXRlcixcbiAgICAgICAgYWRkQnV0dG9uOiBicmlkZ2UuYWRkQnV0dG9uLFxuICAgICAgICBhZGRDb250ZXh0Rm9ybTogYnJpZGdlLmFkZENvbnRleHRGb3JtLFxuICAgICAgICBhZGRDb250ZXh0TWVudTogYnJpZGdlLmFkZENvbnRleHRNZW51LFxuICAgICAgICBhZGRDb250ZXh0VG9vbGJhcjogYnJpZGdlLmFkZENvbnRleHRUb29sYmFyLFxuICAgICAgICBhZGRJY29uOiBicmlkZ2UuYWRkSWNvbixcbiAgICAgICAgYWRkTWVudUJ1dHRvbjogYnJpZGdlLmFkZE1lbnVCdXR0b24sXG4gICAgICAgIGFkZE1lbnVJdGVtOiBicmlkZ2UuYWRkTWVudUl0ZW0sXG4gICAgICAgIGFkZE5lc3RlZE1lbnVJdGVtOiBicmlkZ2UuYWRkTmVzdGVkTWVudUl0ZW0sXG4gICAgICAgIGFkZFNpZGViYXI6IGJyaWRnZS5hZGRTaWRlYmFyLFxuICAgICAgICBhZGRTcGxpdEJ1dHRvbjogYnJpZGdlLmFkZFNwbGl0QnV0dG9uLFxuICAgICAgICBhZGRUb2dnbGVCdXR0b246IGJyaWRnZS5hZGRUb2dnbGVCdXR0b24sXG4gICAgICAgIGFkZEdyb3VwVG9vbGJhckJ1dHRvbjogYnJpZGdlLmFkZEdyb3VwVG9vbGJhckJ1dHRvbixcbiAgICAgICAgYWRkVG9nZ2xlTWVudUl0ZW06IGJyaWRnZS5hZGRUb2dnbGVNZW51SXRlbSxcbiAgICAgICAgYWRkVmlldzogYnJpZGdlLmFkZFZpZXcsXG4gICAgICAgIGdldEFsbDogYnJpZGdlLmdldEFsbFxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgRE9NJDEgPSBET01VdGlscy5ET007XG4gICAgY29uc3QgZXh0ZW5kID0gVG9vbHMuZXh0ZW5kLCBlYWNoJDEgPSBUb29scy5lYWNoO1xuICAgIGNsYXNzIEVkaXRvciB7XG4gICAgICBjb25zdHJ1Y3RvcihpZCwgb3B0aW9ucywgZWRpdG9yTWFuYWdlcikge1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSB7fTtcbiAgICAgICAgdGhpcy5jb250ZW50Q1NTID0gW107XG4gICAgICAgIHRoaXMuY29udGVudFN0eWxlcyA9IFtdO1xuICAgICAgICB0aGlzLmxvYWRlZENTUyA9IHt9O1xuICAgICAgICB0aGlzLmlzTm90RGlydHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNIaWRkZW5JbnB1dCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlmcmFtZUVsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVhZG9ubHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZW1vdmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhcnRDb250ZW50ID0gJyc7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdOYXRpdmVFdmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5fc2tpbkxvYWRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVkaXRvck1hbmFnZXIgPSBlZGl0b3JNYW5hZ2VyO1xuICAgICAgICB0aGlzLmRvY3VtZW50QmFzZVVybCA9IGVkaXRvck1hbmFnZXIuZG9jdW1lbnRCYXNlVVJMO1xuICAgICAgICBleHRlbmQodGhpcywgRWRpdG9yT2JzZXJ2YWJsZSk7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuaGlkZGVuID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRPcHRpb25zID0gbm9ybWFsaXplT3B0aW9ucyhlZGl0b3JNYW5hZ2VyLmRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gY3JlYXRlJDUoc2VsZiwgbm9ybWFsaXplZE9wdGlvbnMpO1xuICAgICAgICByZWdpc3RlciQ3KHNlbGYpO1xuICAgICAgICBjb25zdCBnZXRPcHRpb24gPSB0aGlzLm9wdGlvbnMuZ2V0O1xuICAgICAgICBpZiAoZ2V0T3B0aW9uKCdkZXByZWNhdGlvbl93YXJuaW5ncycpKSB7XG4gICAgICAgICAgbG9nV2FybmluZ3Mob3B0aW9ucywgbm9ybWFsaXplZE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN1ZmZpeCA9IGdldE9wdGlvbignc3VmZml4Jyk7XG4gICAgICAgIGlmIChzdWZmaXgpIHtcbiAgICAgICAgICBlZGl0b3JNYW5hZ2VyLnN1ZmZpeCA9IHN1ZmZpeDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN1ZmZpeCA9IGVkaXRvck1hbmFnZXIuc3VmZml4O1xuICAgICAgICBjb25zdCBiYXNlVXJsID0gZ2V0T3B0aW9uKCdiYXNlX3VybCcpO1xuICAgICAgICBpZiAoYmFzZVVybCkge1xuICAgICAgICAgIGVkaXRvck1hbmFnZXIuX3NldEJhc2VVcmwoYmFzZVVybCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iYXNlVXJpID0gZWRpdG9yTWFuYWdlci5iYXNlVVJJO1xuICAgICAgICBjb25zdCByZWZlcnJlclBvbGljeSA9IGdldFJlZmVycmVyUG9saWN5KHNlbGYpO1xuICAgICAgICBpZiAocmVmZXJyZXJQb2xpY3kpIHtcbiAgICAgICAgICBTY3JpcHRMb2FkZXIuU2NyaXB0TG9hZGVyLl9zZXRSZWZlcnJlclBvbGljeShyZWZlcnJlclBvbGljeSk7XG4gICAgICAgICAgRE9NVXRpbHMuRE9NLnN0eWxlU2hlZXRMb2FkZXIuX3NldFJlZmVycmVyUG9saWN5KHJlZmVycmVyUG9saWN5KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250ZW50Q3NzQ29ycyA9IGhhc0NvbnRlbnRDc3NDb3JzKHNlbGYpO1xuICAgICAgICBpZiAoaXNOb25OdWxsYWJsZShjb250ZW50Q3NzQ29ycykpIHtcbiAgICAgICAgICBET01VdGlscy5ET00uc3R5bGVTaGVldExvYWRlci5fc2V0Q29udGVudENzc0NvcnMoY29udGVudENzc0NvcnMpO1xuICAgICAgICB9XG4gICAgICAgIEFkZE9uTWFuYWdlci5sYW5ndWFnZUxvYWQgPSBnZXRPcHRpb24oJ2xhbmd1YWdlX2xvYWQnKTtcbiAgICAgICAgQWRkT25NYW5hZ2VyLmJhc2VVUkwgPSBlZGl0b3JNYW5hZ2VyLmJhc2VVUkw7XG4gICAgICAgIHRoaXMuc2V0RGlydHkoZmFsc2UpO1xuICAgICAgICB0aGlzLmRvY3VtZW50QmFzZVVSSSA9IG5ldyBVUkkoZ2V0RG9jdW1lbnRCYXNlVXJsKHNlbGYpLCB7IGJhc2VfdXJpOiB0aGlzLmJhc2VVcmkgfSk7XG4gICAgICAgIHRoaXMuYmFzZVVSSSA9IHRoaXMuYmFzZVVyaTtcbiAgICAgICAgdGhpcy5pbmxpbmUgPSBpc0lubGluZShzZWxmKTtcbiAgICAgICAgdGhpcy5oYXNWaXN1YWwgPSBpc1Zpc3VhbEFpZHNFbmFibGVkKHNlbGYpO1xuICAgICAgICB0aGlzLnNob3J0Y3V0cyA9IG5ldyBTaG9ydGN1dHModGhpcyk7XG4gICAgICAgIHRoaXMuZWRpdG9yQ29tbWFuZHMgPSBuZXcgRWRpdG9yQ29tbWFuZHModGhpcyk7XG4gICAgICAgIHJlZ2lzdGVyQ29tbWFuZHModGhpcyk7XG4gICAgICAgIGNvbnN0IGNhY2hlU3VmZml4ID0gZ2V0T3B0aW9uKCdjYWNoZV9zdWZmaXgnKTtcbiAgICAgICAgaWYgKGNhY2hlU3VmZml4KSB7XG4gICAgICAgICAgRW52LmNhY2hlU3VmZml4ID0gY2FjaGVTdWZmaXgucmVwbGFjZSgvXltcXD9cXCZdKy8sICcnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVpID0ge1xuICAgICAgICAgIHJlZ2lzdHJ5OiByZWdpc3RyeSgpLFxuICAgICAgICAgIHN0eWxlU2hlZXRMb2FkZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICBzaG93OiBub29wLFxuICAgICAgICAgIGhpZGU6IG5vb3AsXG4gICAgICAgICAgc2V0RW5hYmxlZDogbm9vcCxcbiAgICAgICAgICBpc0VuYWJsZWQ6IGFsd2F5c1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm1vZGUgPSBjcmVhdGUkNChzZWxmKTtcbiAgICAgICAgZWRpdG9yTWFuYWdlci5kaXNwYXRjaCgnU2V0dXBFZGl0b3InLCB7IGVkaXRvcjogdGhpcyB9KTtcbiAgICAgICAgY29uc3Qgc2V0dXBDYWxsYmFjayA9IGdldFNldHVwQ2FsbGJhY2soc2VsZik7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHNldHVwQ2FsbGJhY2spKSB7XG4gICAgICAgICAgc2V0dXBDYWxsYmFjay5jYWxsKHNlbGYsIHNlbGYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZW5kZXIoKSB7XG4gICAgICAgIHJlbmRlcih0aGlzKTtcbiAgICAgIH1cbiAgICAgIGZvY3VzKHNraXBGb2N1cykge1xuICAgICAgICB0aGlzLmV4ZWNDb21tYW5kKCdtY2VGb2N1cycsIGZhbHNlLCBza2lwRm9jdXMpO1xuICAgICAgfVxuICAgICAgaGFzRm9jdXMoKSB7XG4gICAgICAgIHJldHVybiBoYXNGb2N1cyh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRyYW5zbGF0ZSh0ZXh0KSB7XG4gICAgICAgIHJldHVybiBJMThuLnRyYW5zbGF0ZSh0ZXh0KTtcbiAgICAgIH1cbiAgICAgIGdldFBhcmFtKG5hbWUsIGRlZmF1bHRWYWwsIHR5cGUpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaWYgKCFvcHRpb25zLmlzUmVnaXN0ZXJlZChuYW1lKSkge1xuICAgICAgICAgIGlmIChpc05vbk51bGxhYmxlKHR5cGUpKSB7XG4gICAgICAgICAgICBvcHRpb25zLnJlZ2lzdGVyKG5hbWUsIHtcbiAgICAgICAgICAgICAgcHJvY2Vzc29yOiB0eXBlLFxuICAgICAgICAgICAgICBkZWZhdWx0OiBkZWZhdWx0VmFsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucy5yZWdpc3RlcihuYW1lLCB7XG4gICAgICAgICAgICAgIHByb2Nlc3NvcjogYWx3YXlzLFxuICAgICAgICAgICAgICBkZWZhdWx0OiBkZWZhdWx0VmFsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFvcHRpb25zLmlzU2V0KG5hbWUpICYmICFpc1VuZGVmaW5lZChkZWZhdWx0VmFsKSA/IGRlZmF1bHRWYWwgOiBvcHRpb25zLmdldChuYW1lKTtcbiAgICAgIH1cbiAgICAgIGhhc1BsdWdpbihuYW1lLCBsb2FkZWQpIHtcbiAgICAgICAgY29uc3QgaGFzUGx1Z2luID0gY29udGFpbnMkMihnZXRQbHVnaW5zKHRoaXMpLCBuYW1lKTtcbiAgICAgICAgaWYgKGhhc1BsdWdpbikge1xuICAgICAgICAgIHJldHVybiBsb2FkZWQgPyBQbHVnaW5NYW5hZ2VyLmdldChuYW1lKSAhPT0gdW5kZWZpbmVkIDogdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5vZGVDaGFuZ2VkKGFyZ3MpIHtcbiAgICAgICAgdGhpcy5fbm9kZUNoYW5nZURpc3BhdGNoZXIubm9kZUNoYW5nZWQoYXJncyk7XG4gICAgICB9XG4gICAgICBhZGRDb21tYW5kKG5hbWUsIGNhbGxiYWNrLCBzY29wZSkge1xuICAgICAgICB0aGlzLmVkaXRvckNvbW1hbmRzLmFkZENvbW1hbmQobmFtZSwgY2FsbGJhY2ssIHNjb3BlKTtcbiAgICAgIH1cbiAgICAgIGFkZFF1ZXJ5U3RhdGVIYW5kbGVyKG5hbWUsIGNhbGxiYWNrLCBzY29wZSkge1xuICAgICAgICB0aGlzLmVkaXRvckNvbW1hbmRzLmFkZFF1ZXJ5U3RhdGVIYW5kbGVyKG5hbWUsIGNhbGxiYWNrLCBzY29wZSk7XG4gICAgICB9XG4gICAgICBhZGRRdWVyeVZhbHVlSGFuZGxlcihuYW1lLCBjYWxsYmFjaywgc2NvcGUpIHtcbiAgICAgICAgdGhpcy5lZGl0b3JDb21tYW5kcy5hZGRRdWVyeVZhbHVlSGFuZGxlcihuYW1lLCBjYWxsYmFjaywgc2NvcGUpO1xuICAgICAgfVxuICAgICAgYWRkU2hvcnRjdXQocGF0dGVybiwgZGVzYywgY21kRnVuYywgc2NvcGUpIHtcbiAgICAgICAgdGhpcy5zaG9ydGN1dHMuYWRkKHBhdHRlcm4sIGRlc2MsIGNtZEZ1bmMsIHNjb3BlKTtcbiAgICAgIH1cbiAgICAgIGV4ZWNDb21tYW5kKGNtZCwgdWksIHZhbHVlLCBhcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRvckNvbW1hbmRzLmV4ZWNDb21tYW5kKGNtZCwgdWksIHZhbHVlLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5Q29tbWFuZFN0YXRlKGNtZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lZGl0b3JDb21tYW5kcy5xdWVyeUNvbW1hbmRTdGF0ZShjbWQpO1xuICAgICAgfVxuICAgICAgcXVlcnlDb21tYW5kVmFsdWUoY21kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRvckNvbW1hbmRzLnF1ZXJ5Q29tbWFuZFZhbHVlKGNtZCk7XG4gICAgICB9XG4gICAgICBxdWVyeUNvbW1hbmRTdXBwb3J0ZWQoY21kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRvckNvbW1hbmRzLnF1ZXJ5Q29tbWFuZFN1cHBvcnRlZChjbWQpO1xuICAgICAgfVxuICAgICAgc2hvdygpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmIChzZWxmLmhpZGRlbikge1xuICAgICAgICAgIHNlbGYuaGlkZGVuID0gZmFsc2U7XG4gICAgICAgICAgaWYgKHNlbGYuaW5saW5lKSB7XG4gICAgICAgICAgICBzZWxmLmdldEJvZHkoKS5jb250ZW50RWRpdGFibGUgPSAndHJ1ZSc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIERPTSQxLnNob3coc2VsZi5nZXRDb250YWluZXIoKSk7XG4gICAgICAgICAgICBET00kMS5oaWRlKHNlbGYuaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLmxvYWQoKTtcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoKCdzaG93Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGhpZGUoKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoIXNlbGYuaGlkZGVuKSB7XG4gICAgICAgICAgc2VsZi5zYXZlKCk7XG4gICAgICAgICAgaWYgKHNlbGYuaW5saW5lKSB7XG4gICAgICAgICAgICBzZWxmLmdldEJvZHkoKS5jb250ZW50RWRpdGFibGUgPSAnZmFsc2UnO1xuICAgICAgICAgICAgaWYgKHNlbGYgPT09IHNlbGYuZWRpdG9yTWFuYWdlci5mb2N1c2VkRWRpdG9yKSB7XG4gICAgICAgICAgICAgIHNlbGYuZWRpdG9yTWFuYWdlci5mb2N1c2VkRWRpdG9yID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgRE9NJDEuaGlkZShzZWxmLmdldENvbnRhaW5lcigpKTtcbiAgICAgICAgICAgIERPTSQxLnNldFN0eWxlKHNlbGYuaWQsICdkaXNwbGF5Jywgc2VsZi5vcmdEaXNwbGF5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5oaWRkZW4gPSB0cnVlO1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2goJ2hpZGUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaXNIaWRkZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhpZGRlbjtcbiAgICAgIH1cbiAgICAgIHNldFByb2dyZXNzU3RhdGUoc3RhdGUsIHRpbWUpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCgnUHJvZ3Jlc3NTdGF0ZScsIHtcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB0aW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbG9hZChhcmdzID0ge30pIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGVsbSA9IHNlbGYuZ2V0RWxlbWVudCgpO1xuICAgICAgICBpZiAoc2VsZi5yZW1vdmVkKSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbG0pIHtcbiAgICAgICAgICBjb25zdCBsb2FkQXJncyA9IHtcbiAgICAgICAgICAgIC4uLmFyZ3MsXG4gICAgICAgICAgICBsb2FkOiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGlzVGV4dGFyZWFPcklucHV0KGVsbSkgPyBlbG0udmFsdWUgOiBlbG0uaW5uZXJIVE1MO1xuICAgICAgICAgIGNvbnN0IGh0bWwgPSBzZWxmLnNldENvbnRlbnQodmFsdWUsIGxvYWRBcmdzKTtcbiAgICAgICAgICBpZiAoIWxvYWRBcmdzLm5vX2V2ZW50cykge1xuICAgICAgICAgICAgc2VsZi5kaXNwYXRjaCgnTG9hZENvbnRlbnQnLCB7XG4gICAgICAgICAgICAgIC4uLmxvYWRBcmdzLFxuICAgICAgICAgICAgICBlbGVtZW50OiBlbG1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaHRtbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNhdmUoYXJncyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBsZXQgZWxtID0gc2VsZi5nZXRFbGVtZW50KCk7XG4gICAgICAgIGlmICghZWxtIHx8ICFzZWxmLmluaXRpYWxpemVkIHx8IHNlbGYucmVtb3ZlZCkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBnZXRBcmdzID0ge1xuICAgICAgICAgIC4uLmFyZ3MsXG4gICAgICAgICAgc2F2ZTogdHJ1ZSxcbiAgICAgICAgICBlbGVtZW50OiBlbG1cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGh0bWwgPSBzZWxmLmdldENvbnRlbnQoZ2V0QXJncyk7XG4gICAgICAgIGNvbnN0IHNhdmVBcmdzID0ge1xuICAgICAgICAgIC4uLmdldEFyZ3MsXG4gICAgICAgICAgY29udGVudDogaHRtbFxuICAgICAgICB9O1xuICAgICAgICBpZiAoIXNhdmVBcmdzLm5vX2V2ZW50cykge1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2goJ1NhdmVDb250ZW50Jywgc2F2ZUFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzYXZlQXJncy5mb3JtYXQgPT09ICdyYXcnKSB7XG4gICAgICAgICAgc2VsZi5kaXNwYXRjaCgnUmF3U2F2ZUNvbnRlbnQnLCBzYXZlQXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgaHRtbCA9IHNhdmVBcmdzLmNvbnRlbnQ7XG4gICAgICAgIGlmICghaXNUZXh0YXJlYU9ySW5wdXQoZWxtKSkge1xuICAgICAgICAgIGlmIChhcmdzLmlzX3JlbW92aW5nIHx8ICFzZWxmLmlubGluZSkge1xuICAgICAgICAgICAgZWxtLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGZvcm0gPSBET00kMS5nZXRQYXJlbnQoc2VsZi5pZCwgJ2Zvcm0nKTtcbiAgICAgICAgICBpZiAoZm9ybSkge1xuICAgICAgICAgICAgZWFjaCQxKGZvcm0uZWxlbWVudHMsIGVsbSA9PiB7XG4gICAgICAgICAgICAgIGlmIChlbG0ubmFtZSA9PT0gc2VsZi5pZCkge1xuICAgICAgICAgICAgICAgIGVsbS52YWx1ZSA9IGh0bWw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxtLnZhbHVlID0gaHRtbDtcbiAgICAgICAgfVxuICAgICAgICBzYXZlQXJncy5lbGVtZW50ID0gZ2V0QXJncy5lbGVtZW50ID0gZWxtID0gbnVsbDtcbiAgICAgICAgaWYgKHNhdmVBcmdzLnNldF9kaXJ0eSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBzZWxmLnNldERpcnR5KGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICAgIH1cbiAgICAgIHNldENvbnRlbnQoY29udGVudCwgYXJncykge1xuICAgICAgICByZXR1cm4gc2V0Q29udGVudCh0aGlzLCBjb250ZW50LCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIGdldENvbnRlbnQoYXJncykge1xuICAgICAgICByZXR1cm4gZ2V0Q29udGVudCh0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIGluc2VydENvbnRlbnQoY29udGVudCwgYXJncykge1xuICAgICAgICBpZiAoYXJncykge1xuICAgICAgICAgIGNvbnRlbnQgPSBleHRlbmQoeyBjb250ZW50IH0sIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXhlY0NvbW1hbmQoJ21jZUluc2VydENvbnRlbnQnLCBmYWxzZSwgY29udGVudCk7XG4gICAgICB9XG4gICAgICByZXNldENvbnRlbnQoaW5pdGlhbENvbnRlbnQpIHtcbiAgICAgICAgaWYgKGluaXRpYWxDb250ZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzZXRDb250ZW50KHRoaXMsIHRoaXMuc3RhcnRDb250ZW50LCB7IGZvcm1hdDogJ3JhdycgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0Q29udGVudCh0aGlzLCBpbml0aWFsQ29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51bmRvTWFuYWdlci5yZXNldCgpO1xuICAgICAgICB0aGlzLnNldERpcnR5KGZhbHNlKTtcbiAgICAgICAgdGhpcy5ub2RlQ2hhbmdlZCgpO1xuICAgICAgfVxuICAgICAgaXNEaXJ0eSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzTm90RGlydHk7XG4gICAgICB9XG4gICAgICBzZXREaXJ0eShzdGF0ZSkge1xuICAgICAgICBjb25zdCBvbGRTdGF0ZSA9ICF0aGlzLmlzTm90RGlydHk7XG4gICAgICAgIHRoaXMuaXNOb3REaXJ0eSA9ICFzdGF0ZTtcbiAgICAgICAgaWYgKHN0YXRlICYmIHN0YXRlICE9PSBvbGRTdGF0ZSkge1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2goJ2RpcnR5Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGdldENvbnRhaW5lcigpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmICghc2VsZi5jb250YWluZXIpIHtcbiAgICAgICAgICBzZWxmLmNvbnRhaW5lciA9IHNlbGYuZWRpdG9yQ29udGFpbmVyIHx8IERPTSQxLmdldChzZWxmLmlkICsgJ19wYXJlbnQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZi5jb250YWluZXI7XG4gICAgICB9XG4gICAgICBnZXRDb250ZW50QXJlYUNvbnRhaW5lcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudEFyZWFDb250YWluZXI7XG4gICAgICB9XG4gICAgICBnZXRFbGVtZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMudGFyZ2V0RWxtKSB7XG4gICAgICAgICAgdGhpcy50YXJnZXRFbG0gPSBET00kMS5nZXQodGhpcy5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0RWxtO1xuICAgICAgfVxuICAgICAgZ2V0V2luKCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKCFzZWxmLmNvbnRlbnRXaW5kb3cpIHtcbiAgICAgICAgICBjb25zdCBlbG0gPSBzZWxmLmlmcmFtZUVsZW1lbnQ7XG4gICAgICAgICAgaWYgKGVsbSkge1xuICAgICAgICAgICAgc2VsZi5jb250ZW50V2luZG93ID0gZWxtLmNvbnRlbnRXaW5kb3c7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmLmNvbnRlbnRXaW5kb3c7XG4gICAgICB9XG4gICAgICBnZXREb2MoKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoIXNlbGYuY29udGVudERvY3VtZW50KSB7XG4gICAgICAgICAgY29uc3Qgd2luID0gc2VsZi5nZXRXaW4oKTtcbiAgICAgICAgICBpZiAod2luKSB7XG4gICAgICAgICAgICBzZWxmLmNvbnRlbnREb2N1bWVudCA9IHdpbi5kb2N1bWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGYuY29udGVudERvY3VtZW50O1xuICAgICAgfVxuICAgICAgZ2V0Qm9keSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgZG9jID0gdGhpcy5nZXREb2MoKTtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuYm9keUVsZW1lbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRvYyA9PT0gbnVsbCB8fCBkb2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRvYy5ib2R5KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsO1xuICAgICAgfVxuICAgICAgY29udmVydFVSTCh1cmwsIG5hbWUsIGVsbSkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcywgZ2V0T3B0aW9uID0gc2VsZi5vcHRpb25zLmdldDtcbiAgICAgICAgY29uc3QgdXJsQ29udmVydGVyQ2FsbGJhY2sgPSBnZXRVcmxDb252ZXJ0ZXJDYWxsYmFjayhzZWxmKTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odXJsQ29udmVydGVyQ2FsbGJhY2spKSB7XG4gICAgICAgICAgcmV0dXJuIHVybENvbnZlcnRlckNhbGxiYWNrLmNhbGwoc2VsZiwgdXJsLCBlbG0sIHRydWUsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZ2V0T3B0aW9uKCdjb252ZXJ0X3VybHMnKSB8fCBlbG0gPT09ICdsaW5rJyB8fCBpc09iamVjdChlbG0pICYmIGVsbS5ub2RlTmFtZSA9PT0gJ0xJTksnIHx8IHVybC5pbmRleE9mKCdmaWxlOicpID09PSAwIHx8IHVybC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZXRPcHRpb24oJ3JlbGF0aXZlX3VybHMnKSkge1xuICAgICAgICAgIHJldHVybiBzZWxmLmRvY3VtZW50QmFzZVVSSS50b1JlbGF0aXZlKHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgdXJsID0gc2VsZi5kb2N1bWVudEJhc2VVUkkudG9BYnNvbHV0ZSh1cmwsIGdldE9wdGlvbigncmVtb3ZlX3NjcmlwdF9ob3N0JykpO1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgfVxuICAgICAgYWRkVmlzdWFsKGVsbSkge1xuICAgICAgICBhZGRWaXN1YWwodGhpcywgZWxtKTtcbiAgICAgIH1cbiAgICAgIHJlbW92ZSgpIHtcbiAgICAgICAgcmVtb3ZlJDEodGhpcyk7XG4gICAgICB9XG4gICAgICBkZXN0cm95KGF1dG9tYXRpYykge1xuICAgICAgICBkZXN0cm95KHRoaXMsIGF1dG9tYXRpYyk7XG4gICAgICB9XG4gICAgICB1cGxvYWRJbWFnZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRvclVwbG9hZC51cGxvYWRJbWFnZXMoKTtcbiAgICAgIH1cbiAgICAgIF9zY2FuRm9ySW1hZ2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lZGl0b3JVcGxvYWQuc2NhbkZvckltYWdlcygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IERPTSA9IERPTVV0aWxzLkRPTTtcbiAgICBjb25zdCBlYWNoID0gVG9vbHMuZWFjaDtcbiAgICBsZXQgYm91bmRHbG9iYWxFdmVudHMgPSBmYWxzZTtcbiAgICBsZXQgYmVmb3JlVW5sb2FkRGVsZWdhdGU7XG4gICAgbGV0IGVkaXRvcnMgPSBbXTtcbiAgICBjb25zdCBnbG9iYWxFdmVudERlbGVnYXRlID0gZSA9PiB7XG4gICAgICBjb25zdCB0eXBlID0gZS50eXBlO1xuICAgICAgZWFjaChFZGl0b3JNYW5hZ2VyLmdldCgpLCBlZGl0b3IgPT4ge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnc2Nyb2xsJzpcbiAgICAgICAgICBlZGl0b3IuZGlzcGF0Y2goJ1Njcm9sbFdpbmRvdycsIGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyZXNpemUnOlxuICAgICAgICAgIGVkaXRvci5kaXNwYXRjaCgnUmVzaXplV2luZG93JywgZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgdG9nZ2xlR2xvYmFsRXZlbnRzID0gc3RhdGUgPT4ge1xuICAgICAgaWYgKHN0YXRlICE9PSBib3VuZEdsb2JhbEV2ZW50cykge1xuICAgICAgICBjb25zdCBET00gPSBET01VdGlscy5ET007XG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgIERPTS5iaW5kKHdpbmRvdywgJ3Jlc2l6ZScsIGdsb2JhbEV2ZW50RGVsZWdhdGUpO1xuICAgICAgICAgIERPTS5iaW5kKHdpbmRvdywgJ3Njcm9sbCcsIGdsb2JhbEV2ZW50RGVsZWdhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIERPTS51bmJpbmQod2luZG93LCAncmVzaXplJywgZ2xvYmFsRXZlbnREZWxlZ2F0ZSk7XG4gICAgICAgICAgRE9NLnVuYmluZCh3aW5kb3csICdzY3JvbGwnLCBnbG9iYWxFdmVudERlbGVnYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBib3VuZEdsb2JhbEV2ZW50cyA9IHN0YXRlO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmVtb3ZlRWRpdG9yRnJvbUxpc3QgPSB0YXJnZXRFZGl0b3IgPT4ge1xuICAgICAgY29uc3Qgb2xkRWRpdG9ycyA9IGVkaXRvcnM7XG4gICAgICBlZGl0b3JzID0gZmlsdGVyJDUoZWRpdG9ycywgZWRpdG9yID0+IHtcbiAgICAgICAgcmV0dXJuIHRhcmdldEVkaXRvciAhPT0gZWRpdG9yO1xuICAgICAgfSk7XG4gICAgICBpZiAoRWRpdG9yTWFuYWdlci5hY3RpdmVFZGl0b3IgPT09IHRhcmdldEVkaXRvcikge1xuICAgICAgICBFZGl0b3JNYW5hZ2VyLmFjdGl2ZUVkaXRvciA9IGVkaXRvcnMubGVuZ3RoID4gMCA/IGVkaXRvcnNbMF0gOiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKEVkaXRvck1hbmFnZXIuZm9jdXNlZEVkaXRvciA9PT0gdGFyZ2V0RWRpdG9yKSB7XG4gICAgICAgIEVkaXRvck1hbmFnZXIuZm9jdXNlZEVkaXRvciA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2xkRWRpdG9ycy5sZW5ndGggIT09IGVkaXRvcnMubGVuZ3RoO1xuICAgIH07XG4gICAgY29uc3QgcHVyZ2VEZXN0cm95ZWRFZGl0b3IgPSBlZGl0b3IgPT4ge1xuICAgICAgaWYgKGVkaXRvciAmJiBlZGl0b3IuaW5pdGlhbGl6ZWQgJiYgIShlZGl0b3IuZ2V0Q29udGFpbmVyKCkgfHwgZWRpdG9yLmdldEJvZHkoKSkucGFyZW50Tm9kZSkge1xuICAgICAgICByZW1vdmVFZGl0b3JGcm9tTGlzdChlZGl0b3IpO1xuICAgICAgICBlZGl0b3IudW5iaW5kQWxsTmF0aXZlRXZlbnRzKCk7XG4gICAgICAgIGVkaXRvci5kZXN0cm95KHRydWUpO1xuICAgICAgICBlZGl0b3IucmVtb3ZlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpc1F1aXJrc01vZGUgPSBkb2N1bWVudC5jb21wYXRNb2RlICE9PSAnQ1NTMUNvbXBhdCc7XG4gICAgY29uc3QgRWRpdG9yTWFuYWdlciA9IHtcbiAgICAgIC4uLk9ic2VydmFibGUsXG4gICAgICBiYXNlVVJJOiBudWxsLFxuICAgICAgYmFzZVVSTDogbnVsbCxcbiAgICAgIGRlZmF1bHRPcHRpb25zOiB7fSxcbiAgICAgIGRvY3VtZW50QmFzZVVSTDogbnVsbCxcbiAgICAgIHN1ZmZpeDogbnVsbCxcbiAgICAgIG1ham9yVmVyc2lvbjogJzYnLFxuICAgICAgbWlub3JWZXJzaW9uOiAnNC4yJyxcbiAgICAgIHJlbGVhc2VEYXRlOiAnMjAyMy0wNC0yNicsXG4gICAgICBpMThuOiBJMThuLFxuICAgICAgYWN0aXZlRWRpdG9yOiBudWxsLFxuICAgICAgZm9jdXNlZEVkaXRvcjogbnVsbCxcbiAgICAgIHNldHVwKCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgbGV0IGJhc2VVUkwgPSAnJztcbiAgICAgICAgbGV0IHN1ZmZpeCA9ICcnO1xuICAgICAgICBsZXQgZG9jdW1lbnRCYXNlVVJMID0gVVJJLmdldERvY3VtZW50QmFzZVVybChkb2N1bWVudC5sb2NhdGlvbik7XG4gICAgICAgIGlmICgvXlteOl0rOlxcL1xcL1xcLz9bXlxcL10rXFwvLy50ZXN0KGRvY3VtZW50QmFzZVVSTCkpIHtcbiAgICAgICAgICBkb2N1bWVudEJhc2VVUkwgPSBkb2N1bWVudEJhc2VVUkwucmVwbGFjZSgvW1xcPyNdLiokLywgJycpLnJlcGxhY2UoL1tcXC9cXFxcXVteXFwvXSskLywgJycpO1xuICAgICAgICAgIGlmICghL1tcXC9cXFxcXSQvLnRlc3QoZG9jdW1lbnRCYXNlVVJMKSkge1xuICAgICAgICAgICAgZG9jdW1lbnRCYXNlVVJMICs9ICcvJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJlSW5pdCA9IHdpbmRvdy50aW55bWNlIHx8IHdpbmRvdy50aW55TUNFUHJlSW5pdDtcbiAgICAgICAgaWYgKHByZUluaXQpIHtcbiAgICAgICAgICBiYXNlVVJMID0gcHJlSW5pdC5iYXNlIHx8IHByZUluaXQuYmFzZVVSTDtcbiAgICAgICAgICBzdWZmaXggPSBwcmVJbml0LnN1ZmZpeDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2NyaXB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc3JjID0gc2NyaXB0c1tpXS5zcmMgfHwgJyc7XG4gICAgICAgICAgICBpZiAoc3JjID09PSAnJykge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNyY1NjcmlwdCA9IHNyYy5zdWJzdHJpbmcoc3JjLmxhc3RJbmRleE9mKCcvJykpO1xuICAgICAgICAgICAgaWYgKC90aW55bWNlKFxcLmZ1bGx8XFwuanF1ZXJ5fCkoXFwubWlufFxcLmRldnwpXFwuanMvLnRlc3Qoc3JjKSkge1xuICAgICAgICAgICAgICBpZiAoc3JjU2NyaXB0LmluZGV4T2YoJy5taW4nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBzdWZmaXggPSAnLm1pbic7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYmFzZVVSTCA9IHNyYy5zdWJzdHJpbmcoMCwgc3JjLmxhc3RJbmRleE9mKCcvJykpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFiYXNlVVJMICYmIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNyYyA9IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjO1xuICAgICAgICAgICAgaWYgKHNyYy5pbmRleE9mKCcubWluJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgIHN1ZmZpeCA9ICcubWluJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJhc2VVUkwgPSBzcmMuc3Vic3RyaW5nKDAsIHNyYy5sYXN0SW5kZXhPZignLycpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5iYXNlVVJMID0gbmV3IFVSSShkb2N1bWVudEJhc2VVUkwpLnRvQWJzb2x1dGUoYmFzZVVSTCk7XG4gICAgICAgIHNlbGYuZG9jdW1lbnRCYXNlVVJMID0gZG9jdW1lbnRCYXNlVVJMO1xuICAgICAgICBzZWxmLmJhc2VVUkkgPSBuZXcgVVJJKHNlbGYuYmFzZVVSTCk7XG4gICAgICAgIHNlbGYuc3VmZml4ID0gc3VmZml4O1xuICAgICAgICBzZXR1cCR2KHNlbGYpO1xuICAgICAgfSxcbiAgICAgIG92ZXJyaWRlRGVmYXVsdHMoZGVmYXVsdE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYmFzZVVybCA9IGRlZmF1bHRPcHRpb25zLmJhc2VfdXJsO1xuICAgICAgICBpZiAoYmFzZVVybCkge1xuICAgICAgICAgIHRoaXMuX3NldEJhc2VVcmwoYmFzZVVybCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3VmZml4ID0gZGVmYXVsdE9wdGlvbnMuc3VmZml4O1xuICAgICAgICBpZiAoc3VmZml4KSB7XG4gICAgICAgICAgdGhpcy5zdWZmaXggPSBzdWZmaXg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuICAgICAgICBjb25zdCBwbHVnaW5CYXNlVXJscyA9IGRlZmF1bHRPcHRpb25zLnBsdWdpbl9iYXNlX3VybHM7XG4gICAgICAgIGlmIChwbHVnaW5CYXNlVXJscyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZWFjaCRkKHBsdWdpbkJhc2VVcmxzLCAocGx1Z2luQmFzZVVybCwgcGx1Z2luTmFtZSkgPT4ge1xuICAgICAgICAgICAgQWRkT25NYW5hZ2VyLlBsdWdpbk1hbmFnZXIudXJsc1twbHVnaW5OYW1lXSA9IHBsdWdpbkJhc2VVcmw7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpbml0KG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGNvbnN0IGludmFsaWRJbmxpbmVUYXJnZXRzID0gVG9vbHMubWFrZU1hcCgnYXJlYSBiYXNlIGJhc2Vmb250IGJyIGNvbCBmcmFtZSBociBpbWcgaW5wdXQgaXNpbmRleCBsaW5rIG1ldGEgcGFyYW0gZW1iZWQgc291cmNlIHdiciB0cmFjayAnICsgJ2NvbGdyb3VwIG9wdGlvbiB0YWJsZSB0Ym9keSB0Zm9vdCB0aGVhZCB0ciB0aCB0ZCBzY3JpcHQgbm9zY3JpcHQgc3R5bGUgdGV4dGFyZWEgdmlkZW8gYXVkaW8gaWZyYW1lIG9iamVjdCBtZW51JywgJyAnKTtcbiAgICAgICAgY29uc3QgaXNJbnZhbGlkSW5saW5lVGFyZ2V0ID0gKG9wdGlvbnMsIGVsbSkgPT4gb3B0aW9ucy5pbmxpbmUgJiYgZWxtLnRhZ05hbWUudG9Mb3dlckNhc2UoKSBpbiBpbnZhbGlkSW5saW5lVGFyZ2V0cztcbiAgICAgICAgY29uc3QgY3JlYXRlSWQgPSBlbG0gPT4ge1xuICAgICAgICAgIGxldCBpZCA9IGVsbS5pZDtcbiAgICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgICBpZCA9IGdldCRhKGVsbSwgJ25hbWUnKS5maWx0ZXIobmFtZSA9PiAhRE9NLmdldChuYW1lKSkuZ2V0T3JUaHVuayhET00udW5pcXVlSWQpO1xuICAgICAgICAgICAgZWxtLnNldEF0dHJpYnV0ZSgnaWQnLCBpZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXhlY0NhbGxiYWNrID0gbmFtZSA9PiB7XG4gICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBvcHRpb25zW25hbWVdO1xuICAgICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHNlbGYsIFtdKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZmluZFRhcmdldHMgPSBvcHRpb25zID0+IHtcbiAgICAgICAgICBpZiAoRW52LmJyb3dzZXIuaXNJRSgpIHx8IEVudi5icm93c2VyLmlzRWRnZSgpKSB7XG4gICAgICAgICAgICBpbml0RXJyb3IoJ1RpbnlNQ0UgZG9lcyBub3Qgc3VwcG9ydCB0aGUgYnJvd3NlciB5b3UgYXJlIHVzaW5nLiBGb3IgYSBsaXN0IG9mIHN1cHBvcnRlZCcgKyAnIGJyb3dzZXJzIHBsZWFzZSBzZWU6IGh0dHBzOi8vd3d3LnRpbnkuY2xvdWQvZG9jcy90aW55bWNlLzYvc3VwcG9ydC8jc3VwcG9ydGVkd2ViYnJvd3NlcnMnKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzUXVpcmtzTW9kZSkge1xuICAgICAgICAgICAgaW5pdEVycm9yKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZSB0aGUgZWRpdG9yIGFzIHRoZSBkb2N1bWVudCBpcyBub3QgaW4gc3RhbmRhcmRzIG1vZGUuICcgKyAnVGlueU1DRSByZXF1aXJlcyBzdGFuZGFyZHMgbW9kZS4nKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKG9wdGlvbnMuc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICByZXR1cm4gRE9NLnNlbGVjdChvcHRpb25zLnNlbGVjdG9yKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTm9uTnVsbGFibGUob3B0aW9ucy50YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gW29wdGlvbnMudGFyZ2V0XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHByb3ZpZGVSZXN1bHRzID0gZWRpdG9ycyA9PiB7XG4gICAgICAgICAgcmVzdWx0ID0gZWRpdG9ycztcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaW5pdEVkaXRvcnMgPSAoKSA9PiB7XG4gICAgICAgICAgbGV0IGluaXRDb3VudCA9IDA7XG4gICAgICAgICAgY29uc3QgZWRpdG9ycyA9IFtdO1xuICAgICAgICAgIGxldCB0YXJnZXRzO1xuICAgICAgICAgIGNvbnN0IGNyZWF0ZUVkaXRvciA9IChpZCwgb3B0aW9ucywgdGFyZ2V0RWxtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlZGl0b3IgPSBuZXcgRWRpdG9yKGlkLCBvcHRpb25zLCBzZWxmKTtcbiAgICAgICAgICAgIGVkaXRvcnMucHVzaChlZGl0b3IpO1xuICAgICAgICAgICAgZWRpdG9yLm9uKCdpbml0JywgKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoKytpbml0Q291bnQgPT09IHRhcmdldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZVJlc3VsdHMoZWRpdG9ycyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZWRpdG9yLnRhcmdldEVsbSA9IGVkaXRvci50YXJnZXRFbG0gfHwgdGFyZ2V0RWxtO1xuICAgICAgICAgICAgZWRpdG9yLnJlbmRlcigpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgRE9NLnVuYmluZCh3aW5kb3csICdyZWFkeScsIGluaXRFZGl0b3JzKTtcbiAgICAgICAgICBleGVjQ2FsbGJhY2soJ29ucGFnZWxvYWQnKTtcbiAgICAgICAgICB0YXJnZXRzID0gdW5pcXVlJDEoZmluZFRhcmdldHMob3B0aW9ucykpO1xuICAgICAgICAgIFRvb2xzLmVhY2godGFyZ2V0cywgZWxtID0+IHtcbiAgICAgICAgICAgIHB1cmdlRGVzdHJveWVkRWRpdG9yKHNlbGYuZ2V0KGVsbS5pZCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRhcmdldHMgPSBUb29scy5ncmVwKHRhcmdldHMsIGVsbSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gIXNlbGYuZ2V0KGVsbS5pZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHRhcmdldHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBwcm92aWRlUmVzdWx0cyhbXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVhY2godGFyZ2V0cywgZWxtID0+IHtcbiAgICAgICAgICAgICAgaWYgKGlzSW52YWxpZElubGluZVRhcmdldChvcHRpb25zLCBlbG0pKSB7XG4gICAgICAgICAgICAgICAgaW5pdEVycm9yKCdDb3VsZCBub3QgaW5pdGlhbGl6ZSBpbmxpbmUgZWRpdG9yIG9uIGludmFsaWQgaW5saW5lIHRhcmdldCBlbGVtZW50JywgZWxtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjcmVhdGVFZGl0b3IoY3JlYXRlSWQoZWxtKSwgb3B0aW9ucywgZWxtKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBET00uYmluZCh3aW5kb3csICdyZWFkeScsIGluaXRFZGl0b3JzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvdmlkZVJlc3VsdHMgPSBlZGl0b3JzID0+IHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShlZGl0b3JzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBnZXQoaWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gZWRpdG9ycy5zbGljZSgwKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1N0cmluZyhpZCkpIHtcbiAgICAgICAgICByZXR1cm4gZmluZCQyKGVkaXRvcnMsIGVkaXRvciA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZWRpdG9yLmlkID09PSBpZDtcbiAgICAgICAgICB9KS5nZXRPcihudWxsKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc051bWJlcihpZCkpIHtcbiAgICAgICAgICByZXR1cm4gZWRpdG9yc1tpZF0gPyBlZGl0b3JzW2lkXSA6IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhZGQoZWRpdG9yKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBjb25zdCBleGlzdGluZ0VkaXRvciA9IHNlbGYuZ2V0KGVkaXRvci5pZCk7XG4gICAgICAgIGlmIChleGlzdGluZ0VkaXRvciA9PT0gZWRpdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVkaXRvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhpc3RpbmdFZGl0b3IgPT09IG51bGwpIHtcbiAgICAgICAgICBlZGl0b3JzLnB1c2goZWRpdG9yKTtcbiAgICAgICAgfVxuICAgICAgICB0b2dnbGVHbG9iYWxFdmVudHModHJ1ZSk7XG4gICAgICAgIHNlbGYuYWN0aXZlRWRpdG9yID0gZWRpdG9yO1xuICAgICAgICBzZWxmLmRpc3BhdGNoKCdBZGRFZGl0b3InLCB7IGVkaXRvciB9KTtcbiAgICAgICAgaWYgKCFiZWZvcmVVbmxvYWREZWxlZ2F0ZSkge1xuICAgICAgICAgIGJlZm9yZVVubG9hZERlbGVnYXRlID0gZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IHNlbGYuZGlzcGF0Y2goJ0JlZm9yZVVubG9hZCcpO1xuICAgICAgICAgICAgaWYgKGV2ZW50LnJldHVyblZhbHVlKSB7XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJldHVyblZhbHVlO1xuICAgICAgICAgICAgICByZXR1cm4gZXZlbnQucmV0dXJuVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgYmVmb3JlVW5sb2FkRGVsZWdhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlZGl0b3I7XG4gICAgICB9LFxuICAgICAgY3JlYXRlRWRpdG9yKGlkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChuZXcgRWRpdG9yKGlkLCBvcHRpb25zLCB0aGlzKSk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlKHNlbGVjdG9yKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBsZXQgZWRpdG9yO1xuICAgICAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IGVkaXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHNlbGYucmVtb3ZlKGVkaXRvcnNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyaW5nKHNlbGVjdG9yKSkge1xuICAgICAgICAgIGVhY2goRE9NLnNlbGVjdChzZWxlY3RvciksIGVsbSA9PiB7XG4gICAgICAgICAgICBlZGl0b3IgPSBzZWxmLmdldChlbG0uaWQpO1xuICAgICAgICAgICAgaWYgKGVkaXRvcikge1xuICAgICAgICAgICAgICBzZWxmLnJlbW92ZShlZGl0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlZGl0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgaWYgKGlzTnVsbChzZWxmLmdldChlZGl0b3IuaWQpKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZW1vdmVFZGl0b3JGcm9tTGlzdChlZGl0b3IpKSB7XG4gICAgICAgICAgc2VsZi5kaXNwYXRjaCgnUmVtb3ZlRWRpdG9yJywgeyBlZGl0b3IgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVkaXRvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGJlZm9yZVVubG9hZERlbGVnYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlZGl0b3IucmVtb3ZlKCk7XG4gICAgICAgIHRvZ2dsZUdsb2JhbEV2ZW50cyhlZGl0b3JzLmxlbmd0aCA+IDApO1xuICAgICAgICByZXR1cm4gZWRpdG9yO1xuICAgICAgfSxcbiAgICAgIGV4ZWNDb21tYW5kKGNtZCwgdWksIHZhbHVlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGVkaXRvcklkID0gaXNPYmplY3QodmFsdWUpID8gKF9hID0gdmFsdWUuaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZhbHVlLmluZGV4IDogdmFsdWU7XG4gICAgICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICAgIGNhc2UgJ21jZUFkZEVkaXRvcic6IHtcbiAgICAgICAgICAgIGlmICghc2VsZi5nZXQoZWRpdG9ySWQpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGVkaXRvck9wdGlvbnMgPSB2YWx1ZS5vcHRpb25zO1xuICAgICAgICAgICAgICBuZXcgRWRpdG9yKGVkaXRvcklkLCBlZGl0b3JPcHRpb25zLCBzZWxmKS5yZW5kZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnbWNlUmVtb3ZlRWRpdG9yJzoge1xuICAgICAgICAgICAgY29uc3QgZWRpdG9yID0gc2VsZi5nZXQoZWRpdG9ySWQpO1xuICAgICAgICAgICAgaWYgKGVkaXRvcikge1xuICAgICAgICAgICAgICBlZGl0b3IucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ21jZVRvZ2dsZUVkaXRvcic6IHtcbiAgICAgICAgICAgIGNvbnN0IGVkaXRvciA9IHNlbGYuZ2V0KGVkaXRvcklkKTtcbiAgICAgICAgICAgIGlmICghZWRpdG9yKSB7XG4gICAgICAgICAgICAgIHNlbGYuZXhlY0NvbW1hbmQoJ21jZUFkZEVkaXRvcicsIGZhbHNlLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVkaXRvci5pc0hpZGRlbigpKSB7XG4gICAgICAgICAgICAgIGVkaXRvci5zaG93KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlZGl0b3IuaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLmFjdGl2ZUVkaXRvcikge1xuICAgICAgICAgIHJldHVybiBzZWxmLmFjdGl2ZUVkaXRvci5leGVjQ29tbWFuZChjbWQsIHVpLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIHRyaWdnZXJTYXZlOiAoKSA9PiB7XG4gICAgICAgIGVhY2goZWRpdG9ycywgZWRpdG9yID0+IHtcbiAgICAgICAgICBlZGl0b3Iuc2F2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBhZGRJMThuOiAoY29kZSwgaXRlbXMpID0+IHtcbiAgICAgICAgSTE4bi5hZGQoY29kZSwgaXRlbXMpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zbGF0ZTogdGV4dCA9PiB7XG4gICAgICAgIHJldHVybiBJMThuLnRyYW5zbGF0ZSh0ZXh0KTtcbiAgICAgIH0sXG4gICAgICBzZXRBY3RpdmUoZWRpdG9yKSB7XG4gICAgICAgIGNvbnN0IGFjdGl2ZUVkaXRvciA9IHRoaXMuYWN0aXZlRWRpdG9yO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmVFZGl0b3IgIT09IGVkaXRvcikge1xuICAgICAgICAgIGlmIChhY3RpdmVFZGl0b3IpIHtcbiAgICAgICAgICAgIGFjdGl2ZUVkaXRvci5kaXNwYXRjaCgnZGVhY3RpdmF0ZScsIHsgcmVsYXRlZFRhcmdldDogZWRpdG9yIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlZGl0b3IuZGlzcGF0Y2goJ2FjdGl2YXRlJywgeyByZWxhdGVkVGFyZ2V0OiBhY3RpdmVFZGl0b3IgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmVFZGl0b3IgPSBlZGl0b3I7XG4gICAgICB9LFxuICAgICAgX3NldEJhc2VVcmwoYmFzZVVybCkge1xuICAgICAgICB0aGlzLmJhc2VVUkwgPSBuZXcgVVJJKHRoaXMuZG9jdW1lbnRCYXNlVVJMKS50b0Fic29sdXRlKGJhc2VVcmwucmVwbGFjZSgvXFwvKyQvLCAnJykpO1xuICAgICAgICB0aGlzLmJhc2VVUkkgPSBuZXcgVVJJKHRoaXMuYmFzZVVSTCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBFZGl0b3JNYW5hZ2VyLnNldHVwKCk7XG5cbiAgICBjb25zdCBzZXR1cCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGRhdGFWYWx1ZSA9IHZhbHVlJDIoKTtcbiAgICAgIGNvbnN0IEZha2VDbGlwYm9hcmRJdGVtID0gaXRlbXMgPT4gKHtcbiAgICAgICAgaXRlbXMsXG4gICAgICAgIHR5cGVzOiBrZXlzKGl0ZW1zKSxcbiAgICAgICAgZ2V0VHlwZTogdHlwZSA9PiBnZXQkYShpdGVtcywgdHlwZSkuZ2V0T3JVbmRlZmluZWQoKVxuICAgICAgfSk7XG4gICAgICBjb25zdCB3cml0ZSA9IGRhdGEgPT4ge1xuICAgICAgICBkYXRhVmFsdWUuc2V0KGRhdGEpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlYWQgPSAoKSA9PiBkYXRhVmFsdWUuZ2V0KCkuZ2V0T3JVbmRlZmluZWQoKTtcbiAgICAgIGNvbnN0IGNsZWFyID0gZGF0YVZhbHVlLmNsZWFyO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgRmFrZUNsaXBib2FyZEl0ZW0sXG4gICAgICAgIHdyaXRlLFxuICAgICAgICByZWFkLFxuICAgICAgICBjbGVhclxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IEZha2VDbGlwYm9hcmQgPSBzZXR1cCgpO1xuXG4gICAgY29uc3QgbWluID0gTWF0aC5taW4sIG1heCA9IE1hdGgubWF4LCByb3VuZCA9IE1hdGgucm91bmQ7XG4gICAgY29uc3QgcmVsYXRpdmVQb3NpdGlvbiA9IChyZWN0LCB0YXJnZXRSZWN0LCByZWwpID0+IHtcbiAgICAgIGxldCB4ID0gdGFyZ2V0UmVjdC54O1xuICAgICAgbGV0IHkgPSB0YXJnZXRSZWN0Lnk7XG4gICAgICBjb25zdCB3ID0gcmVjdC53O1xuICAgICAgY29uc3QgaCA9IHJlY3QuaDtcbiAgICAgIGNvbnN0IHRhcmdldFcgPSB0YXJnZXRSZWN0Lnc7XG4gICAgICBjb25zdCB0YXJnZXRIID0gdGFyZ2V0UmVjdC5oO1xuICAgICAgY29uc3QgcmVsQ2hhcnMgPSAocmVsIHx8ICcnKS5zcGxpdCgnJyk7XG4gICAgICBpZiAocmVsQ2hhcnNbMF0gPT09ICdiJykge1xuICAgICAgICB5ICs9IHRhcmdldEg7XG4gICAgICB9XG4gICAgICBpZiAocmVsQ2hhcnNbMV0gPT09ICdyJykge1xuICAgICAgICB4ICs9IHRhcmdldFc7XG4gICAgICB9XG4gICAgICBpZiAocmVsQ2hhcnNbMF0gPT09ICdjJykge1xuICAgICAgICB5ICs9IHJvdW5kKHRhcmdldEggLyAyKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWxDaGFyc1sxXSA9PT0gJ2MnKSB7XG4gICAgICAgIHggKz0gcm91bmQodGFyZ2V0VyAvIDIpO1xuICAgICAgfVxuICAgICAgaWYgKHJlbENoYXJzWzNdID09PSAnYicpIHtcbiAgICAgICAgeSAtPSBoO1xuICAgICAgfVxuICAgICAgaWYgKHJlbENoYXJzWzRdID09PSAncicpIHtcbiAgICAgICAgeCAtPSB3O1xuICAgICAgfVxuICAgICAgaWYgKHJlbENoYXJzWzNdID09PSAnYycpIHtcbiAgICAgICAgeSAtPSByb3VuZChoIC8gMik7XG4gICAgICB9XG4gICAgICBpZiAocmVsQ2hhcnNbNF0gPT09ICdjJykge1xuICAgICAgICB4IC09IHJvdW5kKHcgLyAyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGUkMih4LCB5LCB3LCBoKTtcbiAgICB9O1xuICAgIGNvbnN0IGZpbmRCZXN0UmVsYXRpdmVQb3NpdGlvbiA9IChyZWN0LCB0YXJnZXRSZWN0LCBjb25zdHJhaW5SZWN0LCByZWxzKSA9PiB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcG9zID0gcmVsYXRpdmVQb3NpdGlvbihyZWN0LCB0YXJnZXRSZWN0LCByZWxzW2ldKTtcbiAgICAgICAgaWYgKHBvcy54ID49IGNvbnN0cmFpblJlY3QueCAmJiBwb3MueCArIHBvcy53IDw9IGNvbnN0cmFpblJlY3QudyArIGNvbnN0cmFpblJlY3QueCAmJiBwb3MueSA+PSBjb25zdHJhaW5SZWN0LnkgJiYgcG9zLnkgKyBwb3MuaCA8PSBjb25zdHJhaW5SZWN0LmggKyBjb25zdHJhaW5SZWN0LnkpIHtcbiAgICAgICAgICByZXR1cm4gcmVsc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBjb25zdCBpbmZsYXRlID0gKHJlY3QsIHcsIGgpID0+IHtcbiAgICAgIHJldHVybiBjcmVhdGUkMihyZWN0LnggLSB3LCByZWN0LnkgLSBoLCByZWN0LncgKyB3ICogMiwgcmVjdC5oICsgaCAqIDIpO1xuICAgIH07XG4gICAgY29uc3QgaW50ZXJzZWN0ID0gKHJlY3QsIGNyb3BSZWN0KSA9PiB7XG4gICAgICBjb25zdCB4MSA9IG1heChyZWN0LngsIGNyb3BSZWN0LngpO1xuICAgICAgY29uc3QgeTEgPSBtYXgocmVjdC55LCBjcm9wUmVjdC55KTtcbiAgICAgIGNvbnN0IHgyID0gbWluKHJlY3QueCArIHJlY3QudywgY3JvcFJlY3QueCArIGNyb3BSZWN0LncpO1xuICAgICAgY29uc3QgeTIgPSBtaW4ocmVjdC55ICsgcmVjdC5oLCBjcm9wUmVjdC55ICsgY3JvcFJlY3QuaCk7XG4gICAgICBpZiAoeDIgLSB4MSA8IDAgfHwgeTIgLSB5MSA8IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlJDIoeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxKTtcbiAgICB9O1xuICAgIGNvbnN0IGNsYW1wID0gKHJlY3QsIGNsYW1wUmVjdCwgZml4ZWRTaXplKSA9PiB7XG4gICAgICBsZXQgeDEgPSByZWN0Lng7XG4gICAgICBsZXQgeTEgPSByZWN0Lnk7XG4gICAgICBsZXQgeDIgPSByZWN0LnggKyByZWN0Lnc7XG4gICAgICBsZXQgeTIgPSByZWN0LnkgKyByZWN0Lmg7XG4gICAgICBjb25zdCBjeDIgPSBjbGFtcFJlY3QueCArIGNsYW1wUmVjdC53O1xuICAgICAgY29uc3QgY3kyID0gY2xhbXBSZWN0LnkgKyBjbGFtcFJlY3QuaDtcbiAgICAgIGNvbnN0IHVuZGVyZmxvd1gxID0gbWF4KDAsIGNsYW1wUmVjdC54IC0geDEpO1xuICAgICAgY29uc3QgdW5kZXJmbG93WTEgPSBtYXgoMCwgY2xhbXBSZWN0LnkgLSB5MSk7XG4gICAgICBjb25zdCBvdmVyZmxvd1gyID0gbWF4KDAsIHgyIC0gY3gyKTtcbiAgICAgIGNvbnN0IG92ZXJmbG93WTIgPSBtYXgoMCwgeTIgLSBjeTIpO1xuICAgICAgeDEgKz0gdW5kZXJmbG93WDE7XG4gICAgICB5MSArPSB1bmRlcmZsb3dZMTtcbiAgICAgIGlmIChmaXhlZFNpemUpIHtcbiAgICAgICAgeDIgKz0gdW5kZXJmbG93WDE7XG4gICAgICAgIHkyICs9IHVuZGVyZmxvd1kxO1xuICAgICAgICB4MSAtPSBvdmVyZmxvd1gyO1xuICAgICAgICB5MSAtPSBvdmVyZmxvd1kyO1xuICAgICAgfVxuICAgICAgeDIgLT0gb3ZlcmZsb3dYMjtcbiAgICAgIHkyIC09IG92ZXJmbG93WTI7XG4gICAgICByZXR1cm4gY3JlYXRlJDIoeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxKTtcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZSQyID0gKHgsIHksIHcsIGgpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHcsXG4gICAgICAgIGhcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBmcm9tQ2xpZW50UmVjdCA9IGNsaWVudFJlY3QgPT4ge1xuICAgICAgcmV0dXJuIGNyZWF0ZSQyKGNsaWVudFJlY3QubGVmdCwgY2xpZW50UmVjdC50b3AsIGNsaWVudFJlY3Qud2lkdGgsIGNsaWVudFJlY3QuaGVpZ2h0KTtcbiAgICB9O1xuICAgIGNvbnN0IFJlY3QgPSB7XG4gICAgICBpbmZsYXRlLFxuICAgICAgcmVsYXRpdmVQb3NpdGlvbixcbiAgICAgIGZpbmRCZXN0UmVsYXRpdmVQb3NpdGlvbixcbiAgICAgIGludGVyc2VjdCxcbiAgICAgIGNsYW1wLFxuICAgICAgY3JlYXRlOiBjcmVhdGUkMixcbiAgICAgIGZyb21DbGllbnRSZWN0XG4gICAgfTtcblxuICAgIGNvbnN0IGF3YWl0ZXIgPSAocmVzb2x2ZUNiLCByZWplY3RDYiwgdGltZW91dCA9IDEwMDApID0+IHtcbiAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICBsZXQgdGltZXIgPSBudWxsO1xuICAgICAgY29uc3QgY29tcGxldGUgPSBjb21wbGV0ZXIgPT4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgaWYgKHRpbWVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb21wbGV0ZXIuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCByZXNvbHZlID0gY29tcGxldGUocmVzb2x2ZUNiKTtcbiAgICAgIGNvbnN0IHJlamVjdCA9IGNvbXBsZXRlKHJlamVjdENiKTtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgaWYgKCFkb25lICYmIHRpbWVyID09PSBudWxsKSB7XG4gICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHJlamVjdC5hcHBseShudWxsLCBhcmdzKSwgdGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGFydCxcbiAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgcmVqZWN0XG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgY3JlYXRlJDEgPSAoKSA9PiB7XG4gICAgICBjb25zdCB0YXNrcyA9IHt9O1xuICAgICAgY29uc3QgcmVzdWx0Rm5zID0ge307XG4gICAgICBjb25zdCBsb2FkID0gKGlkLCB1cmwpID0+IHtcbiAgICAgICAgY29uc3QgbG9hZEVyck1zZyA9IGBTY3JpcHQgYXQgVVJMIFwiJHsgdXJsIH1cIiBmYWlsZWQgdG8gbG9hZGA7XG4gICAgICAgIGNvbnN0IHJ1bkVyck1zZyA9IGBTY3JpcHQgYXQgVVJMIFwiJHsgdXJsIH1cIiBkaWQgbm90IGNhbGwgXFxgdGlueW1jZS5SZXNvdXJjZS5hZGQoJyR7IGlkIH0nLCBkYXRhKVxcYCB3aXRoaW4gMSBzZWNvbmRgO1xuICAgICAgICBpZiAodGFza3NbaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gdGFza3NbaWRdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHRhc2sgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB3YWl0ZXIgPSBhd2FpdGVyKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICByZXN1bHRGbnNbaWRdID0gd2FpdGVyLnJlc29sdmU7XG4gICAgICAgICAgICBTY3JpcHRMb2FkZXIuU2NyaXB0TG9hZGVyLmxvYWRTY3JpcHQodXJsKS50aGVuKCgpID0+IHdhaXRlci5zdGFydChydW5FcnJNc2cpLCAoKSA9PiB3YWl0ZXIucmVqZWN0KGxvYWRFcnJNc2cpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0YXNrc1tpZF0gPSB0YXNrO1xuICAgICAgICAgIHJldHVybiB0YXNrO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgYWRkID0gKGlkLCBkYXRhKSA9PiB7XG4gICAgICAgIGlmIChyZXN1bHRGbnNbaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXN1bHRGbnNbaWRdKGRhdGEpO1xuICAgICAgICAgIGRlbGV0ZSByZXN1bHRGbnNbaWRdO1xuICAgICAgICB9XG4gICAgICAgIHRhc2tzW2lkXSA9IFByb21pc2UucmVzb2x2ZShkYXRhKTtcbiAgICAgIH07XG4gICAgICBjb25zdCB1bmxvYWQgPSBpZCA9PiB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc1tpZF07XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbG9hZCxcbiAgICAgICAgYWRkLFxuICAgICAgICB1bmxvYWRcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBSZXNvdXJjZSA9IGNyZWF0ZSQxKCk7XG5cbiAgICBjb25zdCBjcmVhdGUgPSAoKSA9PiAoKCkgPT4ge1xuICAgICAgbGV0IGRhdGEgPSB7fTtcbiAgICAgIGxldCBrZXlzID0gW107XG4gICAgICBjb25zdCBzdG9yYWdlID0ge1xuICAgICAgICBnZXRJdGVtOiBrZXkgPT4ge1xuICAgICAgICAgIGNvbnN0IGl0ZW0gPSBkYXRhW2tleV07XG4gICAgICAgICAgcmV0dXJuIGl0ZW0gPyBpdGVtIDogbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0SXRlbTogKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICBkYXRhW2tleV0gPSBTdHJpbmcodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBrZXk6IGluZGV4ID0+IHtcbiAgICAgICAgICByZXR1cm4ga2V5c1tpbmRleF07XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUl0ZW06IGtleSA9PiB7XG4gICAgICAgICAga2V5cyA9IGtleXMuZmlsdGVyKGsgPT4gayA9PT0ga2V5KTtcbiAgICAgICAgICBkZWxldGUgZGF0YVtrZXldO1xuICAgICAgICB9LFxuICAgICAgICBjbGVhcjogKCkgPT4ge1xuICAgICAgICAgIGtleXMgPSBbXTtcbiAgICAgICAgICBkYXRhID0ge307XG4gICAgICAgIH0sXG4gICAgICAgIGxlbmd0aDogMFxuICAgICAgfTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdG9yYWdlLCAnbGVuZ3RoJywge1xuICAgICAgICBnZXQ6ICgpID0+IGtleXMubGVuZ3RoLFxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gc3RvcmFnZTtcbiAgICB9KSgpO1xuXG4gICAgbGV0IGxvY2FsU3RvcmFnZTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdGVzdCA9ICdfX3N0b3JhZ2VfdGVzdF9fJztcbiAgICAgIGxvY2FsU3RvcmFnZSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSh0ZXN0LCB0ZXN0KTtcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRlc3QpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvY2FsU3RvcmFnZSA9IGNyZWF0ZSgpO1xuICAgIH1cbiAgICB2YXIgTG9jYWxTdG9yYWdlID0gbG9jYWxTdG9yYWdlO1xuXG4gICAgY29uc3QgcHVibGljQXBpID0ge1xuICAgICAgZ2VvbTogeyBSZWN0IH0sXG4gICAgICB1dGlsOiB7XG4gICAgICAgIERlbGF5LFxuICAgICAgICBUb29scyxcbiAgICAgICAgVkssXG4gICAgICAgIFVSSSxcbiAgICAgICAgRXZlbnREaXNwYXRjaGVyLFxuICAgICAgICBPYnNlcnZhYmxlLFxuICAgICAgICBJMThuLFxuICAgICAgICBMb2NhbFN0b3JhZ2UsXG4gICAgICAgIEltYWdlVXBsb2FkZXJcbiAgICAgIH0sXG4gICAgICBkb206IHtcbiAgICAgICAgRXZlbnRVdGlscyxcbiAgICAgICAgVHJlZVdhbGtlcjogRG9tVHJlZVdhbGtlcixcbiAgICAgICAgVGV4dFNlZWtlcixcbiAgICAgICAgRE9NVXRpbHMsXG4gICAgICAgIFNjcmlwdExvYWRlcixcbiAgICAgICAgUmFuZ2VVdGlscyxcbiAgICAgICAgU2VyaWFsaXplcjogRG9tU2VyaWFsaXplcixcbiAgICAgICAgU3R5bGVTaGVldExvYWRlcixcbiAgICAgICAgQ29udHJvbFNlbGVjdGlvbixcbiAgICAgICAgQm9va21hcmtNYW5hZ2VyLFxuICAgICAgICBTZWxlY3Rpb246IEVkaXRvclNlbGVjdGlvbixcbiAgICAgICAgRXZlbnQ6IEV2ZW50VXRpbHMuRXZlbnRcbiAgICAgIH0sXG4gICAgICBodG1sOiB7XG4gICAgICAgIFN0eWxlcyxcbiAgICAgICAgRW50aXRpZXMsXG4gICAgICAgIE5vZGU6IEFzdE5vZGUsXG4gICAgICAgIFNjaGVtYSxcbiAgICAgICAgRG9tUGFyc2VyLFxuICAgICAgICBXcml0ZXIsXG4gICAgICAgIFNlcmlhbGl6ZXI6IEh0bWxTZXJpYWxpemVyXG4gICAgICB9LFxuICAgICAgRW52LFxuICAgICAgQWRkT25NYW5hZ2VyLFxuICAgICAgQW5ub3RhdG9yLFxuICAgICAgRm9ybWF0dGVyLFxuICAgICAgVW5kb01hbmFnZXIsXG4gICAgICBFZGl0b3JDb21tYW5kcyxcbiAgICAgIFdpbmRvd01hbmFnZXIsXG4gICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLFxuICAgICAgRWRpdG9yT2JzZXJ2YWJsZSxcbiAgICAgIFNob3J0Y3V0cyxcbiAgICAgIEVkaXRvcixcbiAgICAgIEZvY3VzTWFuYWdlcixcbiAgICAgIEVkaXRvck1hbmFnZXIsXG4gICAgICBET006IERPTVV0aWxzLkRPTSxcbiAgICAgIFNjcmlwdExvYWRlcjogU2NyaXB0TG9hZGVyLlNjcmlwdExvYWRlcixcbiAgICAgIFBsdWdpbk1hbmFnZXIsXG4gICAgICBUaGVtZU1hbmFnZXIsXG4gICAgICBNb2RlbE1hbmFnZXIsXG4gICAgICBJY29uTWFuYWdlcixcbiAgICAgIFJlc291cmNlLFxuICAgICAgRmFrZUNsaXBib2FyZCxcbiAgICAgIHRyaW06IFRvb2xzLnRyaW0sXG4gICAgICBpc0FycmF5OiBUb29scy5pc0FycmF5LFxuICAgICAgaXM6IFRvb2xzLmlzLFxuICAgICAgdG9BcnJheTogVG9vbHMudG9BcnJheSxcbiAgICAgIG1ha2VNYXA6IFRvb2xzLm1ha2VNYXAsXG4gICAgICBlYWNoOiBUb29scy5lYWNoLFxuICAgICAgbWFwOiBUb29scy5tYXAsXG4gICAgICBncmVwOiBUb29scy5ncmVwLFxuICAgICAgaW5BcnJheTogVG9vbHMuaW5BcnJheSxcbiAgICAgIGV4dGVuZDogVG9vbHMuZXh0ZW5kLFxuICAgICAgd2FsazogVG9vbHMud2FsayxcbiAgICAgIHJlc29sdmU6IFRvb2xzLnJlc29sdmUsXG4gICAgICBleHBsb2RlOiBUb29scy5leHBsb2RlLFxuICAgICAgX2FkZENhY2hlU3VmZml4OiBUb29scy5fYWRkQ2FjaGVTdWZmaXhcbiAgICB9O1xuICAgIGNvbnN0IHRpbnltY2UgPSBUb29scy5leHRlbmQoRWRpdG9yTWFuYWdlciwgcHVibGljQXBpKTtcblxuICAgIGNvbnN0IGV4cG9ydFRvTW9kdWxlTG9hZGVycyA9IHRpbnltY2UgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSB0aW55bWNlO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGV4cG9ydFRvV2luZG93R2xvYmFsID0gdGlueW1jZSA9PiB7XG4gICAgICB3aW5kb3cudGlueW1jZSA9IHRpbnltY2U7XG4gICAgICB3aW5kb3cudGlueU1DRSA9IHRpbnltY2U7XG4gICAgfTtcbiAgICBleHBvcnRUb1dpbmRvd0dsb2JhbCh0aW55bWNlKTtcbiAgICBleHBvcnRUb01vZHVsZUxvYWRlcnModGlueW1jZSk7XG5cbn0pKCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=